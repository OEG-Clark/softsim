{"home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust.parse_args": [[15, 29], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "os.path.realpath", "os.path.realpath", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "''", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--results-dir'", ",", "\n", "default", "=", "os", ".", "path", ".", "realpath", "(", "os", ".", "path", ".", "join", "(", "dir_path", ",", "\"..\"", ",", "\"results\"", ")", ")", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--out-dir'", ",", "\n", "default", "=", "os", ".", "path", ".", "realpath", "(", "os", ".", "path", ".", "join", "(", "dir_path", ",", "\"..\"", ",", "\"plot-results\"", ")", ")", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--dataset'", ",", "\n", "default", "=", "\"all\"", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust.gen_plots": [[32, 66], ["os.path.join", "os.makedirs", "seaborn.catplot", "matplotlib.pyplot.axhline", "sns.catplot.set", "sns.catplot.ax.legend", "os.path.join", "sns.catplot.savefig", "options[].replace().title", "options[].replace"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["", "def", "gen_plots", "(", "data", ",", "options", ")", ":", "\n", "\n", "# linear plots", "\n", "    ", "lin_dir", "=", "os", ".", "path", ".", "join", "(", "options", "[", "'out_dir'", "]", ",", "'basetrain_robustness'", ")", "\n", "os", ".", "makedirs", "(", "lin_dir", ",", "exist_ok", "=", "True", ")", "\n", "linear_data", "=", "data", "[", "data", ".", "result_type", "==", "'linear-eval'", "]", "\n", "linear_data", "=", "linear_data", "[", "linear_data", ".", "variant", "==", "\"linear-eval-lr\"", "]", "\n", "\n", "#since catplot is a figure level function, it produces a new, separate plot which doesn't follow style of past graphs", "\n", "fig", "=", "sns", ".", "catplot", "(", "x", "=", "'basetrain'", ",", "y", "=", "'result'", ",", "hue", "=", "'basetrain_robust'", ",", "data", "=", "linear_data", ",", "kind", "=", "\"point\"", ",", "s", "=", "10", ",", "\n", "linestyle", "=", "\"-\"", ",", "legend_out", "=", "False", ",", "order", "=", "[", "\"MoCo 20-epochs\"", ",", "\"MoCo 200-epochs\"", ",", "\"MoCo 800-epochs\"", "]", ",", "aspect", "=", "11.7", "/", "8.27", ")", "\n", "plt", ".", "axhline", "(", "y", "=", "options", "[", "'asymptote'", "]", ",", "c", "=", "'red'", ",", "linestyle", "=", "'dashed'", ",", "label", "=", "\"Best MoCo Random Init\"", ")", "\n", "\n", "#sets axis labels and title of graph", "\n", "y_axis", "=", "\"Accuracy\"", "\n", "if", "options", "[", "'dataset_type'", "]", "==", "'chexpert'", ":", "\n", "        ", "y_axis", "=", "\"AUROC\"", "\n", "\n", "", "fig", ".", "set", "(", "xlabel", "=", "'Pretrained Model'", ",", "ylabel", "=", "y_axis", ",", "title", "=", "options", "[", "'data_name'", "]", ".", "replace", "(", "\"_\"", ",", "\" \"", ")", ".", "title", "(", ")", ")", "\n", "\n", "#sets legend", "\n", "fig", ".", "ax", ".", "legend", "(", "loc", "=", "4", ",", "title", "=", "\"Pre-training\"", ",", "fontsize", "=", "\"x-small\"", ")", "\n", "# handles, _ = fig.ax.get_legend_handles_labels()", "\n", "# fig.ax.legend(handles = handles[1:],labels=labels,title=\"Basetrain\")", "\n", "# plt.show()", "\n", "\n", "#gets rid of other graph created ", "\n", "# plt.close(1) ", "\n", "\n", "#creates output file", "\n", "outplot", "=", "os", ".", "path", ".", "join", "(", "lin_dir", ",", "'{}.pdf'", ".", "format", "(", "options", "[", "'data_name'", "]", ")", ")", "\n", "\n", "#saves Figure 1, but Figure 1 is the empty graph created (NOT SNS Graph)", "\n", "fig", ".", "savefig", "(", "outplot", ",", "format", "=", "'pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust.reduce": [[68, 74], ["data.iterrows"], "function", ["None"], ["", "def", "reduce", "(", "data", ")", ":", "\n", "    ", "best", "=", "0", "\n", "for", "i", ",", "row", "in", "data", ".", "iterrows", "(", ")", ":", "\n", "        ", "if", "best", "<", "row", "[", "'result'", "]", ":", "\n", "            ", "best", "=", "row", "[", "'result'", "]", "\n", "", "", "return", "best", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust.main": [[75, 196], ["os.makedirs", "seaborn.set_style", "seaborn.set", "glob.glob", "glob.glob", "glob.glob.append", "pandas.concat", "print", "print", "print", "print", "pd.concat.iterrows", "print", "result[].sort_values().head", "result[].sort_values().head", "pandas.concat", "print", "print", "plot_basetrain_robust.gen_plots", "os.path.join", "os.path.join", "os.path.join", "print", "pandas.DataFrame", "pd.concat.astype", "pd.concat.basetrain.replace", "pd.concat.basetrain.replace", "pd.concat.basetrain.replace", "pd.concat.basetrain.replace", "pd.concat.basetrain.replace", "frames.append", "len", "open", "json.load", "json.load.values", "data_moco_x.sort_values().head.sort_values().head", "data_moco_y.sort_values().head.sort_values().head", "pandas.concat", "plot_basetrain_robust.reduce", "types.append", "pandas.concat", "result[].sort_values", "result[].sort_values", "data_moco_x.sort_values().head.sort_values", "data_moco_y.sort_values().head.sort_values"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.gen_plots", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.reduce"], ["", "def", "main", "(", "args", ")", ":", "\n", "\n", "#must pass in dataset arg for proper results", "\n", "\n", "    ", "os", ".", "makedirs", "(", "args", ".", "out_dir", ",", "exist_ok", "=", "True", ")", "\n", "# setup plots", "\n", "sns", ".", "set_style", "(", "'darkgrid'", ")", "\n", "sns", ".", "set", "(", ")", "\n", "\n", "frames", "=", "[", "]", "#array that collects dataframes from each file", "\n", "if", "(", "args", ".", "dataset", "==", "\"all\"", ")", ":", "\n", "        ", "dataset_type", "=", "\"*\"", "\n", "", "else", ":", "\n", "        ", "dataset_type", "=", "args", ".", "dataset", "\n", "\n", "", "nobt_baseline", "=", "0", "\n", "\n", "#gets all the basetrain results from the specified dataset", "\n", "result_files", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "dataset_type", "+", "\"*basetrain*.json\"", ")", ",", "recursive", "=", "True", ")", "\n", "result_files2", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "dataset_type", "+", "\"*bt_robust*.json\"", ")", ",", "recursive", "=", "True", ")", "\n", "result_files", "+=", "result_files2", "\n", "result_files", ".", "append", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "dataset_type", "+", "\"_results.json\"", ")", ")", "#gets file with basetrian results", "\n", "\n", "for", "resfile", "in", "result_files", ":", "\n", "        ", "with", "open", "(", "resfile", ",", "'r'", ")", "as", "infile", ":", "\n", "            ", "raw_data", "=", "json", ".", "load", "(", "infile", ")", "\n", "\n", "", "print", "(", "resfile", ")", "\n", "\n", "types", "=", "[", "]", "#used for concatenating the resultzs from each basetrained model", "\n", "data", "=", "pd", ".", "DataFrame", "(", "raw_data", ".", "values", "(", ")", ")", "\n", "\n", "\n", "#finds the relevant values for moco bt no bt", "\n", "#mainly done to work around the baseline json file (has extra info that we don't want)", "\n", "if", "(", "dataset_type", "+", "\"_results.json\"", ")", "in", "resfile", ":", "\n", "            ", "linear_data", "=", "data", "[", "data", ".", "result_type", "==", "'linear-eval'", "]", "\n", "linear_data", "=", "linear_data", "[", "linear_data", ".", "variant", "==", "\"linear-eval-lr\"", "]", "\n", "\n", "data_moco", "=", "linear_data", "[", "data", ".", "basetrain", "==", "\"moco_v2_800ep\"", "]", "\n", "data_moco", "=", "data_moco", "[", "data_moco", ".", "pretrain_data", "==", "dataset_type", "]", "\n", "data_moco_x", "=", "data_moco", "[", "(", "data_moco", "[", "'pretrain_iters'", "]", "==", "\"5000\"", ")", "]", "\n", "data_moco_y", "=", "data_moco", "[", "(", "data_moco", "[", "'pretrain_iters'", "]", "==", "\"0\"", ")", "]", "\n", "data_moco_x", "=", "data_moco_x", ".", "sort_values", "(", "by", "=", "[", "'result'", "]", ",", "ascending", "=", "False", ")", ".", "head", "(", "1", ")", "\n", "data_moco_y", "=", "data_moco_y", ".", "sort_values", "(", "by", "=", "[", "'result'", "]", ",", "ascending", "=", "False", ")", ".", "head", "(", "1", ")", "\n", "data_moco", "=", "pd", ".", "concat", "(", "[", "data_moco_x", ",", "data_moco_y", "]", ",", "ignore_index", "=", "True", ")", "\n", "\n", "#just for asympotote", "\n", "data_nobt", "=", "linear_data", "[", "data", ".", "basetrain", "==", "\"no\"", "]", "\n", "data_nobt", "=", "data_nobt", "[", "data_nobt", ".", "pretrain_data", "==", "dataset_type", "]", "\n", "nobt_baseline", "=", "reduce", "(", "data_nobt", ")", "\n", "\n", "\n", "#appended to list ", "\n", "types", ".", "append", "(", "data_moco", ")", "\n", "\n", "#all concat to new dataframe ", "\n", "data", "=", "pd", ".", "concat", "(", "types", ",", "ignore_index", "=", "True", ")", "\n", "\n", "#get baseline and update results", "\n", "\n", "", "data", "=", "data", ".", "astype", "(", "{", "\n", "\"pretrain_iters\"", ":", "int", "\n", "}", ")", "\n", "if", "not", "(", "data", ".", "result", ">", "1", ")", ".", "all", "(", ")", ":", "\n", "            ", "data", ".", "result", "*=", "100", "\n", "\n", "", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"moco_v2_800ep\"", ",", "\"MoCo 800-epochs\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"moco_v2_200ep_pretrain\"", ",", "\"MoCo 200-epochs\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"moco_v2_20ep_pretrain\"", ",", "\"MoCo 20-epochs\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"no\"", ",", "\"random init\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"none\"", ",", "\"random init\"", ")", "\n", "frames", ".", "append", "(", "data", ")", "\n", "\n", "#combines all the dataframes from each file into 1 large dataframe", "\n", "", "result", "=", "pd", ".", "concat", "(", "frames", ",", "ignore_index", "=", "True", ")", "\n", "dataname", "=", "dataset_type", "+", "\"_basetrain_robustness\"", "\n", "asymptote", "=", "nobt_baseline", "\n", "if", "asymptote", "<", "1", ":", "\n", "        ", "asymptote", "*=", "100", "\n", "", "print", "(", "result", ")", "\n", "print", "(", "result", ".", "result", ")", "\n", "print", "(", "asymptote", ")", "\n", "\n", "basetrain_robust", "=", "[", "\"a\"", "]", "*", "len", "(", "result", ")", "\n", "result", "[", "\"basetrain_robust\"", "]", "=", "basetrain_robust", "\n", "\n", "print", "(", "result", ".", "pretrain_iters", ")", "\n", "for", "i", ",", "row", "in", "result", ".", "iterrows", "(", ")", ":", "\n", "        ", "name", "=", "\"\"", "\n", "if", "row", "[", "'pretrain_iters'", "]", "==", "0", ":", "\n", "            ", "name", "=", "\"MoCo Direct Transfer\"", "\n", "", "else", ":", "\n", "            ", "name", "=", "\"HPT\"", "\n", "\n", "", "result", ".", "at", "[", "i", ",", "\"basetrain_robust\"", "]", "=", "name", "\n", "", "print", "(", "result", ")", "\n", "\n", "#only ran extra experiments for moco_20", "\n", "#take only the best result (50k iterations)", "\n", "result_20_m", "=", "result", "[", "(", "result", "[", "'basetrain'", "]", "==", "\"MoCo 20-epochs\"", ")", "&", "(", "result", "[", "'basetrain_robust'", "]", "==", "\"HPT\"", ")", "]", ".", "sort_values", "(", "by", "=", "[", "'result'", "]", ",", "ascending", "=", "False", ")", ".", "head", "(", "1", ")", "\n", "\n", "result_20_o", "=", "result", "[", "(", "result", "[", "'basetrain'", "]", "==", "\"MoCo 20-epochs\"", ")", "&", "(", "result", "[", "'basetrain_robust'", "]", "==", "\"MoCo Direct Transfer\"", ")", "]", ".", "sort_values", "(", "by", "=", "[", "'result'", "]", ",", "ascending", "=", "False", ")", ".", "head", "(", "1", ")", "\n", "\n", "result_other", "=", "result", "[", "(", "(", "result", "[", "'basetrain'", "]", "!=", "\"MoCo 20-epochs\"", ")", "|", "(", "result", "[", "'basetrain_robust'", "]", "==", "\"MoCo Direct Transfer\"", ")", ")", "&", "(", "(", "result", "[", "'basetrain'", "]", "!=", "\"MoCo 20-epochs\"", ")", "|", "(", "result", "[", "'basetrain_robust'", "]", "!=", "\"MoCo Direct Transfer\"", ")", ")", "]", "\n", "result", "=", "pd", ".", "concat", "(", "[", "result_20_m", ",", "result_20_o", ",", "result_other", "]", ",", "ignore_index", "=", "True", ")", "\n", "\n", "\n", "#changes all the dataset names to dataset_augmentation", "\n", "\n", "result", ".", "dataset", "=", "dataset_type", "\n", "\n", "#prints new concatenated dataframe ", "\n", "print", "(", "result", ")", "\n", "print", "(", "result", ".", "result", ")", "\n", "\n", "gen_plots", "(", "result", ",", "{", "\n", "'out_dir'", ":", "args", ".", "out_dir", ",", "\n", "'data_name'", ":", "dataname", ",", "\n", "'asymptote'", ":", "asymptote", ",", "\n", "'dataset_type'", ":", "dataset_type", "\n", "}", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_augmentation_modified.parse_args": [[15, 32], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "os.path.realpath", "os.path.realpath", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "''", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--results-dir'", ",", "\n", "default", "=", "os", ".", "path", ".", "realpath", "(", "os", ".", "path", ".", "join", "(", "dir_path", ",", "\"results_modified\"", ")", ")", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--out-dir'", ",", "\n", "default", "=", "os", ".", "path", ".", "realpath", "(", "os", ".", "path", ".", "join", "(", "dir_path", ",", "\"plot-results\"", ")", ")", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--dataset'", ",", "\n", "default", "=", "\"all\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--basetrain'", ",", "\n", "default", "=", "\"\"", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_augmentation_modified.gen_plots": [[34, 84], ["os.path.join", "os.makedirs", "matplotlib.style.use", "seaborn.catplot", "sns.catplot.set", "sns.catplot.ax.legend", "matplotlib.pyplot.close", "os.path.join", "sns.catplot.savefig", "ax.set_title", "ax.set_xlabel", "ax.set_xticklabels", "ax.set_yticklabels", "ax.spines[].set_color", "ax.spines[].set_color", "ax.spines[].set_color", "ax.spines[].set_color", "ax.patch.set_facecolor", "ax.grid", "options[].replace().title", "options[].replace().title", "ax.set_ylabel", "ax.set_ylabel", "item.get_text", "ax.get_yticklabels", "options[].replace", "options[].replace"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.TensorboardXWriter.close"], ["", "def", "gen_plots", "(", "data", ",", "options", ")", ":", "\n", "\n", "# linear plots", "\n", "    ", "lin_dir", "=", "os", ".", "path", ".", "join", "(", "options", "[", "'out_dir'", "]", ",", "'aug_robust_no_supervised'", ")", "\n", "os", ".", "makedirs", "(", "lin_dir", ",", "exist_ok", "=", "True", ")", "\n", "linear_data", "=", "data", "[", "data", ".", "result_type", "==", "'linear-eval'", "]", "\n", "linear_data", "=", "linear_data", "[", "linear_data", ".", "variant", "==", "\"linear-eval-lr\"", "]", "\n", "mpl", ".", "style", ".", "use", "(", "'default'", ")", "\n", "#since catplot is a figure level function, it produces a new, separate plot which doesn't follow style of past graphs", "\n", "#     with sns.axes_style(\"white\"):", "\n", "fig", "=", "sns", ".", "catplot", "(", "x", "=", "'aug_type'", ",", "y", "=", "'result'", ",", "hue", "=", "'basetrain'", ",", "data", "=", "linear_data", ",", "kind", "=", "\"point\"", ",", "s", "=", "10", ",", "\n", "linestyle", "=", "\"-\"", ",", "legend_out", "=", "False", ",", "order", "=", "[", "\"Baseline\"", ",", "\"Remove\\ngrayscale\"", ",", "\"Remove\\ncolor\"", ",", "\"Crop + blur\\nonly\"", ",", "\"Crop\\nonly\"", "]", ")", "\n", "\n", "#sets axis labels and title of graph", "\n", "fig", ".", "set", "(", "xlabel", "=", "'Augmentation Sets'", ",", "ylabel", "=", "'Change of Accuracy from Baseline'", ",", "title", "=", "options", "[", "'data_name'", "]", ".", "replace", "(", "\"_\"", ",", "\" \"", ")", ".", "title", "(", ")", ")", "\n", "# fig._legend.set_title(\"Basetrain\")", "\n", "fig", ".", "ax", ".", "legend", "(", "title", "=", "\"Basetrain\"", ",", "fontsize", "=", "\"large\"", ",", "title_fontsize", "=", "'large'", ")", "\n", "for", "ax", "in", "fig", ".", "axes", ".", "flat", ":", "\n", "        ", "ax", ".", "set_title", "(", "options", "[", "'data_name'", "]", ".", "replace", "(", "\"_\"", ",", "\" \"", ")", ".", "title", "(", ")", ",", "fontsize", "=", "20", ")", "\n", "ax", ".", "set_xlabel", "(", "\"Augmentation Sets\"", ",", "fontsize", "=", "18", ")", "\n", "\n", "if", "'chexpert'", "in", "options", "[", "'data_name'", "]", ":", "\n", "            ", "ax", ".", "set_ylabel", "(", "\"AUROC Change\"", ",", "fontsize", "=", "18", ")", "\n", "", "else", ":", "\n", "            ", "ax", ".", "set_ylabel", "(", "\"Accuracy Change\"", ",", "fontsize", "=", "18", ")", "\n", "", "xticks", "=", "[", "\"Baseline\"", ",", "\"Remove\\ngrayscale\"", ",", "\"Remove\\ncolor\"", ",", "\"Crop+Blur\\nonly\"", ",", "\"Crop\\nonly\"", "]", "\n", "ax", ".", "set_xticklabels", "(", "xticks", ",", "rotation", "=", "0", ",", "fontsize", "=", "12", ")", "\n", "\n", "yticks", "=", "[", "item", ".", "get_text", "(", ")", "for", "item", "in", "ax", ".", "get_yticklabels", "(", ")", "]", "\n", "ax", ".", "set_yticklabels", "(", "yticks", ",", "rotation", "=", "0", ",", "fontsize", "=", "17", ")", "\n", "# ax.tick_params(axis='y', labelsize='large')", "\n", "\n", "ax", ".", "spines", "[", "'bottom'", "]", ".", "set_color", "(", "'1'", ")", "\n", "ax", ".", "spines", "[", "'top'", "]", ".", "set_color", "(", "'1'", ")", "\n", "ax", ".", "spines", "[", "'right'", "]", ".", "set_color", "(", "'1'", ")", "\n", "ax", ".", "spines", "[", "'left'", "]", ".", "set_color", "(", "'1'", ")", "\n", "ax", ".", "patch", ".", "set_facecolor", "(", "'0.97'", ")", "\n", "ax", ".", "grid", "(", "axis", "=", "'y'", ",", "color", "=", "'grey'", ",", "dashes", "=", "[", "10", ",", "4", "]", ")", "\n", "\n", "#         print(ax.spines)", "\n", "\n", "#         ax.legend(fontsize=8)", "\n", "#gets rid of other graph created ", "\n", "", "plt", ".", "close", "(", "1", ")", "\n", "\n", "#creates output file", "\n", "outplot", "=", "os", ".", "path", ".", "join", "(", "lin_dir", ",", "'{}_{}.pdf'", ".", "format", "(", "options", "[", "'data_name'", "]", "+", "\"_augmentation\"", ",", "\"no_supervised\"", ")", ")", "\n", "\n", "#saves Figure 1, but Figure 1 is the empty graph created (NOT SNS Graph)", "\n", "fig", ".", "savefig", "(", "outplot", ",", "format", "=", "'pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_augmentation_modified.set_size": [[85, 116], ["None"], "function", ["None"], ["", "def", "set_size", "(", "width", ",", "fraction", "=", "1", ")", ":", "\n", "    ", "\"\"\" Set figure dimensions to avoid scaling in LaTeX.\n    Parameters\n    ----------\n    width: float\n            Document textwidth or columnwidth in pts\n    fraction: float, optional\n            Fraction of the width which you wish the figure to occupy\n    Returns\n    -------\n    fig_dim: tuple\n            Dimensions of figure in inches\n    \"\"\"", "\n", "# Width of figure (in pts)", "\n", "fig_width_pt", "=", "width", "*", "fraction", "\n", "\n", "# Convert from pt to inches", "\n", "inches_per_pt", "=", "1", "/", "72.27", "\n", "\n", "# Golden ratio to set aesthetic figure height", "\n", "# https://disq.us/p/2940ij3", "\n", "golden_ratio", "=", "(", "5", "**", ".5", "-", "1", ")", "/", "2", "\n", "\n", "# Figure width in inches", "\n", "fig_width_in", "=", "fig_width_pt", "*", "inches_per_pt", "\n", "# Figure height in inches", "\n", "fig_height_in", "=", "fig_width_in", "*", "golden_ratio", "\n", "\n", "fig_dim", "=", "(", "fig_width_in", ",", "fig_height_in", ")", "\n", "\n", "return", "fig_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_augmentation_modified.setup_plot": [[117, 119], ["matplotlib.pyplot.subplots", "plot_augmentation_modified.set_size"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain.set_size"], ["", "def", "setup_plot", "(", "width", "=", "300", ")", ":", "\n", "    ", "return", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "set_size", "(", "width", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_augmentation_modified.reduce": [[120, 130], ["data[].tolist", "float", "float"], "function", ["None"], ["", "def", "reduce", "(", "data", ")", ":", "\n", "    ", "result", "=", "data", "[", "'result'", "]", ".", "tolist", "(", ")", "\n", "\n", "best", "=", "0", "\n", "for", "value", "in", "result", ":", "\n", "        ", "if", "best", "<", "float", "(", "value", ")", ":", "\n", "            ", "best", "=", "float", "(", "value", ")", "\n", "\n", "", "", "data", ".", "result", "=", "best", "\n", "return", "data", ",", "best", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_augmentation_modified.main": [[131, 273], ["os.makedirs", "seaborn.set_style", "seaborn.set", "glob.glob", "glob.glob", "glob.glob", "result_files.append", "pandas.concat", "print", "print", "print", "print", "plot_augmentation_modified.gen_plots", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "print", "pandas.DataFrame", "len", "pd.concat.astype", "pd.concat.basetrain.replace", "pd.concat.basetrain.replace", "pd.concat.basetrain.replace", "pd.concat.basetrain.replace", "frames.append", "print", "print", "pandas.concat", "pandas.concat", "open", "json.load", "json.load.values", "plot_augmentation_modified.reduce", "plot_augmentation_modified.reduce", "types.append", "types.append", "pandas.concat", "plot_augmentation_modified.reduce", "types.append"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.gen_plots", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.reduce", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.reduce", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.reduce"], ["", "def", "main", "(", "args", ")", ":", "\n", "\n", "#must pass in dataset arg for proper results", "\n", "\n", "    ", "os", ".", "makedirs", "(", "args", ".", "out_dir", ",", "exist_ok", "=", "True", ")", "\n", "# setup plots", "\n", "sns", ".", "set_style", "(", "'darkgrid'", ")", "\n", "sns", ".", "set", "(", ")", "\n", "\n", "frames", "=", "[", "]", "#array that collects dataframes from each file", "\n", "if", "(", "args", ".", "dataset", "==", "\"all\"", ")", ":", "\n", "        ", "dataset_type", "=", "\"*\"", "\n", "", "else", ":", "\n", "        ", "dataset_type", "=", "args", ".", "dataset", "\n", "\n", "#gets all files that start with \"resisc_\" (still need a file with the baseline results)", "\n", "# result_files = glob.glob(os.path.join(args.results_dir, dataset_type + \"*.json\"), recursive=True)", "\n", "", "result_files1", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "dataset_type", "+", "\"*crop*.json\"", ")", ",", "recursive", "=", "True", ")", "\n", "result_files2", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "dataset_type", "+", "\"*color*.json\"", ")", ",", "recursive", "=", "True", ")", "\n", "result_files3", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "dataset_type", "+", "\"*gray*.json\"", ")", ",", "recursive", "=", "True", ")", "\n", "result_files", "=", "result_files1", "+", "result_files2", "+", "result_files3", "\n", "result_files", ".", "append", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "dataset_type", "+", "\"_results.json\"", ")", ")", "\n", "\n", "moco_baseline", "=", "imagenet_baseline", "=", "nobt_baseline", "=", "0", "\n", "\n", "for", "resfile", "in", "result_files", ":", "\n", "        ", "with", "open", "(", "resfile", ",", "'r'", ")", "as", "infile", ":", "\n", "            ", "raw_data", "=", "json", ".", "load", "(", "infile", ")", "\n", "\n", "", "print", "(", "resfile", ")", "\n", "\n", "types", "=", "[", "]", "#used for concatenating the resultzs from each basetrained model", "\n", "data", "=", "pd", ".", "DataFrame", "(", "raw_data", ".", "values", "(", ")", ")", "\n", "\n", "\n", "#finds the relevant values for moco bt, imagenet supervised bt, and no bt", "\n", "#mainly done to work around the baseline json file (has extra info that we don't want)", "\n", "if", "(", "dataset_type", "+", "\"_results.json\"", ")", "in", "resfile", ":", "\n", "            ", "linear_data", "=", "data", "[", "data", ".", "result_type", "==", "'linear-eval'", "]", "\n", "linear_data", "=", "linear_data", "[", "linear_data", ".", "variant", "==", "\"linear-eval-lr\"", "]", "\n", "\n", "data_moco", "=", "linear_data", "[", "data", ".", "basetrain", "==", "\"moco_v2_800ep\"", "]", "\n", "data_moco", "=", "data_moco", "[", "data_moco", ".", "pretrain_iters", "==", "\"5000\"", "]", "\n", "data_moco", "=", "data_moco", "[", "data_moco", ".", "pretrain_data", "==", "dataset_type", "]", "\n", "data_moco", ",", "moco_baseline", "=", "reduce", "(", "data_moco", ")", "\n", "\n", "if", "args", ".", "basetrain", "==", "'supervised'", ":", "\n", "                ", "data_imagenet", "=", "linear_data", "[", "data", ".", "basetrain", "==", "\"imagenet_r50_supervised\"", "]", "\n", "data_imagenet", "=", "data_imagenet", "[", "data_imagenet", ".", "pretrain_iters", "==", "\"50000\"", "]", "\n", "data_imagenet", "=", "data_imagenet", "[", "data_imagenet", ".", "pretrain_data", "==", "dataset_type", "]", "\n", "data_imagenet", ",", "imagenet_baseline", "=", "reduce", "(", "data_imagenet", ")", "\n", "types", ".", "append", "(", "data_imagenet", ")", "\n", "\n", "", "data_nobt", "=", "linear_data", "[", "data", ".", "basetrain", "==", "\"no\"", "]", "\n", "data_nobt", "=", "data_nobt", "[", "data_nobt", ".", "pretrain_iters", "==", "\"100000\"", "]", "\n", "data_nobt", "=", "data_nobt", "[", "data_nobt", ".", "pretrain_data", "==", "dataset_type", "]", "\n", "data_nobt", ",", "nobt_baseline", "=", "reduce", "(", "data_nobt", ")", "\n", "\n", "\n", "#appended to list ", "\n", "types", ".", "append", "(", "data_moco", ")", "\n", "types", ".", "append", "(", "data_nobt", ")", "\n", "\n", "#all concat to new dataframe ", "\n", "data", "=", "pd", ".", "concat", "(", "types", ",", "ignore_index", "=", "True", ")", "\n", "\n", "#used to add new column called aug_type", "\n", "", "aug_type", "=", "[", "]", "\n", "num_rows", "=", "len", "(", "data", ")", "\n", "\n", "#adds an aug-type column, which is used for catplot in gen_plot", "\n", "if", "\"crop_only\"", "in", "resfile", ":", "\n", "            ", "aug_type", "=", "[", "\"Crop\\nonly\"", "]", "*", "num_rows", "\n", "", "elif", "\"crop_blur\"", "in", "resfile", ":", "\n", "            ", "aug_type", "=", "[", "\"Crop + blur\\nonly\"", "]", "*", "num_rows", "\n", "", "elif", "\"rm_gray\"", "in", "resfile", ":", "\n", "            ", "aug_type", "=", "[", "\"Remove\\ngrayscale\"", "]", "*", "num_rows", "\n", "", "elif", "\"rm_color\"", "in", "resfile", ":", "\n", "            ", "aug_type", "=", "[", "\"Remove\\ncolor\"", "]", "*", "num_rows", "\n", "", "else", ":", "\n", "            ", "aug_type", "=", "[", "\"Baseline\"", "]", "*", "num_rows", "\n", "\n", "", "data", "[", "\"aug_type\"", "]", "=", "aug_type", "\n", "\n", "\n", "#get baseline and update results", "\n", "\n", "data", "=", "data", ".", "astype", "(", "{", "\n", "\"pretrain_iters\"", ":", "int", "\n", "}", ")", "\n", "\n", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"imagenet_r50_supervised\"", ",", "\"supervised imagenet init\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"moco_v2_800ep\"", ",", "\"HPT\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"no\"", ",", "\"MoCo Random Init\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"none\"", ",", "\"MoCo Random Init\"", ")", "\n", "frames", ".", "append", "(", "data", ")", "\n", "\n", "#combines all the dataframes from each file into 1 large dataframe", "\n", "", "result", "=", "pd", ".", "concat", "(", "frames", ",", "ignore_index", "=", "True", ")", "\n", "\n", "\n", "#changes all the dataset names to dataset_augmentation", "\n", "result", ".", "dataset", "=", "dataset_type", "# + \"_augmentation\"", "\n", "\n", "#prints new concatenated dataframe ", "\n", "print", "(", "result", ")", "\n", "print", "(", "not", "(", "result", ".", "result", ">", "1", ")", ".", "all", "(", ")", ")", "\n", "\n", "mult100", "=", "False", "\n", "if", "not", "(", "result", ".", "result", ">", "1", ")", ".", "all", "(", ")", ":", "\n", "        ", "mult100", "=", "True", "\n", "\n", "", "if", "args", ".", "basetrain", "==", "'supervised'", ":", "\n", "        ", "print", "(", "moco_baseline", ",", "imagenet_baseline", ",", "nobt_baseline", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "moco_baseline", ",", "nobt_baseline", ")", "\n", "\n", "\n", "\n", "", "result_moco", "=", "result", "[", "result", ".", "basetrain", "==", "\"HPT\"", "]", "\n", "result_moco", ".", "result", "=", "result_moco", ".", "result", "-", "moco_baseline", "\n", "\n", "result_nobt", "=", "result", "[", "result", ".", "basetrain", "==", "\"MoCo Random Init\"", "]", "\n", "result_nobt", ".", "result", "=", "result_nobt", ".", "result", "-", "nobt_baseline", "\n", "\n", "if", "args", ".", "basetrain", "==", "'supervised'", ":", "\n", "        ", "result_imagenet", "=", "result", "[", "result", ".", "basetrain", "==", "\"supervised imagenet init\"", "]", "\n", "result_imagenet", ".", "result", "=", "result_imagenet", ".", "result", "-", "imagenet_baseline", "\n", "result", "=", "pd", ".", "concat", "(", "[", "result_moco", ",", "result_imagenet", ",", "result_nobt", "]", ",", "ignore_index", "=", "True", ")", "\n", "", "else", ":", "\n", "        ", "result", "=", "pd", ".", "concat", "(", "[", "result_moco", ",", "result_nobt", "]", ",", "ignore_index", "=", "True", ")", "\n", "", "dataname", "=", "result", ".", "dataset", "[", "0", "]", "\n", "\n", "if", "mult100", ":", "\n", "        ", "result", ".", "result", "*=", "100", "\n", "", "print", "(", "result", ".", "result", ")", "\n", "print", "(", "result", ")", "\n", "\n", "gen_plots", "(", "result", ",", "{", "\n", "'out_dir'", ":", "args", ".", "out_dir", ",", "\n", "'data_name'", ":", "dataname", ",", "\n", "}", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot-results-aug-resisc.parse_args": [[15, 29], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "os.path.realpath", "os.path.realpath", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "''", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--results-dir'", ",", "\n", "default", "=", "os", ".", "path", ".", "realpath", "(", "os", ".", "path", ".", "join", "(", "dir_path", ",", "\"..\"", ",", "\"results\"", ")", ")", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--out-dir'", ",", "\n", "default", "=", "os", ".", "path", ".", "realpath", "(", "os", ".", "path", ".", "join", "(", "dir_path", ",", "\"..\"", ",", "\"plot-results\"", ")", ")", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--dataset'", ",", "\n", "default", "=", "\"all\"", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot-results-aug-resisc.gen_plots": [[31, 55], ["os.path.join", "os.makedirs", "print", "seaborn.catplot", "matplotlib.pyplot.close", "matplotlib.pyplot.xlabel", "matplotlib.pyplot.ylabel", "matplotlib.pyplot.title", "os.path.join", "sns.catplot.savefig", "options[].replace().title", "options[].replace"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.TensorboardXWriter.close"], ["", "def", "gen_plots", "(", "data", ",", "options", ")", ":", "\n", "\n", "# linear plots", "\n", "    ", "lin_dir", "=", "os", ".", "path", ".", "join", "(", "options", "[", "'out_dir'", "]", ",", "'augmentation_robustness'", ")", "\n", "os", ".", "makedirs", "(", "lin_dir", ",", "exist_ok", "=", "True", ")", "\n", "linear_data", "=", "data", "[", "data", ".", "result_type", "==", "'linear-eval'", "]", "\n", "print", "(", "linear_data", ")", "\n", "\n", "#since catplot is a figure level function, it produces a new, separate plot which doesn't follow style of past graphs", "\n", "fig", "=", "sns", ".", "catplot", "(", "x", "=", "'aug_type'", ",", "y", "=", "'result'", ",", "hue", "=", "'basetrain'", ",", "data", "=", "linear_data", ",", "kind", "=", "\"point\"", ",", "linestyle", "=", "\"-\"", ",", "ci", "=", "None", ")", "\n", "plt", ".", "close", "(", "1", ")", "\n", "plt", ".", "xlabel", "(", "\"Augmentation Sets\"", ")", "\n", "plt", ".", "ylabel", "(", "\"Accuracy\"", ")", "\n", "plt", ".", "title", "(", "options", "[", "'data_name'", "]", ".", "replace", "(", "\"_\"", ",", "\" \"", ")", ".", "title", "(", ")", ")", "\n", "\n", "#when you run the program, it shows 2 graphs (sns graph and empty graph)", "\n", "#Figure 1 is the empty graph; Figure 2 is the sns graph", "\n", "# plt.show()", "\n", "\n", "#creates output file", "\n", "outplot", "=", "os", ".", "path", ".", "join", "(", "lin_dir", ",", "'{}.pdf'", ".", "format", "(", "options", "[", "'data_name'", "]", ")", ")", "\n", "\n", "#saves Figure 1, but Figure 1 is the empty graph created (NOT SNS Graph)", "\n", "fig", ".", "savefig", "(", "outplot", ",", "format", "=", "'pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot-results-aug-resisc.set_size": [[60, 93], ["None"], "function", ["None"], ["", "def", "set_size", "(", "width", ",", "fraction", "=", "1", ")", ":", "\n", "    ", "\"\"\" Set figure dimensions to avoid scaling in LaTeX.\n\n    Parameters\n    ----------\n    width: float\n            Document textwidth or columnwidth in pts\n    fraction: float, optional\n            Fraction of the width which you wish the figure to occupy\n\n    Returns\n    -------\n    fig_dim: tuple\n            Dimensions of figure in inches\n    \"\"\"", "\n", "# Width of figure (in pts)", "\n", "fig_width_pt", "=", "width", "*", "fraction", "\n", "\n", "# Convert from pt to inches", "\n", "inches_per_pt", "=", "1", "/", "72.27", "\n", "\n", "# Golden ratio to set aesthetic figure height", "\n", "# https://disq.us/p/2940ij3", "\n", "golden_ratio", "=", "(", "5", "**", ".5", "-", "1", ")", "/", "2", "\n", "\n", "# Figure width in inches", "\n", "fig_width_in", "=", "fig_width_pt", "*", "inches_per_pt", "\n", "# Figure height in inches", "\n", "fig_height_in", "=", "fig_width_in", "*", "golden_ratio", "\n", "\n", "fig_dim", "=", "(", "fig_width_in", ",", "fig_height_in", ")", "\n", "\n", "return", "fig_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot-results-aug-resisc.setup_plot": [[94, 96], ["matplotlib.pyplot.subplots", "plot-results-aug-resisc.set_size"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain.set_size"], ["", "def", "setup_plot", "(", "width", "=", "300", ")", ":", "\n", "    ", "return", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "set_size", "(", "width", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot-results-aug-resisc.main": [[98, 157], ["os.makedirs", "seaborn.set_style", "seaborn.set", "glob.glob", "pandas.concat", "print", "plot-results-aug-resisc.gen_plots", "os.path.join", "pandas.DataFrame", "len", "print", "print", "data.astype.astype", "data.astype.basetrain.replace", "data.astype.basetrain.replace", "data.astype.basetrain.replace", "data.astype.basetrain.replace", "frames.append", "open", "json.load", "json.load.values", "data.astype.result.max"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.gen_plots"], ["", "def", "main", "(", "args", ")", ":", "\n", "    ", "os", ".", "makedirs", "(", "args", ".", "out_dir", ",", "exist_ok", "=", "True", ")", "\n", "# setup plots", "\n", "sns", ".", "set_style", "(", "'darkgrid'", ")", "\n", "sns", ".", "set", "(", ")", "\n", "\n", "frames", "=", "[", "]", "#array that collects dataframes from each file", "\n", "\n", "#gets all files that start with \"resisc_\" (still need a file with the baseline results)", "\n", "result_files", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "\"resisc_*.json\"", ")", ",", "recursive", "=", "True", ")", "\n", "for", "resfile", "in", "result_files", ":", "\n", "        ", "with", "open", "(", "resfile", ",", "'r'", ")", "as", "infile", ":", "\n", "            ", "raw_data", "=", "json", ".", "load", "(", "infile", ")", "\n", "", "data", "=", "pd", ".", "DataFrame", "(", "raw_data", ".", "values", "(", ")", ")", "\n", "\n", "aug_type", "=", "[", "]", "\n", "num_rows", "=", "len", "(", "data", ")", "\n", "\n", "#adds an aug-type column, which is used for catplot in gen_plot", "\n", "if", "\"crop_only\"", "in", "resfile", ":", "\n", "            ", "aug_type", "=", "[", "\"Crop only\"", "]", "*", "num_rows", "\n", "", "elif", "\"crop_blur\"", "in", "resfile", ":", "\n", "            ", "aug_type", "=", "[", "\"Crop + blur only\"", "]", "*", "num_rows", "\n", "", "elif", "\"rm_gray\"", "in", "resfile", ":", "\n", "            ", "aug_type", "=", "[", "\"Remove grayscale\"", "]", "*", "num_rows", "\n", "", "elif", "\"rm_color\"", "in", "resfile", ":", "\n", "            ", "aug_type", "=", "[", "\"Remove color\"", "]", "*", "num_rows", "\n", "", "else", ":", "\n", "            ", "aug_type", "=", "[", "\"Baseline\"", "]", "*", "num_rows", "\n", "\n", "", "data", "[", "\"aug_type\"", "]", "=", "aug_type", "\n", "print", "(", "data", ")", "\n", "print", "(", "\"*********************************\"", ")", "\n", "\n", "\n", "data", "=", "data", ".", "astype", "(", "{", "\n", "\"pretrain_iters\"", ":", "int", "\n", "}", ")", "\n", "if", "data", ".", "result", ".", "max", "(", ")", ">", "1", ":", "\n", "            ", "data", ".", "result", "/=", "100", "\n", "", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"imagenet_r50_supervised\"", ",", "\"supervised imagenet init\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"moco_v2_800ep\"", ",", "\"moco imagenet init\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"no\"", ",", "\"random init\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"none\"", ",", "\"random init\"", ")", "\n", "frames", ".", "append", "(", "data", ")", "\n", "\n", "#combines all the dataframes from each file into 1 large dataframe", "\n", "", "result", "=", "pd", ".", "concat", "(", "frames", ",", "ignore_index", "=", "True", ")", "\n", "\n", "#changes all the dataset names to resisc_augmentation", "\n", "result", ".", "dataset", "=", "\"resisc_augmentation\"", "\n", "dataname", "=", "result", ".", "dataset", "[", "0", "]", "\n", "\n", "#prints new concatenated dataframe ", "\n", "print", "(", "result", ")", "\n", "\n", "gen_plots", "(", "result", ",", "{", "\n", "'out_dir'", ":", "args", ".", "out_dir", ",", "\n", "'data_name'", ":", "dataname", "\n", "}", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot-mini.parse_args": [[17, 31], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "os.path.realpath", "os.path.realpath", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "''", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--results-dir'", ",", "\n", "default", "=", "os", ".", "path", ".", "realpath", "(", "os", ".", "path", ".", "join", "(", "dir_path", ",", "\"..\"", ",", "\"results\"", ")", ")", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--out-dir'", ",", "\n", "default", "=", "os", ".", "path", ".", "realpath", "(", "os", ".", "path", ".", "join", "(", "dir_path", ",", "\"..\"", ",", "\"plot-results\"", ")", ")", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--dataset'", ",", "\n", "default", "=", "\"all\"", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot-mini.logit_y_axis": [[32, 38], ["matplotlib.pyplot.yscale", "matplotlib.pyplot.gca().yaxis.set_ticklabels", "matplotlib.pyplot.yticks", "round", "matplotlib.pyplot.gca"], "function", ["None"], ["", "def", "logit_y_axis", "(", "yfact", "=", "100", ")", ":", "\n", "# logit y axes with readable labels", "\n", "    ", "plt", ".", "yscale", "(", "'logit'", ")", "\n", "tickvals", "=", "plt", ".", "yticks", "(", ")", "[", "0", "]", "\n", "ylabs", "=", "[", "\"{}\"", ".", "format", "(", "round", "(", "v", "*", "yfact", ")", ")", "for", "v", "in", "tickvals", "]", "\n", "plt", ".", "gca", "(", ")", ".", "yaxis", ".", "set_ticklabels", "(", "ylabs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot-mini.gen_plots": [[40, 148], ["os.path.join", "os.makedirs", "linear_data.pretrain_data.unique", "axes[].get_legend_handles_labels", "matplotlib.pyplot.setp", "matplotlib.pyplot.setp", "matplotlib.pyplot.setp", "matplotlib.pyplot.setp", "matplotlib.pyplot.setp", "os.path.join", "print", "fig.savefig", "seaborn.axes_style", "matplotlib.pyplot.subplots", "seaborn.axes_style", "axes[].legend", "seaborn.axes_style", "print", "ax1.set_xscale", "ax1.set_xticks", "variant_data[].unique().astype", "ax1.set_xticklabels", "print", "ax1.axhline", "seaborn.lineplot", "ax1.plot", "ax1.set_title", "ax1.get_legend().remove", "variant_data[].unique", "str().replace().title", "variant_data[].unique().astype", "variant_data[].unique", "ax1.get_legend", "str().replace", "variant_data[].unique", "str"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.remove"], ["", "def", "gen_plots", "(", "data", ",", "options", ")", ":", "\n", "\n", "# linear plots", "\n", "    ", "lin_dir", "=", "os", ".", "path", ".", "join", "(", "options", "[", "'out_dir'", "]", ",", "'linear-eval'", ")", "\n", "os", ".", "makedirs", "(", "lin_dir", ",", "exist_ok", "=", "True", ")", "\n", "linear_data", "=", "data", "[", "data", ".", "result_type", "==", "'linear-eval'", "]", "\n", "\n", "#for axes for subplots", "\n", "i", "=", "0", "\n", "j", "=", "0", "\n", "\n", "#creates suplots", "\n", "#didn't use setup_plot since the aspect ratios weren't ideal for the figures", "\n", "with", "sns", ".", "axes_style", "(", "\"ticks\"", ")", ":", "\n", "        ", "fig", ",", "axes", "=", "plt", ".", "subplots", "(", "4", ",", "4", ",", "figsize", "=", "(", "25", ",", "16", ")", ",", "sharey", "=", "False", ",", "constrained_layout", "=", "True", ")", "\n", "", "for", "pretrain_data", "in", "linear_data", ".", "pretrain_data", ".", "unique", "(", ")", ":", "\n", "        ", "for", "variant", "in", "[", "\"linear-eval-lr\"", "]", ":", "# linear_data['variant'].unique():", "\n", "            ", "with", "sns", ".", "axes_style", "(", "\"ticks\"", ")", ":", "\n", "\n", "#checks to make sure axes indices are in range", "\n", "                ", "if", "j", ">", "3", ":", "\n", "                    ", "i", "+=", "1", "\n", "j", "%=", "4", "\n", "\n", "", "variant_data", "=", "linear_data", "[", "(", "linear_data", ".", "variant", "==", "variant", ")", "&", "(", "linear_data", ".", "pretrain_data", "==", "pretrain_data", ")", "]", "\n", "# hack to \"clean up\" other analyses ", "\n", "variant_data", "=", "variant_data", "[", "(", "linear_data", ".", "basetrain", "==", "'MoCo Random Init'", ")", "|", "(", "linear_data", ".", "basetrain", "==", "'HPT'", ")", "]", "\n", "\n", "\n", "print", "(", "i", ",", "j", ")", "\n", "ax1", "=", "axes", "[", "i", ",", "j", "]", "\n", "\n", "#set up x scale", "\n", "ax1", ".", "set_xscale", "(", "'symlog'", ")", "\n", "# data = data[~((data.pretrain_iters == \"5000\") & (data.basetrain == \"MoCo Random Init\"))]", "\n", "ax1", ".", "set_xticks", "(", "ticks", "=", "variant_data", "[", "'pretrain_iters'", "]", ".", "unique", "(", ")", ".", "astype", "(", "int", ")", ")", "\n", "\n", "name_map", "=", "{", "\n", "50", ":", "'50'", ",", "\n", "500", ":", "'500'", ",", "\n", "5000", ":", "'5K'", ",", "\n", "50000", ":", "'50K'", ",", "\n", "100000", ":", "'100K'", ",", "\n", "200000", ":", "'200K'", ",", "\n", "400000", ":", "'400K'", "\n", "}", "\n", "\n", "ori_labels", "=", "variant_data", "[", "'pretrain_iters'", "]", ".", "unique", "(", ")", ".", "astype", "(", "int", ")", "\n", "new_labels", "=", "[", "name_map", "[", "key", "]", "for", "key", "in", "ori_labels", "]", "\n", "\n", "ax1", ".", "set_xticklabels", "(", "labels", "=", "new_labels", ",", "minor", "=", "False", ",", "rotation", "=", "40", ")", "\n", "print", "(", "variant_data", "[", "'pretrain_iters'", "]", ".", "unique", "(", ")", ")", "\n", "\n", "#hard coded bn_data result", "\n", "\n", "#plot data ", "\n", "ax1", ".", "axhline", "(", "y", "=", "options", "[", "'moco_transfers'", "]", "[", "pretrain_data", "]", ",", "c", "=", "'black'", ",", "linestyle", "=", "'dashed'", ",", "linewidth", "=", "3", ",", "label", "=", "\"MoCo Direct Transfer\"", ")", "\n", "\n", "sns", ".", "lineplot", "(", "ax", "=", "ax1", ",", "x", "=", "'pretrain_iters'", ",", "y", "=", "'result'", ",", "hue", "=", "'basetrain'", ",", "data", "=", "variant_data", ",", "marker", "=", "'o'", ",", "mew", "=", "0", ",", "ms", "=", "9", ",", "linewidth", "=", "4", ",", "err_style", "=", "'bars'", ")", "\n", "\n", "ax1", ".", "plot", "(", "5000", ",", "options", "[", "'data_bn'", "]", "[", "pretrain_data", "]", ",", "\"x\"", ",", "ms", "=", "10", ",", "mew", "=", "3", ",", "c", "=", "'red'", ",", "label", "=", "\"HPT-BN\"", ")", "\n", "\n", "\n", "\n", "#set title of each subplot", "\n", "ax1", ".", "set_title", "(", "str", "(", "variant_data", "[", "'dataset'", "]", ".", "iloc", "[", "0", "]", ")", ".", "replace", "(", "\"_\"", ",", "\" \"", ")", ".", "title", "(", ")", ")", "\n", "# handles, _ = axes[0,0].get_legend_handles_labels()", "\n", "\n", "#remove the legend generated for each subplot ", "\n", "ax1", ".", "get_legend", "(", ")", ".", "remove", "(", ")", "\n", "\n", "#incremetns j so next plot is for suplot to the right", "\n", "j", "+=", "1", "\n", "\n", "\n", "#get handles from first subplot (handles from all of them are the same)", "\n", "", "", "", "handles", ",", "_", "=", "axes", "[", "1", ",", "0", "]", ".", "get_legend_handles_labels", "(", ")", "\n", "\n", "#remove the axis lables generated from sns for all subplots", "\n", "plt", ".", "setp", "(", "axes", ",", "xlabel", "=", "''", ")", "\n", "plt", ".", "setp", "(", "axes", ",", "ylabel", "=", "''", ")", "\n", "\n", "#create common x-axis and y-axis labels", "\n", "plt", ".", "setp", "(", "axes", "[", ":", "-", "1", ",", "0", "]", ",", "ylabel", "=", "'Accuracy'", ")", "\n", "plt", ".", "setp", "(", "axes", "[", "-", "1", ",", "0", "]", ",", "ylabel", "=", "'AUROC'", ")", "\n", "plt", ".", "setp", "(", "axes", "[", "-", "1", ",", ":", "]", ",", "xlabel", "=", "'Pretrain Iters'", ")", "\n", "\n", "\n", "#lables used for legend", "\n", "#       labels = [\"HPT\", \"MoCo Target\", \"MoCo ImageNet Transfer\", \"HPT-BN\"]", "\n", "\n", "#crete legend (TODO: make legend fit at bottom of figure properly)", "\n", "#     plt.legend(handles = handles,labels=labels)", "\n", "with", "sns", ".", "axes_style", "(", "\"ticks\"", ")", ":", "\n", "        ", "axes", "[", "0", ",", "0", "]", ".", "legend", "(", ")", "\n", "\n", "# plt.legend(title='Basetrain', labels=labels,", "\n", "#        handles=handles[1:],loc=9,", "\n", "#        fancybox=True, shadow=True, ncol=7, bbox_to_anchor=(0.5, 0.07))", "\n", "\n", "#title for entire figure", "\n", "# fig.suptitle(\"HPT Linear Evaluation Across 14 Datasets\", fontsize=18)", "\n", "\n", "#save figure", "\n", "", "outplot", "=", "os", ".", "path", ".", "join", "(", "lin_dir", ",", "'{}_pretrain-linear_eval.pdf'", ".", "format", "(", "\"all_datasets\"", ",", "variant", ")", ")", "\n", "\n", "print", "(", "outplot", ")", "\n", "fig", ".", "savefig", "(", "outplot", ",", "format", "=", "'pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot-mini.set_size": [[150, 183], ["None"], "function", ["None"], ["", "def", "set_size", "(", "width", ",", "fraction", "=", "1", ")", ":", "\n", "    ", "\"\"\" Set figure dimensions to avoid scaling in LaTeX.\n\n    Parameters\n    ----------\n    width: float\n            Document textwidth or columnwidth in pts\n    fraction: float, optional\n            Fraction of the width which you wish the figure to occupy\n\n    Returns\n    -------\n    fig_dim: tuple\n            Dimensions of figure in inches\n    \"\"\"", "\n", "# Width of figure (in pts)", "\n", "fig_width_pt", "=", "width", "*", "fraction", "\n", "\n", "# Convert from pt to inches", "\n", "inches_per_pt", "=", "1", "/", "72.27", "\n", "\n", "# Golden ratio to set aesthetic figure height", "\n", "# https://disq.us/p/2940ij3", "\n", "golden_ratio", "=", "(", "5", "**", ".5", "-", "1", ")", "/", "2", "\n", "\n", "# Figure width in inches", "\n", "fig_width_in", "=", "fig_width_pt", "*", "inches_per_pt", "\n", "# Figure height in inches", "\n", "fig_height_in", "=", "fig_width_in", "*", "golden_ratio", "\n", "\n", "fig_dim", "=", "(", "fig_width_in", ",", "fig_height_in", ")", "\n", "\n", "return", "fig_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot-mini.setup_plot": [[184, 186], ["matplotlib.pyplot.subplots", "plot-mini.set_size"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain.set_size"], ["", "def", "setup_plot", "(", "width", "=", "300", ")", ":", "\n", "    ", "return", "plt", ".", "subplots", "(", "2", ",", "7", ",", "figsize", "=", "set_size", "(", "width", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot-mini.reduce": [[188, 194], ["data.iterrows", "len"], "function", ["None"], ["", "def", "reduce", "(", "data", ")", ":", "\n", "    ", "avg", "=", "0", "\n", "for", "i", ",", "row", "in", "data", ".", "iterrows", "(", ")", ":", "\n", "        ", "avg", "+=", "row", ".", "result", "\n", "\n", "", "return", "avg", "/", "len", "(", "data", ".", "index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot-mini.main": [[195, 291], ["os.makedirs", "seaborn.set_style", "seaborn.set", "print", "pandas.concat", "print", "print", "plot-mini.gen_plots", "result_files.append", "pandas.DataFrame", "pd.DataFrame.basetrain.replace", "pd.DataFrame.basetrain.replace", "pd.DataFrame.basetrain.replace", "pandas.to_numeric", "plot-mini.reduce", "data_bn.result.max", "datasets_pd.append", "os.path.join", "open", "json.load", "json.load.values", "pd.DataFrame.result.max", "data_bn.result.max", "pd.DataFrame.pretrain_iters.str.contains", "pd.DataFrame.pretrain_iters.str.contains"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.gen_plots", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.reduce"], ["", "def", "main", "(", "args", ")", ":", "\n", "    ", "os", ".", "makedirs", "(", "args", ".", "out_dir", ",", "exist_ok", "=", "True", ")", "\n", "\n", "# setup plots", "\n", "# sns.set_style('white')", "\n", "sns", ".", "set_style", "(", "\"ticks\"", ")", "\n", "# sns.set()", "\n", "sns", ".", "set", "(", "font_scale", "=", "1.7", ")", "\n", "\n", "#list of all datasets wanted", "\n", "datasets", "=", "[", "\n", "'resisc'", ",", "'ucmerced'", ",", "'viper'", ",", "'bdd'", ",", "\n", "'domain_net_painting'", ",", "'domain_net_clipart'", ",", "'domain_net_infograph'", ",", "'domain_net_sketch'", ",", "\n", "'domain_net_quickdraw'", ",", "'domain_net_real'", ",", "'flowers'", ",", "'chest_xray_kids'", ",", "\n", "'chexpert'", ",", "'xview'", ",", "'coco_2014'", ",", "'pascal'", ",", "\n", "]", "\n", "\n", "#", "\n", "\n", "#get files for all datasets wanted", "\n", "result_files", "=", "[", "]", "\n", "for", "dataset", "in", "datasets", ":", "\n", "        ", "result_files", ".", "append", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "dataset", "+", "\"_results.json\"", ")", ")", "\n", "\n", "", "print", "(", "result_files", ")", "\n", "\n", "#creates a datasets list to concatenate all pd to form one large pandas df", "\n", "datasets_pd", "=", "[", "]", "\n", "\n", "#createsd dictionary for moco transfer result and bn result for each dataset", "\n", "moco_transfers", "=", "{", "}", "\n", "data_bn_points", "=", "{", "}", "\n", "\n", "for", "resfile", "in", "result_files", ":", "\n", "        ", "with", "open", "(", "resfile", ",", "'r'", ")", "as", "infile", ":", "\n", "            ", "raw_data", "=", "json", ".", "load", "(", "infile", ")", "\n", "#get data into pandas dataframe", "\n", "", "data", "=", "pd", ".", "DataFrame", "(", "raw_data", ".", "values", "(", ")", ")", "\n", "\n", "#takes only linear evals", "\n", "data", "=", "data", "[", "data", ".", "result_type", "==", "'linear-eval'", "]", "\n", "\n", "#ignores all imagenet basetrain models", "\n", "data", "=", "data", "[", "data", ".", "basetrain", "!=", "\"imagenet_r50_supervised\"", "]", "\n", "\n", "#renames the basetrain", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"moco_v2_800ep\"", ",", "\"HPT\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"no\"", ",", "\"MoCo Random Init\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"none\"", ",", "\"MoCo Random Init\"", ")", "\n", "\n", "\n", "#ignores all imagenet basetrain models", "\n", "# data = data[~((data.pretrain_iters == \"5000\") & (data.basetrain == \"MoCo Random Init\"))]", "\n", "\n", "#gets all bn data ", "\n", "data_bn", "=", "data", "[", "data", ".", "pretrain_iters", ".", "str", ".", "contains", "(", "\"bn\"", ")", "]", "\n", "\n", "#all non-bn data", "\n", "data", "=", "data", "[", "~", "data", ".", "pretrain_iters", ".", "str", ".", "contains", "(", "\"bn\"", ")", "]", "\n", "\n", "#converts the pretrain iters to int", "\n", "data", ".", "pretrain_iters", "=", "pd", ".", "to_numeric", "(", "data", ".", "pretrain_iters", ",", "errors", "=", "'coerce'", ")", "\n", "\n", "\n", "#converts all results to range from 0 - 100", "\n", "if", "data", ".", "result", ".", "max", "(", ")", "<", "1", ":", "\n", "            ", "data", ".", "result", "*=", "100", "\n", "", "if", "data_bn", ".", "result", ".", "max", "(", ")", "<", "1", ":", "\n", "            ", "data_bn", ".", "result", "*=", "100", "\n", "\n", "\n", "#get moco transfer values for horixontal line on graph", "\n", "", "dataset_name", "=", "data", ".", "dataset", ".", "iloc", "[", "0", "]", "\n", "moco_transfer_val", "=", "reduce", "(", "data", "[", "(", "data", ".", "pretrain_iters", "==", "0", ")", "&", "(", "data", ".", "basetrain", "==", "'HPT'", ")", "]", ")", "\n", "moco_transfers", "[", "dataset_name", "]", "=", "moco_transfer_val", "\n", "\n", "#get rid of all pretrain 0 iter runs in data", "\n", "data", "=", "data", "[", "data", ".", "pretrain_iters", "!=", "0", "]", "\n", "\n", "#get best data_bn value", "\n", "top_bn_val", "=", "data_bn", ".", "result", ".", "max", "(", ")", "\n", "data_bn_points", "[", "dataset_name", "]", "=", "top_bn_val", "\n", "\n", "#adds df to a list", "\n", "datasets_pd", ".", "append", "(", "data", ")", "\n", "\n", "#concatenates all df into a final df", "\n", "", "result", "=", "pd", ".", "concat", "(", "datasets_pd", ",", "ignore_index", "=", "True", ")", "\n", "print", "(", "result", ")", "\n", "print", "(", "moco_transfers", ")", "\n", "\n", "#passes in the final df, and dictionaries for moco transger and data_bn and output dir", "\n", "gen_plots", "(", "result", ",", "{", "\n", "'out_dir'", ":", "args", ".", "out_dir", ",", "\n", "'moco_transfers'", ":", "moco_transfers", ",", "\n", "'data_bn'", ":", "data_bn_points", "\n", "}", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot-results.parse_args": [[13, 27], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "os.path.realpath", "os.path.realpath", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "''", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--results-dir'", ",", "\n", "default", "=", "os", ".", "path", ".", "realpath", "(", "os", ".", "path", ".", "join", "(", "dir_path", ",", "\"..\"", ",", "\"results\"", ")", ")", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--out-dir'", ",", "\n", "default", "=", "os", ".", "path", ".", "realpath", "(", "os", ".", "path", ".", "join", "(", "dir_path", ",", "\"..\"", ",", "\"plot-results\"", ")", ")", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--dataset'", ",", "\n", "default", "=", "\"all\"", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot-results.logit_y_axis": [[28, 34], ["matplotlib.pyplot.yscale", "matplotlib.pyplot.gca().yaxis.set_ticklabels", "matplotlib.pyplot.yticks", "round", "matplotlib.pyplot.gca"], "function", ["None"], ["", "def", "logit_y_axis", "(", "yfact", "=", "100", ")", ":", "\n", "# logit y axes with readable labels", "\n", "    ", "plt", ".", "yscale", "(", "'logit'", ")", "\n", "tickvals", "=", "plt", ".", "yticks", "(", ")", "[", "0", "]", "\n", "ylabs", "=", "[", "\"{}\"", ".", "format", "(", "round", "(", "v", "*", "yfact", ")", ")", "for", "v", "in", "tickvals", "]", "\n", "plt", ".", "gca", "(", ")", ".", "yaxis", ".", "set_ticklabels", "(", "ylabs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot-results.gen_plots": [[36, 114], ["os.path.join", "os.makedirs", "linear_data.pretrain_data.unique", "os.path.join", "os.makedirs", "finetune_data.subset.unique", "linear_data.pretrain_data.unique", "linear_data[].result.mean", "bn_data.result.max", "plot-results.setup_plot", "seaborn.lineplot", "ax.axhline", "ax.plot", "ax.get_legend_handles_labels", "matplotlib.pyplot.legend", "matplotlib.pyplot.xlabel", "matplotlib.pyplot.ylabel", "matplotlib.pyplot.title", "matplotlib.pyplot.xscale", "matplotlib.pyplot.xticks", "os.path.join", "print", "fig.savefig", "subset_data.groupby().apply.groupby().apply", "plot-results.setup_plot", "seaborn.lineplot", "matplotlib.pyplot.xlabel", "matplotlib.pyplot.ylabel", "matplotlib.pyplot.xscale", "matplotlib.pyplot.xticks", "plot-results.logit_y_axis", "matplotlib.pyplot.title", "os.path.join", "print", "fig.savefig", "options[].replace().title", "options[].replace().title", "subset_data.groupby().apply.groupby", "options[].replace", "options[].replace", "x.result.idxmax"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain.setup_plot", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain.setup_plot", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain.logit_y_axis"], ["", "def", "gen_plots", "(", "data", ",", "bn_data", ",", "options", ")", ":", "\n", "\n", "# linear plots", "\n", "    ", "lin_dir", "=", "os", ".", "path", ".", "join", "(", "options", "[", "'out_dir'", "]", ",", "'linear-eval'", ")", "\n", "os", ".", "makedirs", "(", "lin_dir", ",", "exist_ok", "=", "True", ")", "\n", "linear_data", "=", "data", "[", "data", ".", "result_type", "==", "'linear-eval'", "]", "\n", "for", "pretrain_data", "in", "linear_data", ".", "pretrain_data", ".", "unique", "(", ")", ":", "\n", "        ", "for", "variant", "in", "[", "\"linear-eval-lr\"", "]", ":", "# linear_data['variant'].unique():", "\n", "            ", "variant_data", "=", "linear_data", "[", "(", "linear_data", ".", "variant", "==", "variant", ")", "&", "\n", "(", "linear_data", ".", "pretrain_data", "==", "pretrain_data", ")", "&", "\n", "(", "linear_data", ".", "pretrain_iters", ">", "0", ")", "&", "\n", "(", "linear_data", ".", "basetrain", "!=", "\"supervised imagenet init\"", ")", "\n", "]", "\n", "\n", "moco_zero_val", "=", "linear_data", "[", "(", "linear_data", ".", "pretrain_iters", "==", "0", ")", "&", "(", "linear_data", ".", "basetrain", "==", "\"moco imagenet init\"", ")", "]", ".", "result", ".", "mean", "(", ")", "\n", "top_bn_val", "=", "bn_data", ".", "result", ".", "max", "(", ")", "\n", "if", "top_bn_val", "<", "1", ":", "\n", "                ", "top_bn_val", "*=", "100", "\n", "\n", "# hack to \"clean up\" other analyses ", "\n", "", "variant_data", "=", "variant_data", "[", "(", "linear_data", ".", "basetrain", "==", "'random init'", ")", "|", "(", "linear_data", ".", "basetrain", "==", "'moco imagenet init'", ")", "|", "(", "linear_data", ".", "basetrain", "==", "'supervised imagenet init'", ")", "]", "\n", "fig", ",", "ax", "=", "setup_plot", "(", "500", ")", "\n", "\n", "# variant_data.groupby(\"basetrain\").plot(x=\"pretrain_iters\", y=\"result\", marker=\"o\", ax=ax)", "\n", "sns", ".", "lineplot", "(", "x", "=", "'pretrain_iters'", ",", "y", "=", "'result'", ",", "hue", "=", "'basetrain'", ",", "data", "=", "variant_data", ",", "marker", "=", "'o'", ",", "mew", "=", "0", ",", "ms", "=", "5", ")", "\n", "ax", ".", "axhline", "(", "moco_zero_val", ",", "ls", "=", "'--'", ",", "label", "=", "\"moco transfer\"", ")", "\n", "\n", "# TODO(cjrd) hardcoding", "\n", "ax", ".", "plot", "(", "5000", ",", "top_bn_val", ",", "\"xr\"", ",", "label", "=", "\"HPT-BN\"", ")", "\n", "\n", "labels", "=", "[", "\"HPT\"", ",", "\"MoCo Random Init\"", ",", "\"MoCo Direct Transfer\"", ",", "\"HPT-BN\"", "]", "\n", "handles", ",", "_", "=", "ax", ".", "get_legend_handles_labels", "(", ")", "\n", "\n", "# Slice list to remove first handle", "\n", "plt", ".", "legend", "(", "handles", "=", "handles", ",", "labels", "=", "labels", ")", "\n", "\n", "plt", ".", "xlabel", "(", "\"Pretrain Steps\"", ")", "\n", "plt", ".", "ylabel", "(", "\"Accuracy\"", ")", "\n", "plt", ".", "title", "(", "options", "[", "'data_name'", "]", ".", "replace", "(", "\"_\"", ",", "\" \"", ")", ".", "title", "(", ")", ")", "\n", "\n", "plt", ".", "xscale", "(", "'log'", ")", "\n", "plt", ".", "xticks", "(", "ticks", "=", "variant_data", "[", "'pretrain_iters'", "]", ",", "labels", "=", "variant_data", "[", "'pretrain_iters'", "]", ",", "rotation", "=", "'vertical'", ")", "\n", "\n", "# logit_y_axis()", "\n", "outplot", "=", "os", ".", "path", ".", "join", "(", "lin_dir", ",", "'{}_pretrain-{}_linear_eval-{}_variant.pdf'", ".", "format", "(", "pretrain_data", ",", "options", "[", "'data_name'", "]", ",", "variant", ")", ")", "\n", "print", "(", "outplot", ")", "\n", "fig", ".", "savefig", "(", "outplot", ",", "format", "=", "'pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "\n", "\n", "# finetune plots", "\n", "", "", "finetune_dir", "=", "os", ".", "path", ".", "join", "(", "options", "[", "'out_dir'", "]", ",", "'finetune-eval'", ")", "\n", "os", ".", "makedirs", "(", "finetune_dir", ",", "exist_ok", "=", "True", ")", "\n", "finetune_data", "=", "data", "[", "data", ".", "result_type", "==", "'finetune'", "]", "\n", "\n", "for", "subset", "in", "finetune_data", ".", "subset", ".", "unique", "(", ")", ":", "\n", "        ", "for", "pretrain_data", "in", "linear_data", ".", "pretrain_data", ".", "unique", "(", ")", ":", "\n", "            ", "subset_data", "=", "finetune_data", "[", "(", "finetune_data", ".", "subset", "==", "subset", ")", "&", "(", "finetune_data", ".", "pretrain_data", "==", "pretrain_data", ")", "]", "\n", "# take max val across each sample, iter, and basetrain", "\n", "# (isn't pandas cool?)", "\n", "subset_data", "=", "subset_data", ".", "groupby", "(", "[", "'sample'", ",", "'pretrain_iters'", ",", "'basetrain'", "]", ")", ".", "apply", "(", "lambda", "x", ":", "x", ".", "loc", "[", "x", ".", "result", ".", "idxmax", "(", ")", "]", ")", "\n", "if", "subset_data", ".", "empty", ":", "\n", "                ", "continue", "\n", "\n", "", "fig", ",", "ax", "=", "setup_plot", "(", "500", ")", "\n", "\n", "sns", ".", "lineplot", "(", "x", "=", "'pretrain_iters'", ",", "y", "=", "'result'", ",", "hue", "=", "'basetrain'", ",", "data", "=", "subset_data", ",", "marker", "=", "'o'", ",", "mew", "=", "0", ",", "ms", "=", "5", ")", "\n", "\n", "plt", ".", "xlabel", "(", "\"Pretrain Steps\"", ")", "\n", "plt", ".", "ylabel", "(", "\"Accuracy\"", ")", "\n", "plt", ".", "xscale", "(", "'symlog'", ")", "\n", "plt", ".", "xticks", "(", "ticks", "=", "subset_data", "[", "'pretrain_iters'", "]", ",", "labels", "=", "subset_data", "[", "'pretrain_iters'", "]", ",", "rotation", "=", "'vertical'", ")", "\n", "logit_y_axis", "(", ")", "\n", "\n", "plt", ".", "title", "(", "options", "[", "'data_name'", "]", ".", "replace", "(", "\"_\"", ",", "\" \"", ")", ".", "title", "(", ")", ")", "\n", "\n", "outplot", "=", "os", ".", "path", ".", "join", "(", "finetune_dir", ",", "'{}_pretrain-{}_fintune-{}_subset.pdf'", ".", "format", "(", "pretrain_data", ",", "options", "[", "'data_name'", "]", ",", "subset", ")", ")", "\n", "print", "(", "outplot", ")", "\n", "fig", ".", "savefig", "(", "outplot", ",", "format", "=", "'pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot-results.set_size": [[116, 149], ["None"], "function", ["None"], ["", "", "", "def", "set_size", "(", "width", ",", "fraction", "=", "1", ")", ":", "\n", "    ", "\"\"\" Set figure dimensions to avoid scaling in LaTeX.\n\n    Parameters\n    ----------\n    width: float\n            Document textwidth or columnwidth in pts\n    fraction: float, optional\n            Fraction of the width which you wish the figure to occupy\n\n    Returns\n    -------\n    fig_dim: tuple\n            Dimensions of figure in inches\n    \"\"\"", "\n", "# Width of figure (in pts)", "\n", "fig_width_pt", "=", "width", "*", "fraction", "\n", "\n", "# Convert from pt to inches", "\n", "inches_per_pt", "=", "1", "/", "72.27", "\n", "\n", "# Golden ratio to set aesthetic figure height", "\n", "# https://disq.us/p/2940ij3", "\n", "golden_ratio", "=", "(", "5", "**", ".5", "-", "1", ")", "/", "2", "\n", "\n", "# Figure width in inches", "\n", "fig_width_in", "=", "fig_width_pt", "*", "inches_per_pt", "\n", "# Figure height in inches", "\n", "fig_height_in", "=", "fig_width_in", "*", "golden_ratio", "\n", "\n", "fig_dim", "=", "(", "fig_width_in", ",", "fig_height_in", ")", "\n", "\n", "return", "fig_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot-results.setup_plot": [[150, 152], ["matplotlib.pyplot.subplots", "plot-results.set_size"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain.set_size"], ["", "def", "setup_plot", "(", "width", "=", "300", ")", ":", "\n", "    ", "return", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "set_size", "(", "width", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot-results.main": [[154, 191], ["os.makedirs", "seaborn.set_style", "seaborn.set", "glob.glob", "os.path.join", "pandas.DataFrame", "pandas.to_numeric", "data.astype.basetrain.replace", "data.astype.basetrain.replace", "data.astype.basetrain.replace", "data.astype.basetrain.replace", "plot-results.gen_plots", "open", "json.load", "json.load.values", "data.astype.astype", "data.astype.result.max", "data.astype.pretrain_iters.str.contains", "print", "data.astype.pretrain_iters.str.contains"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.gen_plots"], ["", "def", "main", "(", "args", ")", ":", "\n", "    ", "os", ".", "makedirs", "(", "args", ".", "out_dir", ",", "exist_ok", "=", "True", ")", "\n", "\n", "# setup plots", "\n", "sns", ".", "set_style", "(", "'darkgrid'", ")", "\n", "sns", ".", "set", "(", ")", "\n", "\n", "result_files", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "\"*.json\"", ")", ",", "recursive", "=", "True", ")", "\n", "for", "resfile", "in", "result_files", ":", "\n", "        ", "with", "open", "(", "resfile", ",", "'r'", ")", "as", "infile", ":", "\n", "            ", "raw_data", "=", "json", ".", "load", "(", "infile", ")", "\n", "", "data", "=", "pd", ".", "DataFrame", "(", "raw_data", ".", "values", "(", ")", ")", "\n", "dataname", "=", "data", ".", "dataset", "[", "0", "]", "\n", "if", "args", ".", "dataset", "!=", "\"all\"", "and", "dataname", "!=", "args", ".", "dataset", ":", "\n", "             ", "continue", "\n", "\n", "", "bn_data", "=", "data", "[", "data", ".", "pretrain_iters", ".", "str", ".", "contains", "(", "\"bn\"", ")", "]", "\n", "data", "=", "data", "[", "~", "data", ".", "pretrain_iters", ".", "str", ".", "contains", "(", "\"bn\"", ")", "]", "\n", "data", ".", "pretrain_iters", "=", "pd", ".", "to_numeric", "(", "data", ".", "pretrain_iters", ",", "errors", "=", "'coerce'", ")", "\n", "# convert batchnorm iters to a new type of data", "\n", "\n", "try", ":", "\n", "            ", "data", "=", "data", ".", "astype", "(", "{", "\n", "\"pretrain_iters\"", ":", "int", "\n", "}", ")", "\n", "# pokemon exceptions!", "\n", "", "except", "Exception", "as", "exp", ":", "\n", "            ", "print", "(", "f\"WARNING: Unable to parse pretrain_iters as int for {dataname}\"", ")", "\n", "", "if", "data", ".", "result", ".", "max", "(", ")", "<", "1", ":", "\n", "            ", "data", ".", "result", "*=", "100", "\n", "", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"imagenet_r50_supervised\"", ",", "\"supervised imagenet init\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"moco_v2_800ep\"", ",", "\"moco imagenet init\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"no\"", ",", "\"random init\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"none\"", ",", "\"random init\"", ")", "\n", "gen_plots", "(", "data", ",", "bn_data", ",", "{", "\n", "'out_dir'", ":", "args", ".", "out_dir", ",", "\n", "'data_name'", ":", "dataname", "\n", "}", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain_modified.parse_args": [[15, 29], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "os.path.realpath", "os.path.realpath", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "''", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--results-dir'", ",", "\n", "default", "=", "os", ".", "path", ".", "realpath", "(", "os", ".", "path", ".", "join", "(", "dir_path", ",", "\"results_modified\"", ")", ")", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--out-dir'", ",", "\n", "default", "=", "os", ".", "path", ".", "realpath", "(", "os", ".", "path", ".", "join", "(", "dir_path", ",", "\"plot-results\"", ")", ")", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--dataset'", ",", "\n", "default", "=", "\"all\"", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain_modified.logit_y_axis": [[30, 36], ["matplotlib.pyplot.yscale", "matplotlib.pyplot.gca().yaxis.set_ticklabels", "matplotlib.pyplot.yticks", "round", "matplotlib.pyplot.gca"], "function", ["None"], ["", "def", "logit_y_axis", "(", "yfact", "=", "100", ")", ":", "\n", "# logit y axes with readable labels", "\n", "    ", "plt", ".", "yscale", "(", "'logit'", ")", "\n", "tickvals", "=", "plt", ".", "yticks", "(", ")", "[", "0", "]", "\n", "ylabs", "=", "[", "\"{}\"", ".", "format", "(", "round", "(", "v", "*", "yfact", ")", ")", "for", "v", "in", "tickvals", "]", "\n", "plt", ".", "gca", "(", ")", ".", "yaxis", ".", "set_ticklabels", "(", "ylabs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain_modified.gen_plots": [[38, 99], ["matplotlib.style.use", "os.path.join", "os.makedirs", "linear_data.pretrain_data.unique", "plot_pct_pretrain_modified.setup_plot", "variant_data[].sort_values", "variant_data[].sort_values", "variant_data[].sort_values", "matplotlib.pyplot.plot", "matplotlib.pyplot.plot", "matplotlib.pyplot.plot", "matplotlib.pyplot.axhline", "matplotlib.pyplot.xlabel", "matplotlib.pyplot.title", "matplotlib.pyplot.xscale", "matplotlib.pyplot.xticks", "matplotlib.pyplot.yticks", "ax.get_legend_handles_labels", "matplotlib.pyplot.legend", "os.path.join", "print", "fig.savefig", "matplotlib.pyplot.ylabel", "matplotlib.pyplot.ylabel", "options[].replace().title", "options[].replace"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain.setup_plot"], ["", "def", "gen_plots", "(", "data", ",", "options", ")", ":", "\n", "\n", "    ", "mpl", ".", "style", ".", "use", "(", "'default'", ")", "\n", "# linear plots", "\n", "lin_dir", "=", "os", ".", "path", ".", "join", "(", "options", "[", "'out_dir'", "]", ",", "'pretrain_robustness'", ")", "\n", "os", ".", "makedirs", "(", "lin_dir", ",", "exist_ok", "=", "True", ")", "\n", "linear_data", "=", "data", "[", "data", ".", "result_type", "==", "'linear-eval'", "]", "\n", "for", "pretrain_data", "in", "linear_data", ".", "pretrain_data", ".", "unique", "(", ")", ":", "\n", "        ", "for", "variant", "in", "[", "\"linear-eval-lr\"", "]", ":", "# linear_data['variant'].unique():", "\n", "            ", "variant_data", "=", "linear_data", "[", "(", "linear_data", ".", "variant", "==", "variant", ")", "&", "(", "linear_data", ".", "pretrain_data", "==", "pretrain_data", ")", "]", "\n", "# hack to \"clean up\" other analyses ", "\n", "variant_data", "=", "variant_data", "[", "(", "linear_data", ".", "basetrain", "==", "'MoCo Random Init'", ")", "|", "(", "linear_data", ".", "basetrain", "==", "'HPT'", ")", "|", "(", "linear_data", ".", "basetrain", "==", "'supervised imagenet init'", ")", "|", "(", "linear_data", ".", "basetrain", "==", "'HPT-BN'", ")", "]", "\n", "# fig, ax = setup_plot(500)", "\n", "# print(variant_data)", "\n", "fig", ",", "ax", "=", "setup_plot", "(", "600", ")", "\n", "\n", "# variant_data.groupby(\"basetrain\").plot(x=\"pretrain_iters\", y=\"result\", marker=\"o\", ax=ax)", "\n", "# sns.lineplot(x='pct_train', y='result', ", "\n", "#              hue='basetrain', data=variant_data, marker='o', mew=0, ms=10, lw=4)", "\n", "data_1", "=", "variant_data", "[", "variant_data", ".", "basetrain", "==", "'HPT'", "]", ".", "sort_values", "(", "'pct_train'", ")", "\n", "data_2", "=", "variant_data", "[", "variant_data", ".", "basetrain", "==", "'HPT-BN'", "]", ".", "sort_values", "(", "'pct_train'", ")", "\n", "data_3", "=", "variant_data", "[", "variant_data", ".", "basetrain", "==", "'MoCo Random Init'", "]", ".", "sort_values", "(", "'pct_train'", ")", "\n", "colors", "=", "[", "(", "209", "/", "225.", ",", "136", "/", "225.", ",", "92", "/", "225.", ")", ",", "(", "171", "/", "225.", ",", "94", "/", "225.", ",", "91", "/", "225.", ")", ",", "\n", "(", "93", "/", "225.", ",", "126", "/", "225.", ",", "105", "/", "225.", ")", ",", "(", "84", "/", "225.", ",", "114", "/", "225.", ",", "171", "/", "225.", ")", "]", "\n", "plt", ".", "plot", "(", "data_1", "[", "'pct_train'", "]", ",", "data_1", "[", "'result'", "]", ",", "marker", "=", "'o'", ",", "mew", "=", "0", ",", "ms", "=", "10", ",", "lw", "=", "3.5", ",", "color", "=", "colors", "[", "3", "]", ",", "label", "=", "\"d\"", ")", "\n", "plt", ".", "plot", "(", "data_2", "[", "'pct_train'", "]", ",", "data_2", "[", "'result'", "]", ",", "marker", "=", "'o'", ",", "mew", "=", "0", ",", "ms", "=", "10", ",", "lw", "=", "3.5", ",", "color", "=", "colors", "[", "1", "]", ",", "label", "=", "\"d\"", ")", "\n", "plt", ".", "plot", "(", "data_3", "[", "'pct_train'", "]", ",", "data_3", "[", "'result'", "]", ",", "marker", "=", "'o'", ",", "mew", "=", "0", ",", "ms", "=", "10", ",", "lw", "=", "3.5", ",", "color", "=", "colors", "[", "0", "]", ",", "label", "=", "\"d\"", ")", "\n", "# fig.set(xlabel='Percent of Pretrain data', ylabel='Change of Accuracy from Baseline', title=options['data_name'].replace(\"_\", \" \").title())", "\n", "# plt.close(1) ", "\n", "plt", ".", "axhline", "(", "y", "=", "options", "[", "'asymptote'", "]", ",", "c", "=", "'red'", ",", "dashes", "=", "[", "10", ",", "4", "]", ",", "label", "=", "\"MoCo Direct Transfer\"", ")", "\n", "\n", "plt", ".", "xlabel", "(", "\"Percentage of Pretrain Data\"", ",", "fontsize", "=", "24", ")", "\n", "\n", "if", "'chexpert'", "in", "options", "[", "'data_name'", "]", ":", "\n", "                ", "plt", ".", "ylabel", "(", "\"AUROC\"", ",", "fontsize", "=", "24", ")", "\n", "", "else", ":", "\n", "                ", "plt", ".", "ylabel", "(", "\"Accuracy\"", ",", "fontsize", "=", "24", ")", "\n", "", "plt", ".", "title", "(", "options", "[", "'data_name'", "]", ".", "replace", "(", "\"_\"", ",", "\" \"", ")", ".", "title", "(", ")", ",", "fontsize", "=", "27", ")", "\n", "\n", "plt", ".", "xscale", "(", "'linear'", ")", "\n", "plt", ".", "xticks", "(", "ticks", "=", "variant_data", "[", "'pct_train'", "]", ",", "\n", "labels", "=", "variant_data", "[", "'pct_train'", "]", ",", "\n", "#                        rotation='horizontal', ", "\n", "fontsize", "=", "20", ")", "\n", "plt", ".", "yticks", "(", "fontsize", "=", "20", ")", "\n", "\n", "\n", "#             plt.grid(axis='y', color='grey', dashes=[10, 4])", "\n", "# ax.patch.set_facecolor('0.97')", "\n", "\n", "\n", "labels", "=", "[", "\"HPT\"", ",", "\"HPT-BN\"", ",", "\"MoCo Random Init\"", ",", "\"MoCo Direct Transfer\"", "]", "\n", "handles", ",", "_", "=", "ax", ".", "get_legend_handles_labels", "(", ")", "\n", "plt", ".", "legend", "(", "handles", "=", "handles", "[", ":", "]", ",", "\n", "labels", "=", "labels", ",", "\n", "#                        title=\"Basetrain\",", "\n", "fontsize", "=", "'x-large'", ")", "\n", "# plt.show()", "\n", "outplot", "=", "os", ".", "path", ".", "join", "(", "lin_dir", ",", "'{}_data_robustness-{}_linear_eval.pdf'", ".", "format", "(", "pretrain_data", ",", "options", "[", "'data_name'", "]", "+", "\"_data_robustness\"", ")", ")", "\n", "print", "(", "outplot", ")", "\n", "fig", ".", "savefig", "(", "outplot", ",", "format", "=", "'pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain_modified.set_size": [[100, 133], ["None"], "function", ["None"], ["", "", "", "def", "set_size", "(", "width", ",", "fraction", "=", "1", ")", ":", "\n", "    ", "\"\"\" Set figure dimensions to avoid scaling in LaTeX.\n\n    Parameters\n    ----------\n    width: float\n            Document textwidth or columnwidth in pts\n    fraction: float, optional\n            Fraction of the width which you wish the figure to occupy\n\n    Returns\n    -------\n    fig_dim: tuple\n            Dimensions of figure in inches\n    \"\"\"", "\n", "# Width of figure (in pts)", "\n", "fig_width_pt", "=", "width", "*", "fraction", "\n", "\n", "# Convert from pt to inches", "\n", "inches_per_pt", "=", "1", "/", "72.27", "\n", "\n", "# Golden ratio to set aesthetic figure height", "\n", "# https://disq.us/p/2940ij3", "\n", "golden_ratio", "=", "(", "5", "**", ".5", "-", "1", ")", "/", "2", "\n", "\n", "# Figure width in inches", "\n", "fig_width_in", "=", "fig_width_pt", "*", "inches_per_pt", "\n", "# Figure height in inches", "\n", "fig_height_in", "=", "fig_width_in", "*", "golden_ratio", "\n", "\n", "fig_dim", "=", "(", "fig_width_in", ",", "fig_height_in", ")", "\n", "\n", "return", "fig_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain_modified.reduce": [[134, 141], ["data.iterrows"], "function", ["None"], ["", "def", "reduce", "(", "data", ")", ":", "\n", "    ", "best", "=", "0", "\n", "for", "i", ",", "row", "in", "data", ".", "iterrows", "(", ")", ":", "\n", "        ", "if", "best", "<", "row", "[", "'result'", "]", ":", "\n", "            ", "best", "=", "row", "[", "'result'", "]", "\n", "\n", "", "", "return", "data", "[", "data", ".", "result", "==", "best", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain_modified.setup_plot": [[143, 145], ["matplotlib.pyplot.subplots", "plot_pct_pretrain_modified.set_size"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain.set_size"], ["", "def", "setup_plot", "(", "width", "=", "300", ")", ":", "\n", "    ", "return", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "set_size", "(", "width", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain_modified.main": [[147, 306], ["os.makedirs", "seaborn.set_style", "seaborn.set", "glob.glob", "glob.glob.append", "pandas.concat", "pd.concat.iterrows", "pct1[].max", "pct10[].max", "pct25[].max", "pandas.concat", "pct1_bn[].max", "pct10_bn[].max", "pct25_bn[].max", "pct100_bn[].max", "pandas.concat", "pandas.concat", "print", "print", "print", "print", "plot_pct_pretrain_modified.gen_plots", "os.path.join", "os.path.join", "glob.glob.append", "print", "pandas.DataFrame", "pd.concat.astype", "pd.concat.basetrain.replace", "pd.concat.basetrain.replace", "pd.concat.basetrain.replace", "frames.append", "len", "pandas.concat", "os.path.join", "open", "json.load", "json.load.values", "plot_pct_pretrain_modified.reduce", "plot_pct_pretrain_modified.reduce", "types.append", "types.append", "pandas.concat", "print", "pd.concat.basetrain.replace"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.gen_plots", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.reduce", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.reduce"], ["", "def", "main", "(", "args", ")", ":", "\n", "\n", "#must pass in dataset arg for proper results", "\n", "\n", "    ", "os", ".", "makedirs", "(", "args", ".", "out_dir", ",", "exist_ok", "=", "True", ")", "\n", "# setup plots", "\n", "sns", ".", "set_style", "(", "'darkgrid'", ")", "\n", "sns", ".", "set", "(", ")", "\n", "\n", "frames", "=", "[", "]", "#array that collects dataframes from each file", "\n", "if", "(", "args", ".", "dataset", "==", "\"all\"", ")", ":", "\n", "        ", "dataset_type", "=", "\"*\"", "\n", "", "else", ":", "\n", "        ", "dataset_type", "=", "args", ".", "dataset", "\n", "\n", "#gets all files that start with \"*pct\" for the corresponding dataset", "\n", "", "result_files", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "dataset_type", "+", "\"*pct*.json\"", ")", ",", "recursive", "=", "True", ")", "\n", "result_files", ".", "append", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "dataset_type", "+", "\"_results.json\"", ")", ")", "#gets file with 100% pretrain data results", "\n", "if", "(", "dataset_type", "!=", "'resisc'", ")", ":", "\n", "        ", "result_files", ".", "append", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "dataset_type", "+", "\"_bn_results.json\"", ")", ")", "\n", "", "for", "resfile", "in", "result_files", ":", "\n", "        ", "with", "open", "(", "resfile", ",", "'r'", ")", "as", "infile", ":", "\n", "            ", "raw_data", "=", "json", ".", "load", "(", "infile", ")", "\n", "\n", "", "print", "(", "resfile", ")", "\n", "\n", "types", "=", "[", "]", "#used for concatenating the resultzs from each basetrained model", "\n", "data", "=", "pd", ".", "DataFrame", "(", "raw_data", ".", "values", "(", ")", ")", "\n", "\n", "\n", "#finds the relevant values for moco bt, and no bt", "\n", "#mainly done to work around the baseline json file (has extra info that we don't want)", "\n", "if", "(", "dataset_type", "+", "\"_results.json\"", ")", "in", "resfile", ":", "\n", "            ", "linear_data", "=", "data", "[", "data", ".", "result_type", "==", "'linear-eval'", "]", "\n", "linear_data", "=", "linear_data", "[", "linear_data", ".", "variant", "==", "\"linear-eval-lr\"", "]", "\n", "\n", "data_moco", "=", "linear_data", "[", "data", ".", "basetrain", "==", "\"moco_v2_800ep\"", "]", "\n", "# data_moco = data_moco[data_moco.pretrain_iters==\"5000\"]", "\n", "data_moco", "=", "data_moco", "[", "data_moco", ".", "pretrain_data", "==", "dataset_type", "]", "\n", "data_moco", "=", "reduce", "(", "data_moco", ")", "\n", "\n", "\n", "data_nobt", "=", "linear_data", "[", "data", ".", "basetrain", "==", "\"no\"", "]", "\n", "# data_nobt= data_nobt[data_nobt.pretrain_iters==\"100000\"]", "\n", "data_nobt", "=", "data_nobt", "[", "data_nobt", ".", "pretrain_data", "==", "dataset_type", "]", "\n", "data_nobt", "=", "reduce", "(", "data_nobt", ")", "\n", "\n", "\n", "#appended to list ", "\n", "types", ".", "append", "(", "data_moco", ")", "\n", "types", ".", "append", "(", "data_nobt", ")", "\n", "\n", "#all concat to new dataframe ", "\n", "data", "=", "pd", ".", "concat", "(", "types", ",", "ignore_index", "=", "True", ")", "\n", "print", "(", "data", ")", "\n", "\n", "", "if", "\"bn\"", "in", "resfile", ":", "\n", "            ", "data_bn", "=", "data", "[", "data", ".", "pretrain_iters", "!=", "'0'", "]", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"moco_v2_800ep\"", ",", "\"HPT-BN\"", ")", "\n", "\n", "#convert pretrain iters values to int", "\n", "\n", "", "data", "=", "data", ".", "astype", "(", "{", "\n", "\"pretrain_iters\"", ":", "int", "\n", "}", ")", "\n", "\n", "#multiply all results < 1 by 100", "\n", "if", "not", "(", "data", ".", "result", ">", "1", ")", ".", "all", "(", ")", ":", "\n", "            ", "data", ".", "result", "*=", "100", "\n", "\n", "\n", "#change corresponding names of each basetrain ", "\n", "", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"moco_v2_800ep\"", ",", "\"HPT\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"no\"", ",", "\"MoCo Random Init\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"none\"", ",", "\"MoCo Random Init\"", ")", "\n", "frames", ".", "append", "(", "data", ")", "\n", "\n", "#combines all the dataframes from each file into 1 large dataframe", "\n", "", "result", "=", "pd", ".", "concat", "(", "frames", ",", "ignore_index", "=", "True", ")", "\n", "\n", "#add a column for pct pretrain data and iterate through each row to add appropriate value", "\n", "pct", "=", "[", "0", "]", "*", "len", "(", "result", ")", "\n", "asymptote", "=", "0", "\n", "count", "=", "0", "\n", "result", "[", "\"pct_train\"", "]", "=", "pct", "\n", "\n", "for", "i", ",", "row", "in", "result", ".", "iterrows", "(", ")", ":", "\n", "        ", "val", "=", "0", "\n", "if", "row", "[", "\"pretrain_iters\"", "]", "==", "0", ":", "\n", "            ", "asymptote", "+=", "row", "[", "\"result\"", "]", "\n", "count", "+=", "1", "\n", "continue", "\n", "", "if", "\"1_pct\"", "in", "row", "[", "\"dataset\"", "]", ":", "\n", "            ", "val", "=", "1", "\n", "", "elif", "\"10_pct\"", "in", "row", "[", "\"dataset\"", "]", ":", "\n", "            ", "val", "=", "10", "\n", "", "elif", "\"25_pct\"", "in", "row", "[", "\"dataset\"", "]", ":", "\n", "            ", "val", "=", "25", "\n", "", "else", ":", "\n", "            ", "val", "=", "100", "\n", "", "result", ".", "at", "[", "i", ",", "\"pct_train\"", "]", "=", "val", "\n", "\n", "", "result", "=", "result", "[", "result", "[", "'pretrain_iters'", "]", ">", "0", "]", "\n", "result", ".", "pretrain_data", "=", "dataset_type", "\n", "\n", "#changes entries to best performace ", "\n", "pct1", "=", "result", "[", "(", "result", "[", "'pct_train'", "]", "==", "1", ")", "&", "(", "result", "[", "'basetrain'", "]", "==", "\"HPT\"", ")", "]", "\n", "pct1", ".", "result", "=", "pct1", "[", "'result'", "]", ".", "max", "(", ")", "\n", "pct10", "=", "result", "[", "(", "result", "[", "'pct_train'", "]", "==", "10", ")", "&", "(", "result", "[", "'basetrain'", "]", "==", "\"HPT\"", ")", "]", "\n", "pct10", ".", "result", "=", "pct10", "[", "'result'", "]", ".", "max", "(", ")", "\n", "pct25", "=", "result", "[", "(", "result", "[", "'pct_train'", "]", "==", "25", ")", "&", "(", "result", "[", "'basetrain'", "]", "==", "\"HPT\"", ")", "]", "\n", "pct25", ".", "result", "=", "pct25", "[", "'result'", "]", ".", "max", "(", ")", "\n", "\n", "moco", "=", "pd", ".", "concat", "(", "[", "pct1", ",", "pct10", ",", "pct25", "]", ",", "ignore_index", "=", "True", ")", "\n", "\n", "pct1_bn", "=", "result", "[", "(", "result", "[", "'pct_train'", "]", "==", "1", ")", "&", "(", "result", "[", "'basetrain'", "]", "==", "\"HPT-BN\"", ")", "]", "\n", "pct1_bn", ".", "result", "=", "pct1_bn", "[", "'result'", "]", ".", "max", "(", ")", "\n", "pct10_bn", "=", "result", "[", "(", "result", "[", "'pct_train'", "]", "==", "10", ")", "&", "(", "result", "[", "'basetrain'", "]", "==", "\"HPT-BN\"", ")", "]", "\n", "pct10_bn", ".", "result", "=", "pct10_bn", "[", "'result'", "]", ".", "max", "(", ")", "\n", "pct25_bn", "=", "result", "[", "(", "result", "[", "'pct_train'", "]", "==", "25", ")", "&", "(", "result", "[", "'basetrain'", "]", "==", "\"HPT-BN\"", ")", "]", "\n", "pct25_bn", ".", "result", "=", "pct25_bn", "[", "'result'", "]", ".", "max", "(", ")", "\n", "pct100_bn", "=", "result", "[", "(", "result", "[", "'pct_train'", "]", "==", "100", ")", "&", "(", "result", "[", "'basetrain'", "]", "==", "\"HPT-BN\"", ")", "]", "\n", "pct100_bn", ".", "result", "=", "pct100_bn", "[", "'result'", "]", ".", "max", "(", ")", "\n", "\n", "bn", "=", "pd", ".", "concat", "(", "[", "pct1_bn", ",", "pct10_bn", ",", "pct25_bn", ",", "pct100_bn", "]", ",", "ignore_index", "=", "True", ")", "\n", "\n", "\n", "\n", "\n", "#keeps all the random inits in result pd", "\n", "result", "=", "result", "[", "(", "(", "result", "[", "'basetrain'", "]", "!=", "\"HPT\"", ")", "&", "(", "result", "[", "'basetrain'", "]", "!=", "\"HPT-BN\"", ")", ")", "|", "(", "result", "[", "'pct_train'", "]", "==", "100", ")", "]", "\n", "\n", "\n", "#hack for resisc bn 100% pretrain", "\n", "if", "dataset_type", "==", "'resisc'", ":", "\n", "        ", "pct100_bn", "=", "result", "[", "(", "result", "[", "'pct_train'", "]", "==", "100", ")", "&", "(", "result", "[", "'basetrain'", "]", "==", "\"HPT\"", ")", "]", "\n", "pct100_bn", ".", "basetrain", "=", "'HPT-BN'", "\n", "pct100_bn", ".", "result", "=", "92.50794", "\n", "bn", "=", "pd", ".", "concat", "(", "[", "bn", ",", "pct100_bn", "]", ",", "ignore_index", "=", "True", ")", "\n", "\n", "", "result", "=", "pd", ".", "concat", "(", "[", "moco", ",", "bn", ",", "result", "]", ",", "ignore_index", "=", "True", ")", "\n", "\n", "\n", "\n", "\n", "#prints new concatenated dataframe ", "\n", "print", "(", "result", ")", "\n", "print", "(", "result", ".", "result", ")", "\n", "print", "(", "result", ".", "basetrain", ")", "\n", "\n", "\n", "dataname", "=", "dataset_type", "#+\"_data_robustness\"", "\n", "asymptote", "/=", "count", "\n", "print", "(", "\"moco transfer:\"", ",", "asymptote", ")", "\n", "\n", "gen_plots", "(", "result", ",", "{", "\n", "'out_dir'", ":", "args", ".", "out_dir", ",", "\n", "'data_name'", ":", "dataname", ",", "\n", "'asymptote'", ":", "asymptote", "\n", "}", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_augmentation.parse_args": [[15, 32], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "os.path.realpath", "os.path.realpath", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "''", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--results-dir'", ",", "\n", "default", "=", "os", ".", "path", ".", "realpath", "(", "os", ".", "path", ".", "join", "(", "dir_path", ",", "\"..\"", ",", "\"results\"", ")", ")", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--out-dir'", ",", "\n", "default", "=", "os", ".", "path", ".", "realpath", "(", "os", ".", "path", ".", "join", "(", "dir_path", ",", "\"..\"", ",", "\"plot-results\"", ")", ")", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--dataset'", ",", "\n", "default", "=", "\"all\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--basetrain'", ",", "\n", "default", "=", "\"\"", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_augmentation.gen_plots": [[34, 59], ["os.path.join", "os.makedirs", "seaborn.catplot", "sns.catplot.set", "sns.catplot.ax.legend", "matplotlib.pyplot.close", "os.path.join", "sns.catplot.savefig", "options[].replace().title", "options[].replace"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.TensorboardXWriter.close"], ["", "def", "gen_plots", "(", "data", ",", "options", ")", ":", "\n", "\n", "# linear plots", "\n", "    ", "lin_dir", "=", "os", ".", "path", ".", "join", "(", "options", "[", "'out_dir'", "]", ",", "'aug_robust_no_supervised'", ")", "\n", "os", ".", "makedirs", "(", "lin_dir", ",", "exist_ok", "=", "True", ")", "\n", "linear_data", "=", "data", "[", "data", ".", "result_type", "==", "'linear-eval'", "]", "\n", "linear_data", "=", "linear_data", "[", "linear_data", ".", "variant", "==", "\"linear-eval-lr\"", "]", "\n", "\n", "#since catplot is a figure level function, it produces a new, separate plot which doesn't follow style of past graphs", "\n", "fig", "=", "sns", ".", "catplot", "(", "x", "=", "'aug_type'", ",", "y", "=", "'result'", ",", "hue", "=", "'basetrain'", ",", "data", "=", "linear_data", ",", "kind", "=", "\"point\"", ",", "s", "=", "10", ",", "\n", "linestyle", "=", "\"-\"", ",", "legend_out", "=", "False", ",", "order", "=", "[", "\"Baseline\"", ",", "\"Remove\\ngrayscale\"", ",", "\"Remove\\ncolor\"", ",", "\"Crop + blur\\nonly\"", ",", "\"Crop\\nonly\"", "]", ")", "\n", "\n", "#sets axis labels and title of graph", "\n", "fig", ".", "set", "(", "xlabel", "=", "'Augmentation Sets'", ",", "ylabel", "=", "'Change of Accuracy from Baseline'", ",", "title", "=", "options", "[", "'data_name'", "]", ".", "replace", "(", "\"_\"", ",", "\" \"", ")", ".", "title", "(", ")", ")", "\n", "# fig._legend.set_title(\"Basetrain\")", "\n", "fig", ".", "ax", ".", "legend", "(", "loc", "=", "3", ",", "title", "=", "\"Basetrain\"", ",", "fontsize", "=", "\"x-small\"", ")", "\n", "\n", "#gets rid of other graph created ", "\n", "plt", ".", "close", "(", "1", ")", "\n", "\n", "#creates output file", "\n", "outplot", "=", "os", ".", "path", ".", "join", "(", "lin_dir", ",", "'{}_{}.pdf'", ".", "format", "(", "options", "[", "'data_name'", "]", ",", "\"no_supervised\"", ")", ")", "\n", "\n", "#saves Figure 1, but Figure 1 is the empty graph created (NOT SNS Graph)", "\n", "fig", ".", "savefig", "(", "outplot", ",", "format", "=", "'pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_augmentation.set_size": [[60, 93], ["None"], "function", ["None"], ["", "def", "set_size", "(", "width", ",", "fraction", "=", "1", ")", ":", "\n", "    ", "\"\"\" Set figure dimensions to avoid scaling in LaTeX.\n\n    Parameters\n    ----------\n    width: float\n            Document textwidth or columnwidth in pts\n    fraction: float, optional\n            Fraction of the width which you wish the figure to occupy\n\n    Returns\n    -------\n    fig_dim: tuple\n            Dimensions of figure in inches\n    \"\"\"", "\n", "# Width of figure (in pts)", "\n", "fig_width_pt", "=", "width", "*", "fraction", "\n", "\n", "# Convert from pt to inches", "\n", "inches_per_pt", "=", "1", "/", "72.27", "\n", "\n", "# Golden ratio to set aesthetic figure height", "\n", "# https://disq.us/p/2940ij3", "\n", "golden_ratio", "=", "(", "5", "**", ".5", "-", "1", ")", "/", "2", "\n", "\n", "# Figure width in inches", "\n", "fig_width_in", "=", "fig_width_pt", "*", "inches_per_pt", "\n", "# Figure height in inches", "\n", "fig_height_in", "=", "fig_width_in", "*", "golden_ratio", "\n", "\n", "fig_dim", "=", "(", "fig_width_in", ",", "fig_height_in", ")", "\n", "\n", "return", "fig_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_augmentation.setup_plot": [[94, 96], ["matplotlib.pyplot.subplots", "plot_augmentation.set_size"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain.set_size"], ["", "def", "setup_plot", "(", "width", "=", "300", ")", ":", "\n", "    ", "return", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "set_size", "(", "width", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_augmentation.reduce": [[97, 107], ["data[].tolist", "float", "float"], "function", ["None"], ["", "def", "reduce", "(", "data", ")", ":", "\n", "    ", "result", "=", "data", "[", "'result'", "]", ".", "tolist", "(", ")", "\n", "\n", "best", "=", "0", "\n", "for", "value", "in", "result", ":", "\n", "        ", "if", "best", "<", "float", "(", "value", ")", ":", "\n", "            ", "best", "=", "float", "(", "value", ")", "\n", "\n", "", "", "data", ".", "result", "=", "best", "\n", "return", "data", ",", "best", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_augmentation.main": [[108, 250], ["os.makedirs", "seaborn.set_style", "seaborn.set", "glob.glob", "glob.glob", "glob.glob", "result_files.append", "pandas.concat", "print", "print", "print", "print", "plot_augmentation.gen_plots", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "print", "pandas.DataFrame", "len", "pd.concat.astype", "pd.concat.basetrain.replace", "pd.concat.basetrain.replace", "pd.concat.basetrain.replace", "pd.concat.basetrain.replace", "frames.append", "print", "print", "pandas.concat", "pandas.concat", "open", "json.load", "json.load.values", "plot_augmentation.reduce", "plot_augmentation.reduce", "types.append", "types.append", "pandas.concat", "plot_augmentation.reduce", "types.append"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.gen_plots", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.reduce", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.reduce", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.reduce"], ["", "def", "main", "(", "args", ")", ":", "\n", "\n", "#must pass in dataset arg for proper results", "\n", "\n", "    ", "os", ".", "makedirs", "(", "args", ".", "out_dir", ",", "exist_ok", "=", "True", ")", "\n", "# setup plots", "\n", "sns", ".", "set_style", "(", "'darkgrid'", ")", "\n", "sns", ".", "set", "(", ")", "\n", "\n", "frames", "=", "[", "]", "#array that collects dataframes from each file", "\n", "if", "(", "args", ".", "dataset", "==", "\"all\"", ")", ":", "\n", "        ", "dataset_type", "=", "\"*\"", "\n", "", "else", ":", "\n", "        ", "dataset_type", "=", "args", ".", "dataset", "\n", "\n", "#gets all files that start with \"resisc_\" (still need a file with the baseline results)", "\n", "# result_files = glob.glob(os.path.join(args.results_dir, dataset_type + \"*.json\"), recursive=True)", "\n", "", "result_files1", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "dataset_type", "+", "\"*crop*.json\"", ")", ",", "recursive", "=", "True", ")", "\n", "result_files2", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "dataset_type", "+", "\"*color*.json\"", ")", ",", "recursive", "=", "True", ")", "\n", "result_files3", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "dataset_type", "+", "\"*gray*.json\"", ")", ",", "recursive", "=", "True", ")", "\n", "result_files", "=", "result_files1", "+", "result_files2", "+", "result_files3", "\n", "result_files", ".", "append", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "dataset_type", "+", "\"_results.json\"", ")", ")", "\n", "\n", "moco_baseline", "=", "imagenet_baseline", "=", "nobt_baseline", "=", "0", "\n", "\n", "for", "resfile", "in", "result_files", ":", "\n", "        ", "with", "open", "(", "resfile", ",", "'r'", ")", "as", "infile", ":", "\n", "            ", "raw_data", "=", "json", ".", "load", "(", "infile", ")", "\n", "\n", "", "print", "(", "resfile", ")", "\n", "\n", "types", "=", "[", "]", "#used for concatenating the resultzs from each basetrained model", "\n", "data", "=", "pd", ".", "DataFrame", "(", "raw_data", ".", "values", "(", ")", ")", "\n", "\n", "\n", "#finds the relevant values for moco bt, imagenet supervised bt, and no bt", "\n", "#mainly done to work around the baseline json file (has extra info that we don't want)", "\n", "if", "(", "dataset_type", "+", "\"_results.json\"", ")", "in", "resfile", ":", "\n", "            ", "linear_data", "=", "data", "[", "data", ".", "result_type", "==", "'linear-eval'", "]", "\n", "linear_data", "=", "linear_data", "[", "linear_data", ".", "variant", "==", "\"linear-eval-lr\"", "]", "\n", "\n", "data_moco", "=", "linear_data", "[", "data", ".", "basetrain", "==", "\"moco_v2_800ep\"", "]", "\n", "data_moco", "=", "data_moco", "[", "data_moco", ".", "pretrain_iters", "==", "\"5000\"", "]", "\n", "data_moco", "=", "data_moco", "[", "data_moco", ".", "pretrain_data", "==", "dataset_type", "]", "\n", "data_moco", ",", "moco_baseline", "=", "reduce", "(", "data_moco", ")", "\n", "\n", "if", "args", ".", "basetrain", "==", "'supervised'", ":", "\n", "                ", "data_imagenet", "=", "linear_data", "[", "data", ".", "basetrain", "==", "\"imagenet_r50_supervised\"", "]", "\n", "data_imagenet", "=", "data_imagenet", "[", "data_imagenet", ".", "pretrain_iters", "==", "\"50000\"", "]", "\n", "data_imagenet", "=", "data_imagenet", "[", "data_imagenet", ".", "pretrain_data", "==", "dataset_type", "]", "\n", "data_imagenet", ",", "imagenet_baseline", "=", "reduce", "(", "data_imagenet", ")", "\n", "types", ".", "append", "(", "data_imagenet", ")", "\n", "\n", "", "data_nobt", "=", "linear_data", "[", "data", ".", "basetrain", "==", "\"no\"", "]", "\n", "data_nobt", "=", "data_nobt", "[", "data_nobt", ".", "pretrain_iters", "==", "\"100000\"", "]", "\n", "data_nobt", "=", "data_nobt", "[", "data_nobt", ".", "pretrain_data", "==", "dataset_type", "]", "\n", "data_nobt", ",", "nobt_baseline", "=", "reduce", "(", "data_nobt", ")", "\n", "\n", "\n", "#appended to list ", "\n", "types", ".", "append", "(", "data_moco", ")", "\n", "types", ".", "append", "(", "data_nobt", ")", "\n", "\n", "#all concat to new dataframe ", "\n", "data", "=", "pd", ".", "concat", "(", "types", ",", "ignore_index", "=", "True", ")", "\n", "\n", "#used to add new column called aug_type", "\n", "", "aug_type", "=", "[", "]", "\n", "num_rows", "=", "len", "(", "data", ")", "\n", "\n", "#adds an aug-type column, which is used for catplot in gen_plot", "\n", "if", "\"crop_only\"", "in", "resfile", ":", "\n", "            ", "aug_type", "=", "[", "\"Crop\\nonly\"", "]", "*", "num_rows", "\n", "", "elif", "\"crop_blur\"", "in", "resfile", ":", "\n", "            ", "aug_type", "=", "[", "\"Crop + blur\\nonly\"", "]", "*", "num_rows", "\n", "", "elif", "\"rm_gray\"", "in", "resfile", ":", "\n", "            ", "aug_type", "=", "[", "\"Remove\\ngrayscale\"", "]", "*", "num_rows", "\n", "", "elif", "\"rm_color\"", "in", "resfile", ":", "\n", "            ", "aug_type", "=", "[", "\"Remove\\ncolor\"", "]", "*", "num_rows", "\n", "", "else", ":", "\n", "            ", "aug_type", "=", "[", "\"Baseline\"", "]", "*", "num_rows", "\n", "\n", "", "data", "[", "\"aug_type\"", "]", "=", "aug_type", "\n", "\n", "\n", "#get baseline and update results", "\n", "\n", "data", "=", "data", ".", "astype", "(", "{", "\n", "\"pretrain_iters\"", ":", "int", "\n", "}", ")", "\n", "\n", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"imagenet_r50_supervised\"", ",", "\"supervised imagenet init\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"moco_v2_800ep\"", ",", "\"HPT\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"no\"", ",", "\"MoCo Random Init\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"none\"", ",", "\"MoCo Random Init\"", ")", "\n", "frames", ".", "append", "(", "data", ")", "\n", "\n", "#combines all the dataframes from each file into 1 large dataframe", "\n", "", "result", "=", "pd", ".", "concat", "(", "frames", ",", "ignore_index", "=", "True", ")", "\n", "\n", "\n", "#changes all the dataset names to dataset_augmentation", "\n", "result", ".", "dataset", "=", "dataset_type", "+", "\"_augmentation\"", "\n", "\n", "#prints new concatenated dataframe ", "\n", "print", "(", "result", ")", "\n", "print", "(", "not", "(", "result", ".", "result", ">", "1", ")", ".", "all", "(", ")", ")", "\n", "\n", "mult100", "=", "False", "\n", "if", "not", "(", "result", ".", "result", ">", "1", ")", ".", "all", "(", ")", ":", "\n", "        ", "mult100", "=", "True", "\n", "\n", "", "if", "args", ".", "basetrain", "==", "'supervised'", ":", "\n", "        ", "print", "(", "moco_baseline", ",", "imagenet_baseline", ",", "nobt_baseline", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "moco_baseline", ",", "nobt_baseline", ")", "\n", "\n", "\n", "\n", "", "result_moco", "=", "result", "[", "result", ".", "basetrain", "==", "\"HPT\"", "]", "\n", "result_moco", ".", "result", "=", "result_moco", ".", "result", "-", "moco_baseline", "\n", "\n", "result_nobt", "=", "result", "[", "result", ".", "basetrain", "==", "\"MoCo Random Init\"", "]", "\n", "result_nobt", ".", "result", "=", "result_nobt", ".", "result", "-", "nobt_baseline", "\n", "\n", "if", "args", ".", "basetrain", "==", "'supervised'", ":", "\n", "        ", "result_imagenet", "=", "result", "[", "result", ".", "basetrain", "==", "\"supervised imagenet init\"", "]", "\n", "result_imagenet", ".", "result", "=", "result_imagenet", ".", "result", "-", "imagenet_baseline", "\n", "result", "=", "pd", ".", "concat", "(", "[", "result_moco", ",", "result_imagenet", ",", "result_nobt", "]", ",", "ignore_index", "=", "True", ")", "\n", "", "else", ":", "\n", "        ", "result", "=", "pd", ".", "concat", "(", "[", "result_moco", ",", "result_nobt", "]", ",", "ignore_index", "=", "True", ")", "\n", "", "dataname", "=", "result", ".", "dataset", "[", "0", "]", "\n", "\n", "if", "mult100", ":", "\n", "        ", "result", ".", "result", "*=", "100", "\n", "", "print", "(", "result", ".", "result", ")", "\n", "print", "(", "result", ")", "\n", "\n", "gen_plots", "(", "result", ",", "{", "\n", "'out_dir'", ":", "args", ".", "out_dir", ",", "\n", "'data_name'", ":", "dataname", ",", "\n", "}", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain.parse_args": [[14, 28], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "os.path.realpath", "os.path.realpath", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "''", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--results-dir'", ",", "\n", "default", "=", "os", ".", "path", ".", "realpath", "(", "os", ".", "path", ".", "join", "(", "dir_path", ",", "\"..\"", ",", "\"results\"", ")", ")", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--out-dir'", ",", "\n", "default", "=", "os", ".", "path", ".", "realpath", "(", "os", ".", "path", ".", "join", "(", "dir_path", ",", "\"..\"", ",", "\"plot-results\"", ")", ")", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--dataset'", ",", "\n", "default", "=", "\"all\"", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain.logit_y_axis": [[29, 35], ["matplotlib.pyplot.yscale", "matplotlib.pyplot.gca().yaxis.set_ticklabels", "matplotlib.pyplot.yticks", "round", "matplotlib.pyplot.gca"], "function", ["None"], ["", "def", "logit_y_axis", "(", "yfact", "=", "100", ")", ":", "\n", "# logit y axes with readable labels", "\n", "    ", "plt", ".", "yscale", "(", "'logit'", ")", "\n", "tickvals", "=", "plt", ".", "yticks", "(", ")", "[", "0", "]", "\n", "ylabs", "=", "[", "\"{}\"", ".", "format", "(", "round", "(", "v", "*", "yfact", ")", ")", "for", "v", "in", "tickvals", "]", "\n", "plt", ".", "gca", "(", ")", ".", "yaxis", ".", "set_ticklabels", "(", "ylabs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain.gen_plots": [[37, 74], ["os.path.join", "os.makedirs", "linear_data.pretrain_data.unique", "plot_pct_pretrain.setup_plot", "seaborn.lineplot", "matplotlib.pyplot.axhline", "matplotlib.pyplot.xlabel", "matplotlib.pyplot.ylabel", "matplotlib.pyplot.title", "matplotlib.pyplot.xscale", "matplotlib.pyplot.xticks", "ax.get_legend_handles_labels", "matplotlib.pyplot.legend", "matplotlib.pyplot.show", "os.path.join", "print", "fig.savefig", "options[].replace().title", "options[].replace"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain.setup_plot"], ["", "def", "gen_plots", "(", "data", ",", "options", ")", ":", "\n", "\n", "# linear plots", "\n", "    ", "lin_dir", "=", "os", ".", "path", ".", "join", "(", "options", "[", "'out_dir'", "]", ",", "'pretrain_robustness'", ")", "\n", "os", ".", "makedirs", "(", "lin_dir", ",", "exist_ok", "=", "True", ")", "\n", "linear_data", "=", "data", "[", "data", ".", "result_type", "==", "'linear-eval'", "]", "\n", "for", "pretrain_data", "in", "linear_data", ".", "pretrain_data", ".", "unique", "(", ")", ":", "\n", "        ", "for", "variant", "in", "[", "\"linear-eval-lr\"", "]", ":", "# linear_data['variant'].unique():", "\n", "            ", "variant_data", "=", "linear_data", "[", "(", "linear_data", ".", "variant", "==", "variant", ")", "&", "(", "linear_data", ".", "pretrain_data", "==", "pretrain_data", ")", "]", "\n", "# hack to \"clean up\" other analyses ", "\n", "variant_data", "=", "variant_data", "[", "(", "linear_data", ".", "basetrain", "==", "'MoCo Random Init'", ")", "|", "(", "linear_data", ".", "basetrain", "==", "'HPT'", ")", "|", "(", "linear_data", ".", "basetrain", "==", "'supervised imagenet init'", ")", "|", "(", "linear_data", ".", "basetrain", "==", "'HPT-BN'", ")", "]", "\n", "# fig, ax = setup_plot(500)", "\n", "# print(variant_data)", "\n", "fig", ",", "ax", "=", "setup_plot", "(", "600", ")", "\n", "\n", "# variant_data.groupby(\"basetrain\").plot(x=\"pretrain_iters\", y=\"result\", marker=\"o\", ax=ax)", "\n", "sns", ".", "lineplot", "(", "x", "=", "'pct_train'", ",", "y", "=", "'result'", ",", "hue", "=", "'basetrain'", ",", "data", "=", "variant_data", ",", "marker", "=", "'o'", ",", "mew", "=", "0", ",", "ms", "=", "5", ")", "\n", "# fig.set(xlabel='Percent of Pretrain data', ylabel='Change of Accuracy from Baseline', title=options['data_name'].replace(\"_\", \" \").title())", "\n", "# plt.close(1) ", "\n", "plt", ".", "axhline", "(", "y", "=", "options", "[", "'asymptote'", "]", ",", "c", "=", "'red'", ",", "linestyle", "=", "'dashed'", ",", "label", "=", "\"MoCo Direct Transfer\"", ")", "\n", "\n", "plt", ".", "xlabel", "(", "\"Percentage of Pretrain Data\"", ")", "\n", "plt", ".", "ylabel", "(", "\"Accuracy\"", ")", "\n", "plt", ".", "title", "(", "options", "[", "'data_name'", "]", ".", "replace", "(", "\"_\"", ",", "\" \"", ")", ".", "title", "(", ")", ")", "\n", "\n", "\n", "\n", "plt", ".", "xscale", "(", "'linear'", ")", "\n", "plt", ".", "xticks", "(", "ticks", "=", "variant_data", "[", "'pct_train'", "]", ",", "labels", "=", "variant_data", "[", "'pct_train'", "]", ",", "rotation", "=", "'horizontal'", ")", "\n", "\n", "labels", "=", "[", "\"HPT\"", ",", "\"HPT-BN\"", ",", "\"MoCo Random Init\"", ",", "\"MoCo Direct Transfer\"", "]", "\n", "handles", ",", "_", "=", "ax", ".", "get_legend_handles_labels", "(", ")", "\n", "plt", ".", "legend", "(", "handles", "=", "handles", ",", "labels", "=", "labels", ",", "title", "=", "\"Basetrain\"", ")", "\n", "plt", ".", "show", "(", ")", "\n", "outplot", "=", "os", ".", "path", ".", "join", "(", "lin_dir", ",", "'{}_data_robustness-{}_linear_eval.pdf'", ".", "format", "(", "pretrain_data", ",", "options", "[", "'data_name'", "]", ")", ")", "\n", "print", "(", "outplot", ")", "\n", "fig", ".", "savefig", "(", "outplot", ",", "format", "=", "'pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain.set_size": [[75, 108], ["None"], "function", ["None"], ["", "", "", "def", "set_size", "(", "width", ",", "fraction", "=", "1", ")", ":", "\n", "    ", "\"\"\" Set figure dimensions to avoid scaling in LaTeX.\n\n    Parameters\n    ----------\n    width: float\n            Document textwidth or columnwidth in pts\n    fraction: float, optional\n            Fraction of the width which you wish the figure to occupy\n\n    Returns\n    -------\n    fig_dim: tuple\n            Dimensions of figure in inches\n    \"\"\"", "\n", "# Width of figure (in pts)", "\n", "fig_width_pt", "=", "width", "*", "fraction", "\n", "\n", "# Convert from pt to inches", "\n", "inches_per_pt", "=", "1", "/", "72.27", "\n", "\n", "# Golden ratio to set aesthetic figure height", "\n", "# https://disq.us/p/2940ij3", "\n", "golden_ratio", "=", "(", "5", "**", ".5", "-", "1", ")", "/", "2", "\n", "\n", "# Figure width in inches", "\n", "fig_width_in", "=", "fig_width_pt", "*", "inches_per_pt", "\n", "# Figure height in inches", "\n", "fig_height_in", "=", "fig_width_in", "*", "golden_ratio", "\n", "\n", "fig_dim", "=", "(", "fig_width_in", ",", "fig_height_in", ")", "\n", "\n", "return", "fig_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain.reduce": [[109, 116], ["data.iterrows"], "function", ["None"], ["", "def", "reduce", "(", "data", ")", ":", "\n", "    ", "best", "=", "0", "\n", "for", "i", ",", "row", "in", "data", ".", "iterrows", "(", ")", ":", "\n", "        ", "if", "best", "<", "row", "[", "'result'", "]", ":", "\n", "            ", "best", "=", "row", "[", "'result'", "]", "\n", "\n", "", "", "return", "data", "[", "data", ".", "result", "==", "best", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain.setup_plot": [[118, 120], ["matplotlib.pyplot.subplots", "plot_pct_pretrain.set_size"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain.set_size"], ["", "def", "setup_plot", "(", "width", "=", "300", ")", ":", "\n", "    ", "return", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "set_size", "(", "width", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_pct_pretrain.main": [[122, 281], ["os.makedirs", "seaborn.set_style", "seaborn.set", "glob.glob", "glob.glob.append", "pandas.concat", "pd.concat.iterrows", "pct1[].max", "pct10[].max", "pct25[].max", "pandas.concat", "pct1_bn[].max", "pct10_bn[].max", "pct25_bn[].max", "pct100_bn[].max", "pandas.concat", "pandas.concat", "print", "print", "print", "print", "plot_pct_pretrain.gen_plots", "os.path.join", "os.path.join", "glob.glob.append", "print", "pandas.DataFrame", "pd.concat.astype", "pd.concat.basetrain.replace", "pd.concat.basetrain.replace", "pd.concat.basetrain.replace", "frames.append", "len", "pandas.concat", "os.path.join", "open", "json.load", "json.load.values", "plot_pct_pretrain.reduce", "plot_pct_pretrain.reduce", "types.append", "types.append", "pandas.concat", "print", "pd.concat.basetrain.replace"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.gen_plots", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.reduce", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.reduce"], ["", "def", "main", "(", "args", ")", ":", "\n", "\n", "#must pass in dataset arg for proper results", "\n", "\n", "    ", "os", ".", "makedirs", "(", "args", ".", "out_dir", ",", "exist_ok", "=", "True", ")", "\n", "# setup plots", "\n", "sns", ".", "set_style", "(", "'darkgrid'", ")", "\n", "sns", ".", "set", "(", ")", "\n", "\n", "frames", "=", "[", "]", "#array that collects dataframes from each file", "\n", "if", "(", "args", ".", "dataset", "==", "\"all\"", ")", ":", "\n", "        ", "dataset_type", "=", "\"*\"", "\n", "", "else", ":", "\n", "        ", "dataset_type", "=", "args", ".", "dataset", "\n", "\n", "#gets all files that start with \"*pct\" for the corresponding dataset", "\n", "", "result_files", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "dataset_type", "+", "\"*pct*.json\"", ")", ",", "recursive", "=", "True", ")", "\n", "result_files", ".", "append", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "dataset_type", "+", "\"_results.json\"", ")", ")", "#gets file with 100% pretrain data results", "\n", "if", "(", "dataset_type", "!=", "'resisc'", ")", ":", "\n", "        ", "result_files", ".", "append", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "dataset_type", "+", "\"_bn_results.json\"", ")", ")", "\n", "", "for", "resfile", "in", "result_files", ":", "\n", "        ", "with", "open", "(", "resfile", ",", "'r'", ")", "as", "infile", ":", "\n", "            ", "raw_data", "=", "json", ".", "load", "(", "infile", ")", "\n", "\n", "", "print", "(", "resfile", ")", "\n", "\n", "types", "=", "[", "]", "#used for concatenating the resultzs from each basetrained model", "\n", "data", "=", "pd", ".", "DataFrame", "(", "raw_data", ".", "values", "(", ")", ")", "\n", "\n", "\n", "#finds the relevant values for moco bt, and no bt", "\n", "#mainly done to work around the baseline json file (has extra info that we don't want)", "\n", "if", "(", "dataset_type", "+", "\"_results.json\"", ")", "in", "resfile", ":", "\n", "            ", "linear_data", "=", "data", "[", "data", ".", "result_type", "==", "'linear-eval'", "]", "\n", "linear_data", "=", "linear_data", "[", "linear_data", ".", "variant", "==", "\"linear-eval-lr\"", "]", "\n", "\n", "data_moco", "=", "linear_data", "[", "data", ".", "basetrain", "==", "\"moco_v2_800ep\"", "]", "\n", "# data_moco = data_moco[data_moco.pretrain_iters==\"5000\"]", "\n", "data_moco", "=", "data_moco", "[", "data_moco", ".", "pretrain_data", "==", "dataset_type", "]", "\n", "data_moco", "=", "reduce", "(", "data_moco", ")", "\n", "\n", "\n", "data_nobt", "=", "linear_data", "[", "data", ".", "basetrain", "==", "\"no\"", "]", "\n", "# data_nobt= data_nobt[data_nobt.pretrain_iters==\"100000\"]", "\n", "data_nobt", "=", "data_nobt", "[", "data_nobt", ".", "pretrain_data", "==", "dataset_type", "]", "\n", "data_nobt", "=", "reduce", "(", "data_nobt", ")", "\n", "\n", "\n", "#appended to list ", "\n", "types", ".", "append", "(", "data_moco", ")", "\n", "types", ".", "append", "(", "data_nobt", ")", "\n", "\n", "#all concat to new dataframe ", "\n", "data", "=", "pd", ".", "concat", "(", "types", ",", "ignore_index", "=", "True", ")", "\n", "print", "(", "data", ")", "\n", "\n", "", "if", "\"bn\"", "in", "resfile", ":", "\n", "            ", "data_bn", "=", "data", "[", "data", ".", "pretrain_iters", "!=", "'0'", "]", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"moco_v2_800ep\"", ",", "\"HPT-BN\"", ")", "\n", "\n", "#convert pretrain iters values to int", "\n", "\n", "", "data", "=", "data", ".", "astype", "(", "{", "\n", "\"pretrain_iters\"", ":", "int", "\n", "}", ")", "\n", "\n", "#multiply all results < 1 by 100", "\n", "if", "not", "(", "data", ".", "result", ">", "1", ")", ".", "all", "(", ")", ":", "\n", "            ", "data", ".", "result", "*=", "100", "\n", "\n", "\n", "#change corresponding names of each basetrain ", "\n", "", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"moco_v2_800ep\"", ",", "\"HPT\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"no\"", ",", "\"MoCo Random Init\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"none\"", ",", "\"MoCo Random Init\"", ")", "\n", "frames", ".", "append", "(", "data", ")", "\n", "\n", "#combines all the dataframes from each file into 1 large dataframe", "\n", "", "result", "=", "pd", ".", "concat", "(", "frames", ",", "ignore_index", "=", "True", ")", "\n", "\n", "#add a column for pct pretrain data and iterate through each row to add appropriate value", "\n", "pct", "=", "[", "0", "]", "*", "len", "(", "result", ")", "\n", "asymptote", "=", "0", "\n", "count", "=", "0", "\n", "result", "[", "\"pct_train\"", "]", "=", "pct", "\n", "\n", "for", "i", ",", "row", "in", "result", ".", "iterrows", "(", ")", ":", "\n", "        ", "val", "=", "0", "\n", "if", "row", "[", "\"pretrain_iters\"", "]", "==", "0", ":", "\n", "            ", "asymptote", "+=", "row", "[", "\"result\"", "]", "\n", "count", "+=", "1", "\n", "continue", "\n", "", "if", "\"1_pct\"", "in", "row", "[", "\"dataset\"", "]", ":", "\n", "            ", "val", "=", "1", "\n", "", "elif", "\"10_pct\"", "in", "row", "[", "\"dataset\"", "]", ":", "\n", "            ", "val", "=", "10", "\n", "", "elif", "\"25_pct\"", "in", "row", "[", "\"dataset\"", "]", ":", "\n", "            ", "val", "=", "25", "\n", "", "else", ":", "\n", "            ", "val", "=", "100", "\n", "", "result", ".", "at", "[", "i", ",", "\"pct_train\"", "]", "=", "val", "\n", "\n", "", "result", "=", "result", "[", "result", "[", "'pretrain_iters'", "]", ">", "0", "]", "\n", "result", ".", "pretrain_data", "=", "dataset_type", "\n", "\n", "#changes entries to best performace ", "\n", "pct1", "=", "result", "[", "(", "result", "[", "'pct_train'", "]", "==", "1", ")", "&", "(", "result", "[", "'basetrain'", "]", "==", "\"HPT\"", ")", "]", "\n", "pct1", ".", "result", "=", "pct1", "[", "'result'", "]", ".", "max", "(", ")", "\n", "pct10", "=", "result", "[", "(", "result", "[", "'pct_train'", "]", "==", "10", ")", "&", "(", "result", "[", "'basetrain'", "]", "==", "\"HPT\"", ")", "]", "\n", "pct10", ".", "result", "=", "pct10", "[", "'result'", "]", ".", "max", "(", ")", "\n", "pct25", "=", "result", "[", "(", "result", "[", "'pct_train'", "]", "==", "25", ")", "&", "(", "result", "[", "'basetrain'", "]", "==", "\"HPT\"", ")", "]", "\n", "pct25", ".", "result", "=", "pct25", "[", "'result'", "]", ".", "max", "(", ")", "\n", "\n", "moco", "=", "pd", ".", "concat", "(", "[", "pct1", ",", "pct10", ",", "pct25", "]", ",", "ignore_index", "=", "True", ")", "\n", "\n", "pct1_bn", "=", "result", "[", "(", "result", "[", "'pct_train'", "]", "==", "1", ")", "&", "(", "result", "[", "'basetrain'", "]", "==", "\"HPT-BN\"", ")", "]", "\n", "pct1_bn", ".", "result", "=", "pct1_bn", "[", "'result'", "]", ".", "max", "(", ")", "\n", "pct10_bn", "=", "result", "[", "(", "result", "[", "'pct_train'", "]", "==", "10", ")", "&", "(", "result", "[", "'basetrain'", "]", "==", "\"HPT-BN\"", ")", "]", "\n", "pct10_bn", ".", "result", "=", "pct10_bn", "[", "'result'", "]", ".", "max", "(", ")", "\n", "pct25_bn", "=", "result", "[", "(", "result", "[", "'pct_train'", "]", "==", "25", ")", "&", "(", "result", "[", "'basetrain'", "]", "==", "\"HPT-BN\"", ")", "]", "\n", "pct25_bn", ".", "result", "=", "pct25_bn", "[", "'result'", "]", ".", "max", "(", ")", "\n", "pct100_bn", "=", "result", "[", "(", "result", "[", "'pct_train'", "]", "==", "100", ")", "&", "(", "result", "[", "'basetrain'", "]", "==", "\"HPT-BN\"", ")", "]", "\n", "pct100_bn", ".", "result", "=", "pct100_bn", "[", "'result'", "]", ".", "max", "(", ")", "\n", "\n", "bn", "=", "pd", ".", "concat", "(", "[", "pct1_bn", ",", "pct10_bn", ",", "pct25_bn", ",", "pct100_bn", "]", ",", "ignore_index", "=", "True", ")", "\n", "\n", "\n", "\n", "\n", "#keeps all the random inits in result pd", "\n", "result", "=", "result", "[", "(", "(", "result", "[", "'basetrain'", "]", "!=", "\"HPT\"", ")", "&", "(", "result", "[", "'basetrain'", "]", "!=", "\"HPT-BN\"", ")", ")", "|", "(", "result", "[", "'pct_train'", "]", "==", "100", ")", "]", "\n", "\n", "\n", "#hack for resisc bn 100% pretrain", "\n", "if", "dataset_type", "==", "'resisc'", ":", "\n", "        ", "pct100_bn", "=", "result", "[", "(", "result", "[", "'pct_train'", "]", "==", "100", ")", "&", "(", "result", "[", "'basetrain'", "]", "==", "\"HPT\"", ")", "]", "\n", "pct100_bn", ".", "basetrain", "=", "'HPT-BN'", "\n", "pct100_bn", ".", "result", "=", "92.50794", "\n", "bn", "=", "pd", ".", "concat", "(", "[", "bn", ",", "pct100_bn", "]", ",", "ignore_index", "=", "True", ")", "\n", "\n", "", "result", "=", "pd", ".", "concat", "(", "[", "moco", ",", "bn", ",", "result", "]", ",", "ignore_index", "=", "True", ")", "\n", "\n", "\n", "\n", "\n", "#prints new concatenated dataframe ", "\n", "print", "(", "result", ")", "\n", "print", "(", "result", ".", "result", ")", "\n", "print", "(", "result", ".", "basetrain", ")", "\n", "\n", "\n", "dataname", "=", "dataset_type", "+", "\"_data_robustness\"", "\n", "asymptote", "/=", "count", "\n", "print", "(", "\"moco transfer:\"", ",", "asymptote", ")", "\n", "\n", "gen_plots", "(", "result", ",", "{", "\n", "'out_dir'", ":", "args", ".", "out_dir", ",", "\n", "'data_name'", ":", "dataname", ",", "\n", "'asymptote'", ":", "asymptote", "\n", "}", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.compute-dataset-pixel-mean-std.main": [[28, 64], ["torchvision.ImageFolder", "torch.utils.data.DataLoader", "torch.zeros", "len", "print", "print", "print", "print", "len", "data.sum", "print", "torchvision.Compose", "torchvision.ToTensor", "torchvision.Lambda", "torch.stack", "x.mean"], "function", ["None"], ["def", "main", "(", "args", ")", ":", "\n", "    ", "dataset", "=", "datasets", ".", "ImageFolder", "(", "args", ".", "data", ",", "transform", "=", "transforms", ".", "Compose", "(", "[", "transforms", ".", "ToTensor", "(", ")", ",", "transforms", ".", "Lambda", "(", "lambda", "x", ":", "torch", ".", "stack", "(", "[", "x", ".", "mean", "(", "[", "1", ",", "2", "]", ")", ",", "(", "x", "*", "x", ")", ".", "mean", "(", "[", "1", ",", "2", "]", ")", "]", ")", ")", "]", ")", ")", "# x.view(x.shape[0], -1))]))", "\n", "\n", "loader", "=", "DataLoader", "(", "\n", "dataset", ",", "\n", "batch_size", "=", "args", ".", "batchsize", ",", "\n", "num_workers", "=", "args", ".", "numworkers", ",", "\n", "shuffle", "=", "True", "\n", ")", "\n", "\n", "mean", "=", "0.", "\n", "nb_samples", "=", "0.", "\n", "results", "=", "torch", ".", "zeros", "(", "(", "2", ",", "3", ")", ")", "\n", "N", "=", "len", "(", "dataset", ")", "\n", "Nproc", "=", "0", "\n", "i", "=", "0", "\n", "if", "args", ".", "numbatches", "<", "0", ":", "\n", "        ", "NB", "=", "len", "(", "loader", ")", "\n", "", "else", ":", "\n", "        ", "NB", "=", "args", ".", "numbatches", "\n", "", "for", "data", ",", "_", "in", "loader", ":", "\n", "        ", "results", "+=", "data", ".", "sum", "(", "0", ")", "\n", "Nproc", "+=", "data", ".", "shape", "[", "0", "]", "\n", "i", "+=", "1", "\n", "print", "(", "\"batch: {}/{}\"", ".", "format", "(", "i", ",", "NB", ")", ")", "\n", "if", "i", ">=", "NB", ":", "\n", "            ", "break", "\n", "\n", "", "", "print", "(", "results", ")", "\n", "means", "=", "results", "[", "0", ",", ":", "]", "/", "Nproc", "\n", "sqsums", "=", "results", "[", "1", ",", ":", "]", "/", "Nproc", "\n", "vvars", "=", "sqsums", "-", "means", "**", "2", "\n", "print", "(", "'means: {}'", ".", "format", "(", "means", ")", ")", "\n", "print", "(", "'vars: {}'", ".", "format", "(", "vvars", ")", ")", "\n", "stds", "=", "vvars", "**", "0.5", "\n", "print", "(", "'stds: {}'", ".", "format", "(", "stds", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.extract-tf-splits-direct.main": [[19, 30], ["tensorflow_datasets.load", "filenames.append", "open", "outputf.write", "image[].numpy"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write"], ["def", "main", "(", "args", ")", ":", "\n", "    ", "ds", "=", "tfds", ".", "load", "(", "args", ".", "dataid", ",", "split", "=", "args", ".", "split", ")", "\n", "# Build your input pipeline", "\n", "filenames", "=", "[", "]", "\n", "# ds = ds.take(1)", "\n", "for", "image", "in", "ds", ":", "\n", "        ", "filenames", ".", "append", "(", "image", "[", "'filename'", "]", ".", "numpy", "(", ")", ")", "\n", "\n", "\n", "", "with", "open", "(", "args", ".", "outfile", ",", "\"wb\"", ")", "as", "outputf", ":", "\n", "        ", "outputf", ".", "write", "(", "b\"\\n\"", ".", "join", "(", "filenames", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot.multi_plot": [[19, 67], ["len", "print", "matplotlib.figure", "matplotlib.subplots_adjust", "matplotlib.savefig", "os.walk", "root.endswith", "os.listdir", "print", "os.listdir", "os.path.join", "print", "range", "matplotlib.subplot", "matplotlib.title", "matplotlib.ylabel", "matplotlib.xlabel", "matplotlib.plot", "matplotlib.plot", "matplotlib.legend", "matplotlib.ylim", "matplotlib.grid", "matplotlib.subplots_adjust", "line.strip", "len", "open", "top1_lst.append", "float", "len", "os.path.basename", "[].strip", "numpy.argmax", "line.split"], "function", ["None"], ["def", "multi_plot", "(", "root", ")", ":", "\n", "    ", "root_dir", "=", "root", "\n", "num", "=", "len", "(", "[", "fn", "for", "fn", "in", "os", ".", "listdir", "(", "root_dir", ")", "if", "\".pth\"", "in", "fn", "]", ")", "\n", "print", "(", "num", ")", "\n", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "17", ",", "60", ")", ")", "\n", "plt_idx", "=", "1", "\n", "try", ":", "\n", "        ", "for", "root", ",", "_", ",", "files", "in", "os", ".", "walk", "(", "root_dir", ")", ":", "\n", "            ", "if", "root", ".", "endswith", "(", "\".pth\"", ")", ":", "\n", "                ", "print", "(", "root", ")", "\n", "for", "fname", "in", "os", ".", "listdir", "(", "root", ")", ":", "\n", "                    ", "if", "'train'", "in", "fname", "and", "'.log'", "in", "fname", ":", "\n", "                        ", "json_name", "=", "os", ".", "path", ".", "join", "(", "root", ",", "fname", ")", "\n", "\n", "lines", "=", "[", "line", ".", "strip", "(", ")", "for", "line", "in", "open", "(", "json_name", ")", "]", "\n", "idx", "=", "0", "\n", "val_top1", ",", "val_top5", ",", "test_top1", ",", "test_top5", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "top1_lst", "=", "[", "]", "\n", "for", "line", "in", "lines", ":", "\n", "                            ", "if", "\"- head0_top1\"", "in", "line", ":", "\n", "                                ", "top1_lst", ".", "append", "(", "float", "(", "line", ".", "split", "(", "\":\"", ")", "[", "-", "1", "]", ".", "strip", "(", ")", ")", ")", "\n", "", "", "val_top1", "=", "top1_lst", "[", ":", ":", "2", "]", "\n", "test_top1", "=", "top1_lst", "[", "1", ":", ":", "2", "]", "\n", "print", "(", "f\"=====> length of val_top1 is: {len(val_top1)}\"", ")", "\n", "\n", "x", "=", "range", "(", "len", "(", "val_top1", ")", ")", "\n", "\n", "plt", ".", "subplot", "(", "num", ",", "2", ",", "plt_idx", ")", "\n", "\n", "plt", ".", "title", "(", "basename", "(", "root", ")", "[", ":", "-", "4", "]", "+", "f\"\\nMax : {test_top1[np.argmax(val_top1)]}\"", ")", "\n", "plt", ".", "ylabel", "(", "\"accuracy\"", ")", "\n", "plt", ".", "xlabel", "(", "\"epochs\"", ")", "\n", "\n", "plt", ".", "plot", "(", "x", ",", "val_top1", ",", "'-b'", ",", "label", "=", "'val_top1'", ")", "\n", "plt", ".", "plot", "(", "x", ",", "test_top1", ",", "'-r'", ",", "label", "=", "'test_top1'", ")", "\n", "plt", ".", "legend", "(", ")", "\n", "plt", ".", "ylim", "(", "0", ",", "100", ")", "\n", "plt", ".", "grid", "(", "color", "=", "'k'", ",", "linestyle", "=", "'--'", ",", "linewidth", "=", "0.4", ")", "\n", "plt_idx", "+=", "1", "\n", "\n", "plt", ".", "subplots_adjust", "(", "bottom", "=", "0.1", ",", "right", "=", "0.8", ",", "top", "=", "0.96", ",", "hspace", "=", "0.9", ",", "wspace", "=", "0.3", ")", "\n", "\n", "", "", "", "", "", "except", ":", "\n", "        ", "pass", "\n", "", "plt", ".", "subplots_adjust", "(", "bottom", "=", "0.1", ",", "right", "=", "0.8", ",", "top", "=", "0.96", ",", "hspace", "=", "0.9", ",", "wspace", "=", "0.3", ")", "\n", "plt", ".", "savefig", "(", "args", ".", "fname", ")", "\n", "#     plt.tight_layout()", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.agg-results-to-final-json.parse_args": [[8, 19], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Parse agg results files into a friendly formatted results json for each dataset'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--agg-file'", ",", "\n", "required", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--outdir'", ",", "\n", "required", "=", "True", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.agg-results-to-final-json.str_to_result": [[21, 75], ["inp_str.split", "inp_str.split.pop", "inp_fields[].replace", "inp_fields[].replace", "inp_str.split.pop().split", "inp_str.split.pop().split", "inp_str.split.pop", "[].strip", "inp_str.split.pop().split", "inp_str.split.pop", "len", "hierarchy[].replace", "int", "inp_fields.pop.split", "float", "inp_str.split.pop", "v.replace().replace", "len", "inp_str.split.pop", "len", "[].strip", "print", "inp_str.split.pop", "inp_fields.pop().split.pop", "inp_str.split", "v.replace", "[].split", "inp_fields.pop.split"], "function", ["None"], ["", "def", "str_to_result", "(", "inp_str", ",", "author", "=", "None", ")", ":", "\n", "    ", "result", "=", "{", "}", "\n", "inp_fields", "=", "inp_str", ".", "split", "(", "\"/\"", ")", "\n", "\n", "# WARNING: the filenames are brittle, so this is, err, brittle", "\n", "result", "[", "\"dataset\"", "]", "=", "inp_fields", ".", "pop", "(", "0", ")", ".", "split", "(", "\"-\"", ")", "[", "-", "1", "]", "\n", "result", "[", "\"result_type\"", "]", "=", "inp_fields", ".", "pop", "(", "0", ")", "\n", "\n", "if", "result", "[", "\"result_type\"", "]", "==", "\"finetune\"", ":", "\n", "        ", "result", "[", "\"subset\"", "]", "=", "inp_fields", ".", "pop", "(", "0", ")", "\n", "", "else", ":", "\n", "        ", "result", "[", "\"subset\"", "]", "=", "\"all\"", "\n", "\n", "# \"intelligently\" parse the basetrain field using hyphens", "\n", "", "inp_fields", "[", "0", "]", "=", "inp_fields", "[", "0", "]", ".", "replace", "(", "'-21352794'", ",", "'_21352794'", ")", "\n", "inp_fields", "[", "0", "]", "=", "inp_fields", "[", "0", "]", ".", "replace", "(", "'final_backbone_basetrain-'", ",", "''", ")", "\n", "\n", "hierarchy", "=", "inp_fields", ".", "pop", "(", "0", ")", ".", "split", "(", "\"-\"", ")", "\n", "if", "len", "(", "hierarchy", ")", "==", "1", ":", "\n", "        ", "result", "[", "\"basetrain\"", "]", "=", "hierarchy", "[", "0", "]", ".", "replace", "(", "\"_basetrain\"", ",", "\"\"", ")", "\n", "result", "[", "\"pretrain_data\"", "]", "=", "result", "[", "\"dataset\"", "]", "\n", "", "else", ":", "\n", "        ", "steps", "=", "[", "v", ".", "replace", "(", "\"_basetrain\"", ",", "\"\"", ")", ".", "replace", "(", "\"no\"", ",", "\"none\"", ")", "for", "v", "in", "hierarchy", "]", "\n", "# TODO(cjrd) generalize this", "\n", "if", "len", "(", "steps", ")", ">", "2", ":", "\n", "            ", "steps", "=", "[", "\"-\"", ".", "join", "(", "steps", "[", ":", "-", "1", "]", ")", ",", "steps", "[", "-", "1", "]", "]", "\n", "", "result", "[", "\"basetrain\"", "]", "=", "steps", "[", "0", "]", "\n", "result", "[", "\"pretrain_data\"", "]", "=", "steps", "[", "1", "]", "\n", "\n", "# \"int3lligently\" parse the model weight string", "\n", "", "details", "=", "inp_fields", ".", "pop", "(", "0", ")", ".", "split", "(", "\"-\"", ")", "\n", "result", "[", "\"pretrain_iters\"", "]", "=", "details", "[", "0", "]", "\n", "# check if the last bit is s0 or s1 etc", "\n", "if", "details", "[", "-", "1", "]", "[", "0", "]", "==", "\"s\"", "and", "len", "(", "details", "[", "-", "1", "]", ")", "==", "2", ":", "\n", "        ", "result", "[", "\"sample\"", "]", "=", "int", "(", "details", ".", "pop", "(", ")", "[", "-", "1", "]", ")", "\n", "\n", "", "else", ":", "\n", "        ", "result", "[", "\"sample\"", "]", "=", "0", "\n", "\n", "", "result", "[", "\"variant\"", "]", "=", "\"-\"", ".", "join", "(", "details", "[", "2", ":", "]", ")", "\n", "\n", "# remaining str: date result file", "\n", "remaining_str", "=", "inp_fields", ".", "pop", "(", "0", ")", "\n", "result", "[", "\"date\"", "]", "=", "remaining_str", ".", "split", "(", "\".\"", ")", "[", "0", "]", "\n", "try", ":", "\n", "        ", "result", "[", "\"result\"", "]", "=", "float", "(", "remaining_str", ".", "split", "(", "\":::\"", ")", "[", "-", "1", "]", ".", "split", "(", ")", "[", "0", "]", ".", "strip", "(", ")", ")", "\n", "", "except", ":", "\n", "# some don't have results", "\n", "        ", "print", "(", "\"WARNING: unable to parse result from: {}\"", ".", "format", "(", "inp_str", ")", ")", "\n", "", "result", "[", "\"file\"", "]", "=", "inp_str", ".", "split", "(", "\":::\"", ")", "[", "0", "]", ".", "strip", "(", ")", "\n", "\n", "# result[\"author\"] = author", "\n", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.parse_args": [[15, 29], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "os.path.realpath", "os.path.realpath", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "''", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--results-dir'", ",", "\n", "default", "=", "os", ".", "path", ".", "realpath", "(", "os", ".", "path", ".", "join", "(", "dir_path", ",", "\"results_modified\"", ")", ")", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--out-dir'", ",", "\n", "default", "=", "os", ".", "path", ".", "realpath", "(", "os", ".", "path", ".", "join", "(", "dir_path", ",", "\"plot-results\"", ")", ")", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--dataset'", ",", "\n", "default", "=", "\"all\"", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.gen_plots": [[32, 87], ["os.path.join", "os.makedirs", "seaborn.catplot", "matplotlib.pyplot.axhline", "sns.catplot.set", "sns.catplot.ax.legend", "os.path.join", "sns.catplot.savefig", "ax.set_title", "ax.set_xlabel", "ax.set_ylabel", "ax.set_xticklabels", "ax.set_yticklabels", "ax.spines[].set_color", "ax.spines[].set_color", "ax.spines[].set_color", "ax.spines[].set_color", "ax.patch.set_facecolor", "ax.grid", "options[].replace().title", "ax.set_yticks", "[].replace().title", "item.get_text", "ax.get_yticklabels", "options[].replace", "ax.get_yticks", "[].replace"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["", "def", "gen_plots", "(", "data", ",", "options", ")", ":", "\n", "\n", "# linear plots", "\n", "    ", "lin_dir", "=", "os", ".", "path", ".", "join", "(", "options", "[", "'out_dir'", "]", ",", "'basetrain_robustness'", ")", "\n", "os", ".", "makedirs", "(", "lin_dir", ",", "exist_ok", "=", "True", ")", "\n", "linear_data", "=", "data", "[", "data", ".", "result_type", "==", "'linear-eval'", "]", "\n", "linear_data", "=", "linear_data", "[", "linear_data", ".", "variant", "==", "\"linear-eval-lr\"", "]", "\n", "\n", "#since catplot is a figure level function, it produces a new, separate plot which doesn't follow style of past graphs", "\n", "fig", "=", "sns", ".", "catplot", "(", "x", "=", "'basetrain'", ",", "y", "=", "'result'", ",", "hue", "=", "'basetrain_robust'", ",", "data", "=", "linear_data", ",", "kind", "=", "\"point\"", ",", "s", "=", "10", ",", "\n", "linestyle", "=", "\"-\"", ",", "legend_out", "=", "False", ",", "order", "=", "[", "\"MoCo 20-epochs\"", ",", "\"MoCo 200-epochs\"", ",", "\"MoCo 800-epochs\"", "]", ",", "aspect", "=", "11.7", "/", "8.27", ")", "\n", "plt", ".", "axhline", "(", "y", "=", "options", "[", "'asymptote'", "]", ",", "c", "=", "'red'", ",", "linestyle", "=", "'dashed'", ",", "label", "=", "\"Best MoCo Random Init\"", ")", "\n", "\n", "#sets axis labels and title of graph", "\n", "y_axis", "=", "\"Accuracy\"", "\n", "if", "options", "[", "'dataset_type'", "]", "==", "'chexpert'", ":", "\n", "        ", "y_axis", "=", "\"AUROC\"", "\n", "\n", "", "fig", ".", "set", "(", "xlabel", "=", "'Pretrained Model'", ",", "ylabel", "=", "y_axis", ",", "title", "=", "options", "[", "'data_name'", "]", ".", "replace", "(", "\"_\"", ",", "\" \"", ")", ".", "title", "(", ")", ")", "\n", "# fig.set_yticklabels()", "\n", "#sets legend", "\n", "fig", ".", "ax", ".", "legend", "(", "fontsize", "=", "\"large\"", ")", "\n", "\n", "\n", "\n", "for", "ax", "in", "fig", ".", "axes", ".", "flat", ":", "\n", "        ", "if", "options", "[", "'dataset_type'", "]", "!=", "'chexpert'", ":", "\n", "            ", "ax", ".", "set_yticks", "(", "ax", ".", "get_yticks", "(", ")", "[", ":", ":", "2", "]", ")", "\n", "", "ax", ".", "set_title", "(", "options", "[", "'data_name'", "]", "[", ":", "-", "21", "]", ".", "replace", "(", "\"_\"", ",", "\" \"", ")", ".", "title", "(", ")", ",", "fontsize", "=", "25", ")", "\n", "ax", ".", "set_xlabel", "(", "\"Augmentation Sets\"", ",", "fontsize", "=", "20", ")", "\n", "ax", ".", "set_ylabel", "(", "\"Accuracy Change\"", ",", "fontsize", "=", "20", ")", "\n", "xticks", "=", "[", "\"20-epochs\"", ",", "\"200-epochs\"", ",", "\"800-epochs\"", "]", "\n", "ax", ".", "set_xticklabels", "(", "xticks", ",", "rotation", "=", "0", ",", "fontsize", "=", "20", ")", "\n", "\n", "yticks", "=", "[", "item", ".", "get_text", "(", ")", "for", "item", "in", "ax", ".", "get_yticklabels", "(", ")", "]", "\n", "ax", ".", "set_yticklabels", "(", "yticks", ",", "rotation", "=", "0", ",", "fontsize", "=", "20", ")", "\n", "# ax.tick_params(axis='y', labelsize='large')", "\n", "ax", ".", "spines", "[", "'bottom'", "]", ".", "set_color", "(", "'1'", ")", "\n", "ax", ".", "spines", "[", "'top'", "]", ".", "set_color", "(", "'1'", ")", "\n", "ax", ".", "spines", "[", "'right'", "]", ".", "set_color", "(", "'1'", ")", "\n", "ax", ".", "spines", "[", "'left'", "]", ".", "set_color", "(", "'1'", ")", "\n", "ax", ".", "patch", ".", "set_facecolor", "(", "'0.97'", ")", "\n", "ax", ".", "grid", "(", "axis", "=", "'y'", ",", "color", "=", "'grey'", ",", "dashes", "=", "[", "10", ",", "4", "]", ")", "\n", "# handles, _ = fig.ax.get_legend_handles_labels()", "\n", "# fig.ax.legend(handles = handles[1:],labels=labels,title=\"Basetrain\")", "\n", "# plt.show()", "\n", "\n", "#gets rid of other graph created ", "\n", "# plt.close(1) ", "\n", "\n", "#creates output file", "\n", "", "outplot", "=", "os", ".", "path", ".", "join", "(", "lin_dir", ",", "'{}.pdf'", ".", "format", "(", "options", "[", "'data_name'", "]", ")", ")", "\n", "\n", "#saves Figure 1, but Figure 1 is the empty graph created (NOT SNS Graph)", "\n", "fig", ".", "savefig", "(", "outplot", ",", "format", "=", "'pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.reduce": [[89, 95], ["data.iterrows"], "function", ["None"], ["", "def", "reduce", "(", "data", ")", ":", "\n", "    ", "best", "=", "0", "\n", "for", "i", ",", "row", "in", "data", ".", "iterrows", "(", ")", ":", "\n", "        ", "if", "best", "<", "row", "[", "'result'", "]", ":", "\n", "            ", "best", "=", "row", "[", "'result'", "]", "\n", "", "", "return", "best", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.main": [[96, 217], ["os.makedirs", "seaborn.set_style", "seaborn.set", "glob.glob", "glob.glob", "glob.glob.append", "pandas.concat", "print", "print", "print", "print", "pd.concat.iterrows", "print", "result[].sort_values().head", "result[].sort_values().head", "pandas.concat", "print", "print", "plot_basetrain_robust_modified.gen_plots", "os.path.join", "os.path.join", "os.path.join", "print", "pandas.DataFrame", "pd.concat.astype", "pd.concat.basetrain.replace", "pd.concat.basetrain.replace", "pd.concat.basetrain.replace", "pd.concat.basetrain.replace", "pd.concat.basetrain.replace", "frames.append", "len", "open", "json.load", "json.load.values", "data_moco_x.sort_values().head.sort_values().head", "data_moco_y.sort_values().head.sort_values().head", "pandas.concat", "plot_basetrain_robust_modified.reduce", "types.append", "pandas.concat", "result[].sort_values", "result[].sort_values", "data_moco_x.sort_values().head.sort_values", "data_moco_y.sort_values().head.sort_values"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.gen_plots", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.reduce"], ["", "def", "main", "(", "args", ")", ":", "\n", "\n", "#must pass in dataset arg for proper results", "\n", "\n", "    ", "os", ".", "makedirs", "(", "args", ".", "out_dir", ",", "exist_ok", "=", "True", ")", "\n", "# setup plots", "\n", "sns", ".", "set_style", "(", "'darkgrid'", ")", "\n", "sns", ".", "set", "(", ")", "\n", "\n", "frames", "=", "[", "]", "#array that collects dataframes from each file", "\n", "if", "(", "args", ".", "dataset", "==", "\"all\"", ")", ":", "\n", "        ", "dataset_type", "=", "\"*\"", "\n", "", "else", ":", "\n", "        ", "dataset_type", "=", "args", ".", "dataset", "\n", "\n", "", "nobt_baseline", "=", "0", "\n", "\n", "#gets all the basetrain results from the specified dataset", "\n", "result_files", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "dataset_type", "+", "\"*basetrain*.json\"", ")", ",", "recursive", "=", "True", ")", "\n", "result_files2", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "dataset_type", "+", "\"*bt_robust*.json\"", ")", ",", "recursive", "=", "True", ")", "\n", "result_files", "+=", "result_files2", "\n", "result_files", ".", "append", "(", "os", ".", "path", ".", "join", "(", "args", ".", "results_dir", ",", "dataset_type", "+", "\"_results.json\"", ")", ")", "#gets file with basetrian results", "\n", "\n", "for", "resfile", "in", "result_files", ":", "\n", "        ", "with", "open", "(", "resfile", ",", "'r'", ")", "as", "infile", ":", "\n", "            ", "raw_data", "=", "json", ".", "load", "(", "infile", ")", "\n", "\n", "", "print", "(", "resfile", ")", "\n", "\n", "types", "=", "[", "]", "#used for concatenating the resultzs from each basetrained model", "\n", "data", "=", "pd", ".", "DataFrame", "(", "raw_data", ".", "values", "(", ")", ")", "\n", "\n", "\n", "#finds the relevant values for moco bt no bt", "\n", "#mainly done to work around the baseline json file (has extra info that we don't want)", "\n", "if", "(", "dataset_type", "+", "\"_results.json\"", ")", "in", "resfile", ":", "\n", "            ", "linear_data", "=", "data", "[", "data", ".", "result_type", "==", "'linear-eval'", "]", "\n", "linear_data", "=", "linear_data", "[", "linear_data", ".", "variant", "==", "\"linear-eval-lr\"", "]", "\n", "\n", "data_moco", "=", "linear_data", "[", "data", ".", "basetrain", "==", "\"moco_v2_800ep\"", "]", "\n", "data_moco", "=", "data_moco", "[", "data_moco", ".", "pretrain_data", "==", "dataset_type", "]", "\n", "data_moco_x", "=", "data_moco", "[", "(", "data_moco", "[", "'pretrain_iters'", "]", "==", "\"5000\"", ")", "]", "\n", "data_moco_y", "=", "data_moco", "[", "(", "data_moco", "[", "'pretrain_iters'", "]", "==", "\"0\"", ")", "]", "\n", "data_moco_x", "=", "data_moco_x", ".", "sort_values", "(", "by", "=", "[", "'result'", "]", ",", "ascending", "=", "False", ")", ".", "head", "(", "1", ")", "\n", "data_moco_y", "=", "data_moco_y", ".", "sort_values", "(", "by", "=", "[", "'result'", "]", ",", "ascending", "=", "False", ")", ".", "head", "(", "1", ")", "\n", "data_moco", "=", "pd", ".", "concat", "(", "[", "data_moco_x", ",", "data_moco_y", "]", ",", "ignore_index", "=", "True", ")", "\n", "\n", "#just for asympotote", "\n", "data_nobt", "=", "linear_data", "[", "data", ".", "basetrain", "==", "\"no\"", "]", "\n", "data_nobt", "=", "data_nobt", "[", "data_nobt", ".", "pretrain_data", "==", "dataset_type", "]", "\n", "nobt_baseline", "=", "reduce", "(", "data_nobt", ")", "\n", "\n", "\n", "#appended to list ", "\n", "types", ".", "append", "(", "data_moco", ")", "\n", "\n", "#all concat to new dataframe ", "\n", "data", "=", "pd", ".", "concat", "(", "types", ",", "ignore_index", "=", "True", ")", "\n", "\n", "#get baseline and update results", "\n", "\n", "", "data", "=", "data", ".", "astype", "(", "{", "\n", "\"pretrain_iters\"", ":", "int", "\n", "}", ")", "\n", "if", "not", "(", "data", ".", "result", ">", "1", ")", ".", "all", "(", ")", ":", "\n", "            ", "data", ".", "result", "*=", "100", "\n", "\n", "", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"moco_v2_800ep\"", ",", "\"MoCo 800-epochs\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"moco_v2_200ep_pretrain\"", ",", "\"MoCo 200-epochs\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"moco_v2_20ep_pretrain\"", ",", "\"MoCo 20-epochs\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"no\"", ",", "\"random init\"", ")", "\n", "data", ".", "basetrain", "=", "data", ".", "basetrain", ".", "replace", "(", "\"none\"", ",", "\"random init\"", ")", "\n", "frames", ".", "append", "(", "data", ")", "\n", "\n", "#combines all the dataframes from each file into 1 large dataframe", "\n", "", "result", "=", "pd", ".", "concat", "(", "frames", ",", "ignore_index", "=", "True", ")", "\n", "dataname", "=", "dataset_type", "+", "\"_basetrain_robustness\"", "\n", "asymptote", "=", "nobt_baseline", "\n", "if", "asymptote", "<", "1", ":", "\n", "        ", "asymptote", "*=", "100", "\n", "", "print", "(", "result", ")", "\n", "print", "(", "result", ".", "result", ")", "\n", "print", "(", "asymptote", ")", "\n", "\n", "basetrain_robust", "=", "[", "\"a\"", "]", "*", "len", "(", "result", ")", "\n", "result", "[", "\"basetrain_robust\"", "]", "=", "basetrain_robust", "\n", "\n", "print", "(", "result", ".", "pretrain_iters", ")", "\n", "for", "i", ",", "row", "in", "result", ".", "iterrows", "(", ")", ":", "\n", "        ", "name", "=", "\"\"", "\n", "if", "row", "[", "'pretrain_iters'", "]", "==", "0", ":", "\n", "            ", "name", "=", "\"MoCo Direct Transfer\"", "\n", "", "else", ":", "\n", "            ", "name", "=", "\"HPT\"", "\n", "\n", "", "result", ".", "at", "[", "i", ",", "\"basetrain_robust\"", "]", "=", "name", "\n", "", "print", "(", "result", ")", "\n", "\n", "#only ran extra experiments for moco_20", "\n", "#take only the best result (50k iterations)", "\n", "result_20_m", "=", "result", "[", "(", "result", "[", "'basetrain'", "]", "==", "\"MoCo 20-epochs\"", ")", "&", "(", "result", "[", "'basetrain_robust'", "]", "==", "\"HPT\"", ")", "]", ".", "sort_values", "(", "by", "=", "[", "'result'", "]", ",", "ascending", "=", "False", ")", ".", "head", "(", "1", ")", "\n", "\n", "result_20_o", "=", "result", "[", "(", "result", "[", "'basetrain'", "]", "==", "\"MoCo 20-epochs\"", ")", "&", "(", "result", "[", "'basetrain_robust'", "]", "==", "\"MoCo Direct Transfer\"", ")", "]", ".", "sort_values", "(", "by", "=", "[", "'result'", "]", ",", "ascending", "=", "False", ")", ".", "head", "(", "1", ")", "\n", "\n", "result_other", "=", "result", "[", "(", "(", "result", "[", "'basetrain'", "]", "!=", "\"MoCo 20-epochs\"", ")", "|", "(", "result", "[", "'basetrain_robust'", "]", "==", "\"MoCo Direct Transfer\"", ")", ")", "&", "(", "(", "result", "[", "'basetrain'", "]", "!=", "\"MoCo 20-epochs\"", ")", "|", "(", "result", "[", "'basetrain_robust'", "]", "!=", "\"MoCo Direct Transfer\"", ")", ")", "]", "\n", "result", "=", "pd", ".", "concat", "(", "[", "result_20_m", ",", "result_20_o", ",", "result_other", "]", ",", "ignore_index", "=", "True", ")", "\n", "\n", "\n", "#changes all the dataset names to dataset_augmentation", "\n", "\n", "result", ".", "dataset", "=", "dataset_type", "\n", "\n", "#prints new concatenated dataframe ", "\n", "print", "(", "result", ")", "\n", "print", "(", "result", ".", "result", ")", "\n", "\n", "gen_plots", "(", "result", ",", "{", "\n", "'out_dir'", ":", "args", ".", "out_dir", ",", "\n", "'data_name'", ":", "dataname", ",", "\n", "'asymptote'", ":", "asymptote", ",", "\n", "'dataset_type'", ":", "dataset_type", "\n", "}", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.extract-tf-splits.get_data_params_from_flags": [[20, 33], ["None"], "function", ["None"], ["def", "get_data_params_from_flags", "(", "args", ")", ":", "\n", "  ", "return", "{", "\n", "\"dataset\"", ":", "\"data.{}\"", ".", "format", "(", "args", ".", "dataid", ")", ",", "\n", "\"dataset_train_split_name\"", ":", "args", ".", "split", ",", "\n", "\"dataset_eval_split_name\"", ":", "\"val\"", ",", "\n", "\"shuffle_buffer_size\"", ":", "100", ",", "\n", "\"prefetch\"", ":", "100", ",", "\n", "\"train_examples\"", ":", "None", ",", "\n", "\"batch_size\"", ":", "32", ",", "\n", "\"batch_size_eval\"", ":", "32", ",", "\n", "\"data_for_eval\"", ":", "True", ",", "\n", "\"data_dir\"", ":", "args", ".", "data", ",", "\n", "\"input_range\"", ":", "[", "0.0", ",", "1.0", "]", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.extract-tf-splits.main": [[35, 55], ["extract-tf-splits.get_data_params_from_flags", "task_adaptation.registry.Registry.lookup", "Registry.lookup.get_num_samples", "task_adaptation.build_data_pipeline", "tensorflow.compat.v1.data.make_one_shot_iterator().get_next", "tensorflow.Session", "tensorflow.compat.v1.data.make_one_shot_iterator", "open", "outputf.write", "data_loader.build_data_pipeline.", "[].tolist", "print", "len", "len", "list", "set", "sess.run"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.extract-tf-splits.get_data_params_from_flags", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["", "def", "main", "(", "args", ")", ":", "\n", "    ", "data_params", "=", "get_data_params_from_flags", "(", "args", ")", "\n", "rdata", "=", "Registry", ".", "lookup", "(", "data_params", "[", "\"dataset\"", "]", ",", "\n", "kwargs_extra", "=", "{", "\"data_dir\"", ":", "data_params", "[", "\"data_dir\"", "]", "}", ")", "\n", "nsamples", "=", "rdata", ".", "get_num_samples", "(", "data_params", "[", "\"dataset_train_split_name\"", "]", ")", "\n", "\n", "input_fn", "=", "data_loader", ".", "build_data_pipeline", "(", "data_params", ",", "mode", "=", "\"train\"", ")", "\n", "data", "=", "make_one_shot_iterator", "(", "input_fn", "(", "{", "\"batch_size\"", ":", "32", "}", ")", ")", ".", "get_next", "(", ")", "\n", "filenames", "=", "[", "]", "\n", "with", "tf", ".", "Session", "(", ")", "as", "sess", ":", "\n", "        ", "while", "True", ":", "\n", "            ", "try", ":", "\n", "                ", "filenames", "+=", "sess", ".", "run", "(", "data", ")", "[", "\"filename\"", "]", ".", "tolist", "(", ")", "\n", "print", "(", "len", "(", "filenames", ")", ")", "\n", "if", "len", "(", "filenames", ")", ">", "(", "nsamples", "*", "2", ")", ":", "\n", "                    ", "break", "\n", "", "", "except", ":", "\n", "                ", "break", "\n", "", "", "with", "open", "(", "args", ".", "outfile", ",", "\"wb\"", ")", "as", "outputf", ":", "\n", "            ", "outputf", ".", "write", "(", "b\"\\n\"", ".", "join", "(", "list", "(", "set", "(", "filenames", ")", ")", ")", ")", "\n", "", "", "", "if", "__name__", "==", "\"__main__\"", ":", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.serialize.PicklableWrapper.__init__": [[15, 17], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "obj", ")", ":", "\n", "        ", "self", ".", "_obj", "=", "obj", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.serialize.PicklableWrapper.__reduce__": [[18, 21], ["cloudpickle.dumps"], "methods", ["None"], ["", "def", "__reduce__", "(", "self", ")", ":", "\n", "        ", "s", "=", "cloudpickle", ".", "dumps", "(", "self", ".", "_obj", ")", "\n", "return", "cloudpickle", ".", "loads", ",", "(", "s", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.serialize.PicklableWrapper.__call__": [[22, 24], ["serialize.PicklableWrapper._obj"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "self", ".", "_obj", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.serialize.PicklableWrapper.__getattr__": [[25, 30], ["getattr", "getattr"], "methods", ["None"], ["", "def", "__getattr__", "(", "self", ",", "attr", ")", ":", "\n", "# Ensure that the wrapped object can be used seamlessly as the previous object.", "\n", "        ", "if", "attr", "not", "in", "[", "\"_obj\"", "]", ":", "\n", "            ", "return", "getattr", "(", "self", ".", "_obj", ",", "attr", ")", "\n", "", "return", "getattr", "(", "self", ",", "attr", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.colormap.colormap": [[95, 109], ["None"], "function", ["None"], ["def", "colormap", "(", "rgb", "=", "False", ",", "maximum", "=", "255", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        rgb (bool): whether to return RGB colors or BGR colors.\n        maximum (int): either 255 or 1\n\n    Returns:\n        ndarray: a float32 array of Nx3 colors, in range [0, 255] or [0, 1]\n    \"\"\"", "\n", "assert", "maximum", "in", "[", "255", ",", "1", "]", ",", "maximum", "\n", "c", "=", "_COLORS", "*", "maximum", "\n", "if", "not", "rgb", ":", "\n", "        ", "c", "=", "c", "[", ":", ",", ":", ":", "-", "1", "]", "\n", "", "return", "c", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.colormap.random_color": [[111, 125], ["numpy.random.randint", "len"], "function", ["None"], ["", "def", "random_color", "(", "rgb", "=", "False", ",", "maximum", "=", "255", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        rgb (bool): whether to return RGB colors or BGR colors.\n        maximum (int): either 255 or 1\n\n    Returns:\n        ndarray: a vector of 3 numbers\n    \"\"\"", "\n", "idx", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "_COLORS", ")", ")", "\n", "ret", "=", "_COLORS", "[", "idx", "]", "*", "maximum", "\n", "if", "not", "rgb", ":", "\n", "        ", "ret", "=", "ret", "[", ":", ":", "-", "1", "]", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventWriter.write": [[41, 43], ["None"], "methods", ["None"], ["def", "write", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventWriter.close": [[44, 46], ["None"], "methods", ["None"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.JSONWriter.__init__": [[92, 102], ["fvcore.common.file_io.PathManager.open"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "json_file", ",", "window_size", "=", "20", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            json_file (str): path to the json file. New data will be appended if the file exists.\n            window_size (int): the window size of median smoothing for the scalars whose\n                `smoothing_hint` are True.\n        \"\"\"", "\n", "self", ".", "_file_handle", "=", "PathManager", ".", "open", "(", "json_file", ",", "\"a\"", ")", "\n", "self", ".", "_window_size", "=", "window_size", "\n", "self", ".", "_last_write", "=", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.JSONWriter.write": [[103, 124], ["events.get_event_storage", "collections.defaultdict", "get_event_storage.latest_with_smoothing_hint().items", "len", "collections.defaultdict.items", "events.JSONWriter._file_handle.flush", "sorted", "max", "events.JSONWriter._file_handle.write", "os.fsync", "get_event_storage.latest_with_smoothing_hint", "collections.defaultdict.keys", "events.JSONWriter._file_handle.fileno", "json.dumps"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.get_event_storage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.latest_with_smoothing_hint"], ["", "def", "write", "(", "self", ")", ":", "\n", "        ", "storage", "=", "get_event_storage", "(", ")", "\n", "to_save", "=", "defaultdict", "(", "dict", ")", "\n", "\n", "for", "k", ",", "(", "v", ",", "iter", ")", "in", "storage", ".", "latest_with_smoothing_hint", "(", "self", ".", "_window_size", ")", ".", "items", "(", ")", ":", "\n", "# keep scalars that have not been written", "\n", "            ", "if", "iter", "<=", "self", ".", "_last_write", ":", "\n", "                ", "continue", "\n", "", "to_save", "[", "iter", "]", "[", "k", "]", "=", "v", "\n", "", "if", "len", "(", "to_save", ")", ":", "\n", "            ", "all_iters", "=", "sorted", "(", "to_save", ".", "keys", "(", ")", ")", "\n", "self", ".", "_last_write", "=", "max", "(", "all_iters", ")", "\n", "\n", "", "for", "itr", ",", "scalars_per_iter", "in", "to_save", ".", "items", "(", ")", ":", "\n", "            ", "scalars_per_iter", "[", "\"iteration\"", "]", "=", "itr", "\n", "self", ".", "_file_handle", ".", "write", "(", "json", ".", "dumps", "(", "scalars_per_iter", ",", "sort_keys", "=", "True", ")", "+", "\"\\n\"", ")", "\n", "", "self", ".", "_file_handle", ".", "flush", "(", ")", "\n", "try", ":", "\n", "            ", "os", ".", "fsync", "(", "self", ".", "_file_handle", ".", "fileno", "(", ")", ")", "\n", "", "except", "AttributeError", ":", "\n", "            ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.JSONWriter.close": [[125, 127], ["events.JSONWriter._file_handle.close"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.TensorboardXWriter.close"], ["", "", "def", "close", "(", "self", ")", ":", "\n", "        ", "self", ".", "_file_handle", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.TensorboardXWriter.__init__": [[134, 147], ["SummaryWriter"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "log_dir", ":", "str", ",", "window_size", ":", "int", "=", "20", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            log_dir (str): the directory to save the output events\n            window_size (int): the scalars will be median-smoothed by this window size\n\n            kwargs: other arguments passed to `torch.utils.tensorboard.SummaryWriter(...)`\n        \"\"\"", "\n", "self", ".", "_window_size", "=", "window_size", "\n", "from", "torch", ".", "utils", ".", "tensorboard", "import", "SummaryWriter", "\n", "\n", "self", ".", "_writer", "=", "SummaryWriter", "(", "log_dir", ",", "**", "kwargs", ")", "\n", "self", ".", "_last_write", "=", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.TensorboardXWriter.write": [[148, 173], ["events.get_event_storage", "get_event_storage.latest_with_smoothing_hint().items", "len", "get_event_storage.clear_images", "len", "get_event_storage.clear_histograms", "get_event_storage.latest_with_smoothing_hint", "events.TensorboardXWriter._writer.add_scalar", "max", "events.TensorboardXWriter._writer.add_image", "events.TensorboardXWriter._writer.add_histogram_raw"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.get_event_storage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.clear_images", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.clear_histograms", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.latest_with_smoothing_hint"], ["", "def", "write", "(", "self", ")", ":", "\n", "        ", "storage", "=", "get_event_storage", "(", ")", "\n", "new_last_write", "=", "self", ".", "_last_write", "\n", "for", "k", ",", "(", "v", ",", "iter", ")", "in", "storage", ".", "latest_with_smoothing_hint", "(", "self", ".", "_window_size", ")", ".", "items", "(", ")", ":", "\n", "            ", "if", "iter", ">", "self", ".", "_last_write", ":", "\n", "                ", "self", ".", "_writer", ".", "add_scalar", "(", "k", ",", "v", ",", "iter", ")", "\n", "new_last_write", "=", "max", "(", "new_last_write", ",", "iter", ")", "\n", "", "", "self", ".", "_last_write", "=", "new_last_write", "\n", "\n", "# storage.put_{image,histogram} is only meant to be used by", "\n", "# tensorboard writer. So we access its internal fields directly from here.", "\n", "if", "len", "(", "storage", ".", "_vis_data", ")", ">=", "1", ":", "\n", "            ", "for", "img_name", ",", "img", ",", "step_num", "in", "storage", ".", "_vis_data", ":", "\n", "                ", "self", ".", "_writer", ".", "add_image", "(", "img_name", ",", "img", ",", "step_num", ")", "\n", "# Storage stores all image data and rely on this writer to clear them.", "\n", "# As a result it assumes only one writer will use its image data.", "\n", "# An alternative design is to let storage store limited recent", "\n", "# data (e.g. only the most recent image) that all writers can access.", "\n", "# In that case a writer may not see all image data if its period is long.", "\n", "", "storage", ".", "clear_images", "(", ")", "\n", "\n", "", "if", "len", "(", "storage", ".", "_histograms", ")", ">=", "1", ":", "\n", "            ", "for", "params", "in", "storage", ".", "_histograms", ":", "\n", "                ", "self", ".", "_writer", ".", "add_histogram_raw", "(", "**", "params", ")", "\n", "", "storage", ".", "clear_histograms", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.TensorboardXWriter.close": [[174, 177], ["hasattr", "events.TensorboardXWriter._writer.close"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.TensorboardXWriter.close"], ["", "", "def", "close", "(", "self", ")", ":", "\n", "        ", "if", "hasattr", "(", "self", ",", "\"_writer\"", ")", ":", "# doesn't exist when the code fails at import", "\n", "            ", "self", ".", "_writer", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.CommonMetricPrinter.__init__": [[189, 198], ["logging.getLogger"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "max_iter", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            max_iter (int): the maximum number of iterations to train.\n                Used to compute ETA.\n        \"\"\"", "\n", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "self", ".", "_max_iter", "=", "max_iter", "\n", "self", ".", "_last_write", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.CommonMetricPrinter.write": [[199, 258], ["events.get_event_storage", "torch.cuda.is_available", "events.CommonMetricPrinter.logger.info", "get_event_storage.history().avg", "get_event_storage.history().global_avg", "get_event_storage.put_scalar", "str", "get_event_storage.history().median", "datetime.timedelta", "get_event_storage.history().latest", "get_event_storage.history", "get_event_storage.history", "str", "time.perf_counter", "torch.cuda.max_memory_allocated", "get_event_storage.history", "int", "datetime.timedelta", "get_event_storage.history", "time.perf_counter", "int", "v.median", "get_event_storage.histories().items", "get_event_storage.histories"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.get_event_storage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.latest", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.history", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.history", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.history", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.history", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.histories"], ["", "def", "write", "(", "self", ")", ":", "\n", "        ", "storage", "=", "get_event_storage", "(", ")", "\n", "iteration", "=", "storage", ".", "iter", "\n", "if", "iteration", "==", "self", ".", "_max_iter", ":", "\n", "# This hook only reports training progress (loss, ETA, etc) but not other data,", "\n", "# therefore do not write anything after training succeeds, even if this method", "\n", "# is called.", "\n", "            ", "return", "\n", "\n", "", "try", ":", "\n", "            ", "data_time", "=", "storage", ".", "history", "(", "\"data_time\"", ")", ".", "avg", "(", "20", ")", "\n", "", "except", "KeyError", ":", "\n", "# they may not exist in the first few iterations (due to warmup)", "\n", "# or when SimpleTrainer is not used", "\n", "            ", "data_time", "=", "None", "\n", "\n", "", "eta_string", "=", "None", "\n", "try", ":", "\n", "            ", "iter_time", "=", "storage", ".", "history", "(", "\"time\"", ")", ".", "global_avg", "(", ")", "\n", "eta_seconds", "=", "storage", ".", "history", "(", "\"time\"", ")", ".", "median", "(", "1000", ")", "*", "(", "self", ".", "_max_iter", "-", "iteration", "-", "1", ")", "\n", "storage", ".", "put_scalar", "(", "\"eta_seconds\"", ",", "eta_seconds", ",", "smoothing_hint", "=", "False", ")", "\n", "eta_string", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "eta_seconds", ")", ")", ")", "\n", "", "except", "KeyError", ":", "\n", "            ", "iter_time", "=", "None", "\n", "# estimate eta on our own - more noisy", "\n", "if", "self", ".", "_last_write", "is", "not", "None", ":", "\n", "                ", "estimate_iter_time", "=", "(", "time", ".", "perf_counter", "(", ")", "-", "self", ".", "_last_write", "[", "1", "]", ")", "/", "(", "\n", "iteration", "-", "self", ".", "_last_write", "[", "0", "]", "\n", ")", "\n", "eta_seconds", "=", "estimate_iter_time", "*", "(", "self", ".", "_max_iter", "-", "iteration", "-", "1", ")", "\n", "eta_string", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "eta_seconds", ")", ")", ")", "\n", "", "self", ".", "_last_write", "=", "(", "iteration", ",", "time", ".", "perf_counter", "(", ")", ")", "\n", "\n", "", "try", ":", "\n", "            ", "lr", "=", "\"{:.5g}\"", ".", "format", "(", "storage", ".", "history", "(", "\"lr\"", ")", ".", "latest", "(", ")", ")", "\n", "", "except", "KeyError", ":", "\n", "            ", "lr", "=", "\"N/A\"", "\n", "\n", "", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "max_mem_mb", "=", "torch", ".", "cuda", ".", "max_memory_allocated", "(", ")", "/", "1024.0", "/", "1024.0", "\n", "", "else", ":", "\n", "            ", "max_mem_mb", "=", "None", "\n", "\n", "# NOTE: max_mem is parsed by grep in \"dev/parse_results.sh\"", "\n", "", "self", ".", "logger", ".", "info", "(", "\n", "\" {eta}iter: {iter}  {losses}  {time}{data_time}lr: {lr}  {memory}\"", ".", "format", "(", "\n", "eta", "=", "f\"eta: {eta_string}  \"", "if", "eta_string", "else", "\"\"", ",", "\n", "iter", "=", "iteration", ",", "\n", "losses", "=", "\"  \"", ".", "join", "(", "\n", "[", "\n", "\"{}: {:.4g}\"", ".", "format", "(", "k", ",", "v", ".", "median", "(", "20", ")", ")", "\n", "for", "k", ",", "v", "in", "storage", ".", "histories", "(", ")", ".", "items", "(", ")", "\n", "if", "\"loss\"", "in", "k", "\n", "]", "\n", ")", ",", "\n", "time", "=", "\"time: {:.4f}  \"", ".", "format", "(", "iter_time", ")", "if", "iter_time", "is", "not", "None", "else", "\"\"", ",", "\n", "data_time", "=", "\"data_time: {:.4f}  \"", ".", "format", "(", "data_time", ")", "if", "data_time", "is", "not", "None", "else", "\"\"", ",", "\n", "lr", "=", "lr", ",", "\n", "memory", "=", "\"max_mem: {:.0f}M\"", ".", "format", "(", "max_mem_mb", ")", "if", "max_mem_mb", "is", "not", "None", "else", "\"\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.__init__": [[269, 281], ["collections.defaultdict"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "start_iter", "=", "0", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            start_iter (int): the iteration number to start with\n        \"\"\"", "\n", "self", ".", "_history", "=", "defaultdict", "(", "HistoryBuffer", ")", "\n", "self", ".", "_smoothing_hints", "=", "{", "}", "\n", "self", ".", "_latest_scalars", "=", "{", "}", "\n", "self", ".", "_iter", "=", "start_iter", "\n", "self", ".", "_current_prefix", "=", "\"\"", "\n", "self", ".", "_vis_data", "=", "[", "]", "\n", "self", ".", "_histograms", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_image": [[282, 296], ["events.EventStorage._vis_data.append"], "methods", ["None"], ["", "def", "put_image", "(", "self", ",", "img_name", ",", "img_tensor", ")", ":", "\n", "        ", "\"\"\"\n        Add an `img_tensor` associated with `img_name`, to be shown on\n        tensorboard.\n\n        Args:\n            img_name (str): The name of the image to put into tensorboard.\n            img_tensor (torch.Tensor or numpy.array): An `uint8` or `float`\n                Tensor of shape `[channel, height, width]` where `channel` is\n                3. The image format should be RGB. The elements in img_tensor\n                can either have values in [0, 1] (float32) or [0, 255] (uint8).\n                The `img_tensor` will be visualized in tensorboard.\n        \"\"\"", "\n", "self", ".", "_vis_data", ".", "append", "(", "(", "img_name", ",", "img_tensor", ",", "self", ".", "_iter", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar": [[297, 323], ["float", "history.update", "events.EventStorage._smoothing_hints.get"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "def", "put_scalar", "(", "self", ",", "name", ",", "value", ",", "smoothing_hint", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Add a scalar `value` to the `HistoryBuffer` associated with `name`.\n\n        Args:\n            smoothing_hint (bool): a 'hint' on whether this scalar is noisy and should be\n                smoothed when logged. The hint will be accessible through\n                :meth:`EventStorage.smoothing_hints`.  A writer may ignore the hint\n                and apply custom smoothing rule.\n\n                It defaults to True because most scalars we save need to be smoothed to\n                provide any useful signal.\n        \"\"\"", "\n", "name", "=", "self", ".", "_current_prefix", "+", "name", "\n", "history", "=", "self", ".", "_history", "[", "name", "]", "\n", "value", "=", "float", "(", "value", ")", "\n", "history", ".", "update", "(", "value", ",", "self", ".", "_iter", ")", "\n", "self", ".", "_latest_scalars", "[", "name", "]", "=", "(", "value", ",", "self", ".", "_iter", ")", "\n", "\n", "existing_hint", "=", "self", ".", "_smoothing_hints", ".", "get", "(", "name", ")", "\n", "if", "existing_hint", "is", "not", "None", ":", "\n", "            ", "assert", "(", "\n", "existing_hint", "==", "smoothing_hint", "\n", ")", ",", "\"Scalar {} was put with a different smoothing_hint!\"", ".", "format", "(", "name", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_smoothing_hints", "[", "name", "]", "=", "smoothing_hint", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalars": [[324, 334], ["kwargs.items", "events.EventStorage.put_scalar"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar"], ["", "", "def", "put_scalars", "(", "self", ",", "*", ",", "smoothing_hint", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Put multiple scalars from keyword arguments.\n\n        Examples:\n\n            storage.put_scalars(loss=my_loss, accuracy=my_accuracy, smoothing_hint=True)\n        \"\"\"", "\n", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "put_scalar", "(", "k", ",", "v", ",", "smoothing_hint", "=", "smoothing_hint", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_histogram": [[335, 364], ["torch.histc", "torch.linspace", "dict", "events.EventStorage._histograms.append", "hist_tensor.min().item", "hist_tensor.max().item", "len", "float", "float", "hist_edges[].tolist", "torch.histc.tolist", "hist_tensor.min", "hist_tensor.max", "hist_tensor.sum", "torch.sum"], "methods", ["None"], ["", "", "def", "put_histogram", "(", "self", ",", "hist_name", ",", "hist_tensor", ",", "bins", "=", "1000", ")", ":", "\n", "        ", "\"\"\"\n        Create a histogram from a tensor.\n\n        Args:\n            hist_name (str): The name of the histogram to put into tensorboard.\n            hist_tensor (torch.Tensor): A Tensor of arbitrary shape to be converted\n                into a histogram.\n            bins (int): Number of histogram bins.\n        \"\"\"", "\n", "ht_min", ",", "ht_max", "=", "hist_tensor", ".", "min", "(", ")", ".", "item", "(", ")", ",", "hist_tensor", ".", "max", "(", ")", ".", "item", "(", ")", "\n", "\n", "# Create a histogram with PyTorch", "\n", "hist_counts", "=", "torch", ".", "histc", "(", "hist_tensor", ",", "bins", "=", "bins", ")", "\n", "hist_edges", "=", "torch", ".", "linspace", "(", "start", "=", "ht_min", ",", "end", "=", "ht_max", ",", "steps", "=", "bins", "+", "1", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "# Parameter for the add_histogram_raw function of SummaryWriter", "\n", "hist_params", "=", "dict", "(", "\n", "tag", "=", "hist_name", ",", "\n", "min", "=", "ht_min", ",", "\n", "max", "=", "ht_max", ",", "\n", "num", "=", "len", "(", "hist_tensor", ")", ",", "\n", "sum", "=", "float", "(", "hist_tensor", ".", "sum", "(", ")", ")", ",", "\n", "sum_squares", "=", "float", "(", "torch", ".", "sum", "(", "hist_tensor", "**", "2", ")", ")", ",", "\n", "bucket_limits", "=", "hist_edges", "[", "1", ":", "]", ".", "tolist", "(", ")", ",", "\n", "bucket_counts", "=", "hist_counts", ".", "tolist", "(", ")", ",", "\n", "global_step", "=", "self", ".", "_iter", ",", "\n", ")", "\n", "self", ".", "_histograms", ".", "append", "(", "hist_params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.history": [[365, 374], ["events.EventStorage._history.get", "KeyError"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "def", "history", "(", "self", ",", "name", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            HistoryBuffer: the scalar history for name\n        \"\"\"", "\n", "ret", "=", "self", ".", "_history", ".", "get", "(", "name", ",", "None", ")", "\n", "if", "ret", "is", "None", ":", "\n", "            ", "raise", "KeyError", "(", "\"No history metric available for {}!\"", ".", "format", "(", "name", ")", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.histories": [[375, 381], ["None"], "methods", ["None"], ["", "def", "histories", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            dict[name -> HistoryBuffer]: the HistoryBuffer for all scalars\n        \"\"\"", "\n", "return", "self", ".", "_history", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.latest": [[382, 389], ["None"], "methods", ["None"], ["", "def", "latest", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            dict[str -> (float, int)]: mapping from the name of each scalar to the most\n                recent value and the iteration number its added.\n        \"\"\"", "\n", "return", "self", ".", "_latest_scalars", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.latest_with_smoothing_hint": [[390, 406], ["events.EventStorage._latest_scalars.items", "events.EventStorage._history[].median"], "methods", ["None"], ["", "def", "latest_with_smoothing_hint", "(", "self", ",", "window_size", "=", "20", ")", ":", "\n", "        ", "\"\"\"\n        Similar to :meth:`latest`, but the returned values\n        are either the un-smoothed original latest value,\n        or a median of the given window_size,\n        depend on whether the smoothing_hint is True.\n\n        This provides a default behavior that other writers can use.\n        \"\"\"", "\n", "result", "=", "{", "}", "\n", "for", "k", ",", "(", "v", ",", "itr", ")", "in", "self", ".", "_latest_scalars", ".", "items", "(", ")", ":", "\n", "            ", "result", "[", "k", "]", "=", "(", "\n", "self", ".", "_history", "[", "k", "]", ".", "median", "(", "window_size", ")", "if", "self", ".", "_smoothing_hints", "[", "k", "]", "else", "v", ",", "\n", "itr", ",", "\n", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.smoothing_hints": [[407, 414], ["None"], "methods", ["None"], ["", "def", "smoothing_hints", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            dict[name -> bool]: the user-provided hint on whether the scalar\n                is noisy and needs smoothing.\n        \"\"\"", "\n", "return", "self", ".", "_smoothing_hints", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.step": [[415, 423], ["None"], "methods", ["None"], ["", "def", "step", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        User should either: (1) Call this function to increment storage.iter when needed. Or\n        (2) Set `storage.iter` to the correct iteration number before each iteration.\n\n        The storage will then be able to associate the new data with an iteration number.\n        \"\"\"", "\n", "self", ".", "_iter", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.iter": [[433, 436], ["int"], "methods", ["None"], ["", "@", "iter", ".", "setter", "\n", "def", "iter", "(", "self", ",", "val", ")", ":", "\n", "        ", "self", ".", "_iter", "=", "int", "(", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.iteration": [[437, 441], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "iteration", "(", "self", ")", ":", "\n", "# for backward compatibility", "\n", "        ", "return", "self", ".", "_iter", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.__enter__": [[442, 445], ["_CURRENT_STORAGE_STACK.append"], "methods", ["None"], ["", "def", "__enter__", "(", "self", ")", ":", "\n", "        ", "_CURRENT_STORAGE_STACK", ".", "append", "(", "self", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.__exit__": [[446, 449], ["_CURRENT_STORAGE_STACK.pop"], "methods", ["None"], ["", "def", "__exit__", "(", "self", ",", "exc_type", ",", "exc_val", ",", "exc_tb", ")", ":", "\n", "        ", "assert", "_CURRENT_STORAGE_STACK", "[", "-", "1", "]", "==", "self", "\n", "_CURRENT_STORAGE_STACK", ".", "pop", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.name_scope": [[450, 461], ["name.rstrip"], "methods", ["None"], ["", "@", "contextmanager", "\n", "def", "name_scope", "(", "self", ",", "name", ")", ":", "\n", "        ", "\"\"\"\n        Yields:\n            A context within which all the events added to this storage\n            will be prefixed by the name scope.\n        \"\"\"", "\n", "old_prefix", "=", "self", ".", "_current_prefix", "\n", "self", ".", "_current_prefix", "=", "name", ".", "rstrip", "(", "\"/\"", ")", "+", "\"/\"", "\n", "yield", "\n", "self", ".", "_current_prefix", "=", "old_prefix", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.clear_images": [[462, 468], ["None"], "methods", ["None"], ["", "def", "clear_images", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Delete all the stored images for visualization. This should be called\n        after images are written to tensorboard.\n        \"\"\"", "\n", "self", ".", "_vis_data", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.clear_histograms": [[469, 475], ["None"], "methods", ["None"], ["", "def", "clear_histograms", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Delete all the stored histograms for visualization.\n        This should be called after histograms are written to tensorboard.\n        \"\"\"", "\n", "self", ".", "_histograms", "=", "[", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.get_event_storage": [[24, 34], ["len"], "function", ["None"], ["def", "get_event_storage", "(", ")", ":", "\n", "    ", "\"\"\"\n    Returns:\n        The :class:`EventStorage` object that's currently being used.\n        Throws an error if no :class:`EventStorage` is currently enabled.\n    \"\"\"", "\n", "assert", "len", "(", "\n", "_CURRENT_STORAGE_STACK", "\n", ")", ",", "\"get_event_storage() has to be called inside a 'with EventStorage(...)' context!\"", "\n", "return", "_CURRENT_STORAGE_STACK", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size": [[21, 27], ["torch.get_world_size", "torch.is_available", "torch.is_initialized"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size"], ["def", "get_world_size", "(", ")", "->", "int", ":", "\n", "    ", "if", "not", "dist", ".", "is_available", "(", ")", ":", "\n", "        ", "return", "1", "\n", "", "if", "not", "dist", ".", "is_initialized", "(", ")", ":", "\n", "        ", "return", "1", "\n", "", "return", "dist", ".", "get_world_size", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank": [[29, 35], ["torch.get_rank", "torch.is_available", "torch.is_initialized"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank"], ["", "def", "get_rank", "(", ")", "->", "int", ":", "\n", "    ", "if", "not", "dist", ".", "is_available", "(", ")", ":", "\n", "        ", "return", "0", "\n", "", "if", "not", "dist", ".", "is_initialized", "(", ")", ":", "\n", "        ", "return", "0", "\n", "", "return", "dist", ".", "get_rank", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_local_rank": [[37, 48], ["torch.get_rank", "torch.is_available", "torch.is_initialized"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank"], ["", "def", "get_local_rank", "(", ")", "->", "int", ":", "\n", "    ", "\"\"\"\n    Returns:\n        The rank of the current process within the local (per-machine) process group.\n    \"\"\"", "\n", "if", "not", "dist", ".", "is_available", "(", ")", ":", "\n", "        ", "return", "0", "\n", "", "if", "not", "dist", ".", "is_initialized", "(", ")", ":", "\n", "        ", "return", "0", "\n", "", "assert", "_LOCAL_PROCESS_GROUP", "is", "not", "None", "\n", "return", "dist", ".", "get_rank", "(", "group", "=", "_LOCAL_PROCESS_GROUP", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_local_size": [[50, 61], ["torch.get_world_size", "torch.is_available", "torch.is_initialized"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size"], ["", "def", "get_local_size", "(", ")", "->", "int", ":", "\n", "    ", "\"\"\"\n    Returns:\n        The size of the per-machine process group,\n        i.e. the number of processes per machine.\n    \"\"\"", "\n", "if", "not", "dist", ".", "is_available", "(", ")", ":", "\n", "        ", "return", "1", "\n", "", "if", "not", "dist", ".", "is_initialized", "(", ")", ":", "\n", "        ", "return", "1", "\n", "", "return", "dist", ".", "get_world_size", "(", "group", "=", "_LOCAL_PROCESS_GROUP", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process": [[63, 65], ["comm.get_rank"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank"], ["", "def", "is_main_process", "(", ")", "->", "bool", ":", "\n", "    ", "return", "get_rank", "(", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.synchronize": [[67, 80], ["torch.get_world_size", "torch.barrier", "torch.is_available", "torch.is_initialized"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size"], ["", "def", "synchronize", "(", ")", ":", "\n", "    ", "\"\"\"\n    Helper function to synchronize (barrier) among all processes when\n    using distributed training\n    \"\"\"", "\n", "if", "not", "dist", ".", "is_available", "(", ")", ":", "\n", "        ", "return", "\n", "", "if", "not", "dist", ".", "is_initialized", "(", ")", ":", "\n", "        ", "return", "\n", "", "world_size", "=", "dist", ".", "get_world_size", "(", ")", "\n", "if", "world_size", "==", "1", ":", "\n", "        ", "return", "\n", "", "dist", ".", "barrier", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm._get_global_gloo_group": [[82, 92], ["functools.lru_cache", "torch.get_backend", "torch.new_group"], "function", ["None"], ["", "@", "functools", ".", "lru_cache", "(", ")", "\n", "def", "_get_global_gloo_group", "(", ")", ":", "\n", "    ", "\"\"\"\n    Return a process group based on gloo backend, containing all the ranks\n    The result is cached.\n    \"\"\"", "\n", "if", "dist", ".", "get_backend", "(", ")", "==", "\"nccl\"", ":", "\n", "        ", "return", "dist", ".", "new_group", "(", "backend", "=", "\"gloo\"", ")", "\n", "", "else", ":", "\n", "        ", "return", "dist", ".", "group", ".", "WORLD", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm._serialize_to_tensor": [[94, 110], ["torch.get_backend", "torch.device", "torch.device", "pickle.dumps", "torch.ByteStorage.from_buffer", "torch.ByteStorage.from_buffer", "torch.ByteTensor().to", "torch.ByteTensor().to", "len", "logging.getLogger", "logging.getLogger.warning", "torch.ByteTensor", "torch.ByteTensor", "comm.get_rank", "len"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank"], ["", "", "def", "_serialize_to_tensor", "(", "data", ",", "group", ")", ":", "\n", "    ", "backend", "=", "dist", ".", "get_backend", "(", "group", ")", "\n", "assert", "backend", "in", "[", "\"gloo\"", ",", "\"nccl\"", "]", "\n", "device", "=", "torch", ".", "device", "(", "\"cpu\"", "if", "backend", "==", "\"gloo\"", "else", "\"cuda\"", ")", "\n", "\n", "buffer", "=", "pickle", ".", "dumps", "(", "data", ")", "\n", "if", "len", "(", "buffer", ")", ">", "1024", "**", "3", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warning", "(", "\n", "\"Rank {} trying to all-gather {:.2f} GB of data on device {}\"", ".", "format", "(", "\n", "get_rank", "(", ")", ",", "len", "(", "buffer", ")", "/", "(", "1024", "**", "3", ")", ",", "device", "\n", ")", "\n", ")", "\n", "", "storage", "=", "torch", ".", "ByteStorage", ".", "from_buffer", "(", "buffer", ")", "\n", "tensor", "=", "torch", ".", "ByteTensor", "(", "storage", ")", ".", "to", "(", "device", "=", "device", ")", "\n", "return", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm._pad_to_largest_tensor": [[112, 137], ["torch.get_world_size", "torch.tensor", "torch.tensor", "torch.all_gather", "max", "torch.zeros", "torch.zeros", "int", "torch.zeros", "torch.zeros", "torch.cat", "torch.cat", "torch.cat.numel", "range", "size.item"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "def", "_pad_to_largest_tensor", "(", "tensor", ",", "group", ")", ":", "\n", "    ", "\"\"\"\n    Returns:\n        list[int]: size of the tensor, on each rank\n        Tensor: padded tensor that has the max size\n    \"\"\"", "\n", "world_size", "=", "dist", ".", "get_world_size", "(", "group", "=", "group", ")", "\n", "assert", "(", "\n", "world_size", ">=", "1", "\n", ")", ",", "\"comm.gather/all_gather must be called from ranks within the given group!\"", "\n", "local_size", "=", "torch", ".", "tensor", "(", "[", "tensor", ".", "numel", "(", ")", "]", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "tensor", ".", "device", ")", "\n", "size_list", "=", "[", "\n", "torch", ".", "zeros", "(", "[", "1", "]", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "tensor", ".", "device", ")", "for", "_", "in", "range", "(", "world_size", ")", "\n", "]", "\n", "dist", ".", "all_gather", "(", "size_list", ",", "local_size", ",", "group", "=", "group", ")", "\n", "size_list", "=", "[", "int", "(", "size", ".", "item", "(", ")", ")", "for", "size", "in", "size_list", "]", "\n", "\n", "max_size", "=", "max", "(", "size_list", ")", "\n", "\n", "# we pad the tensor because torch all_gather does not support", "\n", "# gathering tensors of different shapes", "\n", "if", "local_size", "!=", "max_size", ":", "\n", "        ", "padding", "=", "torch", ".", "zeros", "(", "(", "max_size", "-", "local_size", ",", ")", ",", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "tensor", ".", "device", ")", "\n", "tensor", "=", "torch", ".", "cat", "(", "(", "tensor", ",", "padding", ")", ",", "dim", "=", "0", ")", "\n", "", "return", "size_list", ",", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather": [[139, 175], ["comm._serialize_to_tensor", "comm._pad_to_largest_tensor", "max", "torch.all_gather", "zip", "comm.get_world_size", "comm._get_global_gloo_group", "torch.get_world_size", "torch.empty", "torch.empty", "data_list.append", "_serialize_to_tensor.cpu().numpy().tobytes", "pickle.loads", "_serialize_to_tensor.cpu().numpy", "_serialize_to_tensor.cpu"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm._serialize_to_tensor", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm._pad_to_largest_tensor", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm._get_global_gloo_group", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size"], ["", "def", "all_gather", "(", "data", ",", "group", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Run all_gather on arbitrary picklable data (not necessarily tensors).\n\n    Args:\n        data: any picklable object\n        group: a torch process group. By default, will use a group which\n            contains all ranks on gloo backend.\n\n    Returns:\n        list[data]: list of data gathered from each rank\n    \"\"\"", "\n", "if", "get_world_size", "(", ")", "==", "1", ":", "\n", "        ", "return", "[", "data", "]", "\n", "", "if", "group", "is", "None", ":", "\n", "        ", "group", "=", "_get_global_gloo_group", "(", ")", "\n", "", "if", "dist", ".", "get_world_size", "(", "group", ")", "==", "1", ":", "\n", "        ", "return", "[", "data", "]", "\n", "\n", "", "tensor", "=", "_serialize_to_tensor", "(", "data", ",", "group", ")", "\n", "\n", "size_list", ",", "tensor", "=", "_pad_to_largest_tensor", "(", "tensor", ",", "group", ")", "\n", "max_size", "=", "max", "(", "size_list", ")", "\n", "\n", "# receiving Tensor from all ranks", "\n", "tensor_list", "=", "[", "\n", "torch", ".", "empty", "(", "(", "max_size", ",", ")", ",", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "tensor", ".", "device", ")", "for", "_", "in", "size_list", "\n", "]", "\n", "dist", ".", "all_gather", "(", "tensor_list", ",", "tensor", ",", "group", "=", "group", ")", "\n", "\n", "data_list", "=", "[", "]", "\n", "for", "size", ",", "tensor", "in", "zip", "(", "size_list", ",", "tensor_list", ")", ":", "\n", "        ", "buffer", "=", "tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tobytes", "(", ")", "[", ":", "size", "]", "\n", "data_list", ".", "append", "(", "pickle", ".", "loads", "(", "buffer", ")", ")", "\n", "\n", "", "return", "data_list", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.gather": [[177, 218], ["torch.get_rank", "comm._serialize_to_tensor", "comm._pad_to_largest_tensor", "comm.get_world_size", "comm._get_global_gloo_group", "torch.get_world_size", "max", "torch.gather", "zip", "torch.gather", "torch.empty", "torch.empty", "data_list.append", "_serialize_to_tensor.cpu().numpy().tobytes", "pickle.loads", "_serialize_to_tensor.cpu().numpy", "_serialize_to_tensor.cpu"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm._serialize_to_tensor", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm._pad_to_largest_tensor", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm._get_global_gloo_group", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.gather"], ["", "def", "gather", "(", "data", ",", "dst", "=", "0", ",", "group", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Run gather on arbitrary picklable data (not necessarily tensors).\n\n    Args:\n        data: any picklable object\n        dst (int): destination rank\n        group: a torch process group. By default, will use a group which\n            contains all ranks on gloo backend.\n\n    Returns:\n        list[data]: on dst, a list of data gathered from each rank. Otherwise,\n            an empty list.\n    \"\"\"", "\n", "if", "get_world_size", "(", ")", "==", "1", ":", "\n", "        ", "return", "[", "data", "]", "\n", "", "if", "group", "is", "None", ":", "\n", "        ", "group", "=", "_get_global_gloo_group", "(", ")", "\n", "", "if", "dist", ".", "get_world_size", "(", "group", "=", "group", ")", "==", "1", ":", "\n", "        ", "return", "[", "data", "]", "\n", "", "rank", "=", "dist", ".", "get_rank", "(", "group", "=", "group", ")", "\n", "\n", "tensor", "=", "_serialize_to_tensor", "(", "data", ",", "group", ")", "\n", "size_list", ",", "tensor", "=", "_pad_to_largest_tensor", "(", "tensor", ",", "group", ")", "\n", "\n", "# receiving Tensor from all ranks", "\n", "if", "rank", "==", "dst", ":", "\n", "        ", "max_size", "=", "max", "(", "size_list", ")", "\n", "tensor_list", "=", "[", "\n", "torch", ".", "empty", "(", "(", "max_size", ",", ")", ",", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "tensor", ".", "device", ")", "for", "_", "in", "size_list", "\n", "]", "\n", "dist", ".", "gather", "(", "tensor", ",", "tensor_list", ",", "dst", "=", "dst", ",", "group", "=", "group", ")", "\n", "\n", "data_list", "=", "[", "]", "\n", "for", "size", ",", "tensor", "in", "zip", "(", "size_list", ",", "tensor_list", ")", ":", "\n", "            ", "buffer", "=", "tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tobytes", "(", ")", "[", ":", "size", "]", "\n", "data_list", ".", "append", "(", "pickle", ".", "loads", "(", "buffer", ")", ")", "\n", "", "return", "data_list", "\n", "", "else", ":", "\n", "        ", "dist", ".", "gather", "(", "tensor", ",", "[", "]", ",", "dst", "=", "dst", ",", "group", "=", "group", ")", "\n", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.shared_random_seed": [[220, 232], ["numpy.random.randint", "comm.all_gather"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather"], ["", "", "def", "shared_random_seed", "(", ")", ":", "\n", "    ", "\"\"\"\n    Returns:\n        int: a random number that is the same across all workers.\n            If workers need a shared RNG, they can use this shared seed to\n            create one.\n\n    All workers must call this function, otherwise it will deadlock.\n    \"\"\"", "\n", "ints", "=", "np", ".", "random", ".", "randint", "(", "2", "**", "31", ")", "\n", "all_ints", "=", "all_gather", "(", "ints", ")", "\n", "return", "all_ints", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.reduce_dict": [[234, 264], ["comm.get_world_size", "torch.no_grad", "torch.no_grad", "sorted", "torch.stack", "torch.stack", "torch.reduce", "input_dict.keys", "names.append", "torch.stack.append", "torch.get_rank", "zip"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.plot_basetrain_robust_modified.reduce", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank"], ["", "def", "reduce_dict", "(", "input_dict", ",", "average", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Reduce the values in the dictionary from all processes so that process with rank\n    0 has the reduced results.\n\n    Args:\n        input_dict (dict): inputs to be reduced. All the values must be scalar CUDA Tensor.\n        average (bool): whether to do average or sum\n\n    Returns:\n        a dict with the same keys as input_dict, after reduction.\n    \"\"\"", "\n", "world_size", "=", "get_world_size", "(", ")", "\n", "if", "world_size", "<", "2", ":", "\n", "        ", "return", "input_dict", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "names", "=", "[", "]", "\n", "values", "=", "[", "]", "\n", "# sort the keys so that they are consistent across processes", "\n", "for", "k", "in", "sorted", "(", "input_dict", ".", "keys", "(", ")", ")", ":", "\n", "            ", "names", ".", "append", "(", "k", ")", "\n", "values", ".", "append", "(", "input_dict", "[", "k", "]", ")", "\n", "", "values", "=", "torch", ".", "stack", "(", "values", ",", "dim", "=", "0", ")", "\n", "dist", ".", "reduce", "(", "values", ",", "dst", "=", "0", ")", "\n", "if", "dist", ".", "get_rank", "(", ")", "==", "0", "and", "average", ":", "\n", "# only main process gets accumulated, so only divide by", "\n", "# world_size in this case", "\n", "            ", "values", "/=", "world_size", "\n", "", "reduced_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "zip", "(", "names", ",", "values", ")", "}", "\n", "", "return", "reduced_dict", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.GenericMask.__init__": [[67, 94], ["isinstance", "isinstance", "isinstance", "ValueError", "isinstance", "pycocotools.frPyObjects.astype", "pycocotools.frPyObjects", "pycocotools.decode", "numpy.asarray().reshape", "type", "numpy.asarray"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "mask_or_polygons", ",", "height", ",", "width", ")", ":", "\n", "        ", "self", ".", "_mask", "=", "self", ".", "_polygons", "=", "self", ".", "_has_holes", "=", "None", "\n", "self", ".", "height", "=", "height", "\n", "self", ".", "width", "=", "width", "\n", "\n", "m", "=", "mask_or_polygons", "\n", "if", "isinstance", "(", "m", ",", "dict", ")", ":", "\n", "# RLEs", "\n", "            ", "assert", "\"counts\"", "in", "m", "and", "\"size\"", "in", "m", "\n", "if", "isinstance", "(", "m", "[", "\"counts\"", "]", ",", "list", ")", ":", "# uncompressed RLEs", "\n", "                ", "h", ",", "w", "=", "m", "[", "\"size\"", "]", "\n", "assert", "h", "==", "height", "and", "w", "==", "width", "\n", "m", "=", "mask_util", ".", "frPyObjects", "(", "m", ",", "h", ",", "w", ")", "\n", "", "self", ".", "_mask", "=", "mask_util", ".", "decode", "(", "m", ")", "[", ":", ",", ":", "]", "\n", "return", "\n", "\n", "", "if", "isinstance", "(", "m", ",", "list", ")", ":", "# list[ndarray]", "\n", "            ", "self", ".", "_polygons", "=", "[", "np", ".", "asarray", "(", "x", ")", ".", "reshape", "(", "-", "1", ")", "for", "x", "in", "m", "]", "\n", "return", "\n", "\n", "", "if", "isinstance", "(", "m", ",", "np", ".", "ndarray", ")", ":", "# assumed to be a binary mask", "\n", "            ", "assert", "m", ".", "shape", "[", "1", "]", "!=", "2", ",", "m", ".", "shape", "\n", "assert", "m", ".", "shape", "==", "(", "height", ",", "width", ")", ",", "m", ".", "shape", "\n", "self", ".", "_mask", "=", "m", ".", "astype", "(", "\"uint8\"", ")", "\n", "return", "\n", "\n", "", "raise", "ValueError", "(", "\"GenericMask cannot handle object {} of type '{}'\"", ".", "format", "(", "m", ",", "type", "(", "m", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.GenericMask.mask": [[95, 100], ["visualizer.GenericMask.polygons_to_mask"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.GenericMask.polygons_to_mask"], ["", "@", "property", "\n", "def", "mask", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_mask", "is", "None", ":", "\n", "            ", "self", ".", "_mask", "=", "self", ".", "polygons_to_mask", "(", "self", ".", "_polygons", ")", "\n", "", "return", "self", ".", "_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.GenericMask.polygons": [[101, 106], ["visualizer.GenericMask.mask_to_polygons"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.GenericMask.mask_to_polygons"], ["", "@", "property", "\n", "def", "polygons", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_polygons", "is", "None", ":", "\n", "            ", "self", ".", "_polygons", ",", "self", ".", "_has_holes", "=", "self", ".", "mask_to_polygons", "(", "self", ".", "_mask", ")", "\n", "", "return", "self", ".", "_polygons", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.GenericMask.has_holes": [[107, 115], ["visualizer.GenericMask.mask_to_polygons"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.GenericMask.mask_to_polygons"], ["", "@", "property", "\n", "def", "has_holes", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_has_holes", "is", "None", ":", "\n", "            ", "if", "self", ".", "_mask", "is", "not", "None", ":", "\n", "                ", "self", ".", "_polygons", ",", "self", ".", "_has_holes", "=", "self", ".", "mask_to_polygons", "(", "self", ".", "_mask", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_has_holes", "=", "False", "# if original format is polygon, does not have holes", "\n", "", "", "return", "self", ".", "_has_holes", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.GenericMask.mask_to_polygons": [[116, 134], ["numpy.ascontiguousarray", "cv2.findContours", "numpy.ascontiguousarray.astype", "x.flatten", "len", "hierarchy.reshape"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten"], ["", "def", "mask_to_polygons", "(", "self", ",", "mask", ")", ":", "\n", "# cv2.RETR_CCOMP flag retrieves all the contours and arranges them to a 2-level", "\n", "# hierarchy. External contours (boundary) of the object are placed in hierarchy-1.", "\n", "# Internal contours (holes) are placed in hierarchy-2.", "\n", "# cv2.CHAIN_APPROX_NONE flag gets vertices of polygons from contours.", "\n", "        ", "mask", "=", "np", ".", "ascontiguousarray", "(", "mask", ")", "# some versions of cv2 does not support incontiguous arr", "\n", "res", "=", "cv2", ".", "findContours", "(", "mask", ".", "astype", "(", "\"uint8\"", ")", ",", "cv2", ".", "RETR_CCOMP", ",", "cv2", ".", "CHAIN_APPROX_NONE", ")", "\n", "hierarchy", "=", "res", "[", "-", "1", "]", "\n", "if", "hierarchy", "is", "None", ":", "# empty mask", "\n", "            ", "return", "[", "]", ",", "False", "\n", "", "has_holes", "=", "(", "hierarchy", ".", "reshape", "(", "-", "1", ",", "4", ")", "[", ":", ",", "3", "]", ">=", "0", ")", ".", "sum", "(", ")", ">", "0", "\n", "res", "=", "res", "[", "-", "2", "]", "\n", "res", "=", "[", "x", ".", "flatten", "(", ")", "for", "x", "in", "res", "]", "\n", "# These coordinates from OpenCV are integers in range [0, W-1 or H-1].", "\n", "# We add 0.5 to turn them into real-value coordinate space. A better solution", "\n", "# would be to first +0.5 and then dilate the returned polygon by 0.5.", "\n", "res", "=", "[", "x", "+", "0.5", "for", "x", "in", "res", "if", "len", "(", "x", ")", ">=", "6", "]", "\n", "return", "res", ",", "has_holes", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.GenericMask.polygons_to_mask": [[135, 139], ["pycocotools.frPyObjects", "pycocotools.merge", "pycocotools.decode"], "methods", ["None"], ["", "def", "polygons_to_mask", "(", "self", ",", "polygons", ")", ":", "\n", "        ", "rle", "=", "mask_util", ".", "frPyObjects", "(", "polygons", ",", "self", ".", "height", ",", "self", ".", "width", ")", "\n", "rle", "=", "mask_util", ".", "merge", "(", "rle", ")", "\n", "return", "mask_util", ".", "decode", "(", "rle", ")", "[", ":", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.GenericMask.area": [[140, 142], ["visualizer.GenericMask.mask.sum"], "methods", ["None"], ["", "def", "area", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "mask", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.GenericMask.bbox": [[143, 150], ["pycocotools.frPyObjects", "pycocotools.merge", "pycocotools.toBbox"], "methods", ["None"], ["", "def", "bbox", "(", "self", ")", ":", "\n", "        ", "p", "=", "mask_util", ".", "frPyObjects", "(", "self", ".", "polygons", ",", "self", ".", "height", ",", "self", ".", "width", ")", "\n", "p", "=", "mask_util", ".", "merge", "(", "p", ")", "\n", "bbox", "=", "mask_util", ".", "toBbox", "(", "p", ")", "\n", "bbox", "[", "2", "]", "+=", "bbox", "[", "0", "]", "\n", "bbox", "[", "3", "]", "+=", "bbox", "[", "1", "]", "\n", "return", "bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer._PanopticPrediction.__init__": [[153, 188], ["torch.unique", "areas.numpy.numpy.numpy", "numpy.argsort", "visualizer._PanopticPrediction._seg_ids.tolist", "zip", "numpy.unique", "panoptic_seg.numpy", "segments_info.append", "float", "metadata.thing_dataset_id_to_contiguous_id.values", "int", "int", "bool"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "panoptic_seg", ",", "segments_info", ",", "metadata", "=", "None", ")", ":", "\n", "        ", "if", "segments_info", "is", "None", ":", "\n", "            ", "assert", "metadata", "is", "not", "None", "\n", "# If \"segments_info\" is None, we assume \"panoptic_img\" is a", "\n", "# H*W int32 image storing the panoptic_id in the format of", "\n", "# category_id * label_divisor + instance_id. We reserve -1 for", "\n", "# VOID label.", "\n", "label_divisor", "=", "metadata", ".", "label_divisor", "\n", "segments_info", "=", "[", "]", "\n", "for", "panoptic_label", "in", "np", ".", "unique", "(", "panoptic_seg", ".", "numpy", "(", ")", ")", ":", "\n", "                ", "if", "panoptic_label", "==", "-", "1", ":", "\n", "# VOID region.", "\n", "                    ", "continue", "\n", "", "pred_class", "=", "panoptic_label", "//", "label_divisor", "\n", "isthing", "=", "pred_class", "in", "metadata", ".", "thing_dataset_id_to_contiguous_id", ".", "values", "(", ")", "\n", "segments_info", ".", "append", "(", "\n", "{", "\n", "\"id\"", ":", "int", "(", "panoptic_label", ")", ",", "\n", "\"category_id\"", ":", "int", "(", "pred_class", ")", ",", "\n", "\"isthing\"", ":", "bool", "(", "isthing", ")", ",", "\n", "}", "\n", ")", "\n", "", "", "del", "metadata", "\n", "\n", "self", ".", "_seg", "=", "panoptic_seg", "\n", "\n", "self", ".", "_sinfo", "=", "{", "s", "[", "\"id\"", "]", ":", "s", "for", "s", "in", "segments_info", "}", "# seg id -> seg info", "\n", "segment_ids", ",", "areas", "=", "torch", ".", "unique", "(", "panoptic_seg", ",", "sorted", "=", "True", ",", "return_counts", "=", "True", ")", "\n", "areas", "=", "areas", ".", "numpy", "(", ")", "\n", "sorted_idxs", "=", "np", ".", "argsort", "(", "-", "areas", ")", "\n", "self", ".", "_seg_ids", ",", "self", ".", "_seg_areas", "=", "segment_ids", "[", "sorted_idxs", "]", ",", "areas", "[", "sorted_idxs", "]", "\n", "self", ".", "_seg_ids", "=", "self", ".", "_seg_ids", ".", "tolist", "(", ")", "\n", "for", "sid", ",", "area", "in", "zip", "(", "self", ".", "_seg_ids", ",", "self", ".", "_seg_areas", ")", ":", "\n", "            ", "if", "sid", "in", "self", ".", "_sinfo", ":", "\n", "                ", "self", ".", "_sinfo", "[", "sid", "]", "[", "\"area\"", "]", "=", "float", "(", "area", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer._PanopticPrediction.non_empty_mask": [[189, 204], ["len", "numpy.zeros", "len", "empty_ids.append"], "methods", ["None"], ["", "", "", "def", "non_empty_mask", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            (H, W) array, a mask for all pixels that have a prediction\n        \"\"\"", "\n", "empty_ids", "=", "[", "]", "\n", "for", "id", "in", "self", ".", "_seg_ids", ":", "\n", "            ", "if", "id", "not", "in", "self", ".", "_sinfo", ":", "\n", "                ", "empty_ids", ".", "append", "(", "id", ")", "\n", "", "", "if", "len", "(", "empty_ids", ")", "==", "0", ":", "\n", "            ", "return", "np", ".", "zeros", "(", "self", ".", "_seg", ".", "shape", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "", "assert", "(", "\n", "len", "(", "empty_ids", ")", "==", "1", "\n", ")", ",", "\">1 ids corresponds to no labels. This is currently not supported\"", "\n", "return", "(", "self", ".", "_seg", "!=", "empty_ids", "[", "0", "]", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "bool", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer._PanopticPrediction.semantic_masks": [[205, 212], ["visualizer._PanopticPrediction._sinfo.get"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "def", "semantic_masks", "(", "self", ")", ":", "\n", "        ", "for", "sid", "in", "self", ".", "_seg_ids", ":", "\n", "            ", "sinfo", "=", "self", ".", "_sinfo", ".", "get", "(", "sid", ")", "\n", "if", "sinfo", "is", "None", "or", "sinfo", "[", "\"isthing\"", "]", ":", "\n", "# Some pixels (e.g. id 0 in PanopticFPN) have no instance or semantic predictions.", "\n", "                ", "continue", "\n", "", "yield", "(", "self", ".", "_seg", "==", "sid", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "bool", ")", ",", "sinfo", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer._PanopticPrediction.instance_masks": [[213, 221], ["visualizer._PanopticPrediction._sinfo.get", "mask.sum"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "", "def", "instance_masks", "(", "self", ")", ":", "\n", "        ", "for", "sid", "in", "self", ".", "_seg_ids", ":", "\n", "            ", "sinfo", "=", "self", ".", "_sinfo", ".", "get", "(", "sid", ")", "\n", "if", "sinfo", "is", "None", "or", "not", "sinfo", "[", "\"isthing\"", "]", ":", "\n", "                ", "continue", "\n", "", "mask", "=", "(", "self", ".", "_seg", "==", "sid", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "bool", ")", "\n", "if", "mask", ".", "sum", "(", ")", ">", "0", ":", "\n", "                ", "yield", "mask", ",", "sinfo", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.__init__": [[245, 255], ["visualizer.VisImage._setup_figure"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage._setup_figure"], ["    ", "def", "__init__", "(", "self", ",", "img", ",", "scale", "=", "1.0", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            img (ndarray): an RGB image of shape (H, W, 3).\n            scale (float): scale the input image\n        \"\"\"", "\n", "self", ".", "img", "=", "img", "\n", "self", ".", "scale", "=", "scale", "\n", "self", ".", "width", ",", "self", ".", "height", "=", "img", ".", "shape", "[", "1", "]", ",", "img", ".", "shape", "[", "0", "]", "\n", "self", ".", "_setup_figure", "(", "img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage._setup_figure": [[256, 282], ["matplotlib.Figure", "matplotlib.Figure", "matplotlib.Figure", "matplotlib.Figure.get_dpi", "matplotlib.Figure.set_size_inches", "matplotlib.backends.backend_agg.FigureCanvasAgg", "matplotlib.backends.backend_agg.FigureCanvasAgg", "matplotlib.backends.backend_agg.FigureCanvasAgg", "matplotlib.Figure.add_axes", "mplfigure.Figure.add_axes.axis", "mplfigure.Figure.add_axes.imshow"], "methods", ["None"], ["", "def", "_setup_figure", "(", "self", ",", "img", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            Same as in :meth:`__init__()`.\n\n        Returns:\n            fig (matplotlib.pyplot.figure): top level container for all the image plot elements.\n            ax (matplotlib.pyplot.Axes): contains figure elements and sets the coordinate system.\n        \"\"\"", "\n", "fig", "=", "mplfigure", ".", "Figure", "(", "frameon", "=", "False", ")", "\n", "self", ".", "dpi", "=", "fig", ".", "get_dpi", "(", ")", "\n", "# add a small 1e-2 to avoid precision lost due to matplotlib's truncation", "\n", "# (https://github.com/matplotlib/matplotlib/issues/15363)", "\n", "fig", ".", "set_size_inches", "(", "\n", "(", "self", ".", "width", "*", "self", ".", "scale", "+", "1e-2", ")", "/", "self", ".", "dpi", ",", "\n", "(", "self", ".", "height", "*", "self", ".", "scale", "+", "1e-2", ")", "/", "self", ".", "dpi", ",", "\n", ")", "\n", "self", ".", "canvas", "=", "FigureCanvasAgg", "(", "fig", ")", "\n", "# self.canvas = mpl.backends.backend_cairo.FigureCanvasCairo(fig)", "\n", "ax", "=", "fig", ".", "add_axes", "(", "[", "0.0", ",", "0.0", ",", "1.0", ",", "1.0", "]", ")", "\n", "ax", ".", "axis", "(", "\"off\"", ")", "\n", "# Need to imshow this first so that other patches can be drawn on top", "\n", "ax", ".", "imshow", "(", "img", ",", "extent", "=", "(", "0", ",", "self", ".", "width", ",", "self", ".", "height", ",", "0", ")", ",", "interpolation", "=", "\"nearest\"", ")", "\n", "\n", "self", ".", "fig", "=", "fig", "\n", "self", ".", "ax", "=", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save": [[283, 290], ["visualizer.VisImage.fig.savefig"], "methods", ["None"], ["", "def", "save", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            filepath (str): a string that contains the absolute path, including the file name, where\n                the visualized image will be saved.\n        \"\"\"", "\n", "self", ".", "fig", ".", "savefig", "(", "filepath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.get_image": [[291, 310], ["canvas.print_to_buffer", "numpy.frombuffer", "numpy.frombuffer.reshape", "numpy.split", "rgb.astype"], "methods", ["None"], ["", "def", "get_image", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            ndarray:\n                the visualized image of shape (H, W, 3) (RGB) in uint8 type.\n                The shape is scaled w.r.t the input image using the given `scale` argument.\n        \"\"\"", "\n", "canvas", "=", "self", ".", "canvas", "\n", "s", ",", "(", "width", ",", "height", ")", "=", "canvas", ".", "print_to_buffer", "(", ")", "\n", "# buf = io.BytesIO()  # works for cairo backend", "\n", "# canvas.print_rgba(buf)", "\n", "# width, height = self.width, self.height", "\n", "# s = buf.getvalue()", "\n", "\n", "buffer", "=", "np", ".", "frombuffer", "(", "s", ",", "dtype", "=", "\"uint8\"", ")", "\n", "\n", "img_rgba", "=", "buffer", ".", "reshape", "(", "height", ",", "width", ",", "4", ")", "\n", "rgb", ",", "alpha", "=", "np", ".", "split", "(", "img_rgba", ",", "[", "3", "]", ",", "axis", "=", "2", ")", "\n", "return", "rgb", ".", "astype", "(", "\"uint8\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.__init__": [[334, 358], ["numpy.asarray().clip().astype", "visualizer.VisImage", "torch.device", "max", "detectron2.data.MetadataCatalog.get", "numpy.asarray().clip", "numpy.sqrt", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clip"], ["def", "__init__", "(", "self", ",", "img_rgb", ",", "metadata", "=", "None", ",", "scale", "=", "1.0", ",", "instance_mode", "=", "ColorMode", ".", "IMAGE", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            img_rgb: a numpy array of shape (H, W, C), where H and W correspond to\n                the height and width of the image respectively. C is the number of\n                color channels. The image is required to be in RGB format since that\n                is a requirement of the Matplotlib library. The image is also expected\n                to be in the range [0, 255].\n            metadata (Metadata): image metadata.\n            instance_mode (ColorMode): defines one of the pre-defined style for drawing\n                instances on an image.\n        \"\"\"", "\n", "self", ".", "img", "=", "np", ".", "asarray", "(", "img_rgb", ")", ".", "clip", "(", "0", ",", "255", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "if", "metadata", "is", "None", ":", "\n", "            ", "metadata", "=", "MetadataCatalog", ".", "get", "(", "\"__nonexist__\"", ")", "\n", "", "self", ".", "metadata", "=", "metadata", "\n", "self", ".", "output", "=", "VisImage", "(", "self", ".", "img", ",", "scale", "=", "scale", ")", "\n", "self", ".", "cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "\n", "# too small texts are useless, therefore clamp to 9", "\n", "self", ".", "_default_font_size", "=", "max", "(", "\n", "np", ".", "sqrt", "(", "self", ".", "output", ".", "height", "*", "self", ".", "output", ".", "width", ")", "//", "90", ",", "10", "//", "scale", "\n", ")", "\n", "self", ".", "_instance_mode", "=", "instance_mode", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_instance_predictions": [[359, 409], ["visualizer._create_text_labels", "predictions.has", "visualizer.Visualizer.overlay_instances", "predictions.has", "predictions.has", "predictions.has", "visualizer.Visualizer.metadata.get", "predictions.has", "numpy.asarray", "visualizer.Visualizer.metadata.get", "visualizer.Visualizer._create_grayscale_image", "visualizer.GenericMask", "visualizer.Visualizer._jitter", "predictions.has", "predictions.pred_masks.any"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer._create_text_labels", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer._create_grayscale_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer._jitter", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has"], ["", "def", "draw_instance_predictions", "(", "self", ",", "predictions", ")", ":", "\n", "        ", "\"\"\"\n        Draw instance-level prediction results on an image.\n\n        Args:\n            predictions (Instances): the output of an instance detection/segmentation\n                model. Following fields will be used to draw:\n                \"pred_boxes\", \"pred_classes\", \"scores\", \"pred_masks\" (or \"pred_masks_rle\").\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"", "\n", "boxes", "=", "predictions", ".", "pred_boxes", "if", "predictions", ".", "has", "(", "\"pred_boxes\"", ")", "else", "None", "\n", "scores", "=", "predictions", ".", "scores", "if", "predictions", ".", "has", "(", "\"scores\"", ")", "else", "None", "\n", "classes", "=", "predictions", ".", "pred_classes", "if", "predictions", ".", "has", "(", "\"pred_classes\"", ")", "else", "None", "\n", "labels", "=", "_create_text_labels", "(", "classes", ",", "scores", ",", "self", ".", "metadata", ".", "get", "(", "\"thing_classes\"", ",", "None", ")", ")", "\n", "keypoints", "=", "predictions", ".", "pred_keypoints", "if", "predictions", ".", "has", "(", "\"pred_keypoints\"", ")", "else", "None", "\n", "\n", "if", "predictions", ".", "has", "(", "\"pred_masks\"", ")", ":", "\n", "            ", "masks", "=", "np", ".", "asarray", "(", "predictions", ".", "pred_masks", ")", "\n", "masks", "=", "[", "GenericMask", "(", "x", ",", "self", ".", "output", ".", "height", ",", "self", ".", "output", ".", "width", ")", "for", "x", "in", "masks", "]", "\n", "", "else", ":", "\n", "            ", "masks", "=", "None", "\n", "\n", "", "if", "self", ".", "_instance_mode", "==", "ColorMode", ".", "SEGMENTATION", "and", "self", ".", "metadata", ".", "get", "(", "\"thing_colors\"", ")", ":", "\n", "            ", "colors", "=", "[", "\n", "self", ".", "_jitter", "(", "[", "x", "/", "255", "for", "x", "in", "self", ".", "metadata", ".", "thing_colors", "[", "c", "]", "]", ")", "for", "c", "in", "classes", "\n", "]", "\n", "alpha", "=", "0.8", "\n", "", "else", ":", "\n", "            ", "colors", "=", "None", "\n", "alpha", "=", "0.5", "\n", "\n", "", "if", "self", ".", "_instance_mode", "==", "ColorMode", ".", "IMAGE_BW", ":", "\n", "            ", "self", ".", "output", ".", "img", "=", "self", ".", "_create_grayscale_image", "(", "\n", "(", "predictions", ".", "pred_masks", ".", "any", "(", "dim", "=", "0", ")", ">", "0", ")", ".", "numpy", "(", ")", "\n", "if", "predictions", ".", "has", "(", "\"pred_masks\"", ")", "\n", "else", "None", "\n", ")", "\n", "alpha", "=", "0.3", "\n", "\n", "", "self", ".", "overlay_instances", "(", "\n", "masks", "=", "masks", ",", "\n", "boxes", "=", "boxes", ",", "\n", "labels", "=", "labels", ",", "\n", "keypoints", "=", "keypoints", ",", "\n", "assigned_colors", "=", "colors", ",", "\n", "alpha", "=", "alpha", ",", "\n", ")", "\n", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_sem_seg": [[410, 445], ["isinstance", "numpy.unique", "numpy.argsort().tolist", "filter", "sem_seg.numpy.numpy.numpy", "visualizer.Visualizer.draw_binary_mask", "numpy.argsort", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_binary_mask"], ["", "def", "draw_sem_seg", "(", "self", ",", "sem_seg", ",", "area_threshold", "=", "None", ",", "alpha", "=", "0.8", ")", ":", "\n", "        ", "\"\"\"\n        Draw semantic segmentation predictions/labels.\n\n        Args:\n            sem_seg (Tensor or ndarray): the segmentation of shape (H, W).\n                Each value is the integer label of the pixel.\n            area_threshold (int): segments with less than `area_threshold` are not drawn.\n            alpha (float): the larger it is, the more opaque the segmentations are.\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"", "\n", "if", "isinstance", "(", "sem_seg", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "sem_seg", "=", "sem_seg", ".", "numpy", "(", ")", "\n", "", "labels", ",", "areas", "=", "np", ".", "unique", "(", "sem_seg", ",", "return_counts", "=", "True", ")", "\n", "sorted_idxs", "=", "np", ".", "argsort", "(", "-", "areas", ")", ".", "tolist", "(", ")", "\n", "labels", "=", "labels", "[", "sorted_idxs", "]", "\n", "for", "label", "in", "filter", "(", "lambda", "l", ":", "l", "<", "len", "(", "self", ".", "metadata", ".", "stuff_classes", ")", ",", "labels", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "mask_color", "=", "[", "x", "/", "255", "for", "x", "in", "self", ".", "metadata", ".", "stuff_colors", "[", "label", "]", "]", "\n", "", "except", "(", "AttributeError", ",", "IndexError", ")", ":", "\n", "                ", "mask_color", "=", "None", "\n", "\n", "", "binary_mask", "=", "(", "sem_seg", "==", "label", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "text", "=", "self", ".", "metadata", ".", "stuff_classes", "[", "label", "]", "\n", "self", ".", "draw_binary_mask", "(", "\n", "binary_mask", ",", "\n", "color", "=", "mask_color", ",", "\n", "edge_color", "=", "_OFF_WHITE", ",", "\n", "text", "=", "text", ",", "\n", "alpha", "=", "alpha", ",", "\n", "area_threshold", "=", "area_threshold", ",", "\n", ")", "\n", "", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_panoptic_seg_predictions": [[446, 507], ["visualizer._PanopticPrediction", "visualizer._PanopticPrediction.semantic_masks", "list", "list", "visualizer._create_text_labels", "visualizer.Visualizer.overlay_instances", "visualizer.Visualizer._create_grayscale_image", "visualizer.Visualizer.draw_binary_mask", "visualizer._PanopticPrediction.instance_masks", "len", "zip", "visualizer._PanopticPrediction.non_empty_mask", "visualizer.Visualizer._jitter"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer._PanopticPrediction.semantic_masks", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer._create_text_labels", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer._create_grayscale_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_binary_mask", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer._PanopticPrediction.instance_masks", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer._PanopticPrediction.non_empty_mask", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer._jitter"], ["", "def", "draw_panoptic_seg_predictions", "(", "\n", "self", ",", "panoptic_seg", ",", "segments_info", ",", "area_threshold", "=", "None", ",", "alpha", "=", "0.7", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Draw panoptic prediction results on an image.\n\n        Args:\n            panoptic_seg (Tensor): of shape (height, width) where the values are ids for each\n                segment.\n            segments_info (list[dict]): Describe each segment in `panoptic_seg`.\n                Each dict contains keys \"id\", \"category_id\", \"isthing\".\n            area_threshold (int): stuff segments with less than `area_threshold` are not drawn.\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"", "\n", "pred", "=", "_PanopticPrediction", "(", "panoptic_seg", ",", "segments_info", ",", "self", ".", "metadata", ")", "\n", "\n", "if", "self", ".", "_instance_mode", "==", "ColorMode", ".", "IMAGE_BW", ":", "\n", "            ", "self", ".", "output", ".", "img", "=", "self", ".", "_create_grayscale_image", "(", "pred", ".", "non_empty_mask", "(", ")", ")", "\n", "\n", "# draw mask for all semantic segments first i.e. \"stuff\"", "\n", "", "for", "mask", ",", "sinfo", "in", "pred", ".", "semantic_masks", "(", ")", ":", "\n", "            ", "category_idx", "=", "sinfo", "[", "\"category_id\"", "]", "\n", "try", ":", "\n", "                ", "mask_color", "=", "[", "x", "/", "255", "for", "x", "in", "self", ".", "metadata", ".", "stuff_colors", "[", "category_idx", "]", "]", "\n", "", "except", "AttributeError", ":", "\n", "                ", "mask_color", "=", "None", "\n", "\n", "", "text", "=", "self", ".", "metadata", ".", "stuff_classes", "[", "category_idx", "]", "\n", "self", ".", "draw_binary_mask", "(", "\n", "mask", ",", "\n", "color", "=", "mask_color", ",", "\n", "edge_color", "=", "_OFF_WHITE", ",", "\n", "text", "=", "text", ",", "\n", "alpha", "=", "alpha", ",", "\n", "area_threshold", "=", "area_threshold", ",", "\n", ")", "\n", "\n", "# draw mask for all instances second", "\n", "", "all_instances", "=", "list", "(", "pred", ".", "instance_masks", "(", ")", ")", "\n", "if", "len", "(", "all_instances", ")", "==", "0", ":", "\n", "            ", "return", "self", ".", "output", "\n", "", "masks", ",", "sinfo", "=", "list", "(", "zip", "(", "*", "all_instances", ")", ")", "\n", "category_ids", "=", "[", "x", "[", "\"category_id\"", "]", "for", "x", "in", "sinfo", "]", "\n", "\n", "try", ":", "\n", "            ", "scores", "=", "[", "x", "[", "\"score\"", "]", "for", "x", "in", "sinfo", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "scores", "=", "None", "\n", "", "labels", "=", "_create_text_labels", "(", "category_ids", ",", "scores", ",", "self", ".", "metadata", ".", "thing_classes", ")", "\n", "\n", "try", ":", "\n", "            ", "colors", "=", "[", "\n", "self", ".", "_jitter", "(", "[", "x", "/", "255", "for", "x", "in", "self", ".", "metadata", ".", "thing_colors", "[", "c", "]", "]", ")", "for", "c", "in", "category_ids", "\n", "]", "\n", "", "except", "AttributeError", ":", "\n", "            ", "colors", "=", "None", "\n", "", "self", ".", "overlay_instances", "(", "masks", "=", "masks", ",", "labels", "=", "labels", ",", "assigned_colors", "=", "colors", ",", "alpha", "=", "alpha", ")", "\n", "\n", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_dataset_dict": [[508, 571], ["dic.get", "dic.get", "dic.get", "visualizer.Visualizer.metadata.get", "visualizer.Visualizer.overlay_instances", "visualizer.Visualizer.draw_sem_seg", "torch.Tensor", "visualizer.Visualizer.draw_panoptic_seg_predictions", "numpy.array().reshape", "detectron2.structures.BoxMode.convert", "visualizer.Visualizer.metadata.get", "fvcore.common.file_io.PathManager.open", "PIL.Image.open", "numpy.asarray", "fvcore.common.file_io.PathManager.open", "PIL.Image.open", "numpy.asarray", "rgb2id", "len", "visualizer.Visualizer._jitter", "zip", "numpy.array", "a.get"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.video_visualizer.VideoVisualizer.draw_sem_seg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.video_visualizer.VideoVisualizer.draw_panoptic_seg_predictions", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer._jitter", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "def", "draw_dataset_dict", "(", "self", ",", "dic", ")", ":", "\n", "        ", "\"\"\"\n        Draw annotations/segmentaions in Detectron2 Dataset format.\n\n        Args:\n            dic (dict): annotation/segmentation data of one image, in Detectron2 Dataset format.\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"", "\n", "annos", "=", "dic", ".", "get", "(", "\"annotations\"", ",", "None", ")", "\n", "if", "annos", ":", "\n", "            ", "if", "\"segmentation\"", "in", "annos", "[", "0", "]", ":", "\n", "                ", "masks", "=", "[", "x", "[", "\"segmentation\"", "]", "for", "x", "in", "annos", "]", "\n", "", "else", ":", "\n", "                ", "masks", "=", "None", "\n", "", "if", "\"keypoints\"", "in", "annos", "[", "0", "]", ":", "\n", "                ", "keypts", "=", "[", "x", "[", "\"keypoints\"", "]", "for", "x", "in", "annos", "]", "\n", "keypts", "=", "np", ".", "array", "(", "keypts", ")", ".", "reshape", "(", "len", "(", "annos", ")", ",", "-", "1", ",", "3", ")", "\n", "", "else", ":", "\n", "                ", "keypts", "=", "None", "\n", "\n", "", "boxes", "=", "[", "BoxMode", ".", "convert", "(", "x", "[", "\"bbox\"", "]", ",", "x", "[", "\"bbox_mode\"", "]", ",", "BoxMode", ".", "XYXY_ABS", ")", "for", "x", "in", "annos", "]", "\n", "\n", "labels", "=", "[", "x", "[", "\"category_id\"", "]", "for", "x", "in", "annos", "]", "\n", "colors", "=", "None", "\n", "if", "self", ".", "_instance_mode", "==", "ColorMode", ".", "SEGMENTATION", "and", "self", ".", "metadata", ".", "get", "(", "\"thing_colors\"", ")", ":", "\n", "                ", "colors", "=", "[", "\n", "self", ".", "_jitter", "(", "[", "x", "/", "255", "for", "x", "in", "self", ".", "metadata", ".", "thing_colors", "[", "c", "]", "]", ")", "for", "c", "in", "labels", "\n", "]", "\n", "", "names", "=", "self", ".", "metadata", ".", "get", "(", "\"thing_classes\"", ",", "None", ")", "\n", "if", "names", ":", "\n", "                ", "labels", "=", "[", "names", "[", "i", "]", "for", "i", "in", "labels", "]", "\n", "", "labels", "=", "[", "\n", "\"{}\"", ".", "format", "(", "i", ")", "+", "(", "\"|crowd\"", "if", "a", ".", "get", "(", "\"iscrowd\"", ",", "0", ")", "else", "\"\"", ")", "\n", "for", "i", ",", "a", "in", "zip", "(", "labels", ",", "annos", ")", "\n", "]", "\n", "self", ".", "overlay_instances", "(", "\n", "labels", "=", "labels", ",", "boxes", "=", "boxes", ",", "masks", "=", "masks", ",", "keypoints", "=", "keypts", ",", "assigned_colors", "=", "colors", "\n", ")", "\n", "\n", "", "sem_seg", "=", "dic", ".", "get", "(", "\"sem_seg\"", ",", "None", ")", "\n", "if", "sem_seg", "is", "None", "and", "\"sem_seg_file_name\"", "in", "dic", ":", "\n", "            ", "with", "PathManager", ".", "open", "(", "dic", "[", "\"sem_seg_file_name\"", "]", ",", "\"rb\"", ")", "as", "f", ":", "\n", "                ", "sem_seg", "=", "Image", ".", "open", "(", "f", ")", "\n", "sem_seg", "=", "np", ".", "asarray", "(", "sem_seg", ",", "dtype", "=", "\"uint8\"", ")", "\n", "", "", "if", "sem_seg", "is", "not", "None", ":", "\n", "            ", "self", ".", "draw_sem_seg", "(", "sem_seg", ",", "area_threshold", "=", "0", ",", "alpha", "=", "0.5", ")", "\n", "\n", "", "pan_seg", "=", "dic", ".", "get", "(", "\"pan_seg\"", ",", "None", ")", "\n", "if", "pan_seg", "is", "None", "and", "\"pan_seg_file_name\"", "in", "dic", ":", "\n", "            ", "assert", "\"segments_info\"", "in", "dic", "\n", "with", "PathManager", ".", "open", "(", "dic", "[", "\"pan_seg_file_name\"", "]", ",", "\"rb\"", ")", "as", "f", ":", "\n", "                ", "pan_seg", "=", "Image", ".", "open", "(", "f", ")", "\n", "pan_seg", "=", "np", ".", "asarray", "(", "pan_seg", ")", "\n", "from", "panopticapi", ".", "utils", "import", "rgb2id", "\n", "\n", "pan_seg", "=", "rgb2id", "(", "pan_seg", ")", "\n", "", "segments_info", "=", "dic", "[", "\"segments_info\"", "]", "\n", "", "if", "pan_seg", "is", "not", "None", ":", "\n", "            ", "pan_seg", "=", "torch", ".", "Tensor", "(", "pan_seg", ")", "\n", "self", ".", "draw_panoptic_seg_predictions", "(", "pan_seg", ",", "segments_info", ",", "area_threshold", "=", "0", ",", "alpha", "=", "0.5", ")", "\n", "", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.overlay_instances": [[572, 714], ["range", "visualizer.Visualizer._convert_boxes", "len", "visualizer.Visualizer._convert_masks", "visualizer.Visualizer._convert_keypoints", "visualizer.Visualizer.overlay_rotated_instances", "numpy.prod", "numpy.argsort().tolist", "len", "len", "len", "colormap.random_color", "numpy.asarray", "visualizer.Visualizer.draw_box", "visualizer.Visualizer._change_color_brightness", "visualizer.Visualizer.draw_text", "visualizer.Visualizer.draw_and_connect_keypoints", "len", "len", "range", "numpy.argsort", "visualizer.Visualizer.draw_polygon", "numpy.sqrt", "x.area", "segment.reshape", "masks[].bbox", "numpy.clip", "len", "numpy.median", "masks[].mask.nonzero"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer._convert_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer._convert_masks", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer._convert_keypoints", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.overlay_rotated_instances", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.colormap.random_color", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_box", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer._change_color_brightness", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_text", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_and_connect_keypoints", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_polygon", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.GenericMask.bbox", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clip"], ["", "def", "overlay_instances", "(", "\n", "self", ",", "\n", "*", ",", "\n", "boxes", "=", "None", ",", "\n", "labels", "=", "None", ",", "\n", "masks", "=", "None", ",", "\n", "keypoints", "=", "None", ",", "\n", "assigned_colors", "=", "None", ",", "\n", "alpha", "=", "0.5", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            boxes (Boxes, RotatedBoxes or ndarray): either a :class:`Boxes`,\n                or an Nx4 numpy array of XYXY_ABS format for the N objects in a single image,\n                or a :class:`RotatedBoxes`,\n                or an Nx5 numpy array of (x_center, y_center, width, height, angle_degrees) format\n                for the N objects in a single image,\n            labels (list[str]): the text to be displayed for each instance.\n            masks (masks-like object): Supported types are:\n\n                * :class:`detectron2.structures.PolygonMasks`,\n                  :class:`detectron2.structures.BitMasks`.\n                * list[list[ndarray]]: contains the segmentation masks for all objects in one image.\n                  The first level of the list corresponds to individual instances. The second\n                  level to all the polygon that compose the instance, and the third level\n                  to the polygon coordinates. The third level should have the format of\n                  [x0, y0, x1, y1, ..., xn, yn] (n >= 3).\n                * list[ndarray]: each ndarray is a binary mask of shape (H, W).\n                * list[dict]: each dict is a COCO-style RLE.\n            keypoints (Keypoint or array like): an array-like object of shape (N, K, 3),\n                where the N is the number of instances and K is the number of keypoints.\n                The last dimension corresponds to (x, y, visibility or score).\n            assigned_colors (list[matplotlib.colors]): a list of colors, where each color\n                corresponds to each mask or box in the image. Refer to 'matplotlib.colors'\n                for full list of formats that the colors are accepted in.\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"", "\n", "num_instances", "=", "None", "\n", "if", "boxes", "is", "not", "None", ":", "\n", "            ", "boxes", "=", "self", ".", "_convert_boxes", "(", "boxes", ")", "\n", "num_instances", "=", "len", "(", "boxes", ")", "\n", "", "if", "masks", "is", "not", "None", ":", "\n", "            ", "masks", "=", "self", ".", "_convert_masks", "(", "masks", ")", "\n", "if", "num_instances", ":", "\n", "                ", "assert", "len", "(", "masks", ")", "==", "num_instances", "\n", "", "else", ":", "\n", "                ", "num_instances", "=", "len", "(", "masks", ")", "\n", "", "", "if", "keypoints", "is", "not", "None", ":", "\n", "            ", "if", "num_instances", ":", "\n", "                ", "assert", "len", "(", "keypoints", ")", "==", "num_instances", "\n", "", "else", ":", "\n", "                ", "num_instances", "=", "len", "(", "keypoints", ")", "\n", "", "keypoints", "=", "self", ".", "_convert_keypoints", "(", "keypoints", ")", "\n", "", "if", "labels", "is", "not", "None", ":", "\n", "            ", "assert", "len", "(", "labels", ")", "==", "num_instances", "\n", "", "if", "assigned_colors", "is", "None", ":", "\n", "            ", "assigned_colors", "=", "[", "random_color", "(", "rgb", "=", "True", ",", "maximum", "=", "1", ")", "for", "_", "in", "range", "(", "num_instances", ")", "]", "\n", "", "if", "num_instances", "==", "0", ":", "\n", "            ", "return", "self", ".", "output", "\n", "", "if", "boxes", "is", "not", "None", "and", "boxes", ".", "shape", "[", "1", "]", "==", "5", ":", "\n", "            ", "return", "self", ".", "overlay_rotated_instances", "(", "\n", "boxes", "=", "boxes", ",", "labels", "=", "labels", ",", "assigned_colors", "=", "assigned_colors", "\n", ")", "\n", "\n", "# Display in largest to smallest order to reduce occlusion.", "\n", "", "areas", "=", "None", "\n", "if", "boxes", "is", "not", "None", ":", "\n", "            ", "areas", "=", "np", ".", "prod", "(", "boxes", "[", ":", ",", "2", ":", "]", "-", "boxes", "[", ":", ",", ":", "2", "]", ",", "axis", "=", "1", ")", "\n", "", "elif", "masks", "is", "not", "None", ":", "\n", "            ", "areas", "=", "np", ".", "asarray", "(", "[", "x", ".", "area", "(", ")", "for", "x", "in", "masks", "]", ")", "\n", "\n", "", "if", "areas", "is", "not", "None", ":", "\n", "            ", "sorted_idxs", "=", "np", ".", "argsort", "(", "-", "areas", ")", ".", "tolist", "(", ")", "\n", "# Re-order overlapped instances in descending order.", "\n", "boxes", "=", "boxes", "[", "sorted_idxs", "]", "if", "boxes", "is", "not", "None", "else", "None", "\n", "labels", "=", "[", "labels", "[", "k", "]", "for", "k", "in", "sorted_idxs", "]", "if", "labels", "is", "not", "None", "else", "None", "\n", "masks", "=", "[", "masks", "[", "idx", "]", "for", "idx", "in", "sorted_idxs", "]", "if", "masks", "is", "not", "None", "else", "None", "\n", "assigned_colors", "=", "[", "assigned_colors", "[", "idx", "]", "for", "idx", "in", "sorted_idxs", "]", "\n", "keypoints", "=", "keypoints", "[", "sorted_idxs", "]", "if", "keypoints", "is", "not", "None", "else", "None", "\n", "\n", "", "for", "i", "in", "range", "(", "num_instances", ")", ":", "\n", "            ", "color", "=", "assigned_colors", "[", "i", "]", "\n", "if", "boxes", "is", "not", "None", ":", "\n", "                ", "self", ".", "draw_box", "(", "boxes", "[", "i", "]", ",", "edge_color", "=", "color", ")", "\n", "\n", "", "if", "masks", "is", "not", "None", ":", "\n", "                ", "for", "segment", "in", "masks", "[", "i", "]", ".", "polygons", ":", "\n", "                    ", "self", ".", "draw_polygon", "(", "segment", ".", "reshape", "(", "-", "1", ",", "2", ")", ",", "color", ",", "alpha", "=", "alpha", ")", "\n", "\n", "", "", "if", "labels", "is", "not", "None", ":", "\n", "# first get a box", "\n", "                ", "if", "boxes", "is", "not", "None", ":", "\n", "                    ", "x0", ",", "y0", ",", "x1", ",", "y1", "=", "boxes", "[", "i", "]", "\n", "text_pos", "=", "(", "x0", ",", "y0", ")", "# if drawing boxes, put text on the box corner.", "\n", "horiz_align", "=", "\"left\"", "\n", "", "elif", "masks", "is", "not", "None", ":", "\n", "# skip small mask without polygon", "\n", "                    ", "if", "len", "(", "masks", "[", "i", "]", ".", "polygons", ")", "==", "0", ":", "\n", "                        ", "continue", "\n", "\n", "", "x0", ",", "y0", ",", "x1", ",", "y1", "=", "masks", "[", "i", "]", ".", "bbox", "(", ")", "\n", "\n", "# draw text in the center (defined by median) when box is not drawn", "\n", "# median is less sensitive to outliers.", "\n", "text_pos", "=", "np", ".", "median", "(", "masks", "[", "i", "]", ".", "mask", ".", "nonzero", "(", ")", ",", "axis", "=", "1", ")", "[", ":", ":", "-", "1", "]", "\n", "horiz_align", "=", "\"center\"", "\n", "", "else", ":", "\n", "                    ", "continue", "# drawing the box confidence for keypoints isn't very useful.", "\n", "# for small objects, draw text at the side to avoid occlusion", "\n", "", "instance_area", "=", "(", "y1", "-", "y0", ")", "*", "(", "x1", "-", "x0", ")", "\n", "if", "(", "\n", "instance_area", "<", "_SMALL_OBJECT_AREA_THRESH", "*", "self", ".", "output", ".", "scale", "\n", "or", "y1", "-", "y0", "<", "40", "*", "self", ".", "output", ".", "scale", "\n", ")", ":", "\n", "                    ", "if", "y1", ">=", "self", ".", "output", ".", "height", "-", "5", ":", "\n", "                        ", "text_pos", "=", "(", "x1", ",", "y0", ")", "\n", "", "else", ":", "\n", "                        ", "text_pos", "=", "(", "x0", ",", "y1", ")", "\n", "\n", "", "", "height_ratio", "=", "(", "y1", "-", "y0", ")", "/", "np", ".", "sqrt", "(", "self", ".", "output", ".", "height", "*", "self", ".", "output", ".", "width", ")", "\n", "lighter_color", "=", "self", ".", "_change_color_brightness", "(", "color", ",", "brightness_factor", "=", "0.7", ")", "\n", "font_size", "=", "(", "\n", "np", ".", "clip", "(", "(", "height_ratio", "-", "0.02", ")", "/", "0.08", "+", "1", ",", "1.2", ",", "2", ")", "\n", "*", "0.5", "\n", "*", "self", ".", "_default_font_size", "\n", ")", "\n", "self", ".", "draw_text", "(", "\n", "labels", "[", "i", "]", ",", "\n", "text_pos", ",", "\n", "color", "=", "lighter_color", ",", "\n", "horizontal_alignment", "=", "horiz_align", ",", "\n", "font_size", "=", "font_size", ",", "\n", ")", "\n", "\n", "# draw keypoints", "\n", "", "", "if", "keypoints", "is", "not", "None", ":", "\n", "            ", "for", "keypoints_per_instance", "in", "keypoints", ":", "\n", "                ", "self", ".", "draw_and_connect_keypoints", "(", "keypoints_per_instance", ")", "\n", "\n", "", "", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.overlay_rotated_instances": [[715, 752], ["len", "numpy.argsort().tolist", "range", "visualizer.Visualizer.draw_rotated_box_with_label", "colormap.random_color", "numpy.argsort", "range"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_rotated_box_with_label", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.colormap.random_color"], ["", "def", "overlay_rotated_instances", "(", "self", ",", "boxes", "=", "None", ",", "labels", "=", "None", ",", "assigned_colors", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            boxes (ndarray): an Nx5 numpy array of\n                (x_center, y_center, width, height, angle_degrees) format\n                for the N objects in a single image.\n            labels (list[str]): the text to be displayed for each instance.\n            assigned_colors (list[matplotlib.colors]): a list of colors, where each color\n                corresponds to each mask or box in the image. Refer to 'matplotlib.colors'\n                for full list of formats that the colors are accepted in.\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"", "\n", "num_instances", "=", "len", "(", "boxes", ")", "\n", "\n", "if", "assigned_colors", "is", "None", ":", "\n", "            ", "assigned_colors", "=", "[", "random_color", "(", "rgb", "=", "True", ",", "maximum", "=", "1", ")", "for", "_", "in", "range", "(", "num_instances", ")", "]", "\n", "", "if", "num_instances", "==", "0", ":", "\n", "            ", "return", "self", ".", "output", "\n", "\n", "# Display in largest to smallest order to reduce occlusion.", "\n", "", "if", "boxes", "is", "not", "None", ":", "\n", "            ", "areas", "=", "boxes", "[", ":", ",", "2", "]", "*", "boxes", "[", ":", ",", "3", "]", "\n", "\n", "", "sorted_idxs", "=", "np", ".", "argsort", "(", "-", "areas", ")", ".", "tolist", "(", ")", "\n", "# Re-order overlapped instances in descending order.", "\n", "boxes", "=", "boxes", "[", "sorted_idxs", "]", "\n", "labels", "=", "[", "labels", "[", "k", "]", "for", "k", "in", "sorted_idxs", "]", "if", "labels", "is", "not", "None", "else", "None", "\n", "colors", "=", "[", "assigned_colors", "[", "idx", "]", "for", "idx", "in", "sorted_idxs", "]", "\n", "\n", "for", "i", "in", "range", "(", "num_instances", ")", ":", "\n", "            ", "self", ".", "draw_rotated_box_with_label", "(", "\n", "boxes", "[", "i", "]", ",", "edge_color", "=", "colors", "[", "i", "]", ",", "label", "=", "labels", "[", "i", "]", "if", "labels", "is", "not", "None", "else", "None", "\n", ")", "\n", "\n", "", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_and_connect_keypoints": [[753, 810], ["visualizer.Visualizer.metadata.get", "enumerate", "visualizer.Visualizer.metadata.get", "visible.get", "visualizer.Visualizer.draw_circle", "visualizer.Visualizer.draw_line", "visualizer.Visualizer.draw_line", "tuple", "visualizer.Visualizer.draw_line"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_circle", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_line", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_line", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_line"], ["", "def", "draw_and_connect_keypoints", "(", "self", ",", "keypoints", ")", ":", "\n", "        ", "\"\"\"\n        Draws keypoints of an instance and follows the rules for keypoint connections\n        to draw lines between appropriate keypoints. This follows color heuristics for\n        line color.\n\n        Args:\n            keypoints (Tensor): a tensor of shape (K, 3), where K is the number of keypoints\n                and the last dimension corresponds to (x, y, probability).\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"", "\n", "visible", "=", "{", "}", "\n", "keypoint_names", "=", "self", ".", "metadata", ".", "get", "(", "\"keypoint_names\"", ")", "\n", "for", "idx", ",", "keypoint", "in", "enumerate", "(", "keypoints", ")", ":", "\n", "# draw keypoint", "\n", "            ", "x", ",", "y", ",", "prob", "=", "keypoint", "\n", "if", "prob", ">", "_KEYPOINT_THRESHOLD", ":", "\n", "                ", "self", ".", "draw_circle", "(", "(", "x", ",", "y", ")", ",", "color", "=", "_RED", ")", "\n", "if", "keypoint_names", ":", "\n", "                    ", "keypoint_name", "=", "keypoint_names", "[", "idx", "]", "\n", "visible", "[", "keypoint_name", "]", "=", "(", "x", ",", "y", ")", "\n", "\n", "", "", "", "if", "self", ".", "metadata", ".", "get", "(", "\"keypoint_connection_rules\"", ")", ":", "\n", "            ", "for", "kp0", ",", "kp1", ",", "color", "in", "self", ".", "metadata", ".", "keypoint_connection_rules", ":", "\n", "                ", "if", "kp0", "in", "visible", "and", "kp1", "in", "visible", ":", "\n", "                    ", "x0", ",", "y0", "=", "visible", "[", "kp0", "]", "\n", "x1", ",", "y1", "=", "visible", "[", "kp1", "]", "\n", "color", "=", "tuple", "(", "x", "/", "255.0", "for", "x", "in", "color", ")", "\n", "self", ".", "draw_line", "(", "[", "x0", ",", "x1", "]", ",", "[", "y0", ",", "y1", "]", ",", "color", "=", "color", ")", "\n", "\n", "# draw lines from nose to mid-shoulder and mid-shoulder to mid-hip", "\n", "# Note that this strategy is specific to person keypoints.", "\n", "# For other keypoints, it should just do nothing", "\n", "", "", "", "try", ":", "\n", "            ", "ls_x", ",", "ls_y", "=", "visible", "[", "\"left_shoulder\"", "]", "\n", "rs_x", ",", "rs_y", "=", "visible", "[", "\"right_shoulder\"", "]", "\n", "mid_shoulder_x", ",", "mid_shoulder_y", "=", "(", "ls_x", "+", "rs_x", ")", "/", "2", ",", "(", "ls_y", "+", "rs_y", ")", "/", "2", "\n", "", "except", "KeyError", ":", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "# draw line from nose to mid-shoulder", "\n", "            ", "nose_x", ",", "nose_y", "=", "visible", ".", "get", "(", "\"nose\"", ",", "(", "None", ",", "None", ")", ")", "\n", "if", "nose_x", "is", "not", "None", ":", "\n", "                ", "self", ".", "draw_line", "(", "[", "nose_x", ",", "mid_shoulder_x", "]", ",", "[", "nose_y", ",", "mid_shoulder_y", "]", ",", "color", "=", "_RED", ")", "\n", "\n", "", "try", ":", "\n", "# draw line from mid-shoulder to mid-hip", "\n", "                ", "lh_x", ",", "lh_y", "=", "visible", "[", "\"left_hip\"", "]", "\n", "rh_x", ",", "rh_y", "=", "visible", "[", "\"right_hip\"", "]", "\n", "", "except", "KeyError", ":", "\n", "                ", "pass", "\n", "", "else", ":", "\n", "                ", "mid_hip_x", ",", "mid_hip_y", "=", "(", "lh_x", "+", "rh_x", ")", "/", "2", ",", "(", "lh_y", "+", "rh_y", ")", "/", "2", "\n", "self", ".", "draw_line", "(", "[", "mid_hip_x", ",", "mid_shoulder_x", "]", ",", "[", "mid_hip_y", ",", "mid_shoulder_y", "]", ",", "color", "=", "_RED", ")", "\n", "", "", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_text": [[815, 861], ["numpy.maximum", "max", "visualizer.Visualizer.output.ax.text", "list", "numpy.max", "matplotlib.to_rgb", "matplotlib.to_rgb", "matplotlib.to_rgb", "numpy.argmax"], "methods", ["None"], ["def", "draw_text", "(", "\n", "self", ",", "\n", "text", ",", "\n", "position", ",", "\n", "*", ",", "\n", "font_size", "=", "None", ",", "\n", "color", "=", "\"g\"", ",", "\n", "horizontal_alignment", "=", "\"center\"", ",", "\n", "rotation", "=", "0", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            text (str): class label\n            position (tuple): a tuple of the x and y coordinates to place text on image.\n            font_size (int, optional): font of the text. If not provided, a font size\n                proportional to the image width is calculated and used.\n            color: color of the text. Refer to `matplotlib.colors` for full list\n                of formats that are accepted.\n            horizontal_alignment (str): see `matplotlib.text.Text`\n            rotation: rotation angle in degrees CCW\n\n        Returns:\n            output (VisImage): image object with text drawn.\n        \"\"\"", "\n", "if", "not", "font_size", ":", "\n", "            ", "font_size", "=", "self", ".", "_default_font_size", "\n", "\n", "# since the text background is dark, we don't want the text to be dark", "\n", "", "color", "=", "np", ".", "maximum", "(", "list", "(", "mplc", ".", "to_rgb", "(", "color", ")", ")", ",", "0.2", ")", "\n", "color", "[", "np", ".", "argmax", "(", "color", ")", "]", "=", "max", "(", "0.8", ",", "np", ".", "max", "(", "color", ")", ")", "\n", "\n", "x", ",", "y", "=", "position", "\n", "self", ".", "output", ".", "ax", ".", "text", "(", "\n", "x", ",", "\n", "y", ",", "\n", "text", ",", "\n", "size", "=", "font_size", "*", "self", ".", "output", ".", "scale", ",", "\n", "family", "=", "\"sans-serif\"", ",", "\n", "bbox", "=", "{", "\"facecolor\"", ":", "\"black\"", ",", "\"alpha\"", ":", "0.8", ",", "\"pad\"", ":", "0.7", ",", "\"edgecolor\"", ":", "\"none\"", "}", ",", "\n", "verticalalignment", "=", "\"top\"", ",", "\n", "horizontalalignment", "=", "horizontal_alignment", ",", "\n", "color", "=", "color", ",", "\n", "zorder", "=", "10", ",", "\n", "rotation", "=", "rotation", ",", "\n", ")", "\n", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_box": [[862, 895], ["max", "visualizer.Visualizer.output.ax.add_patch", "matplotlib.patches.Rectangle", "matplotlib.patches.Rectangle", "matplotlib.patches.Rectangle"], "methods", ["None"], ["", "def", "draw_box", "(", "self", ",", "box_coord", ",", "alpha", "=", "0.5", ",", "edge_color", "=", "\"g\"", ",", "line_style", "=", "\"-\"", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            box_coord (tuple): a tuple containing x0, y0, x1, y1 coordinates, where x0 and y0\n                are the coordinates of the image's top left corner. x1 and y1 are the\n                coordinates of the image's bottom right corner.\n            alpha (float): blending efficient. Smaller values lead to more transparent masks.\n            edge_color: color of the outline of the box. Refer to `matplotlib.colors`\n                for full list of formats that are accepted.\n            line_style (string): the string to use to create the outline of the boxes.\n\n        Returns:\n            output (VisImage): image object with box drawn.\n        \"\"\"", "\n", "x0", ",", "y0", ",", "x1", ",", "y1", "=", "box_coord", "\n", "width", "=", "x1", "-", "x0", "\n", "height", "=", "y1", "-", "y0", "\n", "\n", "linewidth", "=", "max", "(", "self", ".", "_default_font_size", "/", "4", ",", "1", ")", "\n", "\n", "self", ".", "output", ".", "ax", ".", "add_patch", "(", "\n", "mpl", ".", "patches", ".", "Rectangle", "(", "\n", "(", "x0", ",", "y0", ")", ",", "\n", "width", ",", "\n", "height", ",", "\n", "fill", "=", "False", ",", "\n", "edgecolor", "=", "edge_color", ",", "\n", "linewidth", "=", "linewidth", "*", "self", ".", "output", ".", "scale", ",", "\n", "alpha", "=", "alpha", ",", "\n", "linestyle", "=", "line_style", ",", "\n", ")", "\n", ")", "\n", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_rotated_box_with_label": [[896, 950], ["math.cos", "math.sin", "range", "visualizer.Visualizer.draw_line", "visualizer.Visualizer._change_color_brightness", "visualizer.Visualizer.draw_text", "numpy.sqrt", "numpy.clip"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_line", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer._change_color_brightness", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_text", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clip"], ["", "def", "draw_rotated_box_with_label", "(", "\n", "self", ",", "rotated_box", ",", "alpha", "=", "0.5", ",", "edge_color", "=", "\"g\"", ",", "line_style", "=", "\"-\"", ",", "label", "=", "None", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Draw a rotated box with label on its top-left corner.\n\n        Args:\n            rotated_box (tuple): a tuple containing (cnt_x, cnt_y, w, h, angle),\n                where cnt_x and cnt_y are the center coordinates of the box.\n                w and h are the width and height of the box. angle represents how\n                many degrees the box is rotated CCW with regard to the 0-degree box.\n            alpha (float): blending efficient. Smaller values lead to more transparent masks.\n            edge_color: color of the outline of the box. Refer to `matplotlib.colors`\n                for full list of formats that are accepted.\n            line_style (string): the string to use to create the outline of the boxes.\n            label (string): label for rotated box. It will not be rendered when set to None.\n\n        Returns:\n            output (VisImage): image object with box drawn.\n        \"\"\"", "\n", "cnt_x", ",", "cnt_y", ",", "w", ",", "h", ",", "angle", "=", "rotated_box", "\n", "area", "=", "w", "*", "h", "\n", "# use thinner lines when the box is small", "\n", "linewidth", "=", "self", ".", "_default_font_size", "/", "(", "\n", "6", "if", "area", "<", "_SMALL_OBJECT_AREA_THRESH", "*", "self", ".", "output", ".", "scale", "else", "3", "\n", ")", "\n", "\n", "theta", "=", "angle", "*", "math", ".", "pi", "/", "180.0", "\n", "c", "=", "math", ".", "cos", "(", "theta", ")", "\n", "s", "=", "math", ".", "sin", "(", "theta", ")", "\n", "rect", "=", "[", "(", "-", "w", "/", "2", ",", "h", "/", "2", ")", ",", "(", "-", "w", "/", "2", ",", "-", "h", "/", "2", ")", ",", "(", "w", "/", "2", ",", "-", "h", "/", "2", ")", ",", "(", "w", "/", "2", ",", "h", "/", "2", ")", "]", "\n", "# x: left->right ; y: top->down", "\n", "rotated_rect", "=", "[", "(", "s", "*", "yy", "+", "c", "*", "xx", "+", "cnt_x", ",", "c", "*", "yy", "-", "s", "*", "xx", "+", "cnt_y", ")", "for", "(", "xx", ",", "yy", ")", "in", "rect", "]", "\n", "for", "k", "in", "range", "(", "4", ")", ":", "\n", "            ", "j", "=", "(", "k", "+", "1", ")", "%", "4", "\n", "self", ".", "draw_line", "(", "\n", "[", "rotated_rect", "[", "k", "]", "[", "0", "]", ",", "rotated_rect", "[", "j", "]", "[", "0", "]", "]", ",", "\n", "[", "rotated_rect", "[", "k", "]", "[", "1", "]", ",", "rotated_rect", "[", "j", "]", "[", "1", "]", "]", ",", "\n", "color", "=", "edge_color", ",", "\n", "linestyle", "=", "\"--\"", "if", "k", "==", "1", "else", "line_style", ",", "\n", "linewidth", "=", "linewidth", ",", "\n", ")", "\n", "\n", "", "if", "label", "is", "not", "None", ":", "\n", "            ", "text_pos", "=", "rotated_rect", "[", "1", "]", "# topleft corner", "\n", "\n", "height_ratio", "=", "h", "/", "np", ".", "sqrt", "(", "self", ".", "output", ".", "height", "*", "self", ".", "output", ".", "width", ")", "\n", "label_color", "=", "self", ".", "_change_color_brightness", "(", "edge_color", ",", "brightness_factor", "=", "0.7", ")", "\n", "font_size", "=", "(", "\n", "np", ".", "clip", "(", "(", "height_ratio", "-", "0.02", ")", "/", "0.08", "+", "1", ",", "1.2", ",", "2", ")", "*", "0.5", "*", "self", ".", "_default_font_size", "\n", ")", "\n", "self", ".", "draw_text", "(", "label", ",", "text_pos", ",", "color", "=", "label_color", ",", "font_size", "=", "font_size", ",", "rotation", "=", "angle", ")", "\n", "\n", "", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_circle": [[951, 968], ["visualizer.Visualizer.output.ax.add_patch", "matplotlib.patches.Circle", "matplotlib.patches.Circle", "matplotlib.patches.Circle"], "methods", ["None"], ["", "def", "draw_circle", "(", "self", ",", "circle_coord", ",", "color", ",", "radius", "=", "3", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            circle_coord (list(int) or tuple(int)): contains the x and y coordinates\n                of the center of the circle.\n            color: color of the polygon. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted.\n            radius (int): radius of the circle.\n\n        Returns:\n            output (VisImage): image object with box drawn.\n        \"\"\"", "\n", "x", ",", "y", "=", "circle_coord", "\n", "self", ".", "output", ".", "ax", ".", "add_patch", "(", "\n", "mpl", ".", "patches", ".", "Circle", "(", "circle_coord", ",", "radius", "=", "radius", ",", "fill", "=", "True", ",", "color", "=", "color", ")", "\n", ")", "\n", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_line": [[969, 999], ["max", "visualizer.Visualizer.output.ax.add_line", "matplotlib.lines.Line2D", "matplotlib.lines.Line2D", "matplotlib.lines.Line2D"], "methods", ["None"], ["", "def", "draw_line", "(", "self", ",", "x_data", ",", "y_data", ",", "color", ",", "linestyle", "=", "\"-\"", ",", "linewidth", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x_data (list[int]): a list containing x values of all the points being drawn.\n                Length of list should match the length of y_data.\n            y_data (list[int]): a list containing y values of all the points being drawn.\n                Length of list should match the length of x_data.\n            color: color of the line. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted.\n            linestyle: style of the line. Refer to `matplotlib.lines.Line2D`\n                for a full list of formats that are accepted.\n            linewidth (float or None): width of the line. When it's None,\n                a default value will be computed and used.\n\n        Returns:\n            output (VisImage): image object with line drawn.\n        \"\"\"", "\n", "if", "linewidth", "is", "None", ":", "\n", "            ", "linewidth", "=", "self", ".", "_default_font_size", "/", "3", "\n", "", "linewidth", "=", "max", "(", "linewidth", ",", "1", ")", "\n", "self", ".", "output", ".", "ax", ".", "add_line", "(", "\n", "mpl", ".", "lines", ".", "Line2D", "(", "\n", "x_data", ",", "\n", "y_data", ",", "\n", "linewidth", "=", "linewidth", "*", "self", ".", "output", ".", "scale", ",", "\n", "color", "=", "color", ",", "\n", "linestyle", "=", "linestyle", ",", "\n", ")", "\n", ")", "\n", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_binary_mask": [[1000, 1060], ["matplotlib.to_rgb", "matplotlib.to_rgb", "matplotlib.to_rgb", "binary_mask.astype.astype.astype", "visualizer.GenericMask", "colormap.random_color", "numpy.zeros", "visualizer.Visualizer.output.ax.imshow", "visualizer.Visualizer._change_color_brightness", "cv2.connectedComponentsWithStats", "range", "pycocotools.area", "segment.reshape.reshape.reshape", "visualizer.Visualizer.draw_polygon", "numpy.argmax", "pycocotools.frPyObjects", "visualizer.Visualizer.draw_text", "numpy.median"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.colormap.random_color", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer._change_color_brightness", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_polygon", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_text"], ["", "def", "draw_binary_mask", "(", "\n", "self", ",", "binary_mask", ",", "color", "=", "None", ",", "*", ",", "edge_color", "=", "None", ",", "text", "=", "None", ",", "alpha", "=", "0.5", ",", "area_threshold", "=", "0", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            binary_mask (ndarray): numpy array of shape (H, W), where H is the image height and\n                W is the image width. Each value in the array is either a 0 or 1 value of uint8\n                type.\n            color: color of the mask. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted. If None, will pick a random color.\n            edge_color: color of the polygon edges. Refer to `matplotlib.colors` for a\n                full list of formats that are accepted.\n            text (str): if None, will be drawn in the object's center of mass.\n            alpha (float): blending efficient. Smaller values lead to more transparent masks.\n            area_threshold (float): a connected component small than this will not be shown.\n\n        Returns:\n            output (VisImage): image object with mask drawn.\n        \"\"\"", "\n", "if", "color", "is", "None", ":", "\n", "            ", "color", "=", "random_color", "(", "rgb", "=", "True", ",", "maximum", "=", "1", ")", "\n", "", "color", "=", "mplc", ".", "to_rgb", "(", "color", ")", "\n", "\n", "has_valid_segment", "=", "False", "\n", "binary_mask", "=", "binary_mask", ".", "astype", "(", "\"uint8\"", ")", "# opencv needs uint8", "\n", "mask", "=", "GenericMask", "(", "binary_mask", ",", "self", ".", "output", ".", "height", ",", "self", ".", "output", ".", "width", ")", "\n", "shape2d", "=", "(", "binary_mask", ".", "shape", "[", "0", "]", ",", "binary_mask", ".", "shape", "[", "1", "]", ")", "\n", "\n", "if", "not", "mask", ".", "has_holes", ":", "\n", "# draw polygons for regular masks", "\n", "            ", "for", "segment", "in", "mask", ".", "polygons", ":", "\n", "                ", "area", "=", "mask_util", ".", "area", "(", "mask_util", ".", "frPyObjects", "(", "[", "segment", "]", ",", "shape2d", "[", "0", "]", ",", "shape2d", "[", "1", "]", ")", ")", "\n", "if", "area", "<", "(", "area_threshold", "or", "0", ")", ":", "\n", "                    ", "continue", "\n", "", "has_valid_segment", "=", "True", "\n", "segment", "=", "segment", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "self", ".", "draw_polygon", "(", "segment", ",", "color", "=", "color", ",", "edge_color", "=", "edge_color", ",", "alpha", "=", "alpha", ")", "\n", "", "", "else", ":", "\n", "# TODO: Use Path/PathPatch to draw vector graphics:", "\n", "# https://stackoverflow.com/questions/8919719/how-to-plot-a-complex-polygon", "\n", "            ", "rgba", "=", "np", ".", "zeros", "(", "shape2d", "+", "(", "4", ",", ")", ",", "dtype", "=", "\"float32\"", ")", "\n", "rgba", "[", ":", ",", ":", ",", ":", "3", "]", "=", "color", "\n", "rgba", "[", ":", ",", ":", ",", "3", "]", "=", "(", "mask", ".", "mask", "==", "1", ")", ".", "astype", "(", "\"float32\"", ")", "*", "alpha", "\n", "has_valid_segment", "=", "True", "\n", "self", ".", "output", ".", "ax", ".", "imshow", "(", "rgba", ",", "extent", "=", "(", "0", ",", "self", ".", "output", ".", "width", ",", "self", ".", "output", ".", "height", ",", "0", ")", ")", "\n", "\n", "", "if", "text", "is", "not", "None", "and", "has_valid_segment", ":", "\n", "# TODO sometimes drawn on wrong objects. the heuristics here can improve.", "\n", "            ", "lighter_color", "=", "self", ".", "_change_color_brightness", "(", "color", ",", "brightness_factor", "=", "0.7", ")", "\n", "_num_cc", ",", "cc_labels", ",", "stats", ",", "centroids", "=", "cv2", ".", "connectedComponentsWithStats", "(", "binary_mask", ",", "8", ")", "\n", "largest_component_id", "=", "np", ".", "argmax", "(", "stats", "[", "1", ":", ",", "-", "1", "]", ")", "+", "1", "\n", "\n", "# draw text on the largest component, as well as other very large components.", "\n", "for", "cid", "in", "range", "(", "1", ",", "_num_cc", ")", ":", "\n", "                ", "if", "cid", "==", "largest_component_id", "or", "stats", "[", "cid", ",", "-", "1", "]", ">", "_LARGE_MASK_AREA_THRESH", ":", "\n", "# median is more stable than centroid", "\n", "# center = centroids[largest_component_id]", "\n", "                    ", "center", "=", "np", ".", "median", "(", "(", "cc_labels", "==", "cid", ")", ".", "nonzero", "(", ")", ",", "axis", "=", "1", ")", "[", ":", ":", "-", "1", "]", "\n", "self", ".", "draw_text", "(", "text", ",", "center", ",", "color", "=", "lighter_color", ")", "\n", "", "", "", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_polygon": [[1061, 1092], ["matplotlib.patches.Polygon", "matplotlib.patches.Polygon", "matplotlib.patches.Polygon", "visualizer.Visualizer.output.ax.add_patch", "matplotlib.to_rgb", "matplotlib.to_rgb", "matplotlib.to_rgb", "visualizer.Visualizer._change_color_brightness", "max", "matplotlib.to_rgb", "matplotlib.to_rgb", "matplotlib.to_rgb"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer._change_color_brightness"], ["", "def", "draw_polygon", "(", "self", ",", "segment", ",", "color", ",", "edge_color", "=", "None", ",", "alpha", "=", "0.5", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            segment: numpy array of shape Nx2, containing all the points in the polygon.\n            color: color of the polygon. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted.\n            edge_color: color of the polygon edges. Refer to `matplotlib.colors` for a\n                full list of formats that are accepted. If not provided, a darker shade\n                of the polygon color will be used instead.\n            alpha (float): blending efficient. Smaller values lead to more transparent masks.\n\n        Returns:\n            output (VisImage): image object with polygon drawn.\n        \"\"\"", "\n", "if", "edge_color", "is", "None", ":", "\n", "# make edge color darker than the polygon color", "\n", "            ", "if", "alpha", ">", "0.8", ":", "\n", "                ", "edge_color", "=", "self", ".", "_change_color_brightness", "(", "color", ",", "brightness_factor", "=", "-", "0.7", ")", "\n", "", "else", ":", "\n", "                ", "edge_color", "=", "color", "\n", "", "", "edge_color", "=", "mplc", ".", "to_rgb", "(", "edge_color", ")", "+", "(", "1", ",", ")", "\n", "\n", "polygon", "=", "mpl", ".", "patches", ".", "Polygon", "(", "\n", "segment", ",", "\n", "fill", "=", "True", ",", "\n", "facecolor", "=", "mplc", ".", "to_rgb", "(", "color", ")", "+", "(", "alpha", ",", ")", ",", "\n", "edgecolor", "=", "edge_color", ",", "\n", "linewidth", "=", "max", "(", "self", ".", "_default_font_size", "//", "15", "*", "self", ".", "output", ".", "scale", ",", "1", ")", ",", "\n", ")", "\n", "self", ".", "output", ".", "ax", ".", "add_patch", "(", "polygon", ")", "\n", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer._jitter": [[1097, 1115], ["matplotlib.to_rgb", "matplotlib.to_rgb", "matplotlib.to_rgb", "numpy.random.rand", "numpy.clip", "tuple", "numpy.linalg.norm"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.norm"], ["def", "_jitter", "(", "self", ",", "color", ")", ":", "\n", "        ", "\"\"\"\n        Randomly modifies given color to produce a slightly different color than the color given.\n\n        Args:\n            color (tuple[double]): a tuple of 3 elements, containing the RGB values of the color\n                picked. The values in the list are in the [0.0, 1.0] range.\n\n        Returns:\n            jittered_color (tuple[double]): a tuple of 3 elements, containing the RGB values of the\n                color after being jittered. The values in the list are in the [0.0, 1.0] range.\n        \"\"\"", "\n", "color", "=", "mplc", ".", "to_rgb", "(", "color", ")", "\n", "vec", "=", "np", ".", "random", ".", "rand", "(", "3", ")", "\n", "# better to do it in another color space", "\n", "vec", "=", "vec", "/", "np", ".", "linalg", ".", "norm", "(", "vec", ")", "*", "0.5", "\n", "res", "=", "np", ".", "clip", "(", "vec", "+", "color", ",", "0", ",", "1", ")", "\n", "return", "tuple", "(", "res", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer._create_grayscale_image": [[1116, 1126], ["visualizer.Visualizer.img.astype().mean", "numpy.stack", "visualizer.Visualizer.img.astype"], "methods", ["None"], ["", "def", "_create_grayscale_image", "(", "self", ",", "mask", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Create a grayscale version of the original image.\n        The colors in masked area, if given, will be kept.\n        \"\"\"", "\n", "img_bw", "=", "self", ".", "img", ".", "astype", "(", "\"f4\"", ")", ".", "mean", "(", "axis", "=", "2", ")", "\n", "img_bw", "=", "np", ".", "stack", "(", "[", "img_bw", "]", "*", "3", ",", "axis", "=", "2", ")", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "img_bw", "[", "mask", "]", "=", "self", ".", "img", "[", "mask", "]", "\n", "", "return", "img_bw", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer._change_color_brightness": [[1127, 1151], ["matplotlib.to_rgb", "matplotlib.to_rgb", "matplotlib.to_rgb", "colorsys.rgb_to_hls", "colorsys.hls_to_rgb", "matplotlib.to_rgb", "matplotlib.to_rgb", "matplotlib.to_rgb"], "methods", ["None"], ["", "def", "_change_color_brightness", "(", "self", ",", "color", ",", "brightness_factor", ")", ":", "\n", "        ", "\"\"\"\n        Depending on the brightness_factor, gives a lighter or darker color i.e. a color with\n        less or more saturation than the original color.\n\n        Args:\n            color: color of the polygon. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted.\n            brightness_factor (float): a value in [-1.0, 1.0] range. A lightness factor of\n                0 will correspond to no change, a factor in [-1.0, 0) range will result in\n                a darker color and a factor in (0, 1.0] range will result in a lighter color.\n\n        Returns:\n            modified_color (tuple[double]): a tuple containing the RGB values of the\n                modified color. Each value in the tuple is in the [0.0, 1.0] range.\n        \"\"\"", "\n", "assert", "brightness_factor", ">=", "-", "1.0", "and", "brightness_factor", "<=", "1.0", "\n", "color", "=", "mplc", ".", "to_rgb", "(", "color", ")", "\n", "polygon_color", "=", "colorsys", ".", "rgb_to_hls", "(", "*", "mplc", ".", "to_rgb", "(", "color", ")", ")", "\n", "modified_lightness", "=", "polygon_color", "[", "1", "]", "+", "(", "brightness_factor", "*", "polygon_color", "[", "1", "]", ")", "\n", "modified_lightness", "=", "0.0", "if", "modified_lightness", "<", "0.0", "else", "modified_lightness", "\n", "modified_lightness", "=", "1.0", "if", "modified_lightness", ">", "1.0", "else", "modified_lightness", "\n", "modified_color", "=", "colorsys", ".", "hls_to_rgb", "(", "polygon_color", "[", "0", "]", ",", "modified_lightness", ",", "polygon_color", "[", "2", "]", ")", "\n", "return", "modified_color", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer._convert_boxes": [[1152, 1160], ["isinstance", "isinstance", "boxes.tensor.numpy", "numpy.asarray"], "methods", ["None"], ["", "def", "_convert_boxes", "(", "self", ",", "boxes", ")", ":", "\n", "        ", "\"\"\"\n        Convert different format of boxes to an NxB array, where B = 4 or 5 is the box dimension.\n        \"\"\"", "\n", "if", "isinstance", "(", "boxes", ",", "Boxes", ")", "or", "isinstance", "(", "boxes", ",", "RotatedBoxes", ")", ":", "\n", "            ", "return", "boxes", ".", "tensor", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "asarray", "(", "boxes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer._convert_masks": [[1161, 1183], ["isinstance", "isinstance", "isinstance", "m.numpy.numpy.tensor.numpy", "m.numpy.numpy.numpy", "isinstance", "ret.append", "ret.append", "visualizer.GenericMask"], "methods", ["None"], ["", "", "def", "_convert_masks", "(", "self", ",", "masks_or_polygons", ")", ":", "\n", "        ", "\"\"\"\n        Convert different format of masks or polygons to a tuple of masks and polygons.\n\n        Returns:\n            list[GenericMask]:\n        \"\"\"", "\n", "\n", "m", "=", "masks_or_polygons", "\n", "if", "isinstance", "(", "m", ",", "PolygonMasks", ")", ":", "\n", "            ", "m", "=", "m", ".", "polygons", "\n", "", "if", "isinstance", "(", "m", ",", "BitMasks", ")", ":", "\n", "            ", "m", "=", "m", ".", "tensor", ".", "numpy", "(", ")", "\n", "", "if", "isinstance", "(", "m", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "m", "=", "m", ".", "numpy", "(", ")", "\n", "", "ret", "=", "[", "]", "\n", "for", "x", "in", "m", ":", "\n", "            ", "if", "isinstance", "(", "x", ",", "GenericMask", ")", ":", "\n", "                ", "ret", ".", "append", "(", "x", ")", "\n", "", "else", ":", "\n", "                ", "ret", ".", "append", "(", "GenericMask", "(", "x", ",", "self", ".", "output", ".", "height", ",", "self", ".", "output", ".", "width", ")", ")", "\n", "", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer._convert_keypoints": [[1184, 1189], ["isinstance", "numpy.asarray"], "methods", ["None"], ["", "def", "_convert_keypoints", "(", "self", ",", "keypoints", ")", ":", "\n", "        ", "if", "isinstance", "(", "keypoints", ",", "Keypoints", ")", ":", "\n", "            ", "keypoints", "=", "keypoints", ".", "tensor", "\n", "", "keypoints", "=", "np", ".", "asarray", "(", "keypoints", ")", "\n", "return", "keypoints", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.get_output": [[1190, 1197], ["None"], "methods", ["None"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            output (VisImage): the image output containing the visualizations added\n            to the image.\n        \"\"\"", "\n", "return", "self", ".", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer._create_text_labels": [[223, 242], ["len", "zip"], "function", ["None"], ["", "", "", "", "def", "_create_text_labels", "(", "classes", ",", "scores", ",", "class_names", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        classes (list[int] or None):\n        scores (list[float] or None):\n        class_names (list[str] or None):\n\n    Returns:\n        list[str] or None\n    \"\"\"", "\n", "labels", "=", "None", "\n", "if", "classes", "is", "not", "None", "and", "class_names", "is", "not", "None", "and", "len", "(", "class_names", ")", ">", "0", ":", "\n", "        ", "labels", "=", "[", "class_names", "[", "i", "]", "for", "i", "in", "classes", "]", "\n", "", "if", "scores", "is", "not", "None", ":", "\n", "        ", "if", "labels", "is", "None", ":", "\n", "            ", "labels", "=", "[", "\"{:.0f}%\"", ".", "format", "(", "s", "*", "100", ")", "for", "s", "in", "scores", "]", "\n", "", "else", ":", "\n", "            ", "labels", "=", "[", "\"{} {:.0f}%\"", ".", "format", "(", "l", ",", "s", "*", "100", ")", "for", "l", ",", "s", "in", "zip", "(", "labels", ",", "scores", ")", "]", "\n", "", "", "return", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.video_visualizer._DetectedInstance.__init__": [[31, 37], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "label", ",", "bbox", ",", "mask_rle", ",", "color", ",", "ttl", ")", ":", "\n", "        ", "self", ".", "label", "=", "label", "\n", "self", ".", "bbox", "=", "bbox", "\n", "self", ".", "mask_rle", "=", "mask_rle", "\n", "self", ".", "color", "=", "color", "\n", "self", ".", "ttl", "=", "ttl", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.video_visualizer.VideoVisualizer.__init__": [[40, 52], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "metadata", ",", "instance_mode", "=", "ColorMode", ".", "IMAGE", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            metadata (MetadataCatalog): image metadata.\n        \"\"\"", "\n", "self", ".", "metadata", "=", "metadata", "\n", "self", ".", "_old_instances", "=", "[", "]", "\n", "assert", "instance_mode", "in", "[", "\n", "ColorMode", ".", "IMAGE", ",", "\n", "ColorMode", ".", "IMAGE_BW", ",", "\n", "]", ",", "\"Other mode not supported yet.\"", "\n", "self", ".", "_instance_mode", "=", "instance_mode", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.video_visualizer.VideoVisualizer.draw_instance_predictions": [[53, 111], ["detectron2.utils.visualizer.Visualizer", "len", "predictions.has", "video_visualizer.VideoVisualizer._assign_colors", "detectron2.utils.visualizer._create_text_labels", "detectron2.utils.visualizer.Visualizer.overlay_instances", "predictions.has", "predictions.pred_boxes.tensor.numpy", "predictions.has", "predictions.has", "predictions.pred_classes.numpy", "predictions.has", "video_visualizer._DetectedInstance", "video_visualizer.VideoVisualizer.metadata.get", "detectron2.utils.visualizer.Visualizer._create_grayscale_image", "range", "masks.any"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.video_visualizer.VideoVisualizer._assign_colors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer._create_text_labels", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer._create_grayscale_image"], ["", "def", "draw_instance_predictions", "(", "self", ",", "frame", ",", "predictions", ")", ":", "\n", "        ", "\"\"\"\n        Draw instance-level prediction results on an image.\n\n        Args:\n            frame (ndarray): an RGB image of shape (H, W, C), in the range [0, 255].\n            predictions (Instances): the output of an instance detection/segmentation\n                model. Following fields will be used to draw:\n                \"pred_boxes\", \"pred_classes\", \"scores\", \"pred_masks\" (or \"pred_masks_rle\").\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"", "\n", "frame_visualizer", "=", "Visualizer", "(", "frame", ",", "self", ".", "metadata", ")", "\n", "num_instances", "=", "len", "(", "predictions", ")", "\n", "if", "num_instances", "==", "0", ":", "\n", "            ", "return", "frame_visualizer", ".", "output", "\n", "\n", "", "boxes", "=", "predictions", ".", "pred_boxes", ".", "tensor", ".", "numpy", "(", ")", "if", "predictions", ".", "has", "(", "\"pred_boxes\"", ")", "else", "None", "\n", "scores", "=", "predictions", ".", "scores", "if", "predictions", ".", "has", "(", "\"scores\"", ")", "else", "None", "\n", "classes", "=", "predictions", ".", "pred_classes", ".", "numpy", "(", ")", "if", "predictions", ".", "has", "(", "\"pred_classes\"", ")", "else", "None", "\n", "keypoints", "=", "predictions", ".", "pred_keypoints", "if", "predictions", ".", "has", "(", "\"pred_keypoints\"", ")", "else", "None", "\n", "\n", "if", "predictions", ".", "has", "(", "\"pred_masks\"", ")", ":", "\n", "            ", "masks", "=", "predictions", ".", "pred_masks", "\n", "# mask IOU is not yet enabled", "\n", "# masks_rles = mask_util.encode(np.asarray(masks.permute(1, 2, 0), order=\"F\"))", "\n", "# assert len(masks_rles) == num_instances", "\n", "", "else", ":", "\n", "            ", "masks", "=", "None", "\n", "\n", "", "detected", "=", "[", "\n", "_DetectedInstance", "(", "classes", "[", "i", "]", ",", "boxes", "[", "i", "]", ",", "mask_rle", "=", "None", ",", "color", "=", "None", ",", "ttl", "=", "8", ")", "\n", "for", "i", "in", "range", "(", "num_instances", ")", "\n", "]", "\n", "colors", "=", "self", ".", "_assign_colors", "(", "detected", ")", "\n", "\n", "labels", "=", "_create_text_labels", "(", "classes", ",", "scores", ",", "self", ".", "metadata", ".", "get", "(", "\"thing_classes\"", ",", "None", ")", ")", "\n", "\n", "if", "self", ".", "_instance_mode", "==", "ColorMode", ".", "IMAGE_BW", ":", "\n", "# any() returns uint8 tensor", "\n", "            ", "frame_visualizer", ".", "output", ".", "img", "=", "frame_visualizer", ".", "_create_grayscale_image", "(", "\n", "(", "masks", ".", "any", "(", "dim", "=", "0", ")", ">", "0", ")", ".", "numpy", "(", ")", "if", "masks", "is", "not", "None", "else", "None", "\n", ")", "\n", "alpha", "=", "0.3", "\n", "", "else", ":", "\n", "            ", "alpha", "=", "0.5", "\n", "\n", "", "frame_visualizer", ".", "overlay_instances", "(", "\n", "boxes", "=", "None", "if", "masks", "is", "not", "None", "else", "boxes", ",", "# boxes are a bit distracting", "\n", "masks", "=", "masks", ",", "\n", "labels", "=", "labels", ",", "\n", "keypoints", "=", "keypoints", ",", "\n", "assigned_colors", "=", "colors", ",", "\n", "alpha", "=", "alpha", ",", "\n", ")", "\n", "\n", "return", "frame_visualizer", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.video_visualizer.VideoVisualizer.draw_sem_seg": [[112, 123], ["detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.draw_sem_seg"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.video_visualizer.VideoVisualizer.draw_sem_seg"], ["", "def", "draw_sem_seg", "(", "self", ",", "frame", ",", "sem_seg", ",", "area_threshold", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            sem_seg (ndarray or Tensor): semantic segmentation of shape (H, W),\n                each value is the integer label.\n            area_threshold (Optional[int]): only draw segmentations larger than the threshold\n        \"\"\"", "\n", "# don't need to do anything special", "\n", "frame_visualizer", "=", "Visualizer", "(", "frame", ",", "self", ".", "metadata", ")", "\n", "frame_visualizer", ".", "draw_sem_seg", "(", "sem_seg", ",", "area_threshold", "=", "None", ")", "\n", "return", "frame_visualizer", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.video_visualizer.VideoVisualizer.draw_panoptic_seg_predictions": [[124, 179], ["detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer._PanopticPrediction", "detectron2.utils.visualizer._PanopticPrediction.semantic_masks", "list", "list", "len", "pycocotools.encode", "video_visualizer.VideoVisualizer._assign_colors", "detectron2.utils.visualizer.Visualizer.overlay_instances", "detectron2.utils.visualizer.Visualizer._create_grayscale_image", "detectron2.utils.visualizer.Visualizer.draw_binary_mask", "detectron2.utils.visualizer._PanopticPrediction.instance_masks", "len", "zip", "numpy.asarray", "len", "video_visualizer._DetectedInstance", "detectron2.utils.visualizer._PanopticPrediction.non_empty_mask", "numpy.asarray().transpose", "range", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer._PanopticPrediction.semantic_masks", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.video_visualizer.VideoVisualizer._assign_colors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer._create_grayscale_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_binary_mask", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer._PanopticPrediction.instance_masks", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer._PanopticPrediction.non_empty_mask"], ["", "def", "draw_panoptic_seg_predictions", "(", "\n", "self", ",", "frame", ",", "panoptic_seg", ",", "segments_info", ",", "area_threshold", "=", "None", ",", "alpha", "=", "0.5", "\n", ")", ":", "\n", "        ", "frame_visualizer", "=", "Visualizer", "(", "frame", ",", "self", ".", "metadata", ")", "\n", "pred", "=", "_PanopticPrediction", "(", "panoptic_seg", ",", "segments_info", ",", "self", ".", "metadata", ")", "\n", "\n", "if", "self", ".", "_instance_mode", "==", "ColorMode", ".", "IMAGE_BW", ":", "\n", "            ", "frame_visualizer", ".", "output", ".", "img", "=", "frame_visualizer", ".", "_create_grayscale_image", "(", "\n", "pred", ".", "non_empty_mask", "(", ")", "\n", ")", "\n", "\n", "# draw mask for all semantic segments first i.e. \"stuff\"", "\n", "", "for", "mask", ",", "sinfo", "in", "pred", ".", "semantic_masks", "(", ")", ":", "\n", "            ", "category_idx", "=", "sinfo", "[", "\"category_id\"", "]", "\n", "try", ":", "\n", "                ", "mask_color", "=", "[", "x", "/", "255", "for", "x", "in", "self", ".", "metadata", ".", "stuff_colors", "[", "category_idx", "]", "]", "\n", "", "except", "AttributeError", ":", "\n", "                ", "mask_color", "=", "None", "\n", "\n", "", "frame_visualizer", ".", "draw_binary_mask", "(", "\n", "mask", ",", "\n", "color", "=", "mask_color", ",", "\n", "text", "=", "self", ".", "metadata", ".", "stuff_classes", "[", "category_idx", "]", ",", "\n", "alpha", "=", "alpha", ",", "\n", "area_threshold", "=", "area_threshold", ",", "\n", ")", "\n", "\n", "", "all_instances", "=", "list", "(", "pred", ".", "instance_masks", "(", ")", ")", "\n", "if", "len", "(", "all_instances", ")", "==", "0", ":", "\n", "            ", "return", "frame_visualizer", ".", "output", "\n", "# draw mask for all instances second", "\n", "", "masks", ",", "sinfo", "=", "list", "(", "zip", "(", "*", "all_instances", ")", ")", "\n", "num_instances", "=", "len", "(", "masks", ")", "\n", "masks_rles", "=", "mask_util", ".", "encode", "(", "\n", "np", ".", "asarray", "(", "np", ".", "asarray", "(", "masks", ")", ".", "transpose", "(", "1", ",", "2", ",", "0", ")", ",", "dtype", "=", "np", ".", "uint8", ",", "order", "=", "\"F\"", ")", "\n", ")", "\n", "assert", "len", "(", "masks_rles", ")", "==", "num_instances", "\n", "\n", "category_ids", "=", "[", "x", "[", "\"category_id\"", "]", "for", "x", "in", "sinfo", "]", "\n", "detected", "=", "[", "\n", "_DetectedInstance", "(", "category_ids", "[", "i", "]", ",", "bbox", "=", "None", ",", "mask_rle", "=", "masks_rles", "[", "i", "]", ",", "color", "=", "None", ",", "ttl", "=", "8", ")", "\n", "for", "i", "in", "range", "(", "num_instances", ")", "\n", "]", "\n", "colors", "=", "self", ".", "_assign_colors", "(", "detected", ")", "\n", "labels", "=", "[", "self", ".", "metadata", ".", "thing_classes", "[", "k", "]", "for", "k", "in", "category_ids", "]", "\n", "\n", "frame_visualizer", ".", "overlay_instances", "(", "\n", "boxes", "=", "None", ",", "\n", "masks", "=", "masks", ",", "\n", "labels", "=", "labels", ",", "\n", "keypoints", "=", "None", ",", "\n", "assigned_colors", "=", "colors", ",", "\n", "alpha", "=", "alpha", ",", "\n", ")", "\n", "return", "frame_visualizer", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.video_visualizer.VideoVisualizer._assign_colors": [[180, 236], ["numpy.zeros", "enumerate", "numpy.asarray().argmax", "numpy.asarray().max", "enumerate", "pycocotools.iou", "pycocotools.iou", "len", "numpy.zeros", "enumerate", "len", "numpy.asarray", "numpy.asarray", "extra_instances.append", "colormap.random_color", "len", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.colormap.random_color"], ["", "def", "_assign_colors", "(", "self", ",", "instances", ")", ":", "\n", "        ", "\"\"\"\n        Naive tracking heuristics to assign same color to the same instance,\n        will update the internal state of tracked instances.\n\n        Returns:\n            list[tuple[float]]: list of colors.\n        \"\"\"", "\n", "\n", "# Compute iou with either boxes or masks:", "\n", "is_crowd", "=", "np", ".", "zeros", "(", "(", "len", "(", "instances", ")", ",", ")", ",", "dtype", "=", "np", ".", "bool", ")", "\n", "if", "instances", "[", "0", "]", ".", "bbox", "is", "None", ":", "\n", "            ", "assert", "instances", "[", "0", "]", ".", "mask_rle", "is", "not", "None", "\n", "# use mask iou only when box iou is None", "\n", "# because box seems good enough", "\n", "rles_old", "=", "[", "x", ".", "mask_rle", "for", "x", "in", "self", ".", "_old_instances", "]", "\n", "rles_new", "=", "[", "x", ".", "mask_rle", "for", "x", "in", "instances", "]", "\n", "ious", "=", "mask_util", ".", "iou", "(", "rles_old", ",", "rles_new", ",", "is_crowd", ")", "\n", "threshold", "=", "0.5", "\n", "", "else", ":", "\n", "            ", "boxes_old", "=", "[", "x", ".", "bbox", "for", "x", "in", "self", ".", "_old_instances", "]", "\n", "boxes_new", "=", "[", "x", ".", "bbox", "for", "x", "in", "instances", "]", "\n", "ious", "=", "mask_util", ".", "iou", "(", "boxes_old", ",", "boxes_new", ",", "is_crowd", ")", "\n", "threshold", "=", "0.6", "\n", "", "if", "len", "(", "ious", ")", "==", "0", ":", "\n", "            ", "ious", "=", "np", ".", "zeros", "(", "(", "len", "(", "self", ".", "_old_instances", ")", ",", "len", "(", "instances", ")", ")", ",", "dtype", "=", "\"float32\"", ")", "\n", "\n", "# Only allow matching instances of the same label:", "\n", "", "for", "old_idx", ",", "old", "in", "enumerate", "(", "self", ".", "_old_instances", ")", ":", "\n", "            ", "for", "new_idx", ",", "new", "in", "enumerate", "(", "instances", ")", ":", "\n", "                ", "if", "old", ".", "label", "!=", "new", ".", "label", ":", "\n", "                    ", "ious", "[", "old_idx", ",", "new_idx", "]", "=", "0", "\n", "\n", "", "", "", "matched_new_per_old", "=", "np", ".", "asarray", "(", "ious", ")", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "max_iou_per_old", "=", "np", ".", "asarray", "(", "ious", ")", ".", "max", "(", "axis", "=", "1", ")", "\n", "\n", "# Try to find match for each old instance:", "\n", "extra_instances", "=", "[", "]", "\n", "for", "idx", ",", "inst", "in", "enumerate", "(", "self", ".", "_old_instances", ")", ":", "\n", "            ", "if", "max_iou_per_old", "[", "idx", "]", ">", "threshold", ":", "\n", "                ", "newidx", "=", "matched_new_per_old", "[", "idx", "]", "\n", "if", "instances", "[", "newidx", "]", ".", "color", "is", "None", ":", "\n", "                    ", "instances", "[", "newidx", "]", ".", "color", "=", "inst", ".", "color", "\n", "continue", "\n", "# If an old instance does not match any new instances,", "\n", "# keep it for the next frame in case it is just missed by the detector", "\n", "", "", "inst", ".", "ttl", "-=", "1", "\n", "if", "inst", ".", "ttl", ">", "0", ":", "\n", "                ", "extra_instances", ".", "append", "(", "inst", ")", "\n", "\n", "# Assign random color to newly-detected instances:", "\n", "", "", "for", "inst", "in", "instances", ":", "\n", "            ", "if", "inst", ".", "color", "is", "None", ":", "\n", "                ", "inst", ".", "color", "=", "random_color", "(", "rgb", "=", "True", ",", "maximum", "=", "1", ")", "\n", "", "", "self", ".", "_old_instances", "=", "instances", "[", ":", "]", "+", "extra_instances", "\n", "return", "[", "d", ".", "color", "for", "d", "in", "instances", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.analysis.flop_count_operators": [[55, 76], ["analysis._wrapper_count_operators"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.analysis._wrapper_count_operators"], ["def", "flop_count_operators", "(", "\n", "model", ":", "nn", ".", "Module", ",", "inputs", ":", "list", ",", "**", "kwargs", "\n", ")", "->", "typing", ".", "DefaultDict", "[", "str", ",", "float", "]", ":", "\n", "    ", "\"\"\"\n    Implement operator-level flops counting using jit.\n    This is a wrapper of fvcore.nn.flop_count, that supports standard detection models\n    in detectron2.\n\n    Note:\n        The function runs the input through the model to compute flops.\n        The flops of a detection model is often input-dependent, for example,\n        the flops of box & mask head depends on the number of proposals &\n        the number of detected objects.\n        Therefore, the flops counting using a single input may not accurately\n        reflect the computation cost of a model.\n\n    Args:\n        model: a detectron2 model that takes `list[dict]` as input.\n        inputs (list[dict]): inputs to model, in detectron2's standard format.\n    \"\"\"", "\n", "return", "_wrapper_count_operators", "(", "model", "=", "model", ",", "inputs", "=", "inputs", ",", "mode", "=", "FLOPS_MODE", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.analysis.activation_count_operators": [[78, 97], ["analysis._wrapper_count_operators"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.analysis._wrapper_count_operators"], ["", "def", "activation_count_operators", "(", "\n", "model", ":", "nn", ".", "Module", ",", "inputs", ":", "list", ",", "**", "kwargs", "\n", ")", "->", "typing", ".", "DefaultDict", "[", "str", ",", "float", "]", ":", "\n", "    ", "\"\"\"\n    Implement operator-level activations counting using jit.\n    This is a wrapper of fvcore.nn.activation_count, that supports standard detection models\n    in detectron2.\n\n    Note:\n        The function runs the input through the model to compute activations.\n        The activations of a detection model is often input-dependent, for example,\n        the activations of box & mask head depends on the number of proposals &\n        the number of detected objects.\n\n    Args:\n        model: a detectron2 model that takes `list[dict]` as input.\n        inputs (list[dict]): inputs to model, in detectron2's standard format.\n    \"\"\"", "\n", "return", "_wrapper_count_operators", "(", "model", "=", "model", ",", "inputs", "=", "inputs", ",", "mode", "=", "ACTIVATIONS_MODE", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.analysis._flatten_to_tuple": [[99, 120], ["isinstance", "tuple", "result.append", "isinstance", "isinstance", "result.extend", "outputs.items", "isinstance", "analysis._flatten_to_tuple", "result.extend", "result.extend", "isinstance", "analysis._flatten_to_tuple", "analysis._flatten_to_tuple", "result.append", "logger.log_first_n", "outputs.get_fields", "type"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.analysis._flatten_to_tuple", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.analysis._flatten_to_tuple", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.analysis._flatten_to_tuple", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.log_first_n", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.get_fields"], ["", "def", "_flatten_to_tuple", "(", "outputs", ")", ":", "\n", "    ", "result", "=", "[", "]", "\n", "if", "isinstance", "(", "outputs", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "result", ".", "append", "(", "outputs", ")", "\n", "", "elif", "isinstance", "(", "outputs", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "for", "v", "in", "outputs", ":", "\n", "            ", "result", ".", "extend", "(", "_flatten_to_tuple", "(", "v", ")", ")", "\n", "", "", "elif", "isinstance", "(", "outputs", ",", "dict", ")", ":", "\n", "        ", "for", "_", ",", "v", "in", "outputs", ".", "items", "(", ")", ":", "\n", "            ", "result", ".", "extend", "(", "_flatten_to_tuple", "(", "v", ")", ")", "\n", "", "", "elif", "isinstance", "(", "outputs", ",", "Instances", ")", ":", "\n", "        ", "result", ".", "extend", "(", "_flatten_to_tuple", "(", "outputs", ".", "get_fields", "(", ")", ")", ")", "\n", "", "elif", "isinstance", "(", "outputs", ",", "(", "Boxes", ",", "BitMasks", ",", "ImageList", ")", ")", ":", "\n", "        ", "result", ".", "append", "(", "outputs", ".", "tensor", ")", "\n", "", "else", ":", "\n", "        ", "log_first_n", "(", "\n", "logging", ".", "WARN", ",", "\n", "f\"Output of type {type(outputs)} not included in flops/activations count.\"", ",", "\n", "n", "=", "10", ",", "\n", ")", "\n", "", "return", "tuple", "(", "result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.analysis._wrapper_count_operators": [[122, 165], ["supported_ops.update", "isinstance", "model.train", "kwargs.pop", "len", "torch.no_grad", "super().__init__", "isinstance", "analysis..model.forward", "analysis._flatten_to_tuple", "fvcore.nn.flop_count", "WrapModel().train", "fvcore.nn.activation_count", "NotImplementedError", "WrapModel().train", "WrapModel", "WrapModel"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.forward", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.analysis._flatten_to_tuple", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train"], ["", "def", "_wrapper_count_operators", "(", "\n", "model", ":", "nn", ".", "Module", ",", "inputs", ":", "list", ",", "mode", ":", "str", ",", "**", "kwargs", "\n", ")", "->", "typing", ".", "DefaultDict", "[", "str", ",", "float", "]", ":", "\n", "\n", "# ignore some ops", "\n", "    ", "supported_ops", "=", "{", "k", ":", "lambda", "*", "args", ",", "**", "kwargs", ":", "{", "}", "for", "k", "in", "_IGNORED_OPS", "}", "\n", "supported_ops", ".", "update", "(", "kwargs", ".", "pop", "(", "\"supported_ops\"", ",", "{", "}", ")", ")", "\n", "kwargs", "[", "\"supported_ops\"", "]", "=", "supported_ops", "\n", "\n", "assert", "len", "(", "inputs", ")", "==", "1", ",", "\"Please use batch size=1\"", "\n", "tensor_input", "=", "inputs", "[", "0", "]", "[", "\"image\"", "]", "\n", "\n", "class", "WrapModel", "(", "nn", ".", "Module", ")", ":", "\n", "        ", "def", "__init__", "(", "self", ",", "model", ")", ":", "\n", "            ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "isinstance", "(", "\n", "model", ",", "(", "nn", ".", "parallel", ".", "distributed", ".", "DistributedDataParallel", ",", "nn", ".", "DataParallel", ")", "\n", ")", ":", "\n", "                ", "self", ".", "model", "=", "model", ".", "module", "\n", "", "else", ":", "\n", "                ", "self", ".", "model", "=", "model", "\n", "\n", "", "", "def", "forward", "(", "self", ",", "image", ")", ":", "\n", "# jit requires the input/output to be Tensors", "\n", "            ", "inputs", "=", "[", "{", "\"image\"", ":", "image", "}", "]", "\n", "outputs", "=", "self", ".", "model", ".", "forward", "(", "inputs", ")", "\n", "# Only the subgraph that computes the returned tuple of tensor will be", "\n", "# counted. So we flatten everything we found to tuple of tensors.", "\n", "return", "_flatten_to_tuple", "(", "outputs", ")", "\n", "\n", "", "", "old_train", "=", "model", ".", "training", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "if", "mode", "==", "FLOPS_MODE", ":", "\n", "            ", "ret", "=", "flop_count", "(", "WrapModel", "(", "model", ")", ".", "train", "(", "False", ")", ",", "(", "tensor_input", ",", ")", ",", "**", "kwargs", ")", "\n", "", "elif", "mode", "==", "ACTIVATIONS_MODE", ":", "\n", "            ", "ret", "=", "activation_count", "(", "WrapModel", "(", "model", ")", ".", "train", "(", "False", ")", ",", "(", "tensor_input", ",", ")", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Count for mode {} is not supported yet.\"", ".", "format", "(", "mode", ")", ")", "\n", "# compatible with change in fvcore", "\n", "", "", "if", "isinstance", "(", "ret", ",", "tuple", ")", ":", "\n", "        ", "ret", "=", "ret", "[", "0", "]", "\n", "", "model", ".", "train", "(", "old_train", ")", "\n", "return", "ret", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger._ColorfulFormatter.__init__": [[15, 21], ["kwargs.pop", "len", "logging.Formatter.__init__", "kwargs.pop"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "_root_name", "=", "kwargs", ".", "pop", "(", "\"root_name\"", ")", "+", "\".\"", "\n", "self", ".", "_abbrev_name", "=", "kwargs", ".", "pop", "(", "\"abbrev_name\"", ",", "\"\"", ")", "\n", "if", "len", "(", "self", ".", "_abbrev_name", ")", ":", "\n", "            ", "self", ".", "_abbrev_name", "=", "self", ".", "_abbrev_name", "+", "\".\"", "\n", "", "super", "(", "_ColorfulFormatter", ",", "self", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger._ColorfulFormatter.formatMessage": [[22, 32], ["record.name.replace", "super().formatMessage", "termcolor.colored", "termcolor.colored"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger._ColorfulFormatter.formatMessage"], ["", "def", "formatMessage", "(", "self", ",", "record", ")", ":", "\n", "        ", "record", ".", "name", "=", "record", ".", "name", ".", "replace", "(", "self", ".", "_root_name", ",", "self", ".", "_abbrev_name", ")", "\n", "log", "=", "super", "(", "_ColorfulFormatter", ",", "self", ")", ".", "formatMessage", "(", "record", ")", "\n", "if", "record", ".", "levelno", "==", "logging", ".", "WARNING", ":", "\n", "            ", "prefix", "=", "colored", "(", "\"WARNING\"", ",", "\"red\"", ",", "attrs", "=", "[", "\"blink\"", "]", ")", "\n", "", "elif", "record", ".", "levelno", "==", "logging", ".", "ERROR", "or", "record", ".", "levelno", "==", "logging", ".", "CRITICAL", ":", "\n", "            ", "prefix", "=", "colored", "(", "\"ERROR\"", ",", "\"red\"", ",", "attrs", "=", "[", "\"blink\"", ",", "\"underline\"", "]", ")", "\n", "", "else", ":", "\n", "            ", "return", "log", "\n", "", "return", "prefix", "+", "\" \"", "+", "log", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.setup_logger": [[34, 96], ["functools.lru_cache", "logging.getLogger", "logging.getLogger.setLevel", "logging.Formatter", "logging.StreamHandler", "logging.StreamHandler.setLevel", "logging.StreamHandler.setFormatter", "logging.getLogger.addHandler", "fvcore.common.file_io.PathManager.mkdirs", "logging.StreamHandler", "logging.StreamHandler.setLevel", "logging.StreamHandler.setFormatter", "logging.getLogger.addHandler", "logger._ColorfulFormatter", "output.endswith", "output.endswith", "os.path.join", "os.path.dirname", "logger._cached_log_stream", "termcolor.colored", "str"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger._cached_log_stream"], ["", "", "@", "functools", ".", "lru_cache", "(", ")", "# so that calling setup_logger multiple times won't add many handlers", "\n", "def", "setup_logger", "(", "\n", "output", "=", "None", ",", "distributed_rank", "=", "0", ",", "*", ",", "color", "=", "True", ",", "name", "=", "\"detectron2\"", ",", "abbrev_name", "=", "None", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Initialize the detectron2 logger and set its verbosity level to \"DEBUG\".\n\n    Args:\n        output (str): a file name or a directory to save log. If None, will not save log file.\n            If ends with \".txt\" or \".log\", assumed to be a file name.\n            Otherwise, logs will be saved to `output/log.txt`.\n        name (str): the root module name of this logger\n        abbrev_name (str): an abbreviation of the module, to avoid long names in logs.\n            Set to \"\" to not log the root module in logs.\n            By default, will abbreviate \"detectron2\" to \"d2\" and leave other\n            modules unchanged.\n\n    Returns:\n        logging.Logger: a logger\n    \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "name", ")", "\n", "logger", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "logger", ".", "propagate", "=", "False", "\n", "\n", "if", "abbrev_name", "is", "None", ":", "\n", "        ", "abbrev_name", "=", "\"d2\"", "if", "name", "==", "\"detectron2\"", "else", "name", "\n", "\n", "", "plain_formatter", "=", "logging", ".", "Formatter", "(", "\n", "\"[%(asctime)s] %(name)s %(levelname)s: %(message)s\"", ",", "datefmt", "=", "\"%m/%d %H:%M:%S\"", "\n", ")", "\n", "# stdout logging: master only", "\n", "if", "distributed_rank", "==", "0", ":", "\n", "        ", "ch", "=", "logging", ".", "StreamHandler", "(", "stream", "=", "sys", ".", "stdout", ")", "\n", "ch", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "if", "color", ":", "\n", "            ", "formatter", "=", "_ColorfulFormatter", "(", "\n", "colored", "(", "\"[%(asctime)s %(name)s]: \"", ",", "\"green\"", ")", "+", "\"%(message)s\"", ",", "\n", "datefmt", "=", "\"%m/%d %H:%M:%S\"", ",", "\n", "root_name", "=", "name", ",", "\n", "abbrev_name", "=", "str", "(", "abbrev_name", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "formatter", "=", "plain_formatter", "\n", "", "ch", ".", "setFormatter", "(", "formatter", ")", "\n", "logger", ".", "addHandler", "(", "ch", ")", "\n", "\n", "# file logging: all workers", "\n", "", "if", "output", "is", "not", "None", ":", "\n", "        ", "if", "output", ".", "endswith", "(", "\".txt\"", ")", "or", "output", ".", "endswith", "(", "\".log\"", ")", ":", "\n", "            ", "filename", "=", "output", "\n", "", "else", ":", "\n", "            ", "filename", "=", "os", ".", "path", ".", "join", "(", "output", ",", "\"log.txt\"", ")", "\n", "", "if", "distributed_rank", ">", "0", ":", "\n", "            ", "filename", "=", "filename", "+", "\".rank{}\"", ".", "format", "(", "distributed_rank", ")", "\n", "", "PathManager", ".", "mkdirs", "(", "os", ".", "path", ".", "dirname", "(", "filename", ")", ")", "\n", "\n", "fh", "=", "logging", ".", "StreamHandler", "(", "_cached_log_stream", "(", "filename", ")", ")", "\n", "fh", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "fh", ".", "setFormatter", "(", "plain_formatter", ")", "\n", "logger", ".", "addHandler", "(", "fh", ")", "\n", "\n", "", "return", "logger", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger._cached_log_stream": [[100, 105], ["functools.lru_cache", "fvcore.common.file_io.PathManager.open", "atexit.register"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.base.BaseConverter.register"], ["", "@", "functools", ".", "lru_cache", "(", "maxsize", "=", "None", ")", "\n", "def", "_cached_log_stream", "(", "filename", ")", ":", "\n", "    ", "io", "=", "PathManager", ".", "open", "(", "filename", ",", "\"a\"", ")", "\n", "atexit", ".", "register", "(", "io", ".", "close", ")", "\n", "return", "io", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger._find_caller": [[114, 129], ["sys._getframe", "os.path.join"], "function", ["None"], ["def", "_find_caller", "(", ")", ":", "\n", "    ", "\"\"\"\n    Returns:\n        str: module name of the caller\n        tuple: a hashable key to be used to identify different callers\n    \"\"\"", "\n", "frame", "=", "sys", ".", "_getframe", "(", "2", ")", "\n", "while", "frame", ":", "\n", "        ", "code", "=", "frame", ".", "f_code", "\n", "if", "os", ".", "path", ".", "join", "(", "\"utils\"", ",", "\"logger.\"", ")", "not", "in", "code", ".", "co_filename", ":", "\n", "            ", "mod_name", "=", "frame", ".", "f_globals", "[", "\"__name__\"", "]", "\n", "if", "mod_name", "==", "\"__main__\"", ":", "\n", "                ", "mod_name", "=", "\"detectron2\"", "\n", "", "return", "mod_name", ",", "(", "code", ".", "co_filename", ",", "frame", ".", "f_lineno", ",", "code", ".", "co_name", ")", "\n", "", "frame", "=", "frame", ".", "f_back", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.log_first_n": [[135, 168], ["isinstance", "logger._find_caller", "len", "logging.getLogger().log", "logging.getLogger"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger._find_caller"], ["def", "log_first_n", "(", "lvl", ",", "msg", ",", "n", "=", "1", ",", "*", ",", "name", "=", "None", ",", "key", "=", "\"caller\"", ")", ":", "\n", "    ", "\"\"\"\n    Log only for the first n times.\n\n    Args:\n        lvl (int): the logging level\n        msg (str):\n        n (int):\n        name (str): name of the logger to use. Will use the caller's module by default.\n        key (str or tuple[str]): the string(s) can be one of \"caller\" or\n            \"message\", which defines how to identify duplicated logs.\n            For example, if called with `n=1, key=\"caller\"`, this function\n            will only log the first call from the same caller, regardless of\n            the message content.\n            If called with `n=1, key=\"message\"`, this function will log the\n            same content only once, even if they are called from different places.\n            If called with `n=1, key=(\"caller\", \"message\")`, this function\n            will not log only if the same caller has logged the same message before.\n    \"\"\"", "\n", "if", "isinstance", "(", "key", ",", "str", ")", ":", "\n", "        ", "key", "=", "(", "key", ",", ")", "\n", "", "assert", "len", "(", "key", ")", ">", "0", "\n", "\n", "caller_module", ",", "caller_key", "=", "_find_caller", "(", ")", "\n", "hash_key", "=", "(", ")", "\n", "if", "\"caller\"", "in", "key", ":", "\n", "        ", "hash_key", "=", "hash_key", "+", "caller_key", "\n", "", "if", "\"message\"", "in", "key", ":", "\n", "        ", "hash_key", "=", "hash_key", "+", "(", "msg", ",", ")", "\n", "\n", "", "_LOG_COUNTER", "[", "hash_key", "]", "+=", "1", "\n", "if", "_LOG_COUNTER", "[", "hash_key", "]", "<=", "n", ":", "\n", "        ", "logging", ".", "getLogger", "(", "name", "or", "caller_module", ")", ".", "log", "(", "lvl", ",", "msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.log_every_n": [[170, 184], ["logger._find_caller", "logging.getLogger().log", "logging.getLogger"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger._find_caller"], ["", "", "def", "log_every_n", "(", "lvl", ",", "msg", ",", "n", "=", "1", ",", "*", ",", "name", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Log once per n times.\n\n    Args:\n        lvl (int): the logging level\n        msg (str):\n        n (int):\n        name (str): name of the logger to use. Will use the caller's module by default.\n    \"\"\"", "\n", "caller_module", ",", "key", "=", "_find_caller", "(", ")", "\n", "_LOG_COUNTER", "[", "key", "]", "+=", "1", "\n", "if", "n", "==", "1", "or", "_LOG_COUNTER", "[", "key", "]", "%", "n", "==", "1", ":", "\n", "        ", "logging", ".", "getLogger", "(", "name", "or", "caller_module", ")", ".", "log", "(", "lvl", ",", "msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.log_every_n_seconds": [[186, 202], ["logger._find_caller", "_LOG_TIMER.get", "time.time", "logging.getLogger().log", "logging.getLogger"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger._find_caller", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "", "def", "log_every_n_seconds", "(", "lvl", ",", "msg", ",", "n", "=", "1", ",", "*", ",", "name", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Log no more than once per n seconds.\n\n    Args:\n        lvl (int): the logging level\n        msg (str):\n        n (int):\n        name (str): name of the logger to use. Will use the caller's module by default.\n    \"\"\"", "\n", "caller_module", ",", "key", "=", "_find_caller", "(", ")", "\n", "last_logged", "=", "_LOG_TIMER", ".", "get", "(", "key", ",", "None", ")", "\n", "current_time", "=", "time", ".", "time", "(", ")", "\n", "if", "last_logged", "is", "None", "or", "current_time", "-", "last_logged", ">=", "n", ":", "\n", "        ", "logging", ".", "getLogger", "(", "name", "or", "caller_module", ")", ".", "log", "(", "lvl", ",", "msg", ")", "\n", "_LOG_TIMER", "[", "key", "]", "=", "current_time", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.create_small_table": [[204, 225], ["tuple", "tabulate.tabulate", "zip", "small_dict.items"], "function", ["None"], ["", "", "def", "create_small_table", "(", "small_dict", ")", ":", "\n", "    ", "\"\"\"\n    Create a small table using the keys of small_dict as headers. This is only\n    suitable for small dictionaries.\n\n    Args:\n        small_dict (dict): a result dictionary of only a few items.\n\n    Returns:\n        str: the table as a string.\n    \"\"\"", "\n", "keys", ",", "values", "=", "tuple", "(", "zip", "(", "*", "small_dict", ".", "items", "(", ")", ")", ")", "\n", "table", "=", "tabulate", "(", "\n", "[", "values", "]", ",", "\n", "headers", "=", "keys", ",", "\n", "tablefmt", "=", "\"pipe\"", ",", "\n", "floatfmt", "=", "\".3f\"", ",", "\n", "stralign", "=", "\"center\"", ",", "\n", "numalign", "=", "\"center\"", ",", "\n", ")", "\n", "return", "table", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect_env.collect_torch_env": [[17, 27], ["torch.__config__.show", "get_pretty_env_info"], "function", ["None"], ["def", "collect_torch_env", "(", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "import", "torch", ".", "__config__", "\n", "\n", "return", "torch", ".", "__config__", ".", "show", "(", ")", "\n", "", "except", "ImportError", ":", "\n", "# compatible with older versions of pytorch", "\n", "        ", "from", "torch", ".", "utils", ".", "collect_env", "import", "get_pretty_env_info", "\n", "\n", "return", "get_pretty_env_info", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect_env.get_env_module": [[29, 32], ["os.environ.get"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "", "def", "get_env_module", "(", ")", ":", "\n", "    ", "var_name", "=", "\"DETECTRON2_ENV_MODULE\"", "\n", "return", "var_name", ",", "os", ".", "environ", ".", "get", "(", "var_name", ",", "\"<not set>\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect_env.detect_compute_compatibility": [[34, 53], ["os.path.join", "os.path.isfile", "subprocess.check_output", "output.decode().strip().split.decode().strip().split", "sorted", "sorted.append", "set", "output.decode().strip().split.decode().strip", "re.findall", "output.decode().strip().split.decode"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["", "def", "detect_compute_compatibility", "(", "CUDA_HOME", ",", "so_file", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "cuobjdump", "=", "os", ".", "path", ".", "join", "(", "CUDA_HOME", ",", "\"bin\"", ",", "\"cuobjdump\"", ")", "\n", "if", "os", ".", "path", ".", "isfile", "(", "cuobjdump", ")", ":", "\n", "            ", "output", "=", "subprocess", ".", "check_output", "(", "\n", "\"'{}' --list-elf '{}'\"", ".", "format", "(", "cuobjdump", ",", "so_file", ")", ",", "shell", "=", "True", "\n", ")", "\n", "output", "=", "output", ".", "decode", "(", "\"utf-8\"", ")", ".", "strip", "(", ")", ".", "split", "(", "\"\\n\"", ")", "\n", "arch", "=", "[", "]", "\n", "for", "line", "in", "output", ":", "\n", "                ", "line", "=", "re", ".", "findall", "(", "r\"\\.sm_([0-9]*)\\.\"", ",", "line", ")", "[", "0", "]", "\n", "arch", ".", "append", "(", "\".\"", ".", "join", "(", "line", ")", ")", "\n", "", "arch", "=", "sorted", "(", "set", "(", "arch", ")", ")", "\n", "return", "\", \"", ".", "join", "(", "arch", ")", "\n", "", "else", ":", "\n", "            ", "return", "so_file", "+", "\"; cannot find cuobjdump\"", "\n", "", "", "except", "Exception", ":", "\n", "# unhandled failure", "\n", "        ", "return", "so_file", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect_env.collect_env_info": [[55, 177], ["torch.cuda.is_available", "data.append", "data.append", "data.append", "data.append", "data.append", "data.append", "data.append", "data.append", "collect_env.collect_torch_env", "tuple", "data.append", "data.append", "data.append", "collect_env.get_env_module", "collections.defaultdict", "range", "collections.defaultdict.items", "data.append", "data.append", "data.append", "tabulate.tabulate", "map", "sys.version.replace", "data.append", "data.append", "data.append", "torch.cuda.device_count", "devices[].append", "data.append", "data.append", "data.append", "os.environ.get", "data.append", "data.append", "getattr", "data.append", "_C.get_compiler_version", "_C.get_cuda_version", "os.path.dirname", "torch.cuda.get_device_name", "str", "data.append", "collect_env.detect_compute_compatibility", "data.append", "torch_version.split", "os.path.dirname", "os.environ.get", "subprocess.check_output", "data.append", "collect_env.detect_compute_compatibility", "str", "os.path.isdir", "os.path.isdir", "os.path.dirname", "importlib.util.find_spec", "data.append", "subprocess.check_output.decode().strip().split", "os.path.join", "subprocess.check_output", "torch.cuda.get_device_capability", "str", "str", "str", "subprocess.check_output.decode().strip().split", "subprocess.check_output.decode().strip", "subprocess.check_output.decode().strip", "subprocess.check_output.decode", "subprocess.check_output.decode"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect_env.collect_torch_env", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect_env.get_env_module", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect_env.detect_compute_compatibility", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect_env.detect_compute_compatibility"], ["", "", "def", "collect_env_info", "(", ")", ":", "\n", "    ", "has_gpu", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "# true for both CUDA & ROCM", "\n", "torch_version", "=", "torch", ".", "__version__", "\n", "\n", "# NOTE: the use of CUDA_HOME and ROCM_HOME requires the CUDA/ROCM build deps, though in", "\n", "# theory detectron2 should be made runnable with only the corresponding runtimes", "\n", "from", "torch", ".", "utils", ".", "cpp_extension", "import", "CUDA_HOME", "\n", "\n", "has_rocm", "=", "False", "\n", "if", "tuple", "(", "map", "(", "int", ",", "torch_version", ".", "split", "(", "\".\"", ")", "[", ":", "2", "]", ")", ")", ">=", "(", "1", ",", "5", ")", ":", "\n", "        ", "from", "torch", ".", "utils", ".", "cpp_extension", "import", "ROCM_HOME", "\n", "\n", "if", "(", "getattr", "(", "torch", ".", "version", ",", "\"hip\"", ",", "None", ")", "is", "not", "None", ")", "and", "(", "ROCM_HOME", "is", "not", "None", ")", ":", "\n", "            ", "has_rocm", "=", "True", "\n", "", "", "has_cuda", "=", "has_gpu", "and", "(", "not", "has_rocm", ")", "\n", "\n", "data", "=", "[", "]", "\n", "data", ".", "append", "(", "(", "\"sys.platform\"", ",", "sys", ".", "platform", ")", ")", "\n", "data", ".", "append", "(", "(", "\"Python\"", ",", "sys", ".", "version", ".", "replace", "(", "\"\\n\"", ",", "\"\"", ")", ")", ")", "\n", "data", ".", "append", "(", "(", "\"numpy\"", ",", "np", ".", "__version__", ")", ")", "\n", "\n", "try", ":", "\n", "        ", "import", "detectron2", "# noqa", "\n", "\n", "data", ".", "append", "(", "\n", "(", "\"detectron2\"", ",", "detectron2", ".", "__version__", "+", "\" @\"", "+", "os", ".", "path", ".", "dirname", "(", "detectron2", ".", "__file__", ")", ")", "\n", ")", "\n", "", "except", "ImportError", ":", "\n", "        ", "data", ".", "append", "(", "(", "\"detectron2\"", ",", "\"failed to import\"", ")", ")", "\n", "\n", "", "try", ":", "\n", "        ", "from", "detectron2", "import", "_C", "\n", "", "except", "ImportError", ":", "\n", "        ", "data", ".", "append", "(", "(", "\"detectron2._C\"", ",", "\"failed to import. detectron2 is not built correctly\"", ")", ")", "\n", "\n", "# print system compilers when extension fails to build", "\n", "if", "sys", ".", "platform", "!=", "\"win32\"", ":", "# don't know what to do for windows", "\n", "            ", "try", ":", "\n", "# this is how torch/utils/cpp_extensions.py choose compiler", "\n", "                ", "cxx", "=", "os", ".", "environ", ".", "get", "(", "\"CXX\"", ",", "\"c++\"", ")", "\n", "cxx", "=", "subprocess", ".", "check_output", "(", "\"'{}' --version\"", ".", "format", "(", "cxx", ")", ",", "shell", "=", "True", ")", "\n", "cxx", "=", "cxx", ".", "decode", "(", "\"utf-8\"", ")", ".", "strip", "(", ")", ".", "split", "(", "\"\\n\"", ")", "[", "0", "]", "\n", "", "except", "subprocess", ".", "SubprocessError", ":", "\n", "                ", "cxx", "=", "\"Not found\"", "\n", "", "data", ".", "append", "(", "(", "\"Compiler\"", ",", "cxx", ")", ")", "\n", "\n", "if", "has_cuda", "and", "CUDA_HOME", "is", "not", "None", ":", "\n", "                ", "try", ":", "\n", "                    ", "nvcc", "=", "os", ".", "path", ".", "join", "(", "CUDA_HOME", ",", "\"bin\"", ",", "\"nvcc\"", ")", "\n", "nvcc", "=", "subprocess", ".", "check_output", "(", "\"'{}' -V\"", ".", "format", "(", "nvcc", ")", ",", "shell", "=", "True", ")", "\n", "nvcc", "=", "nvcc", ".", "decode", "(", "\"utf-8\"", ")", ".", "strip", "(", ")", ".", "split", "(", "\"\\n\"", ")", "[", "-", "1", "]", "\n", "", "except", "subprocess", ".", "SubprocessError", ":", "\n", "                    ", "nvcc", "=", "\"Not found\"", "\n", "", "data", ".", "append", "(", "(", "\"CUDA compiler\"", ",", "nvcc", ")", ")", "\n", "", "", "", "else", ":", "\n", "# print compilers that are used to build extension", "\n", "        ", "data", ".", "append", "(", "(", "\"Compiler\"", ",", "_C", ".", "get_compiler_version", "(", ")", ")", ")", "\n", "data", ".", "append", "(", "(", "\"CUDA compiler\"", ",", "_C", ".", "get_cuda_version", "(", ")", ")", ")", "# cuda or hip", "\n", "if", "has_cuda", ":", "\n", "            ", "data", ".", "append", "(", "\n", "(", "\"detectron2 arch flags\"", ",", "detect_compute_compatibility", "(", "CUDA_HOME", ",", "_C", ".", "__file__", ")", ")", "\n", ")", "\n", "\n", "", "", "data", ".", "append", "(", "get_env_module", "(", ")", ")", "\n", "data", ".", "append", "(", "(", "\"PyTorch\"", ",", "torch_version", "+", "\" @\"", "+", "os", ".", "path", ".", "dirname", "(", "torch", ".", "__file__", ")", ")", ")", "\n", "data", ".", "append", "(", "(", "\"PyTorch debug build\"", ",", "torch", ".", "version", ".", "debug", ")", ")", "\n", "\n", "data", ".", "append", "(", "(", "\"GPU available\"", ",", "has_gpu", ")", ")", "\n", "if", "has_gpu", ":", "\n", "        ", "devices", "=", "defaultdict", "(", "list", ")", "\n", "for", "k", "in", "range", "(", "torch", ".", "cuda", ".", "device_count", "(", ")", ")", ":", "\n", "            ", "cap", "=", "\".\"", ".", "join", "(", "(", "str", "(", "x", ")", "for", "x", "in", "torch", ".", "cuda", ".", "get_device_capability", "(", "k", ")", ")", ")", "\n", "name", "=", "torch", ".", "cuda", ".", "get_device_name", "(", "k", ")", "+", "f\" (arch={cap})\"", "\n", "devices", "[", "name", "]", ".", "append", "(", "str", "(", "k", ")", ")", "\n", "", "for", "name", ",", "devids", "in", "devices", ".", "items", "(", ")", ":", "\n", "            ", "data", ".", "append", "(", "(", "\"GPU \"", "+", "\",\"", ".", "join", "(", "devids", ")", ",", "name", ")", ")", "\n", "\n", "", "if", "has_rocm", ":", "\n", "            ", "msg", "=", "\" - invalid!\"", "if", "not", "os", ".", "path", ".", "isdir", "(", "ROCM_HOME", ")", "else", "\"\"", "\n", "data", ".", "append", "(", "(", "\"ROCM_HOME\"", ",", "str", "(", "ROCM_HOME", ")", "+", "msg", ")", ")", "\n", "", "else", ":", "\n", "            ", "msg", "=", "\" - invalid!\"", "if", "not", "os", ".", "path", ".", "isdir", "(", "CUDA_HOME", ")", "else", "\"\"", "\n", "data", ".", "append", "(", "(", "\"CUDA_HOME\"", ",", "str", "(", "CUDA_HOME", ")", "+", "msg", ")", ")", "\n", "\n", "cuda_arch_list", "=", "os", ".", "environ", ".", "get", "(", "\"TORCH_CUDA_ARCH_LIST\"", ",", "None", ")", "\n", "if", "cuda_arch_list", ":", "\n", "                ", "data", ".", "append", "(", "(", "\"TORCH_CUDA_ARCH_LIST\"", ",", "cuda_arch_list", ")", ")", "\n", "", "", "", "data", ".", "append", "(", "(", "\"Pillow\"", ",", "PIL", ".", "__version__", ")", ")", "\n", "\n", "try", ":", "\n", "        ", "data", ".", "append", "(", "\n", "(", "\n", "\"torchvision\"", ",", "\n", "str", "(", "torchvision", ".", "__version__", ")", "+", "\" @\"", "+", "os", ".", "path", ".", "dirname", "(", "torchvision", ".", "__file__", ")", ",", "\n", ")", "\n", ")", "\n", "if", "has_cuda", ":", "\n", "            ", "try", ":", "\n", "                ", "torchvision_C", "=", "importlib", ".", "util", ".", "find_spec", "(", "\"torchvision._C\"", ")", ".", "origin", "\n", "msg", "=", "detect_compute_compatibility", "(", "CUDA_HOME", ",", "torchvision_C", ")", "\n", "data", ".", "append", "(", "(", "\"torchvision arch flags\"", ",", "msg", ")", ")", "\n", "", "except", "ImportError", ":", "\n", "                ", "data", ".", "append", "(", "(", "\"torchvision._C\"", ",", "\"Not found\"", ")", ")", "\n", "", "", "", "except", "AttributeError", ":", "\n", "        ", "data", ".", "append", "(", "(", "\"torchvision\"", ",", "\"unknown\"", ")", ")", "\n", "\n", "", "try", ":", "\n", "        ", "import", "fvcore", "\n", "\n", "data", ".", "append", "(", "(", "\"fvcore\"", ",", "fvcore", ".", "__version__", ")", ")", "\n", "", "except", "ImportError", ":", "\n", "        ", "pass", "\n", "\n", "", "try", ":", "\n", "        ", "import", "cv2", "\n", "\n", "data", ".", "append", "(", "(", "\"cv2\"", ",", "cv2", ".", "__version__", ")", ")", "\n", "", "except", "ImportError", ":", "\n", "        ", "data", ".", "append", "(", "(", "\"cv2\"", ",", "\"Not found\"", ")", ")", "\n", "", "env_str", "=", "tabulate", "(", "data", ")", "+", "\"\\n\"", "\n", "env_str", "+=", "collect_torch_env", "(", ")", "\n", "return", "env_str", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.env.seed_all_rng": [[21, 39], ["numpy.random.seed", "torch.set_rng_state", "random.seed", "logging.getLogger", "logging.getLogger.info", "torch.manual_seed().get_state", "int.from_bytes", "os.getpid", "int", "os.urandom", "torch.manual_seed", "datetime.datetime.now().strftime", "datetime.datetime.now"], "function", ["None"], ["def", "seed_all_rng", "(", "seed", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Set the random seed for the RNG in torch, numpy and python.\n\n    Args:\n        seed (int): if None, will use a strong random seed.\n    \"\"\"", "\n", "if", "seed", "is", "None", ":", "\n", "        ", "seed", "=", "(", "\n", "os", ".", "getpid", "(", ")", "\n", "+", "int", "(", "datetime", ".", "now", "(", ")", ".", "strftime", "(", "\"%S%f\"", ")", ")", "\n", "+", "int", ".", "from_bytes", "(", "os", ".", "urandom", "(", "2", ")", ",", "\"big\"", ")", "\n", ")", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Using a generated random seed {}\"", ".", "format", "(", "seed", ")", ")", "\n", "", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "torch", ".", "set_rng_state", "(", "torch", ".", "manual_seed", "(", "seed", ")", ".", "get_state", "(", ")", ")", "\n", "random", ".", "seed", "(", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.env._import_file": [[42, 49], ["importlib.util.spec_from_file_location", "importlib.util.spec_from_file_location", "importlib.util.module_from_spec", "importlib.util.module_from_spec", "importlib.util.spec_from_file_location.loader.exec_module"], "function", ["None"], ["", "def", "_import_file", "(", "module_name", ",", "file_path", ",", "make_importable", "=", "False", ")", ":", "\n", "    ", "spec", "=", "importlib", ".", "util", ".", "spec_from_file_location", "(", "module_name", ",", "file_path", ")", "\n", "module", "=", "importlib", ".", "util", ".", "module_from_spec", "(", "spec", ")", "\n", "spec", ".", "loader", ".", "exec_module", "(", "module", ")", "\n", "if", "make_importable", ":", "\n", "        ", "sys", ".", "modules", "[", "module_name", "]", "=", "module", "\n", "", "return", "module", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.env._configure_libraries": [[51, 84], ["int", "os.environ.get", "tuple", "env._configure_libraries.get_version"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.detection.setup.get_version"], ["", "def", "_configure_libraries", "(", ")", ":", "\n", "    ", "\"\"\"\n    Configurations for some libraries.\n    \"\"\"", "\n", "# An environment option to disable `import cv2` globally,", "\n", "# in case it leads to negative performance impact", "\n", "disable_cv2", "=", "int", "(", "os", ".", "environ", ".", "get", "(", "\"DETECTRON2_DISABLE_CV2\"", ",", "False", ")", ")", "\n", "if", "disable_cv2", ":", "\n", "        ", "sys", ".", "modules", "[", "\"cv2\"", "]", "=", "None", "\n", "", "else", ":", "\n", "# Disable opencl in opencv since its interaction with cuda often has negative effects", "\n", "# This envvar is supported after OpenCV 3.4.0", "\n", "        ", "os", ".", "environ", "[", "\"OPENCV_OPENCL_RUNTIME\"", "]", "=", "\"disabled\"", "\n", "try", ":", "\n", "            ", "import", "cv2", "\n", "\n", "if", "int", "(", "cv2", ".", "__version__", ".", "split", "(", "\".\"", ")", "[", "0", "]", ")", ">=", "3", ":", "\n", "                ", "cv2", ".", "ocl", ".", "setUseOpenCL", "(", "False", ")", "\n", "", "", "except", "ModuleNotFoundError", ":", "\n", "# Other types of ImportError, if happened, should not be ignored.", "\n", "# Because a failed opencv import could mess up address space", "\n", "# https://github.com/skvark/opencv-python/issues/381", "\n", "            ", "pass", "\n", "\n", "", "", "def", "get_version", "(", "module", ",", "digit", "=", "2", ")", ":", "\n", "        ", "return", "tuple", "(", "map", "(", "int", ",", "module", ".", "__version__", ".", "split", "(", "\".\"", ")", "[", ":", "digit", "]", ")", ")", "\n", "\n", "# fmt: off", "\n", "", "assert", "get_version", "(", "torch", ")", ">=", "(", "1", ",", "4", ")", ",", "\"Requires torch>=1.4\"", "\n", "import", "fvcore", "\n", "assert", "get_version", "(", "fvcore", ",", "3", ")", ">=", "(", "0", ",", "1", ",", "1", ")", ",", "\"Requires fvcore>=0.1.1\"", "\n", "import", "yaml", "\n", "assert", "get_version", "(", "yaml", ")", ">=", "(", "5", ",", "1", ")", ",", "\"Requires pyyaml>=5.1\"", "\n", "# fmt: on", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.env.setup_environment": [[90, 110], ["env._configure_libraries", "os.environ.get", "env.setup_custom_environment"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.env._configure_libraries", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.env.setup_custom_environment"], ["def", "setup_environment", "(", ")", ":", "\n", "    ", "\"\"\"Perform environment setup work. The default setup is a no-op, but this\n    function allows the user to specify a Python source file or a module in\n    the $DETECTRON2_ENV_MODULE environment variable, that performs\n    custom setup work that may be necessary to their computing environment.\n    \"\"\"", "\n", "global", "_ENV_SETUP_DONE", "\n", "if", "_ENV_SETUP_DONE", ":", "\n", "        ", "return", "\n", "", "_ENV_SETUP_DONE", "=", "True", "\n", "\n", "_configure_libraries", "(", ")", "\n", "\n", "custom_module_path", "=", "os", ".", "environ", ".", "get", "(", "\"DETECTRON2_ENV_MODULE\"", ")", "\n", "\n", "if", "custom_module_path", ":", "\n", "        ", "setup_custom_environment", "(", "custom_module_path", ")", "\n", "", "else", ":", "\n", "# The default setup is a no-op", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.env.setup_custom_environment": [[112, 126], ["custom_module.endswith", "importlib.import_module.setup_environment", "env._import_file", "importlib.import_module", "importlib.import_module", "hasattr", "callable"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.env.setup_environment", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.env._import_file"], ["", "", "def", "setup_custom_environment", "(", "custom_module", ")", ":", "\n", "    ", "\"\"\"\n    Load custom environment setup by importing a Python source file or a\n    module, and run the setup function.\n    \"\"\"", "\n", "if", "custom_module", ".", "endswith", "(", "\".py\"", ")", ":", "\n", "        ", "module", "=", "_import_file", "(", "\"detectron2.utils.env.custom_module\"", ",", "custom_module", ")", "\n", "", "else", ":", "\n", "        ", "module", "=", "importlib", ".", "import_module", "(", "custom_module", ")", "\n", "", "assert", "hasattr", "(", "module", ",", "\"setup_environment\"", ")", "and", "callable", "(", "module", ".", "setup_environment", ")", ",", "(", "\n", "\"Custom environment module defined in {} does not have the \"", "\n", "\"required callable attribute 'setup_environment'.\"", "\n", ")", ".", "format", "(", "custom_module", ")", "\n", "module", ".", "setup_environment", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.memory._ignore_torch_cuda_oom": [[11, 24], ["str"], "function", ["None"], ["@", "contextmanager", "\n", "def", "_ignore_torch_cuda_oom", "(", ")", ":", "\n", "    ", "\"\"\"\n    A context which ignores CUDA OOM exception from pytorch.\n    \"\"\"", "\n", "try", ":", "\n", "        ", "yield", "\n", "", "except", "RuntimeError", "as", "e", ":", "\n", "# NOTE: the string may change?", "\n", "        ", "if", "\"CUDA out of memory. \"", "in", "str", "(", "e", ")", ":", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "            ", "raise", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.memory.retry_if_cuda_oom": [[26, 85], ["functools.wraps", "torch.cuda.empty_cache", "logging.getLogger", "logging.getLogger.info", "func", "x.to", "memory._ignore_torch_cuda_oom", "func", "memory._ignore_torch_cuda_oom", "func", "memory.retry_if_cuda_oom.maybe_to_cpu"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.memory._ignore_torch_cuda_oom", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.memory._ignore_torch_cuda_oom"], ["", "", "", "def", "retry_if_cuda_oom", "(", "func", ")", ":", "\n", "    ", "\"\"\"\n    Makes a function retry itself after encountering\n    pytorch's CUDA OOM error.\n    It will first retry after calling `torch.cuda.empty_cache()`.\n\n    If that still fails, it will then retry by trying to convert inputs to CPUs.\n    In this case, it expects the function to dispatch to CPU implementation.\n    The return values may become CPU tensors as well and it's user's\n    responsibility to convert it back to CUDA tensor if needed.\n\n    Args:\n        func: a stateless callable that takes tensor-like objects as arguments\n\n    Returns:\n        a callable which retries `func` if OOM is encountered.\n\n    Examples:\n    ::\n        output = retry_if_cuda_oom(some_torch_function)(input1, input2)\n        # output may be on CPU even if inputs are on GPU\n\n    Note:\n        1. When converting inputs to CPU, it will only look at each argument and check\n           if it has `.device` and `.to` for conversion. Nested structures of tensors\n           are not supported.\n\n        2. Since the function might be called more than once, it has to be\n           stateless.\n    \"\"\"", "\n", "\n", "def", "maybe_to_cpu", "(", "x", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "like_gpu_tensor", "=", "x", ".", "device", ".", "type", "==", "\"cuda\"", "and", "hasattr", "(", "x", ",", "\"to\"", ")", "\n", "", "except", "AttributeError", ":", "\n", "            ", "like_gpu_tensor", "=", "False", "\n", "", "if", "like_gpu_tensor", ":", "\n", "            ", "return", "x", ".", "to", "(", "device", "=", "\"cpu\"", ")", "\n", "", "else", ":", "\n", "            ", "return", "x", "\n", "\n", "", "", "@", "wraps", "(", "func", ")", "\n", "def", "wrapped", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "with", "_ignore_torch_cuda_oom", "(", ")", ":", "\n", "            ", "return", "func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "# Clear cache and retry", "\n", "", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "with", "_ignore_torch_cuda_oom", "(", ")", ":", "\n", "            ", "return", "func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "# Try on CPU. This slows down the code significantly, therefore print a notice.", "\n", "", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Attempting to copy inputs of {} to CPU due to CUDA OOM\"", ".", "format", "(", "str", "(", "func", ")", ")", ")", "\n", "new_args", "=", "(", "maybe_to_cpu", "(", "x", ")", "for", "x", "in", "args", ")", "\n", "new_kwargs", "=", "{", "k", ":", "maybe_to_cpu", "(", "v", ")", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", "}", "\n", "return", "func", "(", "*", "new_args", ",", "**", "new_kwargs", ")", "\n", "\n", "", "return", "wrapped", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.dbhelper.EntrySelector.from_string": [[10, 15], ["dbhelper.FieldEntrySelector", "dbhelper.AllEntrySelector"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "from_string", "(", "spec", ":", "str", ")", "->", "\"EntrySelector\"", ":", "\n", "        ", "if", "spec", "==", "\"*\"", ":", "\n", "            ", "return", "AllEntrySelector", "(", ")", "\n", "", "return", "FieldEntrySelector", "(", "spec", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.dbhelper.AllEntrySelector.__call__": [[24, 26], ["None"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "entry", ")", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.dbhelper.FieldEntrySelector.__init__": [[85, 87], ["dbhelper.FieldEntrySelector._parse_specifier_into_predicates"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.dbhelper.FieldEntrySelector._parse_specifier_into_predicates"], ["", "", "def", "__init__", "(", "self", ",", "spec", ":", "str", ")", ":", "\n", "        ", "self", ".", "_predicates", "=", "self", ".", "_parse_specifier_into_predicates", "(", "spec", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.dbhelper.FieldEntrySelector.__call__": [[88, 93], ["predicate"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "entry", ":", "Dict", "[", "str", ",", "Any", "]", ")", ":", "\n", "        ", "for", "predicate", "in", "self", ".", "_predicates", ":", "\n", "            ", "if", "not", "predicate", "(", "entry", ")", ":", "\n", "                ", "return", "False", "\n", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.dbhelper.FieldEntrySelector._parse_specifier_into_predicates": [[94, 118], ["spec.split", "subspec.find", "dbhelper.FieldEntrySelector._parse_field_name_type", "dbhelper.FieldEntrySelector._is_range_spec", "predicates.append", "dbhelper.FieldEntrySelector._get_range_spec", "FieldEntrySelector._FieldEntryRangePredicate", "FieldEntrySelector._FieldEntryValuePredicate", "dbhelper.FieldEntrySelector._parse_error", "dbhelper.FieldEntrySelector._parse_error"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.dbhelper.FieldEntrySelector._parse_field_name_type", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.dbhelper.FieldEntrySelector._is_range_spec", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.dbhelper.FieldEntrySelector._get_range_spec", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.dbhelper.FieldEntrySelector._parse_error", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.dbhelper.FieldEntrySelector._parse_error"], ["", "def", "_parse_specifier_into_predicates", "(", "self", ",", "spec", ":", "str", ")", ":", "\n", "        ", "predicates", "=", "[", "]", "\n", "specs", "=", "spec", ".", "split", "(", "self", ".", "_SPEC_DELIM", ")", "\n", "for", "subspec", "in", "specs", ":", "\n", "            ", "eq_idx", "=", "subspec", ".", "find", "(", "self", ".", "_EQUAL", ")", "\n", "if", "eq_idx", ">", "0", ":", "\n", "                ", "field_name_with_type", "=", "subspec", "[", ":", "eq_idx", "]", "\n", "field_name", ",", "field_type", "=", "self", ".", "_parse_field_name_type", "(", "field_name_with_type", ")", "\n", "field_value_or_range", "=", "subspec", "[", "eq_idx", "+", "1", ":", "]", "\n", "if", "self", ".", "_is_range_spec", "(", "field_value_or_range", ")", ":", "\n", "                    ", "vmin", ",", "vmax", "=", "self", ".", "_get_range_spec", "(", "field_value_or_range", ")", "\n", "predicate", "=", "FieldEntrySelector", ".", "_FieldEntryRangePredicate", "(", "\n", "field_name", ",", "field_type", ",", "vmin", ",", "vmax", "\n", ")", "\n", "", "else", ":", "\n", "                    ", "predicate", "=", "FieldEntrySelector", ".", "_FieldEntryValuePredicate", "(", "\n", "field_name", ",", "field_type", ",", "field_value_or_range", "\n", ")", "\n", "", "predicates", ".", "append", "(", "predicate", ")", "\n", "", "elif", "eq_idx", "==", "0", ":", "\n", "                ", "self", ".", "_parse_error", "(", "f'\"{subspec}\", field name is empty!'", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_parse_error", "(", "f'\"{subspec}\", should have format '", "\"<field>=<value_or_range>!\"", ")", "\n", "", "", "return", "predicates", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.dbhelper.FieldEntrySelector._parse_field_name_type": [[119, 130], ["field_name_with_type.find", "dbhelper.FieldEntrySelector._parse_error"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.dbhelper.FieldEntrySelector._parse_error"], ["", "def", "_parse_field_name_type", "(", "self", ",", "field_name_with_type", ":", "str", ")", "->", "Tuple", "[", "str", ",", "Optional", "[", "str", "]", "]", ":", "\n", "        ", "type_delim_idx", "=", "field_name_with_type", ".", "find", "(", "self", ".", "_TYPE_DELIM", ")", "\n", "if", "type_delim_idx", ">", "0", ":", "\n", "            ", "field_name", "=", "field_name_with_type", "[", ":", "type_delim_idx", "]", "\n", "field_type", "=", "field_name_with_type", "[", "type_delim_idx", "+", "1", ":", "]", "\n", "", "elif", "type_delim_idx", "==", "0", ":", "\n", "            ", "self", ".", "_parse_error", "(", "f'\"{field_name_with_type}\", field name is empty!'", ")", "\n", "", "else", ":", "\n", "            ", "field_name", "=", "field_name_with_type", "\n", "field_type", "=", "None", "\n", "", "return", "field_name", ",", "field_type", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.dbhelper.FieldEntrySelector._is_range_spec": [[131, 134], ["field_value_or_range.find"], "methods", ["None"], ["", "def", "_is_range_spec", "(", "self", ",", "field_value_or_range", ")", ":", "\n", "        ", "delim_idx", "=", "field_value_or_range", ".", "find", "(", "self", ".", "_RANGE_DELIM", ")", "\n", "return", "delim_idx", ">", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.dbhelper.FieldEntrySelector._get_range_spec": [[135, 143], ["dbhelper.FieldEntrySelector._is_range_spec", "field_value_or_range.find", "dbhelper.FieldEntrySelector._parse_error"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.dbhelper.FieldEntrySelector._is_range_spec", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.dbhelper.FieldEntrySelector._parse_error"], ["", "def", "_get_range_spec", "(", "self", ",", "field_value_or_range", ")", ":", "\n", "        ", "if", "self", ".", "_is_range_spec", "(", "field_value_or_range", ")", ":", "\n", "            ", "delim_idx", "=", "field_value_or_range", ".", "find", "(", "self", ".", "_RANGE_DELIM", ")", "\n", "vmin", "=", "field_value_or_range", "[", ":", "delim_idx", "]", "\n", "vmax", "=", "field_value_or_range", "[", "delim_idx", "+", "1", ":", "]", "\n", "return", "vmin", ",", "vmax", "\n", "", "else", ":", "\n", "            ", "self", ".", "_parse_error", "(", "'\"field_value_or_range\", range of values expected!'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.dbhelper.FieldEntrySelector._parse_error": [[144, 146], ["ValueError"], "methods", ["None"], ["", "", "def", "_parse_error", "(", "self", ",", "msg", ")", ":", "\n", "        ", "raise", "ValueError", "(", "f\"{self._ERROR_PREFIX}: {msg}\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.verbosity_to_level": [[5, 14], ["None"], "function", ["None"], ["import", "os", "\n", "import", "sys", "\n", "import", "time", "\n", "from", "collections", "import", "Counter", "\n", "from", "fvcore", ".", "common", ".", "file_io", "import", "PathManager", "\n", "from", "tabulate", "import", "tabulate", "\n", "from", "termcolor", "import", "colored", "\n", "\n", "\n", "class", "_ColorfulFormatter", "(", "logging", ".", "Formatter", ")", ":", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.transform.load_for_dataset": [[9, 13], ["fvcore.common.file_io.PathManager.get_local_path", "densepose.DensePoseTransformData.load", "detectron2.data.MetadataCatalog.get"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["def", "load_for_dataset", "(", "dataset_name", ")", ":", "\n", "    ", "path", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", ".", "densepose_transform_src", "\n", "densepose_transform_data_fpath", "=", "PathManager", ".", "get_local_path", "(", "path", ")", "\n", "return", "DensePoseTransformData", ".", "load", "(", "densepose_transform_data_fpath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.transform.load_from_cfg": [[15, 17], ["transform.load_for_dataset"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.transform.load_for_dataset"], ["", "def", "load_from_cfg", "(", "cfg", ")", ":", "\n", "    ", "return", "load_for_dataset", "(", "cfg", ".", "DATASETS", ".", "TEST", "[", "0", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.gather.gather_tensors": [[7, 37], ["torch.get_world_size", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.all_gather", "max", "numpy.zeros", "input_array.reshape", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.all_gather", "torch.Tensor().cuda", "torch.Tensor().cuda", "x.cpu().numpy", "int", "list", "torch.Tensor().cuda", "torch.Tensor().cuda", "x.cpu().numpy", "x[].reshape", "torch.Tensor", "torch.Tensor", "range", "x.prod", "map", "range", "torch.Tensor", "torch.Tensor", "enumerate", "numpy.array", "torch.Tensor", "torch.Tensor", "x.cpu", "torch.Tensor", "torch.Tensor", "x.cpu", "numpy.array"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda"], ["def", "gather_tensors", "(", "input_array", ")", ":", "\n", "    ", "world_size", "=", "dist", ".", "get_world_size", "(", ")", "\n", "## gather shapes first", "\n", "myshape", "=", "input_array", ".", "shape", "\n", "mycount", "=", "input_array", ".", "size", "\n", "shape_tensor", "=", "torch", ".", "Tensor", "(", "np", ".", "array", "(", "myshape", ")", ")", ".", "cuda", "(", ")", "\n", "all_shape", "=", "[", "\n", "torch", ".", "Tensor", "(", "np", ".", "array", "(", "myshape", ")", ")", ".", "cuda", "(", ")", "for", "i", "in", "range", "(", "world_size", ")", "\n", "]", "\n", "dist", ".", "all_gather", "(", "all_shape", ",", "shape_tensor", ")", "\n", "## compute largest shapes", "\n", "all_shape", "=", "[", "x", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "for", "x", "in", "all_shape", "]", "\n", "all_count", "=", "[", "int", "(", "x", ".", "prod", "(", ")", ")", "for", "x", "in", "all_shape", "]", "\n", "all_shape", "=", "[", "list", "(", "map", "(", "int", ",", "x", ")", ")", "for", "x", "in", "all_shape", "]", "\n", "max_count", "=", "max", "(", "all_count", ")", "\n", "## padding tensors and gather them", "\n", "output_tensors", "=", "[", "\n", "torch", ".", "Tensor", "(", "max_count", ")", ".", "cuda", "(", ")", "for", "i", "in", "range", "(", "world_size", ")", "\n", "]", "\n", "padded_input_array", "=", "np", ".", "zeros", "(", "max_count", ")", "\n", "padded_input_array", "[", ":", "mycount", "]", "=", "input_array", ".", "reshape", "(", "-", "1", ")", "\n", "input_tensor", "=", "torch", ".", "Tensor", "(", "padded_input_array", ")", ".", "cuda", "(", ")", "\n", "dist", ".", "all_gather", "(", "output_tensors", ",", "input_tensor", ")", "\n", "## unpadding gathered tensors", "\n", "padded_output", "=", "[", "x", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "for", "x", "in", "output_tensors", "]", "\n", "output", "=", "[", "\n", "x", "[", ":", "all_count", "[", "i", "]", "]", ".", "reshape", "(", "all_shape", "[", "i", "]", ")", "\n", "for", "i", ",", "x", "in", "enumerate", "(", "padded_output", ")", "\n", "]", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.gather.gather_tensors_batch": [[39, 70], ["torch.get_rank", "range", "gather.gather_tensors", "all_features.append", "numpy.concatenate", "range", "numpy.concatenate", "min", "len", "range", "range", "len", "range"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.gather.gather_tensors"], ["", "def", "gather_tensors_batch", "(", "input_array", ",", "part_size", "=", "100", ",", "ret_rank", "=", "-", "1", ")", ":", "\n", "# batch-wize gathering to avoid CUDA out of memory", "\n", "    ", "rank", "=", "dist", ".", "get_rank", "(", ")", "\n", "all_features", "=", "[", "]", "\n", "part_num", "=", "input_array", ".", "shape", "[", "0", "]", "//", "part_size", "+", "1", "if", "input_array", ".", "shape", "[", "\n", "0", "]", "%", "part_size", "!=", "0", "else", "input_array", ".", "shape", "[", "0", "]", "//", "part_size", "\n", "for", "i", "in", "range", "(", "part_num", ")", ":", "\n", "        ", "part_feat", "=", "input_array", "[", "i", "*", "\n", "part_size", ":", "min", "(", "(", "i", "+", "1", ")", "*", "\n", "part_size", ",", "input_array", ".", "shape", "[", "0", "]", ")", ",", "\n", "...", "]", "\n", "assert", "part_feat", ".", "shape", "[", "\n", "0", "]", ">", "0", ",", "\"rank: {}, length of part features should > 0\"", ".", "format", "(", "rank", ")", "\n", "#print(\"rank: {}, gather part: {}/{}, length: {}\".format(rank, i, part_num, len(part_feat)))", "\n", "gather_part_feat", "=", "gather_tensors", "(", "part_feat", ")", "\n", "all_features", ".", "append", "(", "gather_part_feat", ")", "\n", "", "if", "ret_rank", "==", "-", "1", ":", "\n", "        ", "all_features", "=", "[", "\n", "np", ".", "concatenate", "(", "[", "all_features", "[", "i", "]", "[", "j", "]", "for", "i", "in", "range", "(", "part_num", ")", "]", ",", "\n", "axis", "=", "0", ")", "for", "j", "in", "range", "(", "len", "(", "all_features", "[", "0", "]", ")", ")", "\n", "]", "\n", "return", "all_features", "\n", "", "else", ":", "\n", "        ", "if", "rank", "==", "ret_rank", ":", "\n", "            ", "all_features", "=", "[", "\n", "np", ".", "concatenate", "(", "[", "all_features", "[", "i", "]", "[", "j", "]", "for", "i", "in", "range", "(", "part_num", ")", "]", ",", "\n", "axis", "=", "0", ")", "for", "j", "in", "range", "(", "len", "(", "all_features", "[", "0", "]", ")", ")", "\n", "]", "\n", "return", "all_features", "\n", "", "else", ":", "\n", "            ", "return", "None", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.config_tools.traverse_replace": [[3, 13], ["isinstance", "d.items", "isinstance", "config_tools.traverse_replace", "config_tools.traverse_replace"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.config_tools.traverse_replace", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.config_tools.traverse_replace"], ["def", "traverse_replace", "(", "d", ",", "key", ",", "value", ")", ":", "\n", "    ", "if", "isinstance", "(", "d", ",", "(", "dict", ",", "Config", ")", ")", ":", "\n", "        ", "for", "k", ",", "v", "in", "d", ".", "items", "(", ")", ":", "\n", "            ", "if", "k", "==", "key", ":", "\n", "                ", "d", "[", "k", "]", "=", "value", "\n", "", "else", ":", "\n", "                ", "traverse_replace", "(", "v", ",", "key", ",", "value", ")", "\n", "", "", "", "elif", "isinstance", "(", "d", ",", "(", "list", ",", "tuple", ",", "set", ")", ")", ":", "\n", "        ", "for", "v", "in", "d", ":", "\n", "            ", "traverse_replace", "(", "v", ",", "key", ",", "value", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect.nondist_forward_collect": [[9, 37], ["mmcv.ProgressBar", "enumerate", "results[].keys", "len", "results.append", "mmcv.ProgressBar.update", "numpy.concatenate", "torch.no_grad", "func", "batch[].numpy"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update"], ["def", "nondist_forward_collect", "(", "func", ",", "data_loader", ",", "length", ")", ":", "\n", "    ", "\"\"\"Forward and collect network outputs.\n\n    This function performs forward propagation and collects outputs.\n    It can be used to collect results, features, losses, etc.\n\n    Args:\n        func (function): The function to process data. The output must be\n            a dictionary of CPU tensors.\n        length (int): Expected length of output arrays.\n\n    Returns:\n        results_all (dict(np.ndarray)): The concatenated outputs.\n    \"\"\"", "\n", "results", "=", "[", "]", "\n", "prog_bar", "=", "mmcv", ".", "ProgressBar", "(", "len", "(", "data_loader", ")", ")", "\n", "for", "i", ",", "data", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "result", "=", "func", "(", "**", "data", ")", "\n", "", "results", ".", "append", "(", "result", ")", "\n", "prog_bar", ".", "update", "(", ")", "\n", "\n", "", "results_all", "=", "{", "}", "\n", "for", "k", "in", "results", "[", "0", "]", ".", "keys", "(", ")", ":", "\n", "        ", "results_all", "[", "k", "]", "=", "np", ".", "concatenate", "(", "\n", "[", "batch", "[", "k", "]", ".", "numpy", "(", ")", "for", "batch", "in", "results", "]", ",", "axis", "=", "0", ")", "\n", "assert", "results_all", "[", "k", "]", ".", "shape", "[", "0", "]", "==", "length", "\n", "", "return", "results_all", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect.dist_forward_collect": [[39, 84], ["enumerate", "results[].keys", "mmcv.ProgressBar", "results.append", "numpy.concatenate", "len", "torch.no_grad", "func", "mmcv.ProgressBar.update", "gather.gather_tensors_batch", "gather.gather_tensors_batch", "batch[].numpy", "numpy.concatenate", "numpy.concatenate"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.gather.gather_tensors_batch", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.gather.gather_tensors_batch"], ["", "def", "dist_forward_collect", "(", "func", ",", "data_loader", ",", "rank", ",", "length", ",", "ret_rank", "=", "-", "1", ")", ":", "\n", "    ", "\"\"\"Forward and collect network outputs in a distributed manner.\n\n    This function performs forward propagation and collects outputs.\n    It can be used to collect results, features, losses, etc.\n\n    Args:\n        func (function): The function to process data. The output must be\n            a dictionary of CPU tensors.\n        rank (int): This process id.\n        length (int): Expected length of output arrays.\n        ret_rank (int): The process that returns.\n            Other processes will return None.\n\n    Returns:\n        results_all (dict(np.ndarray)): The concatenated outputs.\n    \"\"\"", "\n", "results", "=", "[", "]", "\n", "if", "rank", "==", "0", ":", "\n", "        ", "prog_bar", "=", "mmcv", ".", "ProgressBar", "(", "len", "(", "data_loader", ")", ")", "\n", "", "for", "idx", ",", "data", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "result", "=", "func", "(", "**", "data", ")", "# dict{key: tensor}", "\n", "", "results", ".", "append", "(", "result", ")", "\n", "\n", "if", "rank", "==", "0", ":", "\n", "            ", "prog_bar", ".", "update", "(", ")", "\n", "\n", "", "", "results_all", "=", "{", "}", "\n", "for", "k", "in", "results", "[", "0", "]", ".", "keys", "(", ")", ":", "\n", "        ", "results_cat", "=", "np", ".", "concatenate", "(", "[", "batch", "[", "k", "]", ".", "numpy", "(", ")", "for", "batch", "in", "results", "]", ",", "\n", "axis", "=", "0", ")", "\n", "if", "ret_rank", "==", "-", "1", ":", "\n", "            ", "results_gathered", "=", "gather_tensors_batch", "(", "results_cat", ",", "part_size", "=", "20", ")", "\n", "results_strip", "=", "np", ".", "concatenate", "(", "results_gathered", ",", "axis", "=", "0", ")", "[", ":", "length", "]", "\n", "", "else", ":", "\n", "            ", "results_gathered", "=", "gather_tensors_batch", "(", "\n", "results_cat", ",", "part_size", "=", "20", ",", "ret_rank", "=", "ret_rank", ")", "\n", "if", "rank", "==", "ret_rank", ":", "\n", "                ", "results_strip", "=", "np", ".", "concatenate", "(", "\n", "results_gathered", ",", "axis", "=", "0", ")", "[", ":", "length", "]", "\n", "", "else", ":", "\n", "                ", "results_strip", "=", "None", "\n", "", "", "results_all", "[", "k", "]", "=", "results_strip", "\n", "", "return", "results_all", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.get_model_complexity_info": [[37, 67], ["flops_counter.add_flops_counting_methods", "add_flops_counting_methods.eval().start_flops_count", "add_flops_counting_methods.compute_average_flops_cost", "flops_counter.get_model_parameters_number", "add_flops_counting_methods.stop_flops_count", "type", "len", "input_constructor", "add_flops_counting_methods.", "torch.ones().new_empty", "torch.ones().new_empty", "add_flops_counting_methods.", "flops_counter.print_model_with_flops", "add_flops_counting_methods.eval", "flops_counter.flops_to_string", "flops_counter.params_to_string", "torch.ones", "torch.ones", "next", "next", "add_flops_counting_methods.parameters", "add_flops_counting_methods.parameters"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.add_flops_counting_methods", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.start_flops_count", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.compute_average_flops_cost", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.get_model_parameters_number", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.stop_flops_count", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.print_model_with_flops", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.flops_to_string", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.params_to_string"], ["def", "get_model_complexity_info", "(", "model", ",", "\n", "input_res", ",", "\n", "print_per_layer_stat", "=", "True", ",", "\n", "as_strings", "=", "True", ",", "\n", "input_constructor", "=", "None", ",", "\n", "ost", "=", "sys", ".", "stdout", ")", ":", "\n", "    ", "assert", "type", "(", "input_res", ")", "is", "tuple", "\n", "assert", "len", "(", "input_res", ")", ">=", "2", "\n", "flops_model", "=", "add_flops_counting_methods", "(", "model", ")", "\n", "flops_model", ".", "eval", "(", ")", ".", "start_flops_count", "(", ")", "\n", "if", "input_constructor", ":", "\n", "        ", "input", "=", "input_constructor", "(", "input_res", ")", "\n", "_", "=", "flops_model", "(", "**", "input", ")", "\n", "", "else", ":", "\n", "        ", "batch", "=", "torch", ".", "ones", "(", "(", ")", ")", ".", "new_empty", "(", "\n", "(", "1", ",", "*", "input_res", ")", ",", "\n", "dtype", "=", "next", "(", "flops_model", ".", "parameters", "(", ")", ")", ".", "dtype", ",", "\n", "device", "=", "next", "(", "flops_model", ".", "parameters", "(", ")", ")", ".", "device", ")", "\n", "flops_model", "(", "batch", ")", "\n", "\n", "", "if", "print_per_layer_stat", ":", "\n", "        ", "print_model_with_flops", "(", "flops_model", ",", "ost", "=", "ost", ")", "\n", "", "flops_count", "=", "flops_model", ".", "compute_average_flops_cost", "(", ")", "\n", "params_count", "=", "get_model_parameters_number", "(", "flops_model", ")", "\n", "flops_model", ".", "stop_flops_count", "(", ")", "\n", "\n", "if", "as_strings", ":", "\n", "        ", "return", "flops_to_string", "(", "flops_count", ")", ",", "params_to_string", "(", "params_count", ")", "\n", "\n", "", "return", "flops_count", ",", "params_count", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.flops_to_string": [[69, 88], ["str", "round", "str", "str", "round", "str", "str", "round", "str", "str", "round", "round", "str", "round"], "function", ["None"], ["", "def", "flops_to_string", "(", "flops", ",", "units", "=", "'GMac'", ",", "precision", "=", "2", ")", ":", "\n", "    ", "if", "units", "is", "None", ":", "\n", "        ", "if", "flops", "//", "10", "**", "9", ">", "0", ":", "\n", "            ", "return", "str", "(", "round", "(", "flops", "/", "10.", "**", "9", ",", "precision", ")", ")", "+", "' GMac'", "\n", "", "elif", "flops", "//", "10", "**", "6", ">", "0", ":", "\n", "            ", "return", "str", "(", "round", "(", "flops", "/", "10.", "**", "6", ",", "precision", ")", ")", "+", "' MMac'", "\n", "", "elif", "flops", "//", "10", "**", "3", ">", "0", ":", "\n", "            ", "return", "str", "(", "round", "(", "flops", "/", "10.", "**", "3", ",", "precision", ")", ")", "+", "' KMac'", "\n", "", "else", ":", "\n", "            ", "return", "str", "(", "flops", ")", "+", "' Mac'", "\n", "", "", "else", ":", "\n", "        ", "if", "units", "==", "'GMac'", ":", "\n", "            ", "return", "str", "(", "round", "(", "flops", "/", "10.", "**", "9", ",", "precision", ")", ")", "+", "' '", "+", "units", "\n", "", "elif", "units", "==", "'MMac'", ":", "\n", "            ", "return", "str", "(", "round", "(", "flops", "/", "10.", "**", "6", ",", "precision", ")", ")", "+", "' '", "+", "units", "\n", "", "elif", "units", "==", "'KMac'", ":", "\n", "            ", "return", "str", "(", "round", "(", "flops", "/", "10.", "**", "3", ",", "precision", ")", ")", "+", "' '", "+", "units", "\n", "", "else", ":", "\n", "            ", "return", "str", "(", "flops", ")", "+", "' Mac'", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.params_to_string": [[90, 109], ["str", "str", "round", "str", "round"], "function", ["None"], ["", "", "", "def", "params_to_string", "(", "params_num", ")", ":", "\n", "    ", "\"\"\"converting number to string\n\n    :param float params_num: number\n    :returns str: number\n\n    >>> params_to_string(1e9)\n    '1000.0 M'\n    >>> params_to_string(2e5)\n    '200.0 k'\n    >>> params_to_string(3e-9)\n    '3e-09'\n    \"\"\"", "\n", "if", "params_num", "//", "10", "**", "6", ">", "0", ":", "\n", "        ", "return", "str", "(", "round", "(", "params_num", "/", "10", "**", "6", ",", "2", ")", ")", "+", "' M'", "\n", "", "elif", "params_num", "//", "10", "**", "3", ":", "\n", "        ", "return", "str", "(", "round", "(", "params_num", "/", "10", "**", "3", ",", "2", ")", ")", "+", "' k'", "\n", "", "else", ":", "\n", "        ", "return", "str", "(", "params_num", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.print_model_with_flops": [[111, 150], ["model.compute_average_flops_cost", "model.apply", "print", "model.apply", "flops_counter.is_supported_instance", "flops_counter..accumulate_flops", "accumulate_flops.__get__", "flops_repr.__get__", "hasattr", "hasattr", "flops_counter..children", "m.accumulate_flops", "flops_counter.flops_to_string", "flops_counter..original_extra_repr"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.compute_average_flops_cost", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.is_supported_instance", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.flops_to_string"], ["", "", "def", "print_model_with_flops", "(", "model", ",", "units", "=", "'GMac'", ",", "precision", "=", "3", ",", "ost", "=", "sys", ".", "stdout", ")", ":", "\n", "    ", "total_flops", "=", "model", ".", "compute_average_flops_cost", "(", ")", "\n", "\n", "def", "accumulate_flops", "(", "self", ")", ":", "\n", "        ", "if", "is_supported_instance", "(", "self", ")", ":", "\n", "            ", "return", "self", ".", "__flops__", "/", "model", ".", "__batch_counter__", "\n", "", "else", ":", "\n", "            ", "sum", "=", "0", "\n", "for", "m", "in", "self", ".", "children", "(", ")", ":", "\n", "                ", "sum", "+=", "m", ".", "accumulate_flops", "(", ")", "\n", "", "return", "sum", "\n", "\n", "", "", "def", "flops_repr", "(", "self", ")", ":", "\n", "        ", "accumulated_flops_cost", "=", "self", ".", "accumulate_flops", "(", ")", "\n", "return", "', '", ".", "join", "(", "[", "\n", "flops_to_string", "(", "\n", "accumulated_flops_cost", ",", "units", "=", "units", ",", "precision", "=", "precision", ")", ",", "\n", "'{:.3%} MACs'", ".", "format", "(", "accumulated_flops_cost", "/", "total_flops", ")", ",", "\n", "self", ".", "original_extra_repr", "(", ")", "\n", "]", ")", "\n", "\n", "", "def", "add_extra_repr", "(", "m", ")", ":", "\n", "        ", "m", ".", "accumulate_flops", "=", "accumulate_flops", ".", "__get__", "(", "m", ")", "\n", "flops_extra_repr", "=", "flops_repr", ".", "__get__", "(", "m", ")", "\n", "if", "m", ".", "extra_repr", "!=", "flops_extra_repr", ":", "\n", "            ", "m", ".", "original_extra_repr", "=", "m", ".", "extra_repr", "\n", "m", ".", "extra_repr", "=", "flops_extra_repr", "\n", "assert", "m", ".", "extra_repr", "!=", "m", ".", "original_extra_repr", "\n", "\n", "", "", "def", "del_extra_repr", "(", "m", ")", ":", "\n", "        ", "if", "hasattr", "(", "m", ",", "'original_extra_repr'", ")", ":", "\n", "            ", "m", ".", "extra_repr", "=", "m", ".", "original_extra_repr", "\n", "del", "m", ".", "original_extra_repr", "\n", "", "if", "hasattr", "(", "m", ",", "'accumulate_flops'", ")", ":", "\n", "            ", "del", "m", ".", "accumulate_flops", "\n", "\n", "", "", "model", ".", "apply", "(", "add_extra_repr", ")", "\n", "print", "(", "model", ",", "file", "=", "ost", ")", "\n", "model", ".", "apply", "(", "del_extra_repr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.get_model_parameters_number": [[152, 155], ["sum", "p.numel", "model.parameters"], "function", ["None"], ["", "def", "get_model_parameters_number", "(", "model", ")", ":", "\n", "    ", "params_num", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", ")", "\n", "return", "params_num", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.add_flops_counting_methods": [[157, 175], ["start_flops_count.__get__", "stop_flops_count.__get__", "reset_flops_count.__get__", "compute_average_flops_cost.__get__", "net_main_module.reset_flops_count", "net_main_module.apply"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.reset_flops_count"], ["", "def", "add_flops_counting_methods", "(", "net_main_module", ")", ":", "\n", "# adding additional methods to the existing module object,", "\n", "# this is done this way so that each function has access to self object", "\n", "    ", "net_main_module", ".", "start_flops_count", "=", "start_flops_count", ".", "__get__", "(", "\n", "net_main_module", ")", "\n", "net_main_module", ".", "stop_flops_count", "=", "stop_flops_count", ".", "__get__", "(", "\n", "net_main_module", ")", "\n", "net_main_module", ".", "reset_flops_count", "=", "reset_flops_count", ".", "__get__", "(", "\n", "net_main_module", ")", "\n", "net_main_module", ".", "compute_average_flops_cost", "=", "compute_average_flops_cost", ".", "__get__", "(", "net_main_module", ")", "\n", "\n", "net_main_module", ".", "reset_flops_count", "(", ")", "\n", "\n", "# Adding variables necessary for masked flops computation", "\n", "net_main_module", ".", "apply", "(", "add_flops_mask_variable_or_reset", ")", "\n", "\n", "return", "net_main_module", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.compute_average_flops_cost": [[177, 191], ["flops_counter..modules", "flops_counter.is_supported_instance"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.is_supported_instance"], ["", "def", "compute_average_flops_cost", "(", "self", ")", ":", "\n", "    ", "\"\"\"\n    A method that will be available after add_flops_counting_methods() is\n    called on a desired net object.\n    Returns current mean flops consumption per image.\n    \"\"\"", "\n", "\n", "batches_count", "=", "self", ".", "__batch_counter__", "\n", "flops_sum", "=", "0", "\n", "for", "module", "in", "self", ".", "modules", "(", ")", ":", "\n", "        ", "if", "is_supported_instance", "(", "module", ")", ":", "\n", "            ", "flops_sum", "+=", "module", ".", "__flops__", "\n", "\n", "", "", "return", "flops_sum", "/", "batches_count", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.start_flops_count": [[193, 202], ["flops_counter.add_batch_counter_hook_function", "flops_counter..apply"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.add_batch_counter_hook_function"], ["", "def", "start_flops_count", "(", "self", ")", ":", "\n", "    ", "\"\"\"\n    A method that will be available after add_flops_counting_methods() is\n    called on a desired net object.\n    Activates the computation of mean flops consumption per image.\n    Call it before you run the network.\n    \"\"\"", "\n", "add_batch_counter_hook_function", "(", "self", ")", "\n", "self", ".", "apply", "(", "add_flops_counter_hook_function", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.stop_flops_count": [[204, 213], ["flops_counter.remove_batch_counter_hook_function", "flops_counter..apply"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.remove_batch_counter_hook_function"], ["", "def", "stop_flops_count", "(", "self", ")", ":", "\n", "    ", "\"\"\"\n    A method that will be available after add_flops_counting_methods() is\n    called on a desired net object.\n    Stops computing the mean flops consumption per image.\n    Call whenever you want to pause the computation.\n    \"\"\"", "\n", "remove_batch_counter_hook_function", "(", "self", ")", "\n", "self", ".", "apply", "(", "remove_flops_counter_hook_function", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.reset_flops_count": [[215, 223], ["flops_counter.add_batch_counter_variables_or_reset", "flops_counter..apply"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.add_batch_counter_variables_or_reset"], ["", "def", "reset_flops_count", "(", "self", ")", ":", "\n", "    ", "\"\"\"\n    A method that will be available after add_flops_counting_methods() is\n    called on a desired net object.\n    Resets statistics computed so far.\n    \"\"\"", "\n", "add_batch_counter_variables_or_reset", "(", "self", ")", "\n", "self", ".", "apply", "(", "add_flops_counter_variable_or_reset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.add_flops_mask": [[225, 232], ["module.apply", "isinstance"], "function", ["None"], ["", "def", "add_flops_mask", "(", "module", ",", "mask", ")", ":", "\n", "\n", "    ", "def", "add_flops_mask_func", "(", "module", ")", ":", "\n", "        ", "if", "isinstance", "(", "module", ",", "torch", ".", "nn", ".", "Conv2d", ")", ":", "\n", "            ", "module", ".", "__mask__", "=", "mask", "\n", "\n", "", "", "module", ".", "apply", "(", "add_flops_mask_func", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.remove_flops_mask": [[234, 236], ["module.apply"], "function", ["None"], ["", "def", "remove_flops_mask", "(", "module", ")", ":", "\n", "    ", "module", ".", "apply", "(", "add_flops_mask_variable_or_reset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.is_supported_instance": [[238, 243], ["issubclass", "type"], "function", ["None"], ["", "def", "is_supported_instance", "(", "module", ")", ":", "\n", "    ", "for", "mod", "in", "hook_mapping", ":", "\n", "        ", "if", "issubclass", "(", "type", "(", "module", ")", ",", "mod", ")", ":", "\n", "            ", "return", "True", "\n", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.empty_flops_counter_hook": [[245, 247], ["None"], "function", ["None"], ["", "def", "empty_flops_counter_hook", "(", "module", ",", "input", ",", "output", ")", ":", "\n", "    ", "module", ".", "__flops__", "+=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.upsample_flops_counter_hook": [[249, 256], ["int"], "function", ["None"], ["", "def", "upsample_flops_counter_hook", "(", "module", ",", "input", ",", "output", ")", ":", "\n", "    ", "output_size", "=", "output", "[", "0", "]", "\n", "batch_size", "=", "output_size", ".", "shape", "[", "0", "]", "\n", "output_elements_count", "=", "batch_size", "\n", "for", "val", "in", "output_size", ".", "shape", "[", "1", ":", "]", ":", "\n", "        ", "output_elements_count", "*=", "val", "\n", "", "module", ".", "__flops__", "+=", "int", "(", "output_elements_count", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.relu_flops_counter_hook": [[258, 261], ["output.numel", "int"], "function", ["None"], ["", "def", "relu_flops_counter_hook", "(", "module", ",", "input", ",", "output", ")", ":", "\n", "    ", "active_elements_count", "=", "output", ".", "numel", "(", ")", "\n", "module", ".", "__flops__", "+=", "int", "(", "active_elements_count", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.linear_flops_counter_hook": [[263, 267], ["int"], "function", ["None"], ["", "def", "linear_flops_counter_hook", "(", "module", ",", "input", ",", "output", ")", ":", "\n", "    ", "input", "=", "input", "[", "0", "]", "\n", "batch_size", "=", "input", ".", "shape", "[", "0", "]", "\n", "module", ".", "__flops__", "+=", "int", "(", "batch_size", "*", "input", ".", "shape", "[", "1", "]", "*", "output", ".", "shape", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.pool_flops_counter_hook": [[269, 272], ["int", "numpy.prod"], "function", ["None"], ["", "def", "pool_flops_counter_hook", "(", "module", ",", "input", ",", "output", ")", ":", "\n", "    ", "input", "=", "input", "[", "0", "]", "\n", "module", ".", "__flops__", "+=", "int", "(", "np", ".", "prod", "(", "input", ".", "shape", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.bn_flops_counter_hook": [[274, 281], ["numpy.prod", "int"], "function", ["None"], ["", "def", "bn_flops_counter_hook", "(", "module", ",", "input", ",", "output", ")", ":", "\n", "    ", "input", "=", "input", "[", "0", "]", "\n", "\n", "batch_flops", "=", "np", ".", "prod", "(", "input", ".", "shape", ")", "\n", "if", "module", ".", "affine", ":", "\n", "        ", "batch_flops", "*=", "2", "\n", "", "module", ".", "__flops__", "+=", "int", "(", "batch_flops", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.gn_flops_counter_hook": [[283, 292], ["numpy.prod", "int"], "function", ["None"], ["", "def", "gn_flops_counter_hook", "(", "module", ",", "input", ",", "output", ")", ":", "\n", "    ", "elems", "=", "np", ".", "prod", "(", "input", "[", "0", "]", ".", "shape", ")", "\n", "# there is no precise FLOPs estimation of computing mean and variance,", "\n", "# and we just set it 2 * elems: half muladds for computing", "\n", "# means and half for computing vars", "\n", "batch_flops", "=", "3", "*", "elems", "\n", "if", "module", ".", "affine", ":", "\n", "        ", "batch_flops", "+=", "elems", "\n", "", "module", ".", "__flops__", "+=", "int", "(", "batch_flops", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.deconv_flops_counter_hook": [[294, 319], ["int"], "function", ["None"], ["", "def", "deconv_flops_counter_hook", "(", "conv_module", ",", "input", ",", "output", ")", ":", "\n", "# Can have multiple inputs, getting the first one", "\n", "    ", "input", "=", "input", "[", "0", "]", "\n", "\n", "batch_size", "=", "input", ".", "shape", "[", "0", "]", "\n", "input_height", ",", "input_width", "=", "input", ".", "shape", "[", "2", ":", "]", "\n", "\n", "kernel_height", ",", "kernel_width", "=", "conv_module", ".", "kernel_size", "\n", "in_channels", "=", "conv_module", ".", "in_channels", "\n", "out_channels", "=", "conv_module", ".", "out_channels", "\n", "groups", "=", "conv_module", ".", "groups", "\n", "\n", "filters_per_channel", "=", "out_channels", "//", "groups", "\n", "conv_per_position_flops", "=", "(", "\n", "kernel_height", "*", "kernel_width", "*", "in_channels", "*", "filters_per_channel", ")", "\n", "\n", "active_elements_count", "=", "batch_size", "*", "input_height", "*", "input_width", "\n", "overall_conv_flops", "=", "conv_per_position_flops", "*", "active_elements_count", "\n", "bias_flops", "=", "0", "\n", "if", "conv_module", ".", "bias", "is", "not", "None", ":", "\n", "        ", "output_height", ",", "output_width", "=", "output", ".", "shape", "[", "2", ":", "]", "\n", "bias_flops", "=", "out_channels", "*", "batch_size", "*", "output_height", "*", "output_height", "\n", "", "overall_flops", "=", "overall_conv_flops", "+", "bias_flops", "\n", "\n", "conv_module", ".", "__flops__", "+=", "int", "(", "overall_flops", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.conv_flops_counter_hook": [[321, 357], ["list", "list", "int", "numpy.prod", "conv_module.__mask__.expand", "conv_module.__mask__.expand.sum", "numpy.prod"], "function", ["None"], ["", "def", "conv_flops_counter_hook", "(", "conv_module", ",", "input", ",", "output", ")", ":", "\n", "# Can have multiple inputs, getting the first one", "\n", "    ", "input", "=", "input", "[", "0", "]", "\n", "\n", "batch_size", "=", "input", ".", "shape", "[", "0", "]", "\n", "output_dims", "=", "list", "(", "output", ".", "shape", "[", "2", ":", "]", ")", "\n", "\n", "kernel_dims", "=", "list", "(", "conv_module", ".", "kernel_size", ")", "\n", "in_channels", "=", "conv_module", ".", "in_channels", "\n", "out_channels", "=", "conv_module", ".", "out_channels", "\n", "groups", "=", "conv_module", ".", "groups", "\n", "\n", "filters_per_channel", "=", "out_channels", "//", "groups", "\n", "conv_per_position_flops", "=", "np", ".", "prod", "(", "\n", "kernel_dims", ")", "*", "in_channels", "*", "filters_per_channel", "\n", "\n", "active_elements_count", "=", "batch_size", "*", "np", ".", "prod", "(", "output_dims", ")", "\n", "\n", "if", "conv_module", ".", "__mask__", "is", "not", "None", ":", "\n", "# (b, 1, h, w)", "\n", "        ", "output_height", ",", "output_width", "=", "output", ".", "shape", "[", "2", ":", "]", "\n", "flops_mask", "=", "conv_module", ".", "__mask__", ".", "expand", "(", "batch_size", ",", "1", ",", "output_height", ",", "\n", "output_width", ")", "\n", "active_elements_count", "=", "flops_mask", ".", "sum", "(", ")", "\n", "\n", "", "overall_conv_flops", "=", "conv_per_position_flops", "*", "active_elements_count", "\n", "\n", "bias_flops", "=", "0", "\n", "\n", "if", "conv_module", ".", "bias", "is", "not", "None", ":", "\n", "\n", "        ", "bias_flops", "=", "out_channels", "*", "active_elements_count", "\n", "\n", "", "overall_flops", "=", "overall_conv_flops", "+", "bias_flops", "\n", "\n", "conv_module", ".", "__flops__", "+=", "int", "(", "overall_flops", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.batch_counter_hook": [[385, 395], ["len", "len", "print"], "function", ["None"], ["def", "batch_counter_hook", "(", "module", ",", "input", ",", "output", ")", ":", "\n", "    ", "batch_size", "=", "1", "\n", "if", "len", "(", "input", ")", ">", "0", ":", "\n", "# Can have multiple inputs, getting the first one", "\n", "        ", "input", "=", "input", "[", "0", "]", "\n", "batch_size", "=", "len", "(", "input", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "'Warning! No positional inputs found for a module, '", "\n", "'assuming batch size is 1.'", ")", "\n", "", "module", ".", "__batch_counter__", "+=", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.add_batch_counter_variables_or_reset": [[397, 399], ["None"], "function", ["None"], ["", "def", "add_batch_counter_variables_or_reset", "(", "module", ")", ":", "\n", "    ", "module", ".", "__batch_counter__", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.add_batch_counter_hook_function": [[401, 407], ["hasattr", "module.register_forward_hook"], "function", ["None"], ["", "def", "add_batch_counter_hook_function", "(", "module", ")", ":", "\n", "    ", "if", "hasattr", "(", "module", ",", "'__batch_counter_handle__'", ")", ":", "\n", "        ", "return", "\n", "\n", "", "handle", "=", "module", ".", "register_forward_hook", "(", "batch_counter_hook", ")", "\n", "module", ".", "__batch_counter_handle__", "=", "handle", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.remove_batch_counter_hook_function": [[409, 413], ["hasattr", "module.__batch_counter_handle__.remove"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.remove"], ["", "def", "remove_batch_counter_hook_function", "(", "module", ")", ":", "\n", "    ", "if", "hasattr", "(", "module", ",", "'__batch_counter_handle__'", ")", ":", "\n", "        ", "module", ".", "__batch_counter_handle__", ".", "remove", "(", ")", "\n", "del", "module", ".", "__batch_counter_handle__", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.add_flops_counter_variable_or_reset": [[415, 418], ["flops_counter.is_supported_instance"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.is_supported_instance"], ["", "", "def", "add_flops_counter_variable_or_reset", "(", "module", ")", ":", "\n", "    ", "if", "is_supported_instance", "(", "module", ")", ":", "\n", "        ", "module", ".", "__flops__", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.add_flops_counter_hook_function": [[420, 431], ["flops_counter.is_supported_instance", "hasattr", "hook_mapping.items", "issubclass", "type", "module.register_forward_hook"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.is_supported_instance"], ["", "", "def", "add_flops_counter_hook_function", "(", "module", ")", ":", "\n", "    ", "if", "is_supported_instance", "(", "module", ")", ":", "\n", "        ", "if", "hasattr", "(", "module", ",", "'__flops_handle__'", ")", ":", "\n", "            ", "return", "\n", "\n", "", "for", "mod_type", ",", "counter_hook", "in", "hook_mapping", ".", "items", "(", ")", ":", "\n", "            ", "if", "issubclass", "(", "type", "(", "module", ")", ",", "mod_type", ")", ":", "\n", "                ", "handle", "=", "module", ".", "register_forward_hook", "(", "counter_hook", ")", "\n", "break", "\n", "\n", "", "", "module", ".", "__flops_handle__", "=", "handle", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.remove_flops_counter_hook_function": [[433, 438], ["flops_counter.is_supported_instance", "hasattr", "module.__flops_handle__.remove"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.is_supported_instance", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.remove"], ["", "", "def", "remove_flops_counter_hook_function", "(", "module", ")", ":", "\n", "    ", "if", "is_supported_instance", "(", "module", ")", ":", "\n", "        ", "if", "hasattr", "(", "module", ",", "'__flops_handle__'", ")", ":", "\n", "            ", "module", ".", "__flops_handle__", ".", "remove", "(", ")", "\n", "del", "module", ".", "__flops_handle__", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.add_flops_mask_variable_or_reset": [[442, 445], ["flops_counter.is_supported_instance"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.flops_counter.is_supported_instance"], ["", "", "", "def", "add_flops_mask_variable_or_reset", "(", "module", ")", ":", "\n", "    ", "if", "is_supported_instance", "(", "module", ")", ":", "\n", "        ", "module", ".", "__mask__", "=", "None", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.get_root_logger": [[6, 41], ["logging.getLogger", "logging.getLogger.hasHandlers", "logging.basicConfig", "mmcv.runner.get_dist_info", "logging.getLogger.setLevel", "__name__.split", "logging.FileHandler", "logging.FileHandler.setFormatter", "logging.FileHandler.setLevel", "logging.getLogger.addHandler", "logging.Formatter"], "function", ["None"], ["import", "sys", "\n", "import", "time", "\n", "from", "collections", "import", "Counter", "\n", "from", "fvcore", ".", "common", ".", "file_io", "import", "PathManager", "\n", "from", "tabulate", "import", "tabulate", "\n", "from", "termcolor", "import", "colored", "\n", "\n", "\n", "class", "_ColorfulFormatter", "(", "logging", ".", "Formatter", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "_root_name", "=", "kwargs", ".", "pop", "(", "\"root_name\"", ")", "+", "\".\"", "\n", "self", ".", "_abbrev_name", "=", "kwargs", ".", "pop", "(", "\"abbrev_name\"", ",", "\"\"", ")", "\n", "if", "len", "(", "self", ".", "_abbrev_name", ")", ":", "\n", "            ", "self", ".", "_abbrev_name", "=", "self", ".", "_abbrev_name", "+", "\".\"", "\n", "", "super", "(", "_ColorfulFormatter", ",", "self", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "def", "formatMessage", "(", "self", ",", "record", ")", ":", "\n", "        ", "record", ".", "name", "=", "record", ".", "name", ".", "replace", "(", "self", ".", "_root_name", ",", "self", ".", "_abbrev_name", ")", "\n", "log", "=", "super", "(", "_ColorfulFormatter", ",", "self", ")", ".", "formatMessage", "(", "record", ")", "\n", "if", "record", ".", "levelno", "==", "logging", ".", "WARNING", ":", "\n", "            ", "prefix", "=", "colored", "(", "\"WARNING\"", ",", "\"red\"", ",", "attrs", "=", "[", "\"blink\"", "]", ")", "\n", "", "elif", "record", ".", "levelno", "==", "logging", ".", "ERROR", "or", "record", ".", "levelno", "==", "logging", ".", "CRITICAL", ":", "\n", "            ", "prefix", "=", "colored", "(", "\"ERROR\"", ",", "\"red\"", ",", "attrs", "=", "[", "\"blink\"", ",", "\"underline\"", "]", ")", "\n", "", "else", ":", "\n", "            ", "return", "log", "\n", "", "return", "prefix", "+", "\" \"", "+", "log", "\n", "\n", "\n", "", "", "@", "functools", ".", "lru_cache", "(", ")", "# so that calling setup_logger multiple times won't add many handlers", "\n", "def", "setup_logger", "(", "\n", "output", "=", "None", ",", "distributed_rank", "=", "0", ",", "*", ",", "color", "=", "True", ",", "name", "=", "\"detectron2\"", ",", "abbrev_name", "=", "None", "\n", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.print_log": [[43, 67], ["print", "logger.get_root_logger", "get_root_logger.log", "isinstance", "logger.log", "TypeError"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.get_root_logger"], ["\n", "logger", "=", "logging", ".", "getLogger", "(", "name", ")", "\n", "logger", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "logger", ".", "propagate", "=", "False", "\n", "\n", "if", "abbrev_name", "is", "None", ":", "\n", "        ", "abbrev_name", "=", "\"d2\"", "if", "name", "==", "\"detectron2\"", "else", "name", "\n", "\n", "", "plain_formatter", "=", "logging", ".", "Formatter", "(", "\n", "\"[%(asctime)s] %(name)s %(levelname)s: %(message)s\"", ",", "datefmt", "=", "\"%m/%d %H:%M:%S\"", "\n", ")", "\n", "# stdout logging: master only", "\n", "if", "distributed_rank", "==", "0", ":", "\n", "        ", "ch", "=", "logging", ".", "StreamHandler", "(", "stream", "=", "sys", ".", "stdout", ")", "\n", "ch", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.registry.Registry.__init__": [[9, 12], ["dict"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.registry.Registry.__repr__": [[13, 17], ["list", "registry.Registry._module_dict.keys"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.registry.Registry.name": [[18, 21], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.registry.Registry.module_dict": [[22, 25], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.registry.Registry.get": [[26, 28], ["registry.Registry._module_dict.get"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.registry.Registry._register_module": [[29, 43], ["inspect.isclass", "TypeError", "KeyError", "type"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.registry.Registry.register_module": [[44, 49], ["registry.Registry._register_module", "functools.partial"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.registry.Registry._register_module"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.registry.build_from_cfg": [[51, 80], ["cfg.copy", "cfg.copy.pop", "mmcv.is_str", "registry.get.", "isinstance", "isinstance", "registry.get", "inspect.isclass", "default_args.items", "KeyError", "TypeError", "cfg.copy.setdefault", "type"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.misc.tensor2imgs": [[11, 22], ["tensor.size", "numpy.array", "numpy.array", "range", "tensor[].cpu().numpy().transpose", "mmcv.imdenormalize().astype", "imgs.append", "numpy.ascontiguousarray", "tensor[].cpu().numpy", "mmcv.imdenormalize", "tensor[].cpu"], "function", ["None"], ["def", "tensor2imgs", "(", "tensor", ",", "mean", "=", "(", "0", ",", "0", ",", "0", ")", ",", "std", "=", "(", "1", ",", "1", ",", "1", ")", ",", "to_rgb", "=", "True", ")", ":", "\n", "    ", "num_imgs", "=", "tensor", ".", "size", "(", "0", ")", "\n", "mean", "=", "np", ".", "array", "(", "mean", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "std", "=", "np", ".", "array", "(", "std", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "imgs", "=", "[", "]", "\n", "for", "img_id", "in", "range", "(", "num_imgs", ")", ":", "\n", "        ", "img", "=", "tensor", "[", "img_id", ",", "...", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", "1", ",", "2", ",", "0", ")", "\n", "img", "=", "mmcv", ".", "imdenormalize", "(", "\n", "img", ",", "mean", ",", "std", ",", "to_bgr", "=", "to_rgb", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "imgs", ".", "append", "(", "np", ".", "ascontiguousarray", "(", "img", ")", ")", "\n", "", "return", "imgs", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.misc.multi_apply": [[24, 28], ["six.moves.map", "tuple", "functools.partial", "six.moves.map", "six.moves.zip"], "function", ["None"], ["", "def", "multi_apply", "(", "func", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "pfunc", "=", "partial", "(", "func", ",", "**", "kwargs", ")", "if", "kwargs", "else", "func", "\n", "map_results", "=", "map", "(", "pfunc", ",", "*", "args", ")", "\n", "return", "tuple", "(", "map", "(", "list", ",", "zip", "(", "*", "map_results", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.misc.unmap": [[30, 41], ["data.dim", "data.new_full", "data.new_full", "data.size"], "function", ["None"], ["", "def", "unmap", "(", "data", ",", "count", ",", "inds", ",", "fill", "=", "0", ")", ":", "\n", "    ", "\"\"\"Unmap a subset of item (data) back to the original set of items (of\n    size count).\"\"\"", "\n", "if", "data", ".", "dim", "(", ")", "==", "1", ":", "\n", "        ", "ret", "=", "data", ".", "new_full", "(", "(", "count", ",", ")", ",", "fill", ")", "\n", "ret", "[", "inds", "]", "=", "data", "\n", "", "else", ":", "\n", "        ", "new_size", "=", "(", "count", ",", ")", "+", "data", ".", "size", "(", ")", "[", "1", ":", "]", "\n", "ret", "=", "data", ".", "new_full", "(", "new_size", ",", "fill", ")", "\n", "ret", "[", "inds", ",", ":", "]", "=", "data", "\n", "", "return", "ret", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect_env.collect_env": [[14, 60], ["sys.version.replace", "torch.cuda.is_available", "subprocess.check_output", "gcc.decode().strip.decode().strip", "torch.__config__.show", "collections.defaultdict", "range", "collections.defaultdict.items", "os.isdir", "torch.cuda.device_count", "devices[].append", "gcc.decode().strip.decode", "os.join", "subprocess.check_output", "nvcc.decode().strip.decode().strip", "str", "nvcc.decode().strip.decode", "torch.cuda.get_device_name"], "function", ["None"], ["__all__", "=", "[", "\"collect_env_info\"", "]", "\n", "\n", "\n", "def", "collect_torch_env", "(", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "import", "torch", ".", "__config__", "\n", "\n", "return", "torch", ".", "__config__", ".", "show", "(", ")", "\n", "", "except", "ImportError", ":", "\n", "# compatible with older versions of pytorch", "\n", "        ", "from", "torch", ".", "utils", ".", "collect_env", "import", "get_pretty_env_info", "\n", "\n", "return", "get_pretty_env_info", "(", ")", "\n", "\n", "\n", "", "", "def", "get_env_module", "(", ")", ":", "\n", "    ", "var_name", "=", "\"DETECTRON2_ENV_MODULE\"", "\n", "return", "var_name", ",", "os", ".", "environ", ".", "get", "(", "var_name", ",", "\"<not set>\"", ")", "\n", "\n", "\n", "", "def", "detect_compute_compatibility", "(", "CUDA_HOME", ",", "so_file", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "cuobjdump", "=", "os", ".", "path", ".", "join", "(", "CUDA_HOME", ",", "\"bin\"", ",", "\"cuobjdump\"", ")", "\n", "if", "os", ".", "path", ".", "isfile", "(", "cuobjdump", ")", ":", "\n", "            ", "output", "=", "subprocess", ".", "check_output", "(", "\n", "\"'{}' --list-elf '{}'\"", ".", "format", "(", "cuobjdump", ",", "so_file", ")", ",", "shell", "=", "True", "\n", ")", "\n", "output", "=", "output", ".", "decode", "(", "\"utf-8\"", ")", ".", "strip", "(", ")", ".", "split", "(", "\"\\n\"", ")", "\n", "arch", "=", "[", "]", "\n", "for", "line", "in", "output", ":", "\n", "                ", "line", "=", "re", ".", "findall", "(", "r\"\\.sm_([0-9]*)\\.\"", ",", "line", ")", "[", "0", "]", "\n", "arch", ".", "append", "(", "\".\"", ".", "join", "(", "line", ")", ")", "\n", "", "arch", "=", "sorted", "(", "set", "(", "arch", ")", ")", "\n", "return", "\", \"", ".", "join", "(", "arch", ")", "\n", "", "else", ":", "\n", "            ", "return", "so_file", "+", "\"; cannot find cuobjdump\"", "\n", "", "", "except", "Exception", ":", "\n", "# unhandled failure", "\n", "        ", "return", "so_file", "\n", "\n", "\n", "", "", "def", "collect_env_info", "(", ")", ":", "\n", "    ", "has_gpu", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "# true for both CUDA & ROCM", "\n", "torch_version", "=", "torch", ".", "__version__", "\n", "\n", "# NOTE: the use of CUDA_HOME and ROCM_HOME requires the CUDA/ROCM build deps, though in", "\n", "# theory detectron2 should be made runnable with only the corresponding runtimes", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.__init__": [[14, 50], ["len", "torch.zeros", "torch.LongTensor", "enumerate", "probs.sum", "probs.div_", "smaller.pop", "larger.pop", "probs.sum", "smaller.append", "larger.append", "len", "len", "smaller.append", "larger.append"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "probs", ")", ":", "\n", "\n", "        ", "if", "probs", ".", "sum", "(", ")", ">", "1", ":", "\n", "            ", "probs", ".", "div_", "(", "probs", ".", "sum", "(", ")", ")", "\n", "", "K", "=", "len", "(", "probs", ")", "\n", "self", ".", "prob", "=", "torch", ".", "zeros", "(", "K", ")", "\n", "self", ".", "alias", "=", "torch", ".", "LongTensor", "(", "[", "0", "]", "*", "K", ")", "\n", "\n", "# Sort the data into the outcomes with probabilities", "\n", "# that are larger and smaller than 1/K.", "\n", "smaller", "=", "[", "]", "\n", "larger", "=", "[", "]", "\n", "for", "kk", ",", "prob", "in", "enumerate", "(", "probs", ")", ":", "\n", "            ", "self", ".", "prob", "[", "kk", "]", "=", "K", "*", "prob", "\n", "if", "self", ".", "prob", "[", "kk", "]", "<", "1.0", ":", "\n", "                ", "smaller", ".", "append", "(", "kk", ")", "\n", "", "else", ":", "\n", "                ", "larger", ".", "append", "(", "kk", ")", "\n", "\n", "# Loop though and create little binary mixtures that", "\n", "# appropriately allocate the larger outcomes over the", "\n", "# overall uniform mixture.", "\n", "", "", "while", "len", "(", "smaller", ")", ">", "0", "and", "len", "(", "larger", ")", ">", "0", ":", "\n", "            ", "small", "=", "smaller", ".", "pop", "(", ")", "\n", "large", "=", "larger", ".", "pop", "(", ")", "\n", "\n", "self", ".", "alias", "[", "small", "]", "=", "large", "\n", "self", ".", "prob", "[", "large", "]", "=", "(", "self", ".", "prob", "[", "large", "]", "-", "1.0", ")", "+", "self", ".", "prob", "[", "small", "]", "\n", "\n", "if", "self", ".", "prob", "[", "large", "]", "<", "1.0", ":", "\n", "                ", "smaller", ".", "append", "(", "large", ")", "\n", "", "else", ":", "\n", "                ", "larger", ".", "append", "(", "large", ")", "\n", "\n", "", "", "for", "last_one", "in", "smaller", "+", "larger", ":", "\n", "            ", "self", ".", "prob", "[", "last_one", "]", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda": [[51, 54], ["alias_multinomial.AliasMethod.prob.cuda", "alias_multinomial.AliasMethod.alias.cuda"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda"], ["", "", "def", "cuda", "(", "self", ")", ":", "\n", "        ", "self", ".", "prob", "=", "self", ".", "prob", ".", "cuda", "(", ")", "\n", "self", ".", "alias", "=", "self", ".", "alias", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.draw": [[55, 76], ["alias_multinomial.AliasMethod.alias.size", "torch.zeros().random_", "alias_multinomial.AliasMethod.prob.index_select", "alias_multinomial.AliasMethod.alias.index_select", "torch.bernoulli", "torch.zeros().random_.mul", "alias_multinomial.AliasMethod.mul", "torch.bernoulli.long", "torch.zeros"], "methods", ["None"], ["", "def", "draw", "(", "self", ",", "N", ")", ":", "\n", "        ", "\"\"\"Draw N samples from multinomial.\n\n        Args:\n            N (int): Number of samples.\n\n        Returns:\n            Tensor: Samples.\n        \"\"\"", "\n", "K", "=", "self", ".", "alias", ".", "size", "(", "0", ")", "\n", "\n", "kk", "=", "torch", ".", "zeros", "(", "\n", "N", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "self", ".", "prob", ".", "device", ")", ".", "random_", "(", "0", ",", "K", ")", "\n", "prob", "=", "self", ".", "prob", ".", "index_select", "(", "0", ",", "kk", ")", "\n", "alias", "=", "self", ".", "alias", ".", "index_select", "(", "0", ",", "kk", ")", "\n", "# b is whether a random number is greater than q", "\n", "b", "=", "torch", ".", "bernoulli", "(", "prob", ")", "\n", "oq", "=", "kk", ".", "mul", "(", "b", ".", "long", "(", ")", ")", "\n", "oj", "=", "alias", ".", "mul", "(", "(", "1", "-", "b", ")", ".", "long", "(", ")", ")", "\n", "\n", "return", "oq", "+", "oj", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.optimizers.LARS.__init__": [[32, 57], ["dict", "torch.optim.optimizer.Optimizer.__init__", "ValueError", "ValueError", "ValueError", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "\n", "params", ",", "\n", "lr", "=", "required", ",", "\n", "momentum", "=", "0", ",", "\n", "dampening", "=", "0", ",", "\n", "weight_decay", "=", "0", ",", "\n", "eta", "=", "0.001", ",", "\n", "nesterov", "=", "False", ")", ":", "\n", "        ", "if", "lr", "is", "not", "required", "and", "lr", "<", "0.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid learning rate: {}\"", ".", "format", "(", "lr", ")", ")", "\n", "", "if", "momentum", "<", "0.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid momentum value: {}\"", ".", "format", "(", "momentum", ")", ")", "\n", "", "if", "weight_decay", "<", "0.0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Invalid weight_decay value: {}\"", ".", "format", "(", "weight_decay", ")", ")", "\n", "", "if", "eta", "<", "0.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid LARS coefficient value: {}\"", ".", "format", "(", "eta", ")", ")", "\n", "\n", "", "defaults", "=", "dict", "(", "\n", "lr", "=", "lr", ",", "momentum", "=", "momentum", ",", "dampening", "=", "dampening", ",", "\n", "weight_decay", "=", "weight_decay", ",", "nesterov", "=", "nesterov", ",", "eta", "=", "eta", ")", "\n", "if", "nesterov", "and", "(", "momentum", "<=", "0", "or", "dampening", "!=", "0", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Nesterov momentum requires a momentum and zero dampening\"", ")", "\n", "\n", "", "super", "(", "LARS", ",", "self", ")", ".", "__init__", "(", "params", ",", "defaults", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.optimizers.LARS.__setstate__": [[58, 62], ["super().__setstate__", "group.setdefault"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.optimizers.LARS.__setstate__"], ["", "def", "__setstate__", "(", "self", ",", "state", ")", ":", "\n", "        ", "super", "(", "LARS", ",", "self", ")", ".", "__setstate__", "(", "state", ")", "\n", "for", "group", "in", "self", ".", "param_groups", ":", "\n", "            ", "group", ".", "setdefault", "(", "'nesterov'", ",", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.optimizers.LARS.step": [[63, 117], ["torch.no_grad", "group.get", "torch.enable_grad", "closure", "d_p.add.add.add().mul", "p.add_", "torch.norm().item", "torch.norm().item", "d_p.add.add.add", "torch.clone().detach", "torch.clone().detach.mul_().add_", "d_p.add.add.add", "torch.norm", "torch.norm", "torch.clone", "torch.clone().detach.mul_"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "step", "(", "self", ",", "closure", "=", "None", ")", ":", "\n", "        ", "\"\"\"Performs a single optimization step.\n\n        Args:\n            closure (callable, optional): A closure that reevaluates the model\n                and returns the loss.\n        \"\"\"", "\n", "loss", "=", "None", "\n", "if", "closure", "is", "not", "None", ":", "\n", "            ", "with", "torch", ".", "enable_grad", "(", ")", ":", "\n", "                ", "loss", "=", "closure", "(", ")", "\n", "\n", "", "", "for", "group", "in", "self", ".", "param_groups", ":", "\n", "            ", "weight_decay", "=", "group", "[", "'weight_decay'", "]", "\n", "momentum", "=", "group", "[", "'momentum'", "]", "\n", "dampening", "=", "group", "[", "'dampening'", "]", "\n", "eta", "=", "group", "[", "'eta'", "]", "\n", "nesterov", "=", "group", "[", "'nesterov'", "]", "\n", "lr", "=", "group", "[", "'lr'", "]", "\n", "lars_exclude", "=", "group", ".", "get", "(", "'lars_exclude'", ",", "False", ")", "\n", "\n", "for", "p", "in", "group", "[", "'params'", "]", ":", "\n", "                ", "if", "p", ".", "grad", "is", "None", ":", "\n", "                    ", "continue", "\n", "\n", "", "d_p", "=", "p", ".", "grad", "\n", "\n", "if", "lars_exclude", ":", "\n", "                    ", "local_lr", "=", "1.", "\n", "", "else", ":", "\n", "                    ", "weight_norm", "=", "torch", ".", "norm", "(", "p", ")", ".", "item", "(", ")", "\n", "grad_norm", "=", "torch", ".", "norm", "(", "d_p", ")", ".", "item", "(", ")", "\n", "# Compute local learning rate for this layer", "\n", "local_lr", "=", "eta", "*", "weight_norm", "/", "(", "grad_norm", "+", "weight_decay", "*", "weight_norm", ")", "\n", "\n", "", "actual_lr", "=", "local_lr", "*", "lr", "\n", "d_p", "=", "d_p", ".", "add", "(", "p", ",", "alpha", "=", "weight_decay", ")", ".", "mul", "(", "actual_lr", ")", "\n", "if", "momentum", "!=", "0", ":", "\n", "                    ", "param_state", "=", "self", ".", "state", "[", "p", "]", "\n", "if", "'momentum_buffer'", "not", "in", "param_state", ":", "\n", "                        ", "buf", "=", "param_state", "[", "'momentum_buffer'", "]", "=", "torch", ".", "clone", "(", "d_p", ")", ".", "detach", "(", ")", "\n", "", "else", ":", "\n", "                        ", "buf", "=", "param_state", "[", "'momentum_buffer'", "]", "\n", "buf", ".", "mul_", "(", "momentum", ")", ".", "add_", "(", "d_p", ",", "alpha", "=", "1", "-", "dampening", ")", "\n", "", "if", "nesterov", ":", "\n", "                        ", "d_p", "=", "d_p", ".", "add", "(", "buf", ",", "alpha", "=", "momentum", ")", "\n", "", "else", ":", "\n", "                        ", "d_p", "=", "buf", "\n", "", "", "p", ".", "add_", "(", "-", "d_p", ")", "\n", "\n", "", "", "return", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.norm.build_norm_layer": [[12, 56], ["cfg.copy", "cfg.copy.pop", "isinstance", "cfg.copy.pop", "cfg.copy.setdefault", "norm_layer.parameters", "isinstance", "KeyError", "str", "norm_layer", "norm_layer", "norm_layer._specify_ddp_gpu_num"], "function", ["None"], ["def", "build_norm_layer", "(", "cfg", ",", "num_features", ",", "postfix", "=", "''", ")", ":", "\n", "    ", "\"\"\"Build normalization layer.\n\n    Args:\n        cfg (dict): cfg should contain:\n            type (str): identify norm layer type.\n            layer args: args needed to instantiate a norm layer.\n            requires_grad (bool): [optional] whether stop gradient updates\n        num_features (int): number of channels from input.\n        postfix (int, str): appended into norm abbreviation to\n            create named layer.\n\n    Returns:\n        name (str): abbreviation + postfix\n        layer (nn.Module): created norm layer\n    \"\"\"", "\n", "assert", "isinstance", "(", "cfg", ",", "dict", ")", "and", "'type'", "in", "cfg", "\n", "cfg_", "=", "cfg", ".", "copy", "(", ")", "\n", "\n", "layer_type", "=", "cfg_", ".", "pop", "(", "'type'", ")", "\n", "if", "layer_type", "not", "in", "norm_cfg", ":", "\n", "        ", "raise", "KeyError", "(", "'Unrecognized norm type {}'", ".", "format", "(", "layer_type", ")", ")", "\n", "", "else", ":", "\n", "        ", "abbr", ",", "norm_layer", "=", "norm_cfg", "[", "layer_type", "]", "\n", "if", "norm_layer", "is", "None", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "", "assert", "isinstance", "(", "postfix", ",", "(", "int", ",", "str", ")", ")", "\n", "name", "=", "abbr", "+", "str", "(", "postfix", ")", "\n", "\n", "requires_grad", "=", "cfg_", ".", "pop", "(", "'requires_grad'", ",", "True", ")", "\n", "cfg_", ".", "setdefault", "(", "'eps'", ",", "1e-5", ")", "\n", "if", "layer_type", "!=", "'GN'", ":", "\n", "        ", "layer", "=", "norm_layer", "(", "num_features", ",", "**", "cfg_", ")", "\n", "if", "layer_type", "==", "'SyncBN'", ":", "\n", "            ", "layer", ".", "_specify_ddp_gpu_num", "(", "1", ")", "\n", "", "", "else", ":", "\n", "        ", "assert", "'num_groups'", "in", "cfg_", "\n", "layer", "=", "norm_layer", "(", "num_channels", "=", "num_features", ",", "**", "cfg_", ")", "\n", "\n", "", "for", "param", "in", "layer", ".", "parameters", "(", ")", ":", "\n", "        ", "param", ".", "requires_grad", "=", "requires_grad", "\n", "\n", "", "return", "name", ",", "layer", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.scale.Scale.__init__": [[8, 11], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "scale", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "Scale", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "scale", "=", "nn", ".", "Parameter", "(", "torch", ".", "tensor", "(", "scale", ",", "dtype", "=", "torch", ".", "float", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.scale.Scale.forward": [[12, 14], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "*", "self", ".", "scale", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.__init__": [[66, 144], ["torch.Module.__init__", "conv_module.build_conv_layer", "conv_module.ConvModule.init_weights", "isinstance", "isinstance", "isinstance", "set", "set", "warnings.warn", "norm.build_norm_layer", "conv_module.ConvModule.add_module", "len", "order.index", "order.index", "ValueError", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.build_conv_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.norm.build_norm_layer"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "bias", "=", "'auto'", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "activation", "=", "'relu'", ",", "\n", "inplace", "=", "True", ",", "\n", "order", "=", "(", "'conv'", ",", "'norm'", ",", "'act'", ")", ")", ":", "\n", "        ", "super", "(", "ConvModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "conv_cfg", "is", "None", "or", "isinstance", "(", "conv_cfg", ",", "dict", ")", "\n", "assert", "norm_cfg", "is", "None", "or", "isinstance", "(", "norm_cfg", ",", "dict", ")", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "self", ".", "activation", "=", "activation", "\n", "self", ".", "inplace", "=", "inplace", "\n", "self", ".", "order", "=", "order", "\n", "assert", "isinstance", "(", "self", ".", "order", ",", "tuple", ")", "and", "len", "(", "self", ".", "order", ")", "==", "3", "\n", "assert", "set", "(", "order", ")", "==", "set", "(", "[", "'conv'", ",", "'norm'", ",", "'act'", "]", ")", "\n", "\n", "self", ".", "with_norm", "=", "norm_cfg", "is", "not", "None", "\n", "self", ".", "with_activation", "=", "activation", "is", "not", "None", "\n", "# if the conv layer is before a norm layer, bias is unnecessary.", "\n", "if", "bias", "==", "'auto'", ":", "\n", "            ", "bias", "=", "False", "if", "self", ".", "with_norm", "else", "True", "\n", "", "self", ".", "with_bias", "=", "bias", "\n", "\n", "if", "self", ".", "with_norm", "and", "self", ".", "with_bias", ":", "\n", "            ", "warnings", ".", "warn", "(", "'ConvModule has norm and bias at the same time'", ")", "\n", "\n", "# build convolution layer", "\n", "", "self", ".", "conv", "=", "build_conv_layer", "(", "\n", "conv_cfg", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "padding", ",", "\n", "dilation", "=", "dilation", ",", "\n", "groups", "=", "groups", ",", "\n", "bias", "=", "bias", ")", "\n", "# export the attributes of self.conv to a higher level for convenience", "\n", "self", ".", "in_channels", "=", "self", ".", "conv", ".", "in_channels", "\n", "self", ".", "out_channels", "=", "self", ".", "conv", ".", "out_channels", "\n", "self", ".", "kernel_size", "=", "self", ".", "conv", ".", "kernel_size", "\n", "self", ".", "stride", "=", "self", ".", "conv", ".", "stride", "\n", "self", ".", "padding", "=", "self", ".", "conv", ".", "padding", "\n", "self", ".", "dilation", "=", "self", ".", "conv", ".", "dilation", "\n", "self", ".", "transposed", "=", "self", ".", "conv", ".", "transposed", "\n", "self", ".", "output_padding", "=", "self", ".", "conv", ".", "output_padding", "\n", "self", ".", "groups", "=", "self", ".", "conv", ".", "groups", "\n", "\n", "# build normalization layers", "\n", "if", "self", ".", "with_norm", ":", "\n", "# norm layer is after conv layer", "\n", "            ", "if", "order", ".", "index", "(", "'norm'", ")", ">", "order", ".", "index", "(", "'conv'", ")", ":", "\n", "                ", "norm_channels", "=", "out_channels", "\n", "", "else", ":", "\n", "                ", "norm_channels", "=", "in_channels", "\n", "", "self", ".", "norm_name", ",", "norm", "=", "build_norm_layer", "(", "norm_cfg", ",", "norm_channels", ")", "\n", "self", ".", "add_module", "(", "self", ".", "norm_name", ",", "norm", ")", "\n", "\n", "# build activation layer", "\n", "", "if", "self", ".", "with_activation", ":", "\n", "# TODO: introduce `act_cfg` and supports more activation layers", "\n", "            ", "if", "self", ".", "activation", "not", "in", "[", "'relu'", "]", ":", "\n", "                ", "raise", "ValueError", "(", "'{} is currently not supported.'", ".", "format", "(", "\n", "self", ".", "activation", ")", ")", "\n", "", "if", "self", ".", "activation", "==", "'relu'", ":", "\n", "                ", "self", ".", "activate", "=", "nn", ".", "ReLU", "(", "inplace", "=", "inplace", ")", "\n", "\n", "# Use msra init by default", "\n", "", "", "self", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.norm": [[145, 148], ["getattr"], "methods", ["None"], ["", "@", "property", "\n", "def", "norm", "(", "self", ")", ":", "\n", "        ", "return", "getattr", "(", "self", ",", "self", ".", "norm_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.init_weights": [[149, 154], ["mmcv.cnn.kaiming_init", "mmcv.cnn.constant_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "nonlinearity", "=", "'relu'", "if", "self", ".", "activation", "is", "None", "else", "self", ".", "activation", "\n", "kaiming_init", "(", "self", ".", "conv", ",", "mode", "=", "'fan_in'", ",", "nonlinearity", "=", "nonlinearity", ")", "\n", "if", "self", ".", "with_norm", ":", "\n", "            ", "constant_init", "(", "self", ".", "norm", ",", "1", ",", "bias", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.forward": [[155, 164], ["conv_module.ConvModule.conv", "conv_module.ConvModule.norm", "conv_module.ConvModule.activate"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.norm"], ["", "", "def", "forward", "(", "self", ",", "x", ",", "activate", "=", "True", ",", "norm", "=", "True", ")", ":", "\n", "        ", "for", "layer", "in", "self", ".", "order", ":", "\n", "            ", "if", "layer", "==", "'conv'", ":", "\n", "                ", "x", "=", "self", ".", "conv", "(", "x", ")", "\n", "", "elif", "layer", "==", "'norm'", "and", "norm", "and", "self", ".", "with_norm", ":", "\n", "                ", "x", "=", "self", ".", "norm", "(", "x", ")", "\n", "", "elif", "layer", "==", "'act'", "and", "activate", "and", "self", ".", "with_activation", ":", "\n", "                ", "x", "=", "self", ".", "activate", "(", "x", ")", "\n", "", "", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.build_conv_layer": [[15, 41], ["cfg.copy.pop", "conv_layer", "dict", "cfg.copy", "KeyError", "isinstance"], "function", ["None"], ["def", "build_conv_layer", "(", "cfg", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Build convolution layer.\n\n    Args:\n        cfg (None or dict): Cfg should contain:\n            type (str): Identify conv layer type.\n            layer args: Args needed to instantiate a conv layer.\n\n    Returns:\n        nn.Module: Created conv layer.\n    \"\"\"", "\n", "if", "cfg", "is", "None", ":", "\n", "        ", "cfg_", "=", "dict", "(", "type", "=", "'Conv'", ")", "\n", "", "else", ":", "\n", "        ", "assert", "isinstance", "(", "cfg", ",", "dict", ")", "and", "'type'", "in", "cfg", "\n", "cfg_", "=", "cfg", ".", "copy", "(", ")", "\n", "\n", "", "layer_type", "=", "cfg_", ".", "pop", "(", "'type'", ")", "\n", "if", "layer_type", "not", "in", "conv_cfg", ":", "\n", "        ", "raise", "KeyError", "(", "'Unrecognized norm type {}'", ".", "format", "(", "layer_type", ")", ")", "\n", "", "else", ":", "\n", "        ", "conv_layer", "=", "conv_cfg", "[", "layer_type", "]", "\n", "\n", "", "layer", "=", "conv_layer", "(", "*", "args", ",", "**", "kwargs", ",", "**", "cfg_", ")", "\n", "\n", "return", "layer", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.gather_layer.GatherLayer.forward": [[9, 16], ["ctx.save_for_backward", "torch.all_gather", "torch.all_gather", "tuple", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "range", "torch.get_world_size", "torch.get_world_size"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size"], ["@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "input", ")", ":", "\n", "        ", "ctx", ".", "save_for_backward", "(", "input", ")", "\n", "output", "=", "[", "torch", ".", "zeros_like", "(", "input", ")", "for", "_", "in", "range", "(", "dist", ".", "get_world_size", "(", ")", ")", "]", "\n", "dist", ".", "all_gather", "(", "output", ",", "input", ")", "\n", "return", "tuple", "(", "output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.gather_layer.GatherLayer.backward": [[17, 23], ["torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.get_rank", "torch.get_rank"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "*", "grads", ")", ":", "\n", "        ", "input", ",", "=", "ctx", ".", "saved_tensors", "\n", "grad_out", "=", "torch", ".", "zeros_like", "(", "input", ")", "\n", "grad_out", "[", ":", "]", "=", "grads", "[", "dist", ".", "get_rank", "(", ")", "]", "\n", "return", "grad_out", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.sobel.Sobel.__init__": [[8, 22], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d.weight.data.fill_", "torch.Conv2d.bias.data.zero_", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d.weight.data[].copy_", "torch.Conv2d.weight.data[].copy_", "torch.Conv2d.bias.data.zero_", "torch.Sequential", "torch.Sequential", "sobel.Sobel.sobel.parameters", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "Sobel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "grayscale", "=", "nn", ".", "Conv2d", "(", "3", ",", "1", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "grayscale", ".", "weight", ".", "data", ".", "fill_", "(", "1.0", "/", "3.0", ")", "\n", "grayscale", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "sobel_filter", "=", "nn", ".", "Conv2d", "(", "1", ",", "2", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "sobel_filter", ".", "weight", ".", "data", "[", "0", ",", "0", "]", ".", "copy_", "(", "\n", "torch", ".", "FloatTensor", "(", "[", "[", "1", ",", "0", ",", "-", "1", "]", ",", "[", "2", ",", "0", ",", "-", "2", "]", ",", "[", "1", ",", "0", ",", "-", "1", "]", "]", ")", ")", "\n", "sobel_filter", ".", "weight", ".", "data", "[", "1", ",", "0", "]", ".", "copy_", "(", "\n", "torch", ".", "FloatTensor", "(", "[", "[", "1", ",", "2", ",", "1", "]", ",", "[", "0", ",", "0", ",", "0", "]", ",", "[", "-", "1", ",", "-", "2", ",", "-", "1", "]", "]", ")", ")", "\n", "sobel_filter", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "sobel", "=", "nn", ".", "Sequential", "(", "grayscale", ",", "sobel_filter", ")", "\n", "for", "p", "in", "self", ".", "sobel", ".", "parameters", "(", ")", ":", "\n", "            ", "p", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.sobel.Sobel.forward": [[23, 25], ["sobel.Sobel.sobel"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "sobel", "(", "x", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.multi_pooling.MultiPooling.__init__": [[19, 34], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.AdaptiveAvgPool2d", "torch.AvgPool2d"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "\n", "pool_type", "=", "'adaptive'", ",", "\n", "in_indices", "=", "(", "0", ",", ")", ",", "\n", "backbone", "=", "'resnet50'", ")", ":", "\n", "        ", "super", "(", "MultiPooling", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "pool_type", "in", "[", "'adaptive'", ",", "'specified'", "]", "\n", "if", "pool_type", "==", "'adaptive'", ":", "\n", "            ", "self", ".", "pools", "=", "nn", ".", "ModuleList", "(", "[", "\n", "nn", ".", "AdaptiveAvgPool2d", "(", "self", ".", "POOL_SIZES", "[", "backbone", "]", "[", "l", "]", ")", "\n", "for", "l", "in", "in_indices", "\n", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "pools", "=", "nn", ".", "ModuleList", "(", "[", "\n", "nn", ".", "AvgPool2d", "(", "**", "self", ".", "POOL_PARAMS", "[", "backbone", "]", "[", "l", "]", ")", "\n", "for", "l", "in", "in_indices", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.multi_pooling.MultiPooling.forward": [[36, 39], ["isinstance", "p", "zip"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "isinstance", "(", "x", ",", "(", "list", ",", "tuple", ")", ")", "\n", "return", "[", "p", "(", "xx", ")", "for", "p", ",", "xx", "in", "zip", "(", "self", ".", "pools", ",", "x", ")", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.accuracy.Accuracy.__init__": [[39, 42], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "topk", "=", "(", "1", ",", ")", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "topk", "=", "topk", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.accuracy.Accuracy.forward": [[43, 45], ["accuracy.accuracy"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.eval.accuracy"], ["", "def", "forward", "(", "self", ",", "pred", ",", "target", ")", ":", "\n", "        ", "return", "accuracy", "(", "pred", ",", "target", ",", "self", ".", "topk", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.accuracy.accuracy": [[5, 23], ["isinstance", "isinstance", "max", "pred.topk", "pred_label.t.t", "pred_label.t.eq", "target.view().expand_as", "correct[].view().float().sum", "res.append", "correct[].view().float().sum.mul_", "target.view", "correct[].view().float", "pred.size", "correct[].view"], "function", ["None"], ["def", "accuracy", "(", "pred", ",", "target", ",", "topk", "=", "1", ")", ":", "\n", "    ", "assert", "isinstance", "(", "topk", ",", "(", "int", ",", "tuple", ")", ")", "\n", "if", "isinstance", "(", "topk", ",", "int", ")", ":", "\n", "        ", "topk", "=", "(", "topk", ",", ")", "\n", "return_single", "=", "True", "\n", "", "else", ":", "\n", "        ", "return_single", "=", "False", "\n", "\n", "", "maxk", "=", "max", "(", "topk", ")", "\n", "_", ",", "pred_label", "=", "pred", ".", "topk", "(", "maxk", ",", "dim", "=", "1", ")", "\n", "pred_label", "=", "pred_label", ".", "t", "(", ")", "\n", "correct", "=", "pred_label", ".", "eq", "(", "target", ".", "view", "(", "1", ",", "-", "1", ")", ".", "expand_as", "(", "pred_label", ")", ")", "\n", "\n", "res", "=", "[", "]", "\n", "for", "k", "in", "topk", ":", "\n", "        ", "correct_k", "=", "correct", "[", ":", "k", "]", ".", "view", "(", "-", "1", ")", ".", "float", "(", ")", ".", "sum", "(", "0", ",", "keepdim", "=", "True", ")", "\n", "res", ".", "append", "(", "correct_k", ".", "mul_", "(", "100.0", "/", "pred", ".", "size", "(", "0", ")", ")", ")", "\n", "", "return", "res", "[", "0", "]", "if", "return_single", "else", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.accuracy.auroc": [[24, 36], ["torch.zeros", "torch.zeros", "target.detach().cpu().numpy", "pred.detach().cpu().numpy", "range", "torch.zeros.cuda", "target.detach().cpu", "pred.detach().cpu", "sklearn.metrics.roc_auc_score", "target.detach", "pred.detach"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda"], ["", "def", "auroc", "(", "pred", ",", "target", ")", ":", "\n", "    ", "outAUROC", "=", "torch", ".", "zeros", "(", "pred", ".", "shape", "[", "1", "]", ")", "\n", "\n", "datanpGT", "=", "target", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "datanpPRED", "=", "pred", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "pred", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "outAUROC", "[", "i", "]", "=", "roc_auc_score", "(", "datanpGT", "[", ":", ",", "i", "]", ",", "datanpPRED", "[", ":", ",", "i", "]", ")", "\n", "", "except", "ValueError", ":", "\n", "            ", "pass", "\n", "", "", "return", "outAUROC", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_ws.ConvWS2d.__init__": [[23, 43], ["torch.Conv2d.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "bias", "=", "True", ",", "\n", "eps", "=", "1e-5", ")", ":", "\n", "        ", "super", "(", "ConvWS2d", ",", "self", ")", ".", "__init__", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "padding", ",", "\n", "dilation", "=", "dilation", ",", "\n", "groups", "=", "groups", ",", "\n", "bias", "=", "bias", ")", "\n", "self", ".", "eps", "=", "eps", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_ws.ConvWS2d.forward": [[44, 47], ["conv_ws.conv_ws_2d"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_ws.conv_ws_2d"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "conv_ws_2d", "(", "x", ",", "self", ".", "weight", ",", "self", ".", "bias", ",", "self", ".", "stride", ",", "self", ".", "padding", ",", "\n", "self", ".", "dilation", ",", "self", ".", "groups", ",", "self", ".", "eps", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_ws.conv_ws_2d": [[5, 19], ["weight.size", "weight.view", "weight.view.mean().view", "weight.view.std().view", "torch.conv2d", "weight.view.mean", "weight.view.std"], "function", ["None"], ["def", "conv_ws_2d", "(", "input", ",", "\n", "weight", ",", "\n", "bias", "=", "None", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "eps", "=", "1e-5", ")", ":", "\n", "    ", "c_in", "=", "weight", ".", "size", "(", "0", ")", "\n", "weight_flat", "=", "weight", ".", "view", "(", "c_in", ",", "-", "1", ")", "\n", "mean", "=", "weight_flat", ".", "mean", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", ".", "view", "(", "c_in", ",", "1", ",", "1", ",", "1", ")", "\n", "std", "=", "weight_flat", ".", "std", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", ".", "view", "(", "c_in", ",", "1", ",", "1", ",", "1", ")", "\n", "weight", "=", "(", "weight", "-", "mean", ")", "/", "(", "std", "+", "eps", ")", "\n", "return", "F", ".", "conv2d", "(", "input", ",", "weight", ",", "bias", ",", "stride", ",", "padding", ",", "dilation", ",", "groups", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.eval.AverageMeter.__init__": [[123, 127], ["eval.AverageMeter.reset"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator.DensePoseCOCOEvaluator.reset"], ["def", "__init__", "(", "self", ",", "name", ",", "fmt", "=", "':f'", ")", ":", "\n", "        ", "self", ".", "name", "=", "name", "\n", "self", ".", "fmt", "=", "fmt", "\n", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.eval.AverageMeter.reset": [[128, 133], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "val", "=", "0", "\n", "self", ".", "avg", "=", "0", "\n", "self", ".", "sum", "=", "0", "\n", "self", ".", "count", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.eval.AverageMeter.update": [[134, 139], ["None"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "val", ",", "n", "=", "1", ")", ":", "\n", "        ", "self", ".", "val", "=", "val", "\n", "self", ".", "sum", "+=", "val", "*", "n", "\n", "self", ".", "count", "+=", "n", "\n", "self", ".", "avg", "=", "self", ".", "sum", "/", "self", ".", "count", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.eval.AverageMeter.__str__": [[140, 143], ["fmtstr.format"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "fmtstr", "=", "'{name} {val'", "+", "self", ".", "fmt", "+", "'} ({avg'", "+", "self", ".", "fmt", "+", "'})'", "\n", "return", "fmtstr", ".", "format", "(", "**", "self", ".", "__dict__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.eval.ProgressMeter.__init__": [[146, 150], ["eval.ProgressMeter._get_batch_fmtstr"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.eval.ProgressMeter._get_batch_fmtstr"], ["    ", "def", "__init__", "(", "self", ",", "num_batches", ",", "meters", ",", "prefix", "=", "\"\"", ")", ":", "\n", "        ", "self", ".", "batch_fmtstr", "=", "self", ".", "_get_batch_fmtstr", "(", "num_batches", ")", "\n", "self", ".", "meters", "=", "meters", "\n", "self", ".", "prefix", "=", "prefix", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.eval.ProgressMeter.display": [[151, 155], ["print", "str", "eval.ProgressMeter.batch_fmtstr.format"], "methods", ["None"], ["", "def", "display", "(", "self", ",", "batch", ")", ":", "\n", "        ", "entries", "=", "[", "self", ".", "prefix", "+", "self", ".", "batch_fmtstr", ".", "format", "(", "batch", ")", "]", "\n", "entries", "+=", "[", "str", "(", "meter", ")", "for", "meter", "in", "self", ".", "meters", "]", "\n", "print", "(", "'\\t'", ".", "join", "(", "entries", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.eval.ProgressMeter._get_batch_fmtstr": [[156, 160], ["len", "str", "str", "fmt.format"], "methods", ["None"], ["", "def", "_get_batch_fmtstr", "(", "self", ",", "num_batches", ")", ":", "\n", "        ", "num_digits", "=", "len", "(", "str", "(", "num_batches", "//", "1", ")", ")", "\n", "fmt", "=", "'{:'", "+", "str", "(", "num_digits", ")", "+", "'d}'", "\n", "return", "'['", "+", "fmt", "+", "'/'", "+", "fmt", ".", "format", "(", "num_batches", ")", "+", "']'", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.eval.main": [[38, 77], ["parser.parse_args", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "resnet_wider.resnet50x4.load_state_dict", "torch.nn.DataParallel().to", "torch.nn.DataParallel().to", "torch.nn.DataParallel().to", "torch.nn.DataParallel().to", "torch.nn.DataParallel().to", "torch.nn.DataParallel().to", "torch.CrossEntropyLoss", "os.path.join", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "eval.validate", "resnet_wider.resnet50x1", "torchvision.ImageFolder", "resnet_wider.resnet50x2", "torch.nn.DataParallel", "torch.nn.DataParallel", "torch.nn.DataParallel", "torch.nn.DataParallel", "torch.nn.DataParallel", "torch.nn.DataParallel", "torchvision.Compose", "resnet_wider.resnet50x4", "torchvision.Resize", "torchvision.CenterCrop", "torchvision.ToTensor"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.eval.validate", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.resnet50x1", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.resnet50x2", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.resnet50x4"], ["def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "# create model", "\n", "if", "args", ".", "arch", "==", "'resnet50-1x'", ":", "\n", "        ", "model", "=", "resnet50x1", "(", ")", "\n", "sd", "=", "'resnet50-1x.pth'", "\n", "", "elif", "args", ".", "arch", "==", "'resnet50-2x'", ":", "\n", "        ", "model", "=", "resnet50x2", "(", ")", "\n", "sd", "=", "'resnet50-2x.pth'", "\n", "", "elif", "args", ".", "arch", "==", "'resnet50-4x'", ":", "\n", "        ", "model", "=", "resnet50x4", "(", ")", "\n", "sd", "=", "'resnet50-4x.pth'", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "sd", "=", "torch", ".", "load", "(", "sd", ",", "map_location", "=", "'cpu'", ")", "\n", "model", ".", "load_state_dict", "(", "sd", "[", "'state_dict'", "]", ")", "\n", "\n", "model", "=", "torch", ".", "nn", ".", "DataParallel", "(", "model", ")", ".", "to", "(", "'cuda'", ")", "\n", "\n", "# define loss function (criterion) and optimizer", "\n", "criterion", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "cudnn", ".", "benchmark", "=", "True", "\n", "\n", "# Data loading code", "\n", "valdir", "=", "os", ".", "path", ".", "join", "(", "args", ".", "data", ",", "'val'", ")", "\n", "\n", "# NOTICE, the original model do not have normalization", "\n", "val_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "datasets", ".", "ImageFolder", "(", "valdir", ",", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "Resize", "(", "256", ")", ",", "\n", "transforms", ".", "CenterCrop", "(", "256", ")", ",", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "]", ")", ")", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ",", "shuffle", "=", "False", ",", "\n", "num_workers", "=", "args", ".", "workers", ",", "pin_memory", "=", "True", ")", "\n", "\n", "validate", "(", "val_loader", ",", "model", ",", "criterion", ",", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.eval.validate": [[79, 118], ["eval.AverageMeter", "eval.AverageMeter", "eval.AverageMeter", "eval.AverageMeter", "eval.ProgressMeter", "model.eval", "len", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "time.time", "enumerate", "print", "target.to.to", "model", "criterion", "eval.accuracy", "eval.AverageMeter.update", "eval.AverageMeter.update", "eval.AverageMeter.update", "eval.AverageMeter.update", "time.time", "criterion.item", "images.size", "images.size", "images.size", "eval.ProgressMeter.display", "time.time"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.eval.accuracy", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.eval.ProgressMeter.display"], ["", "def", "validate", "(", "val_loader", ",", "model", ",", "criterion", ",", "args", ")", ":", "\n", "    ", "batch_time", "=", "AverageMeter", "(", "'Time'", ",", "':6.3f'", ")", "\n", "losses", "=", "AverageMeter", "(", "'Loss'", ",", "':.4e'", ")", "\n", "top1", "=", "AverageMeter", "(", "'Acc@1'", ",", "':6.2f'", ")", "\n", "top5", "=", "AverageMeter", "(", "'Acc@5'", ",", "':6.2f'", ")", "\n", "progress", "=", "ProgressMeter", "(", "\n", "len", "(", "val_loader", ")", ",", "\n", "[", "batch_time", ",", "losses", ",", "top1", ",", "top5", "]", ",", "\n", "prefix", "=", "'Test: '", ")", "\n", "\n", "# switch to evaluate mode", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "end", "=", "time", ".", "time", "(", ")", "\n", "for", "i", ",", "(", "images", ",", "target", ")", "in", "enumerate", "(", "val_loader", ")", ":", "\n", "            ", "target", "=", "target", ".", "to", "(", "'cuda'", ")", "\n", "\n", "# compute output", "\n", "output", "=", "model", "(", "images", ")", "\n", "loss", "=", "criterion", "(", "output", ",", "target", ")", "\n", "\n", "# measure accuracy and record loss", "\n", "acc1", ",", "acc5", "=", "accuracy", "(", "output", ",", "target", ",", "topk", "=", "(", "1", ",", "5", ")", ")", "\n", "losses", ".", "update", "(", "loss", ".", "item", "(", ")", ",", "images", ".", "size", "(", "0", ")", ")", "\n", "top1", ".", "update", "(", "acc1", "[", "0", "]", ",", "images", ".", "size", "(", "0", ")", ")", "\n", "top5", ".", "update", "(", "acc5", "[", "0", "]", ",", "images", ".", "size", "(", "0", ")", ")", "\n", "\n", "# measure elapsed time", "\n", "batch_time", ".", "update", "(", "time", ".", "time", "(", ")", "-", "end", ")", "\n", "end", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "i", "%", "args", ".", "print_freq", "==", "0", ":", "\n", "                ", "progress", ".", "display", "(", "i", ")", "\n", "\n", "", "", "print", "(", "' * Acc@1 {top1.avg:.3f} Acc@5 {top5.avg:.3f}'", "\n", ".", "format", "(", "top1", "=", "top1", ",", "top5", "=", "top5", ")", ")", "\n", "\n", "", "return", "top1", ".", "avg", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.eval.accuracy": [[162, 177], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "max", "target.size", "output.topk", "pred.t.t", "pred.t.eq", "target.view().expand_as", "correct[].view().float().sum", "res.append", "correct[].view().float().sum.mul_", "target.view", "correct[].view().float", "correct[].view"], "function", ["None"], ["", "", "def", "accuracy", "(", "output", ",", "target", ",", "topk", "=", "(", "1", ",", ")", ")", ":", "\n", "    ", "\"\"\"Computes the accuracy over the k top predictions for the specified values of k\"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "maxk", "=", "max", "(", "topk", ")", "\n", "batch_size", "=", "target", ".", "size", "(", "0", ")", "\n", "\n", "_", ",", "pred", "=", "output", ".", "topk", "(", "maxk", ",", "1", ",", "True", ",", "True", ")", "\n", "pred", "=", "pred", ".", "t", "(", ")", "\n", "correct", "=", "pred", ".", "eq", "(", "target", ".", "view", "(", "1", ",", "-", "1", ")", ".", "expand_as", "(", "pred", ")", ")", "\n", "\n", "res", "=", "[", "]", "\n", "for", "k", "in", "topk", ":", "\n", "            ", "correct_k", "=", "correct", "[", ":", "k", "]", ".", "view", "(", "-", "1", ")", ".", "float", "(", ")", ".", "sum", "(", "0", ",", "keepdim", "=", "True", ")", "\n", "res", ".", "append", "(", "correct_k", ".", "mul_", "(", "100.0", "/", "batch_size", ")", ")", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.convert.main": [[16, 86], ["tensorflow.train.list_variables", "tensorflow.train.load_checkpoint", "sd.pop", "numpy.argsort", "list", "numpy.argsort", "resnet_wider.resnet50x4.modules", "range", "range", "torch.from_numpy().t", "torch.from_numpy().t", "torch.from_numpy", "torch.from_numpy", "torch.save", "torch.save", "tf.train.load_checkpoint.get_tensor", "set", "resnet_wider.resnet50x1", "isinstance", "len", "torch.from_numpy().permute", "torch.from_numpy().permute", "len", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "sd.keys", "k.split", "len", "conv_idx.append", "conv_idx.append", "len", "bn_idx.append", "bn_idx.append", "resnet_wider.resnet50x2", "conv_op.append", "isinstance", "torch.from_numpy", "torch.from_numpy", "resnet_wider.resnet50x4.state_dict", "int", "k.split", "int", "resnet_wider.resnet50x4", "bn_op.append", "torch.from_numpy().permute", "torch.from_numpy().permute", "torch.from_numpy", "torch.from_numpy", "[].split", "k.split", "sd.keys", "k.split", "torch.from_numpy", "torch.from_numpy", "[].split", "k.split", "k.split"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.resnet50x1", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.resnet50x2", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.resnet50x4"], ["def", "main", "(", ")", ":", "\n", "# 1. read tensorflow weight into a python dict", "\n", "    ", "vars_list", "=", "tf", ".", "train", ".", "list_variables", "(", "args", ".", "tf_path", ")", "\n", "vars_list", "=", "[", "v", "[", "0", "]", "for", "v", "in", "vars_list", "]", "\n", "# print('#vars:', len(vars_list))", "\n", "\n", "sd", "=", "{", "}", "\n", "ckpt_reader", "=", "tf", ".", "train", ".", "load_checkpoint", "(", "args", ".", "tf_path", ")", "\n", "for", "v", "in", "vars_list", ":", "\n", "        ", "sd", "[", "v", "]", "=", "ckpt_reader", ".", "get_tensor", "(", "v", ")", "\n", "\n", "", "sd", ".", "pop", "(", "'global_step'", ")", "\n", "\n", "# 2. convert the state_dict to PyTorch format", "\n", "conv_keys", "=", "[", "k", "for", "k", "in", "sd", ".", "keys", "(", ")", "if", "k", ".", "split", "(", "'/'", ")", "[", "1", "]", ".", "split", "(", "'_'", ")", "[", "0", "]", "==", "'conv2d'", "]", "\n", "conv_idx", "=", "[", "]", "\n", "for", "k", "in", "conv_keys", ":", "\n", "        ", "mid", "=", "k", ".", "split", "(", "'/'", ")", "[", "1", "]", "\n", "if", "len", "(", "mid", ")", "==", "6", ":", "\n", "            ", "conv_idx", ".", "append", "(", "0", ")", "\n", "", "else", ":", "\n", "            ", "conv_idx", ".", "append", "(", "int", "(", "mid", "[", "7", ":", "]", ")", ")", "\n", "", "", "arg_idx", "=", "np", ".", "argsort", "(", "conv_idx", ")", "\n", "conv_keys", "=", "[", "conv_keys", "[", "idx", "]", "for", "idx", "in", "arg_idx", "]", "\n", "\n", "bn_keys", "=", "list", "(", "set", "(", "[", "k", ".", "split", "(", "'/'", ")", "[", "1", "]", "for", "k", "in", "sd", ".", "keys", "(", ")", "if", "k", ".", "split", "(", "'/'", ")", "[", "1", "]", ".", "split", "(", "'_'", ")", "[", "0", "]", "==", "'batch'", "]", ")", ")", "\n", "bn_idx", "=", "[", "]", "\n", "for", "k", "in", "bn_keys", ":", "\n", "        ", "if", "len", "(", "k", ".", "split", "(", "'_'", ")", ")", "==", "2", ":", "\n", "            ", "bn_idx", ".", "append", "(", "0", ")", "\n", "", "else", ":", "\n", "            ", "bn_idx", ".", "append", "(", "int", "(", "k", ".", "split", "(", "'_'", ")", "[", "2", "]", ")", ")", "\n", "", "", "arg_idx", "=", "np", ".", "argsort", "(", "bn_idx", ")", "\n", "bn_keys", "=", "[", "bn_keys", "[", "idx", "]", "for", "idx", "in", "arg_idx", "]", "\n", "\n", "if", "'_1x'", "in", "args", ".", "tf_path", ":", "\n", "        ", "model", "=", "resnet50x1", "(", ")", "\n", "", "elif", "'_2x'", "in", "args", ".", "tf_path", ":", "\n", "        ", "model", "=", "resnet50x2", "(", ")", "\n", "", "elif", "'_4x'", "in", "args", ".", "tf_path", ":", "\n", "        ", "model", "=", "resnet50x4", "(", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "conv_op", "=", "[", "]", "\n", "bn_op", "=", "[", "]", "\n", "for", "m", "in", "model", ".", "modules", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "            ", "conv_op", ".", "append", "(", "m", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "            ", "bn_op", ".", "append", "(", "m", ")", "\n", "\n", "", "", "for", "i_conv", "in", "range", "(", "len", "(", "conv_keys", ")", ")", ":", "\n", "        ", "m", "=", "conv_op", "[", "i_conv", "]", "\n", "# assert the weight of conv has the same shape", "\n", "assert", "torch", ".", "from_numpy", "(", "sd", "[", "conv_keys", "[", "i_conv", "]", "]", ")", ".", "permute", "(", "3", ",", "2", ",", "0", ",", "1", ")", ".", "shape", "==", "m", ".", "weight", ".", "data", ".", "shape", "\n", "m", ".", "weight", ".", "data", "=", "torch", ".", "from_numpy", "(", "sd", "[", "conv_keys", "[", "i_conv", "]", "]", ")", ".", "permute", "(", "3", ",", "2", ",", "0", ",", "1", ")", "\n", "\n", "", "for", "i_bn", "in", "range", "(", "len", "(", "bn_keys", ")", ")", ":", "\n", "        ", "m", "=", "bn_op", "[", "i_bn", "]", "\n", "m", ".", "weight", ".", "data", "=", "torch", ".", "from_numpy", "(", "sd", "[", "'base_model/'", "+", "bn_keys", "[", "i_bn", "]", "+", "'/gamma'", "]", ")", "\n", "m", ".", "bias", ".", "data", "=", "torch", ".", "from_numpy", "(", "sd", "[", "'base_model/'", "+", "bn_keys", "[", "i_bn", "]", "+", "'/beta'", "]", ")", "\n", "m", ".", "running_mean", "=", "torch", ".", "from_numpy", "(", "sd", "[", "'base_model/'", "+", "bn_keys", "[", "i_bn", "]", "+", "'/moving_mean'", "]", ")", "\n", "m", ".", "running_var", "=", "torch", ".", "from_numpy", "(", "sd", "[", "'base_model/'", "+", "bn_keys", "[", "i_bn", "]", "+", "'/moving_variance'", "]", ")", "\n", "\n", "", "model", ".", "fc", ".", "weight", ".", "data", "=", "torch", ".", "from_numpy", "(", "sd", "[", "'head_supervised/linear_layer/dense/kernel'", "]", ")", ".", "t", "(", ")", "\n", "model", ".", "fc", ".", "weight", ".", "bias", "=", "torch", ".", "from_numpy", "(", "sd", "[", "'head_supervised/linear_layer/dense/bias'", "]", ")", "\n", "\n", "# 3. dump the PyTorch weights.", "\n", "torch", ".", "save", "(", "{", "'state_dict'", ":", "model", ".", "state_dict", "(", ")", "}", ",", "args", ".", "pth_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.BasicBlock.__init__": [[20, 37], ["torch.Module.__init__", "resnet_wider.conv3x3", "norm_layer", "torch.ReLU", "torch.ReLU", "resnet_wider.conv3x3", "norm_layer", "ValueError", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.conv3x3", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.conv3x3"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", "=", "1", ",", "downsample", "=", "None", ",", "groups", "=", "1", ",", "\n", "base_width", "=", "64", ",", "dilation", "=", "1", ",", "norm_layer", "=", "None", ")", ":", "\n", "        ", "super", "(", "BasicBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "norm_layer", "is", "None", ":", "\n", "            ", "norm_layer", "=", "nn", ".", "BatchNorm2d", "\n", "", "if", "groups", "!=", "1", "or", "base_width", "!=", "64", ":", "\n", "            ", "raise", "ValueError", "(", "'BasicBlock only supports groups=1 and base_width=64'", ")", "\n", "", "if", "dilation", ">", "1", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Dilation > 1 not supported in BasicBlock\"", ")", "\n", "# Both self.conv1 and self.downsample layers downsample the input when stride != 1", "\n", "", "self", ".", "conv1", "=", "conv3x3", "(", "inplanes", ",", "planes", ",", "stride", ")", "\n", "self", ".", "bn1", "=", "norm_layer", "(", "planes", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "conv2", "=", "conv3x3", "(", "planes", ",", "planes", ")", "\n", "self", ".", "bn2", "=", "norm_layer", "(", "planes", ")", "\n", "self", ".", "downsample", "=", "downsample", "\n", "self", ".", "stride", "=", "stride", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.BasicBlock.forward": [[38, 55], ["resnet_wider.BasicBlock.conv1", "resnet_wider.BasicBlock.bn1", "resnet_wider.BasicBlock.relu", "resnet_wider.BasicBlock.conv2", "resnet_wider.BasicBlock.bn2", "resnet_wider.BasicBlock.relu", "resnet_wider.BasicBlock.downsample"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "identity", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "identity", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "identity", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.Bottleneck.__init__": [[61, 77], ["torch.Module.__init__", "resnet_wider.conv1x1", "norm_layer", "resnet_wider.conv3x3", "norm_layer", "resnet_wider.conv1x1", "norm_layer", "torch.ReLU", "torch.ReLU", "int"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.conv1x1", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.conv3x3", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.conv1x1"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", "=", "1", ",", "downsample", "=", "None", ",", "groups", "=", "1", ",", "\n", "base_width", "=", "64", ",", "dilation", "=", "1", ",", "norm_layer", "=", "None", ")", ":", "\n", "        ", "super", "(", "Bottleneck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "downsample", "=", "downsample", "# hack: moving downsample to the first to make order correct", "\n", "if", "norm_layer", "is", "None", ":", "\n", "            ", "norm_layer", "=", "nn", ".", "BatchNorm2d", "\n", "", "width", "=", "int", "(", "planes", "*", "(", "base_width", "/", "64.", ")", ")", "*", "groups", "\n", "self", ".", "conv1", "=", "conv1x1", "(", "inplanes", ",", "width", ")", "\n", "self", ".", "bn1", "=", "norm_layer", "(", "width", ")", "\n", "self", ".", "conv2", "=", "conv3x3", "(", "width", ",", "width", ",", "stride", ",", "groups", ",", "dilation", ")", "\n", "self", ".", "bn2", "=", "norm_layer", "(", "width", ")", "\n", "self", ".", "conv3", "=", "conv1x1", "(", "width", ",", "planes", "*", "self", ".", "expansion", ")", "\n", "self", ".", "bn3", "=", "norm_layer", "(", "planes", "*", "self", ".", "expansion", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n", "self", ".", "stride", "=", "stride", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.Bottleneck.forward": [[78, 99], ["resnet_wider.Bottleneck.conv1", "resnet_wider.Bottleneck.bn1", "resnet_wider.Bottleneck.relu", "resnet_wider.Bottleneck.conv2", "resnet_wider.Bottleneck.bn2", "resnet_wider.Bottleneck.relu", "resnet_wider.Bottleneck.conv3", "resnet_wider.Bottleneck.bn3", "resnet_wider.Bottleneck.relu", "resnet_wider.Bottleneck.downsample"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "identity", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "out", "=", "self", ".", "bn3", "(", "out", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "identity", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "identity", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.ResNet.__init__": [[103, 153], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "norm_layer", "torch.ReLU", "torch.ReLU", "torch.MaxPool2d", "torch.MaxPool2d", "resnet_wider.ResNet._make_layer", "resnet_wider.ResNet._make_layer", "resnet_wider.ResNet._make_layer", "resnet_wider.ResNet._make_layer", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.Linear", "torch.Linear", "resnet_wider.ResNet.modules", "len", "ValueError", "isinstance", "resnet_wider.ResNet.modules", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "isinstance", "isinstance", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "isinstance", "torch.init.constant_", "torch.init.constant_"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.PoseHigherResolutionNet._make_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.PoseHigherResolutionNet._make_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.PoseHigherResolutionNet._make_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.PoseHigherResolutionNet._make_layer"], ["    ", "def", "__init__", "(", "self", ",", "block", ",", "layers", ",", "num_classes", "=", "1000", ",", "zero_init_residual", "=", "False", ",", "\n", "groups", "=", "1", ",", "width_per_group", "=", "64", ",", "replace_stride_with_dilation", "=", "None", ",", "\n", "norm_layer", "=", "None", ",", "width_mult", "=", "1", ")", ":", "\n", "        ", "super", "(", "ResNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "norm_layer", "is", "None", ":", "\n", "            ", "norm_layer", "=", "nn", ".", "BatchNorm2d", "\n", "", "self", ".", "_norm_layer", "=", "norm_layer", "\n", "\n", "self", ".", "inplanes", "=", "64", "*", "width_mult", "\n", "self", ".", "dilation", "=", "1", "\n", "if", "replace_stride_with_dilation", "is", "None", ":", "\n", "# each element in the tuple indicates if we should replace", "\n", "# the 2x2 stride with a dilated convolution instead", "\n", "            ", "replace_stride_with_dilation", "=", "[", "False", ",", "False", ",", "False", "]", "\n", "", "if", "len", "(", "replace_stride_with_dilation", ")", "!=", "3", ":", "\n", "            ", "raise", "ValueError", "(", "\"replace_stride_with_dilation should be None \"", "\n", "\"or a 3-element tuple, got {}\"", ".", "format", "(", "replace_stride_with_dilation", ")", ")", "\n", "", "self", ".", "groups", "=", "groups", "\n", "self", ".", "base_width", "=", "width_per_group", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "3", ",", "self", ".", "inplanes", ",", "kernel_size", "=", "7", ",", "stride", "=", "2", ",", "padding", "=", "3", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "norm_layer", "(", "self", ".", "inplanes", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "maxpool", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "block", ",", "64", "*", "width_mult", ",", "layers", "[", "0", "]", ")", "\n", "self", ".", "layer2", "=", "self", ".", "_make_layer", "(", "block", ",", "128", "*", "width_mult", ",", "layers", "[", "1", "]", ",", "stride", "=", "2", ",", "\n", "dilate", "=", "replace_stride_with_dilation", "[", "0", "]", ")", "\n", "self", ".", "layer3", "=", "self", ".", "_make_layer", "(", "block", ",", "256", "*", "width_mult", ",", "layers", "[", "2", "]", ",", "stride", "=", "2", ",", "\n", "dilate", "=", "replace_stride_with_dilation", "[", "1", "]", ")", "\n", "self", ".", "layer4", "=", "self", ".", "_make_layer", "(", "block", ",", "512", "*", "width_mult", ",", "layers", "[", "3", "]", ",", "stride", "=", "2", ",", "\n", "dilate", "=", "replace_stride_with_dilation", "[", "2", "]", ")", "\n", "self", ".", "avgpool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "(", "1", ",", "1", ")", ")", "\n", "self", ".", "fc", "=", "nn", ".", "Linear", "(", "512", "*", "block", ".", "expansion", "*", "width_mult", ",", "num_classes", ")", "\n", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ",", "mode", "=", "'fan_out'", ",", "nonlinearity", "=", "'relu'", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "(", "nn", ".", "BatchNorm2d", ",", "nn", ".", "GroupNorm", ")", ")", ":", "\n", "                ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "weight", ",", "1", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n", "# Zero-initialize the last BN in each residual branch,", "\n", "# so that the residual branch starts with zeros, and each residual block behaves like an identity.", "\n", "# This improves the model by 0.2~0.3% according to https://arxiv.org/abs/1706.02677", "\n", "", "", "if", "zero_init_residual", ":", "\n", "            ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "m", ",", "Bottleneck", ")", ":", "\n", "                    ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bn3", ".", "weight", ",", "0", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "BasicBlock", ")", ":", "\n", "                    ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bn2", ".", "weight", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.ResNet._make_layer": [[154, 177], ["layers.append", "range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "block", "layers.append", "resnet_wider.conv1x1", "norm_layer", "block"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.conv1x1"], ["", "", "", "", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "blocks", ",", "stride", "=", "1", ",", "dilate", "=", "False", ")", ":", "\n", "        ", "norm_layer", "=", "self", ".", "_norm_layer", "\n", "downsample", "=", "None", "\n", "previous_dilation", "=", "self", ".", "dilation", "\n", "if", "dilate", ":", "\n", "            ", "self", ".", "dilation", "*=", "stride", "\n", "stride", "=", "1", "\n", "", "if", "stride", "!=", "1", "or", "self", ".", "inplanes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "            ", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "conv1x1", "(", "self", ".", "inplanes", ",", "planes", "*", "block", ".", "expansion", ",", "stride", ")", ",", "\n", "norm_layer", "(", "planes", "*", "block", ".", "expansion", ")", ",", "\n", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "stride", ",", "downsample", ",", "self", ".", "groups", ",", "\n", "self", ".", "base_width", ",", "previous_dilation", ",", "norm_layer", ")", ")", "\n", "self", ".", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n", "for", "_", "in", "range", "(", "1", ",", "blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "groups", "=", "self", ".", "groups", ",", "\n", "base_width", "=", "self", ".", "base_width", ",", "dilation", "=", "self", ".", "dilation", ",", "\n", "norm_layer", "=", "norm_layer", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.ResNet._forward_impl": [[178, 195], ["resnet_wider.ResNet.conv1", "resnet_wider.ResNet.bn1", "resnet_wider.ResNet.relu", "resnet_wider.ResNet.maxpool", "resnet_wider.ResNet.layer1", "resnet_wider.ResNet.layer2", "resnet_wider.ResNet.layer3", "resnet_wider.ResNet.layer4", "resnet_wider.ResNet.avgpool", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "resnet_wider.ResNet.fc"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten"], ["", "def", "_forward_impl", "(", "self", ",", "x", ")", ":", "\n", "# See note [TorchScript super()]", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "maxpool", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "layer1", "(", "x", ")", "\n", "x", "=", "self", ".", "layer2", "(", "x", ")", "\n", "x", "=", "self", ".", "layer3", "(", "x", ")", "\n", "x", "=", "self", ".", "layer4", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "avgpool", "(", "x", ")", "\n", "x", "=", "torch", ".", "flatten", "(", "x", ",", "1", ")", "\n", "x", "=", "self", ".", "fc", "(", "x", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.ResNet.forward": [[196, 198], ["resnet_wider.ResNet._forward_impl"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.ResNet._forward_impl"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "_forward_impl", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.conv3x3": [[5, 9], ["torch.Conv2d"], "function", ["None"], ["def", "conv3x3", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ",", "groups", "=", "1", ",", "dilation", "=", "1", ")", ":", "\n", "    ", "\"\"\"3x3 convolution with padding\"\"\"", "\n", "return", "nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "dilation", ",", "groups", "=", "groups", ",", "bias", "=", "False", ",", "dilation", "=", "dilation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.conv1x1": [[11, 14], ["torch.Conv2d"], "function", ["None"], ["", "def", "conv1x1", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ")", ":", "\n", "    ", "\"\"\"1x1 convolution\"\"\"", "\n", "return", "nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.resnet50x1": [[200, 202], ["resnet_wider.ResNet"], "function", ["None"], ["", "", "def", "resnet50x1", "(", "**", "kwargs", ")", ":", "\n", "    ", "return", "ResNet", "(", "Bottleneck", ",", "[", "3", ",", "4", ",", "6", ",", "3", "]", ",", "width_mult", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.resnet50x2": [[203, 205], ["resnet_wider.ResNet"], "function", ["None"], ["", "def", "resnet50x2", "(", "**", "kwargs", ")", ":", "\n", "    ", "return", "ResNet", "(", "Bottleneck", ",", "[", "3", ",", "4", ",", "6", ",", "3", "]", ",", "width_mult", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.resnet_wider.resnet50x4": [[207, 209], ["resnet_wider.ResNet"], "function", ["None"], ["", "def", "resnet50x4", "(", "**", "kwargs", ")", ":", "\n", "    ", "return", "ResNet", "(", "Bottleneck", ",", "[", "3", ",", "4", ",", "6", ",", "3", "]", ",", "width_mult", "=", "4", ")", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.OpenSelfSup.setup.readme": [[8, 12], ["open", "f.read"], "function", ["None"], ["def", "readme", "(", ")", ":", "\n", "    ", "with", "open", "(", "'README.md'", ",", "encoding", "=", "'utf-8'", ")", "as", "f", ":", "\n", "        ", "content", "=", "f", ".", "read", "(", ")", "\n", "", "return", "content", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.OpenSelfSup.setup.get_git_hash": [[26, 50], ["setup.get_git_hash._minimal_ext_cmd"], "function", ["None"], ["def", "get_git_hash", "(", ")", ":", "\n", "\n", "    ", "def", "_minimal_ext_cmd", "(", "cmd", ")", ":", "\n", "# construct minimal environment", "\n", "        ", "env", "=", "{", "}", "\n", "for", "k", "in", "[", "'SYSTEMROOT'", ",", "'PATH'", ",", "'HOME'", "]", ":", "\n", "            ", "v", "=", "os", ".", "environ", ".", "get", "(", "k", ")", "\n", "if", "v", "is", "not", "None", ":", "\n", "                ", "env", "[", "k", "]", "=", "v", "\n", "# LANGUAGE is used on win32", "\n", "", "", "env", "[", "'LANGUAGE'", "]", "=", "'C'", "\n", "env", "[", "'LANG'", "]", "=", "'C'", "\n", "env", "[", "'LC_ALL'", "]", "=", "'C'", "\n", "out", "=", "subprocess", ".", "Popen", "(", "\n", "cmd", ",", "stdout", "=", "subprocess", ".", "PIPE", ",", "env", "=", "env", ")", ".", "communicate", "(", ")", "[", "0", "]", "\n", "return", "out", "\n", "\n", "", "try", ":", "\n", "        ", "out", "=", "_minimal_ext_cmd", "(", "[", "'git'", ",", "'rev-parse'", ",", "'HEAD'", "]", ")", "\n", "sha", "=", "out", ".", "strip", "(", ")", ".", "decode", "(", "'ascii'", ")", "\n", "", "except", "OSError", ":", "\n", "        ", "sha", "=", "'unknown'", "\n", "\n", "", "return", "sha", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.OpenSelfSup.setup.get_hash": [[52, 65], ["os.path.exists", "os.path.exists", "setup.get_git_hash", "__version__.split", "ImportError"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.OpenSelfSup.setup.get_git_hash"], ["", "def", "get_hash", "(", ")", ":", "\n", "    ", "if", "os", ".", "path", ".", "exists", "(", "'.git'", ")", ":", "\n", "        ", "sha", "=", "get_git_hash", "(", ")", "[", ":", "7", "]", "\n", "", "elif", "os", ".", "path", ".", "exists", "(", "version_file", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "from", "openselfsup", ".", "version", "import", "__version__", "\n", "sha", "=", "__version__", ".", "split", "(", "'+'", ")", "[", "-", "1", "]", "\n", "", "except", "ImportError", ":", "\n", "            ", "raise", "ImportError", "(", "'Unable to get git version'", ")", "\n", "", "", "else", ":", "\n", "        ", "sha", "=", "'unknown'", "\n", "\n", "", "return", "sha", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.OpenSelfSup.setup.write_version_py": [[67, 79], ["setup.get_hash", "open", "f.write", "content.format", "time.asctime"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.OpenSelfSup.setup.get_hash", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write"], ["", "def", "write_version_py", "(", ")", ":", "\n", "    ", "content", "=", "\"\"\"# GENERATED VERSION FILE\n# TIME: {}\n\n__version__ = '{}'\nshort_version = '{}'\n\"\"\"", "\n", "sha", "=", "get_hash", "(", ")", "\n", "VERSION", "=", "SHORT_VERSION", "+", "'+'", "+", "sha", "\n", "\n", "with", "open", "(", "version_file", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "content", ".", "format", "(", "time", ".", "asctime", "(", ")", ",", "VERSION", ",", "SHORT_VERSION", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.OpenSelfSup.setup.get_version": [[81, 85], ["open", "exec", "locals", "compile", "f.read"], "function", ["None"], ["", "", "def", "get_version", "(", ")", ":", "\n", "    ", "with", "open", "(", "version_file", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "exec", "(", "compile", "(", "f", ".", "read", "(", ")", ",", "version_file", ",", "'exec'", ")", ")", "\n", "", "return", "locals", "(", ")", "[", "'__version__'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.OpenSelfSup.setup.parse_requirements": [[87, 164], ["list", "line.strip.startswith", "exists", "setup.parse_requirements.gen_packages_items"], "function", ["None"], ["", "def", "parse_requirements", "(", "fname", "=", "'requirements.txt'", ",", "with_version", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Parse the package dependencies listed in a requirements file but strips\n    specific versioning information.\n\n    Args:\n        fname (str): path to requirements file\n        with_version (bool, default=False): if True include version specs\n\n    Returns:\n        List[str]: list of requirements items\n\n    CommandLine:\n        python -c \"import setup; print(setup.parse_requirements())\"\n    \"\"\"", "\n", "import", "sys", "\n", "from", "os", ".", "path", "import", "exists", "\n", "import", "re", "\n", "require_fpath", "=", "fname", "\n", "\n", "def", "parse_line", "(", "line", ")", ":", "\n", "        ", "\"\"\"\n        Parse information from a line in a requirements text file\n        \"\"\"", "\n", "if", "line", ".", "startswith", "(", "'-r '", ")", ":", "\n", "# Allow specifying requirements in other files", "\n", "            ", "target", "=", "line", ".", "split", "(", "' '", ")", "[", "1", "]", "\n", "for", "info", "in", "parse_require_file", "(", "target", ")", ":", "\n", "                ", "yield", "info", "\n", "", "", "else", ":", "\n", "            ", "info", "=", "{", "'line'", ":", "line", "}", "\n", "if", "line", ".", "startswith", "(", "'-e '", ")", ":", "\n", "                ", "info", "[", "'package'", "]", "=", "line", ".", "split", "(", "'#egg='", ")", "[", "1", "]", "\n", "", "else", ":", "\n", "# Remove versioning from the package", "\n", "                ", "pat", "=", "'('", "+", "'|'", ".", "join", "(", "[", "'>='", ",", "'=='", ",", "'>'", "]", ")", "+", "')'", "\n", "parts", "=", "re", ".", "split", "(", "pat", ",", "line", ",", "maxsplit", "=", "1", ")", "\n", "parts", "=", "[", "p", ".", "strip", "(", ")", "for", "p", "in", "parts", "]", "\n", "\n", "info", "[", "'package'", "]", "=", "parts", "[", "0", "]", "\n", "if", "len", "(", "parts", ")", ">", "1", ":", "\n", "                    ", "op", ",", "rest", "=", "parts", "[", "1", ":", "]", "\n", "if", "';'", "in", "rest", ":", "\n", "# Handle platform specific dependencies", "\n", "# http://setuptools.readthedocs.io/en/latest/setuptools.html#declaring-platform-specific-dependencies", "\n", "                        ", "version", ",", "platform_deps", "=", "map", "(", "str", ".", "strip", ",", "\n", "rest", ".", "split", "(", "';'", ")", ")", "\n", "info", "[", "'platform_deps'", "]", "=", "platform_deps", "\n", "", "else", ":", "\n", "                        ", "version", "=", "rest", "# NOQA", "\n", "", "info", "[", "'version'", "]", "=", "(", "op", ",", "version", ")", "\n", "", "", "yield", "info", "\n", "\n", "", "", "def", "parse_require_file", "(", "fpath", ")", ":", "\n", "        ", "with", "open", "(", "fpath", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ".", "readlines", "(", ")", ":", "\n", "                ", "line", "=", "line", ".", "strip", "(", ")", "\n", "if", "line", "and", "not", "line", ".", "startswith", "(", "'#'", ")", ":", "\n", "                    ", "for", "info", "in", "parse_line", "(", "line", ")", ":", "\n", "                        ", "yield", "info", "\n", "\n", "", "", "", "", "", "def", "gen_packages_items", "(", ")", ":", "\n", "        ", "if", "exists", "(", "require_fpath", ")", ":", "\n", "            ", "for", "info", "in", "parse_require_file", "(", "require_fpath", ")", ":", "\n", "                ", "parts", "=", "[", "info", "[", "'package'", "]", "]", "\n", "if", "with_version", "and", "'version'", "in", "info", ":", "\n", "                    ", "parts", ".", "extend", "(", "info", "[", "'version'", "]", ")", "\n", "", "if", "not", "sys", ".", "version", ".", "startswith", "(", "'3.4'", ")", ":", "\n", "# apparently package_deps are broken in 3.4", "\n", "                    ", "platform_deps", "=", "info", ".", "get", "(", "'platform_deps'", ")", "\n", "if", "platform_deps", "is", "not", "None", ":", "\n", "                        ", "parts", ".", "append", "(", "';'", "+", "platform_deps", ")", "\n", "", "", "item", "=", "''", ".", "join", "(", "parts", ")", "\n", "yield", "item", "\n", "\n", "", "", "", "packages", "=", "list", "(", "gen_packages_items", "(", ")", ")", "\n", "return", "packages", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.detection.train_net.Res5ROIHeadsExtraNorm._build_res5_block": [[28, 34], ["super()._build_res5_block", "detectron2.layers.get_norm", "seq.add_module"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.Res5ROIHeads._build_res5_block", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm"], ["def", "_build_res5_block", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "seq", ",", "out_channels", "=", "super", "(", ")", ".", "_build_res5_block", "(", "cfg", ")", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "NORM", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", "\n", "seq", ".", "add_module", "(", "\"norm\"", ",", "norm", ")", "\n", "return", "seq", ",", "out_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.detection.train_net.Trainer.build_evaluator": [[38, 46], ["os.path.join", "detectron2.evaluation.PascalVOCDetectionEvaluator", "detectron2.evaluation.COCOEvaluator"], "methods", ["None"], ["    ", "@", "classmethod", "\n", "def", "build_evaluator", "(", "cls", ",", "cfg", ",", "dataset_name", ",", "output_folder", "=", "None", ")", ":", "\n", "        ", "if", "output_folder", "is", "None", ":", "\n", "            ", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference\"", ")", "\n", "", "if", "\"voc\"", "in", "dataset_name", ":", "\n", "            ", "return", "PascalVOCDetectionEvaluator", "(", "dataset_name", ")", "\n", "", "else", ":", "\n", "            ", "return", "COCOEvaluator", "(", "dataset_name", ",", "cfg", ",", "True", ",", "output_folder", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.detection.train_net.setup": [[48, 55], ["detectron2.config.get_cfg", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.engine.default_setup"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.default_setup"], ["", "", "", "def", "setup", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "default_setup", "(", "cfg", ",", "args", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.detection.train_net.main": [[57, 71], ["train_net.setup", "train_net.Trainer", "Trainer.resume_or_load", "Trainer.train", "Trainer.build_model", "detectron2.checkpoint.DetectionCheckpointer().resume_or_load", "Trainer.test", "detectron2.checkpoint.DetectionCheckpointer"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.setup", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_packaging.TestCollectEnv.test"], ["", "def", "main", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "setup", "(", "args", ")", "\n", "\n", "if", "args", ".", "eval_only", ":", "\n", "        ", "model", "=", "Trainer", ".", "build_model", "(", "cfg", ")", "\n", "DetectionCheckpointer", "(", "\n", "model", ",", "save_dir", "=", "cfg", ".", "OUTPUT_DIR", ")", ".", "resume_or_load", "(", "\n", "cfg", ".", "MODEL", ".", "WEIGHTS", ",", "resume", "=", "args", ".", "resume", ")", "\n", "res", "=", "Trainer", ".", "test", "(", "cfg", ",", "model", ")", "\n", "return", "res", "\n", "\n", "", "trainer", "=", "Trainer", "(", "cfg", ")", "\n", "trainer", ".", "resume_or_load", "(", "resume", "=", "args", ".", "resume", ")", "\n", "return", "trainer", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.detection.setup.get_version": [[18, 39], ["os.path.join", "open().readlines", "[].strip().strip", "os.getenv", "os.path.abspath", "os.getenv", "datetime.today().strftime", "new_init_py.append", "os.path.dirname", "open", "l.strip", "[].strip", "open", "f.write", "l.startswith", "datetime.today", "l.startswith", "version_line.split"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write"], ["if", "PATCH", "!=", "''", ":", "\n", "    ", "SHORT_VERSION", "=", "'{}.{}.{}{}'", ".", "format", "(", "MAJOR", ",", "MINOR", ",", "PATCH", ",", "SUFFIX", ")", "\n", "", "else", ":", "\n", "    ", "SHORT_VERSION", "=", "'{}.{}{}'", ".", "format", "(", "MAJOR", ",", "MINOR", ",", "SUFFIX", ")", "\n", "\n", "", "version_file", "=", "'openselfsup/version.py'", "\n", "\n", "\n", "def", "get_git_hash", "(", ")", ":", "\n", "\n", "    ", "def", "_minimal_ext_cmd", "(", "cmd", ")", ":", "\n", "# construct minimal environment", "\n", "        ", "env", "=", "{", "}", "\n", "for", "k", "in", "[", "'SYSTEMROOT'", ",", "'PATH'", ",", "'HOME'", "]", ":", "\n", "            ", "v", "=", "os", ".", "environ", ".", "get", "(", "k", ")", "\n", "if", "v", "is", "not", "None", ":", "\n", "                ", "env", "[", "k", "]", "=", "v", "\n", "# LANGUAGE is used on win32", "\n", "", "", "env", "[", "'LANGUAGE'", "]", "=", "'C'", "\n", "env", "[", "'LANG'", "]", "=", "'C'", "\n", "env", "[", "'LC_ALL'", "]", "=", "'C'", "\n", "out", "=", "subprocess", ".", "Popen", "(", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.detection.setup.get_extensions": [[41, 138], ["os.path.dirname", "os.path.join", "os.path.join", "glob.glob", "os.path.abspath", "os.path.join", "torch.utils.hipify.hipify_python.hipify", "shutil.copy", "shutil.copy", "os.environ.get", "extension", "glob.glob", "glob.glob", "glob.glob", "glob.glob", "torch.cuda.is_available", "os.getenv", "extra_compile_args[].append", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "s.endswith"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["return", "out", "\n", "\n", "", "try", ":", "\n", "        ", "out", "=", "_minimal_ext_cmd", "(", "[", "'git'", ",", "'rev-parse'", ",", "'HEAD'", "]", ")", "\n", "sha", "=", "out", ".", "strip", "(", ")", ".", "decode", "(", "'ascii'", ")", "\n", "", "except", "OSError", ":", "\n", "        ", "sha", "=", "'unknown'", "\n", "\n", "", "return", "sha", "\n", "\n", "\n", "", "def", "get_hash", "(", ")", ":", "\n", "    ", "if", "os", ".", "path", ".", "exists", "(", "'.git'", ")", ":", "\n", "        ", "sha", "=", "get_git_hash", "(", ")", "[", ":", "7", "]", "\n", "", "elif", "os", ".", "path", ".", "exists", "(", "version_file", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "from", "openselfsup", ".", "version", "import", "__version__", "\n", "sha", "=", "__version__", ".", "split", "(", "'+'", ")", "[", "-", "1", "]", "\n", "", "except", "ImportError", ":", "\n", "            ", "raise", "ImportError", "(", "'Unable to get git version'", ")", "\n", "", "", "else", ":", "\n", "        ", "sha", "=", "'unknown'", "\n", "\n", "", "return", "sha", "\n", "\n", "\n", "", "def", "write_version_py", "(", ")", ":", "\n", "    ", "content", "=", "\"\"\"# GENERATED VERSION FILE\n# TIME: {}\n\n__version__ = '{}'\nshort_version = '{}'\n\"\"\"", "\n", "sha", "=", "get_hash", "(", ")", "\n", "VERSION", "=", "SHORT_VERSION", "+", "'+'", "+", "sha", "\n", "\n", "with", "open", "(", "version_file", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "content", ".", "format", "(", "time", ".", "asctime", "(", ")", ",", "VERSION", ",", "SHORT_VERSION", ")", ")", "\n", "\n", "\n", "", "", "def", "get_version", "(", ")", ":", "\n", "    ", "with", "open", "(", "version_file", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "exec", "(", "compile", "(", "f", ".", "read", "(", ")", ",", "version_file", ",", "'exec'", ")", ")", "\n", "", "return", "locals", "(", ")", "[", "'__version__'", "]", "\n", "\n", "\n", "", "def", "parse_requirements", "(", "fname", "=", "'requirements.txt'", ",", "with_version", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Parse the package dependencies listed in a requirements file but strips\n    specific versioning information.\n\n    Args:\n        fname (str): path to requirements file\n        with_version (bool, default=False): if True include version specs\n\n    Returns:\n        List[str]: list of requirements items\n\n    CommandLine:\n        python -c \"import setup; print(setup.parse_requirements())\"\n    \"\"\"", "\n", "import", "sys", "\n", "from", "os", ".", "path", "import", "exists", "\n", "import", "re", "\n", "require_fpath", "=", "fname", "\n", "\n", "def", "parse_line", "(", "line", ")", ":", "\n", "        ", "\"\"\"\n        Parse information from a line in a requirements text file\n        \"\"\"", "\n", "if", "line", ".", "startswith", "(", "'-r '", ")", ":", "\n", "# Allow specifying requirements in other files", "\n", "            ", "target", "=", "line", ".", "split", "(", "' '", ")", "[", "1", "]", "\n", "for", "info", "in", "parse_require_file", "(", "target", ")", ":", "\n", "                ", "yield", "info", "\n", "", "", "else", ":", "\n", "            ", "info", "=", "{", "'line'", ":", "line", "}", "\n", "if", "line", ".", "startswith", "(", "'-e '", ")", ":", "\n", "                ", "info", "[", "'package'", "]", "=", "line", ".", "split", "(", "'#egg='", ")", "[", "1", "]", "\n", "", "else", ":", "\n", "# Remove versioning from the package", "\n", "                ", "pat", "=", "'('", "+", "'|'", ".", "join", "(", "[", "'>='", ",", "'=='", ",", "'>'", "]", ")", "+", "')'", "\n", "parts", "=", "re", ".", "split", "(", "pat", ",", "line", ",", "maxsplit", "=", "1", ")", "\n", "parts", "=", "[", "p", ".", "strip", "(", ")", "for", "p", "in", "parts", "]", "\n", "\n", "info", "[", "'package'", "]", "=", "parts", "[", "0", "]", "\n", "if", "len", "(", "parts", ")", ">", "1", ":", "\n", "                    ", "op", ",", "rest", "=", "parts", "[", "1", ":", "]", "\n", "if", "';'", "in", "rest", ":", "\n", "# Handle platform specific dependencies", "\n", "# http://setuptools.readthedocs.io/en/latest/setuptools.html#declaring-platform-specific-dependencies", "\n", "                        ", "version", ",", "platform_deps", "=", "map", "(", "str", ".", "strip", ",", "\n", "rest", ".", "split", "(", "';'", ")", ")", "\n", "info", "[", "'platform_deps'", "]", "=", "platform_deps", "\n", "", "else", ":", "\n", "                        ", "version", "=", "rest", "# NOQA", "\n", "", "info", "[", "'version'", "]", "=", "(", "op", ",", "version", ")", "\n", "", "", "yield", "info", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.detection.setup.get_model_zoo_configs": [[140, 169], ["os.path.join", "os.path.join", "os.path.exists", "glob.glob", "os.path.dirname", "os.path.dirname", "os.path.islink", "os.path.exists", "os.path.realpath", "os.path.realpath", "os.unlink", "os.path.isdir", "os.symlink", "shutil.rmtree", "shutil.copytree"], "function", ["None"], ["", "", "def", "parse_require_file", "(", "fpath", ")", ":", "\n", "        ", "with", "open", "(", "fpath", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ".", "readlines", "(", ")", ":", "\n", "                ", "line", "=", "line", ".", "strip", "(", ")", "\n", "if", "line", "and", "not", "line", ".", "startswith", "(", "'#'", ")", ":", "\n", "                    ", "for", "info", "in", "parse_line", "(", "line", ")", ":", "\n", "                        ", "yield", "info", "\n", "\n", "", "", "", "", "", "def", "gen_packages_items", "(", ")", ":", "\n", "        ", "if", "exists", "(", "require_fpath", ")", ":", "\n", "            ", "for", "info", "in", "parse_require_file", "(", "require_fpath", ")", ":", "\n", "                ", "parts", "=", "[", "info", "[", "'package'", "]", "]", "\n", "if", "with_version", "and", "'version'", "in", "info", ":", "\n", "                    ", "parts", ".", "extend", "(", "info", "[", "'version'", "]", ")", "\n", "", "if", "not", "sys", ".", "version", ".", "startswith", "(", "'3.4'", ")", ":", "\n", "# apparently package_deps are broken in 3.4", "\n", "                    ", "platform_deps", "=", "info", ".", "get", "(", "'platform_deps'", ")", "\n", "if", "platform_deps", "is", "not", "None", ":", "\n", "                        ", "parts", ".", "append", "(", "';'", "+", "platform_deps", ")", "\n", "", "", "item", "=", "''", ".", "join", "(", "parts", ")", "\n", "yield", "item", "\n", "\n", "", "", "", "packages", "=", "list", "(", "gen_packages_items", "(", ")", ")", "\n", "return", "packages", "\n", "\n", "\n", "", "if", "__name__", "==", "'__main__'", ":", "\n", "    ", "write_version_py", "(", ")", "\n", "setup", "(", "\n", "name", "=", "'openselfsup'", ",", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.packaging.gen_install_table.gen_header": [[13, 18], ["None"], "function", ["None"], ["def", "gen_header", "(", "torch_versions", ")", ":", "\n", "    ", "return", "'<table class=\"docutils\"><tbody><th width=\"80\"> CUDA </th>'", "+", "\"\"", ".", "join", "(", "\n", "[", "\n", "'<th valign=\"bottom\" align=\"left\" width=\"100\">torch {}</th>'", ".", "format", "(", "t", ")", "\n", "for", "t", "in", "torch_versions", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.prepare_ade20k_sem_seg.convert": [[11, 16], ["numpy.asarray", "PIL.Image.fromarray().save", "PIL.Image.open", "PIL.Image.fromarray"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save"], ["def", "convert", "(", "input", ",", "output", ")", ":", "\n", "    ", "img", "=", "np", ".", "asarray", "(", "Image", ".", "open", "(", "input", ")", ")", "\n", "assert", "img", ".", "dtype", "==", "np", ".", "uint8", "\n", "img", "=", "img", "-", "1", "# 0 (ignore) becomes 255. others are shifted by 1", "\n", "Image", ".", "fromarray", "(", "img", ")", ".", "save", "(", "output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.prepare_cocofied_lvis.cocofy_lvis": [[96, 167], ["json.load.pop", "copy.deepcopy", "set", "collections.defaultdict", "set", "print", "open", "json.load", "synset_to_coco_cat_id.keys", "copy.deepcopy", "new_annos.append", "set.keys", "copy.deepcopy", "new_categories.append", "open", "json.dump", "new_category_list.append"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.dump"], ["def", "cocofy_lvis", "(", "input_filename", ",", "output_filename", ")", ":", "\n", "    ", "\"\"\"\n    Filter LVIS instance segmentation annotations to remove all categories that are not included in\n    COCO. The new json files can be used to evaluate COCO AP using `lvis-api`. The category ids in\n    the output json are the incontiguous COCO dataset ids.\n\n    Args:\n        input_filename (str): path to the LVIS json file.\n        output_filename (str): path to the COCOfied json file.\n    \"\"\"", "\n", "\n", "with", "open", "(", "input_filename", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "lvis_json", "=", "json", ".", "load", "(", "f", ")", "\n", "\n", "", "lvis_annos", "=", "lvis_json", ".", "pop", "(", "\"annotations\"", ")", "\n", "cocofied_lvis", "=", "copy", ".", "deepcopy", "(", "lvis_json", ")", "\n", "lvis_json", "[", "\"annotations\"", "]", "=", "lvis_annos", "\n", "\n", "# Mapping from lvis cat id to coco cat id via synset", "\n", "lvis_cat_id_to_synset", "=", "{", "cat", "[", "\"id\"", "]", ":", "cat", "[", "\"synset\"", "]", "for", "cat", "in", "lvis_json", "[", "\"categories\"", "]", "}", "\n", "synset_to_coco_cat_id", "=", "{", "x", "[", "\"synset\"", "]", ":", "x", "[", "\"coco_cat_id\"", "]", "for", "x", "in", "COCO_SYNSET_CATEGORIES", "}", "\n", "# Synsets that we will keep in the dataset", "\n", "synsets_to_keep", "=", "set", "(", "synset_to_coco_cat_id", ".", "keys", "(", ")", ")", "\n", "coco_cat_id_with_instances", "=", "defaultdict", "(", "int", ")", "\n", "\n", "new_annos", "=", "[", "]", "\n", "ann_id", "=", "1", "\n", "for", "ann", "in", "lvis_annos", ":", "\n", "        ", "lvis_cat_id", "=", "ann", "[", "\"category_id\"", "]", "\n", "synset", "=", "lvis_cat_id_to_synset", "[", "lvis_cat_id", "]", "\n", "if", "synset", "not", "in", "synsets_to_keep", ":", "\n", "            ", "continue", "\n", "", "coco_cat_id", "=", "synset_to_coco_cat_id", "[", "synset", "]", "\n", "new_ann", "=", "copy", ".", "deepcopy", "(", "ann", ")", "\n", "new_ann", "[", "\"category_id\"", "]", "=", "coco_cat_id", "\n", "new_ann", "[", "\"id\"", "]", "=", "ann_id", "\n", "ann_id", "+=", "1", "\n", "new_annos", ".", "append", "(", "new_ann", ")", "\n", "coco_cat_id_with_instances", "[", "coco_cat_id", "]", "+=", "1", "\n", "", "cocofied_lvis", "[", "\"annotations\"", "]", "=", "new_annos", "\n", "\n", "for", "image", "in", "cocofied_lvis", "[", "\"images\"", "]", ":", "\n", "        ", "for", "key", "in", "[", "\"not_exhaustive_category_ids\"", ",", "\"neg_category_ids\"", "]", ":", "\n", "            ", "new_category_list", "=", "[", "]", "\n", "for", "lvis_cat_id", "in", "image", "[", "key", "]", ":", "\n", "                ", "synset", "=", "lvis_cat_id_to_synset", "[", "lvis_cat_id", "]", "\n", "if", "synset", "not", "in", "synsets_to_keep", ":", "\n", "                    ", "continue", "\n", "", "coco_cat_id", "=", "synset_to_coco_cat_id", "[", "synset", "]", "\n", "new_category_list", ".", "append", "(", "coco_cat_id", ")", "\n", "coco_cat_id_with_instances", "[", "coco_cat_id", "]", "+=", "1", "\n", "", "image", "[", "key", "]", "=", "new_category_list", "\n", "\n", "", "", "coco_cat_id_with_instances", "=", "set", "(", "coco_cat_id_with_instances", ".", "keys", "(", ")", ")", "\n", "\n", "new_categories", "=", "[", "]", "\n", "for", "cat", "in", "lvis_json", "[", "\"categories\"", "]", ":", "\n", "        ", "synset", "=", "cat", "[", "\"synset\"", "]", "\n", "if", "synset", "not", "in", "synsets_to_keep", ":", "\n", "            ", "continue", "\n", "", "coco_cat_id", "=", "synset_to_coco_cat_id", "[", "synset", "]", "\n", "if", "coco_cat_id", "not", "in", "coco_cat_id_with_instances", ":", "\n", "            ", "continue", "\n", "", "new_cat", "=", "copy", ".", "deepcopy", "(", "cat", ")", "\n", "new_cat", "[", "\"id\"", "]", "=", "coco_cat_id", "\n", "new_categories", ".", "append", "(", "new_cat", ")", "\n", "", "cocofied_lvis", "[", "\"categories\"", "]", "=", "new_categories", "\n", "\n", "with", "open", "(", "output_filename", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "json", ".", "dump", "(", "cocofied_lvis", ",", "f", ")", "\n", "", "print", "(", "\"{} is COCOfied and stored in {}.\"", ".", "format", "(", "input_filename", ",", "output_filename", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.prepare_panoptic_fpn._process_panoptic_to_semantic": [[18, 27], ["numpy.asarray", "panopticapi.utils.rgb2id", "PIL.Image.fromarray().save", "PIL.Image.open", "numpy.zeros_like", "PIL.Image.fromarray"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save"], ["def", "_process_panoptic_to_semantic", "(", "input_panoptic", ",", "output_semantic", ",", "segments", ",", "id_map", ")", ":", "\n", "    ", "panoptic", "=", "np", ".", "asarray", "(", "Image", ".", "open", "(", "input_panoptic", ")", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "panoptic", "=", "rgb2id", "(", "panoptic", ")", "\n", "output", "=", "np", ".", "zeros_like", "(", "panoptic", ",", "dtype", "=", "np", ".", "uint8", ")", "+", "255", "\n", "for", "seg", "in", "segments", ":", "\n", "        ", "cat_id", "=", "seg", "[", "\"category_id\"", "]", "\n", "new_cat_id", "=", "id_map", "[", "cat_id", "]", "\n", "output", "[", "panoptic", "==", "seg", "[", "\"id\"", "]", "]", "=", "new_cat_id", "\n", "", "Image", ".", "fromarray", "(", "output", ")", ".", "save", "(", "output_semantic", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.prepare_panoptic_fpn.separate_coco_semantic_from_panoptic": [[29, 78], ["os.makedirs", "enumerate", "multiprocessing.Pool", "print", "time.time", "mp.Pool.starmap", "print", "len", "open", "json.load", "functools.partial", "prepare_panoptic_fpn.separate_coco_semantic_from_panoptic.iter_annotations"], "function", ["None"], ["", "def", "separate_coco_semantic_from_panoptic", "(", "panoptic_json", ",", "panoptic_root", ",", "sem_seg_root", ",", "categories", ")", ":", "\n", "    ", "\"\"\"\n    Create semantic segmentation annotations from panoptic segmentation\n    annotations, to be used by PanopticFPN.\n\n    It maps all thing categories to class 0, and maps all unlabeled pixels to class 255.\n    It maps all stuff categories to contiguous ids starting from 1.\n\n    Args:\n        panoptic_json (str): path to the panoptic json file, in COCO's format.\n        panoptic_root (str): a directory with panoptic annotation files, in COCO's format.\n        sem_seg_root (str): a directory to output semantic annotation files\n        categories (list[dict]): category metadata. Each dict needs to have:\n            \"id\": corresponds to the \"category_id\" in the json annotations\n            \"isthing\": 0 or 1\n    \"\"\"", "\n", "os", ".", "makedirs", "(", "sem_seg_root", ",", "exist_ok", "=", "True", ")", "\n", "\n", "stuff_ids", "=", "[", "k", "[", "\"id\"", "]", "for", "k", "in", "categories", "if", "k", "[", "\"isthing\"", "]", "==", "0", "]", "\n", "thing_ids", "=", "[", "k", "[", "\"id\"", "]", "for", "k", "in", "categories", "if", "k", "[", "\"isthing\"", "]", "==", "1", "]", "\n", "id_map", "=", "{", "}", "# map from category id to id in the output semantic annotation", "\n", "assert", "len", "(", "stuff_ids", ")", "<=", "254", "\n", "for", "i", ",", "stuff_id", "in", "enumerate", "(", "stuff_ids", ")", ":", "\n", "        ", "id_map", "[", "stuff_id", "]", "=", "i", "+", "1", "\n", "", "for", "thing_id", "in", "thing_ids", ":", "\n", "        ", "id_map", "[", "thing_id", "]", "=", "0", "\n", "", "id_map", "[", "0", "]", "=", "255", "\n", "\n", "with", "open", "(", "panoptic_json", ")", "as", "f", ":", "\n", "        ", "obj", "=", "json", ".", "load", "(", "f", ")", "\n", "\n", "", "pool", "=", "mp", ".", "Pool", "(", "processes", "=", "max", "(", "mp", ".", "cpu_count", "(", ")", "//", "2", ",", "4", ")", ")", "\n", "\n", "def", "iter_annotations", "(", ")", ":", "\n", "        ", "for", "anno", "in", "obj", "[", "\"annotations\"", "]", ":", "\n", "            ", "file_name", "=", "anno", "[", "\"file_name\"", "]", "\n", "segments", "=", "anno", "[", "\"segments_info\"", "]", "\n", "input", "=", "os", ".", "path", ".", "join", "(", "panoptic_root", ",", "file_name", ")", "\n", "output", "=", "os", ".", "path", ".", "join", "(", "sem_seg_root", ",", "file_name", ")", "\n", "yield", "input", ",", "output", ",", "segments", "\n", "\n", "", "", "print", "(", "\"Start writing to {} ...\"", ".", "format", "(", "sem_seg_root", ")", ")", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "pool", ".", "starmap", "(", "\n", "functools", ".", "partial", "(", "_process_panoptic_to_semantic", ",", "id_map", "=", "id_map", ")", ",", "\n", "iter_annotations", "(", ")", ",", "\n", "chunksize", "=", "100", ",", "\n", ")", "\n", "print", "(", "\"Finished. time: {:.2f}s\"", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.base.BaseDataset.__init__": [[24, 29], ["builder.build_datasource", "torchvision.transforms.Compose", "base.BaseDataset.utils.build_from_cfg"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.builder.build_datasource", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.registry.build_from_cfg"], ["\n", "\n", "if", "converter", "is", "not", "None", ":", "\n", "            ", "cls", ".", "_do_register", "(", "from_type", ",", "converter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.base.BaseDataset.__len__": [[30, 32], ["base.BaseDataset.data_source.get_length"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list_multihead.ImageListMultihead.get_length"], ["", "def", "wrapper", "(", "converter", ":", "Any", ")", "->", "Any", ":", "\n", "            ", "cls", ".", "_do_register", "(", "from_type", ",", "converter", ")", "\n", "return", "converter", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.base.BaseDataset.__getitem__": [[33, 36], ["None"], "methods", ["None"], ["\n", "", "return", "wrapper", "\n", "\n", "", "@", "classmethod", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.base.BaseDataset.evaluate": [[37, 40], ["None"], "methods", ["None"], ["def", "_do_register", "(", "cls", ",", "from_type", ":", "Type", ",", "converter", ":", "Any", ")", ":", "\n", "        ", "cls", ".", "registry", "[", "from_type", "]", "=", "converter", "\n", "\n", "", "@", "classmethod", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.npid.NPIDDataset.__init__": [[11, 13], ["base.BaseDataset.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "data_source", ",", "pipeline", ")", ":", "\n", "        ", "super", "(", "NPIDDataset", ",", "self", ")", ".", "__init__", "(", "data_source", ",", "pipeline", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.npid.NPIDDataset.__getitem__": [[14, 22], ["npid.NPIDDataset.data_source.get_sample", "isinstance", "npid.NPIDDataset.pipeline", "dict", "type"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list_multihead.ImageListMultihead.get_sample"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "img", "=", "self", ".", "data_source", ".", "get_sample", "(", "idx", ")", "\n", "assert", "isinstance", "(", "img", ",", "Image", ".", "Image", ")", ",", "'The output from the data source must be an Image, got: {}. \\\n            Please ensure that the list file does not contain labels.'", ".", "format", "(", "\n", "type", "(", "img", ")", ")", "\n", "img", "=", "self", ".", "pipeline", "(", "img", ")", "\n", "return", "dict", "(", "img", "=", "img", ",", "idx", "=", "idx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.npid.NPIDDataset.evaluate": [[23, 26], ["None"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "scores", ",", "keyword", ",", "logger", "=", "None", ")", ":", "\n", "\n", "        ", "raise", "NotImplemented", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.rotation_pred.RotationPredDataset.__init__": [[30, 32], ["base.BaseDataset.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "data_source", ",", "pipeline", ")", ":", "\n", "        ", "super", "(", "RotationPredDataset", ",", "self", ")", ".", "__init__", "(", "data_source", ",", "pipeline", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.rotation_pred.RotationPredDataset.__getitem__": [[33, 43], ["rotation_pred.RotationPredDataset.data_source.get_sample", "isinstance", "rotation_pred.RotationPredDataset.pipeline", "torch.stack", "torch.LongTensor", "dict", "type", "rotation_pred.rotate"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list_multihead.ImageListMultihead.get_sample", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.rotation_pred.rotate"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "img", "=", "self", ".", "data_source", ".", "get_sample", "(", "idx", ")", "\n", "assert", "isinstance", "(", "img", ",", "Image", ".", "Image", ")", ",", "'The output from the data source must be an Image, got: {}. \\\n            Please ensure that the list file does not contain labels.'", ".", "format", "(", "\n", "type", "(", "img", ")", ")", "\n", "img", "=", "self", ".", "pipeline", "(", "img", ")", "\n", "img", "=", "torch", ".", "stack", "(", "rotate", "(", "img", ")", ",", "dim", "=", "0", ")", "\n", "rotation_labels", "=", "torch", ".", "LongTensor", "(", "[", "0", ",", "1", ",", "2", ",", "3", "]", ")", "\n", "return", "dict", "(", "img", "=", "img", ",", "rot_label", "=", "rotation_labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.rotation_pred.RotationPredDataset.evaluate": [[44, 46], ["None"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "scores", ",", "keyword", ",", "logger", "=", "None", ")", ":", "\n", "        ", "raise", "NotImplemented", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.rotation_pred.rotate": [[8, 22], ["torch.flip", "torch.flip", "torch.flip().transpose", "img.transpose", "torch.flip"], "function", ["None"], ["def", "rotate", "(", "img", ")", ":", "\n", "    ", "\"\"\"Rotate input image with 0, 90, 180, and 270 degrees.\n\n    Args:\n        img (Tensor): input image of shape (C, H, W).\n\n    Returns:\n        list[Tensor]: A list of four rotated images.\n    \"\"\"", "\n", "return", "[", "\n", "img", ",", "\n", "torch", ".", "flip", "(", "img", ".", "transpose", "(", "1", ",", "2", ")", ",", "[", "1", "]", ")", ",", "\n", "torch", ".", "flip", "(", "img", ",", "[", "1", ",", "2", "]", ")", ",", "\n", "torch", ".", "flip", "(", "img", ",", "[", "1", "]", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.auroc.AUROCDataset.__init__": [[14, 16], ["base.BaseDataset.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "data_source", ",", "pipeline", ")", ":", "\n", "        ", "super", "(", "AUROCDataset", ",", "self", ")", ".", "__init__", "(", "data_source", ",", "pipeline", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.auroc.AUROCDataset.__getitem__": [[17, 21], ["models.utils.auroc.AUROCDataset.data_source.get_sample", "models.utils.auroc.AUROCDataset.pipeline", "dict"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list_multihead.ImageListMultihead.get_sample"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "img", ",", "target", "=", "self", ".", "data_source", ".", "get_sample", "(", "idx", ")", "\n", "img", "=", "self", ".", "pipeline", "(", "img", ")", "\n", "return", "dict", "(", "img", "=", "img", ",", "gt_label", "=", "target", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.auroc.AUROCDataset.evaluate": [[22, 36], ["torch.cat().reshape", "models.utils.auroc().cpu", "range", "len", "aurocs[].item", "torch.cat", "models.utils.auroc", "auroc.AUROCDataset.utils.print_log"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.accuracy.auroc", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.print_log"], ["", "def", "evaluate", "(", "self", ",", "scores", ",", "keyword", ",", "logger", "=", "None", ")", ":", "\n", "\n", "        ", "eval_res", "=", "{", "}", "\n", "target", "=", "torch", ".", "cat", "(", "self", ".", "data_source", ".", "labels", ")", ".", "reshape", "(", "scores", ".", "shape", ")", "\n", "\n", "aurocs", "=", "auroc", "(", "scores", ",", "target", ")", ".", "cpu", "(", ")", "\n", "for", "ii", "in", "range", "(", "len", "(", "aurocs", ")", ")", ":", "\n", "            ", "res", "=", "aurocs", "[", "ii", "]", ".", "item", "(", ")", "\n", "eval_res", "[", "\"auroc_{}\"", ".", "format", "(", "ii", ")", "]", "=", "res", "\n", "if", "logger", "is", "not", "None", "and", "logger", "!=", "'silent'", ":", "\n", "                ", "print_log", "(", "\n", "\"auroc_{}: {:.03f}\"", ".", "format", "(", "ii", ",", "res", ")", ",", "\n", "logger", "=", "logger", ")", "\n", "", "", "return", "eval_res", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.builder._concat_dataset": [[8, 28], ["cfg.get", "cfg.get", "cfg.get", "len", "range", "dataset_wrappers.ConcatDataset", "copy.deepcopy", "isinstance", "isinstance", "isinstance", "datasets.append", "builder.build_dataset"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.builder.build_dataset"], ["def", "_concat_dataset", "(", "cfg", ",", "default_args", "=", "None", ")", ":", "\n", "    ", "ann_files", "=", "cfg", "[", "'ann_file'", "]", "\n", "img_prefixes", "=", "cfg", ".", "get", "(", "'img_prefix'", ",", "None", ")", "\n", "seg_prefixes", "=", "cfg", ".", "get", "(", "'seg_prefix'", ",", "None", ")", "\n", "proposal_files", "=", "cfg", ".", "get", "(", "'proposal_file'", ",", "None", ")", "\n", "\n", "datasets", "=", "[", "]", "\n", "num_dset", "=", "len", "(", "ann_files", ")", "\n", "for", "i", "in", "range", "(", "num_dset", ")", ":", "\n", "        ", "data_cfg", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "data_cfg", "[", "'ann_file'", "]", "=", "ann_files", "[", "i", "]", "\n", "if", "isinstance", "(", "img_prefixes", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "data_cfg", "[", "'img_prefix'", "]", "=", "img_prefixes", "[", "i", "]", "\n", "", "if", "isinstance", "(", "seg_prefixes", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "data_cfg", "[", "'seg_prefix'", "]", "=", "seg_prefixes", "[", "i", "]", "\n", "", "if", "isinstance", "(", "proposal_files", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "data_cfg", "[", "'proposal_file'", "]", "=", "proposal_files", "[", "i", "]", "\n", "", "datasets", ".", "append", "(", "build_dataset", "(", "data_cfg", ",", "default_args", ")", ")", "\n", "\n", "", "return", "ConcatDataset", "(", "datasets", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.builder.build_dataset": [[30, 40], ["isinstance", "dataset_wrappers.ConcatDataset", "dataset_wrappers.RepeatDataset", "openselfsup.utils.build_from_cfg", "builder.build_dataset", "builder.build_dataset"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.registry.build_from_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.builder.build_dataset", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.builder.build_dataset"], ["", "def", "build_dataset", "(", "cfg", ",", "default_args", "=", "None", ")", ":", "\n", "    ", "if", "isinstance", "(", "cfg", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "dataset", "=", "ConcatDataset", "(", "[", "build_dataset", "(", "c", ",", "default_args", ")", "for", "c", "in", "cfg", "]", ")", "\n", "", "elif", "cfg", "[", "'type'", "]", "==", "'RepeatDataset'", ":", "\n", "        ", "dataset", "=", "RepeatDataset", "(", "\n", "build_dataset", "(", "cfg", "[", "'dataset'", "]", ",", "default_args", ")", ",", "cfg", "[", "'times'", "]", ")", "\n", "", "else", ":", "\n", "        ", "dataset", "=", "build_from_cfg", "(", "cfg", ",", "DATASETS", ",", "default_args", ")", "\n", "\n", "", "return", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.builder.build_datasource": [[42, 44], ["openselfsup.utils.build_from_cfg"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.registry.build_from_cfg"], ["", "def", "build_datasource", "(", "cfg", ")", ":", "\n", "    ", "return", "build_from_cfg", "(", "cfg", ",", "DATASOURCES", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.deepcluster.DeepClusterDataset.__init__": [[11, 15], ["base.BaseDataset.__init__", "range", "deepcluster.DeepClusterDataset.data_source.get_length"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list_multihead.ImageListMultihead.get_length"], ["def", "__init__", "(", "self", ",", "data_source", ",", "pipeline", ")", ":", "\n", "        ", "super", "(", "DeepClusterDataset", ",", "self", ")", ".", "__init__", "(", "data_source", ",", "pipeline", ")", "\n", "# init clustering labels", "\n", "self", ".", "labels", "=", "[", "-", "1", "for", "_", "in", "range", "(", "self", ".", "data_source", ".", "get_length", "(", ")", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.deepcluster.DeepClusterDataset.__getitem__": [[16, 25], ["deepcluster.DeepClusterDataset.data_source.get_sample", "isinstance", "deepcluster.DeepClusterDataset.pipeline", "dict", "type"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list_multihead.ImageListMultihead.get_sample"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "img", "=", "self", ".", "data_source", ".", "get_sample", "(", "idx", ")", "\n", "assert", "isinstance", "(", "img", ",", "Image", ".", "Image", ")", ",", "'The output from the data source must be an Image, got: {}. \\\n            Please ensure that the list file does not contain labels.'", ".", "format", "(", "\n", "type", "(", "img", ")", ")", "\n", "label", "=", "self", ".", "labels", "[", "idx", "]", "\n", "img", "=", "self", ".", "pipeline", "(", "img", ")", "\n", "return", "dict", "(", "img", "=", "img", ",", "pseudo_label", "=", "label", ",", "idx", "=", "idx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.deepcluster.DeepClusterDataset.assign_labels": [[26, 31], ["len", "len", "len", "len"], "methods", ["None"], ["", "def", "assign_labels", "(", "self", ",", "labels", ")", ":", "\n", "        ", "assert", "len", "(", "self", ".", "labels", ")", "==", "len", "(", "labels", ")", ",", "\"Inconsistent lenght of asigned labels, \\\n            {} vs {}\"", ".", "format", "(", "len", "(", "self", ".", "labels", ")", ",", "len", "(", "labels", ")", ")", "\n", "self", ".", "labels", "=", "labels", "[", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.deepcluster.DeepClusterDataset.evaluate": [[32, 35], ["None"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "scores", ",", "keyword", ",", "logger", "=", "None", ")", ":", "\n", "\n", "        ", "raise", "NotImplemented", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.contrastive.ContrastiveDataset.__init__": [[14, 17], ["base.BaseDataset.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "data_source", ",", "pipeline", ",", "prefetch", "=", "False", ")", ":", "\n", "        ", "data_source", "[", "'return_label'", "]", "=", "False", "\n", "super", "(", "ContrastiveDataset", ",", "self", ")", ".", "__init__", "(", "data_source", ",", "pipeline", ",", "prefetch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.contrastive.ContrastiveDataset.__getitem__": [[18, 31], ["contrastive.ContrastiveDataset.data_source.get_sample", "isinstance", "contrastive.ContrastiveDataset.pipeline", "contrastive.ContrastiveDataset.pipeline", "torch.cat", "dict", "type", "torch.from_numpy", "torch.from_numpy", "utils.to_numpy", "utils.to_numpy", "torch.from_numpy.unsqueeze", "torch.from_numpy.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list_multihead.ImageListMultihead.get_sample", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.utils.to_numpy", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.utils.to_numpy"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "img", "=", "self", ".", "data_source", ".", "get_sample", "(", "idx", ")", "\n", "assert", "isinstance", "(", "img", ",", "Image", ".", "Image", ")", ",", "'The output from the data source must be an Image, got: {}. \\\n            Please ensure that the list file does not contain labels.'", ".", "format", "(", "\n", "type", "(", "img", ")", ")", "\n", "img1", "=", "self", ".", "pipeline", "(", "img", ")", "\n", "img2", "=", "self", ".", "pipeline", "(", "img", ")", "\n", "if", "self", ".", "prefetch", ":", "\n", "            ", "img1", "=", "torch", ".", "from_numpy", "(", "to_numpy", "(", "img1", ")", ")", "\n", "img2", "=", "torch", ".", "from_numpy", "(", "to_numpy", "(", "img2", ")", ")", "\n", "", "img_cat", "=", "torch", ".", "cat", "(", "(", "img1", ".", "unsqueeze", "(", "0", ")", ",", "img2", ".", "unsqueeze", "(", "0", ")", ")", ",", "dim", "=", "0", ")", "\n", "return", "dict", "(", "img", "=", "img_cat", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.contrastive.ContrastiveDataset.evaluate": [[32, 34], ["None"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "scores", ",", "keyword", ",", "logger", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "raise", "NotImplemented", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.classification.ClassificationDataset.__init__": [[15, 17], ["base.BaseDataset.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "data_source", ",", "pipeline", ",", "prefetch", "=", "False", ")", ":", "\n", "        ", "super", "(", "ClassificationDataset", ",", "self", ")", ".", "__init__", "(", "data_source", ",", "pipeline", ",", "prefetch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.classification.ClassificationDataset.__getitem__": [[18, 24], ["classification.ClassificationDataset.data_source.get_sample", "classification.ClassificationDataset.pipeline", "dict", "torch.from_numpy", "utils.to_numpy"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list_multihead.ImageListMultihead.get_sample", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.utils.to_numpy"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "img", ",", "target", "=", "self", ".", "data_source", ".", "get_sample", "(", "idx", ")", "\n", "img", "=", "self", ".", "pipeline", "(", "img", ")", "\n", "if", "self", ".", "prefetch", ":", "\n", "            ", "img", "=", "torch", ".", "from_numpy", "(", "to_numpy", "(", "img", ")", ")", "\n", "", "return", "dict", "(", "img", "=", "img", ",", "gt_label", "=", "target", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.classification.ClassificationDataset.evaluate": [[25, 45], ["torch.LongTensor", "scores.size", "scores.topk", "pred.t.t.t", "pred.t.t.eq", "scores.size", "torch.LongTensor.size", "scores.size", "torch.LongTensor.size", "max", "torch.LongTensor.view().expand_as", "correct[].view().float().sum().item", "classification.ClassificationDataset.utils.print_log", "torch.LongTensor.view", "correct[].view().float().sum", "correct[].view().float", "correct[].view"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.print_log"], ["", "def", "evaluate", "(", "self", ",", "scores", ",", "keyword", ",", "logger", "=", "None", ",", "topk", "=", "(", "1", ",", "5", ")", ")", ":", "\n", "        ", "eval_res", "=", "{", "}", "\n", "\n", "target", "=", "torch", ".", "LongTensor", "(", "self", ".", "data_source", ".", "labels", ")", "\n", "assert", "scores", ".", "size", "(", "0", ")", "==", "target", ".", "size", "(", "0", ")", ",", "\"Inconsistent length for results and labels, {} vs {}\"", ".", "format", "(", "\n", "scores", ".", "size", "(", "0", ")", ",", "target", ".", "size", "(", "0", ")", ")", "\n", "num", "=", "scores", ".", "size", "(", "0", ")", "\n", "_", ",", "pred", "=", "scores", ".", "topk", "(", "max", "(", "topk", ")", ",", "dim", "=", "1", ",", "largest", "=", "True", ",", "sorted", "=", "True", ")", "\n", "pred", "=", "pred", ".", "t", "(", ")", "\n", "correct", "=", "pred", ".", "eq", "(", "target", ".", "view", "(", "1", ",", "-", "1", ")", ".", "expand_as", "(", "pred", ")", ")", "# KxN", "\n", "for", "k", "in", "topk", ":", "\n", "            ", "correct_k", "=", "correct", "[", ":", "k", "]", ".", "view", "(", "-", "1", ")", ".", "float", "(", ")", ".", "sum", "(", "0", ")", ".", "item", "(", ")", "\n", "acc", "=", "correct_k", "*", "100.0", "/", "num", "\n", "eval_res", "[", "\"{}_top{}\"", ".", "format", "(", "keyword", ",", "k", ")", "]", "=", "acc", "\n", "if", "logger", "is", "not", "None", "and", "logger", "!=", "'silent'", ":", "\n", "                ", "print_log", "(", "\n", "\"{}_top{}: {:.03f}\"", ".", "format", "(", "keyword", ",", "k", ",", "acc", ")", ",", "\n", "logger", "=", "logger", ")", "\n", "", "", "return", "eval_res", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.extraction.ExtractDataset.__init__": [[10, 12], ["base.BaseDataset.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "data_source", ",", "pipeline", ")", ":", "\n", "        ", "super", "(", "ExtractDataset", ",", "self", ")", ".", "__init__", "(", "data_source", ",", "pipeline", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.extraction.ExtractDataset.__getitem__": [[13, 17], ["extraction.ExtractDataset.data_source.get_sample", "extraction.ExtractDataset.pipeline", "dict"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list_multihead.ImageListMultihead.get_sample"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "img", "=", "self", ".", "data_source", ".", "get_sample", "(", "idx", ")", "\n", "img", "=", "self", ".", "pipeline", "(", "img", ")", "\n", "return", "dict", "(", "img", "=", "img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.extraction.ExtractDataset.evaluate": [[18, 20], ["None"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "scores", ",", "keyword", ",", "logger", "=", "None", ")", ":", "\n", "        ", "raise", "NotImplemented", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.dataset_wrappers.ConcatDataset.__init__": [[18, 26], ["torch.utils.data.dataset.ConcatDataset.__init__", "hasattr", "range", "numpy.concatenate", "len", "flags.append"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "datasets", ")", ":", "\n", "        ", "super", "(", "ConcatDataset", ",", "self", ")", ".", "__init__", "(", "datasets", ")", "\n", "self", ".", "CLASSES", "=", "datasets", "[", "0", "]", ".", "CLASSES", "\n", "if", "hasattr", "(", "datasets", "[", "0", "]", ",", "'flag'", ")", ":", "\n", "            ", "flags", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "datasets", ")", ")", ":", "\n", "                ", "flags", ".", "append", "(", "datasets", "[", "i", "]", ".", "flag", ")", "\n", "", "self", ".", "flag", "=", "np", ".", "concatenate", "(", "flags", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.dataset_wrappers.RepeatDataset.__init__": [[42, 50], ["hasattr", "len", "numpy.tile"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "dataset", ",", "times", ")", ":", "\n", "        ", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "times", "=", "times", "\n", "self", ".", "CLASSES", "=", "dataset", ".", "CLASSES", "\n", "if", "hasattr", "(", "self", ".", "dataset", ",", "'flag'", ")", ":", "\n", "            ", "self", ".", "flag", "=", "np", ".", "tile", "(", "self", ".", "dataset", ".", "flag", ",", "times", ")", "\n", "\n", "", "self", ".", "_ori_len", "=", "len", "(", "self", ".", "dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.dataset_wrappers.RepeatDataset.__getitem__": [[51, 53], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "return", "self", ".", "dataset", "[", "idx", "%", "self", ".", "_ori_len", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.dataset_wrappers.RepeatDataset.__len__": [[54, 56], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "times", "*", "self", ".", "_ori_len", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.byol.BYOLDataset.__init__": [[18, 25], ["builder.build_datasource", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "byol.BYOLDataset.utils.build_from_cfg", "byol.BYOLDataset.utils.build_from_cfg"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.builder.build_datasource", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.registry.build_from_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.registry.build_from_cfg"], ["def", "__init__", "(", "self", ",", "data_source", ",", "pipeline1", ",", "pipeline2", ",", "prefetch", "=", "False", ")", ":", "\n", "        ", "self", ".", "data_source", "=", "build_datasource", "(", "data_source", ")", "\n", "pipeline1", "=", "[", "build_from_cfg", "(", "p", ",", "PIPELINES", ")", "for", "p", "in", "pipeline1", "]", "\n", "self", ".", "pipeline1", "=", "Compose", "(", "pipeline1", ")", "\n", "pipeline2", "=", "[", "build_from_cfg", "(", "p", ",", "PIPELINES", ")", "for", "p", "in", "pipeline2", "]", "\n", "self", ".", "pipeline2", "=", "Compose", "(", "pipeline2", ")", "\n", "self", ".", "prefetch", "=", "prefetch", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.byol.BYOLDataset.__len__": [[26, 28], ["byol.BYOLDataset.data_source.get_length"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list_multihead.ImageListMultihead.get_length"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "data_source", ".", "get_length", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.byol.BYOLDataset.__getitem__": [[29, 39], ["byol.BYOLDataset.data_source.get_sample", "byol.BYOLDataset.pipeline1", "byol.BYOLDataset.pipeline2", "torch.cat", "dict", "torch.from_numpy", "torch.from_numpy", "utils.to_numpy", "utils.to_numpy", "torch.from_numpy.unsqueeze", "torch.from_numpy.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list_multihead.ImageListMultihead.get_sample", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.utils.to_numpy", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.utils.to_numpy"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "img", "=", "self", ".", "data_source", ".", "get_sample", "(", "idx", ")", "\n", "img1", "=", "self", ".", "pipeline1", "(", "img", ")", "\n", "img2", "=", "self", ".", "pipeline2", "(", "img", ")", "\n", "if", "self", ".", "prefetch", ":", "\n", "            ", "img1", "=", "torch", ".", "from_numpy", "(", "to_numpy", "(", "img1", ")", ")", "\n", "img2", "=", "torch", ".", "from_numpy", "(", "to_numpy", "(", "img2", ")", ")", "\n", "\n", "", "img_cat", "=", "torch", ".", "cat", "(", "(", "img1", ".", "unsqueeze", "(", "0", ")", ",", "img2", ".", "unsqueeze", "(", "0", ")", ")", ",", "dim", "=", "0", ")", "\n", "return", "dict", "(", "img", "=", "img_cat", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.byol.BYOLDataset.evaluate": [[40, 42], ["None"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "scores", ",", "keyword", ",", "logger", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "raise", "NotImplemented", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.utils.to_numpy": [[4, 10], ["numpy.array", "numpy.rollaxis", "numpy.expand_dims"], "function", ["None"], ["\n", "\n", "def", "initialize_module_params", "(", "module", ":", "nn", ".", "Module", ")", ":", "\n", "    ", "for", "name", ",", "param", "in", "module", ".", "named_parameters", "(", ")", ":", "\n", "        ", "if", "\"bias\"", "in", "name", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "param", ",", "0", ")", "\n", "", "elif", "\"weight\"", "in", "name", ":", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.relative_loc.RelativeLocDataset.__init__": [[43, 47], ["base.BaseDataset.__init__", "torchvision.transforms.Compose", "relative_loc.RelativeLocDataset.utils.build_from_cfg"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.registry.build_from_cfg"], ["def", "__init__", "(", "self", ",", "data_source", ",", "pipeline", ",", "format_pipeline", ")", ":", "\n", "        ", "super", "(", "RelativeLocDataset", ",", "self", ")", ".", "__init__", "(", "data_source", ",", "pipeline", ")", "\n", "format_pipeline", "=", "[", "build_from_cfg", "(", "p", ",", "PIPELINES", ")", "for", "p", "in", "format_pipeline", "]", "\n", "self", ".", "format_pipeline", "=", "Compose", "(", "format_pipeline", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.relative_loc.RelativeLocDataset.__getitem__": [[48, 63], ["relative_loc.RelativeLocDataset.data_source.get_sample", "isinstance", "relative_loc.RelativeLocDataset.pipeline", "relative_loc.image_to_patches", "torch.LongTensor", "dict", "type", "relative_loc.RelativeLocDataset.format_pipeline", "perms.append", "torch.cat", "range", "torch.stack"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list_multihead.ImageListMultihead.get_sample", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.relative_loc.image_to_patches", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "img", "=", "self", ".", "data_source", ".", "get_sample", "(", "idx", ")", "\n", "assert", "isinstance", "(", "img", ",", "Image", ".", "Image", ")", ",", "'The output from the data source must be an Image, got: {}. \\\n            Please ensure that the list file does not contain labels.'", ".", "format", "(", "\n", "type", "(", "img", ")", ")", "\n", "img", "=", "self", ".", "pipeline", "(", "img", ")", "\n", "patches", "=", "image_to_patches", "(", "img", ")", "\n", "patches", "=", "[", "self", ".", "format_pipeline", "(", "p", ")", "for", "p", "in", "patches", "]", "\n", "perms", "=", "[", "]", "\n", "# create a list of patch pairs", "\n", "[", "perms", ".", "append", "(", "torch", ".", "cat", "(", "(", "patches", "[", "i", "]", ",", "patches", "[", "4", "]", ")", ",", "dim", "=", "0", ")", ")", "for", "i", "in", "range", "(", "9", ")", "if", "i", "!=", "4", "]", "\n", "# create corresponding labels for patch pairs", "\n", "patch_labels", "=", "torch", ".", "LongTensor", "(", "[", "0", ",", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", "]", ")", "\n", "return", "dict", "(", "img", "=", "torch", ".", "stack", "(", "perms", ")", ",", "patch_label", "=", "patch_labels", ")", "# 8(2C)HW, 8", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.relative_loc.RelativeLocDataset.evaluate": [[64, 66], ["None"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "scores", ",", "keyword", ",", "logger", "=", "None", ")", ":", "\n", "        ", "raise", "NotImplemented", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.relative_loc.image_to_patches": [[12, 36], ["range", "range", "torchvision.crop", "patches.append", "torchvision.transforms.RandomCrop"], "function", ["None"], ["def", "image_to_patches", "(", "img", ")", ":", "\n", "    ", "\"\"\"Crop split_per_side x split_per_side patches from input image.\n\n    Args:\n        img (PIL Image): input image.\n\n    Returns:\n        list[PIL Image]: A list of cropped patches.\n    \"\"\"", "\n", "split_per_side", "=", "3", "# split of patches per image side", "\n", "patch_jitter", "=", "21", "# jitter of each patch from each grid", "\n", "h", ",", "w", "=", "img", ".", "size", "\n", "h_grid", "=", "h", "//", "split_per_side", "\n", "w_grid", "=", "w", "//", "split_per_side", "\n", "h_patch", "=", "h_grid", "-", "patch_jitter", "\n", "w_patch", "=", "w_grid", "-", "patch_jitter", "\n", "assert", "h_patch", ">", "0", "and", "w_patch", ">", "0", "\n", "patches", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "split_per_side", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "split_per_side", ")", ":", "\n", "            ", "p", "=", "TF", ".", "crop", "(", "img", ",", "i", "*", "h_grid", ",", "j", "*", "w_grid", ",", "h_grid", ",", "w_grid", ")", "\n", "p", "=", "RandomCrop", "(", "(", "h_patch", ",", "w_patch", ")", ")", "(", "p", ")", "\n", "patches", ".", "append", "(", "p", ")", "\n", "", "", "return", "patches", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.demo.demo.setup_cfg": [[20, 34], ["detectron2.config.get_cfg", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze"], ["def", "setup_cfg", "(", "args", ")", ":", "\n", "# load config from file and command-line arguments", "\n", "    ", "cfg", "=", "get_cfg", "(", ")", "\n", "# To use demo for Panoptic-DeepLab, please uncomment the following two lines.", "\n", "# from detectron2.projects.panoptic_deeplab import add_panoptic_deeplab_config  # noqa", "\n", "# add_panoptic_deeplab_config(cfg)", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "# Set score_threshold for builtin models", "\n", "cfg", ".", "MODEL", ".", "RETINANET", ".", "SCORE_THRESH_TEST", "=", "args", ".", "confidence_threshold", "\n", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "SCORE_THRESH_TEST", "=", "args", ".", "confidence_threshold", "\n", "cfg", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", ".", "INSTANCES_CONFIDENCE_THRESH", "=", "args", ".", "confidence_threshold", "\n", "cfg", ".", "freeze", "(", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.demo.demo.get_parser": [[36, 71], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["", "def", "get_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "\"Detectron2 demo for builtin configs\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--config-file\"", ",", "\n", "default", "=", "\"configs/quick_schedules/mask_rcnn_R_50_FPN_inference_acc_test.yaml\"", ",", "\n", "metavar", "=", "\"FILE\"", ",", "\n", "help", "=", "\"path to config file\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\"--webcam\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Take inputs from webcam.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--video-input\"", ",", "help", "=", "\"Path to video file.\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--input\"", ",", "\n", "nargs", "=", "\"+\"", ",", "\n", "help", "=", "\"A list of space separated input images; \"", "\n", "\"or a single glob pattern such as 'directory/*.jpg'\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--output\"", ",", "\n", "help", "=", "\"A file or directory to save output visualizations. \"", "\n", "\"If not given, will show output in an OpenCV window.\"", ",", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--confidence-threshold\"", ",", "\n", "type", "=", "float", ",", "\n", "default", "=", "0.5", ",", "\n", "help", "=", "\"Minimum score for instance predictions to be shown\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--opts\"", ",", "\n", "help", "=", "\"Modify config options using the command-line 'KEY VALUE' pairs\"", ",", "\n", "default", "=", "[", "]", ",", "\n", "nargs", "=", "argparse", ".", "REMAINDER", ",", "\n", ")", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.demo.predictor.VisualizationDemo.__init__": [[16, 36], ["detectron2.data.MetadataCatalog.get", "torch.device", "torch.cuda.device_count", "predictor.AsyncPredictor", "detectron2.engine.defaults.DefaultPredictor", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "instance_mode", "=", "ColorMode", ".", "IMAGE", ",", "parallel", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            cfg (CfgNode):\n            instance_mode (ColorMode):\n            parallel (bool): whether to run the model in different processes from visualization.\n                Useful since the visualization logic can be slow.\n        \"\"\"", "\n", "self", ".", "metadata", "=", "MetadataCatalog", ".", "get", "(", "\n", "cfg", ".", "DATASETS", ".", "TEST", "[", "0", "]", "if", "len", "(", "cfg", ".", "DATASETS", ".", "TEST", ")", "else", "\"__unused\"", "\n", ")", "\n", "self", ".", "cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "self", ".", "instance_mode", "=", "instance_mode", "\n", "\n", "self", ".", "parallel", "=", "parallel", "\n", "if", "parallel", ":", "\n", "            ", "num_gpu", "=", "torch", ".", "cuda", ".", "device_count", "(", ")", "\n", "self", ".", "predictor", "=", "AsyncPredictor", "(", "cfg", ",", "num_gpus", "=", "num_gpu", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "predictor", "=", "DefaultPredictor", "(", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.demo.predictor.VisualizationDemo.run_on_image": [[37, 67], ["predictor.VisualizationDemo.predictor", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.draw_panoptic_seg_predictions", "panoptic_seg.to", "detectron2.utils.visualizer.Visualizer.draw_sem_seg", "predictions[].to", "detectron2.utils.visualizer.Visualizer.draw_instance_predictions", "predictions[].argmax().to", "predictions[].argmax"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.video_visualizer.VideoVisualizer.draw_panoptic_seg_predictions", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.video_visualizer.VideoVisualizer.draw_sem_seg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.video_visualizer.VideoVisualizer.draw_instance_predictions", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "", "def", "run_on_image", "(", "self", ",", "image", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image (np.ndarray): an image of shape (H, W, C) (in BGR order).\n                This is the format used by OpenCV.\n\n        Returns:\n            predictions (dict): the output of the model.\n            vis_output (VisImage): the visualized image output.\n        \"\"\"", "\n", "vis_output", "=", "None", "\n", "predictions", "=", "self", ".", "predictor", "(", "image", ")", "\n", "# Convert image from OpenCV BGR format to Matplotlib RGB format.", "\n", "image", "=", "image", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", "\n", "visualizer", "=", "Visualizer", "(", "image", ",", "self", ".", "metadata", ",", "instance_mode", "=", "self", ".", "instance_mode", ")", "\n", "if", "\"panoptic_seg\"", "in", "predictions", ":", "\n", "            ", "panoptic_seg", ",", "segments_info", "=", "predictions", "[", "\"panoptic_seg\"", "]", "\n", "vis_output", "=", "visualizer", ".", "draw_panoptic_seg_predictions", "(", "\n", "panoptic_seg", ".", "to", "(", "self", ".", "cpu_device", ")", ",", "segments_info", "\n", ")", "\n", "", "else", ":", "\n", "            ", "if", "\"sem_seg\"", "in", "predictions", ":", "\n", "                ", "vis_output", "=", "visualizer", ".", "draw_sem_seg", "(", "\n", "predictions", "[", "\"sem_seg\"", "]", ".", "argmax", "(", "dim", "=", "0", ")", ".", "to", "(", "self", ".", "cpu_device", ")", "\n", ")", "\n", "", "if", "\"instances\"", "in", "predictions", ":", "\n", "                ", "instances", "=", "predictions", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "cpu_device", ")", "\n", "vis_output", "=", "visualizer", ".", "draw_instance_predictions", "(", "predictions", "=", "instances", ")", "\n", "\n", "", "", "return", "predictions", ",", "vis_output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.demo.predictor.VisualizationDemo._frame_from_video": [[68, 75], ["video.isOpened", "video.read"], "methods", ["None"], ["", "def", "_frame_from_video", "(", "self", ",", "video", ")", ":", "\n", "        ", "while", "video", ".", "isOpened", "(", ")", ":", "\n", "            ", "success", ",", "frame", "=", "video", ".", "read", "(", ")", "\n", "if", "success", ":", "\n", "                ", "yield", "frame", "\n", "", "else", ":", "\n", "                ", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.demo.predictor.VisualizationDemo.run_on_video": [[76, 130], ["detectron2.utils.video_visualizer.VideoVisualizer", "predictor.VisualizationDemo._frame_from_video", "cv2.cvtColor", "cv2.cvtColor", "collections.deque", "enumerate", "len", "detectron2.utils.video_visualizer.VideoVisualizer.draw_panoptic_seg_predictions", "detectron2.utils.video_visualizer.VideoVisualizer.draw_sem_seg.get_image", "collections.deque.append", "predictor.VisualizationDemo.predictor.put", "collections.deque.popleft", "predictor.VisualizationDemo.predictor.get", "panoptic_seg.to", "predictions[].to", "detectron2.utils.video_visualizer.VideoVisualizer.draw_instance_predictions", "collections.deque.popleft", "predictor.VisualizationDemo.predictor.get", "predictor.VisualizationDemo.run_on_video.process_predictions"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.demo.predictor.VisualizationDemo._frame_from_video", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.video_visualizer.VideoVisualizer.draw_panoptic_seg_predictions", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.get_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.demo.predictor.AsyncPredictor.put", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.video_visualizer.VideoVisualizer.draw_instance_predictions", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "", "", "def", "run_on_video", "(", "self", ",", "video", ")", ":", "\n", "        ", "\"\"\"\n        Visualizes predictions on frames of the input video.\n\n        Args:\n            video (cv2.VideoCapture): a :class:`VideoCapture` object, whose source can be\n                either a webcam or a video file.\n\n        Yields:\n            ndarray: BGR visualizations of each video frame.\n        \"\"\"", "\n", "video_visualizer", "=", "VideoVisualizer", "(", "self", ".", "metadata", ",", "self", ".", "instance_mode", ")", "\n", "\n", "def", "process_predictions", "(", "frame", ",", "predictions", ")", ":", "\n", "            ", "frame", "=", "cv2", ".", "cvtColor", "(", "frame", ",", "cv2", ".", "COLOR_RGB2BGR", ")", "\n", "if", "\"panoptic_seg\"", "in", "predictions", ":", "\n", "                ", "panoptic_seg", ",", "segments_info", "=", "predictions", "[", "\"panoptic_seg\"", "]", "\n", "vis_frame", "=", "video_visualizer", ".", "draw_panoptic_seg_predictions", "(", "\n", "frame", ",", "panoptic_seg", ".", "to", "(", "self", ".", "cpu_device", ")", ",", "segments_info", "\n", ")", "\n", "", "elif", "\"instances\"", "in", "predictions", ":", "\n", "                ", "predictions", "=", "predictions", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "cpu_device", ")", "\n", "vis_frame", "=", "video_visualizer", ".", "draw_instance_predictions", "(", "frame", ",", "predictions", ")", "\n", "", "elif", "\"sem_seg\"", "in", "predictions", ":", "\n", "                ", "vis_frame", "=", "video_visualizer", ".", "draw_sem_seg", "(", "\n", "frame", ",", "predictions", "[", "\"sem_seg\"", "]", ".", "argmax", "(", "dim", "=", "0", ")", ".", "to", "(", "self", ".", "cpu_device", ")", "\n", ")", "\n", "\n", "# Converts Matplotlib RGB format to OpenCV BGR format", "\n", "", "vis_frame", "=", "cv2", ".", "cvtColor", "(", "vis_frame", ".", "get_image", "(", ")", ",", "cv2", ".", "COLOR_RGB2BGR", ")", "\n", "return", "vis_frame", "\n", "\n", "", "frame_gen", "=", "self", ".", "_frame_from_video", "(", "video", ")", "\n", "if", "self", ".", "parallel", ":", "\n", "            ", "buffer_size", "=", "self", ".", "predictor", ".", "default_buffer_size", "\n", "\n", "frame_data", "=", "deque", "(", ")", "\n", "\n", "for", "cnt", ",", "frame", "in", "enumerate", "(", "frame_gen", ")", ":", "\n", "                ", "frame_data", ".", "append", "(", "frame", ")", "\n", "self", ".", "predictor", ".", "put", "(", "frame", ")", "\n", "\n", "if", "cnt", ">=", "buffer_size", ":", "\n", "                    ", "frame", "=", "frame_data", ".", "popleft", "(", ")", "\n", "predictions", "=", "self", ".", "predictor", ".", "get", "(", ")", "\n", "yield", "process_predictions", "(", "frame", ",", "predictions", ")", "\n", "\n", "", "", "while", "len", "(", "frame_data", ")", ":", "\n", "                ", "frame", "=", "frame_data", ".", "popleft", "(", ")", "\n", "predictions", "=", "self", ".", "predictor", ".", "get", "(", ")", "\n", "yield", "process_predictions", "(", "frame", ",", "predictions", ")", "\n", "", "", "else", ":", "\n", "            ", "for", "frame", "in", "frame_gen", ":", "\n", "                ", "yield", "process_predictions", "(", "frame", ",", "self", ".", "predictor", "(", "frame", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.demo.predictor.AsyncPredictor.__init__": [[160, 186], ["max", "multiprocessing.Queue", "multiprocessing.Queue", "range", "atexit.register", "max", "cfg.clone.clone.clone", "cfg.clone.clone.defrost", "predictor.AsyncPredictor.procs.append", "p.start", "AsyncPredictor._PredictWorker"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.base.BaseConverter.register", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone"], ["", "", "", "def", "__init__", "(", "self", ",", "cfg", ",", "num_gpus", ":", "int", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            cfg (CfgNode):\n            num_gpus (int): if 0, will run on CPU\n        \"\"\"", "\n", "num_workers", "=", "max", "(", "num_gpus", ",", "1", ")", "\n", "self", ".", "task_queue", "=", "mp", ".", "Queue", "(", "maxsize", "=", "num_workers", "*", "3", ")", "\n", "self", ".", "result_queue", "=", "mp", ".", "Queue", "(", "maxsize", "=", "num_workers", "*", "3", ")", "\n", "self", ".", "procs", "=", "[", "]", "\n", "for", "gpuid", "in", "range", "(", "max", "(", "num_gpus", ",", "1", ")", ")", ":", "\n", "            ", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "cfg", ".", "defrost", "(", ")", "\n", "cfg", ".", "MODEL", ".", "DEVICE", "=", "\"cuda:{}\"", ".", "format", "(", "gpuid", ")", "if", "num_gpus", ">", "0", "else", "\"cpu\"", "\n", "self", ".", "procs", ".", "append", "(", "\n", "AsyncPredictor", ".", "_PredictWorker", "(", "cfg", ",", "self", ".", "task_queue", ",", "self", ".", "result_queue", ")", "\n", ")", "\n", "\n", "", "self", ".", "put_idx", "=", "0", "\n", "self", ".", "get_idx", "=", "0", "\n", "self", ".", "result_rank", "=", "[", "]", "\n", "self", ".", "result_data", "=", "[", "]", "\n", "\n", "for", "p", "in", "self", ".", "procs", ":", "\n", "            ", "p", ".", "start", "(", ")", "\n", "", "atexit", ".", "register", "(", "self", ".", "shutdown", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.demo.predictor.AsyncPredictor.put": [[187, 190], ["predictor.AsyncPredictor.task_queue.put"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.demo.predictor.AsyncPredictor.put"], ["", "def", "put", "(", "self", ",", "image", ")", ":", "\n", "        ", "self", ".", "put_idx", "+=", "1", "\n", "self", ".", "task_queue", ".", "put", "(", "(", "self", ".", "put_idx", ",", "image", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.demo.predictor.AsyncPredictor.get": [[191, 206], ["len", "predictor.AsyncPredictor.result_queue.get", "bisect.bisect", "predictor.AsyncPredictor.result_rank.insert", "predictor.AsyncPredictor.result_data.insert"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "def", "get", "(", "self", ")", ":", "\n", "        ", "self", ".", "get_idx", "+=", "1", "# the index needed for this request", "\n", "if", "len", "(", "self", ".", "result_rank", ")", "and", "self", ".", "result_rank", "[", "0", "]", "==", "self", ".", "get_idx", ":", "\n", "            ", "res", "=", "self", ".", "result_data", "[", "0", "]", "\n", "del", "self", ".", "result_data", "[", "0", "]", ",", "self", ".", "result_rank", "[", "0", "]", "\n", "return", "res", "\n", "\n", "", "while", "True", ":", "\n", "# make sure the results are returned in the correct order", "\n", "            ", "idx", ",", "res", "=", "self", ".", "result_queue", ".", "get", "(", ")", "\n", "if", "idx", "==", "self", ".", "get_idx", ":", "\n", "                ", "return", "res", "\n", "", "insert", "=", "bisect", ".", "bisect", "(", "self", ".", "result_rank", ",", "idx", ")", "\n", "self", ".", "result_rank", ".", "insert", "(", "insert", ",", "idx", ")", "\n", "self", ".", "result_data", ".", "insert", "(", "insert", ",", "res", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.demo.predictor.AsyncPredictor.__len__": [[207, 209], ["None"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "put_idx", "-", "self", ".", "get_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.demo.predictor.AsyncPredictor.__call__": [[210, 213], ["predictor.AsyncPredictor.put", "predictor.AsyncPredictor.get"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.demo.predictor.AsyncPredictor.put", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "def", "__call__", "(", "self", ",", "image", ")", ":", "\n", "        ", "self", ".", "put", "(", "image", ")", "\n", "return", "self", ".", "get", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.demo.predictor.AsyncPredictor.shutdown": [[214, 217], ["predictor.AsyncPredictor.task_queue.put", "AsyncPredictor._StopToken"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.demo.predictor.AsyncPredictor.put"], ["", "def", "shutdown", "(", "self", ")", ":", "\n", "        ", "for", "_", "in", "self", ".", "procs", ":", "\n", "            ", "self", ".", "task_queue", ".", "put", "(", "AsyncPredictor", ".", "_StopToken", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.demo.predictor.AsyncPredictor.default_buffer_size": [[218, 221], ["len"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "default_buffer_size", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "procs", ")", "*", "5", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.plain_train_net.get_evaluator": [[61, 107], ["detectron2.evaluation.DatasetEvaluators", "os.path.join", "detectron2.data.MetadataCatalog.get", "evaluator_list.append", "evaluator_list.append", "evaluator_list.append", "detectron2.evaluation.CityscapesInstanceEvaluator", "detectron2.evaluation.CityscapesSemSegEvaluator", "detectron2.evaluation.PascalVOCDetectionEvaluator", "detectron2.evaluation.LVISEvaluator", "len", "NotImplementedError", "len", "detectron2.evaluation.SemSegEvaluator", "detectron2.evaluation.COCOEvaluator", "detectron2.evaluation.COCOPanopticEvaluator", "torch.cuda.device_count", "detectron2.get_rank", "torch.cuda.device_count", "detectron2.get_rank"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank"], ["def", "get_evaluator", "(", "cfg", ",", "dataset_name", ",", "output_folder", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Create evaluator(s) for a given dataset.\n    This uses the special metadata \"evaluator_type\" associated with each builtin dataset.\n    For your own dataset, you can simply create an evaluator manually in your\n    script and do not have to worry about the hacky if-else logic here.\n    \"\"\"", "\n", "if", "output_folder", "is", "None", ":", "\n", "        ", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference\"", ")", "\n", "", "evaluator_list", "=", "[", "]", "\n", "evaluator_type", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", ".", "evaluator_type", "\n", "if", "evaluator_type", "in", "[", "\"sem_seg\"", ",", "\"coco_panoptic_seg\"", "]", ":", "\n", "        ", "evaluator_list", ".", "append", "(", "\n", "SemSegEvaluator", "(", "\n", "dataset_name", ",", "\n", "distributed", "=", "True", ",", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NUM_CLASSES", ",", "\n", "ignore_label", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IGNORE_VALUE", ",", "\n", "output_dir", "=", "output_folder", ",", "\n", ")", "\n", ")", "\n", "", "if", "evaluator_type", "in", "[", "\"coco\"", ",", "\"coco_panoptic_seg\"", "]", ":", "\n", "        ", "evaluator_list", ".", "append", "(", "COCOEvaluator", "(", "dataset_name", ",", "cfg", ",", "True", ",", "output_folder", ")", ")", "\n", "", "if", "evaluator_type", "==", "\"coco_panoptic_seg\"", ":", "\n", "        ", "evaluator_list", ".", "append", "(", "COCOPanopticEvaluator", "(", "dataset_name", ",", "output_folder", ")", ")", "\n", "", "if", "evaluator_type", "==", "\"cityscapes_instance\"", ":", "\n", "        ", "assert", "(", "\n", "torch", ".", "cuda", ".", "device_count", "(", ")", ">=", "comm", ".", "get_rank", "(", ")", "\n", ")", ",", "\"CityscapesEvaluator currently do not work with multiple machines.\"", "\n", "return", "CityscapesInstanceEvaluator", "(", "dataset_name", ")", "\n", "", "if", "evaluator_type", "==", "\"cityscapes_sem_seg\"", ":", "\n", "        ", "assert", "(", "\n", "torch", ".", "cuda", ".", "device_count", "(", ")", ">=", "comm", ".", "get_rank", "(", ")", "\n", ")", ",", "\"CityscapesEvaluator currently do not work with multiple machines.\"", "\n", "return", "CityscapesSemSegEvaluator", "(", "dataset_name", ")", "\n", "", "if", "evaluator_type", "==", "\"pascal_voc\"", ":", "\n", "        ", "return", "PascalVOCDetectionEvaluator", "(", "dataset_name", ")", "\n", "", "if", "evaluator_type", "==", "\"lvis\"", ":", "\n", "        ", "return", "LVISEvaluator", "(", "dataset_name", ",", "cfg", ",", "True", ",", "output_folder", ")", "\n", "", "if", "len", "(", "evaluator_list", ")", "==", "0", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\n", "\"no Evaluator for the dataset {} with the type {}\"", ".", "format", "(", "dataset_name", ",", "evaluator_type", ")", "\n", ")", "\n", "", "if", "len", "(", "evaluator_list", ")", "==", "1", ":", "\n", "        ", "return", "evaluator_list", "[", "0", "]", "\n", "", "return", "DatasetEvaluators", "(", "evaluator_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.plain_train_net.do_test": [[109, 124], ["collections.OrderedDict", "detectron2.data.build_detection_test_loader", "plain_train_net.get_evaluator", "detectron2.evaluation.inference_on_dataset", "detectron2.is_main_process", "len", "os.path.join", "logger.info", "detectron2.evaluation.print_csv_format", "list", "collections.OrderedDict.values"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.plain_train_net.get_evaluator", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.evaluator.inference_on_dataset", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.testing.print_csv_format"], ["", "def", "do_test", "(", "cfg", ",", "model", ")", ":", "\n", "    ", "results", "=", "OrderedDict", "(", ")", "\n", "for", "dataset_name", "in", "cfg", ".", "DATASETS", ".", "TEST", ":", "\n", "        ", "data_loader", "=", "build_detection_test_loader", "(", "cfg", ",", "dataset_name", ")", "\n", "evaluator", "=", "get_evaluator", "(", "\n", "cfg", ",", "dataset_name", ",", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference\"", ",", "dataset_name", ")", "\n", ")", "\n", "results_i", "=", "inference_on_dataset", "(", "model", ",", "data_loader", ",", "evaluator", ")", "\n", "results", "[", "dataset_name", "]", "=", "results_i", "\n", "if", "comm", ".", "is_main_process", "(", ")", ":", "\n", "            ", "logger", ".", "info", "(", "\"Evaluation results for {} in csv format:\"", ".", "format", "(", "dataset_name", ")", ")", "\n", "print_csv_format", "(", "results_i", ")", "\n", "", "", "if", "len", "(", "results", ")", "==", "1", ":", "\n", "        ", "results", "=", "list", "(", "results", ".", "values", "(", ")", ")", "[", "0", "]", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.plain_train_net.do_train": [[126, 191], ["model.train", "detectron2.solver.build_optimizer", "detectron2.solver.build_lr_scheduler", "detectron2.checkpoint.DetectionCheckpointer", "detectron2.checkpoint.PeriodicCheckpointer", "detectron2.data.build_detection_train_loader", "logger.info", "detectron2.checkpoint.DetectionCheckpointer.resume_or_load().get", "detectron2.is_main_process", "detectron2.utils.events.EventStorage", "zip", "detectron2.utils.events.CommonMetricPrinter", "detectron2.utils.events.JSONWriter", "detectron2.utils.events.TensorboardXWriter", "range", "model", "sum", "torch.isfinite().all", "sum", "detectron2.is_main_process", "detectron2.solver.build_optimizer.zero_grad", "sum.backward", "detectron2.solver.build_optimizer.step", "storage.put_scalar", "detectron2.solver.build_lr_scheduler.step", "detectron2.checkpoint.PeriodicCheckpointer.step", "detectron2.checkpoint.DetectionCheckpointer.resume_or_load", "os.path.join", "model.values", "v.item", "storage.put_scalars", "plain_train_net.do_test", "detectron2.synchronize", "torch.isfinite", "detectron2.reduce_dict().items", "writer.write", "loss_dict_reduced.values", "detectron2.reduce_dict"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.apis.train.build_optimizer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.build_solver.build_lr_scheduler", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.swap_align2nat._SwapAlign2Nat.backward", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.optimizers.LARS.step", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.optimizers.LARS.step", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.optimizers.LARS.step", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalars", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.plain_train_net.do_test", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.synchronize", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.reduce_dict"], ["", "def", "do_train", "(", "cfg", ",", "model", ",", "resume", "=", "False", ")", ":", "\n", "    ", "model", ".", "train", "(", ")", "\n", "optimizer", "=", "build_optimizer", "(", "cfg", ",", "model", ")", "\n", "scheduler", "=", "build_lr_scheduler", "(", "cfg", ",", "optimizer", ")", "\n", "\n", "checkpointer", "=", "DetectionCheckpointer", "(", "\n", "model", ",", "cfg", ".", "OUTPUT_DIR", ",", "optimizer", "=", "optimizer", ",", "scheduler", "=", "scheduler", "\n", ")", "\n", "start_iter", "=", "(", "\n", "checkpointer", ".", "resume_or_load", "(", "cfg", ".", "MODEL", ".", "WEIGHTS", ",", "resume", "=", "resume", ")", ".", "get", "(", "\"iteration\"", ",", "-", "1", ")", "+", "1", "\n", ")", "\n", "max_iter", "=", "cfg", ".", "SOLVER", ".", "MAX_ITER", "\n", "\n", "periodic_checkpointer", "=", "PeriodicCheckpointer", "(", "\n", "checkpointer", ",", "cfg", ".", "SOLVER", ".", "CHECKPOINT_PERIOD", ",", "max_iter", "=", "max_iter", "\n", ")", "\n", "\n", "writers", "=", "(", "\n", "[", "\n", "CommonMetricPrinter", "(", "max_iter", ")", ",", "\n", "JSONWriter", "(", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"metrics.json\"", ")", ")", ",", "\n", "TensorboardXWriter", "(", "cfg", ".", "OUTPUT_DIR", ")", ",", "\n", "]", "\n", "if", "comm", ".", "is_main_process", "(", ")", "\n", "else", "[", "]", "\n", ")", "\n", "\n", "# compared to \"train_net.py\", we do not support accurate timing and", "\n", "# precise BN here, because they are not trivial to implement in a small training loop", "\n", "data_loader", "=", "build_detection_train_loader", "(", "cfg", ")", "\n", "logger", ".", "info", "(", "\"Starting training from iteration {}\"", ".", "format", "(", "start_iter", ")", ")", "\n", "with", "EventStorage", "(", "start_iter", ")", "as", "storage", ":", "\n", "        ", "for", "data", ",", "iteration", "in", "zip", "(", "data_loader", ",", "range", "(", "start_iter", ",", "max_iter", ")", ")", ":", "\n", "            ", "storage", ".", "iter", "=", "iteration", "\n", "\n", "loss_dict", "=", "model", "(", "data", ")", "\n", "losses", "=", "sum", "(", "loss_dict", ".", "values", "(", ")", ")", "\n", "assert", "torch", ".", "isfinite", "(", "losses", ")", ".", "all", "(", ")", ",", "loss_dict", "\n", "\n", "loss_dict_reduced", "=", "{", "k", ":", "v", ".", "item", "(", ")", "for", "k", ",", "v", "in", "comm", ".", "reduce_dict", "(", "loss_dict", ")", ".", "items", "(", ")", "}", "\n", "losses_reduced", "=", "sum", "(", "loss", "for", "loss", "in", "loss_dict_reduced", ".", "values", "(", ")", ")", "\n", "if", "comm", ".", "is_main_process", "(", ")", ":", "\n", "                ", "storage", ".", "put_scalars", "(", "total_loss", "=", "losses_reduced", ",", "**", "loss_dict_reduced", ")", "\n", "\n", "", "optimizer", ".", "zero_grad", "(", ")", "\n", "losses", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "storage", ".", "put_scalar", "(", "\"lr\"", ",", "optimizer", ".", "param_groups", "[", "0", "]", "[", "\"lr\"", "]", ",", "smoothing_hint", "=", "False", ")", "\n", "scheduler", ".", "step", "(", ")", "\n", "\n", "if", "(", "\n", "cfg", ".", "TEST", ".", "EVAL_PERIOD", ">", "0", "\n", "and", "(", "iteration", "+", "1", ")", "%", "cfg", ".", "TEST", ".", "EVAL_PERIOD", "==", "0", "\n", "and", "iteration", "!=", "max_iter", "-", "1", "\n", ")", ":", "\n", "                ", "do_test", "(", "cfg", ",", "model", ")", "\n", "# Compared to \"train_net.py\", the test results are not dumped to EventStorage", "\n", "comm", ".", "synchronize", "(", ")", "\n", "\n", "", "if", "iteration", "-", "start_iter", ">", "5", "and", "(", "\n", "(", "iteration", "+", "1", ")", "%", "20", "==", "0", "or", "iteration", "==", "max_iter", "-", "1", "\n", ")", ":", "\n", "                ", "for", "writer", "in", "writers", ":", "\n", "                    ", "writer", ".", "write", "(", ")", "\n", "", "", "periodic_checkpointer", ".", "step", "(", "iteration", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.plain_train_net.setup": [[193, 205], ["detectron2.config.get_cfg", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.engine.default_setup"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.default_setup"], ["", "", "", "def", "setup", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Create configs and perform basic setups.\n    \"\"\"", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "default_setup", "(", "\n", "cfg", ",", "args", "\n", ")", "# if you don't like any of the default setup, write your own setup code", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.plain_train_net.main": [[207, 226], ["plain_train_net.setup", "detectron2.modeling.build_model", "logger.info", "plain_train_net.do_train", "plain_train_net.do_test", "detectron2.checkpoint.DetectionCheckpointer().resume_or_load", "plain_train_net.do_test", "detectron2.get_world_size", "torch.nn.parallel.DistributedDataParallel", "detectron2.checkpoint.DetectionCheckpointer", "detectron2.get_local_rank"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.setup", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.plain_train_net.do_train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.plain_train_net.do_test", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.plain_train_net.do_test", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_local_rank"], ["", "def", "main", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "setup", "(", "args", ")", "\n", "\n", "model", "=", "build_model", "(", "cfg", ")", "\n", "logger", ".", "info", "(", "\"Model:\\n{}\"", ".", "format", "(", "model", ")", ")", "\n", "if", "args", ".", "eval_only", ":", "\n", "        ", "DetectionCheckpointer", "(", "model", ",", "save_dir", "=", "cfg", ".", "OUTPUT_DIR", ")", ".", "resume_or_load", "(", "\n", "cfg", ".", "MODEL", ".", "WEIGHTS", ",", "resume", "=", "args", ".", "resume", "\n", ")", "\n", "return", "do_test", "(", "cfg", ",", "model", ")", "\n", "\n", "", "distributed", "=", "comm", ".", "get_world_size", "(", ")", ">", "1", "\n", "if", "distributed", ":", "\n", "        ", "model", "=", "DistributedDataParallel", "(", "\n", "model", ",", "device_ids", "=", "[", "comm", ".", "get_local_rank", "(", ")", "]", ",", "broadcast_buffers", "=", "False", "\n", ")", "\n", "\n", "", "do_train", "(", "cfg", ",", "model", ",", "resume", "=", "args", ".", "resume", ")", "\n", "return", "do_test", "(", "cfg", ",", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.benchmark.setup": [[34, 42], ["detectron2.config.get_cfg", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.utils.logger.setup_logger", "detectron2.utils.comm.get_rank"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.setup_logger", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank"], ["def", "setup", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "SOLVER", ".", "BASE_LR", "=", "0.001", "# Avoid NaNs. Not useful in this script anyway.", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "setup_logger", "(", "distributed_rank", "=", "comm", ".", "get_rank", "(", ")", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.benchmark.benchmark_data": [[44, 83], ["benchmark.setup", "fvcore.common.timer.Timer", "detectron2.data.build_detection_train_loader", "logger.info", "fvcore.common.timer.Timer.reset", "iter", "range", "fvcore.common.timer.Timer", "tqdm.trange", "logger.info", "logger.info", "psutil.virtual_memory", "logger.info", "range", "next", "next", "fvcore.common.timer.Timer", "tqdm.trange", "logger.info", "fvcore.common.timer.Timer.seconds", "fvcore.common.timer.Timer.seconds", "fvcore.common.timer.Timer.seconds", "next", "fvcore.common.timer.Timer.seconds"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.setup", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator.DensePoseCOCOEvaluator.reset", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.iter"], ["", "def", "benchmark_data", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "setup", "(", "args", ")", "\n", "\n", "timer", "=", "Timer", "(", ")", "\n", "dataloader", "=", "build_detection_train_loader", "(", "cfg", ")", "\n", "logger", ".", "info", "(", "\"Initialize loader using {} seconds.\"", ".", "format", "(", "timer", ".", "seconds", "(", ")", ")", ")", "\n", "\n", "timer", ".", "reset", "(", ")", "\n", "itr", "=", "iter", "(", "dataloader", ")", "\n", "for", "i", "in", "range", "(", "10", ")", ":", "# warmup", "\n", "        ", "next", "(", "itr", ")", "\n", "if", "i", "==", "0", ":", "\n", "            ", "startup_time", "=", "timer", ".", "seconds", "(", ")", "\n", "", "", "timer", "=", "Timer", "(", ")", "\n", "max_iter", "=", "1000", "\n", "for", "_", "in", "tqdm", ".", "trange", "(", "max_iter", ")", ":", "\n", "        ", "next", "(", "itr", ")", "\n", "", "logger", ".", "info", "(", "\n", "\"{} iters ({} images) in {} seconds.\"", ".", "format", "(", "\n", "max_iter", ",", "max_iter", "*", "cfg", ".", "SOLVER", ".", "IMS_PER_BATCH", ",", "timer", ".", "seconds", "(", ")", "\n", ")", "\n", ")", "\n", "logger", ".", "info", "(", "\"Startup time: {} seconds\"", ".", "format", "(", "startup_time", ")", ")", "\n", "vram", "=", "psutil", ".", "virtual_memory", "(", ")", "\n", "logger", ".", "info", "(", "\n", "\"RAM Usage: {:.2f}/{:.2f} GB\"", ".", "format", "(", "\n", "(", "vram", ".", "total", "-", "vram", ".", "available", ")", "/", "1024", "**", "3", ",", "vram", ".", "total", "/", "1024", "**", "3", "\n", ")", "\n", ")", "\n", "\n", "# test for a few more rounds", "\n", "for", "_", "in", "range", "(", "10", ")", ":", "\n", "        ", "timer", "=", "Timer", "(", ")", "\n", "max_iter", "=", "1000", "\n", "for", "_", "in", "tqdm", ".", "trange", "(", "max_iter", ")", ":", "\n", "            ", "next", "(", "itr", ")", "\n", "", "logger", ".", "info", "(", "\n", "\"{} iters ({} images) in {} seconds.\"", ".", "format", "(", "\n", "max_iter", ",", "max_iter", "*", "cfg", ".", "SOLVER", ".", "IMS_PER_BATCH", ",", "timer", ".", "seconds", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.benchmark.benchmark_train": [[87, 115], ["benchmark.setup", "detectron2.modeling.build_model", "logger.info", "detectron2.solver.build_optimizer", "detectron2.checkpoint.DetectionCheckpointer", "detectron2.checkpoint.DetectionCheckpointer.load", "setup.defrost", "detectron2.data.build_detection_train_loader", "list", "detectron2.engine.SimpleTrainer", "detectron2.engine.SimpleTrainer.register_hooks", "detectron2.engine.SimpleTrainer.train", "detectron2.utils.comm.get_world_size", "torch.nn.parallel.DistributedDataParallel", "itertools.islice", "detectron2.data.DatasetFromList", "benchmark.benchmark_train.f"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.setup", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.apis.train.build_optimizer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.TrainerBase.register_hooks", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size"], ["", "", "def", "benchmark_train", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "setup", "(", "args", ")", "\n", "model", "=", "build_model", "(", "cfg", ")", "\n", "logger", ".", "info", "(", "\"Model:\\n{}\"", ".", "format", "(", "model", ")", ")", "\n", "if", "comm", ".", "get_world_size", "(", ")", ">", "1", ":", "\n", "        ", "model", "=", "DistributedDataParallel", "(", "\n", "model", ",", "device_ids", "=", "[", "comm", ".", "get_local_rank", "(", ")", "]", ",", "broadcast_buffers", "=", "False", "\n", ")", "\n", "", "optimizer", "=", "build_optimizer", "(", "cfg", ",", "model", ")", "\n", "checkpointer", "=", "DetectionCheckpointer", "(", "model", ",", "optimizer", "=", "optimizer", ")", "\n", "checkpointer", ".", "load", "(", "cfg", ".", "MODEL", ".", "WEIGHTS", ")", "\n", "\n", "cfg", ".", "defrost", "(", ")", "\n", "cfg", ".", "DATALOADER", ".", "NUM_WORKERS", "=", "0", "\n", "data_loader", "=", "build_detection_train_loader", "(", "cfg", ")", "\n", "dummy_data", "=", "list", "(", "itertools", ".", "islice", "(", "data_loader", ",", "100", ")", ")", "\n", "\n", "def", "f", "(", ")", ":", "\n", "        ", "data", "=", "DatasetFromList", "(", "dummy_data", ",", "copy", "=", "False", ")", "\n", "while", "True", ":", "\n", "            ", "yield", "from", "data", "\n", "\n", "", "", "max_iter", "=", "400", "\n", "trainer", "=", "SimpleTrainer", "(", "model", ",", "f", "(", ")", ",", "optimizer", ")", "\n", "trainer", ".", "register_hooks", "(", "\n", "[", "hooks", ".", "IterationTimer", "(", ")", ",", "hooks", ".", "PeriodicWriter", "(", "[", "CommonMetricPrinter", "(", "max_iter", ")", "]", ")", "]", "\n", ")", "\n", "trainer", ".", "train", "(", "1", ",", "max_iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.benchmark.benchmark_eval": [[117, 146], ["torch.no_grad", "benchmark.setup", "detectron2.modeling.build_model", "detectron2.modeling.build_model.eval", "logger.info", "detectron2.checkpoint.DetectionCheckpointer().load", "setup.defrost", "detectron2.data.build_detection_test_loader", "detectron2.data.DatasetFromList", "range", "fvcore.common.timer.Timer", "logger.info", "list", "detectron2.modeling.build_model.", "tqdm.tqdm", "enumerate", "detectron2.checkpoint.DetectionCheckpointer", "itertools.islice", "benchmark.benchmark_train.f"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.setup", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "benchmark_eval", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "setup", "(", "args", ")", "\n", "model", "=", "build_model", "(", "cfg", ")", "\n", "model", ".", "eval", "(", ")", "\n", "logger", ".", "info", "(", "\"Model:\\n{}\"", ".", "format", "(", "model", ")", ")", "\n", "DetectionCheckpointer", "(", "model", ")", ".", "load", "(", "cfg", ".", "MODEL", ".", "WEIGHTS", ")", "\n", "\n", "cfg", ".", "defrost", "(", ")", "\n", "cfg", ".", "DATALOADER", ".", "NUM_WORKERS", "=", "0", "\n", "data_loader", "=", "build_detection_test_loader", "(", "cfg", ",", "cfg", ".", "DATASETS", ".", "TEST", "[", "0", "]", ")", "\n", "dummy_data", "=", "DatasetFromList", "(", "list", "(", "itertools", ".", "islice", "(", "data_loader", ",", "100", ")", ")", ",", "copy", "=", "False", ")", "\n", "\n", "def", "f", "(", ")", ":", "\n", "        ", "while", "True", ":", "\n", "            ", "yield", "from", "dummy_data", "\n", "\n", "", "", "for", "k", "in", "range", "(", "5", ")", ":", "# warmup", "\n", "        ", "model", "(", "dummy_data", "[", "k", "]", ")", "\n", "\n", "", "max_iter", "=", "300", "\n", "timer", "=", "Timer", "(", ")", "\n", "with", "tqdm", ".", "tqdm", "(", "total", "=", "max_iter", ")", "as", "pbar", ":", "\n", "        ", "for", "idx", ",", "d", "in", "enumerate", "(", "f", "(", ")", ")", ":", "\n", "            ", "if", "idx", "==", "max_iter", ":", "\n", "                ", "break", "\n", "", "model", "(", "d", ")", "\n", "pbar", ".", "update", "(", ")", "\n", "", "", "logger", ".", "info", "(", "\"{} iters in {} seconds.\"", ".", "format", "(", "max_iter", ",", "timer", ".", "seconds", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.analyze_model.setup": [[24, 32], ["detectron2.config.get_cfg", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.utils.logger.setup_logger"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.setup_logger"], ["def", "setup", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "DATALOADER", ".", "NUM_WORKERS", "=", "0", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "setup_logger", "(", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.analyze_model.do_flop": [[34, 50], ["detectron2.data.build_detection_test_loader", "detectron2.modeling.build_model", "detectron2.checkpoint.DetectionCheckpointer().load", "detectron2.modeling.build_model.eval", "collections.Counter", "zip", "logger.info", "logger.info", "tqdm.trange", "detectron2.utils.analysis.flop_count_operators", "total_flops.append", "detectron2.checkpoint.DetectionCheckpointer", "sum", "str", "numpy.mean", "numpy.std", "detectron2.utils.analysis.flop_count_operators.values", "collections.Counter.items"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.analysis.flop_count_operators"], ["", "def", "do_flop", "(", "cfg", ")", ":", "\n", "    ", "data_loader", "=", "build_detection_test_loader", "(", "cfg", ",", "cfg", ".", "DATASETS", ".", "TEST", "[", "0", "]", ")", "\n", "model", "=", "build_model", "(", "cfg", ")", "\n", "DetectionCheckpointer", "(", "model", ")", ".", "load", "(", "cfg", ".", "MODEL", ".", "WEIGHTS", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "counts", "=", "Counter", "(", ")", "\n", "total_flops", "=", "[", "]", "\n", "for", "idx", ",", "data", "in", "zip", "(", "tqdm", ".", "trange", "(", "args", ".", "num_inputs", ")", ",", "data_loader", ")", ":", "# noqa", "\n", "        ", "count", "=", "flop_count_operators", "(", "model", ",", "data", ")", "\n", "counts", "+=", "count", "\n", "total_flops", ".", "append", "(", "sum", "(", "count", ".", "values", "(", ")", ")", ")", "\n", "", "logger", ".", "info", "(", "\n", "\"(G)Flops for Each Type of Operators:\\n\"", "+", "str", "(", "[", "(", "k", ",", "v", "/", "idx", ")", "for", "k", ",", "v", "in", "counts", ".", "items", "(", ")", "]", ")", "\n", ")", "\n", "logger", ".", "info", "(", "\"Total (G)Flops: {}\u00b1{}\"", ".", "format", "(", "np", ".", "mean", "(", "total_flops", ")", ",", "np", ".", "std", "(", "total_flops", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.analyze_model.do_activation": [[52, 71], ["detectron2.data.build_detection_test_loader", "detectron2.modeling.build_model", "detectron2.checkpoint.DetectionCheckpointer().load", "detectron2.modeling.build_model.eval", "collections.Counter", "zip", "logger.info", "logger.info", "tqdm.trange", "detectron2.utils.analysis.activation_count_operators", "total_activations.append", "detectron2.checkpoint.DetectionCheckpointer", "sum", "str", "numpy.mean", "numpy.std", "detectron2.utils.analysis.activation_count_operators.values", "collections.Counter.items"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.analysis.activation_count_operators"], ["", "def", "do_activation", "(", "cfg", ")", ":", "\n", "    ", "data_loader", "=", "build_detection_test_loader", "(", "cfg", ",", "cfg", ".", "DATASETS", ".", "TEST", "[", "0", "]", ")", "\n", "model", "=", "build_model", "(", "cfg", ")", "\n", "DetectionCheckpointer", "(", "model", ")", ".", "load", "(", "cfg", ".", "MODEL", ".", "WEIGHTS", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "counts", "=", "Counter", "(", ")", "\n", "total_activations", "=", "[", "]", "\n", "for", "idx", ",", "data", "in", "zip", "(", "tqdm", ".", "trange", "(", "args", ".", "num_inputs", ")", ",", "data_loader", ")", ":", "# noqa", "\n", "        ", "count", "=", "activation_count_operators", "(", "model", ",", "data", ")", "\n", "counts", "+=", "count", "\n", "total_activations", ".", "append", "(", "sum", "(", "count", ".", "values", "(", ")", ")", ")", "\n", "", "logger", ".", "info", "(", "\n", "\"(Million) Activations for Each Type of Operators:\\n\"", "\n", "+", "str", "(", "[", "(", "k", ",", "v", "/", "idx", ")", "for", "k", ",", "v", "in", "counts", ".", "items", "(", ")", "]", ")", "\n", ")", "\n", "logger", ".", "info", "(", "\n", "\"Total (Million) Activations: {}\u00b1{}\"", ".", "format", "(", "\n", "np", ".", "mean", "(", "total_activations", ")", ",", "np", ".", "std", "(", "total_activations", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.analyze_model.do_parameter": [[75, 78], ["detectron2.modeling.build_model", "logger.info", "detectron2.utils.analysis.parameter_count_table"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model"], ["", "def", "do_parameter", "(", "cfg", ")", ":", "\n", "    ", "model", "=", "build_model", "(", "cfg", ")", "\n", "logger", ".", "info", "(", "\"Parameter Count:\\n\"", "+", "parameter_count_table", "(", "model", ",", "max_depth", "=", "5", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.analyze_model.do_structure": [[80, 83], ["detectron2.modeling.build_model", "logger.info", "str"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model"], ["", "def", "do_structure", "(", "cfg", ")", ":", "\n", "    ", "model", "=", "build_model", "(", "cfg", ")", "\n", "logger", ".", "info", "(", "\"Model Structure:\\n\"", "+", "str", "(", "model", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.visualize_data.setup": [[17, 24], ["detectron2.config.get_cfg", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.config.get_cfg.merge_from_file"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file"], ["def", "setup", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "get_cfg", "(", ")", "\n", "if", "args", ".", "config_file", ":", "\n", "        ", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.visualize_data.parse_args": [[26, 44], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args"], ["", "def", "parse_args", "(", "in_args", "=", "None", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "\"Visualize ground-truth data\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--source\"", ",", "\n", "choices", "=", "[", "\"annotation\"", ",", "\"dataloader\"", "]", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"visualize the annotations or the data loader (with pre-processing)\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\"--config-file\"", ",", "metavar", "=", "\"FILE\"", ",", "help", "=", "\"path to config file\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--output-dir\"", ",", "default", "=", "\"./\"", ",", "help", "=", "\"path to output directory\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--show\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"show output in a window\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"opts\"", ",", "\n", "help", "=", "\"Modify config options using the command-line\"", ",", "\n", "default", "=", "None", ",", "\n", "nargs", "=", "argparse", ".", "REMAINDER", ",", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", "in_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.visualize_json_results.create_instances": [[19, 39], ["detectron2.structures.Instances", "numpy.asarray", "numpy.asarray().reshape", "detectron2.structures.BoxMode.convert", "numpy.asarray", "detectron2.structures.Boxes", "numpy.asarray", "dataset_id_map"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["def", "create_instances", "(", "predictions", ",", "image_size", ")", ":", "\n", "    ", "ret", "=", "Instances", "(", "image_size", ")", "\n", "\n", "score", "=", "np", ".", "asarray", "(", "[", "x", "[", "\"score\"", "]", "for", "x", "in", "predictions", "]", ")", "\n", "chosen", "=", "(", "score", ">", "args", ".", "conf_threshold", ")", ".", "nonzero", "(", ")", "[", "0", "]", "\n", "score", "=", "score", "[", "chosen", "]", "\n", "bbox", "=", "np", ".", "asarray", "(", "[", "predictions", "[", "i", "]", "[", "\"bbox\"", "]", "for", "i", "in", "chosen", "]", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "bbox", "=", "BoxMode", ".", "convert", "(", "bbox", ",", "BoxMode", ".", "XYWH_ABS", ",", "BoxMode", ".", "XYXY_ABS", ")", "\n", "\n", "labels", "=", "np", ".", "asarray", "(", "[", "dataset_id_map", "(", "predictions", "[", "i", "]", "[", "\"category_id\"", "]", ")", "for", "i", "in", "chosen", "]", ")", "\n", "\n", "ret", ".", "scores", "=", "score", "\n", "ret", ".", "pred_boxes", "=", "Boxes", "(", "bbox", ")", "\n", "ret", ".", "pred_classes", "=", "labels", "\n", "\n", "try", ":", "\n", "        ", "ret", ".", "pred_masks", "=", "[", "predictions", "[", "i", "]", "[", "\"segmentation\"", "]", "for", "i", "in", "chosen", "]", "\n", "", "except", "KeyError", ":", "\n", "        ", "pass", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.train_net.Trainer.build_evaluator": [[51, 100], ["detectron2.evaluation.DatasetEvaluators", "os.path.join", "detectron2.data.MetadataCatalog.get", "evaluator_list.append", "evaluator_list.append", "evaluator_list.append", "detectron2.evaluation.CityscapesInstanceEvaluator", "detectron2.evaluation.CityscapesSemSegEvaluator", "len", "NotImplementedError", "detectron2.evaluation.SemSegEvaluator", "detectron2.evaluation.COCOEvaluator", "detectron2.evaluation.COCOPanopticEvaluator", "torch.cuda.device_count", "detectron2.get_rank", "torch.cuda.device_count", "detectron2.get_rank", "detectron2.evaluation.PascalVOCDetectionEvaluator", "len", "detectron2.evaluation.LVISEvaluator"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank"], ["cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "default_setup", "(", "cfg", ",", "args", ")", "\n", "return", "cfg", "\n", "\n", "\n", "", "def", "main", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "setup", "(", "args", ")", "\n", "\n", "if", "args", ".", "eval_only", ":", "\n", "        ", "model", "=", "Trainer", ".", "build_model", "(", "cfg", ")", "\n", "DetectionCheckpointer", "(", "\n", "model", ",", "save_dir", "=", "cfg", ".", "OUTPUT_DIR", ")", ".", "resume_or_load", "(", "\n", "cfg", ".", "MODEL", ".", "WEIGHTS", ",", "resume", "=", "args", ".", "resume", ")", "\n", "res", "=", "Trainer", ".", "test", "(", "cfg", ",", "model", ")", "\n", "return", "res", "\n", "\n", "", "trainer", "=", "Trainer", "(", "cfg", ")", "\n", "trainer", ".", "resume_or_load", "(", "resume", "=", "args", ".", "resume", ")", "\n", "return", "trainer", ".", "train", "(", ")", "\n", "\n", "\n", "", "if", "__name__", "==", "\"__main__\"", ":", "\n", "    ", "args", "=", "default_argument_parser", "(", ")", ".", "parse_args", "(", ")", "\n", "\n", "print", "(", "\"Command Line Args:\"", ",", "args", ")", "\n", "launch", "(", "\n", "main", ",", "\n", "args", ".", "num_gpus", ",", "\n", "num_machines", "=", "args", ".", "num_machines", ",", "\n", "machine_rank", "=", "args", ".", "machine_rank", ",", "\n", "dist_url", "=", "args", ".", "dist_url", ",", "\n", "args", "=", "(", "args", ",", ")", ",", "\n", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.train_net.Trainer.test_with_TTA": [[101, 117], ["logging.getLogger", "logging.getLogger.info", "detectron2.modeling.GeneralizedRCNNWithTTA", "cls.test", "collections.OrderedDict", "cls.build_evaluator", "os.path.join", "collections.OrderedDict.items"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_packaging.TestCollectEnv.test", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.Trainer.build_evaluator"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.train_net.setup": [[119, 129], ["detectron2.config.get_cfg", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.engine.default_setup"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.default_setup"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.train_net.main": [[131, 158], ["train_net.setup", "train_net.Trainer", "Trainer.resume_or_load", "Trainer.train", "Trainer.build_model", "detectron2.checkpoint.DetectionCheckpointer().resume_or_load", "Trainer.test", "detectron2.is_main_process", "Trainer.register_hooks", "Trainer.test.update", "detectron2.evaluation.verify_results", "detectron2.checkpoint.DetectionCheckpointer", "train_net.Trainer.test_with_TTA", "detectron2.engine.hooks.EvalHook", "train_net.Trainer.test_with_TTA"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.setup", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_packaging.TestCollectEnv.test", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.TrainerBase.register_hooks", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.testing.verify_results", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.Trainer.test_with_TTA", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.Trainer.test_with_TTA"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.publish_model.parse_args": [[5, 11], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Process a checkpoint to be published'", ")", "\n", "parser", ".", "add_argument", "(", "'in_file'", ",", "help", "=", "'input checkpoint filename'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.publish_model.process_checkpoint": [[13, 25], ["subprocess.Popen", "subprocess.check_output().decode", "out_file.endswith", "print", "subprocess.Popen", "subprocess.check_output"], "function", ["None"], ["", "def", "process_checkpoint", "(", "in_file", ")", ":", "\n", "    ", "tmp_file", "=", "in_file", "+", "\".tmp\"", "\n", "subprocess", ".", "Popen", "(", "[", "'cp'", ",", "in_file", ",", "tmp_file", "]", ")", "\n", "sha", "=", "subprocess", ".", "check_output", "(", "[", "'sha256sum'", ",", "tmp_file", "]", ")", ".", "decode", "(", ")", "\n", "out_file", "=", "in_file", "\n", "if", "out_file", ".", "endswith", "(", "'.pth'", ")", ":", "\n", "        ", "out_file", "=", "out_file", "[", ":", "-", "4", "]", "\n", "", "final_file", "=", "out_file", "+", "f'-{sha[:8]}.pth'", "\n", "assert", "final_file", "!=", "in_file", ",", "\"The output filename is the same as the input file.\"", "\n", "print", "(", "\"Output file: {}\"", ".", "format", "(", "final_file", ")", ")", "\n", "subprocess", ".", "Popen", "(", "[", "'mv'", ",", "tmp_file", ",", "final_file", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.publish_model.main": [[27, 30], ["publish_model.parse_args", "publish_model.process_checkpoint"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.publish_model.process_checkpoint"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "process_checkpoint", "(", "args", ".", "in_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract_backbone_weights.parse_args": [[5, 13], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'This script extracts backbone weights from a checkpoint'", ")", "\n", "parser", ".", "add_argument", "(", "'checkpoint'", ",", "help", "=", "'checkpoint file'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'output'", ",", "type", "=", "str", ",", "help", "=", "'destination file name'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract_backbone_weights.main": [[15, 28], ["extract_backbone_weights.parse_args", "parse_args.output.endswith", "torch.load", "dict", "ck[].items", "torch.save", "key.startswith", "Exception", "torch.device", "dict"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "assert", "args", ".", "output", ".", "endswith", "(", "\".pth\"", ")", "\n", "ck", "=", "torch", ".", "load", "(", "args", ".", "checkpoint", ",", "map_location", "=", "torch", ".", "device", "(", "'cpu'", ")", ")", "\n", "output_dict", "=", "dict", "(", "state_dict", "=", "dict", "(", ")", ",", "author", "=", "\"OpenSelfSup\"", ")", "\n", "has_backbone", "=", "False", "\n", "for", "key", ",", "value", "in", "ck", "[", "'state_dict'", "]", ".", "items", "(", ")", ":", "\n", "        ", "if", "key", ".", "startswith", "(", "'backbone'", ")", ":", "\n", "            ", "output_dict", "[", "'state_dict'", "]", "[", "key", "[", "9", ":", "]", "]", "=", "value", "\n", "has_backbone", "=", "True", "\n", "", "", "if", "not", "has_backbone", ":", "\n", "        ", "raise", "Exception", "(", "\"Cannot find a backbone module in the checkpoint.\"", ")", "\n", "", "torch", ".", "save", "(", "output_dict", ",", "args", ".", "output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.count_parameters.parse_args": [[7, 12], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Train a model'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'train config file path'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.count_parameters.main": [[14, 35], ["count_parameters.parse_args", "mmcv.Config.fromfile", "openselfsup.models.build_model", "print", "print", "print", "print", "sum", "sum", "sum", "sum", "p.numel", "p.numel", "p.numel", "p.numel", "openselfsup.models.build_model.parameters", "openselfsup.models.build_model.parameters", "openselfsup.models.build_model.backbone.parameters", "openselfsup.models.build_model.backbone.parameters"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "\n", "cfg", "=", "Config", ".", "fromfile", "(", "args", ".", "config", ")", "\n", "\n", "model", "=", "build_model", "(", "cfg", ".", "model", ")", "\n", "\n", "num_params", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", ")", "/", "1000000.", "\n", "num_grad_params", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", ")", "/", "1000000.", "\n", "num_backbone_params", "=", "sum", "(", "\n", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "backbone", ".", "parameters", "(", ")", ")", "/", "1000000.", "\n", "num_backbone_grad_params", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "backbone", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", ")", "/", "1000000.", "\n", "print", "(", "\n", "\"Number of backbone parameters: {:.5g} M\"", ".", "format", "(", "num_backbone_params", ")", ")", "\n", "print", "(", "\"Number of backbone parameters requiring grad: {:.5g} M\"", ".", "format", "(", "\n", "num_backbone_grad_params", ")", ")", "\n", "print", "(", "\"Number of total parameters: {:.5g} M\"", ".", "format", "(", "num_params", ")", ")", "\n", "print", "(", "\"Number of total parameters requiring grad: {:.5g} M\"", ".", "format", "(", "\n", "num_grad_params", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.train.parse_args": [[20, 60], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "str"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Train a model'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'train config file path'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--work_dir'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "'the dir to save logs and models'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--resume_from'", ",", "help", "=", "'the checkpoint file to resume from'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--pretrained'", ",", "default", "=", "None", ",", "help", "=", "'pretrained model file'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--gpus'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "1", ",", "\n", "help", "=", "'number of gpus to use '", "\n", "'(only applicable to non-distributed training)'", ")", "\n", "parser", ".", "add_argument", "(", "'--seed'", ",", "type", "=", "int", ",", "default", "=", "None", ",", "help", "=", "'random seed'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--deterministic'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'whether to set deterministic options for CUDNN backend.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--debug'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'debug (one gpu - disable DistributedDataParallel). With this flag, you can set breakpoints'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--launcher'", ",", "\n", "choices", "=", "[", "'none'", ",", "'pytorch'", ",", "'slurm'", ",", "'mpi'", "]", ",", "\n", "default", "=", "'none'", ",", "\n", "help", "=", "'job launcher'", ")", "\n", "parser", ".", "add_argument", "(", "'--local_rank'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "parser", ".", "add_argument", "(", "'--port'", ",", "type", "=", "int", ",", "default", "=", "29500", ",", "\n", "help", "=", "'port only works when launcher==\"slurm\"'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "if", "'LOCAL_RANK'", "not", "in", "os", ".", "environ", ":", "\n", "        ", "os", ".", "environ", "[", "'LOCAL_RANK'", "]", "=", "str", "(", "args", ".", "local_rank", ")", "\n", "\n", "", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.train.main": [[62, 153], ["print", "train.parse_args", "mmcv.Config.fromfile", "Config.fromfile.get", "mmcv.mkdir_or_exist", "time.strftime", "os.join", "openselfsup.utils.get_root_logger", "dict", "openselfsup.utils.collect_env", "openselfsup.utils.get_root_logger.info", "openselfsup.utils.get_root_logger.info", "openselfsup.utils.get_root_logger.info", "openselfsup.models.build_model", "openselfsup.apis.train_model", "importlib.util.find_spec", "openselfsup.utils.traverse_replace", "mmcv.runner.init_dist", "os.abspath", "time.localtime", "openselfsup.utils.get_root_logger.info", "openselfsup.apis.set_random_seed", "isinstance", "openselfsup.utils.get_root_logger.info", "openselfsup.models.build_model.set_debug", "openselfsup.datasets.build_dataset", "len", "dict", "torch.cuda.device_count", "openselfsup.utils.collect_env.items"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect_env.collect_env", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.apis.train.train_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.config_tools.traverse_replace", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.apis.train.set_random_seed", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BaseModel.set_debug", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.builder.build_dataset"], ["", "def", "main", "(", ")", ":", "\n", "    ", "print", "(", "f\"Using num gpus: {torch.cuda.device_count()}\"", ")", "\n", "args", "=", "parse_args", "(", ")", "\n", "\n", "cfg", "=", "Config", ".", "fromfile", "(", "args", ".", "config", ")", "\n", "# set cudnn_benchmark", "\n", "if", "cfg", ".", "get", "(", "'cudnn_benchmark'", ",", "False", ")", ":", "\n", "        ", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "True", "\n", "# update configs according to CLI args", "\n", "", "if", "args", ".", "work_dir", "is", "not", "None", ":", "\n", "        ", "cfg", ".", "work_dir", "=", "args", ".", "work_dir", "\n", "", "if", "args", ".", "resume_from", "is", "not", "None", ":", "\n", "        ", "cfg", ".", "resume_from", "=", "args", ".", "resume_from", "\n", "", "cfg", ".", "gpus", "=", "args", ".", "gpus", "\n", "\n", "# check memcached package exists", "\n", "if", "importlib", ".", "util", ".", "find_spec", "(", "'mc'", ")", "is", "None", ":", "\n", "        ", "traverse_replace", "(", "cfg", ",", "'memcached'", ",", "False", ")", "\n", "\n", "# init distributed env first, since logger depends on the dist info.", "\n", "", "if", "args", ".", "launcher", "==", "'none'", ":", "\n", "        ", "distributed", "=", "False", "\n", "if", "not", "args", ".", "debug", ":", "\n", "            ", "assert", "cfg", ".", "model", ".", "type", "not", "in", "[", "'DeepCluster'", ",", "'MOCO'", ",", "'SimCLR'", ",", "'ODC'", ",", "'NPID'", "]", ",", "\"{} does not support non-dist training unless debugging (use --debug flag).\"", ".", "format", "(", "\n", "cfg", ".", "model", ".", "type", ")", "\n", "", "", "else", ":", "\n", "        ", "distributed", "=", "True", "\n", "if", "args", ".", "launcher", "==", "'slurm'", ":", "\n", "            ", "cfg", ".", "dist_params", "[", "'port'", "]", "=", "args", ".", "port", "\n", "", "init_dist", "(", "args", ".", "launcher", ",", "**", "cfg", ".", "dist_params", ")", "\n", "\n", "# create work_dir", "\n", "", "mmcv", ".", "mkdir_or_exist", "(", "osp", ".", "abspath", "(", "cfg", ".", "work_dir", ")", ")", "\n", "# init the logger before other steps", "\n", "timestamp", "=", "time", ".", "strftime", "(", "'%Y%m%d_%H%M%S'", ",", "time", ".", "localtime", "(", ")", ")", "\n", "log_file", "=", "osp", ".", "join", "(", "cfg", ".", "work_dir", ",", "'train_{}.log'", ".", "format", "(", "timestamp", ")", ")", "\n", "logger", "=", "get_root_logger", "(", "log_file", "=", "log_file", ",", "log_level", "=", "cfg", ".", "log_level", ")", "\n", "\n", "# init the meta dict to record some important information such as", "\n", "# environment info and seed, which will be logged", "\n", "meta", "=", "dict", "(", ")", "\n", "# log env info", "\n", "env_info_dict", "=", "collect_env", "(", ")", "\n", "env_info", "=", "'\\n'", ".", "join", "(", "[", "(", "'{}: {}'", ".", "format", "(", "k", ",", "v", ")", ")", "\n", "for", "k", ",", "v", "in", "env_info_dict", ".", "items", "(", ")", "]", ")", "\n", "dash_line", "=", "'-'", "*", "60", "+", "'\\n'", "\n", "logger", ".", "info", "(", "'Environment info:\\n'", "+", "dash_line", "+", "env_info", "+", "'\\n'", "+", "\n", "dash_line", ")", "\n", "meta", "[", "'env_info'", "]", "=", "env_info", "\n", "\n", "# log some basic info", "\n", "logger", ".", "info", "(", "'Distributed training: {}'", ".", "format", "(", "distributed", ")", ")", "\n", "logger", ".", "info", "(", "'Config:\\n{}'", ".", "format", "(", "cfg", ".", "text", ")", ")", "\n", "\n", "# set random seeds", "\n", "if", "args", ".", "seed", "is", "not", "None", ":", "\n", "        ", "logger", ".", "info", "(", "'Set random seed to {}, deterministic: {}'", ".", "format", "(", "\n", "args", ".", "seed", ",", "args", ".", "deterministic", ")", ")", "\n", "set_random_seed", "(", "args", ".", "seed", ",", "deterministic", "=", "args", ".", "deterministic", ")", "\n", "", "cfg", ".", "seed", "=", "args", ".", "seed", "\n", "meta", "[", "'seed'", "]", "=", "args", ".", "seed", "\n", "\n", "if", "args", ".", "pretrained", "is", "not", "None", ":", "\n", "        ", "assert", "isinstance", "(", "args", ".", "pretrained", ",", "str", ")", "\n", "cfg", ".", "model", ".", "pretrained", "=", "args", ".", "pretrained", "\n", "", "model", "=", "build_model", "(", "cfg", ".", "model", ")", "\n", "if", "args", ".", "debug", ":", "\n", "# TODO(cjrd) fix this hardcoding?", "\n", "        ", "logger", ".", "info", "(", "\n", "\"DEBUGGING enabled, setting batch size to 64 to allow 1 gpu debugging\"", ")", "\n", "cfg", ".", "data", ".", "batch_size", "=", "64", "\n", "model", ".", "set_debug", "(", ")", "\n", "\n", "", "datasets", "=", "[", "build_dataset", "(", "cfg", ".", "data", ".", "train", ")", "]", "\n", "assert", "len", "(", "cfg", ".", "workflow", ")", "==", "1", ",", "\"Validation is called by hook.\"", "\n", "if", "cfg", ".", "checkpoint_config", "is", "not", "None", ":", "\n", "# save openselfsup version, config file content and class names in", "\n", "# checkpoints as meta data", "\n", "        ", "cfg", ".", "checkpoint_config", ".", "meta", "=", "dict", "(", "\n", "openselfsup_version", "=", "__version__", ",", "config", "=", "cfg", ".", "text", ")", "\n", "# add an attribute for visualization convenience", "\n", "", "train_model", "(", "\n", "model", ",", "\n", "datasets", ",", "\n", "cfg", ",", "\n", "distributed", "=", "distributed", ",", "\n", "timestamp", "=", "timestamp", ",", "\n", "meta", "=", "meta", ",", "\n", "debug", "=", "args", ".", "debug", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.test.single_gpu_test": [[18, 24], ["model.eval", "openselfsup.utils.nondist_forward_collect", "model", "len"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect.nondist_forward_collect"], ["def", "single_gpu_test", "(", "model", ",", "data_loader", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "func", "=", "lambda", "**", "x", ":", "model", "(", "mode", "=", "'test'", ",", "**", "x", ")", "\n", "results", "=", "nondist_forward_collect", "(", "func", ",", "data_loader", ",", "\n", "len", "(", "data_loader", ".", "dataset", ")", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.test.multi_gpu_test": [[26, 33], ["model.eval", "mmcv.runner.get_dist_info", "openselfsup.utils.dist_forward_collect", "model", "len"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect.dist_forward_collect"], ["", "def", "multi_gpu_test", "(", "model", ",", "data_loader", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "func", "=", "lambda", "**", "x", ":", "model", "(", "mode", "=", "'test'", ",", "**", "x", ")", "\n", "rank", ",", "world_size", "=", "get_dist_info", "(", ")", "\n", "results", "=", "dist_forward_collect", "(", "func", ",", "data_loader", ",", "rank", ",", "\n", "len", "(", "data_loader", ".", "dataset", ")", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.test.parse_args": [[35, 58], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "str"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'MMDet test (and eval) a model'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'test config file path'", ")", "\n", "parser", ".", "add_argument", "(", "'checkpoint'", ",", "help", "=", "'checkpoint file'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--work_dir'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "'the dir to save logs and models'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--launcher'", ",", "\n", "choices", "=", "[", "'none'", ",", "'pytorch'", ",", "'slurm'", ",", "'mpi'", "]", ",", "\n", "default", "=", "'none'", ",", "\n", "help", "=", "'job launcher'", ")", "\n", "parser", ".", "add_argument", "(", "'--local_rank'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "parser", ".", "add_argument", "(", "'--port'", ",", "type", "=", "int", ",", "default", "=", "29500", ",", "\n", "help", "=", "'port only works when launcher==\"slurm\"'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "if", "'LOCAL_RANK'", "not", "in", "os", ".", "environ", ":", "\n", "        ", "os", ".", "environ", "[", "'LOCAL_RANK'", "]", "=", "str", "(", "args", ".", "local_rank", ")", "\n", "\n", "", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.test.main": [[60, 119], ["test.parse_args", "mmcv.Config.fromfile", "mmcv.Config.fromfile.get", "time.strftime", "os.join", "openselfsup.utils.get_root_logger", "openselfsup.datasets.build_dataset", "openselfsup.datasets.build_dataloader", "openselfsup.models.build_model", "mmcv.runner.load_checkpoint", "mmcv.runner.get_dist_info", "importlib.util.find_spec", "openselfsup.utils.traverse_replace", "mmcv.runner.init_dist", "time.localtime", "mmcv.parallel.MMDataParallel", "test.single_gpu_test", "mmcv.parallel.MMDistributedDataParallel", "test.multi_gpu_test", "multi_gpu_test.items", "mmcv.parallel.MMDistributedDataParallel.cuda", "openselfsup.datasets.build_dataset.evaluate", "torch.from_numpy", "torch.cuda.current_device"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.builder.build_dataset", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.build_loader.build_dataloader", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.config_tools.traverse_replace", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.get_acts.single_gpu_test", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.get_acts.multi_gpu_test", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.deepcluster_hook.DeepClusterHook.evaluate"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "\n", "cfg", "=", "mmcv", ".", "Config", ".", "fromfile", "(", "args", ".", "config", ")", "\n", "# set cudnn_benchmark", "\n", "if", "cfg", ".", "get", "(", "'cudnn_benchmark'", ",", "False", ")", ":", "\n", "        ", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "True", "\n", "# update configs according to CLI args", "\n", "", "if", "args", ".", "work_dir", "is", "not", "None", ":", "\n", "        ", "cfg", ".", "work_dir", "=", "args", ".", "work_dir", "\n", "\n", "", "cfg", ".", "model", ".", "pretrained", "=", "None", "# ensure to use checkpoint rather than pretraining", "\n", "\n", "# check memcached package exists", "\n", "if", "importlib", ".", "util", ".", "find_spec", "(", "'mc'", ")", "is", "None", ":", "\n", "        ", "traverse_replace", "(", "cfg", ",", "'memcached'", ",", "False", ")", "\n", "\n", "# init distributed env first, since logger depends on the dist info.", "\n", "", "if", "args", ".", "launcher", "==", "'none'", ":", "\n", "        ", "distributed", "=", "False", "\n", "", "else", ":", "\n", "        ", "distributed", "=", "True", "\n", "if", "args", ".", "launcher", "==", "'slurm'", ":", "\n", "            ", "cfg", ".", "dist_params", "[", "'port'", "]", "=", "args", ".", "port", "\n", "", "init_dist", "(", "args", ".", "launcher", ",", "**", "cfg", ".", "dist_params", ")", "\n", "\n", "# logger", "\n", "", "timestamp", "=", "time", ".", "strftime", "(", "'%Y%m%d_%H%M%S'", ",", "time", ".", "localtime", "(", ")", ")", "\n", "log_file", "=", "osp", ".", "join", "(", "cfg", ".", "work_dir", ",", "'test_{}.log'", ".", "format", "(", "timestamp", ")", ")", "\n", "logger", "=", "get_root_logger", "(", "log_file", "=", "log_file", ",", "log_level", "=", "cfg", ".", "log_level", ")", "\n", "\n", "# build the dataloader", "\n", "dataset", "=", "build_dataset", "(", "cfg", ".", "data", ".", "val", ")", "\n", "data_loader", "=", "build_dataloader", "(", "\n", "dataset", ",", "\n", "imgs_per_gpu", "=", "cfg", ".", "data", ".", "imgs_per_gpu", ",", "\n", "workers_per_gpu", "=", "cfg", ".", "data", ".", "workers_per_gpu", ",", "\n", "dist", "=", "distributed", ",", "\n", "shuffle", "=", "False", ")", "\n", "\n", "# build the model and load checkpoint", "\n", "model", "=", "build_model", "(", "cfg", ".", "model", ")", "\n", "load_checkpoint", "(", "model", ",", "args", ".", "checkpoint", ",", "map_location", "=", "'cpu'", ")", "\n", "\n", "if", "not", "distributed", ":", "\n", "        ", "model", "=", "MMDataParallel", "(", "model", ",", "device_ids", "=", "[", "0", "]", ")", "\n", "outputs", "=", "single_gpu_test", "(", "model", ",", "data_loader", ")", "\n", "", "else", ":", "\n", "        ", "model", "=", "MMDistributedDataParallel", "(", "\n", "model", ".", "cuda", "(", ")", ",", "\n", "device_ids", "=", "[", "torch", ".", "cuda", ".", "current_device", "(", ")", "]", ",", "\n", "broadcast_buffers", "=", "False", ")", "\n", "outputs", "=", "multi_gpu_test", "(", "model", ",", "data_loader", ")", "# dict{key: np.ndarray}", "\n", "\n", "", "rank", ",", "_", "=", "get_dist_info", "(", ")", "\n", "if", "rank", "==", "0", ":", "\n", "        ", "for", "name", ",", "val", "in", "outputs", ".", "items", "(", ")", ":", "\n", "            ", "dataset", ".", "evaluate", "(", "\n", "torch", ".", "from_numpy", "(", "val", ")", ",", "name", ",", "logger", ",", "topk", "=", "(", "1", ",", "5", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.get_acts.single_gpu_test": [[22, 28], ["model.eval", "openselfsup.utils.nondist_forward_collect", "model", "len"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect.nondist_forward_collect"], ["def", "single_gpu_test", "(", "model", ",", "data_loader", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "func", "=", "lambda", "**", "x", ":", "model", "(", "mode", "=", "'test'", ",", "**", "x", ")", "\n", "results", "=", "nondist_forward_collect", "(", "func", ",", "data_loader", ",", "\n", "len", "(", "data_loader", ".", "dataset", ")", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.get_acts.multi_gpu_test": [[30, 37], ["model.eval", "mmcv.runner.get_dist_info", "openselfsup.utils.dist_forward_collect", "model", "len"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect.dist_forward_collect"], ["", "def", "multi_gpu_test", "(", "model", ",", "data_loader", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "func", "=", "lambda", "**", "x", ":", "model", "(", "mode", "=", "'test'", ",", "**", "x", ")", "\n", "rank", ",", "world_size", "=", "get_dist_info", "(", ")", "\n", "results", "=", "dist_forward_collect", "(", "func", ",", "data_loader", ",", "rank", ",", "\n", "len", "(", "data_loader", ".", "dataset", ")", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.get_acts.parse_args": [[39, 65], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "str"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'MMDet test (and eval) a model'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'test config file path'", ")", "\n", "parser", ".", "add_argument", "(", "'checkpoint'", ",", "help", "=", "'checkpoint file'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--work_dir'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "'the dir to save logs and models'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--launcher'", ",", "\n", "choices", "=", "[", "'none'", ",", "'pytorch'", ",", "'slurm'", ",", "'mpi'", "]", ",", "\n", "default", "=", "'none'", ",", "\n", "help", "=", "'job launcher'", ")", "\n", "parser", ".", "add_argument", "(", "'--local_rank'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "parser", ".", "add_argument", "(", "'--port'", ",", "type", "=", "int", ",", "default", "=", "29500", ",", "\n", "help", "=", "'port only works when launcher==\"slurm\"'", ")", "\n", "parser", ".", "add_argument", "(", "'--grab-conv'", ",", "dest", "=", "'layer_type'", ",", "action", "=", "'store_const'", ",", "\n", "default", "=", "nn", ".", "Linear", ",", "const", "=", "nn", ".", "Conv2d", ",", "\n", "help", "=", "'save conv activations instead of linear'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "if", "'LOCAL_RANK'", "not", "in", "os", ".", "environ", ":", "\n", "        ", "os", ".", "environ", "[", "'LOCAL_RANK'", "]", "=", "str", "(", "args", ".", "local_rank", ")", "\n", "\n", "", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.get_acts.main": [[67, 140], ["get_acts.parse_args", "mmcv.Config.fromfile", "mmcv.Config.fromfile.get", "time.strftime", "os.join", "openselfsup.utils.get_root_logger", "openselfsup.datasets.build_dataset", "openselfsup.datasets.build_dataloader", "openselfsup.models.build_model", "collections.defaultdict", "mmcv.runner.load_checkpoint", "mmcv.parallel.MMDistributedDataParallel.named_modules", "os.join", "numpy.savez", "importlib.util.find_spec", "openselfsup.utils.traverse_replace", "mmcv.runner.init_dist", "time.localtime", "mmcv.parallel.MMDataParallel", "get_acts.single_gpu_test", "NotImplementedError", "mmcv.parallel.MMDistributedDataParallel", "get_acts.multi_gpu_test", "torch.cat", "activations[].append", "type", "m.register_forward_hook", "mmcv.parallel.MMDistributedDataParallel.cuda", "collections.defaultdict.items", "out.cpu", "out.cpu", "functools.partial", "torch.cuda.current_device"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.builder.build_dataset", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.build_loader.build_dataloader", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.config_tools.traverse_replace", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.get_acts.single_gpu_test", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.get_acts.multi_gpu_test", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "\n", "cfg", "=", "mmcv", ".", "Config", ".", "fromfile", "(", "args", ".", "config", ")", "\n", "# set cudnn_benchmark", "\n", "if", "cfg", ".", "get", "(", "'cudnn_benchmark'", ",", "False", ")", ":", "\n", "        ", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "True", "\n", "# update configs according to CLI args", "\n", "", "if", "args", ".", "work_dir", "is", "not", "None", ":", "\n", "        ", "cfg", ".", "work_dir", "=", "args", ".", "work_dir", "\n", "\n", "", "cfg", ".", "model", ".", "pretrained", "=", "None", "# ensure to use checkpoint rather than pretraining", "\n", "\n", "# check memcached package exists", "\n", "if", "importlib", ".", "util", ".", "find_spec", "(", "'mc'", ")", "is", "None", ":", "\n", "        ", "traverse_replace", "(", "cfg", ",", "'memcached'", ",", "False", ")", "\n", "\n", "# init distributed env first, since logger depends on the dist info.", "\n", "", "if", "args", ".", "launcher", "==", "'none'", ":", "\n", "        ", "distributed", "=", "False", "\n", "", "else", ":", "\n", "        ", "distributed", "=", "True", "\n", "if", "args", ".", "launcher", "==", "'slurm'", ":", "\n", "            ", "cfg", ".", "dist_params", "[", "'port'", "]", "=", "args", ".", "port", "\n", "", "init_dist", "(", "args", ".", "launcher", ",", "**", "cfg", ".", "dist_params", ")", "\n", "\n", "# logger", "\n", "", "timestamp", "=", "time", ".", "strftime", "(", "'%Y%m%d_%H%M%S'", ",", "time", ".", "localtime", "(", ")", ")", "\n", "log_file", "=", "osp", ".", "join", "(", "cfg", ".", "work_dir", ",", "'test_{}.log'", ".", "format", "(", "timestamp", ")", ")", "\n", "logger", "=", "get_root_logger", "(", "log_file", "=", "log_file", ",", "log_level", "=", "cfg", ".", "log_level", ")", "\n", "\n", "# build the dataloader", "\n", "dataset", "=", "build_dataset", "(", "cfg", ".", "data", ".", "val", ")", "\n", "data_loader", "=", "build_dataloader", "(", "\n", "dataset", ",", "\n", "imgs_per_gpu", "=", "cfg", ".", "data", ".", "imgs_per_gpu", ",", "\n", "workers_per_gpu", "=", "cfg", ".", "data", ".", "workers_per_gpu", ",", "\n", "dist", "=", "distributed", ",", "\n", "shuffle", "=", "False", ")", "\n", "\n", "# build the model and load checkpoint", "\n", "model", "=", "build_model", "(", "cfg", ".", "model", ")", "\n", "\n", "activations", "=", "defaultdict", "(", "list", ")", "\n", "#idea from gist.github.com/Tushar-N/680633ec18f5cb4b47933da7d10902af", "\n", "if", "args", ".", "layer_type", "==", "nn", ".", "Linear", ":", "#can save all activations", "\n", "        ", "def", "save_activation", "(", "name", ",", "mod", ",", "inp", ",", "out", ")", ":", "\n", "            ", "activations", "[", "name", "]", ".", "append", "(", "out", ".", "cpu", "(", ")", ")", "\n", "", "", "else", ":", "\n", "        ", "def", "save_activation", "(", "name", ",", "mod", ",", "inp", ",", "out", ")", ":", "\n", "            ", "activations", "[", "name", "]", "=", "[", "out", ".", "cpu", "(", ")", "]", "\n", "", "", "load_checkpoint", "(", "model", ",", "args", ".", "checkpoint", ",", "map_location", "=", "'cpu'", ")", "\n", "for", "name", ",", "m", "in", "model", ".", "named_modules", "(", ")", ":", "\n", "        ", "if", "type", "(", "m", ")", "==", "args", ".", "layer_type", ":", "\n", "            ", "m", ".", "register_forward_hook", "(", "partial", "(", "save_activation", ",", "name", ")", ")", "\n", "\n", "\n", "", "", "if", "not", "distributed", ":", "\n", "        ", "model", "=", "MMDataParallel", "(", "model", ",", "device_ids", "=", "[", "0", "]", ")", "\n", "outputs", "=", "single_gpu_test", "(", "model", ",", "data_loader", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"Distributed Data Parallel does not register hooks.\"", ")", "\n", "model", "=", "MMDistributedDataParallel", "(", "\n", "model", ".", "cuda", "(", ")", ",", "\n", "device_ids", "=", "[", "torch", ".", "cuda", ".", "current_device", "(", ")", "]", ",", "\n", "broadcast_buffers", "=", "False", ")", "\n", "outputs", "=", "multi_gpu_test", "(", "model", ",", "data_loader", ")", "# dict{key: np.ndarray}", "\n", "\n", "\n", "", "activations", "=", "{", "name", ":", "torch", ".", "cat", "(", "outputs", ",", "0", ")", "for", "name", ",", "outputs", "in", "activations", ".", "items", "(", ")", "}", "\n", "\n", "act_file", "=", "osp", ".", "join", "(", "cfg", ".", "work_dir", ",", "\"model_acts\"", ")", "\n", "np", ".", "savez", "(", "act_file", ",", "**", "activations", ")", "\n", "# rank, _ = get_dist_info()", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.upgrade_models.parse_args": [[5, 12], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'checkpoint'", ",", "help", "=", "'checkpoint file'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--save-path'", ",", "type", "=", "str", ",", "required", "=", "True", ",", "help", "=", "'destination file name'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.upgrade_models.main": [[14, 24], ["upgrade_models.parse_args", "torch.load", "dict", "torch.load.items", "torch.save", "key.startswith", "torch.device", "dict"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "ck", "=", "torch", ".", "load", "(", "args", ".", "checkpoint", ",", "map_location", "=", "torch", ".", "device", "(", "'cpu'", ")", ")", "\n", "output_dict", "=", "dict", "(", "state_dict", "=", "dict", "(", ")", ",", "author", "=", "'OpenSelfSup'", ")", "\n", "for", "key", ",", "value", "in", "ck", ".", "items", "(", ")", ":", "\n", "        ", "if", "key", ".", "startswith", "(", "'head'", ")", ":", "\n", "            ", "continue", "\n", "", "else", ":", "\n", "            ", "output_dict", "[", "'state_dict'", "]", "[", "key", "]", "=", "value", "\n", "", "", "torch", ".", "save", "(", "output_dict", ",", "args", ".", "save_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.ExtractProcess.__init__": [[22, 28], ["extract.ExtractProcess.models.utils.MultiPooling"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "pool_type", "=", "'specified'", ",", "\n", "backbone", "=", "'resnet50'", ",", "\n", "layer_indices", "=", "(", "0", ",", "1", ",", "2", ",", "3", ",", "4", ")", ")", ":", "\n", "        ", "self", ".", "multi_pooling", "=", "MultiPooling", "(", "\n", "pool_type", ",", "in_indices", "=", "layer_indices", ",", "backbone", "=", "backbone", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.ExtractProcess._forward_func": [[29, 36], ["model", "extract.ExtractProcess.multi_pooling", "xx.view", "feat.cpu", "xx.size", "enumerate"], "methods", ["None"], ["", "def", "_forward_func", "(", "self", ",", "model", ",", "**", "x", ")", ":", "\n", "        ", "backbone_feats", "=", "model", "(", "mode", "=", "'extract'", ",", "**", "x", ")", "\n", "pooling_feats", "=", "self", ".", "multi_pooling", "(", "backbone_feats", ")", "\n", "flat_feats", "=", "[", "xx", ".", "view", "(", "xx", ".", "size", "(", "0", ")", ",", "-", "1", ")", "for", "xx", "in", "pooling_feats", "]", "\n", "feat_dict", "=", "{", "'feat{}'", ".", "format", "(", "i", "+", "1", ")", ":", "feat", ".", "cpu", "(", ")", "for", "i", ",", "feat", "in", "enumerate", "(", "flat_feats", ")", "}", "\n", "return", "feat_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.ExtractProcess.extract": [[37, 48], ["model.eval", "extract.ExtractProcess._forward_func", "mmcv.runner.get_dist_info", "extract.ExtractProcess.utils.dist_forward_collect", "extract.ExtractProcess.utils.nondist_forward_collect", "len", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.extractor.Extractor._forward_func", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect.dist_forward_collect", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect.nondist_forward_collect"], ["", "def", "extract", "(", "self", ",", "model", ",", "data_loader", ",", "distributed", "=", "False", ")", ":", "\n", "        ", "model", ".", "eval", "(", ")", "\n", "func", "=", "lambda", "**", "x", ":", "self", ".", "_forward_func", "(", "model", ",", "**", "x", ")", "\n", "if", "distributed", ":", "\n", "            ", "rank", ",", "world_size", "=", "get_dist_info", "(", ")", "\n", "results", "=", "dist_forward_collect", "(", "func", ",", "data_loader", ",", "rank", ",", "\n", "len", "(", "data_loader", ".", "dataset", ")", ")", "\n", "", "else", ":", "\n", "            ", "results", "=", "nondist_forward_collect", "(", "func", ",", "data_loader", ",", "\n", "len", "(", "data_loader", ".", "dataset", ")", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args": [[50, 83], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "str"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args"], ["", "", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'OpenSelfSup extract features of a model'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'test config file path'", ")", "\n", "parser", ".", "add_argument", "(", "'--checkpoint'", ",", "default", "=", "None", ",", "help", "=", "'checkpoint file'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--pretrained'", ",", "default", "=", "'random'", ",", "\n", "help", "=", "'pretrained model file, exclusive to --checkpoint'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--dataset-config'", ",", "\n", "default", "=", "'benchmarks/extract_info/voc07.py'", ",", "\n", "help", "=", "'extract dataset config file path'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--layer-ind'", ",", "\n", "type", "=", "str", ",", "\n", "help", "=", "'layer indices, separated by comma, e.g., \"0,1,2,3,4\"'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--work_dir'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "'the dir to save logs and models'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--launcher'", ",", "\n", "choices", "=", "[", "'none'", ",", "'pytorch'", ",", "'slurm'", ",", "'mpi'", "]", ",", "\n", "default", "=", "'none'", ",", "\n", "help", "=", "'job launcher'", ")", "\n", "parser", ".", "add_argument", "(", "'--local_rank'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "parser", ".", "add_argument", "(", "'--port'", ",", "type", "=", "int", ",", "default", "=", "29500", ",", "\n", "help", "=", "'port only works when launcher==\"slurm\"'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "if", "'LOCAL_RANK'", "not", "in", "os", ".", "environ", ":", "\n", "        ", "os", ".", "environ", "[", "'LOCAL_RANK'", "]", "=", "str", "(", "args", ".", "local_rank", ")", "\n", "", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.main": [[85, 179], ["extract.parse_args", "mmcv.Config.fromfile", "mmcv.Config.fromfile.get", "mmcv.mkdir_or_exist", "time.strftime", "os.join", "openselfsup.utils.get_root_logger", "mmcv.Config.fromfile", "openselfsup.datasets.build_dataset", "openselfsup.datasets.build_dataloader", "openselfsup.models.build_model", "extract.ExtractProcess", "ExtractProcess.extract", "mmcv.runner.get_dist_info", "mmcv.mkdir_or_exist", "int", "importlib.util.find_spec", "mmcv.runner.init_dist", "os.abspath", "time.localtime", "isinstance", "openselfsup.utils.get_root_logger.info", "mmcv.runner.load_checkpoint", "mmcv.parallel.MMDataParallel", "mmcv.parallel.MMDistributedDataParallel", "extractor.extract.items", "parse_args.layer_ind.split", "hasattr", "openselfsup.utils.get_root_logger.info", "openselfsup.utils.get_root_logger.info", "mmcv.parallel.MMDistributedDataParallel.cuda", "len", "range", "torch.cuda.current_device", "numpy.save", "getattr", "numpy.save", "numpy.save"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.builder.build_dataset", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.build_loader.build_dataloader", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.ExtractProcess.extract", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "cfg", "=", "mmcv", ".", "Config", ".", "fromfile", "(", "args", ".", "config", ")", "\n", "# set cudnn_benchmark", "\n", "if", "cfg", ".", "get", "(", "'cudnn_benchmark'", ",", "False", ")", ":", "\n", "        ", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "True", "\n", "# update configs according to CLI args", "\n", "", "if", "args", ".", "work_dir", "is", "not", "None", ":", "\n", "        ", "cfg", ".", "work_dir", "=", "args", ".", "work_dir", "\n", "", "layer_ind", "=", "[", "int", "(", "idx", ")", "for", "idx", "in", "args", ".", "layer_ind", ".", "split", "(", "','", ")", "]", "\n", "cfg", ".", "model", ".", "backbone", ".", "out_indices", "=", "layer_ind", "\n", "\n", "# checkpoint and pretrained are exclusive", "\n", "assert", "args", ".", "pretrained", "==", "\"random\"", "or", "args", ".", "checkpoint", "is", "None", ",", "\"Checkpoint and pretrained are exclusive.\"", "\n", "\n", "# check memcached package exists", "\n", "if", "importlib", ".", "util", ".", "find_spec", "(", "'mc'", ")", "is", "None", ":", "\n", "        ", "for", "field", "in", "[", "'train'", ",", "'val'", ",", "'test'", "]", ":", "\n", "            ", "if", "hasattr", "(", "cfg", ".", "data", ",", "field", ")", ":", "\n", "                ", "getattr", "(", "cfg", ".", "data", ",", "field", ")", ".", "data_source", ".", "memcached", "=", "False", "\n", "\n", "# init distributed env first, since logger depends on the dist info.", "\n", "", "", "", "if", "args", ".", "launcher", "==", "'none'", ":", "\n", "        ", "distributed", "=", "False", "\n", "", "else", ":", "\n", "        ", "distributed", "=", "True", "\n", "if", "args", ".", "launcher", "==", "'slurm'", ":", "\n", "            ", "cfg", ".", "dist_params", "[", "'port'", "]", "=", "args", ".", "port", "\n", "", "init_dist", "(", "args", ".", "launcher", ",", "**", "cfg", ".", "dist_params", ")", "\n", "\n", "# create work_dir", "\n", "", "mmcv", ".", "mkdir_or_exist", "(", "osp", ".", "abspath", "(", "cfg", ".", "work_dir", ")", ")", "\n", "# logger", "\n", "timestamp", "=", "time", ".", "strftime", "(", "'%Y%m%d_%H%M%S'", ",", "time", ".", "localtime", "(", ")", ")", "\n", "log_file", "=", "osp", ".", "join", "(", "cfg", ".", "work_dir", ",", "'extract_{}.log'", ".", "format", "(", "timestamp", ")", ")", "\n", "logger", "=", "get_root_logger", "(", "log_file", "=", "log_file", ",", "log_level", "=", "cfg", ".", "log_level", ")", "\n", "\n", "# build the dataloader", "\n", "dataset_cfg", "=", "mmcv", ".", "Config", ".", "fromfile", "(", "args", ".", "dataset_config", ")", "\n", "dataset", "=", "build_dataset", "(", "dataset_cfg", ".", "data", ".", "extract", ")", "\n", "data_loader", "=", "build_dataloader", "(", "\n", "dataset", ",", "\n", "imgs_per_gpu", "=", "dataset_cfg", ".", "data", ".", "imgs_per_gpu", ",", "\n", "workers_per_gpu", "=", "dataset_cfg", ".", "data", ".", "workers_per_gpu", ",", "\n", "dist", "=", "distributed", ",", "\n", "shuffle", "=", "False", ")", "\n", "\n", "# specify pretrained model", "\n", "if", "args", ".", "pretrained", "!=", "'random'", ":", "\n", "        ", "assert", "isinstance", "(", "args", ".", "pretrained", ",", "str", ")", "\n", "cfg", ".", "model", ".", "pretrained", "=", "args", ".", "pretrained", "\n", "\n", "# build the model and load checkpoint", "\n", "", "model", "=", "build_model", "(", "cfg", ".", "model", ")", "\n", "if", "args", ".", "checkpoint", "is", "not", "None", ":", "\n", "        ", "logger", ".", "info", "(", "\"Use checkpoint: {} to extract features\"", ".", "format", "(", "\n", "args", ".", "checkpoint", ")", ")", "\n", "load_checkpoint", "(", "model", ",", "args", ".", "checkpoint", ",", "map_location", "=", "'cpu'", ")", "\n", "", "elif", "args", ".", "pretrained", "!=", "\"random\"", ":", "\n", "        ", "logger", ".", "info", "(", "'Use pretrained model: {} to extract features'", ".", "format", "(", "\n", "args", ".", "pretrained", ")", ")", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "'No checkpoint or pretrained is give, use random init.'", ")", "\n", "\n", "", "if", "not", "distributed", ":", "\n", "        ", "model", "=", "MMDataParallel", "(", "model", ",", "device_ids", "=", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "        ", "model", "=", "MMDistributedDataParallel", "(", "\n", "model", ".", "cuda", "(", ")", ",", "\n", "device_ids", "=", "[", "torch", ".", "cuda", ".", "current_device", "(", ")", "]", ",", "\n", "broadcast_buffers", "=", "False", ")", "\n", "\n", "# build extraction processor", "\n", "", "extractor", "=", "ExtractProcess", "(", "\n", "pool_type", "=", "'specified'", ",", "backbone", "=", "'resnet50'", ",", "layer_indices", "=", "layer_ind", ")", "\n", "\n", "# run", "\n", "outputs", "=", "extractor", ".", "extract", "(", "model", ",", "data_loader", ",", "distributed", "=", "distributed", ")", "\n", "rank", ",", "_", "=", "get_dist_info", "(", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "\"{}/features/\"", ".", "format", "(", "args", ".", "work_dir", ")", ")", "\n", "if", "rank", "==", "0", ":", "\n", "        ", "for", "key", ",", "val", "in", "outputs", ".", "items", "(", ")", ":", "\n", "            ", "split_num", "=", "len", "(", "dataset_cfg", ".", "split_name", ")", "\n", "split_at", "=", "dataset_cfg", ".", "split_at", "\n", "for", "ss", "in", "range", "(", "split_num", ")", ":", "\n", "                ", "output_file", "=", "\"{}/features/{}_{}.npy\"", ".", "format", "(", "\n", "args", ".", "work_dir", ",", "dataset_cfg", ".", "split_name", "[", "ss", "]", ",", "key", ")", "\n", "if", "ss", "==", "0", ":", "\n", "                    ", "np", ".", "save", "(", "output_file", ",", "val", "[", ":", "split_at", "[", "0", "]", "]", ")", "\n", "", "elif", "ss", "==", "split_num", "-", "1", ":", "\n", "                    ", "np", ".", "save", "(", "output_file", ",", "val", "[", "split_at", "[", "-", "1", "]", ":", "]", ")", "\n", "", "else", ":", "\n", "                    ", "np", ".", "save", "(", "output_file", ",", "val", "[", "split_at", "[", "ss", "-", "1", "]", ":", "split_at", "[", "ss", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deploy.caffe2_converter.setup_cfg": [[17, 28], ["detectron2.config.get_cfg", "detectron2.export.add_export_config", "detectron2.export.add_export_config.merge_from_file", "detectron2.export.add_export_config.merge_from_list", "detectron2.export.add_export_config.freeze"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.add_export_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze"], ["def", "setup_cfg", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "get_cfg", "(", ")", "\n", "# cuda context is initialized before creating dataloader, so we don't fork anymore", "\n", "cfg", ".", "DATALOADER", ".", "NUM_WORKERS", "=", "0", "\n", "cfg", "=", "add_export_config", "(", "cfg", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "if", "cfg", ".", "MODEL", ".", "DEVICE", "!=", "\"cpu\"", ":", "\n", "        ", "assert", "TORCH_VERSION", ">=", "(", "1", ",", "5", ")", ",", "\"PyTorch>=1.5 required for GPU conversion!\"", "\n", "", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.docs.conf.GithubURLDomain.resolve_any_xref": [[39, 58], ["target.startswith", "target.replace", "print", "target.endswith", "github_url.endswith", "github_url.endswith"], "methods", ["None"], ["def", "resolve_any_xref", "(", "self", ",", "env", ",", "fromdocname", ",", "builder", ",", "target", ",", "node", ",", "contnode", ")", ":", "\n", "        ", "github_url", "=", "None", "\n", "if", "not", "target", ".", "endswith", "(", "\"html\"", ")", "and", "target", ".", "startswith", "(", "\"../../\"", ")", ":", "\n", "            ", "url", "=", "target", ".", "replace", "(", "\"../\"", ",", "\"\"", ")", "\n", "github_url", "=", "url", "\n", "", "if", "fromdocname", "in", "self", ".", "LINKED_DOC", ":", "\n", "# unresolved links in these docs are all github links", "\n", "            ", "github_url", "=", "target", "\n", "\n", "", "if", "github_url", "is", "not", "None", ":", "\n", "            ", "if", "github_url", ".", "endswith", "(", "\"MODEL_ZOO\"", ")", "or", "github_url", ".", "endswith", "(", "\"README\"", ")", ":", "\n", "# bug of recommonmark.", "\n", "# https://github.com/readthedocs/recommonmark/blob/ddd56e7717e9745f11300059e4268e204138a6b1/recommonmark/parser.py#L152-L155", "\n", "                ", "github_url", "+=", "\".md\"", "\n", "", "print", "(", "\"Ref {} resolved to github:{}\"", ".", "format", "(", "target", ",", "github_url", ")", ")", "\n", "contnode", "[", "\"refuri\"", "]", "=", "self", ".", "ROOT", "+", "github_url", "\n", "return", "[", "(", "\"githuburl:any\"", ",", "contnode", ")", "]", "\n", "", "else", ":", "\n", "            ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.docs.conf.autodoc_skip_member": [[262, 286], ["getattr", "obj.__doc__.lower().strip().startswith", "print", "obj.__doc__.lower().strip", "obj.__doc__.lower"], "function", ["None"], ["def", "autodoc_skip_member", "(", "app", ",", "what", ",", "name", ",", "obj", ",", "skip", ",", "options", ")", ":", "\n", "# we hide something deliberately", "\n", "    ", "if", "getattr", "(", "obj", ",", "\"__HIDE_SPHINX_DOC__\"", ",", "False", ")", ":", "\n", "        ", "return", "True", "\n", "\n", "# Hide some that are deprecated or not intended to be used", "\n", "", "HIDDEN", "=", "{", "\n", "\"ResNetBlockBase\"", ",", "\n", "\"GroupedBatchSampler\"", ",", "\n", "\"build_transform_gen\"", ",", "\n", "\"export_caffe2_model\"", ",", "\n", "\"export_onnx_model\"", ",", "\n", "\"apply_transform_gens\"", ",", "\n", "\"TransformGen\"", ",", "\n", "\"apply_augmentations\"", ",", "\n", "\"StandardAugInput\"", ",", "\n", "}", "\n", "try", ":", "\n", "        ", "if", "obj", ".", "__doc__", ".", "lower", "(", ")", ".", "strip", "(", ")", ".", "startswith", "(", "\"deprecated\"", ")", "or", "name", "in", "HIDDEN", ":", "\n", "            ", "print", "(", "\"Skipping deprecated object: {}\"", ".", "format", "(", "name", ")", ")", "\n", "return", "True", "\n", "", "", "except", ":", "\n", "        ", "pass", "\n", "", "return", "skip", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.docs.conf.paper_ref_role": [[307, 336], ["utils.unescape", "split_explicit_title", "link.lower.lower", "nodes.reference", "inliner.reporter.warning"], "function", ["None"], ["def", "paper_ref_role", "(", "\n", "typ", ":", "str", ",", "\n", "rawtext", ":", "str", ",", "\n", "text", ":", "str", ",", "\n", "lineno", ":", "int", ",", "\n", "inliner", ",", "\n", "options", ":", "Dict", "=", "{", "}", ",", "\n", "content", ":", "List", "[", "str", "]", "=", "[", "]", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Parse :paper:`xxx`. Similar to the \"extlinks\" sphinx extension.\n    \"\"\"", "\n", "from", "docutils", "import", "nodes", ",", "utils", "\n", "from", "sphinx", ".", "util", ".", "nodes", "import", "split_explicit_title", "\n", "\n", "text", "=", "utils", ".", "unescape", "(", "text", ")", "\n", "has_explicit_title", ",", "title", ",", "link", "=", "split_explicit_title", "(", "text", ")", "\n", "link", "=", "link", ".", "lower", "(", ")", "\n", "if", "link", "not", "in", "_PAPER_DATA", ":", "\n", "        ", "inliner", ".", "reporter", ".", "warning", "(", "\"Cannot find paper \"", "+", "link", ")", "\n", "paper_url", ",", "paper_title", "=", "\"#\"", ",", "link", "\n", "", "else", ":", "\n", "        ", "paper_url", ",", "paper_title", "=", "_PAPER_DATA", "[", "link", "]", "\n", "if", "\"/\"", "not", "in", "paper_url", ":", "\n", "            ", "paper_url", "=", "\"https://arxiv.org/abs/\"", "+", "paper_url", "\n", "", "", "if", "not", "has_explicit_title", ":", "\n", "        ", "title", "=", "paper_title", "\n", "", "pnode", "=", "nodes", ".", "reference", "(", "title", ",", "title", ",", "internal", "=", "False", ",", "refuri", "=", "paper_url", ")", "\n", "return", "[", "pnode", "]", ",", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.docs.conf.setup": [[338, 350], ["app.add_domain", "app.connect", "app.add_role", "app.add_config_value", "app.add_transform"], "function", ["None"], ["", "def", "setup", "(", "app", ")", ":", "\n", "    ", "from", "recommonmark", ".", "transform", "import", "AutoStructify", "\n", "\n", "app", ".", "add_domain", "(", "GithubURLDomain", ")", "\n", "app", ".", "connect", "(", "\"autodoc-skip-member\"", ",", "autodoc_skip_member", ")", "\n", "app", ".", "add_role", "(", "\"paper\"", ",", "paper_ref_role", ")", "\n", "app", ".", "add_config_value", "(", "\n", "\"recommonmark_config\"", ",", "\n", "{", "\"enable_math\"", ":", "True", ",", "\"enable_inline_math\"", ":", "True", ",", "\"enable_eval_rst\"", ":", "True", "}", ",", "\n", "True", ",", "\n", ")", "\n", "app", ".", "add_transform", "(", "AutoStructify", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.postprocessing.detector_postprocess": [[11, 73], ["isinstance", "isinstance", "detectron2.structures.Instances", "detectron2.structures.Instances.has", "output_boxes.scale", "output_boxes.clip", "detectron2.structures.Instances.has", "detectron2.structures.Instances.has", "output_width.float", "output_height.float", "detectron2.structures.Instances.has", "detectron2.structures.Instances.get_fields", "output_boxes.nonempty", "detectron2.utils.memory.retry_if_cuda_oom"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.scale", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.get_fields", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.nonempty", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.memory.retry_if_cuda_oom"], ["def", "detector_postprocess", "(", "results", ",", "output_height", ",", "output_width", ",", "mask_threshold", "=", "0.5", ")", ":", "\n", "    ", "\"\"\"\n    Resize the output instances.\n    The input images are often resized when entering an object detector.\n    As a result, we often need the outputs of the detector in a different\n    resolution from its inputs.\n\n    This function will resize the raw outputs of an R-CNN detector\n    to produce outputs according to the desired output resolution.\n\n    Args:\n        results (Instances): the raw outputs from the detector.\n            `results.image_size` contains the input image resolution the detector sees.\n            This object might be modified in-place.\n        output_height, output_width: the desired output resolution.\n\n    Returns:\n        Instances: the resized output from the model, based on the output resolution\n    \"\"\"", "\n", "\n", "# Converts integer tensors to float temporaries", "\n", "#   to ensure true division is performed when", "\n", "#   computing scale_x and scale_y.", "\n", "if", "isinstance", "(", "output_width", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "output_width_tmp", "=", "output_width", ".", "float", "(", ")", "\n", "", "else", ":", "\n", "        ", "output_width_tmp", "=", "output_width", "\n", "\n", "", "if", "isinstance", "(", "output_height", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "output_height_tmp", "=", "output_height", ".", "float", "(", ")", "\n", "", "else", ":", "\n", "        ", "output_height_tmp", "=", "output_height", "\n", "\n", "", "scale_x", ",", "scale_y", "=", "(", "\n", "output_width_tmp", "/", "results", ".", "image_size", "[", "1", "]", ",", "\n", "output_height_tmp", "/", "results", ".", "image_size", "[", "0", "]", ",", "\n", ")", "\n", "results", "=", "Instances", "(", "(", "output_height", ",", "output_width", ")", ",", "**", "results", ".", "get_fields", "(", ")", ")", "\n", "\n", "if", "results", ".", "has", "(", "\"pred_boxes\"", ")", ":", "\n", "        ", "output_boxes", "=", "results", ".", "pred_boxes", "\n", "", "elif", "results", ".", "has", "(", "\"proposal_boxes\"", ")", ":", "\n", "        ", "output_boxes", "=", "results", ".", "proposal_boxes", "\n", "\n", "", "output_boxes", ".", "scale", "(", "scale_x", ",", "scale_y", ")", "\n", "output_boxes", ".", "clip", "(", "results", ".", "image_size", ")", "\n", "\n", "results", "=", "results", "[", "output_boxes", ".", "nonempty", "(", ")", "]", "\n", "\n", "if", "results", ".", "has", "(", "\"pred_masks\"", ")", ":", "\n", "        ", "results", ".", "pred_masks", "=", "retry_if_cuda_oom", "(", "paste_masks_in_image", ")", "(", "\n", "results", ".", "pred_masks", "[", ":", ",", "0", ",", ":", ",", ":", "]", ",", "# N, 1, M, M", "\n", "results", ".", "pred_boxes", ",", "\n", "results", ".", "image_size", ",", "\n", "threshold", "=", "mask_threshold", ",", "\n", ")", "\n", "\n", "", "if", "results", ".", "has", "(", "\"pred_keypoints\"", ")", ":", "\n", "        ", "results", ".", "pred_keypoints", "[", ":", ",", ":", ",", "0", "]", "*=", "scale_x", "\n", "results", ".", "pred_keypoints", "[", ":", ",", ":", ",", "1", "]", "*=", "scale_y", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.postprocessing.sem_seg_postprocess": [[75, 99], ["result[].expand", "torch.nn.functional.interpolate"], "function", ["None"], ["", "def", "sem_seg_postprocess", "(", "result", ",", "img_size", ",", "output_height", ",", "output_width", ")", ":", "\n", "    ", "\"\"\"\n    Return semantic segmentation predictions in the original resolution.\n\n    The input images are often resized when entering semantic segmentor. Moreover, in same\n    cases, they also padded inside segmentor to be divisible by maximum network stride.\n    As a result, we often need the predictions of the segmentor in a different\n    resolution from its inputs.\n\n    Args:\n        result (Tensor): semantic segmentation prediction logits. A tensor of shape (C, H, W),\n            where C is the number of classes, and H, W are the height and width of the prediction.\n        img_size (tuple): image size that segmentor is taking as input.\n        output_height, output_width: the desired output resolution.\n\n    Returns:\n        semantic segmentation prediction (Tensor): A tensor of the shape\n            (C, output_height, output_width) that contains per-pixel soft predictions.\n    \"\"\"", "\n", "result", "=", "result", "[", ":", ",", ":", "img_size", "[", "0", "]", ",", ":", "img_size", "[", "1", "]", "]", ".", "expand", "(", "1", ",", "-", "1", ",", "-", "1", ",", "-", "1", ")", "\n", "result", "=", "F", ".", "interpolate", "(", "\n", "result", ",", "size", "=", "(", "output_height", ",", "output_width", ")", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "[", "0", "]", "\n", "return", "result", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.matcher.Matcher.__init__": [[24, 60], ["thresholds.insert", "thresholds.append", "all", "all", "float", "len", "float", "len", "zip"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "thresholds", ":", "List", "[", "float", "]", ",", "labels", ":", "List", "[", "int", "]", ",", "allow_low_quality_matches", ":", "bool", "=", "False", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            thresholds (list): a list of thresholds used to stratify predictions\n                into levels.\n            labels (list): a list of values to label predictions belonging at\n                each level. A label can be one of {-1, 0, 1} signifying\n                {ignore, negative class, positive class}, respectively.\n            allow_low_quality_matches (bool): if True, produce additional matches\n                for predictions with maximum match quality lower than high_threshold.\n                See set_low_quality_matches_ for more details.\n\n            For example,\n                thresholds = [0.3, 0.5]\n                labels = [0, -1, 1]\n                All predictions with iou < 0.3 will be marked with 0 and\n                thus will be considered as false positives while training.\n                All predictions with 0.3 <= iou < 0.5 will be marked with -1 and\n                thus will be ignored.\n                All predictions with 0.5 <= iou will be marked with 1 and\n                thus will be considered as true positives.\n        \"\"\"", "\n", "# Add -inf and +inf to first and last position in thresholds", "\n", "thresholds", "=", "thresholds", "[", ":", "]", "\n", "assert", "thresholds", "[", "0", "]", ">", "0", "\n", "thresholds", ".", "insert", "(", "0", ",", "-", "float", "(", "\"inf\"", ")", ")", "\n", "thresholds", ".", "append", "(", "float", "(", "\"inf\"", ")", ")", "\n", "# Currently torchscript does not support all + generator", "\n", "assert", "all", "(", "[", "low", "<=", "high", "for", "(", "low", ",", "high", ")", "in", "zip", "(", "thresholds", "[", ":", "-", "1", "]", ",", "thresholds", "[", "1", ":", "]", ")", "]", ")", "\n", "assert", "all", "(", "[", "l", "in", "[", "-", "1", ",", "0", ",", "1", "]", "for", "l", "in", "labels", "]", ")", "\n", "assert", "len", "(", "labels", ")", "==", "len", "(", "thresholds", ")", "-", "1", "\n", "self", ".", "thresholds", "=", "thresholds", "\n", "self", ".", "labels", "=", "labels", "\n", "self", ".", "allow_low_quality_matches", "=", "allow_low_quality_matches", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.matcher.Matcher.__call__": [[61, 104], ["torch.all", "match_quality_matrix.max", "matches.new_full", "zip", "match_quality_matrix.dim", "match_quality_matrix.numel", "match_quality_matrix.new_full", "match_quality_matrix.new_full", "matches.size", "matcher.Matcher.set_low_quality_matches_", "match_quality_matrix.size", "match_quality_matrix.size"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.matcher.Matcher.set_low_quality_matches_"], ["", "def", "__call__", "(", "self", ",", "match_quality_matrix", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            match_quality_matrix (Tensor[float]): an MxN tensor, containing the\n                pairwise quality between M ground-truth elements and N predicted\n                elements. All elements must be >= 0 (due to the us of `torch.nonzero`\n                for selecting indices in :meth:`set_low_quality_matches_`).\n\n        Returns:\n            matches (Tensor[int64]): a vector of length N, where matches[i] is a matched\n                ground-truth index in [0, M)\n            match_labels (Tensor[int8]): a vector of length N, where pred_labels[i] indicates\n                whether a prediction is a true or false positive or ignored\n        \"\"\"", "\n", "assert", "match_quality_matrix", ".", "dim", "(", ")", "==", "2", "\n", "if", "match_quality_matrix", ".", "numel", "(", ")", "==", "0", ":", "\n", "            ", "default_matches", "=", "match_quality_matrix", ".", "new_full", "(", "\n", "(", "match_quality_matrix", ".", "size", "(", "1", ")", ",", ")", ",", "0", ",", "dtype", "=", "torch", ".", "int64", "\n", ")", "\n", "# When no gt boxes exist, we define IOU = 0 and therefore set labels", "\n", "# to `self.labels[0]`, which usually defaults to background class 0", "\n", "# To choose to ignore instead, can make labels=[-1,0,-1,1] + set appropriate thresholds", "\n", "default_match_labels", "=", "match_quality_matrix", ".", "new_full", "(", "\n", "(", "match_quality_matrix", ".", "size", "(", "1", ")", ",", ")", ",", "self", ".", "labels", "[", "0", "]", ",", "dtype", "=", "torch", ".", "int8", "\n", ")", "\n", "return", "default_matches", ",", "default_match_labels", "\n", "\n", "", "assert", "torch", ".", "all", "(", "match_quality_matrix", ">=", "0", ")", "\n", "\n", "# match_quality_matrix is M (gt) x N (predicted)", "\n", "# Max over gt elements (dim 0) to find best gt candidate for each prediction", "\n", "matched_vals", ",", "matches", "=", "match_quality_matrix", ".", "max", "(", "dim", "=", "0", ")", "\n", "\n", "match_labels", "=", "matches", ".", "new_full", "(", "matches", ".", "size", "(", ")", ",", "1", ",", "dtype", "=", "torch", ".", "int8", ")", "\n", "\n", "for", "(", "l", ",", "low", ",", "high", ")", "in", "zip", "(", "self", ".", "labels", ",", "self", ".", "thresholds", "[", ":", "-", "1", "]", ",", "self", ".", "thresholds", "[", "1", ":", "]", ")", ":", "\n", "            ", "low_high", "=", "(", "matched_vals", ">=", "low", ")", "&", "(", "matched_vals", "<", "high", ")", "\n", "match_labels", "[", "low_high", "]", "=", "l", "\n", "\n", "", "if", "self", ".", "allow_low_quality_matches", ":", "\n", "            ", "self", ".", "set_low_quality_matches_", "(", "match_labels", ",", "match_quality_matrix", ")", "\n", "\n", "", "return", "matches", ",", "match_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.matcher.Matcher.set_low_quality_matches_": [[105, 127], ["match_quality_matrix.max", "detectron2.layers.nonzero_tuple"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.nonzero_tuple"], ["", "def", "set_low_quality_matches_", "(", "self", ",", "match_labels", ",", "match_quality_matrix", ")", ":", "\n", "        ", "\"\"\"\n        Produce additional matches for predictions that have only low-quality matches.\n        Specifically, for each ground-truth G find the set of predictions that have\n        maximum overlap with it (including ties); for each prediction in that set, if\n        it is unmatched, then match it to the ground-truth G.\n\n        This function implements the RPN assignment case (i) in Sec. 3.1.2 of\n        :paper:`Faster R-CNN`.\n        \"\"\"", "\n", "# For each gt, find the prediction with which it has highest quality", "\n", "highest_quality_foreach_gt", ",", "_", "=", "match_quality_matrix", ".", "max", "(", "dim", "=", "1", ")", "\n", "# Find the highest quality match available, even if it is low, including ties.", "\n", "# Note that the matches qualities must be positive due to the use of", "\n", "# `torch.nonzero`.", "\n", "_", ",", "pred_inds_with_highest_quality", "=", "nonzero_tuple", "(", "\n", "match_quality_matrix", "==", "highest_quality_foreach_gt", "[", ":", ",", "None", "]", "\n", ")", "\n", "# If an anchor was labeled positive only due to a low-quality match", "\n", "# with gt_A, but it has larger overlap with gt_B, it's matched index will still be gt_B.", "\n", "# This follows the implementation in Detectron, and is found to have no significant impact.", "\n", "match_labels", "[", "pred_inds_with_highest_quality", "]", "=", "1", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.BufferList.__init__": [[25, 29], ["torch.nn.Module.__init__", "enumerate", "anchor_generator.BufferList.register_buffer", "str"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "buffers", ")", ":", "\n", "        ", "super", "(", "BufferList", ",", "self", ")", ".", "__init__", "(", ")", "\n", "for", "i", ",", "buffer", "in", "enumerate", "(", "buffers", ")", ":", "\n", "            ", "self", ".", "register_buffer", "(", "str", "(", "i", ")", ",", "buffer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.BufferList.__len__": [[30, 32], ["len"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_buffers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.BufferList.__iter__": [[33, 35], ["iter", "anchor_generator.BufferList._buffers.values"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.iter"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "iter", "(", "self", ".", "_buffers", ".", "values", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.DefaultAnchorGenerator.__init__": [[91, 120], ["torch.nn.Module.__init__", "len", "anchor_generator._broadcast_params", "anchor_generator._broadcast_params", "anchor_generator.DefaultAnchorGenerator._calculate_anchors"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator._broadcast_params", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator._broadcast_params", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.RotatedAnchorGenerator._calculate_anchors"], ["@", "configurable", "\n", "def", "__init__", "(", "self", ",", "*", ",", "sizes", ",", "aspect_ratios", ",", "strides", ",", "offset", "=", "0.5", ")", ":", "\n", "        ", "\"\"\"\n        This interface is experimental.\n\n        Args:\n            sizes (list[list[float]] or list[float]):\n                If sizes is list[list[float]], sizes[i] is the list of anchor sizes\n                (i.e. sqrt of anchor area) to use for the i-th feature map.\n                If sizes is list[float], the sizes are used for all feature maps.\n                Anchor sizes are given in absolute lengths in units of\n                the input image; they do not dynamically scale if the input image size changes.\n            aspect_ratios (list[list[float]] or list[float]): list of aspect ratios\n                (i.e. height / width) to use for anchors. Same \"broadcast\" rule for `sizes` applies.\n            strides (list[int]): stride of each input feature.\n            offset (float): Relative offset between the center of the first anchor and the top-left\n                corner of the image. Value has to be in [0, 1).\n                Recommend to use 0.5, which means half stride.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "strides", "=", "strides", "\n", "self", ".", "num_features", "=", "len", "(", "self", ".", "strides", ")", "\n", "sizes", "=", "_broadcast_params", "(", "sizes", ",", "self", ".", "num_features", ",", "\"sizes\"", ")", "\n", "aspect_ratios", "=", "_broadcast_params", "(", "aspect_ratios", ",", "self", ".", "num_features", ",", "\"aspect_ratios\"", ")", "\n", "self", ".", "cell_anchors", "=", "self", ".", "_calculate_anchors", "(", "sizes", ",", "aspect_ratios", ")", "\n", "\n", "self", ".", "offset", "=", "offset", "\n", "assert", "0.0", "<=", "self", ".", "offset", "<", "1.0", ",", "self", ".", "offset", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.DefaultAnchorGenerator.from_config": [[121, 128], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ":", "List", "[", "ShapeSpec", "]", ")", ":", "\n", "        ", "return", "{", "\n", "\"sizes\"", ":", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "SIZES", ",", "\n", "\"aspect_ratios\"", ":", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "ASPECT_RATIOS", ",", "\n", "\"strides\"", ":", "[", "x", ".", "stride", "for", "x", "in", "input_shape", "]", ",", "\n", "\"offset\"", ":", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "OFFSET", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.DefaultAnchorGenerator._calculate_anchors": [[130, 135], ["anchor_generator.BufferList", "anchor_generator.DefaultAnchorGenerator.generate_cell_anchors().float", "zip", "anchor_generator.DefaultAnchorGenerator.generate_cell_anchors"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.RotatedAnchorGenerator.generate_cell_anchors"], ["", "def", "_calculate_anchors", "(", "self", ",", "sizes", ",", "aspect_ratios", ")", ":", "\n", "        ", "cell_anchors", "=", "[", "\n", "self", ".", "generate_cell_anchors", "(", "s", ",", "a", ")", ".", "float", "(", ")", "for", "s", ",", "a", "in", "zip", "(", "sizes", ",", "aspect_ratios", ")", "\n", "]", "\n", "return", "BufferList", "(", "cell_anchors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.DefaultAnchorGenerator.num_cell_anchors": [[136, 143], ["None"], "methods", ["None"], ["", "@", "property", "\n", "@", "torch", ".", "jit", ".", "unused", "\n", "def", "num_cell_anchors", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Alias of `num_anchors`.\n        \"\"\"", "\n", "return", "self", ".", "num_anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.DefaultAnchorGenerator.num_anchors": [[144, 158], ["len"], "methods", ["None"], ["", "@", "property", "\n", "@", "torch", ".", "jit", ".", "unused", "\n", "def", "num_anchors", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            list[int]: Each int is the number of anchors at every pixel\n                location, on that feature map.\n                For example, if at every pixel we use anchors of 3 aspect\n                ratios and 5 sizes, the number of anchors is 15.\n                (See also ANCHOR_GENERATOR.SIZES and ANCHOR_GENERATOR.ASPECT_RATIOS in config)\n\n                In standard RPN models, `num_anchors` on every feature map is the same.\n        \"\"\"", "\n", "return", "[", "len", "(", "cell_anchors", ")", "for", "cell_anchors", "in", "self", ".", "cell_anchors", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.DefaultAnchorGenerator._grid_anchors": [[159, 174], ["zip", "anchor_generator._create_grid_offsets", "torch.stack", "anchors.append", "anchor_generator.DefaultAnchorGenerator.cell_anchors.named_buffers", "torch.stack.view", "base_anchors.view"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator._create_grid_offsets"], ["", "def", "_grid_anchors", "(", "self", ",", "grid_sizes", ":", "List", "[", "List", "[", "int", "]", "]", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            list[Tensor]: #featuremap tensors, each is (#locations x #cell_anchors) x 4\n        \"\"\"", "\n", "anchors", "=", "[", "]", "\n", "# buffers() not supported by torchscript. use named_buffers() instead", "\n", "buffers", ":", "List", "[", "torch", ".", "Tensor", "]", "=", "[", "x", "[", "1", "]", "for", "x", "in", "self", ".", "cell_anchors", ".", "named_buffers", "(", ")", "]", "\n", "for", "size", ",", "stride", ",", "base_anchors", "in", "zip", "(", "grid_sizes", ",", "self", ".", "strides", ",", "buffers", ")", ":", "\n", "            ", "shift_x", ",", "shift_y", "=", "_create_grid_offsets", "(", "size", ",", "stride", ",", "self", ".", "offset", ",", "base_anchors", ".", "device", ")", "\n", "shifts", "=", "torch", ".", "stack", "(", "(", "shift_x", ",", "shift_y", ",", "shift_x", ",", "shift_y", ")", ",", "dim", "=", "1", ")", "\n", "\n", "anchors", ".", "append", "(", "(", "shifts", ".", "view", "(", "-", "1", ",", "1", ",", "4", ")", "+", "base_anchors", ".", "view", "(", "1", ",", "-", "1", ",", "4", ")", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", ")", "\n", "\n", "", "return", "anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.DefaultAnchorGenerator.generate_cell_anchors": [[175, 211], ["torch.tensor", "math.sqrt", "anchors.append"], "methods", ["None"], ["", "def", "generate_cell_anchors", "(", "self", ",", "sizes", "=", "(", "32", ",", "64", ",", "128", ",", "256", ",", "512", ")", ",", "aspect_ratios", "=", "(", "0.5", ",", "1", ",", "2", ")", ")", ":", "\n", "        ", "\"\"\"\n        Generate a tensor storing canonical anchor boxes, which are all anchor\n        boxes of different sizes and aspect_ratios centered at (0, 0).\n        We can later build the set of anchors for a full feature map by\n        shifting and tiling these tensors (see `meth:_grid_anchors`).\n\n        Args:\n            sizes (tuple[float]):\n            aspect_ratios (tuple[float]]):\n\n        Returns:\n            Tensor of shape (len(sizes) * len(aspect_ratios), 4) storing anchor boxes\n                in XYXY format.\n        \"\"\"", "\n", "\n", "# This is different from the anchor generator defined in the original Faster R-CNN", "\n", "# code or Detectron. They yield the same AP, however the old version defines cell", "\n", "# anchors in a less natural way with a shift relative to the feature grid and", "\n", "# quantization that results in slightly different sizes for different aspect ratios.", "\n", "# See also https://github.com/facebookresearch/Detectron/issues/227", "\n", "\n", "anchors", "=", "[", "]", "\n", "for", "size", "in", "sizes", ":", "\n", "            ", "area", "=", "size", "**", "2.0", "\n", "for", "aspect_ratio", "in", "aspect_ratios", ":", "\n", "# s * s = w * h", "\n", "# a = h / w", "\n", "# ... some algebra ...", "\n", "# w = sqrt(s * s / a)", "\n", "# h = a * w", "\n", "                ", "w", "=", "math", ".", "sqrt", "(", "area", "/", "aspect_ratio", ")", "\n", "h", "=", "aspect_ratio", "*", "w", "\n", "x0", ",", "y0", ",", "x1", ",", "y1", "=", "-", "w", "/", "2.0", ",", "-", "h", "/", "2.0", ",", "w", "/", "2.0", ",", "h", "/", "2.0", "\n", "anchors", ".", "append", "(", "[", "x0", ",", "y0", ",", "x1", ",", "y1", "]", ")", "\n", "", "", "return", "torch", ".", "tensor", "(", "anchors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.DefaultAnchorGenerator.forward": [[212, 226], ["anchor_generator.DefaultAnchorGenerator._grid_anchors", "detectron2.structures.Boxes"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.RotatedAnchorGenerator._grid_anchors"], ["", "def", "forward", "(", "self", ",", "features", ":", "List", "[", "torch", ".", "Tensor", "]", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            features (list[Tensor]): list of backbone feature maps on which to generate anchors.\n\n        Returns:\n            list[Boxes]: a list of Boxes containing all the anchors for each feature map\n                (i.e. the cell anchors repeated over all locations in the feature map).\n                The number of anchors of each feature map is Hi x Wi x num_cell_anchors,\n                where Hi, Wi are resolution of the feature map divided by anchor stride.\n        \"\"\"", "\n", "grid_sizes", "=", "[", "feature_map", ".", "shape", "[", "-", "2", ":", "]", "for", "feature_map", "in", "features", "]", "\n", "anchors_over_all_feature_maps", "=", "self", ".", "_grid_anchors", "(", "grid_sizes", ")", "\n", "return", "[", "Boxes", "(", "x", ")", "for", "x", "in", "anchors_over_all_feature_maps", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.RotatedAnchorGenerator.__init__": [[240, 272], ["torch.nn.Module.__init__", "len", "anchor_generator._broadcast_params", "anchor_generator._broadcast_params", "anchor_generator._broadcast_params", "anchor_generator.RotatedAnchorGenerator._calculate_anchors"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator._broadcast_params", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator._broadcast_params", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator._broadcast_params", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.RotatedAnchorGenerator._calculate_anchors"], ["@", "configurable", "\n", "def", "__init__", "(", "self", ",", "*", ",", "sizes", ",", "aspect_ratios", ",", "strides", ",", "angles", ",", "offset", "=", "0.5", ")", ":", "\n", "        ", "\"\"\"\n        This interface is experimental.\n\n        Args:\n            sizes (list[list[float]] or list[float]):\n                If sizes is list[list[float]], sizes[i] is the list of anchor sizes\n                (i.e. sqrt of anchor area) to use for the i-th feature map.\n                If sizes is list[float], the sizes are used for all feature maps.\n                Anchor sizes are given in absolute lengths in units of\n                the input image; they do not dynamically scale if the input image size changes.\n            aspect_ratios (list[list[float]] or list[float]): list of aspect ratios\n                (i.e. height / width) to use for anchors. Same \"broadcast\" rule for `sizes` applies.\n            strides (list[int]): stride of each input feature.\n            angles (list[list[float]] or list[float]): list of angles (in degrees CCW)\n                to use for anchors. Same \"broadcast\" rule for `sizes` applies.\n            offset (float): Relative offset between the center of the first anchor and the top-left\n                corner of the image. Value has to be in [0, 1).\n                Recommend to use 0.5, which means half stride.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "strides", "=", "strides", "\n", "self", ".", "num_features", "=", "len", "(", "self", ".", "strides", ")", "\n", "sizes", "=", "_broadcast_params", "(", "sizes", ",", "self", ".", "num_features", ",", "\"sizes\"", ")", "\n", "aspect_ratios", "=", "_broadcast_params", "(", "aspect_ratios", ",", "self", ".", "num_features", ",", "\"aspect_ratios\"", ")", "\n", "angles", "=", "_broadcast_params", "(", "angles", ",", "self", ".", "num_features", ",", "\"angles\"", ")", "\n", "self", ".", "cell_anchors", "=", "self", ".", "_calculate_anchors", "(", "sizes", ",", "aspect_ratios", ",", "angles", ")", "\n", "\n", "self", ".", "offset", "=", "offset", "\n", "assert", "0.0", "<=", "self", ".", "offset", "<", "1.0", ",", "self", ".", "offset", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.RotatedAnchorGenerator.from_config": [[273, 281], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ":", "List", "[", "ShapeSpec", "]", ")", ":", "\n", "        ", "return", "{", "\n", "\"sizes\"", ":", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "SIZES", ",", "\n", "\"aspect_ratios\"", ":", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "ASPECT_RATIOS", ",", "\n", "\"strides\"", ":", "[", "x", ".", "stride", "for", "x", "in", "input_shape", "]", ",", "\n", "\"offset\"", ":", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "OFFSET", ",", "\n", "\"angles\"", ":", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "ANGLES", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.RotatedAnchorGenerator._calculate_anchors": [[283, 289], ["anchor_generator.BufferList", "anchor_generator.RotatedAnchorGenerator.generate_cell_anchors().float", "zip", "anchor_generator.RotatedAnchorGenerator.generate_cell_anchors"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.RotatedAnchorGenerator.generate_cell_anchors"], ["", "def", "_calculate_anchors", "(", "self", ",", "sizes", ",", "aspect_ratios", ",", "angles", ")", ":", "\n", "        ", "cell_anchors", "=", "[", "\n", "self", ".", "generate_cell_anchors", "(", "size", ",", "aspect_ratio", ",", "angle", ")", ".", "float", "(", ")", "\n", "for", "size", ",", "aspect_ratio", ",", "angle", "in", "zip", "(", "sizes", ",", "aspect_ratios", ",", "angles", ")", "\n", "]", "\n", "return", "BufferList", "(", "cell_anchors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.RotatedAnchorGenerator.num_cell_anchors": [[290, 296], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_cell_anchors", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Alias of `num_anchors`.\n        \"\"\"", "\n", "return", "self", ".", "num_anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.RotatedAnchorGenerator.num_anchors": [[297, 311], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_anchors", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            list[int]: Each int is the number of anchors at every pixel\n                location, on that feature map.\n                For example, if at every pixel we use anchors of 3 aspect\n                ratios, 2 sizes and 5 angles, the number of anchors is 30.\n                (See also ANCHOR_GENERATOR.SIZES, ANCHOR_GENERATOR.ASPECT_RATIOS\n                and ANCHOR_GENERATOR.ANGLES in config)\n\n                In standard RRPN models, `num_anchors` on every feature map is the same.\n        \"\"\"", "\n", "return", "[", "len", "(", "cell_anchors", ")", "for", "cell_anchors", "in", "self", ".", "cell_anchors", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.RotatedAnchorGenerator._grid_anchors": [[312, 322], ["zip", "anchor_generator._create_grid_offsets", "torch.zeros_like", "torch.stack", "anchors.append", "torch.stack.view", "base_anchors.view"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator._create_grid_offsets"], ["", "def", "_grid_anchors", "(", "self", ",", "grid_sizes", ")", ":", "\n", "        ", "anchors", "=", "[", "]", "\n", "for", "size", ",", "stride", ",", "base_anchors", "in", "zip", "(", "grid_sizes", ",", "self", ".", "strides", ",", "self", ".", "cell_anchors", ")", ":", "\n", "            ", "shift_x", ",", "shift_y", "=", "_create_grid_offsets", "(", "size", ",", "stride", ",", "self", ".", "offset", ",", "base_anchors", ".", "device", ")", "\n", "zeros", "=", "torch", ".", "zeros_like", "(", "shift_x", ")", "\n", "shifts", "=", "torch", ".", "stack", "(", "(", "shift_x", ",", "shift_y", ",", "zeros", ",", "zeros", ",", "zeros", ")", ",", "dim", "=", "1", ")", "\n", "\n", "anchors", ".", "append", "(", "(", "shifts", ".", "view", "(", "-", "1", ",", "1", ",", "5", ")", "+", "base_anchors", ".", "view", "(", "1", ",", "-", "1", ",", "5", ")", ")", ".", "reshape", "(", "-", "1", ",", "5", ")", ")", "\n", "\n", "", "return", "anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.RotatedAnchorGenerator.generate_cell_anchors": [[323, 358], ["torch.tensor", "math.sqrt", "anchors.extend"], "methods", ["None"], ["", "def", "generate_cell_anchors", "(", "\n", "self", ",", "\n", "sizes", "=", "(", "32", ",", "64", ",", "128", ",", "256", ",", "512", ")", ",", "\n", "aspect_ratios", "=", "(", "0.5", ",", "1", ",", "2", ")", ",", "\n", "angles", "=", "(", "-", "90", ",", "-", "60", ",", "-", "30", ",", "0", ",", "30", ",", "60", ",", "90", ")", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Generate a tensor storing canonical anchor boxes, which are all anchor\n        boxes of different sizes, aspect_ratios, angles centered at (0, 0).\n        We can later build the set of anchors for a full feature map by\n        shifting and tiling these tensors (see `meth:_grid_anchors`).\n\n        Args:\n            sizes (tuple[float]):\n            aspect_ratios (tuple[float]]):\n            angles (tuple[float]]):\n\n        Returns:\n            Tensor of shape (len(sizes) * len(aspect_ratios) * len(angles), 5)\n                storing anchor boxes in (x_ctr, y_ctr, w, h, angle) format.\n        \"\"\"", "\n", "anchors", "=", "[", "]", "\n", "for", "size", "in", "sizes", ":", "\n", "            ", "area", "=", "size", "**", "2.0", "\n", "for", "aspect_ratio", "in", "aspect_ratios", ":", "\n", "# s * s = w * h", "\n", "# a = h / w", "\n", "# ... some algebra ...", "\n", "# w = sqrt(s * s / a)", "\n", "# h = a * w", "\n", "                ", "w", "=", "math", ".", "sqrt", "(", "area", "/", "aspect_ratio", ")", "\n", "h", "=", "aspect_ratio", "*", "w", "\n", "anchors", ".", "extend", "(", "[", "0", ",", "0", ",", "w", ",", "h", ",", "a", "]", "for", "a", "in", "angles", ")", "\n", "\n", "", "", "return", "torch", ".", "tensor", "(", "anchors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.RotatedAnchorGenerator.forward": [[359, 373], ["anchor_generator.RotatedAnchorGenerator._grid_anchors", "detectron2.structures.RotatedBoxes"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.RotatedAnchorGenerator._grid_anchors"], ["", "def", "forward", "(", "self", ",", "features", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            features (list[Tensor]): list of backbone feature maps on which to generate anchors.\n\n        Returns:\n            list[RotatedBoxes]: a list of Boxes containing all the anchors for each feature map\n                (i.e. the cell anchors repeated over all locations in the feature map).\n                The number of anchors of each feature map is Hi x Wi x num_cell_anchors,\n                where Hi, Wi are resolution of the feature map divided by anchor stride.\n        \"\"\"", "\n", "grid_sizes", "=", "[", "feature_map", ".", "shape", "[", "-", "2", ":", "]", "for", "feature_map", "in", "features", "]", "\n", "anchors_over_all_feature_maps", "=", "self", ".", "_grid_anchors", "(", "grid_sizes", ")", "\n", "return", "[", "RotatedBoxes", "(", "x", ")", "for", "x", "in", "anchors_over_all_feature_maps", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator._create_grid_offsets": [[37, 50], ["torch.arange", "torch.arange", "torch.meshgrid", "shift_x.reshape.reshape", "shift_y.reshape.reshape"], "function", ["None"], ["", "", "def", "_create_grid_offsets", "(", "size", ":", "List", "[", "int", "]", ",", "stride", ":", "int", ",", "offset", ":", "float", ",", "device", ":", "torch", ".", "device", ")", ":", "\n", "    ", "grid_height", ",", "grid_width", "=", "size", "\n", "shifts_x", "=", "torch", ".", "arange", "(", "\n", "offset", "*", "stride", ",", "grid_width", "*", "stride", ",", "step", "=", "stride", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", "\n", ")", "\n", "shifts_y", "=", "torch", ".", "arange", "(", "\n", "offset", "*", "stride", ",", "grid_height", "*", "stride", ",", "step", "=", "stride", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", "\n", ")", "\n", "\n", "shift_y", ",", "shift_x", "=", "torch", ".", "meshgrid", "(", "shifts_y", ",", "shifts_x", ")", "\n", "shift_x", "=", "shift_x", ".", "reshape", "(", "-", "1", ")", "\n", "shift_y", "=", "shift_y", ".", "reshape", "(", "-", "1", ")", "\n", "return", "shift_x", ",", "shift_y", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator._broadcast_params": [[52, 77], ["isinstance", "len", "isinstance", "len", "len", "list", "len"], "function", ["None"], ["", "def", "_broadcast_params", "(", "params", ",", "num_features", ",", "name", ")", ":", "\n", "    ", "\"\"\"\n    If one size (or aspect ratio) is specified and there are multiple feature\n    maps, we \"broadcast\" anchors of that single size (or aspect ratio)\n    over all feature maps.\n\n    If params is list[float], or list[list[float]] with len(params) == 1, repeat\n    it num_features time.\n\n    Returns:\n        list[list[float]]: param for each feature\n    \"\"\"", "\n", "assert", "isinstance", "(", "\n", "params", ",", "(", "list", ",", "tuple", ")", "\n", ")", ",", "f\"{name} in anchor generator has to be a list! Got {params}.\"", "\n", "assert", "len", "(", "params", ")", ",", "f\"{name} in anchor generator cannot be empty!\"", "\n", "if", "not", "isinstance", "(", "params", "[", "0", "]", ",", "(", "list", ",", "tuple", ")", ")", ":", "# list[float]", "\n", "        ", "return", "[", "params", "]", "*", "num_features", "\n", "", "if", "len", "(", "params", ")", "==", "1", ":", "\n", "        ", "return", "list", "(", "params", ")", "*", "num_features", "\n", "", "assert", "len", "(", "params", ")", "==", "num_features", ",", "(", "\n", "f\"Got {name} of length {len(params)} in anchor generator, \"", "\n", "f\"but the number of input features is {num_features}!\"", "\n", ")", "\n", "return", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.build_anchor_generator": [[375, 381], ["ANCHOR_GENERATOR_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "", "def", "build_anchor_generator", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Built an anchor generator from `cfg.MODEL.ANCHOR_GENERATOR.NAME`.\n    \"\"\"", "\n", "anchor_generator", "=", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "NAME", "\n", "return", "ANCHOR_GENERATOR_REGISTRY", ".", "get", "(", "anchor_generator", ")", "(", "cfg", ",", "input_shape", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.DatasetMapperTTA.__init__": [[36, 41], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "self", ".", "min_sizes", "=", "cfg", ".", "TEST", ".", "AUG", ".", "MIN_SIZES", "\n", "self", ".", "max_size", "=", "cfg", ".", "TEST", ".", "AUG", ".", "MAX_SIZE", "\n", "self", ".", "flip", "=", "cfg", ".", "TEST", ".", "AUG", ".", "FLIP", "\n", "self", ".", "image_format", "=", "cfg", ".", "INPUT", ".", "FORMAT", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.DatasetMapperTTA.__call__": [[42, 83], ["dataset_dict[].permute().numpy", "detectron2.data.transforms.ResizeTransform", "fvcore.transforms.NoOpTransform", "detectron2.data.transforms.ResizeShortestEdge", "aug_candidates.append", "detectron2.data.transforms.apply_augmentations", "torch.from_numpy", "copy.deepcopy", "ret.append", "dataset_dict[].permute", "detectron2.data.transforms.RandomFlip", "aug_candidates.append", "numpy.copy", "numpy.ascontiguousarray", "new_image.transpose"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "dataset_dict", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dict: a dict in standard model input format. See tutorials for details.\n\n        Returns:\n            list[dict]:\n                a list of dicts, which contain augmented version of the input image.\n                The total number of dicts is ``len(min_sizes) * (2 if flip else 1)``.\n                Each dict has field \"transforms\" which is a TransformList,\n                containing the transforms that are used to generate this image.\n        \"\"\"", "\n", "numpy_image", "=", "dataset_dict", "[", "\"image\"", "]", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "numpy", "(", ")", "\n", "shape", "=", "numpy_image", ".", "shape", "\n", "orig_shape", "=", "(", "dataset_dict", "[", "\"height\"", "]", ",", "dataset_dict", "[", "\"width\"", "]", ")", "\n", "if", "shape", "[", ":", "2", "]", "!=", "orig_shape", ":", "\n", "# It transforms the \"original\" image in the dataset to the input image", "\n", "            ", "pre_tfm", "=", "ResizeTransform", "(", "orig_shape", "[", "0", "]", ",", "orig_shape", "[", "1", "]", ",", "shape", "[", "0", "]", ",", "shape", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "pre_tfm", "=", "NoOpTransform", "(", ")", "\n", "\n", "# Create all combinations of augmentations to use", "\n", "", "aug_candidates", "=", "[", "]", "# each element is a list[Augmentation]", "\n", "for", "min_size", "in", "self", ".", "min_sizes", ":", "\n", "            ", "resize", "=", "ResizeShortestEdge", "(", "min_size", ",", "self", ".", "max_size", ")", "\n", "aug_candidates", ".", "append", "(", "[", "resize", "]", ")", "# resize only", "\n", "if", "self", ".", "flip", ":", "\n", "                ", "flip", "=", "RandomFlip", "(", "prob", "=", "1.0", ")", "\n", "aug_candidates", ".", "append", "(", "[", "resize", ",", "flip", "]", ")", "# resize + flip", "\n", "\n", "# Apply all the augmentations", "\n", "", "", "ret", "=", "[", "]", "\n", "for", "aug", "in", "aug_candidates", ":", "\n", "            ", "new_image", ",", "tfms", "=", "apply_augmentations", "(", "aug", ",", "np", ".", "copy", "(", "numpy_image", ")", ")", "\n", "torch_image", "=", "torch", ".", "from_numpy", "(", "np", ".", "ascontiguousarray", "(", "new_image", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", ")", "\n", "\n", "dic", "=", "copy", ".", "deepcopy", "(", "dataset_dict", ")", "\n", "dic", "[", "\"transforms\"", "]", "=", "pre_tfm", "+", "tfms", "\n", "dic", "[", "\"image\"", "]", "=", "torch_image", "\n", "ret", ".", "append", "(", "dic", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA.__init__": [[91, 119], ["torch.nn.Module.__init__", "isinstance", "isinstance", "cfg.clone", "type", "test_time_augmentation.DatasetMapperTTA"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone"], ["def", "__init__", "(", "self", ",", "cfg", ",", "model", ",", "tta_mapper", "=", "None", ",", "batch_size", "=", "3", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            cfg (CfgNode):\n            model (GeneralizedRCNN): a GeneralizedRCNN to apply TTA on.\n            tta_mapper (callable): takes a dataset dict and returns a list of\n                augmented versions of the dataset dict. Defaults to\n                `DatasetMapperTTA(cfg)`.\n            batch_size (int): batch the augmented images into this batch size for inference.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "isinstance", "(", "model", ",", "DistributedDataParallel", ")", ":", "\n", "            ", "model", "=", "model", ".", "module", "\n", "", "assert", "isinstance", "(", "\n", "model", ",", "GeneralizedRCNN", "\n", ")", ",", "\"TTA is only supported on GeneralizedRCNN. Got a model of type {}\"", ".", "format", "(", "type", "(", "model", ")", ")", "\n", "self", ".", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "assert", "not", "self", ".", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ",", "\"TTA for keypoint is not supported yet\"", "\n", "assert", "(", "\n", "not", "self", ".", "cfg", ".", "MODEL", ".", "LOAD_PROPOSALS", "\n", ")", ",", "\"TTA for pre-computed proposals is not supported yet\"", "\n", "\n", "self", ".", "model", "=", "model", "\n", "\n", "if", "tta_mapper", "is", "None", ":", "\n", "            ", "tta_mapper", "=", "DatasetMapperTTA", "(", "cfg", ")", "\n", "", "self", ".", "tta_mapper", "=", "tta_mapper", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._turn_off_roi_heads": [[120, 145], ["len", "old.keys", "old.keys", "getattr", "old.keys", "setattr", "setattr"], "methods", ["None"], ["", "@", "contextmanager", "\n", "def", "_turn_off_roi_heads", "(", "self", ",", "attrs", ")", ":", "\n", "        ", "\"\"\"\n        Open a context where some heads in `model.roi_heads` are temporarily turned off.\n        Args:\n            attr (list[str]): the attribute in `model.roi_heads` which can be used\n                to turn off a specific head, e.g., \"mask_on\", \"keypoint_on\".\n        \"\"\"", "\n", "roi_heads", "=", "self", ".", "model", ".", "roi_heads", "\n", "old", "=", "{", "}", "\n", "for", "attr", "in", "attrs", ":", "\n", "            ", "try", ":", "\n", "                ", "old", "[", "attr", "]", "=", "getattr", "(", "roi_heads", ",", "attr", ")", "\n", "", "except", "AttributeError", ":", "\n", "# The head may not be implemented in certain ROIHeads", "\n", "                ", "pass", "\n", "\n", "", "", "if", "len", "(", "old", ".", "keys", "(", ")", ")", "==", "0", ":", "\n", "            ", "yield", "\n", "", "else", ":", "\n", "            ", "for", "attr", "in", "old", ".", "keys", "(", ")", ":", "\n", "                ", "setattr", "(", "roi_heads", ",", "attr", ",", "False", ")", "\n", "", "yield", "\n", "for", "attr", "in", "old", ".", "keys", "(", ")", ":", "\n", "                ", "setattr", "(", "roi_heads", ",", "attr", ",", "old", "[", "attr", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._batch_inference": [[146, 171], ["zip", "itertools.count", "inputs.append", "instances.append", "len", "outputs.extend", "len", "test_time_augmentation.GeneralizedRCNNWithTTA.model.inference", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.inference"], ["", "", "", "def", "_batch_inference", "(", "self", ",", "batched_inputs", ",", "detected_instances", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Execute inference on a list of inputs,\n        using batch size = self.batch_size, instead of the length of the list.\n\n        Inputs & outputs have the same format as :meth:`GeneralizedRCNN.inference`\n        \"\"\"", "\n", "if", "detected_instances", "is", "None", ":", "\n", "            ", "detected_instances", "=", "[", "None", "]", "*", "len", "(", "batched_inputs", ")", "\n", "\n", "", "outputs", "=", "[", "]", "\n", "inputs", ",", "instances", "=", "[", "]", ",", "[", "]", "\n", "for", "idx", ",", "input", ",", "instance", "in", "zip", "(", "count", "(", ")", ",", "batched_inputs", ",", "detected_instances", ")", ":", "\n", "            ", "inputs", ".", "append", "(", "input", ")", "\n", "instances", ".", "append", "(", "instance", ")", "\n", "if", "len", "(", "inputs", ")", "==", "self", ".", "batch_size", "or", "idx", "==", "len", "(", "batched_inputs", ")", "-", "1", ":", "\n", "                ", "outputs", ".", "extend", "(", "\n", "self", ".", "model", ".", "inference", "(", "\n", "inputs", ",", "\n", "instances", "if", "instances", "[", "0", "]", "is", "not", "None", "else", "None", ",", "\n", "do_postprocess", "=", "False", ",", "\n", ")", "\n", ")", "\n", "inputs", ",", "instances", "=", "[", "]", ",", "[", "]", "\n", "", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA.__call__": [[172, 189], ["copy.copy", "test_time_augmentation.GeneralizedRCNNWithTTA._inference_one_image", "detectron2.data.detection_utils.read_image", "torch.from_numpy().permute", "test_time_augmentation.GeneralizedRCNNWithTTA.__call__._maybe_read_image"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._inference_one_image"], ["", "def", "__call__", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Same input/output format as :meth:`GeneralizedRCNN.forward`\n        \"\"\"", "\n", "\n", "def", "_maybe_read_image", "(", "dataset_dict", ")", ":", "\n", "            ", "ret", "=", "copy", ".", "copy", "(", "dataset_dict", ")", "\n", "if", "\"image\"", "not", "in", "ret", ":", "\n", "                ", "image", "=", "read_image", "(", "ret", ".", "pop", "(", "\"file_name\"", ")", ",", "self", ".", "tta_mapper", ".", "image_format", ")", "\n", "image", "=", "torch", ".", "from_numpy", "(", "image", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "# CHW", "\n", "ret", "[", "\"image\"", "]", "=", "image", "\n", "", "if", "\"height\"", "not", "in", "ret", "and", "\"width\"", "not", "in", "ret", ":", "\n", "                ", "ret", "[", "\"height\"", "]", "=", "image", ".", "shape", "[", "1", "]", "\n", "ret", "[", "\"width\"", "]", "=", "image", ".", "shape", "[", "2", "]", "\n", "", "return", "ret", "\n", "\n", "", "return", "[", "self", ".", "_inference_one_image", "(", "_maybe_read_image", "(", "x", ")", ")", "for", "x", "in", "batched_inputs", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._inference_one_image": [[190, 222], ["test_time_augmentation.GeneralizedRCNNWithTTA._get_augmented_inputs", "test_time_augmentation.GeneralizedRCNNWithTTA._merge_detections", "test_time_augmentation.GeneralizedRCNNWithTTA._turn_off_roi_heads", "test_time_augmentation.GeneralizedRCNNWithTTA._get_augmented_boxes", "test_time_augmentation.GeneralizedRCNNWithTTA._rescale_detected_boxes", "test_time_augmentation.GeneralizedRCNNWithTTA._batch_inference", "test_time_augmentation.GeneralizedRCNNWithTTA._reduce_pred_masks", "postprocessing.detector_postprocess"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._get_augmented_inputs", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._merge_detections", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._turn_off_roi_heads", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._get_augmented_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._rescale_detected_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._batch_inference", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._reduce_pred_masks", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.postprocessing.detector_postprocess"], ["", "def", "_inference_one_image", "(", "self", ",", "input", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input (dict): one dataset dict with \"image\" field being a CHW tensor\n\n        Returns:\n            dict: one output dict\n        \"\"\"", "\n", "orig_shape", "=", "(", "input", "[", "\"height\"", "]", ",", "input", "[", "\"width\"", "]", ")", "\n", "augmented_inputs", ",", "tfms", "=", "self", ".", "_get_augmented_inputs", "(", "input", ")", "\n", "# Detect boxes from all augmented versions", "\n", "with", "self", ".", "_turn_off_roi_heads", "(", "[", "\"mask_on\"", ",", "\"keypoint_on\"", "]", ")", ":", "\n", "# temporarily disable roi heads", "\n", "            ", "all_boxes", ",", "all_scores", ",", "all_classes", "=", "self", ".", "_get_augmented_boxes", "(", "augmented_inputs", ",", "tfms", ")", "\n", "# merge all detected boxes to obtain final predictions for boxes", "\n", "", "merged_instances", "=", "self", ".", "_merge_detections", "(", "all_boxes", ",", "all_scores", ",", "all_classes", ",", "orig_shape", ")", "\n", "\n", "if", "self", ".", "cfg", ".", "MODEL", ".", "MASK_ON", ":", "\n", "# Use the detected boxes to obtain masks", "\n", "            ", "augmented_instances", "=", "self", ".", "_rescale_detected_boxes", "(", "\n", "augmented_inputs", ",", "merged_instances", ",", "tfms", "\n", ")", "\n", "# run forward on the detected boxes", "\n", "outputs", "=", "self", ".", "_batch_inference", "(", "augmented_inputs", ",", "augmented_instances", ")", "\n", "# Delete now useless variables to avoid being out of memory", "\n", "del", "augmented_inputs", ",", "augmented_instances", "\n", "# average the predictions", "\n", "merged_instances", ".", "pred_masks", "=", "self", ".", "_reduce_pred_masks", "(", "outputs", ",", "tfms", ")", "\n", "merged_instances", "=", "detector_postprocess", "(", "merged_instances", ",", "*", "orig_shape", ")", "\n", "return", "{", "\"instances\"", ":", "merged_instances", "}", "\n", "", "else", ":", "\n", "            ", "return", "{", "\"instances\"", ":", "merged_instances", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._get_augmented_inputs": [[223, 227], ["test_time_augmentation.GeneralizedRCNNWithTTA.tta_mapper", "x.pop"], "methods", ["None"], ["", "", "def", "_get_augmented_inputs", "(", "self", ",", "input", ")", ":", "\n", "        ", "augmented_inputs", "=", "self", ".", "tta_mapper", "(", "input", ")", "\n", "tfms", "=", "[", "x", ".", "pop", "(", "\"transforms\"", ")", "for", "x", "in", "augmented_inputs", "]", "\n", "return", "augmented_inputs", ",", "tfms", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._get_augmented_boxes": [[228, 245], ["test_time_augmentation.GeneralizedRCNNWithTTA._batch_inference", "zip", "torch.cat", "tfm.inverse().apply_box", "torch.cat.append", "all_scores.extend", "all_classes.extend", "pred_boxes.cpu().numpy", "torch.from_numpy().to", "tfm.inverse", "pred_boxes.cpu", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._batch_inference", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "_get_augmented_boxes", "(", "self", ",", "augmented_inputs", ",", "tfms", ")", ":", "\n", "# 1: forward with all augmented images", "\n", "        ", "outputs", "=", "self", ".", "_batch_inference", "(", "augmented_inputs", ")", "\n", "# 2: union the results", "\n", "all_boxes", "=", "[", "]", "\n", "all_scores", "=", "[", "]", "\n", "all_classes", "=", "[", "]", "\n", "for", "output", ",", "tfm", "in", "zip", "(", "outputs", ",", "tfms", ")", ":", "\n", "# Need to inverse the transforms on boxes, to obtain results on original image", "\n", "            ", "pred_boxes", "=", "output", ".", "pred_boxes", ".", "tensor", "\n", "original_pred_boxes", "=", "tfm", ".", "inverse", "(", ")", ".", "apply_box", "(", "pred_boxes", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "all_boxes", ".", "append", "(", "torch", ".", "from_numpy", "(", "original_pred_boxes", ")", ".", "to", "(", "pred_boxes", ".", "device", ")", ")", "\n", "\n", "all_scores", ".", "extend", "(", "output", ".", "scores", ")", "\n", "all_classes", ".", "extend", "(", "output", ".", "pred_classes", ")", "\n", "", "all_boxes", "=", "torch", ".", "cat", "(", "all_boxes", ",", "dim", "=", "0", ")", "\n", "return", "all_boxes", ",", "all_scores", ",", "all_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._merge_detections": [[246, 265], ["len", "torch.zeros", "zip", "roi_heads.fast_rcnn.fast_rcnn_inference_single_image", "itertools.count"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.fast_rcnn_inference_single_image"], ["", "def", "_merge_detections", "(", "self", ",", "all_boxes", ",", "all_scores", ",", "all_classes", ",", "shape_hw", ")", ":", "\n", "# select from the union of all results", "\n", "        ", "num_boxes", "=", "len", "(", "all_boxes", ")", "\n", "num_classes", "=", "self", ".", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NUM_CLASSES", "\n", "# +1 because fast_rcnn_inference expects background scores as well", "\n", "all_scores_2d", "=", "torch", ".", "zeros", "(", "num_boxes", ",", "num_classes", "+", "1", ",", "device", "=", "all_boxes", ".", "device", ")", "\n", "for", "idx", ",", "cls", ",", "score", "in", "zip", "(", "count", "(", ")", ",", "all_classes", ",", "all_scores", ")", ":", "\n", "            ", "all_scores_2d", "[", "idx", ",", "cls", "]", "=", "score", "\n", "\n", "", "merged_instances", ",", "_", "=", "fast_rcnn_inference_single_image", "(", "\n", "all_boxes", ",", "\n", "all_scores_2d", ",", "\n", "shape_hw", ",", "\n", "1e-8", ",", "\n", "self", ".", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NMS_THRESH_TEST", ",", "\n", "self", ".", "cfg", ".", "TEST", ".", "DETECTIONS_PER_IMAGE", ",", "\n", ")", "\n", "\n", "return", "merged_instances", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._rescale_detected_boxes": [[266, 281], ["zip", "merged_instances.pred_boxes.tensor.cpu().numpy", "torch.from_numpy", "detectron2.structures.Instances", "augmented_instances.append", "tfm.apply_box", "merged_instances.pred_boxes.tensor.cpu", "detectron2.structures.Boxes"], "methods", ["None"], ["", "def", "_rescale_detected_boxes", "(", "self", ",", "augmented_inputs", ",", "merged_instances", ",", "tfms", ")", ":", "\n", "        ", "augmented_instances", "=", "[", "]", "\n", "for", "input", ",", "tfm", "in", "zip", "(", "augmented_inputs", ",", "tfms", ")", ":", "\n", "# Transform the target box to the augmented image's coordinate space", "\n", "            ", "pred_boxes", "=", "merged_instances", ".", "pred_boxes", ".", "tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "pred_boxes", "=", "torch", ".", "from_numpy", "(", "tfm", ".", "apply_box", "(", "pred_boxes", ")", ")", "\n", "\n", "aug_instances", "=", "Instances", "(", "\n", "image_size", "=", "input", "[", "\"image\"", "]", ".", "shape", "[", "1", ":", "3", "]", ",", "\n", "pred_boxes", "=", "Boxes", "(", "pred_boxes", ")", ",", "\n", "pred_classes", "=", "merged_instances", ".", "pred_classes", ",", "\n", "scores", "=", "merged_instances", ".", "scores", ",", "\n", ")", "\n", "augmented_instances", ".", "append", "(", "aug_instances", ")", "\n", "", "return", "augmented_instances", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._reduce_pred_masks": [[282, 292], ["zip", "torch.stack", "torch.mean", "any", "output.pred_masks.flip", "isinstance"], "methods", ["None"], ["", "def", "_reduce_pred_masks", "(", "self", ",", "outputs", ",", "tfms", ")", ":", "\n", "# Should apply inverse transforms on masks.", "\n", "# We assume only resize & flip are used. pred_masks is a scale-invariant", "\n", "# representation, so we handle flip specially", "\n", "        ", "for", "output", ",", "tfm", "in", "zip", "(", "outputs", ",", "tfms", ")", ":", "\n", "            ", "if", "any", "(", "isinstance", "(", "t", ",", "HFlipTransform", ")", "for", "t", "in", "tfm", ".", "transforms", ")", ":", "\n", "                ", "output", ".", "pred_masks", "=", "output", ".", "pred_masks", ".", "flip", "(", "dims", "=", "[", "3", "]", ")", "\n", "", "", "all_pred_masks", "=", "torch", ".", "stack", "(", "[", "o", ".", "pred_masks", "for", "o", "in", "outputs", "]", ",", "dim", "=", "0", ")", "\n", "avg_pred_masks", "=", "torch", ".", "mean", "(", "all_pred_masks", ",", "dim", "=", "0", ")", "\n", "return", "avg_pred_masks", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.poolers.ROIPooler.__init__": [[104, 189], ["torch.nn.Module.__init__", "isinstance", "int", "int", "len", "isinstance", "isinstance", "torch.nn.ModuleList", "math.log2", "math.log2", "math.isclose", "math.isclose", "len", "torch.nn.ModuleList", "int", "int", "detectron2.layers.ROIAlign", "torch.nn.ModuleList", "detectron2.layers.ROIAlign", "torch.nn.ModuleList", "ValueError", "torchvision.ops.RoIPool", "detectron2.layers.ROIAlignRotated"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "output_size", ",", "\n", "scales", ",", "\n", "sampling_ratio", ",", "\n", "pooler_type", ",", "\n", "canonical_box_size", "=", "224", ",", "\n", "canonical_level", "=", "4", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            output_size (int, tuple[int] or list[int]): output size of the pooled region,\n                e.g., 14 x 14. If tuple or list is given, the length must be 2.\n            scales (list[float]): The scale for each low-level pooling op relative to\n                the input image. For a feature map with stride s relative to the input\n                image, scale is defined as a 1 / s. The stride must be power of 2.\n                When there are multiple scales, they must form a pyramid, i.e. they must be\n                a monotically decreasing geometric sequence with a factor of 1/2.\n            sampling_ratio (int): The `sampling_ratio` parameter for the ROIAlign op.\n            pooler_type (string): Name of the type of pooling operation that should be applied.\n                For instance, \"ROIPool\" or \"ROIAlignV2\".\n            canonical_box_size (int): A canonical box size in pixels (sqrt(box area)). The default\n                is heuristically defined as 224 pixels in the FPN paper (based on ImageNet\n                pre-training).\n            canonical_level (int): The feature map level index from which a canonically-sized box\n                should be placed. The default is defined as level 4 (stride=16) in the FPN paper,\n                i.e., a box of size 224x224 will be placed on the feature with stride=16.\n                The box placement for all boxes will be determined from their sizes w.r.t\n                canonical_box_size. For example, a box whose area is 4x that of a canonical box\n                should be used to pool features from feature level ``canonical_level+1``.\n\n                Note that the actual input feature maps given to this module may not have\n                sufficiently many levels for the input boxes. If the boxes are too large or too\n                small for the input feature maps, the closest level will be used.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "isinstance", "(", "output_size", ",", "int", ")", ":", "\n", "            ", "output_size", "=", "(", "output_size", ",", "output_size", ")", "\n", "", "assert", "len", "(", "output_size", ")", "==", "2", "\n", "assert", "isinstance", "(", "output_size", "[", "0", "]", ",", "int", ")", "and", "isinstance", "(", "output_size", "[", "1", "]", ",", "int", ")", "\n", "self", ".", "output_size", "=", "output_size", "\n", "\n", "if", "pooler_type", "==", "\"ROIAlign\"", ":", "\n", "            ", "self", ".", "level_poolers", "=", "nn", ".", "ModuleList", "(", "\n", "ROIAlign", "(", "\n", "output_size", ",", "spatial_scale", "=", "scale", ",", "sampling_ratio", "=", "sampling_ratio", ",", "aligned", "=", "False", "\n", ")", "\n", "for", "scale", "in", "scales", "\n", ")", "\n", "", "elif", "pooler_type", "==", "\"ROIAlignV2\"", ":", "\n", "            ", "self", ".", "level_poolers", "=", "nn", ".", "ModuleList", "(", "\n", "ROIAlign", "(", "\n", "output_size", ",", "spatial_scale", "=", "scale", ",", "sampling_ratio", "=", "sampling_ratio", ",", "aligned", "=", "True", "\n", ")", "\n", "for", "scale", "in", "scales", "\n", ")", "\n", "", "elif", "pooler_type", "==", "\"ROIPool\"", ":", "\n", "            ", "self", ".", "level_poolers", "=", "nn", ".", "ModuleList", "(", "\n", "RoIPool", "(", "output_size", ",", "spatial_scale", "=", "scale", ")", "for", "scale", "in", "scales", "\n", ")", "\n", "", "elif", "pooler_type", "==", "\"ROIAlignRotated\"", ":", "\n", "            ", "self", ".", "level_poolers", "=", "nn", ".", "ModuleList", "(", "\n", "ROIAlignRotated", "(", "output_size", ",", "spatial_scale", "=", "scale", ",", "sampling_ratio", "=", "sampling_ratio", ")", "\n", "for", "scale", "in", "scales", "\n", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Unknown pooler type: {}\"", ".", "format", "(", "pooler_type", ")", ")", "\n", "\n", "# Map scale (defined as 1 / stride) to its feature map level under the", "\n", "# assumption that stride is a power of 2.", "\n", "", "min_level", "=", "-", "(", "math", ".", "log2", "(", "scales", "[", "0", "]", ")", ")", "\n", "max_level", "=", "-", "(", "math", ".", "log2", "(", "scales", "[", "-", "1", "]", ")", ")", "\n", "assert", "math", ".", "isclose", "(", "min_level", ",", "int", "(", "min_level", ")", ")", "and", "math", ".", "isclose", "(", "\n", "max_level", ",", "int", "(", "max_level", ")", "\n", ")", ",", "\"Featuremap stride is not power of 2!\"", "\n", "self", ".", "min_level", "=", "int", "(", "min_level", ")", "\n", "self", ".", "max_level", "=", "int", "(", "max_level", ")", "\n", "assert", "(", "\n", "len", "(", "scales", ")", "==", "self", ".", "max_level", "-", "self", ".", "min_level", "+", "1", "\n", ")", ",", "\"[ROIPooler] Sizes of input featuremaps do not form a pyramid!\"", "\n", "assert", "0", "<=", "self", ".", "min_level", "and", "self", ".", "min_level", "<=", "self", ".", "max_level", "\n", "self", ".", "canonical_level", "=", "canonical_level", "\n", "assert", "canonical_box_size", ">", "0", "\n", "self", ".", "canonical_box_size", "=", "canonical_box_size", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.poolers.ROIPooler.forward": [[190, 250], ["len", "poolers.convert_boxes_to_pooler_format", "poolers.assign_boxes_to_levels", "len", "torch.zeros", "enumerate", "isinstance", "isinstance", "len", "len", "len", "x[].size", "x[].size", "len", "len", "torch.zeros", "pooler", "detectron2.layers.nonzero_tuple"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.poolers.convert_boxes_to_pooler_format", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.poolers.assign_boxes_to_levels", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.nonzero_tuple"], ["", "def", "forward", "(", "self", ",", "x", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "box_lists", ":", "List", "[", "Boxes", "]", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x (list[Tensor]): A list of feature maps of NCHW shape, with scales matching those\n                used to construct this module.\n            box_lists (list[Boxes] | list[RotatedBoxes]):\n                A list of N Boxes or N RotatedBoxes, where N is the number of images in the batch.\n                The box coordinates are defined on the original image and\n                will be scaled by the `scales` argument of :class:`ROIPooler`.\n\n        Returns:\n            Tensor:\n                A tensor of shape (M, C, output_size, output_size) where M is the total number of\n                boxes aggregated over all N batch images and C is the number of channels in `x`.\n        \"\"\"", "\n", "num_level_assignments", "=", "len", "(", "self", ".", "level_poolers", ")", "\n", "\n", "assert", "isinstance", "(", "x", ",", "list", ")", "and", "isinstance", "(", "\n", "box_lists", ",", "list", "\n", ")", ",", "\"Arguments to pooler must be lists\"", "\n", "assert", "(", "\n", "len", "(", "x", ")", "==", "num_level_assignments", "\n", ")", ",", "\"unequal value, num_level_assignments={}, but x is list of {} Tensors\"", ".", "format", "(", "\n", "num_level_assignments", ",", "len", "(", "x", ")", "\n", ")", "\n", "\n", "assert", "len", "(", "box_lists", ")", "==", "x", "[", "0", "]", ".", "size", "(", "\n", "0", "\n", ")", ",", "\"unequal value, x[0] batch dim 0 is {}, but box_list has length {}\"", ".", "format", "(", "\n", "x", "[", "0", "]", ".", "size", "(", "0", ")", ",", "len", "(", "box_lists", ")", "\n", ")", "\n", "if", "len", "(", "box_lists", ")", "==", "0", ":", "\n", "            ", "return", "torch", ".", "zeros", "(", "\n", "(", "0", ",", "x", "[", "0", "]", ".", "shape", "[", "1", "]", ")", "+", "self", ".", "output_size", ",", "device", "=", "x", "[", "0", "]", ".", "device", ",", "dtype", "=", "x", "[", "0", "]", ".", "dtype", "\n", ")", "\n", "\n", "", "pooler_fmt_boxes", "=", "convert_boxes_to_pooler_format", "(", "box_lists", ")", "\n", "\n", "if", "num_level_assignments", "==", "1", ":", "\n", "            ", "return", "self", ".", "level_poolers", "[", "0", "]", "(", "x", "[", "0", "]", ",", "pooler_fmt_boxes", ")", "\n", "\n", "", "level_assignments", "=", "assign_boxes_to_levels", "(", "\n", "box_lists", ",", "self", ".", "min_level", ",", "self", ".", "max_level", ",", "self", ".", "canonical_box_size", ",", "self", ".", "canonical_level", "\n", ")", "\n", "\n", "num_boxes", "=", "len", "(", "pooler_fmt_boxes", ")", "\n", "num_channels", "=", "x", "[", "0", "]", ".", "shape", "[", "1", "]", "\n", "output_size", "=", "self", ".", "output_size", "[", "0", "]", "\n", "\n", "dtype", ",", "device", "=", "x", "[", "0", "]", ".", "dtype", ",", "x", "[", "0", "]", ".", "device", "\n", "output", "=", "torch", ".", "zeros", "(", "\n", "(", "num_boxes", ",", "num_channels", ",", "output_size", ",", "output_size", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", "\n", ")", "\n", "\n", "for", "level", ",", "pooler", "in", "enumerate", "(", "self", ".", "level_poolers", ")", ":", "\n", "            ", "inds", "=", "nonzero_tuple", "(", "level_assignments", "==", "level", ")", "[", "0", "]", "\n", "pooler_fmt_boxes_level", "=", "pooler_fmt_boxes", "[", "inds", "]", "\n", "output", "[", "inds", "]", "=", "pooler", "(", "x", "[", "level", "]", ",", "pooler_fmt_boxes_level", ")", "\n", "\n", "", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.poolers.assign_boxes_to_levels": [[22, 59], ["torch.sqrt", "torch.floor", "torch.clamp", "detectron2.layers.cat", "torch.clamp.to", "torch.log2", "boxes.area"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.area"], ["def", "assign_boxes_to_levels", "(", "\n", "box_lists", ":", "List", "[", "Boxes", "]", ",", "\n", "min_level", ":", "int", ",", "\n", "max_level", ":", "int", ",", "\n", "canonical_box_size", ":", "int", ",", "\n", "canonical_level", ":", "int", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Map each box in `box_lists` to a feature map level index and return the assignment\n    vector.\n\n    Args:\n        box_lists (list[Boxes] | list[RotatedBoxes]): A list of N Boxes or N RotatedBoxes,\n            where N is the number of images in the batch.\n        min_level (int): Smallest feature map level index. The input is considered index 0,\n            the output of stage 1 is index 1, and so.\n        max_level (int): Largest feature map level index.\n        canonical_box_size (int): A canonical box size in pixels (sqrt(box area)).\n        canonical_level (int): The feature map level index on which a canonically-sized box\n            should be placed.\n\n    Returns:\n        A tensor of length M, where M is the total number of boxes aggregated over all\n            N batch images. The memory layout corresponds to the concatenation of boxes\n            from all images. Each element is the feature map index, as an offset from\n            `self.min_level`, for the corresponding box (so value i means the box is at\n            `self.min_level + i`).\n    \"\"\"", "\n", "box_sizes", "=", "torch", ".", "sqrt", "(", "cat", "(", "[", "boxes", ".", "area", "(", ")", "for", "boxes", "in", "box_lists", "]", ")", ")", "\n", "# Eqn.(1) in FPN paper", "\n", "level_assignments", "=", "torch", ".", "floor", "(", "\n", "canonical_level", "+", "torch", ".", "log2", "(", "box_sizes", "/", "canonical_box_size", "+", "1e-8", ")", "\n", ")", "\n", "# clamp level to (min, max), in case the box size is too large or too small", "\n", "# for the available feature maps", "\n", "level_assignments", "=", "torch", ".", "clamp", "(", "level_assignments", ",", "min", "=", "min_level", ",", "max", "=", "max_level", ")", "\n", "return", "level_assignments", ".", "to", "(", "torch", ".", "int64", ")", "-", "min_level", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.poolers._fmt_box_list": [[61, 66], ["torch.full", "detectron2.layers.cat", "len"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "def", "_fmt_box_list", "(", "box_tensor", ",", "batch_index", ":", "int", ")", ":", "\n", "    ", "repeated_index", "=", "torch", ".", "full", "(", "\n", "(", "len", "(", "box_tensor", ")", ",", "1", ")", ",", "batch_index", ",", "dtype", "=", "box_tensor", ".", "dtype", ",", "device", "=", "box_tensor", ".", "device", "\n", ")", "\n", "return", "cat", "(", "(", "repeated_index", ",", "box_tensor", ")", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.poolers.convert_boxes_to_pooler_format": [[68, 96], ["detectron2.layers.cat", "poolers._fmt_box_list", "enumerate"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.poolers._fmt_box_list"], ["", "def", "convert_boxes_to_pooler_format", "(", "box_lists", ":", "List", "[", "Boxes", "]", ")", ":", "\n", "    ", "\"\"\"\n    Convert all boxes in `box_lists` to the low-level format used by ROI pooling ops\n    (see description under Returns).\n\n    Args:\n        box_lists (list[Boxes] | list[RotatedBoxes]):\n            A list of N Boxes or N RotatedBoxes, where N is the number of images in the batch.\n\n    Returns:\n        When input is list[Boxes]:\n            A tensor of shape (M, 5), where M is the total number of boxes aggregated over all\n            N batch images.\n            The 5 columns are (batch index, x0, y0, x1, y1), where batch index\n            is the index in [0, N) identifying which batch image the box with corners at\n            (x0, y0, x1, y1) comes from.\n        When input is list[RotatedBoxes]:\n            A tensor of shape (M, 6), where M is the total number of boxes aggregated over all\n            N batch images.\n            The 6 columns are (batch index, x_ctr, y_ctr, width, height, angle_degrees),\n            where batch index is the index in [0, N) identifying which batch image the\n            rotated box (x_ctr, y_ctr, width, height, angle_degrees) comes from.\n    \"\"\"", "\n", "pooler_fmt_boxes", "=", "cat", "(", "\n", "[", "_fmt_box_list", "(", "box_list", ".", "tensor", ",", "i", ")", "for", "i", ",", "box_list", "in", "enumerate", "(", "box_lists", ")", "]", ",", "dim", "=", "0", "\n", ")", "\n", "\n", "return", "pooler_fmt_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.box_regression.Box2BoxTransform.__init__": [[23, 37], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "weights", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "scale_clamp", ":", "float", "=", "_DEFAULT_SCALE_CLAMP", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            weights (4-element tuple): Scaling factors that are applied to the\n                (dx, dy, dw, dh) deltas. In Fast R-CNN, these were originally set\n                such that the deltas have unit variance; now they are treated as\n                hyperparameters of the system.\n            scale_clamp (float): When predicting deltas, the predicted box scaling\n                factors (dw and dh) are clamped such that they are <= scale_clamp.\n        \"\"\"", "\n", "self", ".", "weights", "=", "weights", "\n", "self", ".", "scale_clamp", "=", "scale_clamp", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.box_regression.Box2BoxTransform.get_deltas": [[38, 72], ["isinstance", "type", "isinstance", "type", "torch.stack", "torch.log", "torch.log"], "methods", ["None"], ["", "def", "get_deltas", "(", "self", ",", "src_boxes", ",", "target_boxes", ")", ":", "\n", "        ", "\"\"\"\n        Get box regression transformation deltas (dx, dy, dw, dh) that can be used\n        to transform the `src_boxes` into the `target_boxes`. That is, the relation\n        ``target_boxes == self.apply_deltas(deltas, src_boxes)`` is true (unless\n        any delta is too large and is clamped).\n\n        Args:\n            src_boxes (Tensor): source boxes, e.g., object proposals\n            target_boxes (Tensor): target of the transformation, e.g., ground-truth\n                boxes.\n        \"\"\"", "\n", "assert", "isinstance", "(", "src_boxes", ",", "torch", ".", "Tensor", ")", ",", "type", "(", "src_boxes", ")", "\n", "assert", "isinstance", "(", "target_boxes", ",", "torch", ".", "Tensor", ")", ",", "type", "(", "target_boxes", ")", "\n", "\n", "src_widths", "=", "src_boxes", "[", ":", ",", "2", "]", "-", "src_boxes", "[", ":", ",", "0", "]", "\n", "src_heights", "=", "src_boxes", "[", ":", ",", "3", "]", "-", "src_boxes", "[", ":", ",", "1", "]", "\n", "src_ctr_x", "=", "src_boxes", "[", ":", ",", "0", "]", "+", "0.5", "*", "src_widths", "\n", "src_ctr_y", "=", "src_boxes", "[", ":", ",", "1", "]", "+", "0.5", "*", "src_heights", "\n", "\n", "target_widths", "=", "target_boxes", "[", ":", ",", "2", "]", "-", "target_boxes", "[", ":", ",", "0", "]", "\n", "target_heights", "=", "target_boxes", "[", ":", ",", "3", "]", "-", "target_boxes", "[", ":", ",", "1", "]", "\n", "target_ctr_x", "=", "target_boxes", "[", ":", ",", "0", "]", "+", "0.5", "*", "target_widths", "\n", "target_ctr_y", "=", "target_boxes", "[", ":", ",", "1", "]", "+", "0.5", "*", "target_heights", "\n", "\n", "wx", ",", "wy", ",", "ww", ",", "wh", "=", "self", ".", "weights", "\n", "dx", "=", "wx", "*", "(", "target_ctr_x", "-", "src_ctr_x", ")", "/", "src_widths", "\n", "dy", "=", "wy", "*", "(", "target_ctr_y", "-", "src_ctr_y", ")", "/", "src_heights", "\n", "dw", "=", "ww", "*", "torch", ".", "log", "(", "target_widths", "/", "src_widths", ")", "\n", "dh", "=", "wh", "*", "torch", ".", "log", "(", "target_heights", "/", "src_heights", ")", "\n", "\n", "deltas", "=", "torch", ".", "stack", "(", "(", "dx", ",", "dy", ",", "dw", ",", "dh", ")", ",", "dim", "=", "1", ")", "\n", "assert", "(", "src_widths", ">", "0", ")", ".", "all", "(", ")", ".", "item", "(", ")", ",", "\"Input boxes to Box2BoxTransform are not valid!\"", "\n", "return", "deltas", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.box_regression.Box2BoxTransform.apply_deltas": [[73, 111], ["boxes.to.to.to", "torch.clamp", "torch.clamp", "torch.zeros_like", "torch.exp", "torch.exp"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "apply_deltas", "(", "self", ",", "deltas", ",", "boxes", ")", ":", "\n", "        ", "\"\"\"\n        Apply transformation `deltas` (dx, dy, dw, dh) to `boxes`.\n\n        Args:\n            deltas (Tensor): transformation deltas of shape (N, k*4), where k >= 1.\n                deltas[i] represents k potentially different class-specific\n                box transformations for the single box boxes[i].\n            boxes (Tensor): boxes to transform, of shape (N, 4)\n        \"\"\"", "\n", "boxes", "=", "boxes", ".", "to", "(", "deltas", ".", "dtype", ")", "\n", "\n", "widths", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "\n", "heights", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "\n", "ctr_x", "=", "boxes", "[", ":", ",", "0", "]", "+", "0.5", "*", "widths", "\n", "ctr_y", "=", "boxes", "[", ":", ",", "1", "]", "+", "0.5", "*", "heights", "\n", "\n", "wx", ",", "wy", ",", "ww", ",", "wh", "=", "self", ".", "weights", "\n", "dx", "=", "deltas", "[", ":", ",", "0", ":", ":", "4", "]", "/", "wx", "\n", "dy", "=", "deltas", "[", ":", ",", "1", ":", ":", "4", "]", "/", "wy", "\n", "dw", "=", "deltas", "[", ":", ",", "2", ":", ":", "4", "]", "/", "ww", "\n", "dh", "=", "deltas", "[", ":", ",", "3", ":", ":", "4", "]", "/", "wh", "\n", "\n", "# Prevent sending too large values into torch.exp()", "\n", "dw", "=", "torch", ".", "clamp", "(", "dw", ",", "max", "=", "self", ".", "scale_clamp", ")", "\n", "dh", "=", "torch", ".", "clamp", "(", "dh", ",", "max", "=", "self", ".", "scale_clamp", ")", "\n", "\n", "pred_ctr_x", "=", "dx", "*", "widths", "[", ":", ",", "None", "]", "+", "ctr_x", "[", ":", ",", "None", "]", "\n", "pred_ctr_y", "=", "dy", "*", "heights", "[", ":", ",", "None", "]", "+", "ctr_y", "[", ":", ",", "None", "]", "\n", "pred_w", "=", "torch", ".", "exp", "(", "dw", ")", "*", "widths", "[", ":", ",", "None", "]", "\n", "pred_h", "=", "torch", ".", "exp", "(", "dh", ")", "*", "heights", "[", ":", ",", "None", "]", "\n", "\n", "pred_boxes", "=", "torch", ".", "zeros_like", "(", "deltas", ")", "\n", "pred_boxes", "[", ":", ",", "0", ":", ":", "4", "]", "=", "pred_ctr_x", "-", "0.5", "*", "pred_w", "# x1", "\n", "pred_boxes", "[", ":", ",", "1", ":", ":", "4", "]", "=", "pred_ctr_y", "-", "0.5", "*", "pred_h", "# y1", "\n", "pred_boxes", "[", ":", ",", "2", ":", ":", "4", "]", "=", "pred_ctr_x", "+", "0.5", "*", "pred_w", "# x2", "\n", "pred_boxes", "[", ":", ",", "3", ":", ":", "4", "]", "=", "pred_ctr_y", "+", "0.5", "*", "pred_h", "# y2", "\n", "return", "pred_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.box_regression.Box2BoxTransformRotated.__init__": [[123, 138], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "weights", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "scale_clamp", ":", "float", "=", "_DEFAULT_SCALE_CLAMP", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            weights (5-element tuple): Scaling factors that are applied to the\n                (dx, dy, dw, dh, da) deltas. These are treated as\n                hyperparameters of the system.\n            scale_clamp (float): When predicting deltas, the predicted box scaling\n                factors (dw and dh) are clamped such that they are <= scale_clamp.\n        \"\"\"", "\n", "self", ".", "weights", "=", "weights", "\n", "self", ".", "scale_clamp", "=", "scale_clamp", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.box_regression.Box2BoxTransformRotated.get_deltas": [[139, 176], ["isinstance", "type", "isinstance", "type", "torch.unbind", "torch.unbind", "torch.stack", "torch.log", "torch.log"], "methods", ["None"], ["", "def", "get_deltas", "(", "self", ",", "src_boxes", ",", "target_boxes", ")", ":", "\n", "        ", "\"\"\"\n        Get box regression transformation deltas (dx, dy, dw, dh, da) that can be used\n        to transform the `src_boxes` into the `target_boxes`. That is, the relation\n        ``target_boxes == self.apply_deltas(deltas, src_boxes)`` is true (unless\n        any delta is too large and is clamped).\n\n        Args:\n            src_boxes (Tensor): Nx5 source boxes, e.g., object proposals\n            target_boxes (Tensor): Nx5 target of the transformation, e.g., ground-truth\n                boxes.\n        \"\"\"", "\n", "assert", "isinstance", "(", "src_boxes", ",", "torch", ".", "Tensor", ")", ",", "type", "(", "src_boxes", ")", "\n", "assert", "isinstance", "(", "target_boxes", ",", "torch", ".", "Tensor", ")", ",", "type", "(", "target_boxes", ")", "\n", "\n", "src_ctr_x", ",", "src_ctr_y", ",", "src_widths", ",", "src_heights", ",", "src_angles", "=", "torch", ".", "unbind", "(", "src_boxes", ",", "dim", "=", "1", ")", "\n", "\n", "target_ctr_x", ",", "target_ctr_y", ",", "target_widths", ",", "target_heights", ",", "target_angles", "=", "torch", ".", "unbind", "(", "\n", "target_boxes", ",", "dim", "=", "1", "\n", ")", "\n", "\n", "wx", ",", "wy", ",", "ww", ",", "wh", ",", "wa", "=", "self", ".", "weights", "\n", "dx", "=", "wx", "*", "(", "target_ctr_x", "-", "src_ctr_x", ")", "/", "src_widths", "\n", "dy", "=", "wy", "*", "(", "target_ctr_y", "-", "src_ctr_y", ")", "/", "src_heights", "\n", "dw", "=", "ww", "*", "torch", ".", "log", "(", "target_widths", "/", "src_widths", ")", "\n", "dh", "=", "wh", "*", "torch", ".", "log", "(", "target_heights", "/", "src_heights", ")", "\n", "# Angles of deltas are in radians while angles of boxes are in degrees.", "\n", "# the conversion to radians serve as a way to normalize the values", "\n", "da", "=", "target_angles", "-", "src_angles", "\n", "da", "=", "(", "da", "+", "180.0", ")", "%", "360.0", "-", "180.0", "# make it in [-180, 180)", "\n", "da", "*=", "wa", "*", "math", ".", "pi", "/", "180.0", "\n", "\n", "deltas", "=", "torch", ".", "stack", "(", "(", "dx", ",", "dy", ",", "dw", ",", "dh", ",", "da", ")", ",", "dim", "=", "1", ")", "\n", "assert", "(", "\n", "(", "src_widths", ">", "0", ")", ".", "all", "(", ")", ".", "item", "(", ")", "\n", ")", ",", "\"Input boxes to Box2BoxTransformRotated are not valid!\"", "\n", "return", "deltas", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.box_regression.Box2BoxTransformRotated.apply_deltas": [[177, 222], ["boxes.to().unsqueeze.to().unsqueeze.to().unsqueeze", "torch.clamp", "torch.clamp", "torch.zeros_like", "torch.exp", "torch.exp", "boxes.to().unsqueeze.to().unsqueeze.to"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "apply_deltas", "(", "self", ",", "deltas", ",", "boxes", ")", ":", "\n", "        ", "\"\"\"\n        Apply transformation `deltas` (dx, dy, dw, dh, da) to `boxes`.\n\n        Args:\n            deltas (Tensor): transformation deltas of shape (N, k*5).\n                deltas[i] represents box transformation for the single box boxes[i].\n            boxes (Tensor): boxes to transform, of shape (N, 5)\n        \"\"\"", "\n", "assert", "deltas", ".", "shape", "[", "1", "]", "%", "5", "==", "0", "and", "boxes", ".", "shape", "[", "1", "]", "==", "5", "\n", "\n", "boxes", "=", "boxes", ".", "to", "(", "deltas", ".", "dtype", ")", ".", "unsqueeze", "(", "2", ")", "\n", "\n", "ctr_x", "=", "boxes", "[", ":", ",", "0", "]", "\n", "ctr_y", "=", "boxes", "[", ":", ",", "1", "]", "\n", "widths", "=", "boxes", "[", ":", ",", "2", "]", "\n", "heights", "=", "boxes", "[", ":", ",", "3", "]", "\n", "angles", "=", "boxes", "[", ":", ",", "4", "]", "\n", "\n", "wx", ",", "wy", ",", "ww", ",", "wh", ",", "wa", "=", "self", ".", "weights", "\n", "\n", "dx", "=", "deltas", "[", ":", ",", "0", ":", ":", "5", "]", "/", "wx", "\n", "dy", "=", "deltas", "[", ":", ",", "1", ":", ":", "5", "]", "/", "wy", "\n", "dw", "=", "deltas", "[", ":", ",", "2", ":", ":", "5", "]", "/", "ww", "\n", "dh", "=", "deltas", "[", ":", ",", "3", ":", ":", "5", "]", "/", "wh", "\n", "da", "=", "deltas", "[", ":", ",", "4", ":", ":", "5", "]", "/", "wa", "\n", "\n", "# Prevent sending too large values into torch.exp()", "\n", "dw", "=", "torch", ".", "clamp", "(", "dw", ",", "max", "=", "self", ".", "scale_clamp", ")", "\n", "dh", "=", "torch", ".", "clamp", "(", "dh", ",", "max", "=", "self", ".", "scale_clamp", ")", "\n", "\n", "pred_boxes", "=", "torch", ".", "zeros_like", "(", "deltas", ")", "\n", "pred_boxes", "[", ":", ",", "0", ":", ":", "5", "]", "=", "dx", "*", "widths", "+", "ctr_x", "# x_ctr", "\n", "pred_boxes", "[", ":", ",", "1", ":", ":", "5", "]", "=", "dy", "*", "heights", "+", "ctr_y", "# y_ctr", "\n", "pred_boxes", "[", ":", ",", "2", ":", ":", "5", "]", "=", "torch", ".", "exp", "(", "dw", ")", "*", "widths", "# width", "\n", "pred_boxes", "[", ":", ",", "3", ":", ":", "5", "]", "=", "torch", ".", "exp", "(", "dh", ")", "*", "heights", "# height", "\n", "\n", "# Following original RRPN implementation,", "\n", "# angles of deltas are in radians while angles of boxes are in degrees.", "\n", "pred_angle", "=", "da", "*", "180.0", "/", "math", ".", "pi", "+", "angles", "\n", "pred_angle", "=", "(", "pred_angle", "+", "180.0", ")", "%", "360.0", "-", "180.0", "# make it in [-180, 180)", "\n", "\n", "pred_boxes", "[", ":", ",", "4", ":", ":", "5", "]", "=", "pred_angle", "\n", "\n", "return", "pred_boxes", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.sampling.subsample_labels": [[9, 55], ["int", "min", "min", "detectron2.layers.nonzero_tuple", "detectron2.layers.nonzero_tuple", "positive.numel", "negative.numel", "torch.randperm", "torch.randperm", "positive.numel", "negative.numel"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.nonzero_tuple", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.nonzero_tuple"], ["def", "subsample_labels", "(", "\n", "labels", ":", "torch", ".", "Tensor", ",", "num_samples", ":", "int", ",", "positive_fraction", ":", "float", ",", "bg_label", ":", "int", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Return `num_samples` (or fewer, if not enough found)\n    random samples from `labels` which is a mixture of positives & negatives.\n    It will try to return as many positives as possible without\n    exceeding `positive_fraction * num_samples`, and then try to\n    fill the remaining slots with negatives.\n\n    Args:\n        labels (Tensor): (N, ) label vector with values:\n            * -1: ignore\n            * bg_label: background (\"negative\") class\n            * otherwise: one or more foreground (\"positive\") classes\n        num_samples (int): The total number of labels with value >= 0 to return.\n            Values that are not sampled will be filled with -1 (ignore).\n        positive_fraction (float): The number of subsampled labels with values > 0\n            is `min(num_positives, int(positive_fraction * num_samples))`. The number\n            of negatives sampled is `min(num_negatives, num_samples - num_positives_sampled)`.\n            In order words, if there are not enough positives, the sample is filled with\n            negatives. If there are also not enough negatives, then as many elements are\n            sampled as is possible.\n        bg_label (int): label index of background (\"negative\") class.\n\n    Returns:\n        pos_idx, neg_idx (Tensor):\n            1D vector of indices. The total length of both is `num_samples` or fewer.\n    \"\"\"", "\n", "positive", "=", "nonzero_tuple", "(", "(", "labels", "!=", "-", "1", ")", "&", "(", "labels", "!=", "bg_label", ")", ")", "[", "0", "]", "\n", "negative", "=", "nonzero_tuple", "(", "labels", "==", "bg_label", ")", "[", "0", "]", "\n", "\n", "num_pos", "=", "int", "(", "num_samples", "*", "positive_fraction", ")", "\n", "# protect against not enough positive examples", "\n", "num_pos", "=", "min", "(", "positive", ".", "numel", "(", ")", ",", "num_pos", ")", "\n", "num_neg", "=", "num_samples", "-", "num_pos", "\n", "# protect against not enough negative examples", "\n", "num_neg", "=", "min", "(", "negative", ".", "numel", "(", ")", ",", "num_neg", ")", "\n", "\n", "# randomly select positive and negative examples", "\n", "perm1", "=", "torch", ".", "randperm", "(", "positive", ".", "numel", "(", ")", ",", "device", "=", "positive", ".", "device", ")", "[", ":", "num_pos", "]", "\n", "perm2", "=", "torch", ".", "randperm", "(", "negative", ".", "numel", "(", ")", ",", "device", "=", "negative", ".", "device", ")", "[", ":", "num_neg", "]", "\n", "\n", "pos_idx", "=", "positive", "[", "perm1", "]", "\n", "neg_idx", "=", "negative", "[", "perm2", "]", "\n", "return", "pos_idx", ",", "neg_idx", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.densepose_checkpoint.DensePoseCheckpointer.__init__": [[27, 29], ["detectron2.checkpoint.DetectionCheckpointer.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "save_dir", "=", "\"\"", ",", "*", ",", "save_to_disk", "=", "None", ",", "**", "checkpointables", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "model", ",", "save_dir", ",", "save_to_disk", "=", "save_to_disk", ",", "**", "checkpointables", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.densepose_checkpoint.DensePoseCheckpointer._load_file": [[30, 36], ["super()._load_file", "densepose_checkpoint._rename_HRNet_weights"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.detection_checkpoint.DetectionCheckpointer._load_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.densepose_checkpoint._rename_HRNet_weights"], ["", "def", "_load_file", "(", "self", ",", "filename", ":", "str", ")", "->", "object", ":", "\n", "        ", "\"\"\"\n        Adding hrnet support\n        \"\"\"", "\n", "weights", "=", "super", "(", ")", ".", "_load_file", "(", "filename", ")", "\n", "return", "_rename_HRNet_weights", "(", "weights", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.densepose_checkpoint._rename_HRNet_weights": [[7, 20], ["collections.OrderedDict", "weights[].keys", "len", "len", "weights[].keys", "weights[].keys", "k.startswith", "str"], "function", ["None"], ["def", "_rename_HRNet_weights", "(", "weights", ")", ":", "\n", "# We detect and  rename HRNet weights for DensePose. 1956 and 1716 are values that are", "\n", "# common to all HRNet pretrained weights, and should be enough to accurately identify them", "\n", "    ", "if", "(", "\n", "len", "(", "weights", "[", "\"model\"", "]", ".", "keys", "(", ")", ")", "==", "1956", "\n", "and", "len", "(", "[", "k", "for", "k", "in", "weights", "[", "\"model\"", "]", ".", "keys", "(", ")", "if", "k", ".", "startswith", "(", "\"stage\"", ")", "]", ")", "==", "1716", "\n", ")", ":", "\n", "        ", "hrnet_weights", "=", "OrderedDict", "(", ")", "\n", "for", "k", "in", "weights", "[", "\"model\"", "]", ".", "keys", "(", ")", ":", "\n", "            ", "hrnet_weights", "[", "\"backbone.bottom_up.\"", "+", "str", "(", "k", ")", "]", "=", "weights", "[", "\"model\"", "]", "[", "k", "]", "\n", "", "return", "{", "\"model\"", ":", "hrnet_weights", "}", "\n", "", "else", ":", "\n", "        ", "return", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.build.build_densepose_predictor": [[10, 24], ["DENSEPOSE_PREDICTOR_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["\n", "\n", "\n", "def", "build_model", "(", "cfg", ")", ":", "\n", "    ", "\"\"\"\n    Build the whole model architecture, defined by ``cfg.MODEL.META_ARCHITECTURE``.\n    Note that it does not load any weights from ``cfg``.\n    \"\"\"", "\n", "meta_arch", "=", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "\n", "model", "=", "META_ARCH_REGISTRY", ".", "get", "(", "meta_arch", ")", "(", "cfg", ")", "\n", "model", ".", "to", "(", "torch", ".", "device", "(", "cfg", ".", "MODEL", ".", "DEVICE", ")", ")", "\n", "return", "model", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.build.build_densepose_data_filter": [[26, 40], ["filter.DensePoseDataFilter"], "function", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.build.build_densepose_head": [[42, 56], ["ROI_DENSEPOSE_HEAD_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.build.build_densepose_losses": [[58, 71], ["DENSEPOSE_LOSS_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.inference.densepose_inference": [[9, 44], ["len", "type", "dataclasses.fields", "type.", "getattr", "isinstance"], "function", ["None"], ["def", "densepose_inference", "(", "densepose_predictor_output", ":", "Any", ",", "detections", ":", "List", "[", "Instances", "]", ")", ":", "\n", "    ", "\"\"\"\n    Splits DensePose predictor outputs into chunks, each chunk corresponds to\n    detections on one image. Predictor output chunks are stored in `pred_densepose`\n    attribute of the corresponding `Instances` object.\n\n    Args:\n        densepose_predictor_output: a dataclass instance (can be of different types,\n            depending on predictor used for inference). Each field can be `None`\n            (if the corresponding output was not inferred) or a tensor of size\n            [N, ...], where N = N_1 + N_2 + .. + N_k is a total number of\n            detections on all images, N_1 is the number of detections on image 1,\n            N_2 is the number of detections on image 2, etc.\n        detections: a list of objects of type `Instance`, k-th object corresponds\n            to detections on k-th image.\n    \"\"\"", "\n", "k", "=", "0", "\n", "for", "detection_i", "in", "detections", ":", "\n", "        ", "if", "densepose_predictor_output", "is", "None", ":", "\n", "# don't add `pred_densepose` attribute", "\n", "            ", "continue", "\n", "", "n_i", "=", "len", "(", "detection_i", ")", "\n", "PredictorOutput", "=", "type", "(", "densepose_predictor_output", ")", "\n", "output_i_dict", "=", "{", "}", "\n", "# we assume here that `densepose_predictor_output` is a dataclass object", "\n", "for", "field", "in", "fields", "(", "densepose_predictor_output", ")", ":", "\n", "            ", "field_value", "=", "getattr", "(", "densepose_predictor_output", ",", "field", ".", "name", ")", "\n", "# slice tensors", "\n", "if", "isinstance", "(", "field_value", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "output_i_dict", "[", "field", ".", "name", "]", "=", "field_value", "[", "k", ":", "k", "+", "n_i", "]", "\n", "# leave others as is", "\n", "", "else", ":", "\n", "                ", "output_i_dict", "[", "field", ".", "name", "]", "=", "field_value", "\n", "", "", "detection_i", ".", "pred_densepose", "=", "PredictorOutput", "(", "**", "output_i_dict", ")", "\n", "k", "+=", "n_i", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.BasicBlock.__init__": [[31, 40], ["torch.Module.__init__", "hrnet.conv3x3", "torch.BatchNorm2d", "torch.ReLU", "hrnet.conv3x3", "torch.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.conv3x3", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.conv3x3"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", "=", "1", ",", "downsample", "=", "None", ")", ":", "\n", "        ", "super", "(", "BasicBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "conv3x3", "(", "inplanes", ",", "planes", ",", "stride", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ",", "momentum", "=", "BN_MOMENTUM", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "conv2", "=", "conv3x3", "(", "planes", ",", "planes", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ",", "momentum", "=", "BN_MOMENTUM", ")", "\n", "self", ".", "downsample", "=", "downsample", "\n", "self", ".", "stride", "=", "stride", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.BasicBlock.forward": [[41, 58], ["hrnet.BasicBlock.conv1", "hrnet.BasicBlock.bn1", "hrnet.BasicBlock.relu", "hrnet.BasicBlock.conv2", "hrnet.BasicBlock.bn2", "hrnet.BasicBlock.relu", "hrnet.BasicBlock.downsample"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "residual", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "residual", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "residual", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.Bottleneck.__init__": [[63, 74], ["torch.Module.__init__", "torch.Conv2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", "=", "1", ",", "downsample", "=", "None", ")", ":", "\n", "        ", "super", "(", "Bottleneck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "inplanes", ",", "planes", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ",", "momentum", "=", "BN_MOMENTUM", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ",", "momentum", "=", "BN_MOMENTUM", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", "*", "self", ".", "expansion", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3", "=", "nn", ".", "BatchNorm2d", "(", "planes", "*", "self", ".", "expansion", ",", "momentum", "=", "BN_MOMENTUM", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "downsample", "=", "downsample", "\n", "self", ".", "stride", "=", "stride", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.Bottleneck.forward": [[75, 96], ["hrnet.Bottleneck.conv1", "hrnet.Bottleneck.bn1", "hrnet.Bottleneck.relu", "hrnet.Bottleneck.conv2", "hrnet.Bottleneck.bn2", "hrnet.Bottleneck.relu", "hrnet.Bottleneck.conv3", "hrnet.Bottleneck.bn3", "hrnet.Bottleneck.relu", "hrnet.Bottleneck.downsample"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "residual", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "out", "=", "self", ".", "bn3", "(", "out", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "residual", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "residual", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.HighResolutionModule.__init__": [[111, 131], ["torch.Module.__init__", "hrnet.HighResolutionModule._check_branches", "hrnet.HighResolutionModule._make_branches", "hrnet.HighResolutionModule._make_fuse_layers", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.HighResolutionModule._check_branches", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.HighResolutionModule._make_branches", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.HighResolutionModule._make_fuse_layers"], ["def", "__init__", "(", "\n", "self", ",", "\n", "num_branches", ",", "\n", "blocks", ",", "\n", "num_blocks", ",", "\n", "num_inchannels", ",", "\n", "num_channels", ",", "\n", "multi_scale_output", "=", "True", ",", "\n", ")", ":", "\n", "        ", "super", "(", "HighResolutionModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_check_branches", "(", "num_branches", ",", "blocks", ",", "num_blocks", ",", "num_inchannels", ",", "num_channels", ")", "\n", "\n", "self", ".", "num_inchannels", "=", "num_inchannels", "\n", "self", ".", "num_branches", "=", "num_branches", "\n", "\n", "self", ".", "multi_scale_output", "=", "multi_scale_output", "\n", "\n", "self", ".", "branches", "=", "self", ".", "_make_branches", "(", "num_branches", ",", "blocks", ",", "num_blocks", ",", "num_channels", ")", "\n", "self", ".", "fuse_layers", "=", "self", ".", "_make_fuse_layers", "(", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.HighResolutionModule._check_branches": [[132, 151], ["len", "logger.error", "ValueError", "len", "logger.error", "ValueError", "len", "logger.error", "ValueError", "len", "len", "len"], "methods", ["None"], ["", "def", "_check_branches", "(", "self", ",", "num_branches", ",", "blocks", ",", "num_blocks", ",", "num_inchannels", ",", "num_channels", ")", ":", "\n", "        ", "if", "num_branches", "!=", "len", "(", "num_blocks", ")", ":", "\n", "            ", "error_msg", "=", "\"NUM_BRANCHES({}) <> NUM_BLOCKS({})\"", ".", "format", "(", "num_branches", ",", "len", "(", "num_blocks", ")", ")", "\n", "logger", ".", "error", "(", "error_msg", ")", "\n", "raise", "ValueError", "(", "error_msg", ")", "\n", "\n", "", "if", "num_branches", "!=", "len", "(", "num_channels", ")", ":", "\n", "            ", "error_msg", "=", "\"NUM_BRANCHES({}) <> NUM_CHANNELS({})\"", ".", "format", "(", "\n", "num_branches", ",", "len", "(", "num_channels", ")", "\n", ")", "\n", "logger", ".", "error", "(", "error_msg", ")", "\n", "raise", "ValueError", "(", "error_msg", ")", "\n", "\n", "", "if", "num_branches", "!=", "len", "(", "num_inchannels", ")", ":", "\n", "            ", "error_msg", "=", "\"NUM_BRANCHES({}) <> NUM_INCHANNELS({})\"", ".", "format", "(", "\n", "num_branches", ",", "len", "(", "num_inchannels", ")", "\n", ")", "\n", "logger", ".", "error", "(", "error_msg", ")", "\n", "raise", "ValueError", "(", "error_msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.HighResolutionModule._make_one_branch": [[152, 178], ["layers.append", "range", "torch.Sequential", "torch.Sequential", "block", "layers.append", "torch.Conv2d", "torch.BatchNorm2d", "block"], "methods", ["None"], ["", "", "def", "_make_one_branch", "(", "self", ",", "branch_index", ",", "block", ",", "num_blocks", ",", "num_channels", ",", "stride", "=", "1", ")", ":", "\n", "        ", "downsample", "=", "None", "\n", "if", "(", "\n", "stride", "!=", "1", "\n", "or", "self", ".", "num_inchannels", "[", "branch_index", "]", "!=", "num_channels", "[", "branch_index", "]", "*", "block", ".", "expansion", "\n", ")", ":", "\n", "            ", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "self", ".", "num_inchannels", "[", "branch_index", "]", ",", "\n", "num_channels", "[", "branch_index", "]", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "bias", "=", "False", ",", "\n", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "num_channels", "[", "branch_index", "]", "*", "block", ".", "expansion", ",", "momentum", "=", "BN_MOMENTUM", ")", ",", "\n", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "\n", "block", "(", "self", ".", "num_inchannels", "[", "branch_index", "]", ",", "num_channels", "[", "branch_index", "]", ",", "stride", ",", "downsample", ")", "\n", ")", "\n", "self", ".", "num_inchannels", "[", "branch_index", "]", "=", "num_channels", "[", "branch_index", "]", "*", "block", ".", "expansion", "\n", "for", "_", "in", "range", "(", "1", ",", "num_blocks", "[", "branch_index", "]", ")", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "num_inchannels", "[", "branch_index", "]", ",", "num_channels", "[", "branch_index", "]", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.HighResolutionModule._make_branches": [[179, 186], ["range", "torch.ModuleList", "branches.append", "hrnet.HighResolutionModule._make_one_branch"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.HighResolutionModule._make_one_branch"], ["", "def", "_make_branches", "(", "self", ",", "num_branches", ",", "block", ",", "num_blocks", ",", "num_channels", ")", ":", "\n", "        ", "branches", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "num_branches", ")", ":", "\n", "            ", "branches", ".", "append", "(", "self", ".", "_make_one_branch", "(", "i", ",", "block", ",", "num_blocks", ",", "num_channels", ")", ")", "\n", "\n", "", "return", "nn", ".", "ModuleList", "(", "branches", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.HighResolutionModule._make_fuse_layers": [[187, 245], ["range", "torch.ModuleList", "range", "fuse_layers.append", "torch.ModuleList", "fuse_layer.append", "torch.Sequential", "fuse_layer.append", "range", "fuse_layer.append", "torch.Conv2d", "torch.BatchNorm2d", "torch.Upsample", "torch.Sequential", "conv3x3s.append", "conv3x3s.append", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU"], "methods", ["None"], ["", "def", "_make_fuse_layers", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "num_branches", "==", "1", ":", "\n", "            ", "return", "None", "\n", "\n", "", "num_branches", "=", "self", ".", "num_branches", "\n", "num_inchannels", "=", "self", ".", "num_inchannels", "\n", "fuse_layers", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_branches", "if", "self", ".", "multi_scale_output", "else", "1", ")", ":", "\n", "            ", "fuse_layer", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "num_branches", ")", ":", "\n", "                ", "if", "j", ">", "i", ":", "\n", "                    ", "fuse_layer", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "num_inchannels", "[", "j", "]", ",", "num_inchannels", "[", "i", "]", ",", "1", ",", "1", ",", "0", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "num_inchannels", "[", "i", "]", ")", ",", "\n", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", "**", "(", "j", "-", "i", ")", ",", "mode", "=", "\"nearest\"", ")", ",", "\n", ")", "\n", ")", "\n", "", "elif", "j", "==", "i", ":", "\n", "                    ", "fuse_layer", ".", "append", "(", "None", ")", "\n", "", "else", ":", "\n", "                    ", "conv3x3s", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "i", "-", "j", ")", ":", "\n", "                        ", "if", "k", "==", "i", "-", "j", "-", "1", ":", "\n", "                            ", "num_outchannels_conv3x3", "=", "num_inchannels", "[", "i", "]", "\n", "conv3x3s", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "num_inchannels", "[", "j", "]", ",", "\n", "num_outchannels_conv3x3", ",", "\n", "3", ",", "\n", "2", ",", "\n", "1", ",", "\n", "bias", "=", "False", ",", "\n", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "num_outchannels_conv3x3", ")", ",", "\n", ")", "\n", ")", "\n", "", "else", ":", "\n", "                            ", "num_outchannels_conv3x3", "=", "num_inchannels", "[", "j", "]", "\n", "conv3x3s", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "num_inchannels", "[", "j", "]", ",", "\n", "num_outchannels_conv3x3", ",", "\n", "3", ",", "\n", "2", ",", "\n", "1", ",", "\n", "bias", "=", "False", ",", "\n", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "num_outchannels_conv3x3", ")", ",", "\n", "nn", ".", "ReLU", "(", "True", ")", ",", "\n", ")", "\n", ")", "\n", "", "", "fuse_layer", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "conv3x3s", ")", ")", "\n", "", "", "fuse_layers", ".", "append", "(", "nn", ".", "ModuleList", "(", "fuse_layer", ")", ")", "\n", "\n", "", "return", "nn", ".", "ModuleList", "(", "fuse_layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.HighResolutionModule.get_num_inchannels": [[246, 248], ["None"], "methods", ["None"], ["", "def", "get_num_inchannels", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "num_inchannels", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.HighResolutionModule.forward": [[249, 269], ["range", "range", "len", "range", "x_fuse.append", "hrnet.HighResolutionModule.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "num_branches", "==", "1", ":", "\n", "            ", "return", "[", "self", ".", "branches", "[", "0", "]", "(", "x", "[", "0", "]", ")", "]", "\n", "\n", "", "for", "i", "in", "range", "(", "self", ".", "num_branches", ")", ":", "\n", "            ", "x", "[", "i", "]", "=", "self", ".", "branches", "[", "i", "]", "(", "x", "[", "i", "]", ")", "\n", "\n", "", "x_fuse", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "fuse_layers", ")", ")", ":", "\n", "            ", "y", "=", "x", "[", "0", "]", "if", "i", "==", "0", "else", "self", ".", "fuse_layers", "[", "i", "]", "[", "0", "]", "(", "x", "[", "0", "]", ")", "\n", "for", "j", "in", "range", "(", "1", ",", "self", ".", "num_branches", ")", ":", "\n", "                ", "if", "i", "==", "j", ":", "\n", "                    ", "y", "=", "y", "+", "x", "[", "j", "]", "\n", "", "else", ":", "\n", "                    ", "z", "=", "self", ".", "fuse_layers", "[", "i", "]", "[", "j", "]", "(", "x", "[", "j", "]", ")", "[", ":", ",", ":", ",", ":", "y", ".", "shape", "[", "2", "]", ",", ":", "y", ".", "shape", "[", "3", "]", "]", "\n", "y", "=", "y", "+", "z", "\n", "", "", "x_fuse", ".", "append", "(", "self", ".", "relu", "(", "y", ")", ")", "\n", "\n", "", "return", "x_fuse", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.PoseHigherResolutionNet.__init__": [[281, 326], ["detectron2.modeling.backbone.backbone.Backbone.__init__", "torch.Conv2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU", "hrnet.PoseHigherResolutionNet._make_layer", "hrnet.PoseHigherResolutionNet._make_transition_layer", "hrnet.PoseHigherResolutionNet._make_stage", "hrnet.PoseHigherResolutionNet._make_transition_layer", "hrnet.PoseHigherResolutionNet._make_stage", "hrnet.PoseHigherResolutionNet._make_transition_layer", "hrnet.PoseHigherResolutionNet._make_stage", "range", "hrnet.PoseHigherResolutionNet._out_features.append", "hrnet.PoseHigherResolutionNet._out_feature_channels.update", "hrnet.PoseHigherResolutionNet._out_feature_strides.update", "range", "range", "range", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.PoseHigherResolutionNet._make_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.PoseHigherResolutionNet._make_transition_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.PoseHigherResolutionNet._make_stage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.PoseHigherResolutionNet._make_transition_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.PoseHigherResolutionNet._make_stage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.PoseHigherResolutionNet._make_transition_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.PoseHigherResolutionNet._make_stage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update"], ["def", "__init__", "(", "self", ",", "cfg", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "inplanes", "=", "cfg", ".", "MODEL", ".", "HRNET", ".", "STEM_INPLANES", "\n", "super", "(", "PoseHigherResolutionNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# stem net", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "3", ",", "64", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "64", ",", "momentum", "=", "BN_MOMENTUM", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "64", ",", "64", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "64", ",", "momentum", "=", "BN_MOMENTUM", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "Bottleneck", ",", "64", ",", "4", ")", "\n", "\n", "self", ".", "stage2_cfg", "=", "cfg", ".", "MODEL", ".", "HRNET", ".", "STAGE2", "\n", "num_channels", "=", "self", ".", "stage2_cfg", ".", "NUM_CHANNELS", "\n", "block", "=", "blocks_dict", "[", "self", ".", "stage2_cfg", ".", "BLOCK", "]", "\n", "num_channels", "=", "[", "num_channels", "[", "i", "]", "*", "block", ".", "expansion", "for", "i", "in", "range", "(", "len", "(", "num_channels", ")", ")", "]", "\n", "self", ".", "transition1", "=", "self", ".", "_make_transition_layer", "(", "[", "256", "]", ",", "num_channels", ")", "\n", "self", ".", "stage2", ",", "pre_stage_channels", "=", "self", ".", "_make_stage", "(", "self", ".", "stage2_cfg", ",", "num_channels", ")", "\n", "\n", "self", ".", "stage3_cfg", "=", "cfg", ".", "MODEL", ".", "HRNET", ".", "STAGE3", "\n", "num_channels", "=", "self", ".", "stage3_cfg", ".", "NUM_CHANNELS", "\n", "block", "=", "blocks_dict", "[", "self", ".", "stage3_cfg", ".", "BLOCK", "]", "\n", "num_channels", "=", "[", "num_channels", "[", "i", "]", "*", "block", ".", "expansion", "for", "i", "in", "range", "(", "len", "(", "num_channels", ")", ")", "]", "\n", "self", ".", "transition2", "=", "self", ".", "_make_transition_layer", "(", "pre_stage_channels", ",", "num_channels", ")", "\n", "self", ".", "stage3", ",", "pre_stage_channels", "=", "self", ".", "_make_stage", "(", "self", ".", "stage3_cfg", ",", "num_channels", ")", "\n", "\n", "self", ".", "stage4_cfg", "=", "cfg", ".", "MODEL", ".", "HRNET", ".", "STAGE4", "\n", "num_channels", "=", "self", ".", "stage4_cfg", ".", "NUM_CHANNELS", "\n", "block", "=", "blocks_dict", "[", "self", ".", "stage4_cfg", ".", "BLOCK", "]", "\n", "num_channels", "=", "[", "num_channels", "[", "i", "]", "*", "block", ".", "expansion", "for", "i", "in", "range", "(", "len", "(", "num_channels", ")", ")", "]", "\n", "self", ".", "transition3", "=", "self", ".", "_make_transition_layer", "(", "pre_stage_channels", ",", "num_channels", ")", "\n", "self", ".", "stage4", ",", "pre_stage_channels", "=", "self", ".", "_make_stage", "(", "\n", "self", ".", "stage4_cfg", ",", "num_channels", ",", "multi_scale_output", "=", "True", "\n", ")", "\n", "\n", "self", ".", "_out_features", "=", "[", "]", "\n", "self", ".", "_out_feature_channels", "=", "{", "}", "\n", "self", ".", "_out_feature_strides", "=", "{", "}", "\n", "\n", "for", "i", "in", "range", "(", "cfg", ".", "MODEL", ".", "HRNET", ".", "STAGE4", ".", "NUM_BRANCHES", ")", ":", "\n", "            ", "self", ".", "_out_features", ".", "append", "(", "\"p%d\"", "%", "(", "i", "+", "1", ")", ")", "\n", "self", ".", "_out_feature_channels", ".", "update", "(", "\n", "{", "self", ".", "_out_features", "[", "-", "1", "]", ":", "cfg", ".", "MODEL", ".", "HRNET", ".", "STAGE4", ".", "NUM_CHANNELS", "[", "i", "]", "}", "\n", ")", "\n", "self", ".", "_out_feature_strides", ".", "update", "(", "{", "self", ".", "_out_features", "[", "-", "1", "]", ":", "1", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.PoseHigherResolutionNet._get_deconv_cfg": [[327, 339], ["None"], "methods", ["None"], ["", "", "def", "_get_deconv_cfg", "(", "self", ",", "deconv_kernel", ")", ":", "\n", "        ", "if", "deconv_kernel", "==", "4", ":", "\n", "            ", "padding", "=", "1", "\n", "output_padding", "=", "0", "\n", "", "elif", "deconv_kernel", "==", "3", ":", "\n", "            ", "padding", "=", "1", "\n", "output_padding", "=", "1", "\n", "", "elif", "deconv_kernel", "==", "2", ":", "\n", "            ", "padding", "=", "0", "\n", "output_padding", "=", "0", "\n", "\n", "", "return", "deconv_kernel", ",", "padding", ",", "output_padding", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.PoseHigherResolutionNet._make_transition_layer": [[340, 381], ["len", "len", "range", "torch.ModuleList", "range", "transition_layers.append", "transition_layers.append", "transition_layers.append", "conv3x3s.append", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU"], "methods", ["None"], ["", "def", "_make_transition_layer", "(", "self", ",", "num_channels_pre_layer", ",", "num_channels_cur_layer", ")", ":", "\n", "        ", "num_branches_cur", "=", "len", "(", "num_channels_cur_layer", ")", "\n", "num_branches_pre", "=", "len", "(", "num_channels_pre_layer", ")", "\n", "\n", "transition_layers", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_branches_cur", ")", ":", "\n", "            ", "if", "i", "<", "num_branches_pre", ":", "\n", "                ", "if", "num_channels_cur_layer", "[", "i", "]", "!=", "num_channels_pre_layer", "[", "i", "]", ":", "\n", "                    ", "transition_layers", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "num_channels_pre_layer", "[", "i", "]", ",", "\n", "num_channels_cur_layer", "[", "i", "]", ",", "\n", "3", ",", "\n", "1", ",", "\n", "1", ",", "\n", "bias", "=", "False", ",", "\n", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "num_channels_cur_layer", "[", "i", "]", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", ")", "\n", ")", "\n", "", "else", ":", "\n", "                    ", "transition_layers", ".", "append", "(", "None", ")", "\n", "", "", "else", ":", "\n", "                ", "conv3x3s", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "i", "+", "1", "-", "num_branches_pre", ")", ":", "\n", "                    ", "inchannels", "=", "num_channels_pre_layer", "[", "-", "1", "]", "\n", "outchannels", "=", "(", "\n", "num_channels_cur_layer", "[", "i", "]", "if", "j", "==", "i", "-", "num_branches_pre", "else", "inchannels", "\n", ")", "\n", "conv3x3s", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "inchannels", ",", "outchannels", ",", "3", ",", "2", ",", "1", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "outchannels", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", ")", "\n", ")", "\n", "", "transition_layers", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "conv3x3s", ")", ")", "\n", "\n", "", "", "return", "nn", ".", "ModuleList", "(", "transition_layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.PoseHigherResolutionNet._make_layer": [[382, 403], ["layers.append", "range", "torch.Sequential", "torch.Sequential", "block", "layers.append", "torch.Conv2d", "torch.BatchNorm2d", "block"], "methods", ["None"], ["", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "blocks", ",", "stride", "=", "1", ")", ":", "\n", "        ", "downsample", "=", "None", "\n", "if", "stride", "!=", "1", "or", "self", ".", "inplanes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "            ", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "self", ".", "inplanes", ",", "\n", "planes", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "bias", "=", "False", ",", "\n", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "planes", "*", "block", ".", "expansion", ",", "momentum", "=", "BN_MOMENTUM", ")", ",", "\n", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "stride", ",", "downsample", ")", ")", "\n", "self", ".", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n", "for", "_", "in", "range", "(", "1", ",", "blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.PoseHigherResolutionNet._make_stage": [[404, 432], ["range", "modules.append", "modules[].get_num_inchannels", "torch.Sequential", "hrnet.HighResolutionModule"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.HighResolutionModule.get_num_inchannels"], ["", "def", "_make_stage", "(", "self", ",", "layer_config", ",", "num_inchannels", ",", "multi_scale_output", "=", "True", ")", ":", "\n", "        ", "num_modules", "=", "layer_config", "[", "\"NUM_MODULES\"", "]", "\n", "num_branches", "=", "layer_config", "[", "\"NUM_BRANCHES\"", "]", "\n", "num_blocks", "=", "layer_config", "[", "\"NUM_BLOCKS\"", "]", "\n", "num_channels", "=", "layer_config", "[", "\"NUM_CHANNELS\"", "]", "\n", "block", "=", "blocks_dict", "[", "layer_config", "[", "\"BLOCK\"", "]", "]", "\n", "\n", "modules", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_modules", ")", ":", "\n", "# multi_scale_output is only used last module", "\n", "            ", "if", "not", "multi_scale_output", "and", "i", "==", "num_modules", "-", "1", ":", "\n", "                ", "reset_multi_scale_output", "=", "False", "\n", "", "else", ":", "\n", "                ", "reset_multi_scale_output", "=", "True", "\n", "\n", "", "modules", ".", "append", "(", "\n", "HighResolutionModule", "(", "\n", "num_branches", ",", "\n", "block", ",", "\n", "num_blocks", ",", "\n", "num_inchannels", ",", "\n", "num_channels", ",", "\n", "reset_multi_scale_output", ",", "\n", ")", "\n", ")", "\n", "num_inchannels", "=", "modules", "[", "-", "1", "]", ".", "get_num_inchannels", "(", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "modules", ")", ",", "num_inchannels", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.PoseHigherResolutionNet.forward": [[433, 468], ["hrnet.PoseHigherResolutionNet.conv1", "hrnet.PoseHigherResolutionNet.bn1", "hrnet.PoseHigherResolutionNet.relu", "hrnet.PoseHigherResolutionNet.conv2", "hrnet.PoseHigherResolutionNet.bn2", "hrnet.PoseHigherResolutionNet.relu", "hrnet.PoseHigherResolutionNet.layer1", "range", "hrnet.PoseHigherResolutionNet.stage2", "range", "hrnet.PoseHigherResolutionNet.stage3", "range", "hrnet.PoseHigherResolutionNet.stage4", "dict", "len", "len", "zip", "x_list.append", "x_list.append", "x_list.append", "x_list.append", "x_list.append", "x_list.append"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "bn2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "layer1", "(", "x", ")", "\n", "\n", "x_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "stage2_cfg", ".", "NUM_BRANCHES", ")", ":", "\n", "            ", "if", "self", ".", "transition1", "[", "i", "]", "is", "not", "None", ":", "\n", "                ", "x_list", ".", "append", "(", "self", ".", "transition1", "[", "i", "]", "(", "x", ")", ")", "\n", "", "else", ":", "\n", "                ", "x_list", ".", "append", "(", "x", ")", "\n", "", "", "y_list", "=", "self", ".", "stage2", "(", "x_list", ")", "\n", "\n", "x_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "stage3_cfg", ".", "NUM_BRANCHES", ")", ":", "\n", "            ", "if", "self", ".", "transition2", "[", "i", "]", "is", "not", "None", ":", "\n", "                ", "x_list", ".", "append", "(", "self", ".", "transition2", "[", "i", "]", "(", "y_list", "[", "-", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "x_list", ".", "append", "(", "y_list", "[", "i", "]", ")", "\n", "", "", "y_list", "=", "self", ".", "stage3", "(", "x_list", ")", "\n", "\n", "x_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "stage4_cfg", ".", "NUM_BRANCHES", ")", ":", "\n", "            ", "if", "self", ".", "transition3", "[", "i", "]", "is", "not", "None", ":", "\n", "                ", "x_list", ".", "append", "(", "self", ".", "transition3", "[", "i", "]", "(", "y_list", "[", "-", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "x_list", ".", "append", "(", "y_list", "[", "i", "]", ")", "\n", "", "", "y_list", "=", "self", ".", "stage4", "(", "x_list", ")", "\n", "\n", "assert", "len", "(", "self", ".", "_out_features", ")", "==", "len", "(", "y_list", ")", "\n", "return", "dict", "(", "zip", "(", "self", ".", "_out_features", ",", "y_list", ")", ")", "# final_outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.conv3x3": [[23, 26], ["torch.Conv2d"], "function", ["None"], ["def", "conv3x3", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ")", ":", "\n", "    ", "\"\"\"3x3 convolution with padding\"\"\"", "\n", "return", "nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.build_pose_hrnet_backbone": [[470, 474], ["detectron2.modeling.backbone.BACKBONE_REGISTRY.register", "hrnet.PoseHigherResolutionNet"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.base.BaseConverter.register"], ["", "", "@", "BACKBONE_REGISTRY", ".", "register", "(", ")", "\n", "def", "build_pose_hrnet_backbone", "(", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "    ", "model", "=", "PoseHigherResolutionNet", "(", "cfg", ")", "\n", "return", "model", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.DensePoseDatasetMapperTTA.__init__": [[16, 19], ["detectron2.modeling.test_time_augmentation.DatasetMapperTTA.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["apply_augmentations", ",", "\n", ")", "\n", "from", "detectron2", ".", "structures", "import", "Boxes", ",", "Instances", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.DensePoseDatasetMapperTTA.__call__": [[20, 36], ["super().__call__", "dataset_dict[].permute().numpy", "detectron2.data.transforms.RandomRotation", "detectron2.data.transforms.apply_transform_gens", "torch.from_numpy", "copy.deepcopy", "fvcore.transforms.TransformList", "super().__call__.append", "dataset_dict[].permute", "numpy.copy", "numpy.ascontiguousarray", "new_numpy_image.transpose"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.extractor.Extractor.__call__"], ["from", ".", "meta_arch", "import", "GeneralizedRCNN", "\n", "from", ".", "postprocessing", "import", "detector_postprocess", "\n", "from", ".", "roi_heads", ".", "fast_rcnn", "import", "fast_rcnn_inference_single_image", "\n", "\n", "__all__", "=", "[", "\"DatasetMapperTTA\"", ",", "\"GeneralizedRCNNWithTTA\"", "]", "\n", "\n", "\n", "class", "DatasetMapperTTA", ":", "\n", "    ", "\"\"\"\n    Implement test-time augmentation for detection data.\n    It is a callable which takes a dataset dict from a detection dataset,\n    and returns a list of dataset dicts where the images\n    are augmented from the input image by the transformations defined in the config.\n    This is used for test-time augmentation.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.DensePoseGeneralizedRCNNWithTTA.__init__": [[39, 53], ["transform_data.to", "detectron2.modeling.test_time_augmentation.GeneralizedRCNNWithTTA.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["self", ".", "flip", "=", "cfg", ".", "TEST", ".", "AUG", ".", "FLIP", "\n", "self", ".", "image_format", "=", "cfg", ".", "INPUT", ".", "FORMAT", "\n", "\n", "", "def", "__call__", "(", "self", ",", "dataset_dict", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dict: a dict in standard model input format. See tutorials for details.\n\n        Returns:\n            list[dict]:\n                a list of dicts, which contain augmented version of the input image.\n                The total number of dicts is ``len(min_sizes) * (2 if flip else 1)``.\n                Each dict has field \"transforms\" which is a TransformList,\n                containing the transforms that are used to generate this image.\n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._inference_one_image": [[55, 92], ["input[].to", "test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._get_augmented_inputs", "test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._merge_detections", "test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._turn_off_roi_heads", "test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._get_augmented_boxes", "test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._rescale_detected_boxes", "test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._batch_inference", "detectron2.modeling.postprocessing.detector_postprocess", "test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._reduce_pred_masks", "test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._reduce_pred_densepose"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._get_augmented_inputs", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._merge_detections", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._turn_off_roi_heads", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._get_augmented_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._rescale_detected_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._batch_inference", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.postprocessing.detector_postprocess", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._reduce_pred_masks", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._reduce_pred_densepose"], ["shape", "=", "numpy_image", ".", "shape", "\n", "orig_shape", "=", "(", "dataset_dict", "[", "\"height\"", "]", ",", "dataset_dict", "[", "\"width\"", "]", ")", "\n", "if", "shape", "[", ":", "2", "]", "!=", "orig_shape", ":", "\n", "# It transforms the \"original\" image in the dataset to the input image", "\n", "            ", "pre_tfm", "=", "ResizeTransform", "(", "orig_shape", "[", "0", "]", ",", "orig_shape", "[", "1", "]", ",", "shape", "[", "0", "]", ",", "shape", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "pre_tfm", "=", "NoOpTransform", "(", ")", "\n", "\n", "# Create all combinations of augmentations to use", "\n", "", "aug_candidates", "=", "[", "]", "# each element is a list[Augmentation]", "\n", "for", "min_size", "in", "self", ".", "min_sizes", ":", "\n", "            ", "resize", "=", "ResizeShortestEdge", "(", "min_size", ",", "self", ".", "max_size", ")", "\n", "aug_candidates", ".", "append", "(", "[", "resize", "]", ")", "# resize only", "\n", "if", "self", ".", "flip", ":", "\n", "                ", "flip", "=", "RandomFlip", "(", "prob", "=", "1.0", ")", "\n", "aug_candidates", ".", "append", "(", "[", "resize", ",", "flip", "]", ")", "# resize + flip", "\n", "\n", "# Apply all the augmentations", "\n", "", "", "ret", "=", "[", "]", "\n", "for", "aug", "in", "aug_candidates", ":", "\n", "            ", "new_image", ",", "tfms", "=", "apply_augmentations", "(", "aug", ",", "np", ".", "copy", "(", "numpy_image", ")", ")", "\n", "torch_image", "=", "torch", ".", "from_numpy", "(", "np", ".", "ascontiguousarray", "(", "new_image", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", ")", "\n", "\n", "dic", "=", "copy", ".", "deepcopy", "(", "dataset_dict", ")", "\n", "dic", "[", "\"transforms\"", "]", "=", "pre_tfm", "+", "tfms", "\n", "dic", "[", "\"image\"", "]", "=", "torch_image", "\n", "ret", ".", "append", "(", "dic", ")", "\n", "", "return", "ret", "\n", "\n", "\n", "", "", "class", "GeneralizedRCNNWithTTA", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "\"\"\"\n    A GeneralizedRCNN with test-time augmentation enabled.\n    Its :meth:`__call__` method has the same interface as :meth:`GeneralizedRCNN.forward`.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "cfg", ",", "model", ",", "tta_mapper", "=", "None", ",", "batch_size", "=", "3", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._get_augmented_boxes": [[93, 113], ["test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._batch_inference", "zip", "torch.cat", "any", "tfm.inverse().apply_box", "torch.cat.append", "all_scores.extend", "all_classes.extend", "pred_boxes.cpu().numpy", "torch.from_numpy().to", "isinstance", "tfm.inverse", "pred_boxes.cpu", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._batch_inference", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "isinstance", "(", "model", ",", "DistributedDataParallel", ")", ":", "\n", "            ", "model", "=", "model", ".", "module", "\n", "", "assert", "isinstance", "(", "\n", "model", ",", "GeneralizedRCNN", "\n", ")", ",", "\"TTA is only supported on GeneralizedRCNN. Got a model of type {}\"", ".", "format", "(", "type", "(", "model", ")", ")", "\n", "self", ".", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "assert", "not", "self", ".", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ",", "\"TTA for keypoint is not supported yet\"", "\n", "assert", "(", "\n", "not", "self", ".", "cfg", ".", "MODEL", ".", "LOAD_PROPOSALS", "\n", ")", ",", "\"TTA for pre-computed proposals is not supported yet\"", "\n", "\n", "self", ".", "model", "=", "model", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._reduce_pred_densepose": [[114, 134], ["enumerate", "zip", "any", "test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._incremental_avg_dp", "converters.HFlipConverter.convert", "setattr", "isinstance", "test_time_augmentation._inverse_rotation", "getattr"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._incremental_avg_dp", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation._inverse_rotation"], ["\n", "if", "tta_mapper", "is", "None", ":", "\n", "            ", "tta_mapper", "=", "DatasetMapperTTA", "(", "cfg", ")", "\n", "", "self", ".", "tta_mapper", "=", "tta_mapper", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "\n", "", "@", "contextmanager", "\n", "def", "_turn_off_roi_heads", "(", "self", ",", "attrs", ")", ":", "\n", "        ", "\"\"\"\n        Open a context where some heads in `model.roi_heads` are temporarily turned off.\n        Args:\n            attr (list[str]): the attribute in `model.roi_heads` which can be used\n                to turn off a specific head, e.g., \"mask_on\", \"keypoint_on\".\n        \"\"\"", "\n", "roi_heads", "=", "self", ".", "model", ".", "roi_heads", "\n", "old", "=", "{", "}", "\n", "for", "attr", "in", "attrs", ":", "\n", "            ", "try", ":", "\n", "                ", "old", "[", "attr", "]", "=", "getattr", "(", "roi_heads", ",", "attr", ")", "\n", "", "except", "AttributeError", ":", "\n", "# The head may not be implemented in certain ROIHeads", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._incremental_avg_dp": [[136, 143], ["setattr", "setattr", "getattr", "getattr"], "methods", ["None"], ["\n", "", "", "if", "len", "(", "old", ".", "keys", "(", ")", ")", "==", "0", ":", "\n", "            ", "yield", "\n", "", "else", ":", "\n", "            ", "for", "attr", "in", "old", ".", "keys", "(", ")", ":", "\n", "                ", "setattr", "(", "roi_heads", ",", "attr", ",", "False", ")", "\n", "", "yield", "\n", "for", "attr", "in", "old", ".", "keys", "(", ")", ":", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation._inverse_rotation": [[145, 183], ["boxes.int().cpu().numpy.int().cpu().numpy", "rotate_box_inverse().astype", "torch.tensor().to().float", "numpy.maximum", "range", "len", "densepose_attrs[].clone", "torch.nn.functional.interpolate", "torch.nn.functional.pad", "torch.nn.functional.affine_grid", "torch.nn.functional.grid_sample", "len", "isinstance", "boxes.int().cpu().numpy.int().cpu", "test_time_augmentation.rotate_box_inverse", "torch.tensor().to", "min", "tuple", "min", "torch.nn.functional.interpolate", "wh_boxes[].tolist", "numpy.repeat", "boxes.int().cpu().numpy.int", "torch.tensor", "numpy.maximum"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.rotate_box_inverse", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["\n", "", "", "", "def", "_batch_inference", "(", "self", ",", "batched_inputs", ",", "detected_instances", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Execute inference on a list of inputs,\n        using batch size = self.batch_size, instead of the length of the list.\n\n        Inputs & outputs have the same format as :meth:`GeneralizedRCNN.inference`\n        \"\"\"", "\n", "if", "detected_instances", "is", "None", ":", "\n", "            ", "detected_instances", "=", "[", "None", "]", "*", "len", "(", "batched_inputs", ")", "\n", "\n", "", "outputs", "=", "[", "]", "\n", "inputs", ",", "instances", "=", "[", "]", ",", "[", "]", "\n", "for", "idx", ",", "input", ",", "instance", "in", "zip", "(", "count", "(", ")", ",", "batched_inputs", ",", "detected_instances", ")", ":", "\n", "            ", "inputs", ".", "append", "(", "input", ")", "\n", "instances", ".", "append", "(", "instance", ")", "\n", "if", "len", "(", "inputs", ")", "==", "self", ".", "batch_size", "or", "idx", "==", "len", "(", "batched_inputs", ")", "-", "1", ":", "\n", "                ", "outputs", ".", "extend", "(", "\n", "self", ".", "model", ".", "inference", "(", "\n", "inputs", ",", "\n", "instances", "if", "instances", "[", "0", "]", "is", "not", "None", "else", "None", ",", "\n", "do_postprocess", "=", "False", ",", "\n", ")", "\n", ")", "\n", "inputs", ",", "instances", "=", "[", "]", ",", "[", "]", "\n", "", "", "return", "outputs", "\n", "\n", "", "def", "__call__", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Same input/output format as :meth:`GeneralizedRCNN.forward`\n        \"\"\"", "\n", "\n", "def", "_maybe_read_image", "(", "dataset_dict", ")", ":", "\n", "            ", "ret", "=", "copy", ".", "copy", "(", "dataset_dict", ")", "\n", "if", "\"image\"", "not", "in", "ret", ":", "\n", "                ", "image", "=", "read_image", "(", "ret", ".", "pop", "(", "\"file_name\"", ")", ",", "self", ".", "tta_mapper", ".", "image_format", ")", "\n", "image", "=", "torch", ".", "from_numpy", "(", "image", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "# CHW", "\n", "ret", "[", "\"image\"", "]", "=", "image", "\n", "", "if", "\"height\"", "not", "in", "ret", "and", "\"width\"", "not", "in", "ret", ":", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_time_augmentation.rotate_box_inverse": [[185, 208], ["rot_tfm.inverse().apply_box", "rot_tfm.inverse"], "function", ["None"], ["ret", "[", "\"width\"", "]", "=", "image", ".", "shape", "[", "2", "]", "\n", "", "return", "ret", "\n", "\n", "", "return", "[", "self", ".", "_inference_one_image", "(", "_maybe_read_image", "(", "x", ")", ")", "for", "x", "in", "batched_inputs", "]", "\n", "\n", "", "def", "_inference_one_image", "(", "self", ",", "input", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input (dict): one dataset dict with \"image\" field being a CHW tensor\n\n        Returns:\n            dict: one output dict\n        \"\"\"", "\n", "orig_shape", "=", "(", "input", "[", "\"height\"", "]", ",", "input", "[", "\"width\"", "]", ")", "\n", "augmented_inputs", ",", "tfms", "=", "self", ".", "_get_augmented_inputs", "(", "input", ")", "\n", "# Detect boxes from all augmented versions", "\n", "with", "self", ".", "_turn_off_roi_heads", "(", "[", "\"mask_on\"", ",", "\"keypoint_on\"", "]", ")", ":", "\n", "# temporarily disable roi heads", "\n", "            ", "all_boxes", ",", "all_scores", ",", "all_classes", "=", "self", ".", "_get_augmented_boxes", "(", "augmented_inputs", ",", "tfms", ")", "\n", "# merge all detected boxes to obtain final predictions for boxes", "\n", "", "merged_instances", "=", "self", ".", "_merge_detections", "(", "all_boxes", ",", "all_scores", ",", "all_classes", ",", "orig_shape", ")", "\n", "\n", "if", "self", ".", "cfg", ".", "MODEL", ".", "MASK_ON", ":", "\n", "# Use the detected boxes to obtain masks", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrfpn.HRFPN.__init__": [[47, 126], ["detectron2.modeling.backbone.backbone.Backbone.__init__", "isinstance", "len", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "range", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "len", "hrfpn.HRFPN.interp_conv.append", "hrfpn.HRFPN.reduction_pooling_conv.append", "hrfpn.HRFPN._out_features.append", "hrfpn.HRFPN._out_feature_channels.update", "hrfpn.HRFPN._out_feature_strides.update", "hrfpn.HRFPN.fpn_conv.append", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "sum"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update"], ["def", "__init__", "(", "\n", "self", ",", "\n", "bottom_up", ",", "\n", "in_features", ",", "\n", "n_out_features", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "pooling", "=", "\"AVG\"", ",", "\n", "share_conv", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", "HRFPN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "in_channels", ",", "list", ")", "\n", "self", ".", "bottom_up", "=", "bottom_up", "\n", "self", ".", "in_features", "=", "in_features", "\n", "self", ".", "n_out_features", "=", "n_out_features", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "num_ins", "=", "len", "(", "in_channels", ")", "\n", "self", ".", "share_conv", "=", "share_conv", "\n", "\n", "if", "self", ".", "share_conv", ":", "\n", "            ", "self", ".", "fpn_conv", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", "=", "out_channels", ",", "out_channels", "=", "out_channels", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "fpn_conv", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "_", "in", "range", "(", "self", ".", "n_out_features", ")", ":", "\n", "                ", "self", ".", "fpn_conv", ".", "append", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "in_channels", "=", "out_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "\n", ")", "\n", ")", "\n", "\n", "# Custom change: Replaces a simple bilinear interpolation", "\n", "", "", "self", ".", "interp_conv", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "in_features", ")", ")", ":", "\n", "            ", "self", ".", "interp_conv", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "nn", ".", "ConvTranspose2d", "(", "\n", "in_channels", "=", "in_channels", "[", "i", "]", ",", "\n", "out_channels", "=", "in_channels", "[", "i", "]", ",", "\n", "kernel_size", "=", "4", ",", "\n", "stride", "=", "2", "**", "i", ",", "\n", "padding", "=", "0", ",", "\n", "output_padding", "=", "0", ",", "\n", "bias", "=", "False", ",", "\n", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "in_channels", "[", "i", "]", ",", "momentum", "=", "0.1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", ")", "\n", ")", "\n", "\n", "# Custom change: Replaces a couple (reduction conv + pooling) by one conv", "\n", "", "self", ".", "reduction_pooling_conv", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "n_out_features", ")", ":", "\n", "            ", "self", ".", "reduction_pooling_conv", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "sum", "(", "in_channels", ")", ",", "out_channels", ",", "kernel_size", "=", "2", "**", "i", ",", "stride", "=", "2", "**", "i", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "out_channels", ",", "momentum", "=", "0.1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", ")", "\n", ")", "\n", "\n", "", "if", "pooling", "==", "\"MAX\"", ":", "\n", "            ", "self", ".", "pooling", "=", "F", ".", "max_pool2d", "\n", "", "else", ":", "\n", "            ", "self", ".", "pooling", "=", "F", ".", "avg_pool2d", "\n", "\n", "", "self", ".", "_out_features", "=", "[", "]", "\n", "self", ".", "_out_feature_channels", "=", "{", "}", "\n", "self", ".", "_out_feature_strides", "=", "{", "}", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "n_out_features", ")", ":", "\n", "            ", "self", ".", "_out_features", ".", "append", "(", "\"p%d\"", "%", "(", "i", "+", "1", ")", ")", "\n", "self", ".", "_out_feature_channels", ".", "update", "(", "{", "self", ".", "_out_features", "[", "-", "1", "]", ":", "self", ".", "out_channels", "}", ")", "\n", "self", ".", "_out_feature_strides", ".", "update", "(", "{", "self", ".", "_out_features", "[", "-", "1", "]", ":", "2", "**", "(", "i", "+", "2", ")", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrfpn.HRFPN.init_weights": [[128, 133], ["hrfpn.HRFPN.modules", "isinstance", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["None"], ["", "", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ",", "a", "=", "1", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrfpn.HRFPN.forward": [[134, 161], ["hrfpn.HRFPN.bottom_up", "range", "min", "min", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "range", "range", "range", "dict", "len", "len", "len", "outs.append", "outs.append", "len", "len", "len", "len", "zip", "outputs.append", "outputs.append", "hrfpn.HRFPN.fpn_conv"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "", "", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "bottom_up_features", "=", "self", ".", "bottom_up", "(", "inputs", ")", "\n", "assert", "len", "(", "bottom_up_features", ")", "==", "len", "(", "self", ".", "in_features", ")", "\n", "inputs", "=", "[", "bottom_up_features", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", "\n", "\n", "outs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "inputs", ")", ")", ":", "\n", "            ", "outs", ".", "append", "(", "self", ".", "interp_conv", "[", "i", "]", "(", "inputs", "[", "i", "]", ")", ")", "\n", "", "shape_2", "=", "min", "(", "o", ".", "shape", "[", "2", "]", "for", "o", "in", "outs", ")", "\n", "shape_3", "=", "min", "(", "o", ".", "shape", "[", "3", "]", "for", "o", "in", "outs", ")", "\n", "out", "=", "torch", ".", "cat", "(", "[", "o", "[", ":", ",", ":", ",", ":", "shape_2", ",", ":", "shape_3", "]", "for", "o", "in", "outs", "]", ",", "dim", "=", "1", ")", "\n", "outs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "n_out_features", ")", ":", "\n", "            ", "outs", ".", "append", "(", "self", ".", "reduction_pooling_conv", "[", "i", "]", "(", "out", ")", ")", "\n", "", "for", "i", "in", "range", "(", "len", "(", "outs", ")", ")", ":", "# Make shapes consistent", "\n", "            ", "outs", "[", "-", "1", "-", "i", "]", "=", "outs", "[", "-", "1", "-", "i", "]", "[", "\n", ":", ",", ":", ",", ":", "outs", "[", "-", "1", "]", ".", "shape", "[", "2", "]", "*", "2", "**", "i", ",", ":", "outs", "[", "-", "1", "]", ".", "shape", "[", "3", "]", "*", "2", "**", "i", "\n", "]", "\n", "", "outputs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "outs", ")", ")", ":", "\n", "            ", "if", "self", ".", "share_conv", ":", "\n", "                ", "outputs", ".", "append", "(", "self", ".", "fpn_conv", "(", "outs", "[", "i", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "outputs", ".", "append", "(", "self", ".", "fpn_conv", "[", "i", "]", "(", "outs", "[", "i", "]", ")", ")", "\n", "\n", "", "", "assert", "len", "(", "self", ".", "_out_features", ")", "==", "len", "(", "outputs", ")", "\n", "return", "dict", "(", "zip", "(", "self", ".", "_out_features", ",", "outputs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrfpn.build_hrfpn_backbone": [[163, 182], ["detectron2.modeling.backbone.BACKBONE_REGISTRY.register", "len", "hrnet.build_pose_hrnet_backbone", "hrfpn.HRFPN", "range"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.base.BaseConverter.register", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.hrnet.build_pose_hrnet_backbone"], ["", "", "@", "BACKBONE_REGISTRY", ".", "register", "(", ")", "\n", "def", "build_hrfpn_backbone", "(", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "\n", "    ", "in_channels", "=", "cfg", ".", "MODEL", ".", "HRNET", ".", "STAGE4", ".", "NUM_CHANNELS", "\n", "in_features", "=", "[", "\"p%d\"", "%", "(", "i", "+", "1", ")", "for", "i", "in", "range", "(", "cfg", ".", "MODEL", ".", "HRNET", ".", "STAGE4", ".", "NUM_BRANCHES", ")", "]", "\n", "n_out_features", "=", "len", "(", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IN_FEATURES", ")", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "HRNET", ".", "HRFPN", ".", "OUT_CHANNELS", "\n", "hrnet", "=", "build_pose_hrnet_backbone", "(", "cfg", ",", "input_shape", ")", "\n", "hrfpn", "=", "HRFPN", "(", "\n", "hrnet", ",", "\n", "in_features", ",", "\n", "n_out_features", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "pooling", "=", "\"AVG\"", ",", "\n", "share_conv", "=", "False", ",", "\n", ")", "\n", "\n", "return", "hrfpn", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.utils.initialize_module_params": [[6, 12], ["module.named_parameters", "torch.nn.init.constant_", "torch.nn.init.kaiming_normal_"], "function", ["None"], ["def", "initialize_module_params", "(", "module", ":", "nn", ".", "Module", ")", ":", "\n", "    ", "for", "name", ",", "param", "in", "module", ".", "named_parameters", "(", ")", ":", "\n", "        ", "if", "\"bias\"", "in", "name", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "param", ",", "0", ")", "\n", "", "elif", "\"weight\"", "in", "name", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_normal_", "(", "param", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.confidence.DensePoseConfidenceModelConfig.from_cfg": [[61, 72], ["confidence.DensePoseConfidenceModelConfig", "confidence.DensePoseUVConfidenceConfig", "confidence.DensePoseSegmConfidenceConfig", "confidence.DensePoseUVConfidenceType"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "from_cfg", "(", "cfg", ":", "CfgNode", ")", "->", "\"DensePoseConfidenceModelConfig\"", ":", "\n", "        ", "return", "DensePoseConfidenceModelConfig", "(", "\n", "uv_confidence", "=", "DensePoseUVConfidenceConfig", "(", "\n", "enabled", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "UV_CONFIDENCE", ".", "ENABLED", ",", "\n", "epsilon", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "UV_CONFIDENCE", ".", "EPSILON", ",", "\n", "type", "=", "DensePoseUVConfidenceType", "(", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "UV_CONFIDENCE", ".", "TYPE", ")", ",", "\n", ")", ",", "\n", "segm_confidence", "=", "DensePoseSegmConfidenceConfig", "(", "\n", "enabled", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "SEGM_CONFIDENCE", ".", "ENABLED", ",", "\n", "epsilon", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "SEGM_CONFIDENCE", ".", "EPSILON", ",", "\n", ")", ",", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.filter.DensePoseDataFilter.__init__": [[12, 15], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ":", "CfgNode", ")", ":", "\n", "        ", "self", ".", "iou_threshold", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "FG_IOU_THRESHOLD", "\n", "self", ".", "keep_masks", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "COARSE_SEGM_TRAINED_BY_MASKS", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.filter.DensePoseDataFilter.__call__": [[16, 95], ["torch.no_grad", "enumerate", "detectron2.structures.boxes.matched_boxlist_iou", "len", "proposals_filtered.append", "len", "hasattr", "len", "len", "len", "len", "len", "proposals_per_image.has", "len", "hasattr", "enumerate", "proposals_per_image.has", "zip"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.matched_boxlist_iou", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "__call__", "(", "self", ",", "features", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "proposals_with_targets", ":", "List", "[", "Instances", "]", ")", ":", "\n", "        ", "\"\"\"\n        Filters proposals with targets to keep only the ones relevant for\n        DensePose training\n\n        Args:\n            features (list[Tensor]): input data as a list of features,\n                each feature is a tensor. Axis 0 represents the number of\n                images `N` in the input data; axes 1-3 are channels,\n                height, and width, which may vary between features\n                (e.g., if a feature pyramid is used).\n            proposals_with_targets (list[Instances]): length `N` list of\n                `Instances`. The i-th `Instances` contains instances\n                (proposals, GT) for the i-th input image,\n        Returns:\n            list[Tensor]: filtered features\n            list[Instances]: filtered proposals\n        \"\"\"", "\n", "proposals_filtered", "=", "[", "]", "\n", "# TODO: the commented out code was supposed to correctly deal with situations", "\n", "# where no valid DensePose GT is available for certain images. The corresponding", "\n", "# image features were sliced and proposals were filtered. This led to performance", "\n", "# deterioration, both in terms of runtime and in terms of evaluation results.", "\n", "#", "\n", "# feature_mask = torch.ones(", "\n", "#    len(proposals_with_targets),", "\n", "#    dtype=torch.bool,", "\n", "#    device=features[0].device if len(features) > 0 else torch.device(\"cpu\"),", "\n", "# )", "\n", "for", "i", ",", "proposals_per_image", "in", "enumerate", "(", "proposals_with_targets", ")", ":", "\n", "            ", "if", "not", "proposals_per_image", ".", "has", "(", "\"gt_densepose\"", ")", "and", "(", "\n", "not", "proposals_per_image", ".", "has", "(", "\"gt_masks\"", ")", "or", "not", "self", ".", "keep_masks", "\n", ")", ":", "\n", "# feature_mask[i] = 0", "\n", "                ", "continue", "\n", "", "gt_boxes", "=", "proposals_per_image", ".", "gt_boxes", "\n", "est_boxes", "=", "proposals_per_image", ".", "proposal_boxes", "\n", "# apply match threshold for densepose head", "\n", "iou", "=", "matched_boxlist_iou", "(", "gt_boxes", ",", "est_boxes", ")", "\n", "iou_select", "=", "iou", ">", "self", ".", "iou_threshold", "\n", "proposals_per_image", "=", "proposals_per_image", "[", "iou_select", "]", "\n", "\n", "N_gt_boxes", "=", "len", "(", "proposals_per_image", ".", "gt_boxes", ")", "\n", "assert", "N_gt_boxes", "==", "len", "(", "proposals_per_image", ".", "proposal_boxes", ")", ",", "(", "\n", "f\"The number of GT boxes {N_gt_boxes} is different from the \"", "\n", "f\"number of proposal boxes {len(proposals_per_image.proposal_boxes)}\"", "\n", ")", "\n", "# filter out any target without suitable annotation", "\n", "if", "self", ".", "keep_masks", ":", "\n", "                ", "gt_masks", "=", "(", "\n", "proposals_per_image", ".", "gt_masks", "\n", "if", "hasattr", "(", "proposals_per_image", ",", "\"gt_masks\"", ")", "\n", "else", "[", "None", "]", "*", "N_gt_boxes", "\n", ")", "\n", "", "else", ":", "\n", "                ", "gt_masks", "=", "[", "None", "]", "*", "N_gt_boxes", "\n", "", "gt_densepose", "=", "(", "\n", "proposals_per_image", ".", "gt_densepose", "\n", "if", "hasattr", "(", "proposals_per_image", ",", "\"gt_densepose\"", ")", "\n", "else", "[", "None", "]", "*", "N_gt_boxes", "\n", ")", "\n", "assert", "len", "(", "gt_masks", ")", "==", "N_gt_boxes", "\n", "assert", "len", "(", "gt_densepose", ")", "==", "N_gt_boxes", "\n", "selected_indices", "=", "[", "\n", "i", "\n", "for", "i", ",", "(", "dp_target", ",", "mask_target", ")", "in", "enumerate", "(", "zip", "(", "gt_densepose", ",", "gt_masks", ")", ")", "\n", "if", "(", "dp_target", "is", "not", "None", ")", "or", "(", "mask_target", "is", "not", "None", ")", "\n", "]", "\n", "# if not len(selected_indices):", "\n", "#     feature_mask[i] = 0", "\n", "#     continue", "\n", "if", "len", "(", "selected_indices", ")", "!=", "N_gt_boxes", ":", "\n", "                ", "proposals_per_image", "=", "proposals_per_image", "[", "selected_indices", "]", "\n", "", "assert", "len", "(", "proposals_per_image", ".", "gt_boxes", ")", "==", "len", "(", "proposals_per_image", ".", "proposal_boxes", ")", "\n", "proposals_filtered", ".", "append", "(", "proposals_per_image", ")", "\n", "# features_filtered = [feature[feature_mask] for feature in features]", "\n", "# return features_filtered, proposals_filtered", "\n", "", "return", "features", ",", "proposals_filtered", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_roi_pooler.TestROIPooler._rand_boxes": [[14, 26], ["torch.rand", "torch.zeros", "torch.min", "torch.min", "torch.max", "torch.max"], "methods", ["None"], ["    ", "def", "_rand_boxes", "(", "self", ",", "num_boxes", ",", "x_max", ",", "y_max", ")", ":", "\n", "        ", "coords", "=", "torch", ".", "rand", "(", "num_boxes", ",", "4", ")", "\n", "coords", "[", ":", ",", "0", "]", "*=", "x_max", "\n", "coords", "[", ":", ",", "1", "]", "*=", "y_max", "\n", "coords", "[", ":", ",", "2", "]", "*=", "x_max", "\n", "coords", "[", ":", ",", "3", "]", "*=", "y_max", "\n", "boxes", "=", "torch", ".", "zeros", "(", "num_boxes", ",", "4", ")", "\n", "boxes", "[", ":", ",", "0", "]", "=", "torch", ".", "min", "(", "coords", "[", ":", ",", "0", "]", ",", "coords", "[", ":", ",", "2", "]", ")", "\n", "boxes", "[", ":", ",", "1", "]", "=", "torch", ".", "min", "(", "coords", "[", ":", ",", "1", "]", ",", "coords", "[", ":", ",", "3", "]", ")", "\n", "boxes", "[", ":", ",", "2", "]", "=", "torch", ".", "max", "(", "coords", "[", ":", ",", "0", "]", ",", "coords", "[", ":", ",", "2", "]", ")", "\n", "boxes", "[", ":", ",", "3", "]", "=", "torch", ".", "max", "(", "coords", "[", ":", ",", "1", "]", ",", "coords", "[", ":", ",", "3", "]", ")", "\n", "return", "boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_roi_pooler.TestROIPooler._test_roialignv2_roialignrotated_match": [[27, 76], ["range", "detectron2.modeling.poolers.ROIPooler", "detectron2.modeling.poolers.ROIPooler.", "detectron2.modeling.poolers.ROIPooler", "detectron2.modeling.poolers.ROIPooler.", "test_roi_pooler.TestROIPooler.assertTrue", "feature.to", "test_roi_pooler.TestROIPooler._rand_boxes", "torch.zeros", "rois.append", "rois_rotated.append", "torch.allclose", "detectron2.structures.Boxes().to", "detectron2.structures.RotatedBoxes().to", "torch.rand", "detectron2.structures.Boxes", "detectron2.structures.RotatedBoxes"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_roi_pooler.TestROIPooler._rand_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "_test_roialignv2_roialignrotated_match", "(", "self", ",", "device", ")", ":", "\n", "        ", "pooler_resolution", "=", "14", "\n", "canonical_level", "=", "4", "\n", "canonical_scale_factor", "=", "2", "**", "canonical_level", "\n", "pooler_scales", "=", "(", "1.0", "/", "canonical_scale_factor", ",", ")", "\n", "sampling_ratio", "=", "0", "\n", "\n", "N", ",", "C", ",", "H", ",", "W", "=", "2", ",", "4", ",", "10", ",", "8", "\n", "N_rois", "=", "10", "\n", "std", "=", "11", "\n", "mean", "=", "0", "\n", "feature", "=", "(", "torch", ".", "rand", "(", "N", ",", "C", ",", "H", ",", "W", ")", "-", "0.5", ")", "*", "2", "*", "std", "+", "mean", "\n", "\n", "features", "=", "[", "feature", ".", "to", "(", "device", ")", "]", "\n", "\n", "rois", "=", "[", "]", "\n", "rois_rotated", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "N", ")", ":", "\n", "            ", "boxes", "=", "self", ".", "_rand_boxes", "(", "\n", "num_boxes", "=", "N_rois", ",", "x_max", "=", "W", "*", "canonical_scale_factor", ",", "y_max", "=", "H", "*", "canonical_scale_factor", "\n", ")", "\n", "\n", "rotated_boxes", "=", "torch", ".", "zeros", "(", "N_rois", ",", "5", ")", "\n", "rotated_boxes", "[", ":", ",", "0", "]", "=", "(", "boxes", "[", ":", ",", "0", "]", "+", "boxes", "[", ":", ",", "2", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "1", "]", "=", "(", "boxes", "[", ":", ",", "1", "]", "+", "boxes", "[", ":", ",", "3", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "2", "]", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "\n", "rotated_boxes", "[", ":", ",", "3", "]", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "\n", "rois", ".", "append", "(", "Boxes", "(", "boxes", ")", ".", "to", "(", "device", ")", ")", "\n", "rois_rotated", ".", "append", "(", "RotatedBoxes", "(", "rotated_boxes", ")", ".", "to", "(", "device", ")", ")", "\n", "\n", "", "roialignv2_pooler", "=", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "\"ROIAlignV2\"", ",", "\n", ")", "\n", "\n", "roialignv2_out", "=", "roialignv2_pooler", "(", "features", ",", "rois", ")", "\n", "\n", "roialignrotated_pooler", "=", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "\"ROIAlignRotated\"", ",", "\n", ")", "\n", "\n", "roialignrotated_out", "=", "roialignrotated_pooler", "(", "features", ",", "rois_rotated", ")", "\n", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "roialignv2_out", ",", "roialignrotated_out", ",", "atol", "=", "1e-4", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_roi_pooler.TestROIPooler.test_roialignv2_roialignrotated_match_cpu": [[77, 79], ["test_roi_pooler.TestROIPooler._test_roialignv2_roialignrotated_match"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_roi_pooler.TestROIPooler._test_roialignv2_roialignrotated_match"], ["", "def", "test_roialignv2_roialignrotated_match_cpu", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_roialignv2_roialignrotated_match", "(", "device", "=", "\"cpu\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_roi_pooler.TestROIPooler.test_roialignv2_roialignrotated_match_cuda": [[80, 83], ["unittest.skipIf", "test_roi_pooler.TestROIPooler._test_roialignv2_roialignrotated_match", "torch.cuda.is_available"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_roi_pooler.TestROIPooler._test_roialignv2_roialignrotated_match"], ["", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_roialignv2_roialignrotated_match_cuda", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_roialignv2_roialignrotated_match", "(", "device", "=", "\"cuda\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_roi_pooler.TestROIPooler._test_scriptability": [[84, 117], ["range", "detectron2.modeling.poolers.ROIPooler", "detectron2.modeling.poolers.ROIPooler.", "test_roi_pooler.TestROIPooler.assertTrue", "feature.to", "test_roi_pooler.TestROIPooler._rand_boxes", "rois.append", "torch.jit.script", "torch.equal", "detectron2.structures.Boxes().to", "torch.rand", "detectron2.structures.Boxes"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_roi_pooler.TestROIPooler._rand_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "_test_scriptability", "(", "self", ",", "device", ")", ":", "\n", "        ", "pooler_resolution", "=", "14", "\n", "canonical_level", "=", "4", "\n", "canonical_scale_factor", "=", "2", "**", "canonical_level", "\n", "pooler_scales", "=", "(", "1.0", "/", "canonical_scale_factor", ",", ")", "\n", "sampling_ratio", "=", "0", "\n", "\n", "N", ",", "C", ",", "H", ",", "W", "=", "2", ",", "4", ",", "10", ",", "8", "\n", "N_rois", "=", "10", "\n", "std", "=", "11", "\n", "mean", "=", "0", "\n", "feature", "=", "(", "torch", ".", "rand", "(", "N", ",", "C", ",", "H", ",", "W", ")", "-", "0.5", ")", "*", "2", "*", "std", "+", "mean", "\n", "\n", "features", "=", "[", "feature", ".", "to", "(", "device", ")", "]", "\n", "\n", "rois", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "N", ")", ":", "\n", "            ", "boxes", "=", "self", ".", "_rand_boxes", "(", "\n", "num_boxes", "=", "N_rois", ",", "x_max", "=", "W", "*", "canonical_scale_factor", ",", "y_max", "=", "H", "*", "canonical_scale_factor", "\n", ")", "\n", "\n", "rois", ".", "append", "(", "Boxes", "(", "boxes", ")", ".", "to", "(", "device", ")", ")", "\n", "\n", "", "roialignv2_pooler", "=", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "\"ROIAlignV2\"", ",", "\n", ")", "\n", "\n", "roialignv2_out", "=", "roialignv2_pooler", "(", "features", ",", "rois", ")", "\n", "scripted_roialignv2_out", "=", "torch", ".", "jit", ".", "script", "(", "roialignv2_pooler", ")", "(", "features", ",", "rois", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "equal", "(", "roialignv2_out", ",", "scripted_roialignv2_out", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_roi_pooler.TestROIPooler.test_scriptability_cpu": [[118, 121], ["unittest.skipIf", "test_roi_pooler.TestROIPooler._test_scriptability"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_roi_pooler.TestROIPooler._test_scriptability"], ["", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "7", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_scriptability_cpu", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_scriptability", "(", "device", "=", "\"cpu\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_roi_pooler.TestROIPooler.test_scriptability_gpu": [[122, 126], ["unittest.skipIf", "unittest.skipIf", "test_roi_pooler.TestROIPooler._test_scriptability", "torch.cuda.is_available"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_roi_pooler.TestROIPooler._test_scriptability"], ["", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "7", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_scriptability_gpu", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_scriptability", "(", "device", "=", "\"cuda\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_roi_pooler.TestROIPooler.test_no_images": [[127, 136], ["detectron2.modeling.poolers.ROIPooler", "detectron2.modeling.poolers.ROIPooler.forward", "test_roi_pooler.TestROIPooler.assertEqual", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.forward"], ["", "def", "test_no_images", "(", "self", ")", ":", "\n", "        ", "N", ",", "C", ",", "H", ",", "W", "=", "0", ",", "32", ",", "32", ",", "32", "\n", "feature", "=", "torch", ".", "rand", "(", "N", ",", "C", ",", "H", ",", "W", ")", "-", "0.5", "\n", "features", "=", "[", "feature", "]", "\n", "pooler", "=", "ROIPooler", "(", "\n", "output_size", "=", "14", ",", "scales", "=", "(", "1.0", ",", ")", ",", "sampling_ratio", "=", "0.0", ",", "pooler_type", "=", "\"ROIAlignV2\"", "\n", ")", "\n", "output", "=", "pooler", ".", "forward", "(", "features", ",", "[", "]", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "shape", ",", "(", "0", ",", "C", ",", "14", ",", "14", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_matcher.TestMatcher.test_scriptability": [[13, 42], ["unittest.skipIf", "detectron2.config.get_cfg", "detectron2.modeling.matcher.Matcher", "torch.tensor", "torch.tensor", "torch.tensor", "detectron2.modeling.matcher.Matcher.", "test_matcher.TestMatcher.assertTrue", "test_matcher.TestMatcher.assertTrue", "scripted_anchor_matcher", "test_matcher.TestMatcher.assertTrue", "test_matcher.TestMatcher.assertTrue", "torch.allclose", "torch.allclose", "detectron2.modeling.matcher.Matcher", "torch.jit.script", "torch.allclose", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg"], ["    ", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "6", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_scriptability", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "anchor_matcher", "=", "Matcher", "(", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "IOU_THRESHOLDS", ",", "cfg", ".", "MODEL", ".", "RPN", ".", "IOU_LABELS", ",", "allow_low_quality_matches", "=", "True", "\n", ")", "\n", "match_quality_matrix", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "0.15", ",", "0.45", ",", "0.2", ",", "0.6", "]", ",", "[", "0.3", ",", "0.65", ",", "0.05", ",", "0.1", "]", ",", "[", "0.05", ",", "0.4", ",", "0.25", ",", "0.4", "]", "]", "\n", ")", "\n", "expected_matches", "=", "torch", ".", "tensor", "(", "[", "1", ",", "1", ",", "2", ",", "0", "]", ")", "\n", "expected_match_labels", "=", "torch", ".", "tensor", "(", "[", "-", "1", ",", "1", ",", "0", ",", "1", "]", ",", "dtype", "=", "torch", ".", "int8", ")", "\n", "\n", "matches", ",", "match_labels", "=", "anchor_matcher", "(", "match_quality_matrix", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "matches", ",", "expected_matches", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "match_labels", ",", "expected_match_labels", ")", ")", "\n", "\n", "# nonzero_tuple must be import explicitly to let jit know what it is.", "\n", "# https://github.com/pytorch/pytorch/issues/38964", "\n", "from", "detectron2", ".", "layers", "import", "nonzero_tuple", "# noqa F401", "\n", "\n", "def", "f", "(", "thresholds", ":", "List", "[", "float", "]", ",", "labels", ":", "List", "[", "int", "]", ")", ":", "\n", "            ", "return", "Matcher", "(", "thresholds", ",", "labels", ",", "allow_low_quality_matches", "=", "True", ")", "\n", "\n", "", "scripted_anchor_matcher", "=", "torch", ".", "jit", ".", "script", "(", "f", ")", "(", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "IOU_THRESHOLDS", ",", "cfg", ".", "MODEL", ".", "RPN", ".", "IOU_LABELS", "\n", ")", "\n", "matches", ",", "match_labels", "=", "scripted_anchor_matcher", "(", "match_quality_matrix", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "matches", ",", "expected_matches", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "match_labels", ",", "expected_match_labels", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_fast_rcnn.FastRCNNTest.test_fast_rcnn": [[17, 46], ["torch.manual_seed", "detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers", "torch.rand", "detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers.", "torch.tensor", "torch.tensor", "detectron2.structures.Instances", "detectron2.structures.Boxes", "detectron2.structures.Boxes", "torch.tensor", "expected_losses.keys", "detectron2.layers.ShapeSpec", "detectron2.utils.events.EventStorage", "detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers.losses", "torch.tensor", "torch.tensor", "torch.allclose", "detectron2.modeling.box_regression.Box2BoxTransform"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3Head.losses"], ["    ", "def", "test_fast_rcnn", "(", "self", ")", ":", "\n", "        ", "torch", ".", "manual_seed", "(", "132", ")", "\n", "\n", "box_head_output_size", "=", "8", "\n", "\n", "box_predictor", "=", "FastRCNNOutputLayers", "(", "\n", "ShapeSpec", "(", "channels", "=", "box_head_output_size", ")", ",", "\n", "box2box_transform", "=", "Box2BoxTransform", "(", "weights", "=", "(", "10", ",", "10", ",", "5", ",", "5", ")", ")", ",", "\n", "num_classes", "=", "5", ",", "\n", ")", "\n", "feature_pooled", "=", "torch", ".", "rand", "(", "2", ",", "box_head_output_size", ")", "\n", "predictions", "=", "box_predictor", "(", "feature_pooled", ")", "\n", "\n", "proposal_boxes", "=", "torch", ".", "tensor", "(", "[", "[", "0.8", ",", "1.1", ",", "3.2", ",", "2.8", "]", ",", "[", "2.3", ",", "2.5", ",", "7", ",", "8", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "gt_boxes", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "3", ",", "3", "]", ",", "[", "2", ",", "2", ",", "6", ",", "6", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "proposal", "=", "Instances", "(", "(", "10", ",", "10", ")", ")", "\n", "proposal", ".", "proposal_boxes", "=", "Boxes", "(", "proposal_boxes", ")", "\n", "proposal", ".", "gt_boxes", "=", "Boxes", "(", "gt_boxes", ")", "\n", "proposal", ".", "gt_classes", "=", "torch", ".", "tensor", "(", "[", "1", ",", "2", "]", ")", "\n", "\n", "with", "EventStorage", "(", ")", ":", "# capture events in a new storage to discard them", "\n", "            ", "losses", "=", "box_predictor", ".", "losses", "(", "predictions", ",", "[", "proposal", "]", ")", "\n", "\n", "", "expected_losses", "=", "{", "\n", "\"loss_cls\"", ":", "torch", ".", "tensor", "(", "1.7951188087", ")", ",", "\n", "\"loss_box_reg\"", ":", "torch", ".", "tensor", "(", "4.0357131958", ")", ",", "\n", "}", "\n", "for", "name", "in", "expected_losses", ".", "keys", "(", ")", ":", "\n", "            ", "assert", "torch", ".", "allclose", "(", "losses", "[", "name", "]", ",", "expected_losses", "[", "name", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_fast_rcnn.FastRCNNTest.test_fast_rcnn_empty_batch": [[47, 65], ["detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers().to", "torch.randn", "torch.randn", "detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers().to.losses", "FastRCNNOutputLayers().to.losses.values", "sum().backward", "test_fast_rcnn.FastRCNNTest.assertTrue", "test_fast_rcnn.FastRCNNTest.assertTrue", "detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers().to.inference", "test_fast_rcnn.FastRCNNTest.assertEqual", "test_fast_rcnn.FastRCNNTest.assertTrue", "len", "detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers", "torch.allclose", "sum", "detectron2.layers.ShapeSpec", "torch.zeros_like", "FastRCNNOutputLayers().to.losses.values", "detectron2.modeling.box_regression.Box2BoxTransform"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3Head.losses", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.swap_align2nat._SwapAlign2Nat.backward", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.inference"], ["", "", "def", "test_fast_rcnn_empty_batch", "(", "self", ",", "device", "=", "\"cpu\"", ")", ":", "\n", "        ", "box_predictor", "=", "FastRCNNOutputLayers", "(", "\n", "ShapeSpec", "(", "channels", "=", "10", ")", ",", "\n", "box2box_transform", "=", "Box2BoxTransform", "(", "weights", "=", "(", "10", ",", "10", ",", "5", ",", "5", ")", ")", ",", "\n", "num_classes", "=", "8", ",", "\n", ")", ".", "to", "(", "device", "=", "device", ")", "\n", "\n", "logits", "=", "torch", ".", "randn", "(", "0", ",", "100", ",", "requires_grad", "=", "True", ",", "device", "=", "device", ")", "\n", "deltas", "=", "torch", ".", "randn", "(", "0", ",", "4", ",", "requires_grad", "=", "True", ",", "device", "=", "device", ")", "\n", "losses", "=", "box_predictor", ".", "losses", "(", "[", "logits", ",", "deltas", "]", ",", "[", "]", ")", "\n", "for", "value", "in", "losses", ".", "values", "(", ")", ":", "\n", "            ", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "value", ",", "torch", ".", "zeros_like", "(", "value", ")", ")", ")", "\n", "", "sum", "(", "losses", ".", "values", "(", ")", ")", ".", "backward", "(", ")", "\n", "self", ".", "assertTrue", "(", "logits", ".", "grad", "is", "not", "None", ")", "\n", "self", ".", "assertTrue", "(", "deltas", ".", "grad", "is", "not", "None", ")", "\n", "\n", "predictions", ",", "_", "=", "box_predictor", ".", "inference", "(", "[", "logits", ",", "deltas", "]", ",", "[", "]", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "predictions", ")", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_fast_rcnn.FastRCNNTest.test_fast_rcnn_empty_batch_cuda": [[66, 69], ["unittest.skipIf", "test_fast_rcnn.FastRCNNTest.test_fast_rcnn_empty_batch", "torch.cuda.is_available", "torch.device"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_fast_rcnn.FastRCNNTest.test_fast_rcnn_empty_batch", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device"], ["", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_fast_rcnn_empty_batch_cuda", "(", "self", ")", ":", "\n", "        ", "self", ".", "test_fast_rcnn_empty_batch", "(", "device", "=", "torch", ".", "device", "(", "\"cuda\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_fast_rcnn.FastRCNNTest.test_fast_rcnn_rotated": [[70, 103], ["torch.manual_seed", "detectron2.modeling.roi_heads.rotated_fast_rcnn.RotatedFastRCNNOutputLayers", "torch.rand", "detectron2.modeling.roi_heads.rotated_fast_rcnn.RotatedFastRCNNOutputLayers.", "torch.tensor", "torch.tensor", "detectron2.structures.Instances", "detectron2.structures.RotatedBoxes", "detectron2.structures.RotatedBoxes", "torch.tensor", "expected_losses.keys", "detectron2.layers.ShapeSpec", "detectron2.utils.events.EventStorage", "detectron2.modeling.roi_heads.rotated_fast_rcnn.RotatedFastRCNNOutputLayers.losses", "torch.tensor", "torch.tensor", "torch.allclose", "detectron2.modeling.box_regression.Box2BoxTransformRotated"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3Head.losses"], ["", "def", "test_fast_rcnn_rotated", "(", "self", ")", ":", "\n", "        ", "torch", ".", "manual_seed", "(", "132", ")", "\n", "box_head_output_size", "=", "8", "\n", "\n", "box_predictor", "=", "RotatedFastRCNNOutputLayers", "(", "\n", "ShapeSpec", "(", "channels", "=", "box_head_output_size", ")", ",", "\n", "box2box_transform", "=", "Box2BoxTransformRotated", "(", "weights", "=", "(", "10", ",", "10", ",", "5", ",", "5", ",", "1", ")", ")", ",", "\n", "num_classes", "=", "5", ",", "\n", ")", "\n", "feature_pooled", "=", "torch", ".", "rand", "(", "2", ",", "box_head_output_size", ")", "\n", "predictions", "=", "box_predictor", "(", "feature_pooled", ")", "\n", "proposal_boxes", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "2", ",", "1.95", ",", "2.4", ",", "1.7", ",", "0", "]", ",", "[", "4.65", ",", "5.25", ",", "4.7", ",", "5.5", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", "\n", ")", "\n", "gt_boxes", "=", "torch", ".", "tensor", "(", "[", "[", "2", ",", "2", ",", "2", ",", "2", ",", "0", "]", ",", "[", "4", ",", "4", ",", "4", ",", "4", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "proposal", "=", "Instances", "(", "(", "10", ",", "10", ")", ")", "\n", "proposal", ".", "proposal_boxes", "=", "RotatedBoxes", "(", "proposal_boxes", ")", "\n", "proposal", ".", "gt_boxes", "=", "RotatedBoxes", "(", "gt_boxes", ")", "\n", "proposal", ".", "gt_classes", "=", "torch", ".", "tensor", "(", "[", "1", ",", "2", "]", ")", "\n", "\n", "with", "EventStorage", "(", ")", ":", "# capture events in a new storage to discard them", "\n", "            ", "losses", "=", "box_predictor", ".", "losses", "(", "predictions", ",", "[", "proposal", "]", ")", "\n", "\n", "# Note: the expected losses are slightly different even if", "\n", "# the boxes are essentially the same as in the FastRCNNOutput test, because", "\n", "# bbox_pred in FastRCNNOutputLayers have different Linear layers/initialization", "\n", "# between the two cases.", "\n", "", "expected_losses", "=", "{", "\n", "\"loss_cls\"", ":", "torch", ".", "tensor", "(", "1.7920907736", ")", ",", "\n", "\"loss_box_reg\"", ":", "torch", ".", "tensor", "(", "4.0410838127", ")", ",", "\n", "}", "\n", "for", "name", "in", "expected_losses", ".", "keys", "(", ")", ":", "\n", "            ", "assert", "torch", ".", "allclose", "(", "losses", "[", "name", "]", ",", "expected_losses", "[", "name", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_roi_heads.ROIHeadsTest.test_roi_heads": [[32, 84], ["torch.manual_seed", "detectron2.config.get_cfg", "torch.rand", "detectron2.structures.ImageList", "torch.tensor", "detectron2.structures.Instances", "detectron2.structures.Boxes", "torch.tensor", "detectron2.structures.BitMasks", "torch.tensor", "detectron2.structures.Instances", "detectron2.structures.Boxes", "torch.tensor", "detectron2.structures.BitMasks", "detectron2.modeling.proposal_generator.build.build_proposal_generator", "detectron2.modeling.roi_heads.StandardROIHeads", "detector_losses.update", "all", "test_roi_heads.ROIHeadsTest.assertTrue", "torch.rand", "detectron2.layers.ShapeSpec", "detectron2.utils.events.EventStorage", "detectron2.modeling.proposal_generator.build.build_proposal_generator.", "detectron2.modeling.roi_heads.StandardROIHeads.", "torch.rand", "torch.rand", "torch.allclose", "torch.tensor", "detector_losses.keys", "v.item", "expected_losses.get", "detector_losses.items"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.build.build_proposal_generator", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["    ", "def", "test_roi_heads", "(", "self", ")", ":", "\n", "        ", "torch", ".", "manual_seed", "(", "121", ")", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NAME", "=", "\"FastRCNNConvFCHead\"", "\n", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NUM_FC", "=", "2", "\n", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_TYPE", "=", "\"ROIAlignV2\"", "\n", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "BBOX_REG_WEIGHTS", "=", "(", "10", ",", "10", ",", "5", ",", "5", ")", "\n", "cfg", ".", "MODEL", ".", "MASK_ON", "=", "True", "\n", "num_images", "=", "2", "\n", "images_tensor", "=", "torch", ".", "rand", "(", "num_images", ",", "20", ",", "30", ")", "\n", "image_sizes", "=", "[", "(", "10", ",", "10", ")", ",", "(", "20", ",", "30", ")", "]", "\n", "images", "=", "ImageList", "(", "images_tensor", ",", "image_sizes", ")", "\n", "num_channels", "=", "1024", "\n", "features", "=", "{", "\"res4\"", ":", "torch", ".", "rand", "(", "num_images", ",", "num_channels", ",", "1", ",", "2", ")", "}", "\n", "feature_shape", "=", "{", "\"res4\"", ":", "ShapeSpec", "(", "channels", "=", "num_channels", ",", "stride", "=", "16", ")", "}", "\n", "\n", "image_shape", "=", "(", "15", ",", "15", ")", "\n", "gt_boxes0", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "3", ",", "3", "]", ",", "[", "2", ",", "2", ",", "6", ",", "6", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "gt_instance0", "=", "Instances", "(", "image_shape", ")", "\n", "gt_instance0", ".", "gt_boxes", "=", "Boxes", "(", "gt_boxes0", ")", "\n", "gt_instance0", ".", "gt_classes", "=", "torch", ".", "tensor", "(", "[", "2", ",", "1", "]", ")", "\n", "gt_instance0", ".", "gt_masks", "=", "BitMasks", "(", "torch", ".", "rand", "(", "(", "2", ",", ")", "+", "image_shape", ")", ">", "0.5", ")", "\n", "gt_boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "5", ",", "2", ",", "8", "]", ",", "[", "7", ",", "3", ",", "10", ",", "5", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "gt_instance1", "=", "Instances", "(", "image_shape", ")", "\n", "gt_instance1", ".", "gt_boxes", "=", "Boxes", "(", "gt_boxes1", ")", "\n", "gt_instance1", ".", "gt_classes", "=", "torch", ".", "tensor", "(", "[", "1", ",", "2", "]", ")", "\n", "gt_instance1", ".", "gt_masks", "=", "BitMasks", "(", "torch", ".", "rand", "(", "(", "2", ",", ")", "+", "image_shape", ")", ">", "0.5", ")", "\n", "gt_instances", "=", "[", "gt_instance0", ",", "gt_instance1", "]", "\n", "\n", "proposal_generator", "=", "build_proposal_generator", "(", "cfg", ",", "feature_shape", ")", "\n", "roi_heads", "=", "StandardROIHeads", "(", "cfg", ",", "feature_shape", ")", "\n", "\n", "with", "EventStorage", "(", ")", ":", "# capture events in a new storage to discard them", "\n", "            ", "proposals", ",", "proposal_losses", "=", "proposal_generator", "(", "images", ",", "features", ",", "gt_instances", ")", "\n", "_", ",", "detector_losses", "=", "roi_heads", "(", "images", ",", "features", ",", "proposals", ",", "gt_instances", ")", "\n", "\n", "", "detector_losses", ".", "update", "(", "proposal_losses", ")", "\n", "expected_losses", "=", "{", "\n", "\"loss_cls\"", ":", "4.5253729820251465", ",", "\n", "\"loss_box_reg\"", ":", "0.009785720147192478", ",", "\n", "\"loss_mask\"", ":", "0.693184494972229", ",", "\n", "\"loss_rpn_cls\"", ":", "0.08186662942171097", ",", "\n", "\"loss_rpn_loc\"", ":", "0.1104838103055954", ",", "\n", "}", "\n", "succ", "=", "all", "(", "\n", "torch", ".", "allclose", "(", "detector_losses", "[", "name", "]", ",", "torch", ".", "tensor", "(", "expected_losses", ".", "get", "(", "name", ",", "0.0", ")", ")", ")", "\n", "for", "name", "in", "detector_losses", ".", "keys", "(", ")", "\n", ")", "\n", "self", ".", "assertTrue", "(", "\n", "succ", ",", "\n", "\"Losses has changed! New losses: {}\"", ".", "format", "(", "\n", "{", "k", ":", "v", ".", "item", "(", ")", "for", "k", ",", "v", "in", "detector_losses", ".", "items", "(", ")", "}", "\n", ")", ",", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_roi_heads.ROIHeadsTest.test_rroi_heads": [[87, 140], ["torch.manual_seed", "detectron2.config.get_cfg", "torch.rand", "detectron2.structures.ImageList", "torch.tensor", "detectron2.structures.Instances", "detectron2.structures.RotatedBoxes", "torch.tensor", "torch.tensor", "detectron2.structures.Instances", "detectron2.structures.RotatedBoxes", "torch.tensor", "detectron2.modeling.proposal_generator.build.build_proposal_generator", "detectron2.modeling.roi_heads.build_roi_heads", "detector_losses.update", "all", "test_roi_heads.ROIHeadsTest.assertTrue", "torch.rand", "detectron2.layers.ShapeSpec", "detectron2.utils.events.EventStorage", "detectron2.modeling.proposal_generator.build.build_proposal_generator.", "detectron2.modeling.roi_heads.build_roi_heads.", "torch.allclose", "torch.tensor", "detector_losses.keys", "v.item", "expected_losses.get", "detector_losses.items"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.build.build_proposal_generator", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.build_roi_heads", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "def", "test_rroi_heads", "(", "self", ")", ":", "\n", "        ", "torch", ".", "manual_seed", "(", "121", ")", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "MODEL", ".", "PROPOSAL_GENERATOR", ".", "NAME", "=", "\"RRPN\"", "\n", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "NAME", "=", "\"RotatedAnchorGenerator\"", "\n", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NAME", "=", "\"RROIHeads\"", "\n", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NAME", "=", "\"FastRCNNConvFCHead\"", "\n", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NUM_FC", "=", "2", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "BBOX_REG_WEIGHTS", "=", "(", "1", ",", "1", ",", "1", ",", "1", ",", "1", ")", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "HEAD_NAME", "=", "\"StandardRPNHead\"", "\n", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_TYPE", "=", "\"ROIAlignRotated\"", "\n", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "BBOX_REG_WEIGHTS", "=", "(", "10", ",", "10", ",", "5", ",", "5", ",", "1", ")", "\n", "num_images", "=", "2", "\n", "images_tensor", "=", "torch", ".", "rand", "(", "num_images", ",", "20", ",", "30", ")", "\n", "image_sizes", "=", "[", "(", "10", ",", "10", ")", ",", "(", "20", ",", "30", ")", "]", "\n", "images", "=", "ImageList", "(", "images_tensor", ",", "image_sizes", ")", "\n", "num_channels", "=", "1024", "\n", "features", "=", "{", "\"res4\"", ":", "torch", ".", "rand", "(", "num_images", ",", "num_channels", ",", "1", ",", "2", ")", "}", "\n", "feature_shape", "=", "{", "\"res4\"", ":", "ShapeSpec", "(", "channels", "=", "num_channels", ",", "stride", "=", "16", ")", "}", "\n", "\n", "image_shape", "=", "(", "15", ",", "15", ")", "\n", "gt_boxes0", "=", "torch", ".", "tensor", "(", "[", "[", "2", ",", "2", ",", "2", ",", "2", ",", "30", "]", ",", "[", "4", ",", "4", ",", "4", ",", "4", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "gt_instance0", "=", "Instances", "(", "image_shape", ")", "\n", "gt_instance0", ".", "gt_boxes", "=", "RotatedBoxes", "(", "gt_boxes0", ")", "\n", "gt_instance0", ".", "gt_classes", "=", "torch", ".", "tensor", "(", "[", "2", ",", "1", "]", ")", "\n", "gt_boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "1.5", ",", "5.5", ",", "1", ",", "3", ",", "0", "]", ",", "[", "8.5", ",", "4", ",", "3", ",", "2", ",", "-", "50", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "gt_instance1", "=", "Instances", "(", "image_shape", ")", "\n", "gt_instance1", ".", "gt_boxes", "=", "RotatedBoxes", "(", "gt_boxes1", ")", "\n", "gt_instance1", ".", "gt_classes", "=", "torch", ".", "tensor", "(", "[", "1", ",", "2", "]", ")", "\n", "gt_instances", "=", "[", "gt_instance0", ",", "gt_instance1", "]", "\n", "\n", "proposal_generator", "=", "build_proposal_generator", "(", "cfg", ",", "feature_shape", ")", "\n", "roi_heads", "=", "build_roi_heads", "(", "cfg", ",", "feature_shape", ")", "\n", "\n", "with", "EventStorage", "(", ")", ":", "# capture events in a new storage to discard them", "\n", "            ", "proposals", ",", "proposal_losses", "=", "proposal_generator", "(", "images", ",", "features", ",", "gt_instances", ")", "\n", "_", ",", "detector_losses", "=", "roi_heads", "(", "images", ",", "features", ",", "proposals", ",", "gt_instances", ")", "\n", "\n", "", "detector_losses", ".", "update", "(", "proposal_losses", ")", "\n", "expected_losses", "=", "{", "\n", "\"loss_cls\"", ":", "4.365657806396484", ",", "\n", "\"loss_box_reg\"", ":", "0.0015851043863222003", ",", "\n", "\"loss_rpn_cls\"", ":", "0.2427729219198227", ",", "\n", "\"loss_rpn_loc\"", ":", "0.3646621108055115", ",", "\n", "}", "\n", "succ", "=", "all", "(", "\n", "torch", ".", "allclose", "(", "detector_losses", "[", "name", "]", ",", "torch", ".", "tensor", "(", "expected_losses", ".", "get", "(", "name", ",", "0.0", ")", ")", ")", "\n", "for", "name", "in", "detector_losses", ".", "keys", "(", ")", "\n", ")", "\n", "self", ".", "assertTrue", "(", "\n", "succ", ",", "\n", "\"Losses has changed! New losses: {}\"", ".", "format", "(", "\n", "{", "k", ":", "v", ".", "item", "(", ")", "for", "k", ",", "v", "in", "detector_losses", ".", "items", "(", ")", "}", "\n", ")", ",", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_roi_heads.ROIHeadsTest.test_box_head_scriptability": [[143, 156], ["unittest.skipIf", "detectron2.layers.ShapeSpec", "torch.randn", "detectron2.modeling.roi_heads.FastRCNNConvFCHead().eval", "torch.jit.script", "detectron2.modeling.roi_heads.FastRCNNConvFCHead().eval.", "torch.jit.script.", "test_roi_heads.ROIHeadsTest.assertTrue", "torch.equal", "detectron2.modeling.roi_heads.FastRCNNConvFCHead"], "methods", ["None"], ["", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "7", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_box_head_scriptability", "(", "self", ")", ":", "\n", "        ", "input_shape", "=", "ShapeSpec", "(", "channels", "=", "1024", ",", "height", "=", "14", ",", "width", "=", "14", ")", "\n", "box_features", "=", "torch", ".", "randn", "(", "4", ",", "1024", ",", "14", ",", "14", ")", "\n", "\n", "box_head", "=", "FastRCNNConvFCHead", "(", "\n", "input_shape", ",", "conv_dims", "=", "[", "512", ",", "512", "]", ",", "fc_dims", "=", "[", "1024", ",", "1024", "]", "\n", ")", ".", "eval", "(", ")", "\n", "script_box_head", "=", "torch", ".", "jit", ".", "script", "(", "box_head", ")", "\n", "\n", "origin_output", "=", "box_head", "(", "box_features", ")", "\n", "script_output", "=", "script_box_head", "(", "box_features", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "equal", "(", "origin_output", ",", "script_output", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_roi_heads.ROIHeadsTest.test_mask_head_scriptability": [[157, 188], ["unittest.skipIf", "detectron2.layers.ShapeSpec", "torch.randn", "detectron2.structures.Instances", "torch.tensor", "detectron2.structures.Instances", "torch.tensor", "detectron2.modeling.roi_heads.MaskRCNNConvUpsampleHead().eval", "detectron2.modeling.roi_heads.MaskRCNNConvUpsampleHead().eval.", "zip", "copy.deepcopy", "detectron2.export.torchscript.patch_instances", "torch.jit.script", "NewInstances.from_instances", "NewInstances.from_instances", "torch.jit.script.", "test_roi_heads.ROIHeadsTest.assertEqual", "test_roi_heads.ROIHeadsTest.assertTrue", "test_roi_heads.ROIHeadsTest.assertTrue", "detectron2.modeling.roi_heads.MaskRCNNConvUpsampleHead", "torch.equal", "torch.equal"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript_patch.patch_instances"], ["", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "7", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_mask_head_scriptability", "(", "self", ")", ":", "\n", "        ", "input_shape", "=", "ShapeSpec", "(", "channels", "=", "1024", ")", "\n", "mask_features", "=", "torch", ".", "randn", "(", "4", ",", "1024", ",", "14", ",", "14", ")", "\n", "\n", "image_shapes", "=", "[", "(", "10", ",", "10", ")", ",", "(", "15", ",", "15", ")", "]", "\n", "pred_instance0", "=", "Instances", "(", "image_shapes", "[", "0", "]", ")", "\n", "pred_classes0", "=", "torch", ".", "tensor", "(", "[", "1", ",", "2", ",", "3", "]", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "pred_instance0", ".", "pred_classes", "=", "pred_classes0", "\n", "pred_instance1", "=", "Instances", "(", "image_shapes", "[", "1", "]", ")", "\n", "pred_classes1", "=", "torch", ".", "tensor", "(", "[", "4", "]", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "pred_instance1", ".", "pred_classes", "=", "pred_classes1", "\n", "\n", "mask_head", "=", "MaskRCNNConvUpsampleHead", "(", "\n", "input_shape", ",", "num_classes", "=", "80", ",", "conv_dims", "=", "[", "256", ",", "256", "]", "\n", ")", ".", "eval", "(", ")", "\n", "# pred_instance will be in-place changed during the inference", "\n", "# process of `MaskRCNNConvUpsampleHead`", "\n", "origin_outputs", "=", "mask_head", "(", "mask_features", ",", "deepcopy", "(", "[", "pred_instance0", ",", "pred_instance1", "]", ")", ")", "\n", "\n", "fields", "=", "{", "\"pred_masks\"", ":", "\"Tensor\"", ",", "\"pred_classes\"", ":", "\"Tensor\"", "}", "\n", "with", "patch_instances", "(", "fields", ")", "as", "NewInstances", ":", "\n", "            ", "sciript_mask_head", "=", "torch", ".", "jit", ".", "script", "(", "mask_head", ")", "\n", "pred_instance0", "=", "NewInstances", ".", "from_instances", "(", "pred_instance0", ")", "\n", "pred_instance1", "=", "NewInstances", ".", "from_instances", "(", "pred_instance1", ")", "\n", "script_outputs", "=", "sciript_mask_head", "(", "mask_features", ",", "[", "pred_instance0", ",", "pred_instance1", "]", ")", "\n", "\n", "", "for", "origin_ins", ",", "script_ins", "in", "zip", "(", "origin_outputs", ",", "script_outputs", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "origin_ins", ".", "image_size", ",", "script_ins", ".", "image_size", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "equal", "(", "origin_ins", ".", "pred_classes", ",", "script_ins", ".", "pred_classes", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "equal", "(", "origin_ins", ".", "pred_masks", ",", "script_ins", ".", "pred_masks", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_roi_heads.ROIHeadsTest.test_keypoint_head_scriptability": [[189, 227], ["unittest.skipIf", "detectron2.layers.ShapeSpec", "torch.randn", "torch.tensor", "detectron2.structures.Instances", "detectron2.structures.Boxes", "torch.tensor", "detectron2.structures.Instances", "detectron2.structures.Boxes", "detectron2.modeling.roi_heads.KRCNNConvDeconvUpsampleHead().eval", "detectron2.modeling.roi_heads.KRCNNConvDeconvUpsampleHead().eval.", "zip", "copy.deepcopy", "detectron2.export.torchscript.patch_instances", "torch.jit.script", "NewInstances.from_instances", "NewInstances.from_instances", "torch.jit.script.", "test_roi_heads.ROIHeadsTest.assertEqual", "test_roi_heads.ROIHeadsTest.assertTrue", "test_roi_heads.ROIHeadsTest.assertTrue", "detectron2.modeling.roi_heads.KRCNNConvDeconvUpsampleHead", "torch.equal", "torch.equal"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript_patch.patch_instances"], ["", "", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "8", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_keypoint_head_scriptability", "(", "self", ")", ":", "\n", "        ", "input_shape", "=", "ShapeSpec", "(", "channels", "=", "1024", ",", "height", "=", "14", ",", "width", "=", "14", ")", "\n", "keypoint_features", "=", "torch", ".", "randn", "(", "4", ",", "1024", ",", "14", ",", "14", ")", "\n", "\n", "image_shapes", "=", "[", "(", "10", ",", "10", ")", ",", "(", "15", ",", "15", ")", "]", "\n", "pred_boxes0", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "3", ",", "3", "]", ",", "[", "2", ",", "2", ",", "6", ",", "6", "]", ",", "[", "1", ",", "5", ",", "2", ",", "8", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "pred_instance0", "=", "Instances", "(", "image_shapes", "[", "0", "]", ")", "\n", "pred_instance0", ".", "pred_boxes", "=", "Boxes", "(", "pred_boxes0", ")", "\n", "pred_boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "7", ",", "3", ",", "10", ",", "5", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "pred_instance1", "=", "Instances", "(", "image_shapes", "[", "1", "]", ")", "\n", "pred_instance1", ".", "pred_boxes", "=", "Boxes", "(", "pred_boxes1", ")", "\n", "\n", "keypoint_head", "=", "KRCNNConvDeconvUpsampleHead", "(", "\n", "input_shape", ",", "num_keypoints", "=", "17", ",", "conv_dims", "=", "[", "512", ",", "512", "]", "\n", ")", ".", "eval", "(", ")", "\n", "origin_outputs", "=", "keypoint_head", "(", "\n", "keypoint_features", ",", "deepcopy", "(", "[", "pred_instance0", ",", "pred_instance1", "]", ")", "\n", ")", "\n", "\n", "fields", "=", "{", "\n", "\"pred_boxes\"", ":", "\"Boxes\"", ",", "\n", "\"pred_keypoints\"", ":", "\"Tensor\"", ",", "\n", "\"pred_keypoint_heatmaps\"", ":", "\"Tensor\"", ",", "\n", "}", "\n", "with", "patch_instances", "(", "fields", ")", "as", "NewInstances", ":", "\n", "            ", "sciript_keypoint_head", "=", "torch", ".", "jit", ".", "script", "(", "keypoint_head", ")", "\n", "pred_instance0", "=", "NewInstances", ".", "from_instances", "(", "pred_instance0", ")", "\n", "pred_instance1", "=", "NewInstances", ".", "from_instances", "(", "pred_instance1", ")", "\n", "script_outputs", "=", "sciript_keypoint_head", "(", "\n", "keypoint_features", ",", "[", "pred_instance0", ",", "pred_instance1", "]", "\n", ")", "\n", "\n", "", "for", "origin_ins", ",", "script_ins", "in", "zip", "(", "origin_outputs", ",", "script_outputs", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "origin_ins", ".", "image_size", ",", "script_ins", ".", "image_size", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "equal", "(", "origin_ins", ".", "pred_keypoints", ",", "script_ins", ".", "pred_keypoints", ")", ")", "\n", "self", ".", "assertTrue", "(", "\n", "torch", ".", "equal", "(", "origin_ins", ".", "pred_keypoint_heatmaps", ",", "script_ins", ".", "pred_keypoint_heatmaps", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.ModelE2ETest.setUp": [[52, 55], ["torch.manual_seed", "test_model_e2e.get_model_zoo"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_analysis.get_model_zoo"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.ModelE2ETest._test_eval": [[56, 60], ["test_model_e2e.ModelE2ETest.model.eval", "test_model_e2e.ModelE2ETest.model", "test_model_e2e.create_model_input", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.create_model_input"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.ModelE2ETest._test_train": [[61, 72], ["test_model_e2e.ModelE2ETest.model.train", "len", "len", "test_model_e2e.create_model_input", "detectron2.utils.events.EventStorage", "test_model_e2e.ModelE2ETest.model", "sum().backward", "torch.rand", "zip", "sum", "test_model_e2e.ModelE2ETest.values"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.create_model_input", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.swap_align2nat._SwapAlign2Nat.backward"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.ModelE2ETest._inf_tensor": [[73, 75], ["torch.zeros"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.ModelE2ETest._nan_tensor": [[76, 78], ["torch.zeros().fill_", "float", "torch.zeros"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.ModelE2ETest.test_empty_data": [[79, 83], ["test_model_e2e.ModelE2ETest._test_eval", "test_model_e2e.ModelE2ETest._test_train", "test_model_e2e.get_empty_instance", "test_model_e2e.get_empty_instance"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_e2e.ModelE2ETest._test_eval", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.ModelE2ETest._test_train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.get_empty_instance", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.get_empty_instance"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.ModelE2ETest.test_eval_tocpu": [[84, 91], ["unittest.skipIf", "get_model_zoo().cpu", "get_model_zoo().cpu.eval", "get_model_zoo().cpu.", "test_model_e2e.create_model_input", "torch.cuda.is_available", "test_model_e2e.get_model_zoo", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.create_model_input", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_analysis.get_model_zoo"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.MaskRCNNE2ETest.test_half_empty_data": [[96, 99], ["test_model_e2e.MaskRCNNE2ETest._test_train", "test_model_e2e.get_empty_instance", "test_model_e2e.get_regular_bitmask_instances"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.ModelE2ETest._test_train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.get_empty_instance", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.get_regular_bitmask_instances"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.MaskRCNNE2ETest.test_roiheads_inf_nan_data": [[115, 131], ["test_model_e2e.MaskRCNNE2ETest.model.eval", "detectron2.structures.ImageList", "detectron2.structures.Boxes().to", "torch.tensor().reshape", "test_model_e2e.MaskRCNNE2ETest.model.roi_heads", "test_model_e2e.MaskRCNNE2ETest.assertEqual", "tensor", "tensor", "tensor", "tensor", "tensor", "tensor", "detectron2.structures.Instances", "len", "detectron2.structures.Boxes", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.RetinaNetE2ETest.test_inf_nan_data": [[136, 158], ["test_model_e2e.RetinaNetE2ETest.model.eval", "detectron2.structures.ImageList", "test_model_e2e.RetinaNetE2ETest.model.anchor_generator", "test_model_e2e.RetinaNetE2ETest.model.head", "test_model_e2e.RetinaNetE2ETest.model.inference", "len", "tensor", "tensor", "tensor", "tensor", "tensor", "tensor", "tensor", "tensor", "test_model_e2e.RetinaNetE2ETest.assertTrue", "numpy.prod", "torch.isfinite().sum", "torch.isfinite"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.inference"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.get_model_zoo": [[15, 25], ["detectron2.get_config_file", "detectron2.config.get_cfg", "detectron2.config.get_cfg.merge_from_file", "detectron2.modeling.build_model", "torch.cuda.is_available"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get_config_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model"], ["\n", "", "return", "{", "\"image\"", ":", "image", ",", "\"instances\"", ":", "instances", "}", "\n", "\n", "\n", "", "def", "make_empty_instances", "(", "h", ",", "w", ")", ":", "\n", "    ", "instances", "=", "Instances", "(", "(", "h", ",", "w", ")", ")", "\n", "instances", ".", "gt_boxes", "=", "Boxes", "(", "torch", ".", "rand", "(", "0", ",", "4", ")", ")", "\n", "instances", ".", "gt_classes", "=", "torch", ".", "tensor", "(", "[", "]", ")", ".", "to", "(", "dtype", "=", "torch", ".", "int64", ")", "\n", "instances", ".", "gt_masks", "=", "BitMasks", "(", "torch", ".", "rand", "(", "0", ",", "h", ",", "w", ")", ")", "\n", "return", "instances", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.create_model_input": [[27, 32], ["None"], "function", ["None"], ["", "class", "ModelE2ETest", "(", "unittest", ".", "TestCase", ")", ":", "\n", "    ", "CONFIG_PATH", "=", "\"\"", "\n", "\n", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "self", ".", "model", "=", "get_model", "(", "self", ".", "CONFIG_PATH", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.get_empty_instance": [[34, 40], ["detectron2.structures.Instances", "detectron2.structures.Boxes", "torch.tensor().to", "detectron2.structures.BitMasks", "torch.rand", "torch.rand", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["        ", "inputs", "=", "[", "make_model_inputs", "(", "torch", ".", "rand", "(", "3", ",", "size", "[", "0", "]", ",", "size", "[", "1", "]", ")", ")", "for", "size", "in", "sizes", "]", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "self", ".", "model", "(", "inputs", ")", "\n", "\n", "\n", "", "", "class", "DensePoseRCNNE2ETest", "(", "ModelE2ETest", ")", ":", "\n", "    ", "CONFIG_PATH", "=", "\"densepose_rcnn_R_101_FPN_s1x.yaml\"", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_model_e2e.get_regular_bitmask_instances": [[42, 49], ["detectron2.structures.Instances", "detectron2.structures.Boxes", "torch.tensor().to", "detectron2.structures.BitMasks", "torch.rand", "torch.tensor", "torch.rand"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["def", "test_empty_data", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_eval", "(", "[", "(", "200", ",", "250", ")", ",", "(", "200", ",", "249", ")", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_anchor_generator.TestAnchorGenerator.test_default_anchor_generator": [[15, 44], ["detectron2.config.get_cfg", "detectron2.modeling.anchor_generator.DefaultAnchorGenerator", "detectron2.modeling.anchor_generator.DefaultAnchorGenerator.", "torch.tensor", "torch.allclose", "torch.rand", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg"], ["    ", "def", "test_default_anchor_generator", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "SIZES", "=", "[", "[", "32", ",", "64", "]", "]", "\n", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "ASPECT_RATIOS", "=", "[", "[", "0.25", ",", "1", ",", "4", "]", "]", "\n", "\n", "anchor_generator", "=", "DefaultAnchorGenerator", "(", "cfg", ",", "[", "ShapeSpec", "(", "stride", "=", "4", ")", "]", ")", "\n", "\n", "# only the last two dimensions of features matter here", "\n", "num_images", "=", "2", "\n", "features", "=", "{", "\"stage3\"", ":", "torch", ".", "rand", "(", "num_images", ",", "96", ",", "1", ",", "2", ")", "}", "\n", "anchors", "=", "anchor_generator", "(", "[", "features", "[", "\"stage3\"", "]", "]", ")", "\n", "expected_anchor_tensor", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "-", "32.0", ",", "-", "8.0", ",", "32.0", ",", "8.0", "]", ",", "\n", "[", "-", "16.0", ",", "-", "16.0", ",", "16.0", ",", "16.0", "]", ",", "\n", "[", "-", "8.0", ",", "-", "32.0", ",", "8.0", ",", "32.0", "]", ",", "\n", "[", "-", "64.0", ",", "-", "16.0", ",", "64.0", ",", "16.0", "]", ",", "\n", "[", "-", "32.0", ",", "-", "32.0", ",", "32.0", ",", "32.0", "]", ",", "\n", "[", "-", "16.0", ",", "-", "64.0", ",", "16.0", ",", "64.0", "]", ",", "\n", "[", "-", "28.0", ",", "-", "8.0", ",", "36.0", ",", "8.0", "]", ",", "# -28.0 == -32.0 + STRIDE (4)", "\n", "[", "-", "12.0", ",", "-", "16.0", ",", "20.0", ",", "16.0", "]", ",", "\n", "[", "-", "4.0", ",", "-", "32.0", ",", "12.0", ",", "32.0", "]", ",", "\n", "[", "-", "60.0", ",", "-", "16.0", ",", "68.0", ",", "16.0", "]", ",", "\n", "[", "-", "28.0", ",", "-", "32.0", ",", "36.0", ",", "32.0", "]", ",", "\n", "[", "-", "12.0", ",", "-", "64.0", ",", "20.0", ",", "64.0", "]", ",", "\n", "]", "\n", ")", "\n", "\n", "assert", "torch", ".", "allclose", "(", "anchors", "[", "0", "]", ".", "tensor", ",", "expected_anchor_tensor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_anchor_generator.TestAnchorGenerator.test_default_anchor_generator_centered": [[45, 77], ["detectron2.modeling.anchor_generator.DefaultAnchorGenerator", "torch.tensor", "detectron2.modeling.anchor_generator.DefaultAnchorGenerator.", "torch.allclose", "torch.rand", "torch.allclose", "torch.jit.script"], "methods", ["None"], ["", "def", "test_default_anchor_generator_centered", "(", "self", ")", ":", "\n", "# test explicit args", "\n", "        ", "anchor_generator", "=", "DefaultAnchorGenerator", "(", "\n", "sizes", "=", "[", "32", ",", "64", "]", ",", "aspect_ratios", "=", "[", "0.25", ",", "1", ",", "4", "]", ",", "strides", "=", "[", "4", "]", "\n", ")", "\n", "\n", "# only the last two dimensions of features matter here", "\n", "num_images", "=", "2", "\n", "features", "=", "{", "\"stage3\"", ":", "torch", ".", "rand", "(", "num_images", ",", "96", ",", "1", ",", "2", ")", "}", "\n", "expected_anchor_tensor", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "-", "30.0", ",", "-", "6.0", ",", "34.0", ",", "10.0", "]", ",", "\n", "[", "-", "14.0", ",", "-", "14.0", ",", "18.0", ",", "18.0", "]", ",", "\n", "[", "-", "6.0", ",", "-", "30.0", ",", "10.0", ",", "34.0", "]", ",", "\n", "[", "-", "62.0", ",", "-", "14.0", ",", "66.0", ",", "18.0", "]", ",", "\n", "[", "-", "30.0", ",", "-", "30.0", ",", "34.0", ",", "34.0", "]", ",", "\n", "[", "-", "14.0", ",", "-", "62.0", ",", "18.0", ",", "66.0", "]", ",", "\n", "[", "-", "26.0", ",", "-", "6.0", ",", "38.0", ",", "10.0", "]", ",", "\n", "[", "-", "10.0", ",", "-", "14.0", ",", "22.0", ",", "18.0", "]", ",", "\n", "[", "-", "2.0", ",", "-", "30.0", ",", "14.0", ",", "34.0", "]", ",", "\n", "[", "-", "58.0", ",", "-", "14.0", ",", "70.0", ",", "18.0", "]", ",", "\n", "[", "-", "26.0", ",", "-", "30.0", ",", "38.0", ",", "34.0", "]", ",", "\n", "[", "-", "10.0", ",", "-", "62.0", ",", "22.0", ",", "66.0", "]", ",", "\n", "]", "\n", ")", "\n", "\n", "anchors", "=", "anchor_generator", "(", "[", "features", "[", "\"stage3\"", "]", "]", ")", "\n", "assert", "torch", ".", "allclose", "(", "anchors", "[", "0", "]", ".", "tensor", ",", "expected_anchor_tensor", ")", "\n", "\n", "if", "TORCH_VERSION", ">=", "(", "1", ",", "6", ")", ":", "\n", "            ", "anchors", "=", "torch", ".", "jit", ".", "script", "(", "anchor_generator", ")", "(", "[", "features", "[", "\"stage3\"", "]", "]", ")", "\n", "assert", "torch", ".", "allclose", "(", "anchors", "[", "0", "]", ".", "tensor", ",", "expected_anchor_tensor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_anchor_generator.TestAnchorGenerator.test_rrpn_anchor_generator": [[78, 119], ["detectron2.config.get_cfg", "detectron2.modeling.anchor_generator.RotatedAnchorGenerator", "detectron2.modeling.anchor_generator.RotatedAnchorGenerator.", "torch.tensor", "torch.allclose", "torch.rand", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg"], ["", "", "def", "test_rrpn_anchor_generator", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "SIZES", "=", "[", "[", "32", ",", "64", "]", "]", "\n", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "ASPECT_RATIOS", "=", "[", "[", "0.25", ",", "1", ",", "4", "]", "]", "\n", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "ANGLES", "=", "[", "0", ",", "45", "]", "# test single list[float]", "\n", "anchor_generator", "=", "RotatedAnchorGenerator", "(", "cfg", ",", "[", "ShapeSpec", "(", "stride", "=", "4", ")", "]", ")", "\n", "\n", "# only the last two dimensions of features matter here", "\n", "num_images", "=", "2", "\n", "features", "=", "{", "\"stage3\"", ":", "torch", ".", "rand", "(", "num_images", ",", "96", ",", "1", ",", "2", ")", "}", "\n", "anchors", "=", "anchor_generator", "(", "[", "features", "[", "\"stage3\"", "]", "]", ")", "\n", "expected_anchor_tensor", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "0.0", ",", "0.0", ",", "64.0", ",", "16.0", ",", "0.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "64.0", ",", "16.0", ",", "45.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "32.0", ",", "32.0", ",", "0.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "32.0", ",", "32.0", ",", "45.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "16.0", ",", "64.0", ",", "0.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "16.0", ",", "64.0", ",", "45.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "128.0", ",", "32.0", ",", "0.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "128.0", ",", "32.0", ",", "45.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "64.0", ",", "64.0", ",", "0.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "64.0", ",", "64.0", ",", "45.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "32.0", ",", "128.0", ",", "0.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "32.0", ",", "128.0", ",", "45.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "64.0", ",", "16.0", ",", "0.0", "]", ",", "# 4.0 == 0.0 + STRIDE (4)", "\n", "[", "4.0", ",", "0.0", ",", "64.0", ",", "16.0", ",", "45.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "32.0", ",", "32.0", ",", "0.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "32.0", ",", "32.0", ",", "45.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "16.0", ",", "64.0", ",", "0.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "16.0", ",", "64.0", ",", "45.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "128.0", ",", "32.0", ",", "0.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "128.0", ",", "32.0", ",", "45.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "64.0", ",", "64.0", ",", "0.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "64.0", ",", "64.0", ",", "45.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "32.0", ",", "128.0", ",", "0.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "32.0", ",", "128.0", ",", "45.0", "]", ",", "\n", "]", "\n", ")", "\n", "\n", "assert", "torch", ".", "allclose", "(", "anchors", "[", "0", "]", ".", "tensor", ",", "expected_anchor_tensor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_box2box_transform.TestBox2BoxTransform.test_reconstruction": [[16, 31], ["detectron2.modeling.box_regression.Box2BoxTransform", "test_box2box_transform.random_boxes", "test_box2box_transform.random_boxes", "torch.cuda.is_available", "torch.device", "devices.append", "src_boxes.to.to.to", "dst_boxes.to.to.to", "detectron2.modeling.box_regression.Box2BoxTransform.get_deltas", "detectron2.modeling.box_regression.Box2BoxTransform.apply_deltas", "torch.allclose", "torch.device"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_box2box_transform.random_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_box2box_transform.random_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.box_regression.Box2BoxTransformRotated.get_deltas", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.box_regression.Box2BoxTransformRotated.apply_deltas", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device"], ["    ", "def", "test_reconstruction", "(", "self", ")", ":", "\n", "        ", "weights", "=", "(", "5", ",", "5", ",", "10", ",", "10", ")", "\n", "b2b_tfm", "=", "Box2BoxTransform", "(", "weights", "=", "weights", ")", "\n", "src_boxes", "=", "random_boxes", "(", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "1", ",", "10", ")", "\n", "dst_boxes", "=", "random_boxes", "(", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "1", ",", "10", ")", "\n", "\n", "devices", "=", "[", "torch", ".", "device", "(", "\"cpu\"", ")", "]", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "devices", ".", "append", "(", "torch", ".", "device", "(", "\"cuda\"", ")", ")", "\n", "", "for", "device", "in", "devices", ":", "\n", "            ", "src_boxes", "=", "src_boxes", ".", "to", "(", "device", "=", "device", ")", "\n", "dst_boxes", "=", "dst_boxes", ".", "to", "(", "device", "=", "device", ")", "\n", "deltas", "=", "b2b_tfm", ".", "get_deltas", "(", "src_boxes", ",", "dst_boxes", ")", "\n", "dst_boxes_reconstructed", "=", "b2b_tfm", ".", "apply_deltas", "(", "deltas", ",", "src_boxes", ")", "\n", "assert", "torch", ".", "allclose", "(", "dst_boxes", ",", "dst_boxes_reconstructed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_box2box_transform.TestBox2BoxTransformRotated.test_reconstruction": [[40, 60], ["detectron2.modeling.box_regression.Box2BoxTransformRotated", "test_box2box_transform.random_rotated_boxes", "test_box2box_transform.random_rotated_boxes", "torch.cuda.is_available", "torch.device", "devices.append", "src_boxes.to.to.to", "dst_boxes.to.to.to", "detectron2.modeling.box_regression.Box2BoxTransformRotated.get_deltas", "detectron2.modeling.box_regression.Box2BoxTransformRotated.apply_deltas", "torch.allclose", "torch.allclose", "torch.device", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_box2box_transform.random_rotated_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_box2box_transform.random_rotated_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.box_regression.Box2BoxTransformRotated.get_deltas", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.box_regression.Box2BoxTransformRotated.apply_deltas", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device"], ["    ", "def", "test_reconstruction", "(", "self", ")", ":", "\n", "        ", "weights", "=", "(", "5", ",", "5", ",", "10", ",", "10", ",", "1", ")", "\n", "b2b_transform", "=", "Box2BoxTransformRotated", "(", "weights", "=", "weights", ")", "\n", "src_boxes", "=", "random_rotated_boxes", "(", "[", "10", ",", "10", ",", "20", ",", "20", ",", "-", "30", "]", ",", "5", ",", "60.0", ",", "10", ")", "\n", "dst_boxes", "=", "random_rotated_boxes", "(", "[", "10", ",", "10", ",", "20", ",", "20", ",", "-", "30", "]", ",", "5", ",", "60.0", ",", "10", ")", "\n", "\n", "devices", "=", "[", "torch", ".", "device", "(", "\"cpu\"", ")", "]", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "devices", ".", "append", "(", "torch", ".", "device", "(", "\"cuda\"", ")", ")", "\n", "", "for", "device", "in", "devices", ":", "\n", "            ", "src_boxes", "=", "src_boxes", ".", "to", "(", "device", "=", "device", ")", "\n", "dst_boxes", "=", "dst_boxes", ".", "to", "(", "device", "=", "device", ")", "\n", "deltas", "=", "b2b_transform", ".", "get_deltas", "(", "src_boxes", ",", "dst_boxes", ")", "\n", "dst_boxes_reconstructed", "=", "b2b_transform", ".", "apply_deltas", "(", "deltas", ",", "src_boxes", ")", "\n", "assert", "torch", ".", "allclose", "(", "dst_boxes", "[", ":", ",", ":", "4", "]", ",", "dst_boxes_reconstructed", "[", ":", ",", ":", "4", "]", ",", "atol", "=", "1e-5", ")", "\n", "# angle difference has to be normalized", "\n", "assert", "torch", ".", "allclose", "(", "\n", "(", "dst_boxes", "[", ":", ",", "4", "]", "-", "dst_boxes_reconstructed", "[", ":", ",", "4", "]", "+", "180.0", ")", "%", "360.0", "-", "180.0", ",", "\n", "torch", ".", "zeros_like", "(", "dst_boxes", "[", ":", ",", "4", "]", ")", ",", "\n", "atol", "=", "1e-4", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_box2box_transform.random_boxes": [[11, 13], ["torch.tensor", "torch.rand"], "function", ["None"], ["def", "random_boxes", "(", "mean_box", ",", "stdev", ",", "N", ")", ":", "\n", "    ", "return", "torch", ".", "rand", "(", "N", ",", "4", ")", "*", "stdev", "+", "torch", ".", "tensor", "(", "mean_box", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_box2box_transform.random_rotated_boxes": [[33, 37], ["torch.cat", "torch.tensor", "torch.rand", "torch.rand"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "", "", "def", "random_rotated_boxes", "(", "mean_box", ",", "std_length", ",", "std_angle", ",", "N", ")", ":", "\n", "    ", "return", "torch", ".", "cat", "(", "\n", "[", "torch", ".", "rand", "(", "N", ",", "4", ")", "*", "std_length", ",", "torch", ".", "rand", "(", "N", ",", "1", ")", "*", "std_angle", "]", ",", "dim", "=", "1", "\n", ")", "+", "torch", ".", "tensor", "(", "mean_box", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_rpn.RPNTest.test_rpn": [[20, 79], ["torch.manual_seed", "detectron2.config.get_cfg", "detectron2.modeling.backbone.build_backbone", "detectron2.modeling.proposal_generator.RPN", "torch.rand", "detectron2.structures.ImageList", "torch.tensor", "detectron2.structures.Instances", "detectron2.structures.Boxes", "expected_losses.keys", "zip", "detectron2.modeling.backbone.build_backbone.output_shape", "torch.rand", "detectron2.utils.events.EventStorage", "detectron2.modeling.proposal_generator.RPN.", "torch.tensor", "torch.tensor", "test_rpn.RPNTest.assertTrue", "detectron2.structures.Boxes", "detectron2.structures.Boxes", "torch.tensor", "torch.tensor", "test_rpn.RPNTest.assertEqual", "test_rpn.RPNTest.assertEqual", "test_rpn.RPNTest.assertTrue", "test_rpn.RPNTest.assertTrue", "torch.allclose", "torch.tensor", "torch.tensor", "len", "len", "torch.allclose", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.backbone.Backbone.output_shape"], ["    ", "def", "test_rpn", "(", "self", ")", ":", "\n", "        ", "torch", ".", "manual_seed", "(", "121", ")", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "proposal_generator", "=", "RPN", "(", "cfg", ",", "backbone", ".", "output_shape", "(", ")", ")", "\n", "num_images", "=", "2", "\n", "images_tensor", "=", "torch", ".", "rand", "(", "num_images", ",", "20", ",", "30", ")", "\n", "image_sizes", "=", "[", "(", "10", ",", "10", ")", ",", "(", "20", ",", "30", ")", "]", "\n", "images", "=", "ImageList", "(", "images_tensor", ",", "image_sizes", ")", "\n", "image_shape", "=", "(", "15", ",", "15", ")", "\n", "num_channels", "=", "1024", "\n", "features", "=", "{", "\"res4\"", ":", "torch", ".", "rand", "(", "num_images", ",", "num_channels", ",", "1", ",", "2", ")", "}", "\n", "gt_boxes", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "3", ",", "3", "]", ",", "[", "2", ",", "2", ",", "6", ",", "6", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "gt_instances", "=", "Instances", "(", "image_shape", ")", "\n", "gt_instances", ".", "gt_boxes", "=", "Boxes", "(", "gt_boxes", ")", "\n", "with", "EventStorage", "(", ")", ":", "# capture events in a new storage to discard them", "\n", "            ", "proposals", ",", "proposal_losses", "=", "proposal_generator", "(", "\n", "images", ",", "features", ",", "[", "gt_instances", "[", "0", "]", ",", "gt_instances", "[", "1", "]", "]", "\n", ")", "\n", "\n", "", "expected_losses", "=", "{", "\n", "\"loss_rpn_cls\"", ":", "torch", ".", "tensor", "(", "0.0804563984", ")", ",", "\n", "\"loss_rpn_loc\"", ":", "torch", ".", "tensor", "(", "0.0990132466", ")", ",", "\n", "}", "\n", "for", "name", "in", "expected_losses", ".", "keys", "(", ")", ":", "\n", "            ", "err_msg", "=", "\"proposal_losses[{}] = {}, expected losses = {}\"", ".", "format", "(", "\n", "name", ",", "proposal_losses", "[", "name", "]", ",", "expected_losses", "[", "name", "]", "\n", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "proposal_losses", "[", "name", "]", ",", "expected_losses", "[", "name", "]", ")", ",", "err_msg", ")", "\n", "\n", "", "expected_proposal_boxes", "=", "[", "\n", "Boxes", "(", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "[", "7.3365392685", ",", "0", ",", "10", ",", "10", "]", "]", ")", ")", ",", "\n", "Boxes", "(", "\n", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "0", ",", "0", ",", "30", ",", "20", "]", ",", "\n", "[", "0", ",", "0", ",", "16.7862777710", ",", "13.1362524033", "]", ",", "\n", "[", "0", ",", "0", ",", "30", ",", "13.3173446655", "]", ",", "\n", "[", "0", ",", "0", ",", "10.8602609634", ",", "20", "]", ",", "\n", "[", "7.7165775299", ",", "0", ",", "27.3875980377", ",", "20", "]", ",", "\n", "]", "\n", ")", "\n", ")", ",", "\n", "]", "\n", "\n", "expected_objectness_logits", "=", "[", "\n", "torch", ".", "tensor", "(", "[", "0.1225359365", ",", "-", "0.0133192837", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "0.1415634006", ",", "0.0989848152", ",", "0.0565387346", ",", "-", "0.0072308783", ",", "-", "0.0428492837", "]", ")", ",", "\n", "]", "\n", "\n", "for", "proposal", ",", "expected_proposal_box", ",", "im_size", ",", "expected_objectness_logit", "in", "zip", "(", "\n", "proposals", ",", "expected_proposal_boxes", ",", "image_sizes", ",", "expected_objectness_logits", "\n", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "len", "(", "proposal", ")", ",", "len", "(", "expected_proposal_box", ")", ")", "\n", "self", ".", "assertEqual", "(", "proposal", ".", "image_size", ",", "im_size", ")", "\n", "self", ".", "assertTrue", "(", "\n", "torch", ".", "allclose", "(", "proposal", ".", "proposal_boxes", ".", "tensor", ",", "expected_proposal_box", ".", "tensor", ")", "\n", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "proposal", ".", "objectness_logits", ",", "expected_objectness_logit", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_rpn.RPNTest.test_rpn_scriptability": [[80, 102], ["unittest.skipIf", "detectron2.config.get_cfg", "detectron2.modeling.proposal_generator.RPN().eval", "torch.rand", "detectron2.structures.ImageList", "detectron2.export.torchscript.export_torchscript_with_instances", "detectron2.modeling.proposal_generator.RPN().eval.", "detectron2.export.torchscript.export_torchscript_with_instances.", "zip", "torch.rand", "test_rpn.RPNTest.assertEqual", "test_rpn.RPNTest.assertTrue", "test_rpn.RPNTest.assertTrue", "detectron2.modeling.proposal_generator.RPN", "torch.equal", "torch.equal", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript.export_torchscript_with_instances"], ["", "", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "7", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_rpn_scriptability", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "proposal_generator", "=", "RPN", "(", "cfg", ",", "{", "\"res4\"", ":", "ShapeSpec", "(", "channels", "=", "1024", ",", "stride", "=", "16", ")", "}", ")", ".", "eval", "(", ")", "\n", "num_images", "=", "2", "\n", "images_tensor", "=", "torch", ".", "rand", "(", "num_images", ",", "30", ",", "40", ")", "\n", "image_sizes", "=", "[", "(", "32", ",", "32", ")", ",", "(", "30", ",", "40", ")", "]", "\n", "images", "=", "ImageList", "(", "images_tensor", ",", "image_sizes", ")", "\n", "features", "=", "{", "\"res4\"", ":", "torch", ".", "rand", "(", "num_images", ",", "1024", ",", "1", ",", "2", ")", "}", "\n", "\n", "fields", "=", "{", "\"proposal_boxes\"", ":", "\"Boxes\"", ",", "\"objectness_logits\"", ":", "\"Tensor\"", "}", "\n", "proposal_generator_ts", "=", "export_torchscript_with_instances", "(", "proposal_generator", ",", "fields", ")", "\n", "\n", "proposals", ",", "_", "=", "proposal_generator", "(", "images", ",", "features", ")", "\n", "proposals_ts", ",", "_", "=", "proposal_generator_ts", "(", "images", ",", "features", ")", "\n", "\n", "for", "proposal", ",", "proposal_ts", "in", "zip", "(", "proposals", ",", "proposals_ts", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "proposal", ".", "image_size", ",", "proposal_ts", ".", "image_size", ")", "\n", "self", ".", "assertTrue", "(", "\n", "torch", ".", "equal", "(", "proposal", ".", "proposal_boxes", ".", "tensor", ",", "proposal_ts", ".", "proposal_boxes", ".", "tensor", ")", "\n", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "equal", "(", "proposal", ".", "objectness_logits", ",", "proposal_ts", ".", "objectness_logits", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_rpn.RPNTest.test_rrpn": [[103, 245], ["torch.manual_seed", "detectron2.config.get_cfg", "detectron2.modeling.backbone.build_backbone", "detectron2.modeling.proposal_generator.build_proposal_generator", "torch.rand", "detectron2.structures.ImageList", "torch.tensor", "detectron2.structures.Instances", "detectron2.structures.RotatedBoxes", "expected_losses.keys", "torch.set_printoptions", "zip", "detectron2.modeling.backbone.build_backbone.output_shape", "torch.rand", "detectron2.utils.events.EventStorage", "detectron2.modeling.proposal_generator.build_proposal_generator.", "torch.tensor", "torch.tensor", "test_rpn.RPNTest.assertTrue", "detectron2.structures.RotatedBoxes", "detectron2.structures.RotatedBoxes", "torch.tensor", "torch.tensor", "test_rpn.RPNTest.assertEqual", "test_rpn.RPNTest.assertEqual", "test_rpn.RPNTest.assertTrue", "test_rpn.RPNTest.assertTrue", "torch.allclose", "torch.tensor", "torch.tensor", "len", "len", "torch.allclose", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.build.build_proposal_generator", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.backbone.Backbone.output_shape"], ["", "", "def", "test_rrpn", "(", "self", ")", ":", "\n", "        ", "torch", ".", "manual_seed", "(", "121", ")", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "MODEL", ".", "PROPOSAL_GENERATOR", ".", "NAME", "=", "\"RRPN\"", "\n", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "NAME", "=", "\"RotatedAnchorGenerator\"", "\n", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "SIZES", "=", "[", "[", "32", ",", "64", "]", "]", "\n", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "ASPECT_RATIOS", "=", "[", "[", "0.25", ",", "1", "]", "]", "\n", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "ANGLES", "=", "[", "[", "0", ",", "60", "]", "]", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "BBOX_REG_WEIGHTS", "=", "(", "1", ",", "1", ",", "1", ",", "1", ",", "1", ")", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "HEAD_NAME", "=", "\"StandardRPNHead\"", "\n", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "proposal_generator", "=", "build_proposal_generator", "(", "cfg", ",", "backbone", ".", "output_shape", "(", ")", ")", "\n", "num_images", "=", "2", "\n", "images_tensor", "=", "torch", ".", "rand", "(", "num_images", ",", "20", ",", "30", ")", "\n", "image_sizes", "=", "[", "(", "10", ",", "10", ")", ",", "(", "20", ",", "30", ")", "]", "\n", "images", "=", "ImageList", "(", "images_tensor", ",", "image_sizes", ")", "\n", "image_shape", "=", "(", "15", ",", "15", ")", "\n", "num_channels", "=", "1024", "\n", "features", "=", "{", "\"res4\"", ":", "torch", ".", "rand", "(", "num_images", ",", "num_channels", ",", "1", ",", "2", ")", "}", "\n", "gt_boxes", "=", "torch", ".", "tensor", "(", "[", "[", "2", ",", "2", ",", "2", ",", "2", ",", "0", "]", ",", "[", "4", ",", "4", ",", "4", ",", "4", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "gt_instances", "=", "Instances", "(", "image_shape", ")", "\n", "gt_instances", ".", "gt_boxes", "=", "RotatedBoxes", "(", "gt_boxes", ")", "\n", "with", "EventStorage", "(", ")", ":", "# capture events in a new storage to discard them", "\n", "            ", "proposals", ",", "proposal_losses", "=", "proposal_generator", "(", "\n", "images", ",", "features", ",", "[", "gt_instances", "[", "0", "]", ",", "gt_instances", "[", "1", "]", "]", "\n", ")", "\n", "\n", "", "expected_losses", "=", "{", "\n", "\"loss_rpn_cls\"", ":", "torch", ".", "tensor", "(", "0.043263837695121765", ")", ",", "\n", "\"loss_rpn_loc\"", ":", "torch", ".", "tensor", "(", "0.14432406425476074", ")", ",", "\n", "}", "\n", "for", "name", "in", "expected_losses", ".", "keys", "(", ")", ":", "\n", "            ", "err_msg", "=", "\"proposal_losses[{}] = {}, expected losses = {}\"", ".", "format", "(", "\n", "name", ",", "proposal_losses", "[", "name", "]", ",", "expected_losses", "[", "name", "]", "\n", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "proposal_losses", "[", "name", "]", ",", "expected_losses", "[", "name", "]", ")", ",", "err_msg", ")", "\n", "\n", "", "expected_proposal_boxes", "=", "[", "\n", "RotatedBoxes", "(", "\n", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "0.60189795", ",", "1.24095452", ",", "61.98131943", ",", "18.03621292", ",", "-", "4.07244873", "]", ",", "\n", "[", "15.64940453", ",", "1.69624567", ",", "59.59749603", ",", "16.34339333", ",", "2.62692475", "]", ",", "\n", "[", "-", "3.02982378", ",", "-", "2.69752932", ",", "67.90952301", ",", "59.62455750", ",", "59.97010040", "]", ",", "\n", "[", "16.71863365", ",", "1.98309708", ",", "35.61507797", ",", "32.81484985", ",", "62.92267227", "]", ",", "\n", "[", "0.49432933", ",", "-", "7.92979717", ",", "67.77606201", ",", "62.93098450", ",", "-", "1.85656738", "]", ",", "\n", "[", "8.00880814", ",", "1.36017394", ",", "121.81007385", ",", "32.74150467", ",", "50.44297409", "]", ",", "\n", "[", "16.44299889", ",", "-", "4.82221127", ",", "63.39775848", ",", "61.22503662", ",", "54.12270737", "]", ",", "\n", "[", "5.00000000", ",", "5.00000000", ",", "10.00000000", ",", "10.00000000", ",", "-", "0.76943970", "]", ",", "\n", "[", "17.64130402", ",", "-", "0.98095351", ",", "61.40377808", ",", "16.28918839", ",", "55.53118134", "]", ",", "\n", "[", "0.13016054", ",", "4.60568953", ",", "35.80157471", ",", "32.30180359", ",", "62.52872086", "]", ",", "\n", "[", "-", "4.26460743", ",", "0.39604485", ",", "124.30079651", ",", "31.84611320", ",", "-", "1.58203125", "]", ",", "\n", "[", "7.52815342", ",", "-", "0.91636634", ",", "62.39784622", ",", "15.45565224", ",", "60.79549789", "]", ",", "\n", "]", "\n", ")", "\n", ")", ",", "\n", "RotatedBoxes", "(", "\n", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "0.07734215", ",", "0.81635046", ",", "65.33510590", ",", "17.34688377", ",", "-", "1.51821899", "]", ",", "\n", "[", "-", "3.41833067", ",", "-", "3.11320257", ",", "64.17595673", ",", "60.55617905", ",", "58.27033234", "]", ",", "\n", "[", "20.67383385", ",", "-", "6.16561556", ",", "63.60531998", ",", "62.52315903", ",", "54.85546494", "]", ",", "\n", "[", "15.00000000", ",", "10.00000000", ",", "30.00000000", ",", "20.00000000", ",", "-", "0.18218994", "]", ",", "\n", "[", "9.22646523", ",", "-", "6.84775209", ",", "62.09895706", ",", "65.46472931", ",", "-", "2.74307251", "]", ",", "\n", "[", "15.00000000", ",", "4.93451595", ",", "30.00000000", ",", "9.86903191", ",", "-", "0.60272217", "]", ",", "\n", "[", "8.88342094", ",", "2.65560246", ",", "120.95362854", ",", "32.45022202", ",", "55.75970078", "]", ",", "\n", "[", "16.39088631", ",", "2.33887148", ",", "34.78761292", ",", "35.61492920", ",", "60.81977463", "]", ",", "\n", "[", "9.78298569", ",", "10.00000000", ",", "19.56597137", ",", "20.00000000", ",", "-", "0.86660767", "]", ",", "\n", "[", "1.28576660", ",", "5.49873352", ",", "34.93610382", ",", "33.22600174", ",", "60.51599884", "]", ",", "\n", "[", "17.58912468", ",", "-", "1.63270092", ",", "62.96052551", ",", "16.45713997", ",", "52.91245270", "]", ",", "\n", "[", "5.64749718", ",", "-", "1.90428460", ",", "62.37649155", ",", "16.19474792", ",", "61.09543991", "]", ",", "\n", "[", "0.82255805", ",", "2.34931135", ",", "118.83985901", ",", "32.83671188", ",", "56.50753784", "]", ",", "\n", "[", "-", "5.33874989", ",", "1.64404404", ",", "125.28501892", ",", "33.35424042", ",", "-", "2.80731201", "]", ",", "\n", "]", "\n", ")", "\n", ")", ",", "\n", "]", "\n", "\n", "expected_objectness_logits", "=", "[", "\n", "torch", ".", "tensor", "(", "\n", "[", "\n", "0.10111768", ",", "\n", "0.09112845", ",", "\n", "0.08466332", ",", "\n", "0.07589971", ",", "\n", "0.06650183", ",", "\n", "0.06350251", ",", "\n", "0.04299347", ",", "\n", "0.01864817", ",", "\n", "0.00986163", ",", "\n", "0.00078543", ",", "\n", "-", "0.04573630", ",", "\n", "-", "0.04799230", ",", "\n", "]", "\n", ")", ",", "\n", "torch", ".", "tensor", "(", "\n", "[", "\n", "0.11373727", ",", "\n", "0.09377633", ",", "\n", "0.05281663", ",", "\n", "0.05143715", ",", "\n", "0.04040275", ",", "\n", "0.03250912", ",", "\n", "0.01307789", ",", "\n", "0.01177734", ",", "\n", "0.00038105", ",", "\n", "-", "0.00540255", ",", "\n", "-", "0.01194804", ",", "\n", "-", "0.01461012", ",", "\n", "-", "0.03061717", ",", "\n", "-", "0.03599222", ",", "\n", "]", "\n", ")", ",", "\n", "]", "\n", "\n", "torch", ".", "set_printoptions", "(", "precision", "=", "8", ",", "sci_mode", "=", "False", ")", "\n", "\n", "for", "proposal", ",", "expected_proposal_box", ",", "im_size", ",", "expected_objectness_logit", "in", "zip", "(", "\n", "proposals", ",", "expected_proposal_boxes", ",", "image_sizes", ",", "expected_objectness_logits", "\n", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "len", "(", "proposal", ")", ",", "len", "(", "expected_proposal_box", ")", ")", "\n", "self", ".", "assertEqual", "(", "proposal", ".", "image_size", ",", "im_size", ")", "\n", "# It seems that there's some randomness in the result across different machines:", "\n", "# This test can be run on a local machine for 100 times with exactly the same result,", "\n", "# However, a different machine might produce slightly different results,", "\n", "# thus the atol here.", "\n", "err_msg", "=", "\"computed proposal boxes = {}, expected {}\"", ".", "format", "(", "\n", "proposal", ".", "proposal_boxes", ".", "tensor", ",", "expected_proposal_box", ".", "tensor", "\n", ")", "\n", "self", ".", "assertTrue", "(", "\n", "torch", ".", "allclose", "(", "\n", "proposal", ".", "proposal_boxes", ".", "tensor", ",", "expected_proposal_box", ".", "tensor", ",", "atol", "=", "1e-5", "\n", ")", ",", "\n", "err_msg", ",", "\n", ")", "\n", "\n", "err_msg", "=", "\"computed objectness logits = {}, expected {}\"", ".", "format", "(", "\n", "proposal", ".", "objectness_logits", ",", "expected_objectness_logit", "\n", ")", "\n", "self", ".", "assertTrue", "(", "\n", "torch", ".", "allclose", "(", "proposal", ".", "objectness_logits", ",", "expected_objectness_logit", ",", "atol", "=", "1e-5", ")", ",", "\n", "err_msg", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_rpn.RPNTest.test_rpn_proposals_inf": [[247, 253], ["[].fill_", "detectron2.modeling.proposal_generator.proposal_utils.find_top_rpn_proposals", "torch.rand", "torch.rand", "float"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.proposal_utils.find_top_rpn_proposals"], ["", "", "def", "test_rpn_proposals_inf", "(", "self", ")", ":", "\n", "        ", "N", ",", "Hi", ",", "Wi", ",", "A", "=", "3", ",", "3", ",", "3", ",", "3", "\n", "proposals", "=", "[", "torch", ".", "rand", "(", "N", ",", "Hi", "*", "Wi", "*", "A", ",", "4", ")", "]", "\n", "pred_logits", "=", "[", "torch", ".", "rand", "(", "N", ",", "Hi", "*", "Wi", "*", "A", ")", "]", "\n", "pred_logits", "[", "0", "]", "[", "1", "]", "[", "3", ":", "5", "]", ".", "fill_", "(", "float", "(", "\"inf\"", ")", ")", "\n", "find_top_rpn_proposals", "(", "proposals", ",", "pred_logits", ",", "[", "(", "10", ",", "10", ")", "]", ",", "0.5", ",", "1000", ",", "1000", ",", "0", ",", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.rcnn.GeneralizedRCNN.__init__": [[32, 72], ["torch.nn.Module.__init__", "rcnn.GeneralizedRCNN.register_buffer", "rcnn.GeneralizedRCNN.register_buffer", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "*", ",", "\n", "backbone", ":", "Backbone", ",", "\n", "proposal_generator", ":", "nn", ".", "Module", ",", "\n", "roi_heads", ":", "nn", ".", "Module", ",", "\n", "pixel_mean", ":", "Tuple", "[", "float", "]", ",", "\n", "pixel_std", ":", "Tuple", "[", "float", "]", ",", "\n", "input_format", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "vis_period", ":", "int", "=", "0", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            backbone: a backbone module, must follow detectron2's backbone interface\n            proposal_generator: a module that generates proposals using backbone features\n            roi_heads: a ROI head that performs per-region computation\n            pixel_mean, pixel_std: list or tuple with #channels element,\n                representing the per-channel mean and std to be used to normalize\n                the input image\n            input_format: describe the meaning of channels of input. Needed by visualization\n            vis_period: the period to run visualization. Set to 0 to disable.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "backbone", "=", "backbone", "\n", "self", ".", "proposal_generator", "=", "proposal_generator", "\n", "self", ".", "roi_heads", "=", "roi_heads", "\n", "\n", "self", ".", "input_format", "=", "input_format", "\n", "self", ".", "vis_period", "=", "vis_period", "\n", "if", "vis_period", ">", "0", ":", "\n", "            ", "assert", "input_format", "is", "not", "None", ",", "\"input_format is required for visualization!\"", "\n", "\n", "", "self", ".", "register_buffer", "(", "\"pixel_mean\"", ",", "torch", ".", "Tensor", "(", "pixel_mean", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_std\"", ",", "torch", ".", "Tensor", "(", "pixel_std", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "assert", "(", "\n", "self", ".", "pixel_mean", ".", "shape", "==", "self", ".", "pixel_std", ".", "shape", "\n", ")", ",", "f\"{self.pixel_mean} and {self.pixel_std} have different shapes!\"", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.rcnn.GeneralizedRCNN.from_config": [[73, 84], ["backbone.build_backbone.build_backbone", "proposal_generator.build_proposal_generator", "roi_heads.build_roi_heads", "backbone.build_backbone.build_backbone.output_shape", "backbone.build_backbone.build_backbone.output_shape"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.build.build_proposal_generator", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.build_roi_heads", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.backbone.Backbone.output_shape", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.backbone.Backbone.output_shape"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "return", "{", "\n", "\"backbone\"", ":", "backbone", ",", "\n", "\"proposal_generator\"", ":", "build_proposal_generator", "(", "cfg", ",", "backbone", ".", "output_shape", "(", ")", ")", ",", "\n", "\"roi_heads\"", ":", "build_roi_heads", "(", "cfg", ",", "backbone", ".", "output_shape", "(", ")", ")", ",", "\n", "\"input_format\"", ":", "cfg", ".", "INPUT", ".", "FORMAT", ",", "\n", "\"vis_period\"", ":", "cfg", ".", "VIS_PERIOD", ",", "\n", "\"pixel_mean\"", ":", "cfg", ".", "MODEL", ".", "PIXEL_MEAN", ",", "\n", "\"pixel_std\"", ":", "cfg", ".", "MODEL", ".", "PIXEL_STD", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.rcnn.GeneralizedRCNN.device": [[86, 89], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "pixel_mean", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.rcnn.GeneralizedRCNN.visualize_training": [[90, 124], ["detectron2.utils.events.get_event_storage", "zip", "detectron2.data.detection_utils.convert_image_to_rgb", "Visualizer", "v_gt.overlay_instances.overlay_instances.overlay_instances", "v_gt.overlay_instances.overlay_instances.get_image", "min", "Visualizer", "v_pred.overlay_instances.overlay_instances.overlay_instances", "v_pred.overlay_instances.overlay_instances.get_image", "numpy.concatenate", "vis_img.transpose.transpose.transpose", "detectron2.utils.events.get_event_storage.put_image", "detectron2.data.detection_utils.convert_image_to_rgb.permute", "len", "prop.proposal_boxes[].tensor.cpu().numpy", "prop.proposal_boxes[].tensor.cpu"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.get_event_storage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.get_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.get_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_image"], ["", "def", "visualize_training", "(", "self", ",", "batched_inputs", ",", "proposals", ")", ":", "\n", "        ", "\"\"\"\n        A function used to visualize images and proposals. It shows ground truth\n        bounding boxes on the original image and up to 20 top-scoring predicted\n        object proposals on the original image. Users can implement different\n        visualization functions for different models.\n\n        Args:\n            batched_inputs (list): a list that contains input to the model.\n            proposals (list): a list that contains predicted proposals. Both\n                batched_inputs and proposals should have the same length.\n        \"\"\"", "\n", "from", "detectron2", ".", "utils", ".", "visualizer", "import", "Visualizer", "\n", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "max_vis_prop", "=", "20", "\n", "\n", "for", "input", ",", "prop", "in", "zip", "(", "batched_inputs", ",", "proposals", ")", ":", "\n", "            ", "img", "=", "input", "[", "\"image\"", "]", "\n", "img", "=", "convert_image_to_rgb", "(", "img", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ",", "self", ".", "input_format", ")", "\n", "v_gt", "=", "Visualizer", "(", "img", ",", "None", ")", "\n", "v_gt", "=", "v_gt", ".", "overlay_instances", "(", "boxes", "=", "input", "[", "\"instances\"", "]", ".", "gt_boxes", ")", "\n", "anno_img", "=", "v_gt", ".", "get_image", "(", ")", "\n", "box_size", "=", "min", "(", "len", "(", "prop", ".", "proposal_boxes", ")", ",", "max_vis_prop", ")", "\n", "v_pred", "=", "Visualizer", "(", "img", ",", "None", ")", "\n", "v_pred", "=", "v_pred", ".", "overlay_instances", "(", "\n", "boxes", "=", "prop", ".", "proposal_boxes", "[", "0", ":", "box_size", "]", ".", "tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", ")", "\n", "prop_img", "=", "v_pred", ".", "get_image", "(", ")", "\n", "vis_img", "=", "np", ".", "concatenate", "(", "(", "anno_img", ",", "prop_img", ")", ",", "axis", "=", "1", ")", "\n", "vis_img", "=", "vis_img", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", "\n", "vis_name", "=", "\"Left: GT bounding boxes;  Right: Predicted proposals\"", "\n", "storage", ".", "put_image", "(", "vis_name", ",", "vis_img", ")", "\n", "break", "# only visualize one image in a batch", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.rcnn.GeneralizedRCNN.forward": [[125, 176], ["rcnn.GeneralizedRCNN.preprocess_image", "rcnn.GeneralizedRCNN.backbone", "rcnn.GeneralizedRCNN.roi_heads", "losses.update", "losses.update", "rcnn.GeneralizedRCNN.inference", "rcnn.GeneralizedRCNN.proposal_generator", "detectron2.utils.events.get_event_storage", "x[].to", "x[].to", "rcnn.GeneralizedRCNN.visualize_training"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.preprocess_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.inference", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.get_event_storage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.RetinaNet.visualize_training"], ["", "", "def", "forward", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            batched_inputs: a list, batched outputs of :class:`DatasetMapper` .\n                Each item in the list contains the inputs for one image.\n                For now, each item in the list is a dict that contains:\n\n                * image: Tensor, image in (C, H, W) format.\n                * instances (optional): groundtruth :class:`Instances`\n                * proposals (optional): :class:`Instances`, precomputed proposals.\n\n                Other information that's included in the original dicts, such as:\n\n                * \"height\", \"width\" (int): the output resolution of the model, used in inference.\n                  See :meth:`postprocess` for details.\n\n        Returns:\n            list[dict]:\n                Each dict is the output for one input image.\n                The dict contains one key \"instances\" whose value is a :class:`Instances`.\n                The :class:`Instances` object has the following keys:\n                \"pred_boxes\", \"pred_classes\", \"scores\", \"pred_masks\", \"pred_keypoints\"\n        \"\"\"", "\n", "if", "not", "self", ".", "training", ":", "\n", "            ", "return", "self", ".", "inference", "(", "batched_inputs", ")", "\n", "\n", "", "images", "=", "self", ".", "preprocess_image", "(", "batched_inputs", ")", "\n", "if", "\"instances\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "gt_instances", "=", "[", "x", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "", "else", ":", "\n", "            ", "gt_instances", "=", "None", "\n", "\n", "", "features", "=", "self", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "\n", "if", "self", ".", "proposal_generator", ":", "\n", "            ", "proposals", ",", "proposal_losses", "=", "self", ".", "proposal_generator", "(", "images", ",", "features", ",", "gt_instances", ")", "\n", "", "else", ":", "\n", "            ", "assert", "\"proposals\"", "in", "batched_inputs", "[", "0", "]", "\n", "proposals", "=", "[", "x", "[", "\"proposals\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "proposal_losses", "=", "{", "}", "\n", "\n", "", "_", ",", "detector_losses", "=", "self", ".", "roi_heads", "(", "images", ",", "features", ",", "proposals", ",", "gt_instances", ")", "\n", "if", "self", ".", "vis_period", ">", "0", ":", "\n", "            ", "storage", "=", "get_event_storage", "(", ")", "\n", "if", "storage", ".", "iter", "%", "self", ".", "vis_period", "==", "0", ":", "\n", "                ", "self", ".", "visualize_training", "(", "batched_inputs", ",", "proposals", ")", "\n", "\n", "", "", "losses", "=", "{", "}", "\n", "losses", ".", "update", "(", "detector_losses", ")", "\n", "losses", ".", "update", "(", "proposal_losses", ")", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.rcnn.GeneralizedRCNN.inference": [[177, 215], ["rcnn.GeneralizedRCNN.preprocess_image", "rcnn.GeneralizedRCNN.backbone", "rcnn.GeneralizedRCNN.roi_heads", "rcnn.GeneralizedRCNN.roi_heads.forward_with_given_boxes", "rcnn.GeneralizedRCNN._postprocess", "rcnn.GeneralizedRCNN.proposal_generator", "x.to", "x[].to"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.preprocess_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_head.DensePoseROIHeads.forward_with_given_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch._postprocess", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "inference", "(", "self", ",", "batched_inputs", ",", "detected_instances", "=", "None", ",", "do_postprocess", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Run inference on the given inputs.\n\n        Args:\n            batched_inputs (list[dict]): same as in :meth:`forward`\n            detected_instances (None or list[Instances]): if not None, it\n                contains an `Instances` object per image. The `Instances`\n                object contains \"pred_boxes\" and \"pred_classes\" which are\n                known boxes in the image.\n                The inference will then skip the detection of bounding boxes,\n                and only predict other per-ROI outputs.\n            do_postprocess (bool): whether to apply post-processing on the outputs.\n\n        Returns:\n            same as in :meth:`forward`.\n        \"\"\"", "\n", "assert", "not", "self", ".", "training", "\n", "\n", "images", "=", "self", ".", "preprocess_image", "(", "batched_inputs", ")", "\n", "features", "=", "self", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "\n", "if", "detected_instances", "is", "None", ":", "\n", "            ", "if", "self", ".", "proposal_generator", ":", "\n", "                ", "proposals", ",", "_", "=", "self", ".", "proposal_generator", "(", "images", ",", "features", ",", "None", ")", "\n", "", "else", ":", "\n", "                ", "assert", "\"proposals\"", "in", "batched_inputs", "[", "0", "]", "\n", "proposals", "=", "[", "x", "[", "\"proposals\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "\n", "", "results", ",", "_", "=", "self", ".", "roi_heads", "(", "images", ",", "features", ",", "proposals", ",", "None", ")", "\n", "", "else", ":", "\n", "            ", "detected_instances", "=", "[", "x", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "detected_instances", "]", "\n", "results", "=", "self", ".", "roi_heads", ".", "forward_with_given_boxes", "(", "features", ",", "detected_instances", ")", "\n", "\n", "", "if", "do_postprocess", ":", "\n", "            ", "return", "GeneralizedRCNN", ".", "_postprocess", "(", "results", ",", "batched_inputs", ",", "images", ".", "image_sizes", ")", "\n", "", "else", ":", "\n", "            ", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.rcnn.GeneralizedRCNN.preprocess_image": [[216, 224], ["detectron2.structures.ImageList.from_tensors", "x[].to"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "", "def", "preprocess_image", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Normalize, pad and batch the input images.\n        \"\"\"", "\n", "images", "=", "[", "x", "[", "\"image\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "images", "=", "[", "(", "x", "-", "self", ".", "pixel_mean", ")", "/", "self", ".", "pixel_std", "for", "x", "in", "images", "]", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "self", ".", "backbone", ".", "size_divisibility", ")", "\n", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.rcnn.GeneralizedRCNN._postprocess": [[225, 240], ["zip", "input_per_image.get", "input_per_image.get", "postprocessing.detector_postprocess", "processed_results.append"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.postprocessing.detector_postprocess"], ["", "@", "staticmethod", "\n", "def", "_postprocess", "(", "instances", ",", "batched_inputs", ",", "image_sizes", ")", ":", "\n", "        ", "\"\"\"\n        Rescale the output instances to the target size.\n        \"\"\"", "\n", "# note: private function; subject to changes", "\n", "processed_results", "=", "[", "]", "\n", "for", "results_per_image", ",", "input_per_image", ",", "image_size", "in", "zip", "(", "\n", "instances", ",", "batched_inputs", ",", "image_sizes", "\n", ")", ":", "\n", "            ", "height", "=", "input_per_image", ".", "get", "(", "\"height\"", ",", "image_size", "[", "0", "]", ")", "\n", "width", "=", "input_per_image", ".", "get", "(", "\"width\"", ",", "image_size", "[", "1", "]", ")", "\n", "r", "=", "detector_postprocess", "(", "results_per_image", ",", "height", ",", "width", ")", "\n", "processed_results", ".", "append", "(", "{", "\"instances\"", ":", "r", "}", ")", "\n", "", "return", "processed_results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.rcnn.ProposalNetwork.__init__": [[248, 255], ["torch.nn.Module.__init__", "backbone.build_backbone", "proposal_generator.build_proposal_generator", "rcnn.ProposalNetwork.register_buffer", "rcnn.ProposalNetwork.register_buffer", "rcnn.ProposalNetwork.backbone.output_shape", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.build.build_proposal_generator", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.backbone.Backbone.output_shape"], ["def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "self", ".", "proposal_generator", "=", "build_proposal_generator", "(", "cfg", ",", "self", ".", "backbone", ".", "output_shape", "(", ")", ")", "\n", "\n", "self", ".", "register_buffer", "(", "\"pixel_mean\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_MEAN", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_std\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_STD", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.rcnn.ProposalNetwork.device": [[256, 259], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "pixel_mean", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.rcnn.ProposalNetwork.forward": [[260, 300], ["detectron2.structures.ImageList.from_tensors", "rcnn.ProposalNetwork.backbone", "rcnn.ProposalNetwork.proposal_generator", "zip", "x[].to", "input_per_image.get", "input_per_image.get", "postprocessing.detector_postprocess", "processed_results.append", "x[].to", "detectron2.utils.logger.log_first_n", "x[].to"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.postprocessing.detector_postprocess", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.log_first_n", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "forward", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            Same as in :class:`GeneralizedRCNN.forward`\n\n        Returns:\n            list[dict]:\n                Each dict is the output for one input image.\n                The dict contains one key \"proposals\" whose value is a\n                :class:`Instances` with keys \"proposal_boxes\" and \"objectness_logits\".\n        \"\"\"", "\n", "images", "=", "[", "x", "[", "\"image\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "images", "=", "[", "(", "x", "-", "self", ".", "pixel_mean", ")", "/", "self", ".", "pixel_std", "for", "x", "in", "images", "]", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "self", ".", "backbone", ".", "size_divisibility", ")", "\n", "features", "=", "self", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "\n", "if", "\"instances\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "gt_instances", "=", "[", "x", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "", "elif", "\"targets\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "log_first_n", "(", "\n", "logging", ".", "WARN", ",", "\"'targets' in the model inputs is now renamed to 'instances'!\"", ",", "n", "=", "10", "\n", ")", "\n", "gt_instances", "=", "[", "x", "[", "\"targets\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "", "else", ":", "\n", "            ", "gt_instances", "=", "None", "\n", "", "proposals", ",", "proposal_losses", "=", "self", ".", "proposal_generator", "(", "images", ",", "features", ",", "gt_instances", ")", "\n", "# In training, the proposals are not useful at all but we generate them anyway.", "\n", "# This makes RPN-only models about 5% slower.", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "proposal_losses", "\n", "\n", "", "processed_results", "=", "[", "]", "\n", "for", "results_per_image", ",", "input_per_image", ",", "image_size", "in", "zip", "(", "\n", "proposals", ",", "batched_inputs", ",", "images", ".", "image_sizes", "\n", ")", ":", "\n", "            ", "height", "=", "input_per_image", ".", "get", "(", "\"height\"", ",", "image_size", "[", "0", "]", ")", "\n", "width", "=", "input_per_image", ".", "get", "(", "\"width\"", ",", "image_size", "[", "1", "]", ")", "\n", "r", "=", "detector_postprocess", "(", "results_per_image", ",", "height", ",", "width", ")", "\n", "processed_results", ".", "append", "(", "{", "\"proposals\"", ":", "r", "}", ")", "\n", "", "return", "processed_results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.RetinaNet.__init__": [[45, 91], ["torch.nn.Module.__init__", "backbone.build_backbone", "retinanet.RetinaNet.backbone.output_shape", "retinanet.RetinaNetHead", "anchor_generator.build_anchor_generator", "box_regression.Box2BoxTransform", "matcher.Matcher", "retinanet.RetinaNet.register_buffer", "retinanet.RetinaNet.register_buffer", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.backbone.Backbone.output_shape", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.build_anchor_generator"], ["def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "# fmt: off", "\n", "self", ".", "num_classes", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "NUM_CLASSES", "\n", "self", ".", "in_features", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "IN_FEATURES", "\n", "# Loss parameters:", "\n", "self", ".", "focal_loss_alpha", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "FOCAL_LOSS_ALPHA", "\n", "self", ".", "focal_loss_gamma", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "FOCAL_LOSS_GAMMA", "\n", "self", ".", "smooth_l1_loss_beta", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "SMOOTH_L1_LOSS_BETA", "\n", "self", ".", "box_reg_loss_type", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "BBOX_REG_LOSS_TYPE", "\n", "# Inference parameters:", "\n", "self", ".", "score_threshold", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "SCORE_THRESH_TEST", "\n", "self", ".", "topk_candidates", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "TOPK_CANDIDATES_TEST", "\n", "self", ".", "nms_threshold", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "NMS_THRESH_TEST", "\n", "self", ".", "max_detections_per_image", "=", "cfg", ".", "TEST", ".", "DETECTIONS_PER_IMAGE", "\n", "# Vis parameters", "\n", "self", ".", "vis_period", "=", "cfg", ".", "VIS_PERIOD", "\n", "self", ".", "input_format", "=", "cfg", ".", "INPUT", ".", "FORMAT", "\n", "# fmt: on", "\n", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "\n", "backbone_shape", "=", "self", ".", "backbone", ".", "output_shape", "(", ")", "\n", "feature_shapes", "=", "[", "backbone_shape", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", "\n", "self", ".", "head", "=", "RetinaNetHead", "(", "cfg", ",", "feature_shapes", ")", "\n", "self", ".", "anchor_generator", "=", "build_anchor_generator", "(", "cfg", ",", "feature_shapes", ")", "\n", "\n", "# Matching and loss", "\n", "self", ".", "box2box_transform", "=", "Box2BoxTransform", "(", "weights", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "BBOX_REG_WEIGHTS", ")", "\n", "self", ".", "anchor_matcher", "=", "Matcher", "(", "\n", "cfg", ".", "MODEL", ".", "RETINANET", ".", "IOU_THRESHOLDS", ",", "\n", "cfg", ".", "MODEL", ".", "RETINANET", ".", "IOU_LABELS", ",", "\n", "allow_low_quality_matches", "=", "True", ",", "\n", ")", "\n", "\n", "self", ".", "register_buffer", "(", "\"pixel_mean\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_MEAN", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_std\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_STD", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "\n", "\"\"\"\n        In Detectron1, loss is normalized by number of foreground samples in the batch.\n        When batch size is 1 per GPU, #foreground has a large variance and\n        using it lead to lower performance. Here we maintain an EMA of #foreground to\n        stabilize the normalizer.\n        \"\"\"", "\n", "self", ".", "loss_normalizer", "=", "100", "# initialize with any reasonable #fg that's not too small", "\n", "self", ".", "loss_normalizer_momentum", "=", "0.9", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.RetinaNet.device": [[92, 95], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "pixel_mean", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.RetinaNet.visualize_training": [[96, 130], ["detectron2.utils.events.get_event_storage", "detectron2.data.detection_utils.convert_image_to_rgb", "Visualizer", "v_gt.overlay_instances.overlay_instances.overlay_instances", "v_gt.overlay_instances.overlay_instances.get_image", "postprocessing.detector_postprocess", "postprocessing.detector_postprocess.pred_boxes.tensor.detach().cpu().numpy", "Visualizer", "v_pred.overlay_instances.overlay_instances.overlay_instances", "v_pred.overlay_instances.overlay_instances.get_image", "numpy.vstack", "vis_img.transpose.transpose.transpose", "detectron2.utils.events.get_event_storage.put_image", "len", "len", "detectron2.data.detection_utils.convert_image_to_rgb.permute", "postprocessing.detector_postprocess.pred_boxes.tensor.detach().cpu", "postprocessing.detector_postprocess.pred_boxes.tensor.detach"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.get_event_storage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.get_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.postprocessing.detector_postprocess", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.get_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_image"], ["", "def", "visualize_training", "(", "self", ",", "batched_inputs", ",", "results", ")", ":", "\n", "        ", "\"\"\"\n        A function used to visualize ground truth images and final network predictions.\n        It shows ground truth bounding boxes on the original image and up to 20\n        predicted object bounding boxes on the original image.\n\n        Args:\n            batched_inputs (list): a list that contains input to the model.\n            results (List[Instances]): a list of #images elements.\n        \"\"\"", "\n", "from", "detectron2", ".", "utils", ".", "visualizer", "import", "Visualizer", "\n", "\n", "assert", "len", "(", "batched_inputs", ")", "==", "len", "(", "\n", "results", "\n", ")", ",", "\"Cannot visualize inputs and results of different sizes\"", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "max_boxes", "=", "20", "\n", "\n", "image_index", "=", "0", "# only visualize a single image", "\n", "img", "=", "batched_inputs", "[", "image_index", "]", "[", "\"image\"", "]", "\n", "img", "=", "convert_image_to_rgb", "(", "img", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ",", "self", ".", "input_format", ")", "\n", "v_gt", "=", "Visualizer", "(", "img", ",", "None", ")", "\n", "v_gt", "=", "v_gt", ".", "overlay_instances", "(", "boxes", "=", "batched_inputs", "[", "image_index", "]", "[", "\"instances\"", "]", ".", "gt_boxes", ")", "\n", "anno_img", "=", "v_gt", ".", "get_image", "(", ")", "\n", "processed_results", "=", "detector_postprocess", "(", "results", "[", "image_index", "]", ",", "img", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "1", "]", ")", "\n", "predicted_boxes", "=", "processed_results", ".", "pred_boxes", ".", "tensor", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "v_pred", "=", "Visualizer", "(", "img", ",", "None", ")", "\n", "v_pred", "=", "v_pred", ".", "overlay_instances", "(", "boxes", "=", "predicted_boxes", "[", "0", ":", "max_boxes", "]", ")", "\n", "prop_img", "=", "v_pred", ".", "get_image", "(", ")", "\n", "vis_img", "=", "np", ".", "vstack", "(", "(", "anno_img", ",", "prop_img", ")", ")", "\n", "vis_img", "=", "vis_img", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", "\n", "vis_name", "=", "f\"Top: GT bounding boxes; Bottom: {max_boxes} Highest Scoring Results\"", "\n", "storage", ".", "put_image", "(", "vis_name", ",", "vis_img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.RetinaNet.forward": [[131, 186], ["retinanet.RetinaNet.preprocess_image", "retinanet.RetinaNet.backbone", "retinanet.RetinaNet.anchor_generator", "retinanet.RetinaNet.head", "retinanet.permute_to_N_HWA_K", "retinanet.permute_to_N_HWA_K", "retinanet.RetinaNet.label_anchors", "retinanet.RetinaNet.losses", "retinanet.RetinaNet.inference", "zip", "x[].to", "detectron2.utils.events.get_event_storage", "input_per_image.get", "input_per_image.get", "postprocessing.detector_postprocess", "processed_results.append", "retinanet.RetinaNet.inference", "retinanet.RetinaNet.visualize_training"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.preprocess_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.permute_to_N_HWA_K", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.permute_to_N_HWA_K", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.RetinaNet.label_anchors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3Head.losses", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.inference", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.get_event_storage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.postprocessing.detector_postprocess", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.inference", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.RetinaNet.visualize_training"], ["", "def", "forward", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            batched_inputs: a list, batched outputs of :class:`DatasetMapper` .\n                Each item in the list contains the inputs for one image.\n                For now, each item in the list is a dict that contains:\n\n                * image: Tensor, image in (C, H, W) format.\n                * instances: Instances\n\n                Other information that's included in the original dicts, such as:\n\n                * \"height\", \"width\" (int): the output resolution of the model, used in inference.\n                  See :meth:`postprocess` for details.\n        Returns:\n            dict[str: Tensor]:\n                mapping from a named loss to a tensor storing the loss. Used during training only.\n        \"\"\"", "\n", "images", "=", "self", ".", "preprocess_image", "(", "batched_inputs", ")", "\n", "features", "=", "self", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", "\n", "\n", "anchors", "=", "self", ".", "anchor_generator", "(", "features", ")", "\n", "pred_logits", ",", "pred_anchor_deltas", "=", "self", ".", "head", "(", "features", ")", "\n", "# Transpose the Hi*Wi*A dimension to the middle:", "\n", "pred_logits", "=", "[", "permute_to_N_HWA_K", "(", "x", ",", "self", ".", "num_classes", ")", "for", "x", "in", "pred_logits", "]", "\n", "pred_anchor_deltas", "=", "[", "permute_to_N_HWA_K", "(", "x", ",", "4", ")", "for", "x", "in", "pred_anchor_deltas", "]", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "assert", "\"instances\"", "in", "batched_inputs", "[", "0", "]", ",", "\"Instance annotations are missing in training!\"", "\n", "gt_instances", "=", "[", "x", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "\n", "gt_labels", ",", "gt_boxes", "=", "self", ".", "label_anchors", "(", "anchors", ",", "gt_instances", ")", "\n", "losses", "=", "self", ".", "losses", "(", "anchors", ",", "pred_logits", ",", "gt_labels", ",", "pred_anchor_deltas", ",", "gt_boxes", ")", "\n", "\n", "if", "self", ".", "vis_period", ">", "0", ":", "\n", "                ", "storage", "=", "get_event_storage", "(", ")", "\n", "if", "storage", ".", "iter", "%", "self", ".", "vis_period", "==", "0", ":", "\n", "                    ", "results", "=", "self", ".", "inference", "(", "\n", "anchors", ",", "pred_logits", ",", "pred_anchor_deltas", ",", "images", ".", "image_sizes", "\n", ")", "\n", "self", ".", "visualize_training", "(", "batched_inputs", ",", "results", ")", "\n", "\n", "", "", "return", "losses", "\n", "", "else", ":", "\n", "            ", "results", "=", "self", ".", "inference", "(", "anchors", ",", "pred_logits", ",", "pred_anchor_deltas", ",", "images", ".", "image_sizes", ")", "\n", "processed_results", "=", "[", "]", "\n", "for", "results_per_image", ",", "input_per_image", ",", "image_size", "in", "zip", "(", "\n", "results", ",", "batched_inputs", ",", "images", ".", "image_sizes", "\n", ")", ":", "\n", "                ", "height", "=", "input_per_image", ".", "get", "(", "\"height\"", ",", "image_size", "[", "0", "]", ")", "\n", "width", "=", "input_per_image", ".", "get", "(", "\"width\"", ",", "image_size", "[", "1", "]", ")", "\n", "r", "=", "detector_postprocess", "(", "results_per_image", ",", "height", ",", "width", ")", "\n", "processed_results", ".", "append", "(", "{", "\"instances\"", ":", "r", "}", ")", "\n", "", "return", "processed_results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.RetinaNet.losses": [[187, 251], ["len", "torch.stack", "torch.stack", "pos_mask.sum().item", "detectron2.utils.events.get_event_storage().put_scalar", "fvcore.nn.sigmoid_focal_loss_jit", "type().cat", "retinanet.RetinaNet.box2box_transform.get_deltas", "torch.nn.functional.one_hot", "gt_labels_target.to", "fvcore.nn.smooth_l1_loss", "pos_mask.sum", "detectron2.utils.events.get_event_storage", "max", "detectron2.layers.cat", "fvcore.nn.giou_loss", "ValueError", "type", "detectron2.layers.cat", "retinanet.RetinaNet.box2box_transform.apply_deltas", "detectron2.layers.cat", "torch.stack", "torch.stack"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.box_regression.Box2BoxTransformRotated.get_deltas", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.get_event_storage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.box_regression.Box2BoxTransformRotated.apply_deltas", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "", "def", "losses", "(", "self", ",", "anchors", ",", "pred_logits", ",", "gt_labels", ",", "pred_anchor_deltas", ",", "gt_boxes", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            anchors (list[Boxes]): a list of #feature level Boxes\n            gt_labels, gt_boxes: see output of :meth:`RetinaNet.label_anchors`.\n                Their shapes are (N, R) and (N, R, 4), respectively, where R is\n                the total number of anchors across levels, i.e. sum(Hi x Wi x Ai)\n            pred_logits, pred_anchor_deltas: both are list[Tensor]. Each element in the\n                list corresponds to one level and has shape (N, Hi * Wi * Ai, K or 4).\n                Where K is the number of classes used in `pred_logits`.\n\n        Returns:\n            dict[str, Tensor]:\n                mapping from a named loss to a scalar tensor\n                storing the loss. Used during training only. The dict keys are:\n                \"loss_cls\" and \"loss_box_reg\"\n        \"\"\"", "\n", "num_images", "=", "len", "(", "gt_labels", ")", "\n", "gt_labels", "=", "torch", ".", "stack", "(", "gt_labels", ")", "# (N, R)", "\n", "anchors", "=", "type", "(", "anchors", "[", "0", "]", ")", ".", "cat", "(", "anchors", ")", ".", "tensor", "# (R, 4)", "\n", "gt_anchor_deltas", "=", "[", "self", ".", "box2box_transform", ".", "get_deltas", "(", "anchors", ",", "k", ")", "for", "k", "in", "gt_boxes", "]", "\n", "gt_anchor_deltas", "=", "torch", ".", "stack", "(", "gt_anchor_deltas", ")", "# (N, R, 4)", "\n", "\n", "valid_mask", "=", "gt_labels", ">=", "0", "\n", "pos_mask", "=", "(", "gt_labels", ">=", "0", ")", "&", "(", "gt_labels", "!=", "self", ".", "num_classes", ")", "\n", "num_pos_anchors", "=", "pos_mask", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "get_event_storage", "(", ")", ".", "put_scalar", "(", "\"num_pos_anchors\"", ",", "num_pos_anchors", "/", "num_images", ")", "\n", "self", ".", "loss_normalizer", "=", "self", ".", "loss_normalizer_momentum", "*", "self", ".", "loss_normalizer", "+", "(", "\n", "1", "-", "self", ".", "loss_normalizer_momentum", "\n", ")", "*", "max", "(", "num_pos_anchors", ",", "1", ")", "\n", "\n", "# classification and regression loss", "\n", "gt_labels_target", "=", "F", ".", "one_hot", "(", "gt_labels", "[", "valid_mask", "]", ",", "num_classes", "=", "self", ".", "num_classes", "+", "1", ")", "[", "\n", ":", ",", ":", "-", "1", "\n", "]", "# no loss for the last (background) class", "\n", "loss_cls", "=", "sigmoid_focal_loss_jit", "(", "\n", "cat", "(", "pred_logits", ",", "dim", "=", "1", ")", "[", "valid_mask", "]", ",", "\n", "gt_labels_target", ".", "to", "(", "pred_logits", "[", "0", "]", ".", "dtype", ")", ",", "\n", "alpha", "=", "self", ".", "focal_loss_alpha", ",", "\n", "gamma", "=", "self", ".", "focal_loss_gamma", ",", "\n", "reduction", "=", "\"sum\"", ",", "\n", ")", "\n", "\n", "if", "self", ".", "box_reg_loss_type", "==", "\"smooth_l1\"", ":", "\n", "            ", "loss_box_reg", "=", "smooth_l1_loss", "(", "\n", "cat", "(", "pred_anchor_deltas", ",", "dim", "=", "1", ")", "[", "pos_mask", "]", ",", "\n", "gt_anchor_deltas", "[", "pos_mask", "]", ",", "\n", "beta", "=", "self", ".", "smooth_l1_loss_beta", ",", "\n", "reduction", "=", "\"sum\"", ",", "\n", ")", "\n", "", "elif", "self", ".", "box_reg_loss_type", "==", "\"giou\"", ":", "\n", "            ", "pred_boxes", "=", "[", "\n", "self", ".", "box2box_transform", ".", "apply_deltas", "(", "k", ",", "anchors", ")", "\n", "for", "k", "in", "cat", "(", "pred_anchor_deltas", ",", "dim", "=", "1", ")", "\n", "]", "\n", "loss_box_reg", "=", "giou_loss", "(", "\n", "torch", ".", "stack", "(", "pred_boxes", ")", "[", "pos_mask", "]", ",", "torch", ".", "stack", "(", "gt_boxes", ")", "[", "pos_mask", "]", ",", "reduction", "=", "\"sum\"", "\n", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Invalid bbox reg loss type '{self.box_reg_loss_type}'\"", ")", "\n", "\n", "", "return", "{", "\n", "\"loss_cls\"", ":", "loss_cls", "/", "self", ".", "loss_normalizer", ",", "\n", "\"loss_box_reg\"", ":", "loss_box_reg", "/", "self", ".", "loss_normalizer", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.RetinaNet.label_anchors": [[253, 298], ["torch.no_grad", "detectron2.structures.Boxes.cat", "detectron2.structures.pairwise_iou", "retinanet.RetinaNet.anchor_matcher", "gt_labels.append", "matched_gt_boxes.append", "len", "torch.zeros_like", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.pairwise_iou"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "label_anchors", "(", "self", ",", "anchors", ",", "gt_instances", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            anchors (list[Boxes]): A list of #feature level Boxes.\n                The Boxes contains anchors of this image on the specific feature level.\n            gt_instances (list[Instances]): a list of N `Instances`s. The i-th\n                `Instances` contains the ground-truth per-instance annotations\n                for the i-th input image.\n\n        Returns:\n            list[Tensor]:\n                List of #img tensors. i-th element is a vector of labels whose length is\n                the total number of anchors across all feature maps (sum(Hi * Wi * A)).\n                Label values are in {-1, 0, ..., K}, with -1 means ignore, and K means background.\n            list[Tensor]:\n                i-th element is a Rx4 tensor, where R is the total number of anchors across\n                feature maps. The values are the matched gt boxes for each anchor.\n                Values are undefined for those anchors not labeled as foreground.\n        \"\"\"", "\n", "anchors", "=", "Boxes", ".", "cat", "(", "anchors", ")", "# Rx4", "\n", "\n", "gt_labels", "=", "[", "]", "\n", "matched_gt_boxes", "=", "[", "]", "\n", "for", "gt_per_image", "in", "gt_instances", ":", "\n", "            ", "match_quality_matrix", "=", "pairwise_iou", "(", "gt_per_image", ".", "gt_boxes", ",", "anchors", ")", "\n", "matched_idxs", ",", "anchor_labels", "=", "self", ".", "anchor_matcher", "(", "match_quality_matrix", ")", "\n", "del", "match_quality_matrix", "\n", "\n", "if", "len", "(", "gt_per_image", ")", ">", "0", ":", "\n", "                ", "matched_gt_boxes_i", "=", "gt_per_image", ".", "gt_boxes", ".", "tensor", "[", "matched_idxs", "]", "\n", "\n", "gt_labels_i", "=", "gt_per_image", ".", "gt_classes", "[", "matched_idxs", "]", "\n", "# Anchors with label 0 are treated as background.", "\n", "gt_labels_i", "[", "anchor_labels", "==", "0", "]", "=", "self", ".", "num_classes", "\n", "# Anchors with label -1 are ignored.", "\n", "gt_labels_i", "[", "anchor_labels", "==", "-", "1", "]", "=", "-", "1", "\n", "", "else", ":", "\n", "                ", "matched_gt_boxes_i", "=", "torch", ".", "zeros_like", "(", "anchors", ".", "tensor", ")", "\n", "gt_labels_i", "=", "torch", ".", "zeros_like", "(", "matched_idxs", ")", "+", "self", ".", "num_classes", "\n", "\n", "", "gt_labels", ".", "append", "(", "gt_labels_i", ")", "\n", "matched_gt_boxes", ".", "append", "(", "matched_gt_boxes_i", ")", "\n", "\n", "", "return", "gt_labels", ",", "matched_gt_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.RetinaNet.inference": [[299, 320], ["enumerate", "retinanet.RetinaNet.inference_single_image", "results.append", "tuple"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.inference_single_image"], ["", "def", "inference", "(", "self", ",", "anchors", ",", "pred_logits", ",", "pred_anchor_deltas", ",", "image_sizes", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            anchors (list[Boxes]): A list of #feature level Boxes.\n                The Boxes contain anchors of this image on the specific feature level.\n            pred_logits, pred_anchor_deltas: list[Tensor], one per level. Each\n                has shape (N, Hi * Wi * Ai, K or 4)\n            image_sizes (List[torch.Size]): the input image sizes\n\n        Returns:\n            results (List[Instances]): a list of #images elements.\n        \"\"\"", "\n", "results", "=", "[", "]", "\n", "for", "img_idx", ",", "image_size", "in", "enumerate", "(", "image_sizes", ")", ":", "\n", "            ", "pred_logits_per_image", "=", "[", "x", "[", "img_idx", "]", "for", "x", "in", "pred_logits", "]", "\n", "deltas_per_image", "=", "[", "x", "[", "img_idx", "]", "for", "x", "in", "pred_anchor_deltas", "]", "\n", "results_per_image", "=", "self", ".", "inference_single_image", "(", "\n", "anchors", ",", "pred_logits_per_image", ",", "deltas_per_image", ",", "tuple", "(", "image_size", ")", "\n", ")", "\n", "results", ".", "append", "(", "results_per_image", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.RetinaNet.inference_single_image": [[321, 382], ["zip", "detectron2.layers.batched_nms", "detectron2.structures.Instances", "detectron2.structures.Boxes", "box_cls_i.flatten().sigmoid_", "min", "box_cls_i.flatten().sigmoid_.sort", "retinanet.RetinaNet.box2box_transform.apply_deltas", "boxes_all.append", "scores_all.append", "class_idxs_all.append", "detectron2.layers.cat", "torch.nonzero", "topk_idxs.size", "box_cls_i.flatten"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.batched_nms", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.box_regression.Box2BoxTransformRotated.apply_deltas", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten"], ["", "def", "inference_single_image", "(", "self", ",", "anchors", ",", "box_cls", ",", "box_delta", ",", "image_size", ")", ":", "\n", "        ", "\"\"\"\n        Single-image inference. Return bounding-box detection results by thresholding\n        on scores and applying non-maximum suppression (NMS).\n\n        Arguments:\n            anchors (list[Boxes]): list of #feature levels. Each entry contains\n                a Boxes object, which contains all the anchors in that feature level.\n            box_cls (list[Tensor]): list of #feature levels. Each entry contains\n                tensor of size (H x W x A, K)\n            box_delta (list[Tensor]): Same shape as 'box_cls' except that K becomes 4.\n            image_size (tuple(H, W)): a tuple of the image height and width.\n\n        Returns:\n            Same as `inference`, but for only one image.\n        \"\"\"", "\n", "boxes_all", "=", "[", "]", "\n", "scores_all", "=", "[", "]", "\n", "class_idxs_all", "=", "[", "]", "\n", "\n", "# Iterate over every feature level", "\n", "for", "box_cls_i", ",", "box_reg_i", ",", "anchors_i", "in", "zip", "(", "box_cls", ",", "box_delta", ",", "anchors", ")", ":", "\n", "# (HxWxAxK,)", "\n", "            ", "predicted_prob", "=", "box_cls_i", ".", "flatten", "(", ")", ".", "sigmoid_", "(", ")", "\n", "\n", "# Apply two filtering below to make NMS faster.", "\n", "# 1. Keep boxes with confidence score higher than threshold", "\n", "keep_idxs", "=", "predicted_prob", ">", "self", ".", "score_threshold", "\n", "predicted_prob", "=", "predicted_prob", "[", "keep_idxs", "]", "\n", "topk_idxs", "=", "torch", ".", "nonzero", "(", "keep_idxs", ",", "as_tuple", "=", "True", ")", "[", "0", "]", "\n", "\n", "# 2. Keep top k top scoring boxes only", "\n", "num_topk", "=", "min", "(", "self", ".", "topk_candidates", ",", "topk_idxs", ".", "size", "(", "0", ")", ")", "\n", "# torch.sort is actually faster than .topk (at least on GPUs)", "\n", "predicted_prob", ",", "idxs", "=", "predicted_prob", ".", "sort", "(", "descending", "=", "True", ")", "\n", "predicted_prob", "=", "predicted_prob", "[", ":", "num_topk", "]", "\n", "topk_idxs", "=", "topk_idxs", "[", "idxs", "[", ":", "num_topk", "]", "]", "\n", "\n", "anchor_idxs", "=", "topk_idxs", "//", "self", ".", "num_classes", "\n", "classes_idxs", "=", "topk_idxs", "%", "self", ".", "num_classes", "\n", "\n", "box_reg_i", "=", "box_reg_i", "[", "anchor_idxs", "]", "\n", "anchors_i", "=", "anchors_i", "[", "anchor_idxs", "]", "\n", "# predict boxes", "\n", "predicted_boxes", "=", "self", ".", "box2box_transform", ".", "apply_deltas", "(", "box_reg_i", ",", "anchors_i", ".", "tensor", ")", "\n", "\n", "boxes_all", ".", "append", "(", "predicted_boxes", ")", "\n", "scores_all", ".", "append", "(", "predicted_prob", ")", "\n", "class_idxs_all", ".", "append", "(", "classes_idxs", ")", "\n", "\n", "", "boxes_all", ",", "scores_all", ",", "class_idxs_all", "=", "[", "\n", "cat", "(", "x", ")", "for", "x", "in", "[", "boxes_all", ",", "scores_all", ",", "class_idxs_all", "]", "\n", "]", "\n", "keep", "=", "batched_nms", "(", "boxes_all", ",", "scores_all", ",", "class_idxs_all", ",", "self", ".", "nms_threshold", ")", "\n", "keep", "=", "keep", "[", ":", "self", ".", "max_detections_per_image", "]", "\n", "\n", "result", "=", "Instances", "(", "image_size", ")", "\n", "result", ".", "pred_boxes", "=", "Boxes", "(", "boxes_all", "[", "keep", "]", ")", "\n", "result", ".", "scores", "=", "scores_all", "[", "keep", "]", "\n", "result", ".", "pred_classes", "=", "class_idxs_all", "[", "keep", "]", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.RetinaNet.preprocess_image": [[383, 391], ["detectron2.structures.ImageList.from_tensors", "x[].to"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "preprocess_image", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Normalize, pad and batch the input images.\n        \"\"\"", "\n", "images", "=", "[", "x", "[", "\"image\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "images", "=", "[", "(", "x", "-", "self", ".", "pixel_mean", ")", "/", "self", ".", "pixel_std", "for", "x", "in", "images", "]", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "self", ".", "backbone", ".", "size_divisibility", ")", "\n", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.RetinaNetHead.__init__": [[399, 464], ["torch.nn.Module.__init__", "zip", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.init.constant_", "logging.getLogger", "logging.getLogger.warn", "cls_subnet.append", "cls_subnet.append", "bbox_subnet.append", "bbox_subnet.append", "modules.modules", "math.log", "torch.nn.Conv2d", "cls_subnet.append", "torch.nn.ReLU", "torch.nn.Conv2d", "bbox_subnet.append", "torch.nn.ReLU", "isinstance", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "torch.nn.init.normal_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "*", ",", "\n", "input_shape", ":", "List", "[", "ShapeSpec", "]", ",", "\n", "num_classes", ",", "\n", "num_anchors", ",", "\n", "conv_dims", ":", "List", "[", "int", "]", ",", "\n", "norm", "=", "\"\"", ",", "\n", "prior_prob", "=", "0.01", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            input_shape (List[ShapeSpec]): input shape\n            num_classes (int): number of classes. Used to label background proposals.\n            num_anchors (int): number of generated anchors\n            conv_dims (List[int]): dimensions for each convolution layer\n            norm (str or callable):\n                    Normalization for conv layers except for the two output layers.\n                    See :func:`detectron2.layers.get_norm` for supported types.\n            prior_prob (float): Prior weight for computing bias\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "norm", "==", "\"BN\"", "or", "norm", "==", "\"SyncBN\"", ":", "\n", "            ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warn", "(", "\"Shared norm does not work well for BN, SyncBN, expect poor results\"", ")", "\n", "\n", "", "cls_subnet", "=", "[", "]", "\n", "bbox_subnet", "=", "[", "]", "\n", "for", "in_channels", ",", "out_channels", "in", "zip", "(", "[", "input_shape", "[", "0", "]", ".", "channels", "]", "+", "conv_dims", ",", "conv_dims", ")", ":", "\n", "            ", "cls_subnet", ".", "append", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", ")", "\n", "if", "norm", ":", "\n", "                ", "cls_subnet", ".", "append", "(", "get_norm", "(", "norm", ",", "out_channels", ")", ")", "\n", "", "cls_subnet", ".", "append", "(", "nn", ".", "ReLU", "(", ")", ")", "\n", "bbox_subnet", ".", "append", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", ")", "\n", "if", "norm", ":", "\n", "                ", "bbox_subnet", ".", "append", "(", "get_norm", "(", "norm", ",", "out_channels", ")", ")", "\n", "", "bbox_subnet", ".", "append", "(", "nn", ".", "ReLU", "(", ")", ")", "\n", "\n", "", "self", ".", "cls_subnet", "=", "nn", ".", "Sequential", "(", "*", "cls_subnet", ")", "\n", "self", ".", "bbox_subnet", "=", "nn", ".", "Sequential", "(", "*", "bbox_subnet", ")", "\n", "self", ".", "cls_score", "=", "nn", ".", "Conv2d", "(", "\n", "conv_dims", "[", "-", "1", "]", ",", "num_anchors", "*", "num_classes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", "\n", ")", "\n", "self", ".", "bbox_pred", "=", "nn", ".", "Conv2d", "(", "\n", "conv_dims", "[", "-", "1", "]", ",", "num_anchors", "*", "4", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", "\n", ")", "\n", "\n", "# Initialization", "\n", "for", "modules", "in", "[", "self", ".", "cls_subnet", ",", "self", ".", "bbox_subnet", ",", "self", ".", "cls_score", ",", "self", ".", "bbox_pred", "]", ":", "\n", "            ", "for", "layer", "in", "modules", ".", "modules", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "layer", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                    ", "torch", ".", "nn", ".", "init", ".", "normal_", "(", "layer", ".", "weight", ",", "mean", "=", "0", ",", "std", "=", "0.01", ")", "\n", "torch", ".", "nn", ".", "init", ".", "constant_", "(", "layer", ".", "bias", ",", "0", ")", "\n", "\n", "# Use prior in model initialization to improve stability", "\n", "", "", "", "bias_value", "=", "-", "(", "math", ".", "log", "(", "(", "1", "-", "prior_prob", ")", "/", "prior_prob", ")", ")", "\n", "torch", ".", "nn", ".", "init", ".", "constant_", "(", "self", ".", "cls_score", ".", "bias", ",", "bias_value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.RetinaNetHead.from_config": [[465, 481], ["anchor_generator.build_anchor_generator", "len", "set"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.build_anchor_generator", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ":", "List", "[", "ShapeSpec", "]", ")", ":", "\n", "        ", "num_anchors", "=", "build_anchor_generator", "(", "cfg", ",", "input_shape", ")", ".", "num_cell_anchors", "\n", "# fmt: on", "\n", "assert", "(", "\n", "len", "(", "set", "(", "num_anchors", ")", ")", "==", "1", "\n", ")", ",", "\"Using different number of anchors between levels is not currently supported!\"", "\n", "num_anchors", "=", "num_anchors", "[", "0", "]", "\n", "\n", "return", "{", "\n", "\"input_shape\"", ":", "input_shape", ",", "\n", "\"num_classes\"", ":", "cfg", ".", "MODEL", ".", "RETINANET", ".", "NUM_CLASSES", ",", "\n", "\"conv_dims\"", ":", "[", "input_shape", "[", "0", "]", ".", "channels", "]", "*", "cfg", ".", "MODEL", ".", "RETINANET", ".", "NUM_CONVS", ",", "\n", "\"prior_prob\"", ":", "cfg", ".", "MODEL", ".", "RETINANET", ".", "PRIOR_PROB", ",", "\n", "\"norm\"", ":", "cfg", ".", "MODEL", ".", "RETINANET", ".", "NORM", ",", "\n", "\"num_anchors\"", ":", "num_anchors", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.RetinaNetHead.forward": [[483, 505], ["logits.append", "bbox_reg.append", "retinanet.RetinaNetHead.cls_score", "retinanet.RetinaNetHead.bbox_pred", "retinanet.RetinaNetHead.cls_subnet", "retinanet.RetinaNetHead.bbox_subnet"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "features", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            features (list[Tensor]): FPN feature map tensors in high to low resolution.\n                Each tensor in the list correspond to different feature levels.\n\n        Returns:\n            logits (list[Tensor]): #lvl tensors, each has shape (N, AxK, Hi, Wi).\n                The tensor predicts the classification probability\n                at each spatial position for each of the A anchors and K object\n                classes.\n            bbox_reg (list[Tensor]): #lvl tensors, each has shape (N, Ax4, Hi, Wi).\n                The tensor predicts 4-vector (dx,dy,dw,dh) box\n                regression values for every anchor. These values are the\n                relative offset between the anchor and the ground truth box.\n        \"\"\"", "\n", "logits", "=", "[", "]", "\n", "bbox_reg", "=", "[", "]", "\n", "for", "feature", "in", "features", ":", "\n", "            ", "logits", ".", "append", "(", "self", ".", "cls_score", "(", "self", ".", "cls_subnet", "(", "feature", ")", ")", ")", "\n", "bbox_reg", ".", "append", "(", "self", ".", "bbox_pred", "(", "self", ".", "bbox_subnet", "(", "feature", ")", ")", ")", "\n", "", "return", "logits", ",", "bbox_reg", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.permute_to_N_HWA_K": [[27, 37], ["tensor.reshape.view", "tensor.reshape.permute", "tensor.reshape.reshape", "tensor.reshape.dim"], "function", ["None"], ["def", "permute_to_N_HWA_K", "(", "tensor", ",", "K", ")", ":", "\n", "    ", "\"\"\"\n    Transpose/reshape a tensor from (N, (Ai x K), H, W) to (N, (HxWxAi), K)\n    \"\"\"", "\n", "assert", "tensor", ".", "dim", "(", ")", "==", "4", ",", "tensor", ".", "shape", "\n", "N", ",", "_", ",", "H", ",", "W", "=", "tensor", ".", "shape", "\n", "tensor", "=", "tensor", ".", "view", "(", "N", ",", "-", "1", ",", "K", ",", "H", ",", "W", ")", "\n", "tensor", "=", "tensor", ".", "permute", "(", "0", ",", "3", ",", "4", ",", "1", ",", "2", ")", "\n", "tensor", "=", "tensor", ".", "reshape", "(", "N", ",", "-", "1", ",", "K", ")", "# Size=(N,HWA,K)", "\n", "return", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.build.build_model": [[15, 24], ["model.to", "META_ARCH_REGISTRY.get", "torch.device"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device"], ["def", "build_model", "(", "cfg", ")", ":", "\n", "    ", "\"\"\"\n    Build the whole model architecture, defined by ``cfg.MODEL.META_ARCHITECTURE``.\n    Note that it does not load any weights from ``cfg``.\n    \"\"\"", "\n", "meta_arch", "=", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "\n", "model", "=", "META_ARCH_REGISTRY", ".", "get", "(", "meta_arch", ")", "(", "cfg", ")", "\n", "model", ".", "to", "(", "torch", ".", "device", "(", "cfg", ".", "MODEL", ".", "DEVICE", ")", ")", "\n", "return", "model", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.panoptic_fpn.PanopticFPN.__init__": [[25, 45], ["torch.nn.Module.__init__", "backbone.build_backbone", "proposal_generator.build_proposal_generator", "roi_heads.build_roi_heads", "semantic_seg.build_sem_seg_head", "panoptic_fpn.PanopticFPN.register_buffer", "panoptic_fpn.PanopticFPN.register_buffer", "panoptic_fpn.PanopticFPN.backbone.output_shape", "panoptic_fpn.PanopticFPN.backbone.output_shape", "panoptic_fpn.PanopticFPN.backbone.output_shape", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.build.build_proposal_generator", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.build_roi_heads", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.semantic_seg.build_sem_seg_head", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.backbone.Backbone.output_shape", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.backbone.Backbone.output_shape", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.backbone.Backbone.output_shape"], ["def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "instance_loss_weight", "=", "cfg", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "INSTANCE_LOSS_WEIGHT", "\n", "\n", "# options when combining instance & semantic outputs", "\n", "self", ".", "combine_on", "=", "cfg", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", ".", "ENABLED", "\n", "self", ".", "combine_overlap_threshold", "=", "cfg", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", ".", "OVERLAP_THRESH", "\n", "self", ".", "combine_stuff_area_limit", "=", "cfg", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", ".", "STUFF_AREA_LIMIT", "\n", "self", ".", "combine_instances_confidence_threshold", "=", "(", "\n", "cfg", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", ".", "INSTANCES_CONFIDENCE_THRESH", "\n", ")", "\n", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "self", ".", "proposal_generator", "=", "build_proposal_generator", "(", "cfg", ",", "self", ".", "backbone", ".", "output_shape", "(", ")", ")", "\n", "self", ".", "roi_heads", "=", "build_roi_heads", "(", "cfg", ",", "self", ".", "backbone", ".", "output_shape", "(", ")", ")", "\n", "self", ".", "sem_seg_head", "=", "build_sem_seg_head", "(", "cfg", ",", "self", ".", "backbone", ".", "output_shape", "(", ")", ")", "\n", "\n", "self", ".", "register_buffer", "(", "\"pixel_mean\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_MEAN", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_std\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_STD", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.panoptic_fpn.PanopticFPN.device": [[46, 49], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "pixel_mean", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.panoptic_fpn.PanopticFPN.forward": [[50, 131], ["detectron2.structures.ImageList.from_tensors", "panoptic_fpn.PanopticFPN.backbone", "panoptic_fpn.PanopticFPN.sem_seg_head", "panoptic_fpn.PanopticFPN.roi_heads", "zip", "x[].to", "panoptic_fpn.PanopticFPN.proposal_generator", "losses.update", "losses.update", "losses.update", "input_per_image.get", "input_per_image.get", "postprocessing.sem_seg_postprocess", "postprocessing.detector_postprocess", "processed_results.append", "x[].to", "x[].to", "detectron2.structures.ImageList.from_tensors", "x[].to", "panoptic_fpn.combine_semantic_and_instance_outputs", "postprocessing.sem_seg_postprocess.argmax", "detector_losses.items"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.postprocessing.sem_seg_postprocess", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.postprocessing.detector_postprocess", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.panoptic_fpn.combine_semantic_and_instance_outputs"], ["", "def", "forward", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            batched_inputs: a list, batched outputs of :class:`DatasetMapper`.\n                Each item in the list contains the inputs for one image.\n\n                For now, each item in the list is a dict that contains:\n\n                * \"image\": Tensor, image in (C, H, W) format.\n                * \"instances\": Instances\n                * \"sem_seg\": semantic segmentation ground truth.\n                * Other information that's included in the original dicts, such as:\n                  \"height\", \"width\" (int): the output resolution of the model, used in inference.\n                  See :meth:`postprocess` for details.\n\n        Returns:\n            list[dict]:\n                each dict is the results for one image. The dict contains the following keys:\n\n                * \"instances\": see :meth:`GeneralizedRCNN.forward` for its format.\n                * \"sem_seg\": see :meth:`SemanticSegmentor.forward` for its format.\n                * \"panoptic_seg\": available when `PANOPTIC_FPN.COMBINE.ENABLED`.\n                  See the return value of\n                  :func:`combine_semantic_and_instance_outputs` for its format.\n        \"\"\"", "\n", "images", "=", "[", "x", "[", "\"image\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "images", "=", "[", "(", "x", "-", "self", ".", "pixel_mean", ")", "/", "self", ".", "pixel_std", "for", "x", "in", "images", "]", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "self", ".", "backbone", ".", "size_divisibility", ")", "\n", "features", "=", "self", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "\n", "if", "\"proposals\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "proposals", "=", "[", "x", "[", "\"proposals\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "proposal_losses", "=", "{", "}", "\n", "\n", "", "if", "\"sem_seg\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "gt_sem_seg", "=", "[", "x", "[", "\"sem_seg\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "gt_sem_seg", "=", "ImageList", ".", "from_tensors", "(", "\n", "gt_sem_seg", ",", "self", ".", "backbone", ".", "size_divisibility", ",", "self", ".", "sem_seg_head", ".", "ignore_value", "\n", ")", ".", "tensor", "\n", "", "else", ":", "\n", "            ", "gt_sem_seg", "=", "None", "\n", "", "sem_seg_results", ",", "sem_seg_losses", "=", "self", ".", "sem_seg_head", "(", "features", ",", "gt_sem_seg", ")", "\n", "\n", "if", "\"instances\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "gt_instances", "=", "[", "x", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "", "else", ":", "\n", "            ", "gt_instances", "=", "None", "\n", "", "if", "self", ".", "proposal_generator", ":", "\n", "            ", "proposals", ",", "proposal_losses", "=", "self", ".", "proposal_generator", "(", "images", ",", "features", ",", "gt_instances", ")", "\n", "", "detector_results", ",", "detector_losses", "=", "self", ".", "roi_heads", "(", "\n", "images", ",", "features", ",", "proposals", ",", "gt_instances", "\n", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "losses", "=", "{", "}", "\n", "losses", ".", "update", "(", "sem_seg_losses", ")", "\n", "losses", ".", "update", "(", "{", "k", ":", "v", "*", "self", ".", "instance_loss_weight", "for", "k", ",", "v", "in", "detector_losses", ".", "items", "(", ")", "}", ")", "\n", "losses", ".", "update", "(", "proposal_losses", ")", "\n", "return", "losses", "\n", "\n", "", "processed_results", "=", "[", "]", "\n", "for", "sem_seg_result", ",", "detector_result", ",", "input_per_image", ",", "image_size", "in", "zip", "(", "\n", "sem_seg_results", ",", "detector_results", ",", "batched_inputs", ",", "images", ".", "image_sizes", "\n", ")", ":", "\n", "            ", "height", "=", "input_per_image", ".", "get", "(", "\"height\"", ",", "image_size", "[", "0", "]", ")", "\n", "width", "=", "input_per_image", ".", "get", "(", "\"width\"", ",", "image_size", "[", "1", "]", ")", "\n", "sem_seg_r", "=", "sem_seg_postprocess", "(", "sem_seg_result", ",", "image_size", ",", "height", ",", "width", ")", "\n", "detector_r", "=", "detector_postprocess", "(", "detector_result", ",", "height", ",", "width", ")", "\n", "\n", "processed_results", ".", "append", "(", "{", "\"sem_seg\"", ":", "sem_seg_r", ",", "\"instances\"", ":", "detector_r", "}", ")", "\n", "\n", "if", "self", ".", "combine_on", ":", "\n", "                ", "panoptic_r", "=", "combine_semantic_and_instance_outputs", "(", "\n", "detector_r", ",", "\n", "sem_seg_r", ".", "argmax", "(", "dim", "=", "0", ")", ",", "\n", "self", ".", "combine_overlap_threshold", ",", "\n", "self", ".", "combine_stuff_area_limit", ",", "\n", "self", ".", "combine_instances_confidence_threshold", ",", "\n", ")", "\n", "processed_results", "[", "-", "1", "]", "[", "\"panoptic_seg\"", "]", "=", "panoptic_r", "\n", "", "", "return", "processed_results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.panoptic_fpn.combine_semantic_and_instance_outputs": [[133, 219], ["torch.zeros_like", "torch.argsort", "instance_results.pred_masks.to", "torch.unique().cpu().tolist", "instance_results.scores[].item", "mask.sum().item", "intersect.sum().item", "segments_info.append", "mask.sum().item", "segments_info.append", "torch.unique().cpu", "mask.sum", "intersect.sum", "instance_results.pred_classes[].item", "inst_id.item", "mask.sum", "torch.unique"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "", "def", "combine_semantic_and_instance_outputs", "(", "\n", "instance_results", ",", "\n", "semantic_results", ",", "\n", "overlap_threshold", ",", "\n", "stuff_area_limit", ",", "\n", "instances_confidence_threshold", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Implement a simple combining logic following\n    \"combine_semantic_and_instance_predictions.py\" in panopticapi\n    to produce panoptic segmentation outputs.\n\n    Args:\n        instance_results: output of :func:`detector_postprocess`.\n        semantic_results: an (H, W) tensor, each is the contiguous semantic\n            category id\n\n    Returns:\n        panoptic_seg (Tensor): of shape (height, width) where the values are ids for each segment.\n        segments_info (list[dict]): Describe each segment in `panoptic_seg`.\n            Each dict contains keys \"id\", \"category_id\", \"isthing\".\n    \"\"\"", "\n", "panoptic_seg", "=", "torch", ".", "zeros_like", "(", "semantic_results", ",", "dtype", "=", "torch", ".", "int32", ")", "\n", "\n", "# sort instance outputs by scores", "\n", "sorted_inds", "=", "torch", ".", "argsort", "(", "-", "instance_results", ".", "scores", ")", "\n", "\n", "current_segment_id", "=", "0", "\n", "segments_info", "=", "[", "]", "\n", "\n", "instance_masks", "=", "instance_results", ".", "pred_masks", ".", "to", "(", "dtype", "=", "torch", ".", "bool", ",", "device", "=", "panoptic_seg", ".", "device", ")", "\n", "\n", "# Add instances one-by-one, check for overlaps with existing ones", "\n", "for", "inst_id", "in", "sorted_inds", ":", "\n", "        ", "score", "=", "instance_results", ".", "scores", "[", "inst_id", "]", ".", "item", "(", ")", "\n", "if", "score", "<", "instances_confidence_threshold", ":", "\n", "            ", "break", "\n", "", "mask", "=", "instance_masks", "[", "inst_id", "]", "# H,W", "\n", "mask_area", "=", "mask", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "if", "mask_area", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "intersect", "=", "(", "mask", ">", "0", ")", "&", "(", "panoptic_seg", ">", "0", ")", "\n", "intersect_area", "=", "intersect", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "if", "intersect_area", "*", "1.0", "/", "mask_area", ">", "overlap_threshold", ":", "\n", "            ", "continue", "\n", "\n", "", "if", "intersect_area", ">", "0", ":", "\n", "            ", "mask", "=", "mask", "&", "(", "panoptic_seg", "==", "0", ")", "\n", "\n", "", "current_segment_id", "+=", "1", "\n", "panoptic_seg", "[", "mask", "]", "=", "current_segment_id", "\n", "segments_info", ".", "append", "(", "\n", "{", "\n", "\"id\"", ":", "current_segment_id", ",", "\n", "\"isthing\"", ":", "True", ",", "\n", "\"score\"", ":", "score", ",", "\n", "\"category_id\"", ":", "instance_results", ".", "pred_classes", "[", "inst_id", "]", ".", "item", "(", ")", ",", "\n", "\"instance_id\"", ":", "inst_id", ".", "item", "(", ")", ",", "\n", "}", "\n", ")", "\n", "\n", "# Add semantic results to remaining empty areas", "\n", "", "semantic_labels", "=", "torch", ".", "unique", "(", "semantic_results", ")", ".", "cpu", "(", ")", ".", "tolist", "(", ")", "\n", "for", "semantic_label", "in", "semantic_labels", ":", "\n", "        ", "if", "semantic_label", "==", "0", ":", "# 0 is a special \"thing\" class", "\n", "            ", "continue", "\n", "", "mask", "=", "(", "semantic_results", "==", "semantic_label", ")", "&", "(", "panoptic_seg", "==", "0", ")", "\n", "mask_area", "=", "mask", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "if", "mask_area", "<", "stuff_area_limit", ":", "\n", "            ", "continue", "\n", "\n", "", "current_segment_id", "+=", "1", "\n", "panoptic_seg", "[", "mask", "]", "=", "current_segment_id", "\n", "segments_info", ".", "append", "(", "\n", "{", "\n", "\"id\"", ":", "current_segment_id", ",", "\n", "\"isthing\"", ":", "False", ",", "\n", "\"category_id\"", ":", "semantic_label", ",", "\n", "\"area\"", ":", "mask_area", ",", "\n", "}", "\n", ")", "\n", "\n", "", "return", "panoptic_seg", ",", "segments_info", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.semantic_seg.SemanticSegmentor.__init__": [[33, 39], ["torch.nn.Module.__init__", "backbone.build_backbone", "semantic_seg.build_sem_seg_head", "semantic_seg.SemanticSegmentor.register_buffer", "semantic_seg.SemanticSegmentor.register_buffer", "semantic_seg.SemanticSegmentor.backbone.output_shape", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.semantic_seg.build_sem_seg_head", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.backbone.Backbone.output_shape"], ["def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "self", ".", "sem_seg_head", "=", "build_sem_seg_head", "(", "cfg", ",", "self", ".", "backbone", ".", "output_shape", "(", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_mean\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_MEAN", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_std\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_STD", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.semantic_seg.SemanticSegmentor.device": [[40, 43], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "pixel_mean", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.semantic_seg.SemanticSegmentor.forward": [[44, 93], ["detectron2.structures.ImageList.from_tensors", "semantic_seg.SemanticSegmentor.backbone", "semantic_seg.SemanticSegmentor.sem_seg_head", "zip", "x[].to", "input_per_image.get", "input_per_image.get", "postprocessing.sem_seg_postprocess", "processed_results.append", "x[].to", "detectron2.structures.ImageList.from_tensors"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.postprocessing.sem_seg_postprocess", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.from_tensors"], ["", "def", "forward", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            batched_inputs: a list, batched outputs of :class:`DatasetMapper`.\n                Each item in the list contains the inputs for one image.\n\n                For now, each item in the list is a dict that contains:\n\n                   * \"image\": Tensor, image in (C, H, W) format.\n                   * \"sem_seg\": semantic segmentation ground truth\n                   * Other information that's included in the original dicts, such as:\n                     \"height\", \"width\" (int): the output resolution of the model (may be different\n                     from input resolution), used in inference.\n\n\n        Returns:\n            list[dict]:\n              Each dict is the output for one input image.\n              The dict contains one key \"sem_seg\" whose value is a\n              Tensor that represents the\n              per-pixel segmentation prediced by the head.\n              The prediction has shape KxHxW that represents the logits of\n              each class for each pixel.\n        \"\"\"", "\n", "images", "=", "[", "x", "[", "\"image\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "images", "=", "[", "(", "x", "-", "self", ".", "pixel_mean", ")", "/", "self", ".", "pixel_std", "for", "x", "in", "images", "]", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "self", ".", "backbone", ".", "size_divisibility", ")", "\n", "\n", "features", "=", "self", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "\n", "if", "\"sem_seg\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "targets", "=", "[", "x", "[", "\"sem_seg\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "targets", "=", "ImageList", ".", "from_tensors", "(", "\n", "targets", ",", "self", ".", "backbone", ".", "size_divisibility", ",", "self", ".", "sem_seg_head", ".", "ignore_value", "\n", ")", ".", "tensor", "\n", "", "else", ":", "\n", "            ", "targets", "=", "None", "\n", "", "results", ",", "losses", "=", "self", ".", "sem_seg_head", "(", "features", ",", "targets", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "losses", "\n", "\n", "", "processed_results", "=", "[", "]", "\n", "for", "result", ",", "input_per_image", ",", "image_size", "in", "zip", "(", "results", ",", "batched_inputs", ",", "images", ".", "image_sizes", ")", ":", "\n", "            ", "height", "=", "input_per_image", ".", "get", "(", "\"height\"", ")", "\n", "width", "=", "input_per_image", ".", "get", "(", "\"width\"", ")", "\n", "r", "=", "sem_seg_postprocess", "(", "result", ",", "image_size", ",", "height", ",", "width", ")", "\n", "processed_results", ".", "append", "(", "{", "\"sem_seg\"", ":", "r", "}", ")", "\n", "", "return", "processed_results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.semantic_seg.SemSegFPNHead.__init__": [[111, 154], ["torch.nn.Module.__init__", "detectron2.layers.Conv2d", "fvcore.c2_msra_fill", "max", "range", "semantic_seg.SemSegFPNHead.scale_heads.append", "semantic_seg.SemSegFPNHead.add_module", "input_shape.items", "input_shape.items", "int", "detectron2.layers.Conv2d", "fvcore.c2_msra_fill", "head_ops.append", "torch.nn.Sequential", "torch.nn.GroupNorm", "head_ops.append", "numpy.log2", "numpy.log2", "torch.nn.Upsample"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "Dict", "[", "str", ",", "ShapeSpec", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "self", ".", "in_features", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IN_FEATURES", "\n", "feature_strides", "=", "{", "k", ":", "v", ".", "stride", "for", "k", ",", "v", "in", "input_shape", ".", "items", "(", ")", "}", "\n", "feature_channels", "=", "{", "k", ":", "v", ".", "channels", "for", "k", ",", "v", "in", "input_shape", ".", "items", "(", ")", "}", "\n", "self", ".", "ignore_value", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IGNORE_VALUE", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NUM_CLASSES", "\n", "conv_dims", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "CONVS_DIM", "\n", "self", ".", "common_stride", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "COMMON_STRIDE", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NORM", "\n", "self", ".", "loss_weight", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "LOSS_WEIGHT", "\n", "# fmt: on", "\n", "\n", "self", ".", "scale_heads", "=", "[", "]", "\n", "for", "in_feature", "in", "self", ".", "in_features", ":", "\n", "            ", "head_ops", "=", "[", "]", "\n", "head_length", "=", "max", "(", "\n", "1", ",", "int", "(", "np", ".", "log2", "(", "feature_strides", "[", "in_feature", "]", ")", "-", "np", ".", "log2", "(", "self", ".", "common_stride", ")", ")", "\n", ")", "\n", "for", "k", "in", "range", "(", "head_length", ")", ":", "\n", "                ", "norm_module", "=", "nn", ".", "GroupNorm", "(", "32", ",", "conv_dims", ")", "if", "norm", "==", "\"GN\"", "else", "None", "\n", "conv", "=", "Conv2d", "(", "\n", "feature_channels", "[", "in_feature", "]", "if", "k", "==", "0", "else", "conv_dims", ",", "\n", "conv_dims", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "not", "norm", ",", "\n", "norm", "=", "norm_module", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", "\n", "weight_init", ".", "c2_msra_fill", "(", "conv", ")", "\n", "head_ops", ".", "append", "(", "conv", ")", "\n", "if", "feature_strides", "[", "in_feature", "]", "!=", "self", ".", "common_stride", ":", "\n", "                    ", "head_ops", ".", "append", "(", "\n", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", "\n", ")", "\n", "", "", "self", ".", "scale_heads", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "head_ops", ")", ")", "\n", "self", ".", "add_module", "(", "in_feature", ",", "self", ".", "scale_heads", "[", "-", "1", "]", ")", "\n", "", "self", ".", "predictor", "=", "Conv2d", "(", "conv_dims", ",", "num_classes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "weight_init", ".", "c2_msra_fill", "(", "self", ".", "predictor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.semantic_seg.SemSegFPNHead.forward": [[155, 169], ["semantic_seg.SemSegFPNHead.layers", "torch.nn.functional.interpolate", "semantic_seg.SemSegFPNHead.losses"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3PlusHead.layers", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3Head.losses"], ["", "def", "forward", "(", "self", ",", "features", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            In training, returns (None, dict of losses)\n            In inference, returns (CxHxW logits, {})\n        \"\"\"", "\n", "x", "=", "self", ".", "layers", "(", "features", ")", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "None", ",", "self", ".", "losses", "(", "x", ",", "targets", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "F", ".", "interpolate", "(", "\n", "x", ",", "scale_factor", "=", "self", ".", "common_stride", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "return", "x", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.semantic_seg.SemSegFPNHead.layers": [[170, 178], ["enumerate", "semantic_seg.SemSegFPNHead.predictor"], "methods", ["None"], ["", "", "def", "layers", "(", "self", ",", "features", ")", ":", "\n", "        ", "for", "i", ",", "f", "in", "enumerate", "(", "self", ".", "in_features", ")", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "                ", "x", "=", "self", ".", "scale_heads", "[", "i", "]", "(", "features", "[", "f", "]", ")", "\n", "", "else", ":", "\n", "                ", "x", "=", "x", "+", "self", ".", "scale_heads", "[", "i", "]", "(", "features", "[", "f", "]", ")", "\n", "", "", "x", "=", "self", ".", "predictor", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.semantic_seg.SemSegFPNHead.losses": [[179, 188], ["torch.nn.functional.interpolate", "torch.nn.functional.cross_entropy"], "methods", ["None"], ["", "def", "losses", "(", "self", ",", "predictions", ",", "targets", ")", ":", "\n", "        ", "predictions", "=", "F", ".", "interpolate", "(", "\n", "predictions", ",", "scale_factor", "=", "self", ".", "common_stride", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "\n", "predictions", ",", "targets", ",", "reduction", "=", "\"mean\"", ",", "ignore_index", "=", "self", ".", "ignore_value", "\n", ")", "\n", "losses", "=", "{", "\"loss_sem_seg\"", ":", "loss", "*", "self", ".", "loss_weight", "}", "\n", "return", "losses", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.semantic_seg.build_sem_seg_head": [[95, 101], ["SEM_SEG_HEADS_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "", "def", "build_sem_seg_head", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build a semantic segmentation head from `cfg.MODEL.SEM_SEG_HEAD.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NAME", "\n", "return", "SEM_SEG_HEADS_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.proposal_utils.find_top_rpn_proposals": [[13, 119], ["len", "torch.arange", "enumerate", "detectron2.layers.cat", "detectron2.layers.cat", "detectron2.layers.cat", "enumerate", "zip", "min", "logits_i.sort", "detectron2.layers.cat.append", "detectron2.layers.cat.append", "detectron2.layers.cat.append", "detectron2.structures.Boxes", "detectron2.structures.Boxes.clip", "detectron2.structures.Boxes.nonempty", "detectron2.layers.batched_nms", "detectron2.structures.Instances", "results.append", "torch.full", "torch.isfinite().all", "torch.isfinite", "valid_mask.all", "detectron2.layers.batched_nms.sum().item", "len", "FloatingPointError", "torch.isfinite", "detectron2.layers.batched_nms.sum"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.nonempty", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.batched_nms"], ["def", "find_top_rpn_proposals", "(", "\n", "proposals", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "\n", "pred_objectness_logits", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "\n", "image_sizes", ":", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", ",", "\n", "nms_thresh", ":", "float", ",", "\n", "pre_nms_topk", ":", "int", ",", "\n", "post_nms_topk", ":", "int", ",", "\n", "min_box_size", ":", "float", ",", "\n", "training", ":", "bool", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    For each feature map, select the `pre_nms_topk` highest scoring proposals,\n    apply NMS, clip proposals, and remove small boxes. Return the `post_nms_topk`\n    highest scoring proposals among all the feature maps for each image.\n\n    Args:\n        proposals (list[Tensor]): A list of L tensors. Tensor i has shape (N, Hi*Wi*A, 4).\n            All proposal predictions on the feature maps.\n        pred_objectness_logits (list[Tensor]): A list of L tensors. Tensor i has shape (N, Hi*Wi*A).\n        image_sizes (list[tuple]): sizes (h, w) for each image\n        nms_thresh (float): IoU threshold to use for NMS\n        pre_nms_topk (int): number of top k scoring proposals to keep before applying NMS.\n            When RPN is run on multiple feature maps (as in FPN) this number is per\n            feature map.\n        post_nms_topk (int): number of top k scoring proposals to keep after applying NMS.\n            When RPN is run on multiple feature maps (as in FPN) this number is total,\n            over all feature maps.\n        min_box_size (float): minimum proposal box side length in pixels (absolute units\n            wrt input images).\n        training (bool): True if proposals are to be used in training, otherwise False.\n            This arg exists only to support a legacy bug; look for the \"NB: Legacy bug ...\"\n            comment.\n\n    Returns:\n        list[Instances]: list of N Instances. The i-th Instances\n            stores post_nms_topk object proposals for image i, sorted by their\n            objectness score in descending order.\n    \"\"\"", "\n", "num_images", "=", "len", "(", "image_sizes", ")", "\n", "device", "=", "proposals", "[", "0", "]", ".", "device", "\n", "\n", "# 1. Select top-k anchor for every level and every image", "\n", "topk_scores", "=", "[", "]", "# #lvl Tensor, each of shape N x topk", "\n", "topk_proposals", "=", "[", "]", "\n", "level_ids", "=", "[", "]", "# #lvl Tensor, each of shape (topk,)", "\n", "batch_idx", "=", "torch", ".", "arange", "(", "num_images", ",", "device", "=", "device", ")", "\n", "for", "level_id", ",", "(", "proposals_i", ",", "logits_i", ")", "in", "enumerate", "(", "zip", "(", "proposals", ",", "pred_objectness_logits", ")", ")", ":", "\n", "        ", "Hi_Wi_A", "=", "logits_i", ".", "shape", "[", "1", "]", "\n", "num_proposals_i", "=", "min", "(", "pre_nms_topk", ",", "Hi_Wi_A", ")", "\n", "\n", "# sort is faster than topk (https://github.com/pytorch/pytorch/issues/22812)", "\n", "# topk_scores_i, topk_idx = logits_i.topk(num_proposals_i, dim=1)", "\n", "logits_i", ",", "idx", "=", "logits_i", ".", "sort", "(", "descending", "=", "True", ",", "dim", "=", "1", ")", "\n", "topk_scores_i", "=", "logits_i", "[", "batch_idx", ",", ":", "num_proposals_i", "]", "\n", "topk_idx", "=", "idx", "[", "batch_idx", ",", ":", "num_proposals_i", "]", "\n", "\n", "# each is N x topk", "\n", "topk_proposals_i", "=", "proposals_i", "[", "batch_idx", "[", ":", ",", "None", "]", ",", "topk_idx", "]", "# N x topk x 4", "\n", "\n", "topk_proposals", ".", "append", "(", "topk_proposals_i", ")", "\n", "topk_scores", ".", "append", "(", "topk_scores_i", ")", "\n", "level_ids", ".", "append", "(", "torch", ".", "full", "(", "(", "num_proposals_i", ",", ")", ",", "level_id", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "device", ")", ")", "\n", "\n", "# 2. Concat all levels together", "\n", "", "topk_scores", "=", "cat", "(", "topk_scores", ",", "dim", "=", "1", ")", "\n", "topk_proposals", "=", "cat", "(", "topk_proposals", ",", "dim", "=", "1", ")", "\n", "level_ids", "=", "cat", "(", "level_ids", ",", "dim", "=", "0", ")", "\n", "\n", "# 3. For each image, run a per-level NMS, and choose topk results.", "\n", "results", ":", "List", "[", "Instances", "]", "=", "[", "]", "\n", "for", "n", ",", "image_size", "in", "enumerate", "(", "image_sizes", ")", ":", "\n", "        ", "boxes", "=", "Boxes", "(", "topk_proposals", "[", "n", "]", ")", "\n", "scores_per_img", "=", "topk_scores", "[", "n", "]", "\n", "lvl", "=", "level_ids", "\n", "\n", "valid_mask", "=", "torch", ".", "isfinite", "(", "boxes", ".", "tensor", ")", ".", "all", "(", "dim", "=", "1", ")", "&", "torch", ".", "isfinite", "(", "scores_per_img", ")", "\n", "if", "not", "valid_mask", ".", "all", "(", ")", ":", "\n", "            ", "if", "training", ":", "\n", "                ", "raise", "FloatingPointError", "(", "\n", "\"Predicted boxes or scores contain Inf/NaN. Training has diverged.\"", "\n", ")", "\n", "", "boxes", "=", "boxes", "[", "valid_mask", "]", "\n", "scores_per_img", "=", "scores_per_img", "[", "valid_mask", "]", "\n", "lvl", "=", "lvl", "[", "valid_mask", "]", "\n", "", "boxes", ".", "clip", "(", "image_size", ")", "\n", "\n", "# filter empty boxes", "\n", "keep", "=", "boxes", ".", "nonempty", "(", "threshold", "=", "min_box_size", ")", "\n", "if", "keep", ".", "sum", "(", ")", ".", "item", "(", ")", "!=", "len", "(", "boxes", ")", ":", "\n", "            ", "boxes", ",", "scores_per_img", ",", "lvl", "=", "boxes", "[", "keep", "]", ",", "scores_per_img", "[", "keep", "]", ",", "lvl", "[", "keep", "]", "\n", "\n", "", "keep", "=", "batched_nms", "(", "boxes", ".", "tensor", ",", "scores_per_img", ",", "lvl", ",", "nms_thresh", ")", "\n", "# In Detectron1, there was different behavior during training vs. testing.", "\n", "# (https://github.com/facebookresearch/Detectron/issues/459)", "\n", "# During training, topk is over the proposals from *all* images in the training batch.", "\n", "# During testing, it is over the proposals for each image separately.", "\n", "# As a result, the training behavior becomes batch-dependent,", "\n", "# and the configuration \"POST_NMS_TOPK_TRAIN\" end up relying on the batch size.", "\n", "# This bug is addressed in Detectron2 to make the behavior independent of batch size.", "\n", "keep", "=", "keep", "[", ":", "post_nms_topk", "]", "# keep is already sorted", "\n", "\n", "res", "=", "Instances", "(", "image_size", ")", "\n", "res", ".", "proposal_boxes", "=", "boxes", "[", "keep", "]", "\n", "res", ".", "objectness_logits", "=", "scores_per_img", "[", "keep", "]", "\n", "results", ".", "append", "(", "res", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.proposal_utils.add_ground_truth_to_proposals": [[121, 144], ["len", "len", "len", "proposal_utils.add_ground_truth_to_proposals_single_image", "zip"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.proposal_utils.add_ground_truth_to_proposals_single_image"], ["", "def", "add_ground_truth_to_proposals", "(", "gt_boxes", ",", "proposals", ")", ":", "\n", "    ", "\"\"\"\n    Call `add_ground_truth_to_proposals_single_image` for all images.\n\n    Args:\n        gt_boxes(list[Boxes]): list of N elements. Element i is a Boxes\n            representing the gound-truth for image i.\n        proposals (list[Instances]): list of N elements. Element i is a Instances\n            representing the proposals for image i.\n\n    Returns:\n        list[Instances]: list of N Instances. Each is the proposals for the image,\n            with field \"proposal_boxes\" and \"objectness_logits\".\n    \"\"\"", "\n", "assert", "gt_boxes", "is", "not", "None", "\n", "\n", "assert", "len", "(", "proposals", ")", "==", "len", "(", "gt_boxes", ")", "\n", "if", "len", "(", "proposals", ")", "==", "0", ":", "\n", "        ", "return", "proposals", "\n", "\n", "", "return", "[", "\n", "add_ground_truth_to_proposals_single_image", "(", "gt_boxes_i", ",", "proposals_i", ")", "\n", "for", "gt_boxes_i", ",", "proposals_i", "in", "zip", "(", "gt_boxes", ",", "proposals", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.proposal_utils.add_ground_truth_to_proposals_single_image": [[147, 171], ["math.log", "detectron2.structures.Instances", "detectron2.structures.Instances.cat", "torch.ones", "len"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "def", "add_ground_truth_to_proposals_single_image", "(", "gt_boxes", ",", "proposals", ")", ":", "\n", "    ", "\"\"\"\n    Augment `proposals` with ground-truth boxes from `gt_boxes`.\n\n    Args:\n        Same as `add_ground_truth_to_proposals`, but with gt_boxes and proposals\n        per image.\n\n    Returns:\n        Same as `add_ground_truth_to_proposals`, but for only one image.\n    \"\"\"", "\n", "device", "=", "proposals", ".", "objectness_logits", ".", "device", "\n", "# Assign all ground-truth boxes an objectness logit corresponding to", "\n", "# P(object) = sigmoid(logit) =~ 1.", "\n", "gt_logit_value", "=", "math", ".", "log", "(", "(", "1.0", "-", "1e-10", ")", "/", "(", "1", "-", "(", "1.0", "-", "1e-10", ")", ")", ")", "\n", "gt_logits", "=", "gt_logit_value", "*", "torch", ".", "ones", "(", "len", "(", "gt_boxes", ")", ",", "device", "=", "device", ")", "\n", "\n", "# Concatenating gt_boxes with proposals requires them to have the same fields", "\n", "gt_proposal", "=", "Instances", "(", "proposals", ".", "image_size", ")", "\n", "gt_proposal", ".", "proposal_boxes", "=", "gt_boxes", "\n", "gt_proposal", ".", "objectness_logits", "=", "gt_logits", "\n", "new_proposals", "=", "Instances", ".", "cat", "(", "[", "proposals", ",", "gt_proposal", "]", ")", "\n", "\n", "return", "new_proposals", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rpn.StandardRPNHead.__init__": [[76, 102], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.constant_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "self", ",", "*", ",", "in_channels", ":", "int", ",", "num_anchors", ":", "int", ",", "box_dim", ":", "int", "=", "4", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            in_channels (int): number of input feature channels. When using multiple\n                input features, they must have the same number of channels.\n            num_anchors (int): number of anchors to predict for *each spatial position*\n                on the feature map. The total number of anchors for each\n                feature map will be `num_anchors * H * W`.\n            box_dim (int): dimension of a box, which is also the number of box regression\n                predictions to make for each anchor. An axis aligned box has\n                box_dim=4, while a rotated box has box_dim=5.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "# 3x3 conv for the hidden representation", "\n", "self", ".", "conv", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "in_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "# 1x1 conv for predicting objectness logits", "\n", "self", ".", "objectness_logits", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "num_anchors", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "\n", "# 1x1 conv for predicting box2box transform deltas", "\n", "self", ".", "anchor_deltas", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "num_anchors", "*", "box_dim", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "\n", "\n", "for", "l", "in", "[", "self", ".", "conv", ",", "self", ".", "objectness_logits", ",", "self", ".", "anchor_deltas", "]", ":", "\n", "            ", "nn", ".", "init", ".", "normal_", "(", "l", ".", "weight", ",", "std", "=", "0.01", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rpn.StandardRPNHead.from_config": [[103, 119], ["anchor_generator.build_anchor_generator.build_anchor_generator", "len", "len", "set", "set"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.build_anchor_generator", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "# Standard RPN is shared across levels:", "\n", "        ", "in_channels", "=", "[", "s", ".", "channels", "for", "s", "in", "input_shape", "]", "\n", "assert", "len", "(", "set", "(", "in_channels", ")", ")", "==", "1", ",", "\"Each level must have the same channel!\"", "\n", "in_channels", "=", "in_channels", "[", "0", "]", "\n", "\n", "# RPNHead should take the same input as anchor generator", "\n", "# NOTE: it assumes that creating an anchor generator does not have unwanted side effect.", "\n", "anchor_generator", "=", "build_anchor_generator", "(", "cfg", ",", "input_shape", ")", "\n", "num_anchors", "=", "anchor_generator", ".", "num_anchors", "\n", "box_dim", "=", "anchor_generator", ".", "box_dim", "\n", "assert", "(", "\n", "len", "(", "set", "(", "num_anchors", ")", ")", "==", "1", "\n", ")", ",", "\"Each level must have the same number of anchors per spatial position\"", "\n", "return", "{", "\"in_channels\"", ":", "in_channels", ",", "\"num_anchors\"", ":", "num_anchors", "[", "0", "]", ",", "\"box_dim\"", ":", "box_dim", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rpn.StandardRPNHead.forward": [[120, 140], ["torch.relu", "torch.relu", "pred_objectness_logits.append", "pred_anchor_deltas.append", "rpn.StandardRPNHead.conv", "rpn.StandardRPNHead.objectness_logits", "rpn.StandardRPNHead.anchor_deltas"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "features", ":", "List", "[", "torch", ".", "Tensor", "]", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            features (list[Tensor]): list of feature maps\n\n        Returns:\n            list[Tensor]: A list of L elements.\n                Element i is a tensor of shape (N, A, Hi, Wi) representing\n                the predicted objectness logits for all anchors. A is the number of cell anchors.\n            list[Tensor]: A list of L elements. Element i is a tensor of shape\n                (N, A*box_dim, Hi, Wi) representing the predicted \"deltas\" used to transform anchors\n                to proposals.\n        \"\"\"", "\n", "pred_objectness_logits", "=", "[", "]", "\n", "pred_anchor_deltas", "=", "[", "]", "\n", "for", "x", "in", "features", ":", "\n", "            ", "t", "=", "F", ".", "relu", "(", "self", ".", "conv", "(", "x", ")", ")", "\n", "pred_objectness_logits", ".", "append", "(", "self", ".", "objectness_logits", "(", "t", ")", ")", "\n", "pred_anchor_deltas", ".", "append", "(", "self", ".", "anchor_deltas", "(", "t", ")", ")", "\n", "", "return", "pred_objectness_logits", ",", "pred_anchor_deltas", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rpn.RPN.__init__": [[148, 219], ["torch.nn.Module.__init__", "float", "isinstance"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "*", ",", "\n", "in_features", ":", "List", "[", "str", "]", ",", "\n", "head", ":", "nn", ".", "Module", ",", "\n", "anchor_generator", ":", "nn", ".", "Module", ",", "\n", "anchor_matcher", ":", "Matcher", ",", "\n", "box2box_transform", ":", "Box2BoxTransform", ",", "\n", "batch_size_per_image", ":", "int", ",", "\n", "positive_fraction", ":", "float", ",", "\n", "pre_nms_topk", ":", "Tuple", "[", "float", ",", "float", "]", ",", "\n", "post_nms_topk", ":", "Tuple", "[", "float", ",", "float", "]", ",", "\n", "nms_thresh", ":", "float", "=", "0.7", ",", "\n", "min_box_size", ":", "float", "=", "0.0", ",", "\n", "anchor_boundary_thresh", ":", "float", "=", "-", "1.0", ",", "\n", "loss_weight", ":", "Union", "[", "float", ",", "Dict", "[", "str", ",", "float", "]", "]", "=", "1.0", ",", "\n", "box_reg_loss_type", ":", "str", "=", "\"smooth_l1\"", ",", "\n", "smooth_l1_beta", ":", "float", "=", "0.0", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            in_features (list[str]): list of names of input features to use\n            head (nn.Module): a module that predicts logits and regression deltas\n                for each level from a list of per-level features\n            anchor_generator (nn.Module): a module that creates anchors from a\n                list of features. Usually an instance of :class:`AnchorGenerator`\n            anchor_matcher (Matcher): label the anchors by matching them with ground truth.\n            box2box_transform (Box2BoxTransform): defines the transform from anchors boxes to\n                instance boxes\n            batch_size_per_image (int): number of anchors per image to sample for training\n            positive_fraction (float): fraction of foreground anchors to sample for training\n            pre_nms_topk (tuple[float]): (train, test) that represents the\n                number of top k proposals to select before NMS, in\n                training and testing.\n            post_nms_topk (tuple[float]): (train, test) that represents the\n                number of top k proposals to select after NMS, in\n                training and testing.\n            nms_thresh (float): NMS threshold used to de-duplicate the predicted proposals\n            min_box_size (float): remove proposal boxes with any side smaller than this threshold,\n                in the unit of input image pixels\n            anchor_boundary_thresh (float): legacy option\n            loss_weight (float|dict): weights to use for losses. Can be single float for weighting\n                all rpn losses together, or a dict of individual weightings. Valid dict keys are:\n                    \"loss_rpn_cls\" - applied to classification loss\n                    \"loss_rpn_loc\" - applied to box regression loss\n            box_reg_loss_type (str): Loss type to use. Supported losses: \"smooth_l1\", \"giou\".\n            smooth_l1_beta (float): beta parameter for the smooth L1 regression loss. Default to\n                use L1 loss. Only used when `box_reg_loss_type` is \"smooth_l1\"\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_features", "=", "in_features", "\n", "self", ".", "rpn_head", "=", "head", "\n", "self", ".", "anchor_generator", "=", "anchor_generator", "\n", "self", ".", "anchor_matcher", "=", "anchor_matcher", "\n", "self", ".", "box2box_transform", "=", "box2box_transform", "\n", "self", ".", "batch_size_per_image", "=", "batch_size_per_image", "\n", "self", ".", "positive_fraction", "=", "positive_fraction", "\n", "# Map from self.training state to train/test settings", "\n", "self", ".", "pre_nms_topk", "=", "{", "True", ":", "pre_nms_topk", "[", "0", "]", ",", "False", ":", "pre_nms_topk", "[", "1", "]", "}", "\n", "self", ".", "post_nms_topk", "=", "{", "True", ":", "post_nms_topk", "[", "0", "]", ",", "False", ":", "post_nms_topk", "[", "1", "]", "}", "\n", "self", ".", "nms_thresh", "=", "nms_thresh", "\n", "self", ".", "min_box_size", "=", "float", "(", "min_box_size", ")", "\n", "self", ".", "anchor_boundary_thresh", "=", "anchor_boundary_thresh", "\n", "if", "isinstance", "(", "loss_weight", ",", "float", ")", ":", "\n", "            ", "loss_weight", "=", "{", "\"loss_rpn_cls\"", ":", "loss_weight", ",", "\"loss_rpn_loc\"", ":", "loss_weight", "}", "\n", "", "self", ".", "loss_weight", "=", "loss_weight", "\n", "self", ".", "box_reg_loss_type", "=", "box_reg_loss_type", "\n", "self", ".", "smooth_l1_beta", "=", "smooth_l1_beta", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rpn.RPN.from_config": [[220, 248], ["anchor_generator.build_anchor_generator", "matcher.Matcher", "rpn.build_rpn_head", "box_regression.Box2BoxTransform"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.anchor_generator.build_anchor_generator", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rpn.build_rpn_head"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ":", "Dict", "[", "str", ",", "ShapeSpec", "]", ")", ":", "\n", "        ", "in_features", "=", "cfg", ".", "MODEL", ".", "RPN", ".", "IN_FEATURES", "\n", "ret", "=", "{", "\n", "\"in_features\"", ":", "in_features", ",", "\n", "\"min_box_size\"", ":", "cfg", ".", "MODEL", ".", "PROPOSAL_GENERATOR", ".", "MIN_SIZE", ",", "\n", "\"nms_thresh\"", ":", "cfg", ".", "MODEL", ".", "RPN", ".", "NMS_THRESH", ",", "\n", "\"batch_size_per_image\"", ":", "cfg", ".", "MODEL", ".", "RPN", ".", "BATCH_SIZE_PER_IMAGE", ",", "\n", "\"positive_fraction\"", ":", "cfg", ".", "MODEL", ".", "RPN", ".", "POSITIVE_FRACTION", ",", "\n", "\"loss_weight\"", ":", "{", "\n", "\"loss_rpn_cls\"", ":", "cfg", ".", "MODEL", ".", "RPN", ".", "LOSS_WEIGHT", ",", "\n", "\"loss_rpn_loc\"", ":", "cfg", ".", "MODEL", ".", "RPN", ".", "BBOX_REG_LOSS_WEIGHT", "*", "cfg", ".", "MODEL", ".", "RPN", ".", "LOSS_WEIGHT", ",", "\n", "}", ",", "\n", "\"anchor_boundary_thresh\"", ":", "cfg", ".", "MODEL", ".", "RPN", ".", "BOUNDARY_THRESH", ",", "\n", "\"box2box_transform\"", ":", "Box2BoxTransform", "(", "weights", "=", "cfg", ".", "MODEL", ".", "RPN", ".", "BBOX_REG_WEIGHTS", ")", ",", "\n", "\"box_reg_loss_type\"", ":", "cfg", ".", "MODEL", ".", "RPN", ".", "BBOX_REG_LOSS_TYPE", ",", "\n", "\"smooth_l1_beta\"", ":", "cfg", ".", "MODEL", ".", "RPN", ".", "SMOOTH_L1_BETA", ",", "\n", "}", "\n", "\n", "ret", "[", "\"pre_nms_topk\"", "]", "=", "(", "cfg", ".", "MODEL", ".", "RPN", ".", "PRE_NMS_TOPK_TRAIN", ",", "cfg", ".", "MODEL", ".", "RPN", ".", "PRE_NMS_TOPK_TEST", ")", "\n", "ret", "[", "\"post_nms_topk\"", "]", "=", "(", "cfg", ".", "MODEL", ".", "RPN", ".", "POST_NMS_TOPK_TRAIN", ",", "cfg", ".", "MODEL", ".", "RPN", ".", "POST_NMS_TOPK_TEST", ")", "\n", "\n", "ret", "[", "\"anchor_generator\"", "]", "=", "build_anchor_generator", "(", "cfg", ",", "[", "input_shape", "[", "f", "]", "for", "f", "in", "in_features", "]", ")", "\n", "ret", "[", "\"anchor_matcher\"", "]", "=", "Matcher", "(", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "IOU_THRESHOLDS", ",", "cfg", ".", "MODEL", ".", "RPN", ".", "IOU_LABELS", ",", "allow_low_quality_matches", "=", "True", "\n", ")", "\n", "ret", "[", "\"head\"", "]", "=", "build_rpn_head", "(", "cfg", ",", "[", "input_shape", "[", "f", "]", "for", "f", "in", "in_features", "]", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rpn.RPN._subsample_labels": [[249, 266], ["sampling.subsample_labels", "label.fill_", "label.scatter_", "label.scatter_"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.sampling.subsample_labels"], ["", "def", "_subsample_labels", "(", "self", ",", "label", ")", ":", "\n", "        ", "\"\"\"\n        Randomly sample a subset of positive and negative examples, and overwrite\n        the label vector to the ignore value (-1) for all elements that are not\n        included in the sample.\n\n        Args:\n            labels (Tensor): a vector of -1, 0, 1. Will be modified in-place and returned.\n        \"\"\"", "\n", "pos_idx", ",", "neg_idx", "=", "subsample_labels", "(", "\n", "label", ",", "self", ".", "batch_size_per_image", ",", "self", ".", "positive_fraction", ",", "0", "\n", ")", "\n", "# Fill with the ignore label (-1), then set positive and negative labels", "\n", "label", ".", "fill_", "(", "-", "1", ")", "\n", "label", ".", "scatter_", "(", "0", ",", "pos_idx", ",", "1", ")", "\n", "label", ".", "scatter_", "(", "0", ",", "neg_idx", ",", "0", ")", "\n", "return", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rpn.RPN.label_and_sample_anchors": [[267, 326], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "detectron2.structures.Boxes.cat", "zip", "rpn.RPN.to", "rpn.RPN._subsample_labels", "gt_labels.append", "matched_gt_boxes.append", "detectron2.utils.memory.retry_if_cuda_oom", "detectron2.utils.memory.retry_if_cuda_oom", "detectron2.structures.Boxes.cat.inside_box", "len", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rpn.RPN._subsample_labels", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.memory.retry_if_cuda_oom", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.memory.retry_if_cuda_oom", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.inside_box"], ["", "@", "torch", ".", "jit", ".", "unused", "\n", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "label_and_sample_anchors", "(", "\n", "self", ",", "anchors", ":", "List", "[", "Boxes", "]", ",", "gt_instances", ":", "List", "[", "Instances", "]", "\n", ")", "->", "Tuple", "[", "List", "[", "torch", ".", "Tensor", "]", ",", "List", "[", "torch", ".", "Tensor", "]", "]", ":", "\n", "        ", "\"\"\"\n        Args:\n            anchors (list[Boxes]): anchors for each feature map.\n            gt_instances: the ground-truth instances for each image.\n\n        Returns:\n            list[Tensor]:\n                List of #img tensors. i-th element is a vector of labels whose length is\n                the total number of anchors across all feature maps R = sum(Hi * Wi * A).\n                Label values are in {-1, 0, 1}, with meanings: -1 = ignore; 0 = negative\n                class; 1 = positive class.\n            list[Tensor]:\n                i-th element is a Rx4 tensor. The values are the matched gt boxes for each\n                anchor. Values are undefined for those anchors not labeled as 1.\n        \"\"\"", "\n", "anchors", "=", "Boxes", ".", "cat", "(", "anchors", ")", "\n", "\n", "gt_boxes", "=", "[", "x", ".", "gt_boxes", "for", "x", "in", "gt_instances", "]", "\n", "image_sizes", "=", "[", "x", ".", "image_size", "for", "x", "in", "gt_instances", "]", "\n", "del", "gt_instances", "\n", "\n", "gt_labels", "=", "[", "]", "\n", "matched_gt_boxes", "=", "[", "]", "\n", "for", "image_size_i", ",", "gt_boxes_i", "in", "zip", "(", "image_sizes", ",", "gt_boxes", ")", ":", "\n", "            ", "\"\"\"\n            image_size_i: (h, w) for the i-th image\n            gt_boxes_i: ground-truth boxes for i-th image\n            \"\"\"", "\n", "\n", "match_quality_matrix", "=", "retry_if_cuda_oom", "(", "pairwise_iou", ")", "(", "gt_boxes_i", ",", "anchors", ")", "\n", "matched_idxs", ",", "gt_labels_i", "=", "retry_if_cuda_oom", "(", "self", ".", "anchor_matcher", ")", "(", "match_quality_matrix", ")", "\n", "# Matching is memory-expensive and may result in CPU tensors. But the result is small", "\n", "gt_labels_i", "=", "gt_labels_i", ".", "to", "(", "device", "=", "gt_boxes_i", ".", "device", ")", "\n", "del", "match_quality_matrix", "\n", "\n", "if", "self", ".", "anchor_boundary_thresh", ">=", "0", ":", "\n", "# Discard anchors that go out of the boundaries of the image", "\n", "# NOTE: This is legacy functionality that is turned off by default in Detectron2", "\n", "                ", "anchors_inside_image", "=", "anchors", ".", "inside_box", "(", "image_size_i", ",", "self", ".", "anchor_boundary_thresh", ")", "\n", "gt_labels_i", "[", "~", "anchors_inside_image", "]", "=", "-", "1", "\n", "\n", "# A vector of labels (-1, 0, 1) for each anchor", "\n", "", "gt_labels_i", "=", "self", ".", "_subsample_labels", "(", "gt_labels_i", ")", "\n", "\n", "if", "len", "(", "gt_boxes_i", ")", "==", "0", ":", "\n", "# These values won't be used anyway since the anchor is labeled as background", "\n", "                ", "matched_gt_boxes_i", "=", "torch", ".", "zeros_like", "(", "anchors", ".", "tensor", ")", "\n", "", "else", ":", "\n", "# TODO wasted indexing computation for ignored boxes", "\n", "                ", "matched_gt_boxes_i", "=", "gt_boxes_i", "[", "matched_idxs", "]", ".", "tensor", "\n", "\n", "", "gt_labels", ".", "append", "(", "gt_labels_i", ")", "# N,AHW", "\n", "matched_gt_boxes", ".", "append", "(", "matched_gt_boxes_i", ")", "\n", "", "return", "gt_labels", ",", "matched_gt_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rpn.RPN.losses": [[327, 401], ["len", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "pos_mask.view.view.sum().item", "detectron2.utils.events.get_event_storage", "detectron2.utils.events.get_event_storage.put_scalar", "detectron2.utils.events.get_event_storage.put_scalar", "torch.binary_cross_entropy_with_logits", "torch.binary_cross_entropy_with_logits", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "fvcore.nn.smooth_l1_loss", "gt_labels[].to", "pos_mask.view.view.sum", "type().cat", "rpn.RPN.box2box_transform.get_deltas", "rpn.RPN._decode_proposals", "detectron2.layers.cat", "pred_proposals.view.view.view", "pos_mask.view.view.view", "fvcore.nn.giou_loss", "ValueError", "detectron2.layers.cat", "rpn.RPN.loss_weight.get", "losses.items", "detectron2.layers.cat", "type", "detectron2.layers.cat"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.get_event_storage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.box_regression.Box2BoxTransformRotated.get_deltas", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rpn.RPN._decode_proposals", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "@", "torch", ".", "jit", ".", "unused", "\n", "def", "losses", "(", "\n", "self", ",", "\n", "anchors", ":", "List", "[", "Boxes", "]", ",", "\n", "pred_objectness_logits", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "\n", "gt_labels", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "\n", "pred_anchor_deltas", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "\n", "gt_boxes", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "\n", ")", "->", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Return the losses from a set of RPN predictions and their associated ground-truth.\n\n        Args:\n            anchors (list[Boxes or RotatedBoxes]): anchors for each feature map, each\n                has shape (Hi*Wi*A, B), where B is box dimension (4 or 5).\n            pred_objectness_logits (list[Tensor]): A list of L elements.\n                Element i is a tensor of shape (N, Hi*Wi*A) representing\n                the predicted objectness logits for all anchors.\n            gt_labels (list[Tensor]): Output of :meth:`label_and_sample_anchors`.\n            pred_anchor_deltas (list[Tensor]): A list of L elements. Element i is a tensor of shape\n                (N, Hi*Wi*A, 4 or 5) representing the predicted \"deltas\" used to transform anchors\n                to proposals.\n            gt_boxes (list[Tensor]): Output of :meth:`label_and_sample_anchors`.\n\n        Returns:\n            dict[loss name -> loss value]: A dict mapping from loss name to loss value.\n                Loss names are: `loss_rpn_cls` for objectness classification and\n                `loss_rpn_loc` for proposal localization.\n        \"\"\"", "\n", "num_images", "=", "len", "(", "gt_labels", ")", "\n", "gt_labels", "=", "torch", ".", "stack", "(", "gt_labels", ")", "# (N, sum(Hi*Wi*Ai))", "\n", "\n", "# Log the number of positive/negative anchors per-image that's used in training", "\n", "pos_mask", "=", "gt_labels", "==", "1", "\n", "num_pos_anchors", "=", "pos_mask", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "num_neg_anchors", "=", "(", "gt_labels", "==", "0", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "storage", ".", "put_scalar", "(", "\"rpn/num_pos_anchors\"", ",", "num_pos_anchors", "/", "num_images", ")", "\n", "storage", ".", "put_scalar", "(", "\"rpn/num_neg_anchors\"", ",", "num_neg_anchors", "/", "num_images", ")", "\n", "\n", "if", "self", ".", "box_reg_loss_type", "==", "\"smooth_l1\"", ":", "\n", "            ", "anchors", "=", "type", "(", "anchors", "[", "0", "]", ")", ".", "cat", "(", "anchors", ")", ".", "tensor", "# Ax(4 or 5)", "\n", "gt_anchor_deltas", "=", "[", "self", ".", "box2box_transform", ".", "get_deltas", "(", "anchors", ",", "k", ")", "for", "k", "in", "gt_boxes", "]", "\n", "gt_anchor_deltas", "=", "torch", ".", "stack", "(", "gt_anchor_deltas", ")", "# (N, sum(Hi*Wi*Ai), 4 or 5)", "\n", "localization_loss", "=", "smooth_l1_loss", "(", "\n", "cat", "(", "pred_anchor_deltas", ",", "dim", "=", "1", ")", "[", "pos_mask", "]", ",", "\n", "gt_anchor_deltas", "[", "pos_mask", "]", ",", "\n", "self", ".", "smooth_l1_beta", ",", "\n", "reduction", "=", "\"sum\"", ",", "\n", ")", "\n", "", "elif", "self", ".", "box_reg_loss_type", "==", "\"giou\"", ":", "\n", "            ", "pred_proposals", "=", "self", ".", "_decode_proposals", "(", "anchors", ",", "pred_anchor_deltas", ")", "\n", "pred_proposals", "=", "cat", "(", "pred_proposals", ",", "dim", "=", "1", ")", "\n", "pred_proposals", "=", "pred_proposals", ".", "view", "(", "-", "1", ",", "pred_proposals", ".", "shape", "[", "-", "1", "]", ")", "\n", "pos_mask", "=", "pos_mask", ".", "view", "(", "-", "1", ")", "\n", "localization_loss", "=", "giou_loss", "(", "\n", "pred_proposals", "[", "pos_mask", "]", ",", "cat", "(", "gt_boxes", ")", "[", "pos_mask", "]", ",", "reduction", "=", "\"sum\"", "\n", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Invalid rpn box reg loss type '{self.box_reg_loss_type}'\"", ")", "\n", "\n", "", "valid_mask", "=", "gt_labels", ">=", "0", "\n", "objectness_loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "cat", "(", "pred_objectness_logits", ",", "dim", "=", "1", ")", "[", "valid_mask", "]", ",", "\n", "gt_labels", "[", "valid_mask", "]", ".", "to", "(", "torch", ".", "float32", ")", ",", "\n", "reduction", "=", "\"sum\"", ",", "\n", ")", "\n", "normalizer", "=", "self", ".", "batch_size_per_image", "*", "num_images", "\n", "losses", "=", "{", "\n", "\"loss_rpn_cls\"", ":", "objectness_loss", "/", "normalizer", ",", "\n", "\"loss_rpn_loc\"", ":", "localization_loss", "/", "normalizer", ",", "\n", "}", "\n", "losses", "=", "{", "k", ":", "v", "*", "self", ".", "loss_weight", ".", "get", "(", "k", ",", "1.0", ")", "for", "k", ",", "v", "in", "losses", ".", "items", "(", ")", "}", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rpn.RPN.forward": [[402, 452], ["rpn.RPN.anchor_generator", "rpn.RPN.rpn_head", "rpn.RPN.predict_proposals", "score.permute().flatten", "x.view().permute().flatten", "rpn.RPN.label_and_sample_anchors", "rpn.RPN.losses", "score.permute", "x.view().permute", "x.view"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rrpn.RRPN.predict_proposals", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rrpn.RRPN.label_and_sample_anchors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3Head.losses"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "images", ":", "ImageList", ",", "\n", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "\n", "gt_instances", ":", "Optional", "[", "List", "[", "Instances", "]", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            images (ImageList): input images of length `N`\n            features (dict[str, Tensor]): input data as a mapping from feature\n                map name to tensor. Axis 0 represents the number of images `N` in\n                the input data; axes 1-3 are channels, height, and width, which may\n                vary between feature maps (e.g., if a feature pyramid is used).\n            gt_instances (list[Instances], optional): a length `N` list of `Instances`s.\n                Each `Instances` stores ground-truth instances for the corresponding image.\n\n        Returns:\n            proposals: list[Instances]: contains fields \"proposal_boxes\", \"objectness_logits\"\n            loss: dict[Tensor] or None\n        \"\"\"", "\n", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", "\n", "anchors", "=", "self", ".", "anchor_generator", "(", "features", ")", "\n", "\n", "pred_objectness_logits", ",", "pred_anchor_deltas", "=", "self", ".", "rpn_head", "(", "features", ")", "\n", "# Transpose the Hi*Wi*A dimension to the middle:", "\n", "pred_objectness_logits", "=", "[", "\n", "# (N, A, Hi, Wi) -> (N, Hi, Wi, A) -> (N, Hi*Wi*A)", "\n", "score", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "flatten", "(", "1", ")", "\n", "for", "score", "in", "pred_objectness_logits", "\n", "]", "\n", "pred_anchor_deltas", "=", "[", "\n", "# (N, A*B, Hi, Wi) -> (N, A, B, Hi, Wi) -> (N, Hi, Wi, A, B) -> (N, Hi*Wi*A, B)", "\n", "x", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "-", "1", ",", "self", ".", "anchor_generator", ".", "box_dim", ",", "x", ".", "shape", "[", "-", "2", "]", ",", "x", ".", "shape", "[", "-", "1", "]", ")", "\n", ".", "permute", "(", "0", ",", "3", ",", "4", ",", "1", ",", "2", ")", "\n", ".", "flatten", "(", "1", ",", "-", "2", ")", "\n", "for", "x", "in", "pred_anchor_deltas", "\n", "]", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "assert", "gt_instances", "is", "not", "None", ",", "\"RPN requires gt_instances in training!\"", "\n", "gt_labels", ",", "gt_boxes", "=", "self", ".", "label_and_sample_anchors", "(", "anchors", ",", "gt_instances", ")", "\n", "losses", "=", "self", ".", "losses", "(", "\n", "anchors", ",", "pred_objectness_logits", ",", "gt_labels", ",", "pred_anchor_deltas", ",", "gt_boxes", "\n", ")", "\n", "", "else", ":", "\n", "            ", "losses", "=", "{", "}", "\n", "", "proposals", "=", "self", ".", "predict_proposals", "(", "\n", "anchors", ",", "pred_objectness_logits", ",", "pred_anchor_deltas", ",", "images", ".", "image_sizes", "\n", ")", "\n", "return", "proposals", ",", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rpn.RPN.predict_proposals": [[453, 483], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "rpn.RPN._decode_proposals", "proposal_utils.find_top_rpn_proposals"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rpn.RPN._decode_proposals", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.proposal_utils.find_top_rpn_proposals"], ["", "def", "predict_proposals", "(", "\n", "self", ",", "\n", "anchors", ":", "List", "[", "Boxes", "]", ",", "\n", "pred_objectness_logits", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "\n", "pred_anchor_deltas", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "\n", "image_sizes", ":", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Decode all the predicted box regression deltas to proposals. Find the top proposals\n        by applying NMS and removing boxes that are too small.\n\n        Returns:\n            proposals (list[Instances]): list of N Instances. The i-th Instances\n                stores post_nms_topk object proposals for image i, sorted by their\n                objectness score in descending order.\n        \"\"\"", "\n", "# The proposals are treated as fixed for joint training with roi heads.", "\n", "# This approach ignores the derivative w.r.t. the proposal boxes\u2019 coordinates that", "\n", "# are also network responses.", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "pred_proposals", "=", "self", ".", "_decode_proposals", "(", "anchors", ",", "pred_anchor_deltas", ")", "\n", "return", "find_top_rpn_proposals", "(", "\n", "pred_proposals", ",", "\n", "pred_objectness_logits", ",", "\n", "image_sizes", ",", "\n", "self", ".", "nms_thresh", ",", "\n", "self", ".", "pre_nms_topk", "[", "self", ".", "training", "]", ",", "\n", "self", ".", "post_nms_topk", "[", "self", ".", "training", "]", ",", "\n", "self", ".", "min_box_size", ",", "\n", "self", ".", "training", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rpn.RPN._decode_proposals": [[485, 505], ["zip", "anchors_i.tensor.unsqueeze().expand().reshape.tensor.unsqueeze().expand().reshape.tensor.size", "pred_anchor_deltas_i.reshape.reshape.reshape", "anchors_i.tensor.unsqueeze().expand().reshape.tensor.unsqueeze().expand().reshape.tensor.unsqueeze().expand().reshape", "rpn.RPN.box2box_transform.apply_deltas", "proposals.append", "rpn.RPN.view", "anchors_i.tensor.unsqueeze().expand().reshape.tensor.unsqueeze().expand().reshape.tensor.unsqueeze().expand", "anchors_i.tensor.unsqueeze().expand().reshape.tensor.unsqueeze().expand().reshape.tensor.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.box_regression.Box2BoxTransformRotated.apply_deltas"], ["", "", "def", "_decode_proposals", "(", "self", ",", "anchors", ":", "List", "[", "Boxes", "]", ",", "pred_anchor_deltas", ":", "List", "[", "torch", ".", "Tensor", "]", ")", ":", "\n", "        ", "\"\"\"\n        Transform anchors into proposals by applying the predicted anchor deltas.\n\n        Returns:\n            proposals (list[Tensor]): A list of L tensors. Tensor i has shape\n                (N, Hi*Wi*A, B)\n        \"\"\"", "\n", "N", "=", "pred_anchor_deltas", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "proposals", "=", "[", "]", "\n", "# For each feature map", "\n", "for", "anchors_i", ",", "pred_anchor_deltas_i", "in", "zip", "(", "anchors", ",", "pred_anchor_deltas", ")", ":", "\n", "            ", "B", "=", "anchors_i", ".", "tensor", ".", "size", "(", "1", ")", "\n", "pred_anchor_deltas_i", "=", "pred_anchor_deltas_i", ".", "reshape", "(", "-", "1", ",", "B", ")", "\n", "# Expand anchors to shape (N*Hi*Wi*A, B)", "\n", "anchors_i", "=", "anchors_i", ".", "tensor", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "N", ",", "-", "1", ",", "-", "1", ")", ".", "reshape", "(", "-", "1", ",", "B", ")", "\n", "proposals_i", "=", "self", ".", "box2box_transform", ".", "apply_deltas", "(", "pred_anchor_deltas_i", ",", "anchors_i", ")", "\n", "# Append feature map proposals with shape (N, Hi*Wi*A, B)", "\n", "proposals", ".", "append", "(", "proposals_i", ".", "view", "(", "N", ",", "-", "1", ",", "B", ")", ")", "\n", "", "return", "proposals", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rpn.build_rpn_head": [[59, 65], ["RPN_HEAD_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["def", "build_rpn_head", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build an RPN head defined by `cfg.MODEL.RPN.HEAD_NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "RPN", ".", "HEAD_NAME", "\n", "return", "RPN_HEAD_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rrpn.RRPN.__init__": [[129, 135], ["box_regression.Box2BoxTransformRotated", "rpn.RPN.__init__", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "Dict", "[", "str", ",", "ShapeSpec", "]", ")", ":", "\n", "        ", "box2box_transform", "=", "Box2BoxTransformRotated", "(", "weights", "=", "cfg", ".", "MODEL", ".", "RPN", ".", "BBOX_REG_WEIGHTS", ")", "\n", "super", "(", ")", ".", "__init__", "(", "cfg", ",", "input_shape", ",", "box2box_transform", "=", "box2box_transform", ")", "\n", "if", "self", ".", "anchor_boundary_thresh", ">=", "0", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"anchor_boundary_thresh is a legacy option not implemented for RRPN.\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rrpn.RRPN.label_and_sample_anchors": [[137, 183], ["torch.no_grad", "detectron2.structures.RotatedBoxes.cat", "rrpn.RRPN.to", "rrpn.RRPN._subsample_labels", "gt_labels.append", "matched_gt_boxes.append", "detectron2.utils.memory.retry_if_cuda_oom", "detectron2.utils.memory.retry_if_cuda_oom", "len", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rpn.RPN._subsample_labels", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.memory.retry_if_cuda_oom", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.memory.retry_if_cuda_oom"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "label_and_sample_anchors", "(", "self", ",", "anchors", ":", "List", "[", "RotatedBoxes", "]", ",", "gt_instances", ":", "List", "[", "Instances", "]", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            anchors (list[RotatedBoxes]): anchors for each feature map.\n            gt_instances: the ground-truth instances for each image.\n\n        Returns:\n            list[Tensor]:\n                List of #img tensors. i-th element is a vector of labels whose length is\n                the total number of anchors across feature maps. Label values are in {-1, 0, 1},\n                with meanings: -1 = ignore; 0 = negative class; 1 = positive class.\n            list[Tensor]:\n                i-th element is a Nx5 tensor, where N is the total number of anchors across\n                feature maps.  The values are the matched gt boxes for each anchor.\n                Values are undefined for those anchors not labeled as 1.\n        \"\"\"", "\n", "anchors", "=", "RotatedBoxes", ".", "cat", "(", "anchors", ")", "\n", "\n", "gt_boxes", "=", "[", "x", ".", "gt_boxes", "for", "x", "in", "gt_instances", "]", "\n", "del", "gt_instances", "\n", "\n", "gt_labels", "=", "[", "]", "\n", "matched_gt_boxes", "=", "[", "]", "\n", "for", "gt_boxes_i", "in", "gt_boxes", ":", "\n", "            ", "\"\"\"\n            gt_boxes_i: ground-truth boxes for i-th image\n            \"\"\"", "\n", "match_quality_matrix", "=", "retry_if_cuda_oom", "(", "pairwise_iou_rotated", ")", "(", "gt_boxes_i", ",", "anchors", ")", "\n", "matched_idxs", ",", "gt_labels_i", "=", "retry_if_cuda_oom", "(", "self", ".", "anchor_matcher", ")", "(", "match_quality_matrix", ")", "\n", "# Matching is memory-expensive and may result in CPU tensors. But the result is small", "\n", "gt_labels_i", "=", "gt_labels_i", ".", "to", "(", "device", "=", "gt_boxes_i", ".", "device", ")", "\n", "\n", "# A vector of labels (-1, 0, 1) for each anchor", "\n", "gt_labels_i", "=", "self", ".", "_subsample_labels", "(", "gt_labels_i", ")", "\n", "\n", "if", "len", "(", "gt_boxes_i", ")", "==", "0", ":", "\n", "# These values won't be used anyway since the anchor is labeled as background", "\n", "                ", "matched_gt_boxes_i", "=", "torch", ".", "zeros_like", "(", "anchors", ".", "tensor", ")", "\n", "", "else", ":", "\n", "# TODO wasted indexing computation for ignored boxes", "\n", "                ", "matched_gt_boxes_i", "=", "gt_boxes_i", "[", "matched_idxs", "]", ".", "tensor", "\n", "\n", "", "gt_labels", ".", "append", "(", "gt_labels_i", ")", "# N,AHW", "\n", "matched_gt_boxes", ".", "append", "(", "matched_gt_boxes_i", ")", "\n", "", "return", "gt_labels", ",", "matched_gt_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rrpn.RRPN.predict_proposals": [[184, 196], ["torch.no_grad", "rrpn.RRPN._decode_proposals", "rrpn.find_top_rrpn_proposals"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rpn.RPN._decode_proposals", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rrpn.find_top_rrpn_proposals"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "predict_proposals", "(", "self", ",", "anchors", ",", "pred_objectness_logits", ",", "pred_anchor_deltas", ",", "image_sizes", ")", ":", "\n", "        ", "pred_proposals", "=", "self", ".", "_decode_proposals", "(", "anchors", ",", "pred_anchor_deltas", ")", "\n", "return", "find_top_rrpn_proposals", "(", "\n", "pred_proposals", ",", "\n", "pred_objectness_logits", ",", "\n", "image_sizes", ",", "\n", "self", ".", "nms_thresh", ",", "\n", "self", ".", "pre_nms_topk", "[", "self", ".", "training", "]", ",", "\n", "self", ".", "post_nms_topk", "[", "self", ".", "training", "]", ",", "\n", "self", ".", "min_box_size", ",", "\n", "self", ".", "training", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.rrpn.find_top_rrpn_proposals": [[18, 121], ["len", "torch.arange", "zip", "detectron2.layers.cat", "detectron2.layers.cat", "detectron2.layers.cat", "enumerate", "itertools.count", "min", "logits_i.sort", "detectron2.layers.cat.append", "detectron2.layers.cat.append", "detectron2.layers.cat.append", "detectron2.structures.RotatedBoxes", "detectron2.structures.RotatedBoxes.clip", "detectron2.structures.RotatedBoxes.nonempty", "detectron2.layers.batched_nms_rotated", "detectron2.structures.Instances", "results.append", "torch.full", "torch.isfinite().all", "torch.isfinite", "valid_mask.all", "detectron2.layers.batched_nms_rotated.sum().item", "len", "torch.isfinite", "detectron2.layers.batched_nms_rotated.sum"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.nonempty", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.batched_nms_rotated"], ["def", "find_top_rrpn_proposals", "(", "\n", "proposals", ",", "\n", "pred_objectness_logits", ",", "\n", "image_sizes", ",", "\n", "nms_thresh", ",", "\n", "pre_nms_topk", ",", "\n", "post_nms_topk", ",", "\n", "min_box_size", ",", "\n", "training", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    For each feature map, select the `pre_nms_topk` highest scoring proposals,\n    apply NMS, clip proposals, and remove small boxes. Return the `post_nms_topk`\n    highest scoring proposals among all the feature maps if `training` is True,\n    otherwise, returns the highest `post_nms_topk` scoring proposals for each\n    feature map.\n\n    Args:\n        proposals (list[Tensor]): A list of L tensors. Tensor i has shape (N, Hi*Wi*A, 5).\n            All proposal predictions on the feature maps.\n        pred_objectness_logits (list[Tensor]): A list of L tensors. Tensor i has shape (N, Hi*Wi*A).\n        image_sizes (list[tuple]): sizes (h, w) for each image\n        nms_thresh (float): IoU threshold to use for NMS\n        pre_nms_topk (int): number of top k scoring proposals to keep before applying NMS.\n            When RRPN is run on multiple feature maps (as in FPN) this number is per\n            feature map.\n        post_nms_topk (int): number of top k scoring proposals to keep after applying NMS.\n            When RRPN is run on multiple feature maps (as in FPN) this number is total,\n            over all feature maps.\n        min_box_size(float): minimum proposal box side length in pixels (absolute units wrt\n            input images).\n        training (bool): True if proposals are to be used in training, otherwise False.\n            This arg exists only to support a legacy bug; look for the \"NB: Legacy bug ...\"\n            comment.\n\n    Returns:\n        proposals (list[Instances]): list of N Instances. The i-th Instances\n            stores post_nms_topk object proposals for image i.\n    \"\"\"", "\n", "num_images", "=", "len", "(", "image_sizes", ")", "\n", "device", "=", "proposals", "[", "0", "]", ".", "device", "\n", "\n", "# 1. Select top-k anchor for every level and every image", "\n", "topk_scores", "=", "[", "]", "# #lvl Tensor, each of shape N x topk", "\n", "topk_proposals", "=", "[", "]", "\n", "level_ids", "=", "[", "]", "# #lvl Tensor, each of shape (topk,)", "\n", "batch_idx", "=", "torch", ".", "arange", "(", "num_images", ",", "device", "=", "device", ")", "\n", "for", "level_id", ",", "proposals_i", ",", "logits_i", "in", "zip", "(", "\n", "itertools", ".", "count", "(", ")", ",", "proposals", ",", "pred_objectness_logits", "\n", ")", ":", "\n", "        ", "Hi_Wi_A", "=", "logits_i", ".", "shape", "[", "1", "]", "\n", "num_proposals_i", "=", "min", "(", "pre_nms_topk", ",", "Hi_Wi_A", ")", "\n", "\n", "# sort is faster than topk (https://github.com/pytorch/pytorch/issues/22812)", "\n", "# topk_scores_i, topk_idx = logits_i.topk(num_proposals_i, dim=1)", "\n", "logits_i", ",", "idx", "=", "logits_i", ".", "sort", "(", "descending", "=", "True", ",", "dim", "=", "1", ")", "\n", "topk_scores_i", "=", "logits_i", "[", "batch_idx", ",", ":", "num_proposals_i", "]", "\n", "topk_idx", "=", "idx", "[", "batch_idx", ",", ":", "num_proposals_i", "]", "\n", "\n", "# each is N x topk", "\n", "topk_proposals_i", "=", "proposals_i", "[", "batch_idx", "[", ":", ",", "None", "]", ",", "topk_idx", "]", "# N x topk x 5", "\n", "\n", "topk_proposals", ".", "append", "(", "topk_proposals_i", ")", "\n", "topk_scores", ".", "append", "(", "topk_scores_i", ")", "\n", "level_ids", ".", "append", "(", "torch", ".", "full", "(", "(", "num_proposals_i", ",", ")", ",", "level_id", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "device", ")", ")", "\n", "\n", "# 2. Concat all levels together", "\n", "", "topk_scores", "=", "cat", "(", "topk_scores", ",", "dim", "=", "1", ")", "\n", "topk_proposals", "=", "cat", "(", "topk_proposals", ",", "dim", "=", "1", ")", "\n", "level_ids", "=", "cat", "(", "level_ids", ",", "dim", "=", "0", ")", "\n", "\n", "# 3. For each image, run a per-level NMS, and choose topk results.", "\n", "results", "=", "[", "]", "\n", "for", "n", ",", "image_size", "in", "enumerate", "(", "image_sizes", ")", ":", "\n", "        ", "boxes", "=", "RotatedBoxes", "(", "topk_proposals", "[", "n", "]", ")", "\n", "scores_per_img", "=", "topk_scores", "[", "n", "]", "\n", "valid_mask", "=", "torch", ".", "isfinite", "(", "boxes", ".", "tensor", ")", ".", "all", "(", "dim", "=", "1", ")", "&", "torch", ".", "isfinite", "(", "scores_per_img", ")", "\n", "if", "not", "valid_mask", ".", "all", "(", ")", ":", "\n", "            ", "boxes", "=", "boxes", "[", "valid_mask", "]", "\n", "scores_per_img", "=", "scores_per_img", "[", "valid_mask", "]", "\n", "", "boxes", ".", "clip", "(", "image_size", ")", "\n", "\n", "# filter empty boxes", "\n", "keep", "=", "boxes", ".", "nonempty", "(", "threshold", "=", "min_box_size", ")", "\n", "lvl", "=", "level_ids", "\n", "if", "keep", ".", "sum", "(", ")", ".", "item", "(", ")", "!=", "len", "(", "boxes", ")", ":", "\n", "            ", "boxes", ",", "scores_per_img", ",", "lvl", "=", "(", "boxes", "[", "keep", "]", ",", "scores_per_img", "[", "keep", "]", ",", "level_ids", "[", "keep", "]", ")", "\n", "\n", "", "keep", "=", "batched_nms_rotated", "(", "boxes", ".", "tensor", ",", "scores_per_img", ",", "lvl", ",", "nms_thresh", ")", "\n", "# In Detectron1, there was different behavior during training vs. testing.", "\n", "# (https://github.com/facebookresearch/Detectron/issues/459)", "\n", "# During training, topk is over the proposals from *all* images in the training batch.", "\n", "# During testing, it is over the proposals for each image separately.", "\n", "# As a result, the training behavior becomes batch-dependent,", "\n", "# and the configuration \"POST_NMS_TOPK_TRAIN\" end up relying on the batch size.", "\n", "# This bug is addressed in Detectron2 to make the behavior independent of batch size.", "\n", "keep", "=", "keep", "[", ":", "post_nms_topk", "]", "\n", "\n", "res", "=", "Instances", "(", "image_size", ")", "\n", "res", ".", "proposal_boxes", "=", "boxes", "[", "keep", "]", "\n", "res", ".", "objectness_logits", "=", "scores_per_img", "[", "keep", "]", "\n", "results", ".", "append", "(", "res", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.build.build_proposal_generator": [[15, 25], ["PROPOSAL_GENERATOR_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["def", "build_model", "(", "cfg", ")", ":", "\n", "    ", "\"\"\"\n    Build the whole model architecture, defined by ``cfg.MODEL.META_ARCHITECTURE``.\n    Note that it does not load any weights from ``cfg``.\n    \"\"\"", "\n", "meta_arch", "=", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "\n", "model", "=", "META_ARCH_REGISTRY", ".", "get", "(", "meta_arch", ")", "(", "cfg", ")", "\n", "model", ".", "to", "(", "torch", ".", "device", "(", "cfg", ".", "MODEL", ".", "DEVICE", ")", ")", "\n", "return", "model", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.mask_head.BaseMaskRCNNHead.__init__": [[160, 170], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "self", ",", "*", ",", "vis_period", "=", "0", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            vis_period (int): visualization period\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "vis_period", "=", "vis_period", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.mask_head.BaseMaskRCNNHead.from_config": [[171, 174], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "return", "{", "\"vis_period\"", ":", "cfg", ".", "VIS_PERIOD", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.mask_head.BaseMaskRCNNHead.forward": [[175, 195], ["mask_head.BaseMaskRCNNHead.layers", "mask_head.mask_rcnn_inference", "mask_head.mask_rcnn_loss"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3PlusHead.layers", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.mask_head.mask_rcnn_inference", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.mask_head.mask_rcnn_loss"], ["", "def", "forward", "(", "self", ",", "x", ",", "instances", ":", "List", "[", "Instances", "]", ")", "->", "Any", ":", "\n", "        ", "\"\"\"\n        Args:\n            x: input region feature(s) provided by :class:`ROIHeads`.\n            instances (list[Instances]): contains the boxes & labels corresponding\n                to the input features.\n                Exact format is up to its caller to decide.\n                Typically, this is the foreground instances in training, with\n                \"proposal_boxes\" field and other gt annotations.\n                In inference, it contains boxes that are already predicted.\n\n        Returns:\n            A dict of losses in training. The predicted \"instances\" in inference.\n        \"\"\"", "\n", "x", "=", "self", ".", "layers", "(", "x", ")", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "{", "\"loss_mask\"", ":", "mask_rcnn_loss", "(", "x", ",", "instances", ",", "self", ".", "vis_period", ")", "}", "\n", "", "else", ":", "\n", "            ", "mask_rcnn_inference", "(", "x", ",", "instances", ")", "\n", "return", "instances", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.mask_head.BaseMaskRCNNHead.layers": [[196, 201], ["None"], "methods", ["None"], ["", "", "def", "layers", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Neural network layers that makes predictions from input features.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.mask_head.MaskRCNNConvUpsampleHead.__init__": [[213, 261], ["super().__init__", "enumerate", "detectron2.layers.ConvTranspose2d", "mask_head.MaskRCNNConvUpsampleHead.add_module", "detectron2.layers.Conv2d", "torch.nn.init.normal_", "len", "detectron2.layers.Conv2d", "mask_head.MaskRCNNConvUpsampleHead.add_module", "mask_head.MaskRCNNConvUpsampleHead.conv_norm_relus.append", "torch.nn.ReLU", "fvcore.c2_msra_fill", "torch.nn.init.constant_", "detectron2.layers.get_norm", "torch.nn.ReLU"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm"], ["@", "configurable", "\n", "def", "__init__", "(", "self", ",", "input_shape", ":", "ShapeSpec", ",", "*", ",", "num_classes", ",", "conv_dims", ",", "conv_norm", "=", "\"\"", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            input_shape (ShapeSpec): shape of the input feature\n            num_classes (int): the number of classes. 1 if using class agnostic prediction.\n            conv_dims (list[int]): a list of N>0 integers representing the output dimensions\n                of N-1 conv layers and the last upsample layer.\n            conv_norm (str or callable): normalization for the conv layers.\n                See :func:`detectron2.layers.get_norm` for supported types.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "assert", "len", "(", "conv_dims", ")", ">=", "1", ",", "\"conv_dims have to be non-empty!\"", "\n", "\n", "self", ".", "conv_norm_relus", "=", "[", "]", "\n", "\n", "cur_channels", "=", "input_shape", ".", "channels", "\n", "for", "k", ",", "conv_dim", "in", "enumerate", "(", "conv_dims", "[", ":", "-", "1", "]", ")", ":", "\n", "            ", "conv", "=", "Conv2d", "(", "\n", "cur_channels", ",", "\n", "conv_dim", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "not", "conv_norm", ",", "\n", "norm", "=", "get_norm", "(", "conv_norm", ",", "conv_dim", ")", ",", "\n", "activation", "=", "nn", ".", "ReLU", "(", ")", ",", "\n", ")", "\n", "self", ".", "add_module", "(", "\"mask_fcn{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "conv", ")", "\n", "self", ".", "conv_norm_relus", ".", "append", "(", "conv", ")", "\n", "cur_channels", "=", "conv_dim", "\n", "\n", "", "self", ".", "deconv", "=", "ConvTranspose2d", "(", "\n", "cur_channels", ",", "conv_dims", "[", "-", "1", "]", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ",", "padding", "=", "0", "\n", ")", "\n", "self", ".", "add_module", "(", "\"deconv_relu\"", ",", "nn", ".", "ReLU", "(", ")", ")", "\n", "cur_channels", "=", "conv_dims", "[", "-", "1", "]", "\n", "\n", "self", ".", "predictor", "=", "Conv2d", "(", "cur_channels", ",", "num_classes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "\n", "for", "layer", "in", "self", ".", "conv_norm_relus", "+", "[", "self", ".", "deconv", "]", ":", "\n", "            ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "# use normal distribution initialization for mask prediction layer", "\n", "", "nn", ".", "init", ".", "normal_", "(", "self", ".", "predictor", ".", "weight", ",", "std", "=", "0.001", ")", "\n", "if", "self", ".", "predictor", ".", "bias", "is", "not", "None", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "self", ".", "predictor", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.mask_head.MaskRCNNConvUpsampleHead.from_config": [[262, 277], ["super().from_config", "super().from_config.update"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3PlusHead.from_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update"], ["", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "ret", "=", "super", "(", ")", ".", "from_config", "(", "cfg", ",", "input_shape", ")", "\n", "conv_dim", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "CONV_DIM", "\n", "num_conv", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "NUM_CONV", "\n", "ret", ".", "update", "(", "\n", "conv_dims", "=", "[", "conv_dim", "]", "*", "(", "num_conv", "+", "1", ")", ",", "# +1 for ConvTranspose", "\n", "conv_norm", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "NORM", ",", "\n", "input_shape", "=", "input_shape", ",", "\n", ")", "\n", "if", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "CLS_AGNOSTIC_MASK", ":", "\n", "            ", "ret", "[", "\"num_classes\"", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "ret", "[", "\"num_classes\"", "]", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NUM_CLASSES", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.mask_head.MaskRCNNConvUpsampleHead.layers": [[278, 282], ["layer"], "methods", ["None"], ["", "def", "layers", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "layer", "in", "self", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.mask_head.mask_rcnn_loss": [[31, 112], ["pred_mask_logits.size", "pred_mask_logits.size", "detectron2.layers.cat", "gt_masks.to.to", "gt_masks_bool.sum().item", "detectron2.utils.events.get_event_storage", "detectron2.utils.events.get_event_storage.put_scalar", "detectron2.utils.events.get_event_storage.put_scalar", "detectron2.utils.events.get_event_storage.put_scalar", "torch.nn.functional.binary_cross_entropy_with_logits", "pred_mask_logits.size", "pred_mask_logits.size", "pred_mask_logits.size", "instances_per_image.gt_masks.crop_and_resize().to", "gt_masks.to.append", "len", "torch.arange", "detectron2.layers.cat", "max", "max", "pred_mask_logits.sigmoid", "torch.cat", "enumerate", "len", "instances_per_image.gt_classes.to", "detectron2.layers.cat.append", "pred_mask_logits.sum", "mask_incorrect.sum().item", "max", "gt_masks_bool.sum", "torch.stack", "detectron2.utils.events.get_event_storage.put_image", "instances_per_image.gt_masks.crop_and_resize", "mask_incorrect.numel", "gt_masks_bool.numel", "mask_incorrect.sum"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.get_event_storage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.PolygonMasks.crop_and_resize"], ["@", "torch", ".", "jit", ".", "unused", "\n", "def", "mask_rcnn_loss", "(", "pred_mask_logits", ":", "torch", ".", "Tensor", ",", "instances", ":", "List", "[", "Instances", "]", ",", "vis_period", ":", "int", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Compute the mask prediction loss defined in the Mask R-CNN paper.\n\n    Args:\n        pred_mask_logits (Tensor): A tensor of shape (B, C, Hmask, Wmask) or (B, 1, Hmask, Wmask)\n            for class-specific or class-agnostic, where B is the total number of predicted masks\n            in all images, C is the number of foreground classes, and Hmask, Wmask are the height\n            and width of the mask predictions. The values are logits.\n        instances (list[Instances]): A list of N Instances, where N is the number of images\n            in the batch. These instances are in 1:1\n            correspondence with the pred_mask_logits. The ground-truth labels (class, box, mask,\n            ...) associated with each instance are stored in fields.\n        vis_period (int): the period (in steps) to dump visualization.\n\n    Returns:\n        mask_loss (Tensor): A scalar tensor containing the loss.\n    \"\"\"", "\n", "cls_agnostic_mask", "=", "pred_mask_logits", ".", "size", "(", "1", ")", "==", "1", "\n", "total_num_masks", "=", "pred_mask_logits", ".", "size", "(", "0", ")", "\n", "mask_side_len", "=", "pred_mask_logits", ".", "size", "(", "2", ")", "\n", "assert", "pred_mask_logits", ".", "size", "(", "2", ")", "==", "pred_mask_logits", ".", "size", "(", "3", ")", ",", "\"Mask prediction must be square!\"", "\n", "\n", "gt_classes", "=", "[", "]", "\n", "gt_masks", "=", "[", "]", "\n", "for", "instances_per_image", "in", "instances", ":", "\n", "        ", "if", "len", "(", "instances_per_image", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "", "if", "not", "cls_agnostic_mask", ":", "\n", "            ", "gt_classes_per_image", "=", "instances_per_image", ".", "gt_classes", ".", "to", "(", "dtype", "=", "torch", ".", "int64", ")", "\n", "gt_classes", ".", "append", "(", "gt_classes_per_image", ")", "\n", "\n", "", "gt_masks_per_image", "=", "instances_per_image", ".", "gt_masks", ".", "crop_and_resize", "(", "\n", "instances_per_image", ".", "proposal_boxes", ".", "tensor", ",", "mask_side_len", "\n", ")", ".", "to", "(", "device", "=", "pred_mask_logits", ".", "device", ")", "\n", "# A tensor of shape (N, M, M), N=#instances in the image; M=mask_side_len", "\n", "gt_masks", ".", "append", "(", "gt_masks_per_image", ")", "\n", "\n", "", "if", "len", "(", "gt_masks", ")", "==", "0", ":", "\n", "        ", "return", "pred_mask_logits", ".", "sum", "(", ")", "*", "0", "\n", "\n", "", "gt_masks", "=", "cat", "(", "gt_masks", ",", "dim", "=", "0", ")", "\n", "\n", "if", "cls_agnostic_mask", ":", "\n", "        ", "pred_mask_logits", "=", "pred_mask_logits", "[", ":", ",", "0", "]", "\n", "", "else", ":", "\n", "        ", "indices", "=", "torch", ".", "arange", "(", "total_num_masks", ")", "\n", "gt_classes", "=", "cat", "(", "gt_classes", ",", "dim", "=", "0", ")", "\n", "pred_mask_logits", "=", "pred_mask_logits", "[", "indices", ",", "gt_classes", "]", "\n", "\n", "", "if", "gt_masks", ".", "dtype", "==", "torch", ".", "bool", ":", "\n", "        ", "gt_masks_bool", "=", "gt_masks", "\n", "", "else", ":", "\n", "# Here we allow gt_masks to be float as well (depend on the implementation of rasterize())", "\n", "        ", "gt_masks_bool", "=", "gt_masks", ">", "0.5", "\n", "", "gt_masks", "=", "gt_masks", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "# Log the training accuracy (using gt classes and 0.5 threshold)", "\n", "mask_incorrect", "=", "(", "pred_mask_logits", ">", "0.0", ")", "!=", "gt_masks_bool", "\n", "mask_accuracy", "=", "1", "-", "(", "mask_incorrect", ".", "sum", "(", ")", ".", "item", "(", ")", "/", "max", "(", "mask_incorrect", ".", "numel", "(", ")", ",", "1.0", ")", ")", "\n", "num_positive", "=", "gt_masks_bool", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "false_positive", "=", "(", "mask_incorrect", "&", "~", "gt_masks_bool", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "/", "max", "(", "\n", "gt_masks_bool", ".", "numel", "(", ")", "-", "num_positive", ",", "1.0", "\n", ")", "\n", "false_negative", "=", "(", "mask_incorrect", "&", "gt_masks_bool", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "/", "max", "(", "num_positive", ",", "1.0", ")", "\n", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "storage", ".", "put_scalar", "(", "\"mask_rcnn/accuracy\"", ",", "mask_accuracy", ")", "\n", "storage", ".", "put_scalar", "(", "\"mask_rcnn/false_positive\"", ",", "false_positive", ")", "\n", "storage", ".", "put_scalar", "(", "\"mask_rcnn/false_negative\"", ",", "false_negative", ")", "\n", "if", "vis_period", ">", "0", "and", "storage", ".", "iter", "%", "vis_period", "==", "0", ":", "\n", "        ", "pred_masks", "=", "pred_mask_logits", ".", "sigmoid", "(", ")", "\n", "vis_masks", "=", "torch", ".", "cat", "(", "[", "pred_masks", ",", "gt_masks", "]", ",", "axis", "=", "2", ")", "\n", "name", "=", "\"Left: mask prediction;   Right: mask GT\"", "\n", "for", "idx", ",", "vis_mask", "in", "enumerate", "(", "vis_masks", ")", ":", "\n", "            ", "vis_mask", "=", "torch", ".", "stack", "(", "[", "vis_mask", "]", "*", "3", ",", "axis", "=", "0", ")", "\n", "storage", ".", "put_image", "(", "name", "+", "f\" ({idx})\"", ",", "vis_mask", ")", "\n", "\n", "", "", "mask_loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "pred_mask_logits", ",", "gt_masks", ",", "reduction", "=", "\"mean\"", ")", "\n", "return", "mask_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.mask_head.mask_rcnn_inference": [[114, 153], ["[].sigmoid.split", "zip", "pred_mask_logits.size", "pred_mask_logits.sigmoid", "detectron2.layers.cat", "torch.arange", "[].sigmoid", "len"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "def", "mask_rcnn_inference", "(", "pred_mask_logits", ":", "torch", ".", "Tensor", ",", "pred_instances", ":", "List", "[", "Instances", "]", ")", ":", "\n", "    ", "\"\"\"\n    Convert pred_mask_logits to estimated foreground probability masks while also\n    extracting only the masks for the predicted classes in pred_instances. For each\n    predicted box, the mask of the same class is attached to the instance by adding a\n    new \"pred_masks\" field to pred_instances.\n\n    Args:\n        pred_mask_logits (Tensor): A tensor of shape (B, C, Hmask, Wmask) or (B, 1, Hmask, Wmask)\n            for class-specific or class-agnostic, where B is the total number of predicted masks\n            in all images, C is the number of foreground classes, and Hmask, Wmask are the height\n            and width of the mask predictions. The values are logits.\n        pred_instances (list[Instances]): A list of N Instances, where N is the number of images\n            in the batch. Each Instances must have field \"pred_classes\".\n\n    Returns:\n        None. pred_instances will contain an extra \"pred_masks\" field storing a mask of size (Hmask,\n            Wmask) for predicted class. Note that the masks are returned as a soft (non-quantized)\n            masks the resolution predicted by the network; post-processing steps, such as resizing\n            the predicted masks to the original image resolution and/or binarizing them, is left\n            to the caller.\n    \"\"\"", "\n", "cls_agnostic_mask", "=", "pred_mask_logits", ".", "size", "(", "1", ")", "==", "1", "\n", "\n", "if", "cls_agnostic_mask", ":", "\n", "        ", "mask_probs_pred", "=", "pred_mask_logits", ".", "sigmoid", "(", ")", "\n", "", "else", ":", "\n", "# Select masks corresponding to the predicted classes", "\n", "        ", "num_masks", "=", "pred_mask_logits", ".", "shape", "[", "0", "]", "\n", "class_pred", "=", "cat", "(", "[", "i", ".", "pred_classes", "for", "i", "in", "pred_instances", "]", ")", "\n", "indices", "=", "torch", ".", "arange", "(", "num_masks", ",", "device", "=", "class_pred", ".", "device", ")", "\n", "mask_probs_pred", "=", "pred_mask_logits", "[", "indices", ",", "class_pred", "]", "[", ":", ",", "None", "]", ".", "sigmoid", "(", ")", "\n", "# mask_probs_pred.shape: (B, 1, Hmask, Wmask)", "\n", "\n", "", "num_boxes_per_image", "=", "[", "len", "(", "i", ")", "for", "i", "in", "pred_instances", "]", "\n", "mask_probs_pred", "=", "mask_probs_pred", ".", "split", "(", "num_boxes_per_image", ",", "dim", "=", "0", ")", "\n", "\n", "for", "prob", ",", "instances", "in", "zip", "(", "mask_probs_pred", ",", "pred_instances", ")", ":", "\n", "        ", "instances", ".", "pred_masks", "=", "prob", "# (1, Hmask, Wmask)", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.mask_head.build_mask_head": [[284, 290], ["ROI_MASK_HEAD_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "", "def", "build_mask_head", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build a mask head defined by `cfg.MODEL.ROI_MASK_HEAD.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "NAME", "\n", "return", "ROI_MASK_HEAD_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputs.__init__": [[138, 195], ["len", "len", "type", "type.cat", "proposals[].has", "detectron2.structures.Boxes", "len", "type.cat", "proposals[].has", "detectron2.layers.cat", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["def", "__init__", "(", "\n", "self", ",", "\n", "box2box_transform", ",", "\n", "pred_class_logits", ",", "\n", "pred_proposal_deltas", ",", "\n", "proposals", ",", "\n", "smooth_l1_beta", "=", "0.0", ",", "\n", "box_reg_loss_type", "=", "\"smooth_l1\"", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            box2box_transform (Box2BoxTransform/Box2BoxTransformRotated):\n                box2box transform instance for proposal-to-detection transformations.\n            pred_class_logits (Tensor): A tensor of shape (R, K + 1) storing the predicted class\n                logits for all R predicted object instances.\n                Each row corresponds to a predicted object instance.\n            pred_proposal_deltas (Tensor): A tensor of shape (R, K * B) or (R, B) for\n                class-specific or class-agnostic regression. It stores the predicted deltas that\n                transform proposals into final box detections.\n                B is the box dimension (4 or 5).\n                When B is 4, each row is [dx, dy, dw, dh (, ....)].\n                When B is 5, each row is [dx, dy, dw, dh, da (, ....)].\n            proposals (list[Instances]): A list of N Instances, where Instances i stores the\n                proposals for image i, in the field \"proposal_boxes\".\n                When training, each Instances must have ground-truth labels\n                stored in the field \"gt_classes\" and \"gt_boxes\".\n                The total number of all instances must be equal to R.\n            smooth_l1_beta (float): The transition point between L1 and L2 loss in\n                the smooth L1 loss function. When set to 0, the loss becomes L1. When\n                set to +inf, the loss becomes constant 0.\n            box_reg_loss_type (str): Box regression loss type. One of: \"smooth_l1\", \"giou\"\n        \"\"\"", "\n", "self", ".", "box2box_transform", "=", "box2box_transform", "\n", "self", ".", "num_preds_per_image", "=", "[", "len", "(", "p", ")", "for", "p", "in", "proposals", "]", "\n", "self", ".", "pred_class_logits", "=", "pred_class_logits", "\n", "self", ".", "pred_proposal_deltas", "=", "pred_proposal_deltas", "\n", "self", ".", "smooth_l1_beta", "=", "smooth_l1_beta", "\n", "self", ".", "box_reg_loss_type", "=", "box_reg_loss_type", "\n", "\n", "self", ".", "image_shapes", "=", "[", "x", ".", "image_size", "for", "x", "in", "proposals", "]", "\n", "\n", "if", "len", "(", "proposals", ")", ":", "\n", "            ", "box_type", "=", "type", "(", "proposals", "[", "0", "]", ".", "proposal_boxes", ")", "\n", "# cat(..., dim=0) concatenates over all images in the batch", "\n", "self", ".", "proposals", "=", "box_type", ".", "cat", "(", "[", "p", ".", "proposal_boxes", "for", "p", "in", "proposals", "]", ")", "\n", "assert", "(", "\n", "not", "self", ".", "proposals", ".", "tensor", ".", "requires_grad", "\n", ")", ",", "\"Proposals should not require gradients!\"", "\n", "\n", "# The following fields should exist only when training.", "\n", "if", "proposals", "[", "0", "]", ".", "has", "(", "\"gt_boxes\"", ")", ":", "\n", "                ", "self", ".", "gt_boxes", "=", "box_type", ".", "cat", "(", "[", "p", ".", "gt_boxes", "for", "p", "in", "proposals", "]", ")", "\n", "assert", "proposals", "[", "0", "]", ".", "has", "(", "\"gt_classes\"", ")", "\n", "self", ".", "gt_classes", "=", "cat", "(", "[", "p", ".", "gt_classes", "for", "p", "in", "proposals", "]", ",", "dim", "=", "0", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "proposals", "=", "Boxes", "(", "torch", ".", "zeros", "(", "0", ",", "4", ",", "device", "=", "self", ".", "pred_proposal_deltas", ".", "device", ")", ")", "\n", "", "self", ".", "_no_instances", "=", "len", "(", "self", ".", "proposals", ")", "==", "0", "# no instances found", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputs._log_accuracy": [[196, 219], ["fast_rcnn.FastRCNNOutputs.gt_classes.numel", "fast_rcnn.FastRCNNOutputs.pred_class_logits.argmax", "fg_inds.nonzero().numel", "detectron2.utils.events.get_event_storage", "detectron2.utils.events.get_event_storage.put_scalar", "fg_inds.nonzero", "detectron2.utils.events.get_event_storage.put_scalar", "detectron2.utils.events.get_event_storage.put_scalar"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.get_event_storage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar"], ["", "def", "_log_accuracy", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Log the accuracy metrics to EventStorage.\n        \"\"\"", "\n", "num_instances", "=", "self", ".", "gt_classes", ".", "numel", "(", ")", "\n", "pred_classes", "=", "self", ".", "pred_class_logits", ".", "argmax", "(", "dim", "=", "1", ")", "\n", "bg_class_ind", "=", "self", ".", "pred_class_logits", ".", "shape", "[", "1", "]", "-", "1", "\n", "\n", "fg_inds", "=", "(", "self", ".", "gt_classes", ">=", "0", ")", "&", "(", "self", ".", "gt_classes", "<", "bg_class_ind", ")", "\n", "num_fg", "=", "fg_inds", ".", "nonzero", "(", ")", ".", "numel", "(", ")", "\n", "fg_gt_classes", "=", "self", ".", "gt_classes", "[", "fg_inds", "]", "\n", "fg_pred_classes", "=", "pred_classes", "[", "fg_inds", "]", "\n", "\n", "num_false_negative", "=", "(", "fg_pred_classes", "==", "bg_class_ind", ")", ".", "nonzero", "(", ")", ".", "numel", "(", ")", "\n", "num_accurate", "=", "(", "pred_classes", "==", "self", ".", "gt_classes", ")", ".", "nonzero", "(", ")", ".", "numel", "(", ")", "\n", "fg_num_accurate", "=", "(", "fg_pred_classes", "==", "fg_gt_classes", ")", ".", "nonzero", "(", ")", ".", "numel", "(", ")", "\n", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "if", "num_instances", ">", "0", ":", "\n", "            ", "storage", ".", "put_scalar", "(", "\"fast_rcnn/cls_accuracy\"", ",", "num_accurate", "/", "num_instances", ")", "\n", "if", "num_fg", ">", "0", ":", "\n", "                ", "storage", ".", "put_scalar", "(", "\"fast_rcnn/fg_cls_accuracy\"", ",", "fg_num_accurate", "/", "num_fg", ")", "\n", "storage", ".", "put_scalar", "(", "\"fast_rcnn/false_negative\"", ",", "num_false_negative", "/", "num_fg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputs.softmax_cross_entropy_loss": [[220, 232], ["fast_rcnn.FastRCNNOutputs._log_accuracy", "torch.nn.functional.cross_entropy", "fast_rcnn.FastRCNNOutputs.pred_class_logits.sum"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputs._log_accuracy"], ["", "", "", "def", "softmax_cross_entropy_loss", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Compute the softmax cross entropy loss for box classification.\n\n        Returns:\n            scalar Tensor\n        \"\"\"", "\n", "if", "self", ".", "_no_instances", ":", "\n", "            ", "return", "0.0", "*", "self", ".", "pred_class_logits", ".", "sum", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_log_accuracy", "(", ")", "\n", "return", "F", ".", "cross_entropy", "(", "self", ".", "pred_class_logits", ",", "self", ".", "gt_classes", ",", "reduction", "=", "\"mean\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputs.box_reg_loss": [[233, 299], ["fast_rcnn.FastRCNNOutputs.gt_boxes.tensor.size", "fast_rcnn.FastRCNNOutputs.pred_proposal_deltas.size", "detectron2.layers.nonzero_tuple", "torch.arange", "fast_rcnn.FastRCNNOutputs.box2box_transform.get_deltas", "fvcore.nn.smooth_l1_loss", "fast_rcnn.FastRCNNOutputs.gt_classes.numel", "fast_rcnn.FastRCNNOutputs.pred_proposal_deltas.sum", "torch.arange", "fvcore.nn.giou_loss", "ValueError", "fast_rcnn.FastRCNNOutputs._predict_boxes"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.nonzero_tuple", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.box_regression.Box2BoxTransformRotated.get_deltas", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputs._predict_boxes"], ["", "", "def", "box_reg_loss", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Compute the smooth L1 loss for box regression.\n\n        Returns:\n            scalar Tensor\n        \"\"\"", "\n", "if", "self", ".", "_no_instances", ":", "\n", "            ", "return", "0.0", "*", "self", ".", "pred_proposal_deltas", ".", "sum", "(", ")", "\n", "\n", "", "box_dim", "=", "self", ".", "gt_boxes", ".", "tensor", ".", "size", "(", "1", ")", "# 4 or 5", "\n", "cls_agnostic_bbox_reg", "=", "self", ".", "pred_proposal_deltas", ".", "size", "(", "1", ")", "==", "box_dim", "\n", "device", "=", "self", ".", "pred_proposal_deltas", ".", "device", "\n", "\n", "bg_class_ind", "=", "self", ".", "pred_class_logits", ".", "shape", "[", "1", "]", "-", "1", "\n", "\n", "# Box delta loss is only computed between the prediction for the gt class k", "\n", "# (if 0 <= k < bg_class_ind) and the target; there is no loss defined on predictions", "\n", "# for non-gt classes and background.", "\n", "# Empty fg_inds produces a valid loss of zero as long as the size_average", "\n", "# arg to smooth_l1_loss is False (otherwise it uses torch.mean internally", "\n", "# and would produce a nan loss).", "\n", "fg_inds", "=", "nonzero_tuple", "(", "(", "self", ".", "gt_classes", ">=", "0", ")", "&", "(", "self", ".", "gt_classes", "<", "bg_class_ind", ")", ")", "[", "0", "]", "\n", "if", "cls_agnostic_bbox_reg", ":", "\n", "# pred_proposal_deltas only corresponds to foreground class for agnostic", "\n", "            ", "gt_class_cols", "=", "torch", ".", "arange", "(", "box_dim", ",", "device", "=", "device", ")", "\n", "", "else", ":", "\n", "            ", "fg_gt_classes", "=", "self", ".", "gt_classes", "[", "fg_inds", "]", "\n", "# pred_proposal_deltas for class k are located in columns [b * k : b * k + b],", "\n", "# where b is the dimension of box representation (4 or 5)", "\n", "# Note that compared to Detectron1,", "\n", "# we do not perform bounding box regression for background classes.", "\n", "gt_class_cols", "=", "box_dim", "*", "fg_gt_classes", "[", ":", ",", "None", "]", "+", "torch", ".", "arange", "(", "box_dim", ",", "device", "=", "device", ")", "\n", "\n", "", "if", "self", ".", "box_reg_loss_type", "==", "\"smooth_l1\"", ":", "\n", "            ", "gt_proposal_deltas", "=", "self", ".", "box2box_transform", ".", "get_deltas", "(", "\n", "self", ".", "proposals", ".", "tensor", ",", "self", ".", "gt_boxes", ".", "tensor", "\n", ")", "\n", "loss_box_reg", "=", "smooth_l1_loss", "(", "\n", "self", ".", "pred_proposal_deltas", "[", "fg_inds", "[", ":", ",", "None", "]", ",", "gt_class_cols", "]", ",", "\n", "gt_proposal_deltas", "[", "fg_inds", "]", ",", "\n", "self", ".", "smooth_l1_beta", ",", "\n", "reduction", "=", "\"sum\"", ",", "\n", ")", "\n", "", "elif", "self", ".", "box_reg_loss_type", "==", "\"giou\"", ":", "\n", "            ", "loss_box_reg", "=", "giou_loss", "(", "\n", "self", ".", "_predict_boxes", "(", ")", "[", "fg_inds", "[", ":", ",", "None", "]", ",", "gt_class_cols", "]", ",", "\n", "self", ".", "gt_boxes", ".", "tensor", "[", "fg_inds", "]", ",", "\n", "reduction", "=", "\"sum\"", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Invalid bbox reg loss type '{self.box_reg_loss_type}'\"", ")", "\n", "\n", "# The loss is normalized using the total number of regions (R), not the number", "\n", "# of foreground regions even though the box regression loss is only defined on", "\n", "# foreground regions. Why? Because doing so gives equal training influence to", "\n", "# each foreground example. To see how, consider two different minibatches:", "\n", "#  (1) Contains a single foreground region", "\n", "#  (2) Contains 100 foreground regions", "\n", "# If we normalize by the number of foreground regions, the single example in", "\n", "# minibatch (1) will be given 100 times as much influence as each foreground", "\n", "# example in minibatch (2). Normalizing by the total number of regions, R,", "\n", "# means that the single example in minibatch (1) and each of the 100 examples", "\n", "# in minibatch (2) are given equal influence.", "\n", "", "loss_box_reg", "=", "loss_box_reg", "/", "self", ".", "gt_classes", ".", "numel", "(", ")", "\n", "return", "loss_box_reg", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputs._predict_boxes": [[300, 308], ["fast_rcnn.FastRCNNOutputs.box2box_transform.apply_deltas"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.box_regression.Box2BoxTransformRotated.apply_deltas"], ["", "def", "_predict_boxes", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            Tensor: A Tensors of predicted class-specific or class-agnostic boxes\n                for all images in a batch. Element i has shape (Ri, K * B) or (Ri, B), where Ri is\n                the number of predicted objects for image i and B is the box dimension (4 or 5)\n        \"\"\"", "\n", "return", "self", ".", "box2box_transform", ".", "apply_deltas", "(", "self", ".", "pred_proposal_deltas", ",", "self", ".", "proposals", ".", "tensor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputs.losses": [[314, 323], ["fast_rcnn.FastRCNNOutputs.softmax_cross_entropy_loss", "fast_rcnn.FastRCNNOutputs.box_reg_loss"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputs.softmax_cross_entropy_loss", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputs.box_reg_loss"], ["def", "losses", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Compute the default losses for box head in Fast(er) R-CNN,\n        with softmax cross entropy loss and smooth L1 loss.\n\n        Returns:\n            A dict of losses (scalar tensors) containing keys \"loss_cls\" and \"loss_box_reg\".\n        \"\"\"", "\n", "return", "{", "\"loss_cls\"", ":", "self", ".", "softmax_cross_entropy_loss", "(", ")", ",", "\"loss_box_reg\"", ":", "self", ".", "box_reg_loss", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputs.predict_boxes": [[324, 329], ["fast_rcnn.FastRCNNOutputs._predict_boxes().split", "fast_rcnn.FastRCNNOutputs._predict_boxes"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputs._predict_boxes"], ["", "def", "predict_boxes", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Deprecated\n        \"\"\"", "\n", "return", "self", ".", "_predict_boxes", "(", ")", ".", "split", "(", "self", ".", "num_preds_per_image", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputs.predict_probs": [[330, 336], ["torch.nn.functional.softmax", "torch.nn.functional.softmax.split"], "methods", ["None"], ["", "def", "predict_probs", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Deprecated\n        \"\"\"", "\n", "probs", "=", "F", ".", "softmax", "(", "self", ".", "pred_class_logits", ",", "dim", "=", "-", "1", ")", "\n", "return", "probs", ".", "split", "(", "self", ".", "num_preds_per_image", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputs.inference": [[337, 346], ["fast_rcnn.FastRCNNOutputs.predict_boxes", "fast_rcnn.FastRCNNOutputs.predict_probs", "fast_rcnn.fast_rcnn_inference"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_probs", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.fast_rcnn_inference"], ["", "def", "inference", "(", "self", ",", "score_thresh", ",", "nms_thresh", ",", "topk_per_image", ")", ":", "\n", "        ", "\"\"\"\n        Deprecated\n        \"\"\"", "\n", "boxes", "=", "self", ".", "predict_boxes", "(", ")", "\n", "scores", "=", "self", ".", "predict_probs", "(", ")", "\n", "image_shapes", "=", "self", ".", "image_shapes", "\n", "return", "fast_rcnn_inference", "(", "\n", "boxes", ",", "scores", ",", "image_shapes", ",", "score_thresh", ",", "nms_thresh", ",", "topk_per_image", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputLayers.__init__": [[357, 415], ["torch.nn.Module.__init__", "isinstance", "detectron2.layers.Linear", "len", "detectron2.layers.Linear", "torch.nn.init.normal_", "torch.nn.init.normal_", "isinstance", "detectron2.layers.ShapeSpec", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "input_shape", ":", "ShapeSpec", ",", "\n", "*", ",", "\n", "box2box_transform", ",", "\n", "num_classes", ":", "int", ",", "\n", "test_score_thresh", ":", "float", "=", "0.0", ",", "\n", "test_nms_thresh", ":", "float", "=", "0.5", ",", "\n", "test_topk_per_image", ":", "int", "=", "100", ",", "\n", "cls_agnostic_bbox_reg", ":", "bool", "=", "False", ",", "\n", "smooth_l1_beta", ":", "float", "=", "0.0", ",", "\n", "box_reg_loss_type", ":", "str", "=", "\"smooth_l1\"", ",", "\n", "loss_weight", ":", "Union", "[", "float", ",", "Dict", "[", "str", ",", "float", "]", "]", "=", "1.0", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            input_shape (ShapeSpec): shape of the input feature to this module\n            box2box_transform (Box2BoxTransform or Box2BoxTransformRotated):\n            num_classes (int): number of foreground classes\n            test_score_thresh (float): threshold to filter predictions results.\n            test_nms_thresh (float): NMS threshold for prediction results.\n            test_topk_per_image (int): number of top predictions to produce per image.\n            cls_agnostic_bbox_reg (bool): whether to use class agnostic for bbox regression\n            smooth_l1_beta (float): transition point from L1 to L2 loss. Only used if\n                `box_reg_loss_type` is \"smooth_l1\"\n            box_reg_loss_type (str): Box regression loss type. One of: \"smooth_l1\", \"giou\"\n            loss_weight (float|dict): weights to use for losses. Can be single float for weighting\n                all losses, or a dict of individual weightings. Valid dict keys are:\n                    * \"loss_cls\": applied to classification loss\n                    * \"loss_box_reg\": applied to box regression loss\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "isinstance", "(", "input_shape", ",", "int", ")", ":", "# some backward compatibility", "\n", "            ", "input_shape", "=", "ShapeSpec", "(", "channels", "=", "input_shape", ")", "\n", "", "input_size", "=", "input_shape", ".", "channels", "*", "(", "input_shape", ".", "width", "or", "1", ")", "*", "(", "input_shape", ".", "height", "or", "1", ")", "\n", "# prediction layer for num_classes foreground classes and one background class (hence + 1)", "\n", "self", ".", "cls_score", "=", "Linear", "(", "input_size", ",", "num_classes", "+", "1", ")", "\n", "num_bbox_reg_classes", "=", "1", "if", "cls_agnostic_bbox_reg", "else", "num_classes", "\n", "box_dim", "=", "len", "(", "box2box_transform", ".", "weights", ")", "\n", "self", ".", "bbox_pred", "=", "Linear", "(", "input_size", ",", "num_bbox_reg_classes", "*", "box_dim", ")", "\n", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "cls_score", ".", "weight", ",", "std", "=", "0.01", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "bbox_pred", ".", "weight", ",", "std", "=", "0.001", ")", "\n", "for", "l", "in", "[", "self", ".", "cls_score", ",", "self", ".", "bbox_pred", "]", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "\n", "", "self", ".", "box2box_transform", "=", "box2box_transform", "\n", "self", ".", "smooth_l1_beta", "=", "smooth_l1_beta", "\n", "self", ".", "test_score_thresh", "=", "test_score_thresh", "\n", "self", ".", "test_nms_thresh", "=", "test_nms_thresh", "\n", "self", ".", "test_topk_per_image", "=", "test_topk_per_image", "\n", "self", ".", "box_reg_loss_type", "=", "box_reg_loss_type", "\n", "if", "isinstance", "(", "loss_weight", ",", "float", ")", ":", "\n", "            ", "loss_weight", "=", "{", "\"loss_cls\"", ":", "loss_weight", ",", "\"loss_box_reg\"", ":", "loss_weight", "}", "\n", "", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputLayers.from_config": [[416, 430], ["detectron2.modeling.box_regression.Box2BoxTransform"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "return", "{", "\n", "\"input_shape\"", ":", "input_shape", ",", "\n", "\"box2box_transform\"", ":", "Box2BoxTransform", "(", "weights", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "BBOX_REG_WEIGHTS", ")", ",", "\n", "# fmt: off", "\n", "\"num_classes\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NUM_CLASSES", ",", "\n", "\"cls_agnostic_bbox_reg\"", ":", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "CLS_AGNOSTIC_BBOX_REG", ",", "\n", "\"smooth_l1_beta\"", ":", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "SMOOTH_L1_BETA", ",", "\n", "\"test_score_thresh\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "SCORE_THRESH_TEST", ",", "\n", "\"test_nms_thresh\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NMS_THRESH_TEST", ",", "\n", "\"test_topk_per_image\"", ":", "cfg", ".", "TEST", ".", "DETECTIONS_PER_IMAGE", ",", "\n", "\"box_reg_loss_type\"", ":", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "BBOX_REG_LOSS_TYPE", ",", "\n", "\"loss_weight\"", ":", "{", "\"loss_box_reg\"", ":", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "BBOX_REG_LOSS_WEIGHT", "}", ",", "\n", "# fmt: on", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputLayers.forward": [[433, 451], ["fast_rcnn.FastRCNNOutputLayers.cls_score", "fast_rcnn.FastRCNNOutputLayers.bbox_pred", "torch.flatten.dim", "torch.flatten"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x: per-region features of shape (N, ...) for N bounding boxes to predict.\n\n        Returns:\n            (Tensor, Tensor):\n            First tensor: shape (N,K+1), scores for each of the N box. Each row contains the\n            scores for K object categories and 1 background class.\n\n            Second tensor: bounding box regression deltas for each box. Shape is shape (N,Kx4),\n            or (N,4) for class-agnostic regression.\n        \"\"\"", "\n", "if", "x", ".", "dim", "(", ")", ">", "2", ":", "\n", "            ", "x", "=", "torch", ".", "flatten", "(", "x", ",", "start_dim", "=", "1", ")", "\n", "", "scores", "=", "self", ".", "cls_score", "(", "x", ")", "\n", "proposal_deltas", "=", "self", ".", "bbox_pred", "(", "x", ")", "\n", "return", "scores", ",", "proposal_deltas", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputLayers.losses": [[453, 474], ["fast_rcnn.FastRCNNOutputs.losses", "fast_rcnn.FastRCNNOutputs", "fast_rcnn.FastRCNNOutputLayers.loss_weight.get", "fast_rcnn.FastRCNNOutputs.losses"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3Head.losses", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3Head.losses"], ["", "def", "losses", "(", "self", ",", "predictions", ",", "proposals", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were used\n                to compute predictions. The fields ``proposal_boxes``, ``gt_boxes``,\n                ``gt_classes`` are expected.\n\n        Returns:\n            Dict[str, Tensor]: dict of losses\n        \"\"\"", "\n", "scores", ",", "proposal_deltas", "=", "predictions", "\n", "losses", "=", "FastRCNNOutputs", "(", "\n", "self", ".", "box2box_transform", ",", "\n", "scores", ",", "\n", "proposal_deltas", ",", "\n", "proposals", ",", "\n", "self", ".", "smooth_l1_beta", ",", "\n", "self", ".", "box_reg_loss_type", ",", "\n", ")", ".", "losses", "(", ")", "\n", "return", "{", "k", ":", "v", "*", "self", ".", "loss_weight", ".", "get", "(", "k", ",", "1.0", ")", "for", "k", ",", "v", "in", "losses", ".", "items", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputLayers.inference": [[475, 496], ["fast_rcnn.FastRCNNOutputLayers.predict_boxes", "fast_rcnn.FastRCNNOutputLayers.predict_probs", "fast_rcnn.fast_rcnn_inference"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_probs", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.fast_rcnn_inference"], ["", "def", "inference", "(", "self", ",", "predictions", ",", "proposals", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were\n                used to compute predictions. The ``proposal_boxes`` field is expected.\n\n        Returns:\n            list[Instances]: same as `fast_rcnn_inference`.\n            list[Tensor]: same as `fast_rcnn_inference`.\n        \"\"\"", "\n", "boxes", "=", "self", ".", "predict_boxes", "(", "predictions", ",", "proposals", ")", "\n", "scores", "=", "self", ".", "predict_probs", "(", "predictions", ",", "proposals", ")", "\n", "image_shapes", "=", "[", "x", ".", "image_size", "for", "x", "in", "proposals", "]", "\n", "return", "fast_rcnn_inference", "(", "\n", "boxes", ",", "\n", "scores", ",", "\n", "image_shapes", ",", "\n", "self", ".", "test_score_thresh", ",", "\n", "self", ".", "test_nms_thresh", ",", "\n", "self", ".", "test_topk_per_image", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_boxes_for_gt_classes": [[498, 533], ["fast_rcnn.FastRCNNOutputLayers.box2box_transform.apply_deltas", "fast_rcnn.FastRCNNOutputLayers.split", "len", "proposal_boxes[].cat", "torch.cat", "gt_classes.clamp_.clamp_.clamp_", "len", "fast_rcnn.FastRCNNOutputLayers.view", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.box_regression.Box2BoxTransformRotated.apply_deltas", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "def", "predict_boxes_for_gt_classes", "(", "self", ",", "predictions", ",", "proposals", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were used\n                to compute predictions. The fields ``proposal_boxes``, ``gt_classes`` are expected.\n\n        Returns:\n            list[Tensor]:\n                A list of Tensors of predicted boxes for GT classes in case of\n                class-specific box head. Element i of the list has shape (Ri, B), where Ri is\n                the number of proposals for image i and B is the box dimension (4 or 5)\n        \"\"\"", "\n", "if", "not", "len", "(", "proposals", ")", ":", "\n", "            ", "return", "[", "]", "\n", "", "scores", ",", "proposal_deltas", "=", "predictions", "\n", "proposal_boxes", "=", "[", "p", ".", "proposal_boxes", "for", "p", "in", "proposals", "]", "\n", "proposal_boxes", "=", "proposal_boxes", "[", "0", "]", ".", "cat", "(", "proposal_boxes", ")", ".", "tensor", "\n", "N", ",", "B", "=", "proposal_boxes", ".", "shape", "\n", "predict_boxes", "=", "self", ".", "box2box_transform", ".", "apply_deltas", "(", "\n", "proposal_deltas", ",", "proposal_boxes", "\n", ")", "# Nx(KxB)", "\n", "\n", "K", "=", "predict_boxes", ".", "shape", "[", "1", "]", "//", "B", "\n", "if", "K", ">", "1", ":", "\n", "            ", "gt_classes", "=", "torch", ".", "cat", "(", "[", "p", ".", "gt_classes", "for", "p", "in", "proposals", "]", ",", "dim", "=", "0", ")", "\n", "# Some proposals are ignored or have a background class. Their gt_classes", "\n", "# cannot be used as index.", "\n", "gt_classes", "=", "gt_classes", ".", "clamp_", "(", "0", ",", "K", "-", "1", ")", "\n", "\n", "predict_boxes", "=", "predict_boxes", ".", "view", "(", "N", ",", "K", ",", "B", ")", "[", "\n", "torch", ".", "arange", "(", "N", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "predict_boxes", ".", "device", ")", ",", "gt_classes", "\n", "]", "\n", "", "num_prop_per_image", "=", "[", "len", "(", "p", ")", "for", "p", "in", "proposals", "]", "\n", "return", "predict_boxes", ".", "split", "(", "num_prop_per_image", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_boxes": [[534, 557], ["fast_rcnn.FastRCNNOutputLayers.box2box_transform.apply_deltas", "fast_rcnn.FastRCNNOutputLayers.split", "len", "len", "proposal_boxes[].cat"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.box_regression.Box2BoxTransformRotated.apply_deltas", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "def", "predict_boxes", "(", "self", ",", "predictions", ",", "proposals", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were\n                used to compute predictions. The ``proposal_boxes`` field is expected.\n\n        Returns:\n            list[Tensor]:\n                A list of Tensors of predicted class-specific or class-agnostic boxes\n                for each image. Element i has shape (Ri, K * B) or (Ri, B), where Ri is\n                the number of proposals for image i and B is the box dimension (4 or 5)\n        \"\"\"", "\n", "if", "not", "len", "(", "proposals", ")", ":", "\n", "            ", "return", "[", "]", "\n", "", "_", ",", "proposal_deltas", "=", "predictions", "\n", "num_prop_per_image", "=", "[", "len", "(", "p", ")", "for", "p", "in", "proposals", "]", "\n", "proposal_boxes", "=", "[", "p", ".", "proposal_boxes", "for", "p", "in", "proposals", "]", "\n", "proposal_boxes", "=", "proposal_boxes", "[", "0", "]", ".", "cat", "(", "proposal_boxes", ")", ".", "tensor", "\n", "predict_boxes", "=", "self", ".", "box2box_transform", ".", "apply_deltas", "(", "\n", "proposal_deltas", ",", "proposal_boxes", "\n", ")", "# Nx(KxB)", "\n", "return", "predict_boxes", ".", "split", "(", "num_prop_per_image", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_probs": [[558, 574], ["torch.nn.functional.softmax", "torch.nn.functional.softmax.split", "len"], "methods", ["None"], ["", "def", "predict_probs", "(", "self", ",", "predictions", ",", "proposals", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were\n                used to compute predictions.\n\n        Returns:\n            list[Tensor]:\n                A list of Tensors of predicted class probabilities for each image.\n                Element i has shape (Ri, K + 1), where Ri is the number of proposals for image i.\n        \"\"\"", "\n", "scores", ",", "_", "=", "predictions", "\n", "num_inst_per_image", "=", "[", "len", "(", "p", ")", "for", "p", "in", "proposals", "]", "\n", "probs", "=", "F", ".", "softmax", "(", "scores", ",", "dim", "=", "-", "1", ")", "\n", "return", "probs", ".", "split", "(", "num_inst_per_image", ",", "dim", "=", "0", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.fast_rcnn_inference": [[46, 79], ["fast_rcnn.fast_rcnn_inference_single_image", "zip"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.fast_rcnn_inference_single_image"], ["def", "fast_rcnn_inference", "(", "boxes", ",", "scores", ",", "image_shapes", ",", "score_thresh", ",", "nms_thresh", ",", "topk_per_image", ")", ":", "\n", "    ", "\"\"\"\n    Call `fast_rcnn_inference_single_image` for all images.\n\n    Args:\n        boxes (list[Tensor]): A list of Tensors of predicted class-specific or class-agnostic\n            boxes for each image. Element i has shape (Ri, K * 4) if doing\n            class-specific regression, or (Ri, 4) if doing class-agnostic\n            regression, where Ri is the number of predicted objects for image i.\n            This is compatible with the output of :meth:`FastRCNNOutputLayers.predict_boxes`.\n        scores (list[Tensor]): A list of Tensors of predicted class scores for each image.\n            Element i has shape (Ri, K + 1), where Ri is the number of predicted objects\n            for image i. Compatible with the output of :meth:`FastRCNNOutputLayers.predict_probs`.\n        image_shapes (list[tuple]): A list of (width, height) tuples for each image in the batch.\n        score_thresh (float): Only return detections with a confidence score exceeding this\n            threshold.\n        nms_thresh (float):  The threshold to use for box non-maximum suppression. Value in [0, 1].\n        topk_per_image (int): The number of top scoring detections to return. Set < 0 to return\n            all detections.\n\n    Returns:\n        instances: (list[Instances]): A list of N instances, one for each image in the batch,\n            that stores the topk most confidence detections.\n        kept_indices: (list[Tensor]): A list of 1D tensor of length of N, each element indicates\n            the corresponding boxes/scores index in [0, Ri) from the input, for image i.\n    \"\"\"", "\n", "result_per_image", "=", "[", "\n", "fast_rcnn_inference_single_image", "(", "\n", "boxes_per_image", ",", "scores_per_image", ",", "image_shape", ",", "score_thresh", ",", "nms_thresh", ",", "topk_per_image", "\n", ")", "\n", "for", "scores_per_image", ",", "boxes_per_image", ",", "image_shape", "in", "zip", "(", "scores", ",", "boxes", ",", "image_shapes", ")", "\n", "]", "\n", "return", "[", "x", "[", "0", "]", "for", "x", "in", "result_per_image", "]", ",", "[", "x", "[", "1", "]", "for", "x", "in", "result_per_image", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.fast_rcnn_inference_single_image": [[81, 130], ["detectron2.structures.Boxes", "boxes.tensor.view.clip", "boxes.tensor.view.tensor.view", "filter_mask.nonzero", "detectron2.layers.batched_nms", "detectron2.structures.Instances", "detectron2.structures.Boxes", "torch.isfinite().all", "torch.isfinite().all", "valid_mask.all", "boxes.tensor.view.reshape", "torch.isfinite", "torch.isfinite"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.batched_nms"], ["", "def", "fast_rcnn_inference_single_image", "(", "\n", "boxes", ",", "scores", ",", "image_shape", ",", "score_thresh", ",", "nms_thresh", ",", "topk_per_image", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Single-image inference. Return bounding-box detection results by thresholding\n    on scores and applying non-maximum suppression (NMS).\n\n    Args:\n        Same as `fast_rcnn_inference`, but with boxes, scores, and image shapes\n        per image.\n\n    Returns:\n        Same as `fast_rcnn_inference`, but for only one image.\n    \"\"\"", "\n", "valid_mask", "=", "torch", ".", "isfinite", "(", "boxes", ")", ".", "all", "(", "dim", "=", "1", ")", "&", "torch", ".", "isfinite", "(", "scores", ")", ".", "all", "(", "dim", "=", "1", ")", "\n", "if", "not", "valid_mask", ".", "all", "(", ")", ":", "\n", "        ", "boxes", "=", "boxes", "[", "valid_mask", "]", "\n", "scores", "=", "scores", "[", "valid_mask", "]", "\n", "\n", "", "scores", "=", "scores", "[", ":", ",", ":", "-", "1", "]", "\n", "num_bbox_reg_classes", "=", "boxes", ".", "shape", "[", "1", "]", "//", "4", "\n", "# Convert to Boxes to use the `clip` function ...", "\n", "boxes", "=", "Boxes", "(", "boxes", ".", "reshape", "(", "-", "1", ",", "4", ")", ")", "\n", "boxes", ".", "clip", "(", "image_shape", ")", "\n", "boxes", "=", "boxes", ".", "tensor", ".", "view", "(", "-", "1", ",", "num_bbox_reg_classes", ",", "4", ")", "# R x C x 4", "\n", "\n", "# 1. Filter results based on detection scores. It can make NMS more efficient", "\n", "#    by filtering out low-confidence detections.", "\n", "filter_mask", "=", "scores", ">", "score_thresh", "# R x K", "\n", "# R' x 2. First column contains indices of the R predictions;", "\n", "# Second column contains indices of classes.", "\n", "filter_inds", "=", "filter_mask", ".", "nonzero", "(", ")", "\n", "if", "num_bbox_reg_classes", "==", "1", ":", "\n", "        ", "boxes", "=", "boxes", "[", "filter_inds", "[", ":", ",", "0", "]", ",", "0", "]", "\n", "", "else", ":", "\n", "        ", "boxes", "=", "boxes", "[", "filter_mask", "]", "\n", "", "scores", "=", "scores", "[", "filter_mask", "]", "\n", "\n", "# 2. Apply NMS for each class independently.", "\n", "keep", "=", "batched_nms", "(", "boxes", ",", "scores", ",", "filter_inds", "[", ":", ",", "1", "]", ",", "nms_thresh", ")", "\n", "if", "topk_per_image", ">=", "0", ":", "\n", "        ", "keep", "=", "keep", "[", ":", "topk_per_image", "]", "\n", "", "boxes", ",", "scores", ",", "filter_inds", "=", "boxes", "[", "keep", "]", ",", "scores", "[", "keep", "]", ",", "filter_inds", "[", "keep", "]", "\n", "\n", "result", "=", "Instances", "(", "image_shape", ")", "\n", "result", ".", "pred_boxes", "=", "Boxes", "(", "boxes", ")", "\n", "result", ".", "scores", "=", "scores", "\n", "result", ".", "pred_classes", "=", "filter_inds", "[", ":", ",", "1", "]", "\n", "return", "result", ",", "filter_inds", "[", ":", ",", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.rotated_fast_rcnn.RotatedFastRCNNOutputLayers.from_config": [[139, 146], ["super().from_config", "box_regression.Box2BoxTransformRotated"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3PlusHead.from_config"], ["@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "args", "=", "super", "(", ")", ".", "from_config", "(", "cfg", ",", "input_shape", ")", "\n", "args", "[", "\"box2box_transform\"", "]", "=", "Box2BoxTransformRotated", "(", "\n", "weights", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "BBOX_REG_WEIGHTS", "\n", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.rotated_fast_rcnn.RotatedFastRCNNOutputLayers.inference": [[147, 164], ["rotated_fast_rcnn.RotatedFastRCNNOutputLayers.predict_boxes", "rotated_fast_rcnn.RotatedFastRCNNOutputLayers.predict_probs", "rotated_fast_rcnn.fast_rcnn_inference_rotated"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_probs", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.rotated_fast_rcnn.fast_rcnn_inference_rotated"], ["", "def", "inference", "(", "self", ",", "predictions", ",", "proposals", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            list[Instances]: same as `fast_rcnn_inference_rotated`.\n            list[Tensor]: same as `fast_rcnn_inference_rotated`.\n        \"\"\"", "\n", "boxes", "=", "self", ".", "predict_boxes", "(", "predictions", ",", "proposals", ")", "\n", "scores", "=", "self", ".", "predict_probs", "(", "predictions", ",", "proposals", ")", "\n", "image_shapes", "=", "[", "x", ".", "image_size", "for", "x", "in", "proposals", "]", "\n", "\n", "return", "fast_rcnn_inference_rotated", "(", "\n", "boxes", ",", "\n", "scores", ",", "\n", "image_shapes", ",", "\n", "self", ".", "test_score_thresh", ",", "\n", "self", ".", "test_nms_thresh", ",", "\n", "self", ".", "test_topk_per_image", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.rotated_fast_rcnn.RROIHeads.__init__": [[174, 184], ["roi_heads.StandardROIHeads.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "assert", "(", "\n", "not", "self", ".", "mask_on", "and", "not", "self", ".", "keypoint_on", "\n", ")", ",", "\"Mask/Keypoints not supported in Rotated ROIHeads.\"", "\n", "assert", "not", "self", ".", "train_on_pred_boxes", ",", "\"train_on_pred_boxes not implemented for RROIHeads!\"", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.rotated_fast_rcnn.RROIHeads._init_box_head": [[185, 214], ["tuple", "poolers.ROIPooler", "box_head.build_box_head.build_box_head", "rotated_fast_rcnn.RotatedFastRCNNOutputLayers", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.box_head.build_box_head"], ["", "@", "classmethod", "\n", "def", "_init_box_head", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "# fmt: off", "\n", "        ", "in_features", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IN_FEATURES", "\n", "pooler_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_RESOLUTION", "\n", "pooler_scales", "=", "tuple", "(", "1.0", "/", "input_shape", "[", "k", "]", ".", "stride", "for", "k", "in", "in_features", ")", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "pooler_type", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_TYPE", "\n", "# fmt: on", "\n", "assert", "pooler_type", "in", "[", "\"ROIAlignRotated\"", "]", ",", "pooler_type", "\n", "# assume all channel counts are equal", "\n", "in_channels", "=", "[", "input_shape", "[", "f", "]", ".", "channels", "for", "f", "in", "in_features", "]", "[", "0", "]", "\n", "\n", "box_pooler", "=", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "pooler_type", ",", "\n", ")", "\n", "box_head", "=", "build_box_head", "(", "\n", "cfg", ",", "ShapeSpec", "(", "channels", "=", "in_channels", ",", "height", "=", "pooler_resolution", ",", "width", "=", "pooler_resolution", ")", "\n", ")", "\n", "# This line is the only difference v.s. StandardROIHeads", "\n", "box_predictor", "=", "RotatedFastRCNNOutputLayers", "(", "cfg", ",", "box_head", ".", "output_shape", ")", "\n", "return", "{", "\n", "\"box_in_features\"", ":", "in_features", ",", "\n", "\"box_pooler\"", ":", "box_pooler", ",", "\n", "\"box_head\"", ":", "box_head", ",", "\n", "\"box_predictor\"", ":", "box_predictor", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.rotated_fast_rcnn.RROIHeads.label_and_sample_proposals": [[216, 277], ["torch.no_grad", "zip", "detectron2.utils.events.get_event_storage", "detectron2.utils.events.get_event_storage.put_scalar", "detectron2.utils.events.get_event_storage.put_scalar", "proposal_generator.proposal_utils.add_ground_truth_to_proposals", "detectron2.structures.pairwise_iou_rotated", "rotated_fast_rcnn.RROIHeads.proposal_matcher", "rotated_fast_rcnn.RROIHeads._sample_proposals", "num_bg_samples.append", "num_fg_samples.append", "proposals_with_gt.append", "numpy.mean", "numpy.mean", "len", "detectron2.structures.RotatedBoxes", "targets_per_image.gt_boxes.tensor.new_zeros", "gt_classes.numel", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.get_event_storage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.proposal_utils.add_ground_truth_to_proposals", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.rotated_boxes.pairwise_iou_rotated", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.ROIHeads._sample_proposals"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "label_and_sample_proposals", "(", "self", ",", "proposals", ",", "targets", ")", ":", "\n", "        ", "\"\"\"\n        Prepare some proposals to be used to train the RROI heads.\n        It performs box matching between `proposals` and `targets`, and assigns\n        training labels to the proposals.\n        It returns `self.batch_size_per_image` random samples from proposals and groundtruth boxes,\n        with a fraction of positives that is no larger than `self.positive_sample_fraction.\n\n        Args:\n            See :meth:`StandardROIHeads.forward`\n\n        Returns:\n            list[Instances]: length `N` list of `Instances`s containing the proposals\n                sampled for training. Each `Instances` has the following fields:\n                - proposal_boxes: the rotated proposal boxes\n                - gt_boxes: the ground-truth rotated boxes that the proposal is assigned to\n                  (this is only meaningful if the proposal has a label > 0; if label = 0\n                   then the ground-truth box is random)\n                - gt_classes: the ground-truth classification lable for each proposal\n        \"\"\"", "\n", "gt_boxes", "=", "[", "x", ".", "gt_boxes", "for", "x", "in", "targets", "]", "\n", "if", "self", ".", "proposal_append_gt", ":", "\n", "            ", "proposals", "=", "add_ground_truth_to_proposals", "(", "gt_boxes", ",", "proposals", ")", "\n", "\n", "", "proposals_with_gt", "=", "[", "]", "\n", "\n", "num_fg_samples", "=", "[", "]", "\n", "num_bg_samples", "=", "[", "]", "\n", "for", "proposals_per_image", ",", "targets_per_image", "in", "zip", "(", "proposals", ",", "targets", ")", ":", "\n", "            ", "has_gt", "=", "len", "(", "targets_per_image", ")", ">", "0", "\n", "match_quality_matrix", "=", "pairwise_iou_rotated", "(", "\n", "targets_per_image", ".", "gt_boxes", ",", "proposals_per_image", ".", "proposal_boxes", "\n", ")", "\n", "matched_idxs", ",", "matched_labels", "=", "self", ".", "proposal_matcher", "(", "match_quality_matrix", ")", "\n", "sampled_idxs", ",", "gt_classes", "=", "self", ".", "_sample_proposals", "(", "\n", "matched_idxs", ",", "matched_labels", ",", "targets_per_image", ".", "gt_classes", "\n", ")", "\n", "\n", "proposals_per_image", "=", "proposals_per_image", "[", "sampled_idxs", "]", "\n", "proposals_per_image", ".", "gt_classes", "=", "gt_classes", "\n", "\n", "if", "has_gt", ":", "\n", "                ", "sampled_targets", "=", "matched_idxs", "[", "sampled_idxs", "]", "\n", "proposals_per_image", ".", "gt_boxes", "=", "targets_per_image", ".", "gt_boxes", "[", "sampled_targets", "]", "\n", "", "else", ":", "\n", "                ", "gt_boxes", "=", "RotatedBoxes", "(", "\n", "targets_per_image", ".", "gt_boxes", ".", "tensor", ".", "new_zeros", "(", "(", "len", "(", "sampled_idxs", ")", ",", "5", ")", ")", "\n", ")", "\n", "proposals_per_image", ".", "gt_boxes", "=", "gt_boxes", "\n", "\n", "", "num_bg_samples", ".", "append", "(", "(", "gt_classes", "==", "self", ".", "num_classes", ")", ".", "sum", "(", ")", ".", "item", "(", ")", ")", "\n", "num_fg_samples", ".", "append", "(", "gt_classes", ".", "numel", "(", ")", "-", "num_bg_samples", "[", "-", "1", "]", ")", "\n", "proposals_with_gt", ".", "append", "(", "proposals_per_image", ")", "\n", "\n", "# Log the number of fg/bg samples that are selected for training ROI heads", "\n", "", "storage", "=", "get_event_storage", "(", ")", "\n", "storage", ".", "put_scalar", "(", "\"roi_head/num_fg_samples\"", ",", "np", ".", "mean", "(", "num_fg_samples", ")", ")", "\n", "storage", ".", "put_scalar", "(", "\"roi_head/num_bg_samples\"", ",", "np", ".", "mean", "(", "num_bg_samples", ")", ")", "\n", "\n", "return", "proposals_with_gt", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.rotated_fast_rcnn.fast_rcnn_inference_rotated": [[46, 81], ["rotated_fast_rcnn.fast_rcnn_inference_single_image_rotated", "zip"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.rotated_fast_rcnn.fast_rcnn_inference_single_image_rotated"], ["def", "fast_rcnn_inference_rotated", "(", "\n", "boxes", ",", "scores", ",", "image_shapes", ",", "score_thresh", ",", "nms_thresh", ",", "topk_per_image", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Call `fast_rcnn_inference_single_image_rotated` for all images.\n\n    Args:\n        boxes (list[Tensor]): A list of Tensors of predicted class-specific or class-agnostic\n            boxes for each image. Element i has shape (Ri, K * 5) if doing\n            class-specific regression, or (Ri, 5) if doing class-agnostic\n            regression, where Ri is the number of predicted objects for image i.\n            This is compatible with the output of :meth:`FastRCNNOutputs.predict_boxes`.\n        scores (list[Tensor]): A list of Tensors of predicted class scores for each image.\n            Element i has shape (Ri, K + 1), where Ri is the number of predicted objects\n            for image i. Compatible with the output of :meth:`FastRCNNOutputs.predict_probs`.\n        image_shapes (list[tuple]): A list of (width, height) tuples for each image in the batch.\n        score_thresh (float): Only return detections with a confidence score exceeding this\n            threshold.\n        nms_thresh (float):  The threshold to use for box non-maximum suppression. Value in [0, 1].\n        topk_per_image (int): The number of top scoring detections to return. Set < 0 to return\n            all detections.\n\n    Returns:\n        instances: (list[Instances]): A list of N instances, one for each image in the batch,\n            that stores the topk most confidence detections.\n        kept_indices: (list[Tensor]): A list of 1D tensor of length of N, each element indicates\n            the corresponding boxes/scores index in [0, Ri) from the input, for image i.\n    \"\"\"", "\n", "result_per_image", "=", "[", "\n", "fast_rcnn_inference_single_image_rotated", "(", "\n", "boxes_per_image", ",", "scores_per_image", ",", "image_shape", ",", "score_thresh", ",", "nms_thresh", ",", "topk_per_image", "\n", ")", "\n", "for", "scores_per_image", ",", "boxes_per_image", ",", "image_shape", "in", "zip", "(", "scores", ",", "boxes", ",", "image_shapes", ")", "\n", "]", "\n", "return", "[", "x", "[", "0", "]", "for", "x", "in", "result_per_image", "]", ",", "[", "x", "[", "1", "]", "for", "x", "in", "result_per_image", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.rotated_fast_rcnn.fast_rcnn_inference_single_image_rotated": [[83, 132], ["detectron2.structures.RotatedBoxes", "boxes.tensor.view.clip", "boxes.tensor.view.tensor.view", "filter_mask.nonzero", "detectron2.layers.batched_nms_rotated", "detectron2.structures.Instances", "detectron2.structures.RotatedBoxes", "torch.isfinite().all", "torch.isfinite().all", "valid_mask.all", "boxes.tensor.view.reshape", "torch.isfinite", "torch.isfinite"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.batched_nms_rotated"], ["", "def", "fast_rcnn_inference_single_image_rotated", "(", "\n", "boxes", ",", "scores", ",", "image_shape", ",", "score_thresh", ",", "nms_thresh", ",", "topk_per_image", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Single-image inference. Return rotated bounding-box detection results by thresholding\n    on scores and applying rotated non-maximum suppression (Rotated NMS).\n\n    Args:\n        Same as `fast_rcnn_inference_rotated`, but with rotated boxes, scores, and image shapes\n        per image.\n\n    Returns:\n        Same as `fast_rcnn_inference_rotated`, but for only one image.\n    \"\"\"", "\n", "valid_mask", "=", "torch", ".", "isfinite", "(", "boxes", ")", ".", "all", "(", "dim", "=", "1", ")", "&", "torch", ".", "isfinite", "(", "scores", ")", ".", "all", "(", "dim", "=", "1", ")", "\n", "if", "not", "valid_mask", ".", "all", "(", ")", ":", "\n", "        ", "boxes", "=", "boxes", "[", "valid_mask", "]", "\n", "scores", "=", "scores", "[", "valid_mask", "]", "\n", "\n", "", "B", "=", "5", "# box dimension", "\n", "scores", "=", "scores", "[", ":", ",", ":", "-", "1", "]", "\n", "num_bbox_reg_classes", "=", "boxes", ".", "shape", "[", "1", "]", "//", "B", "\n", "# Convert to Boxes to use the `clip` function ...", "\n", "boxes", "=", "RotatedBoxes", "(", "boxes", ".", "reshape", "(", "-", "1", ",", "B", ")", ")", "\n", "boxes", ".", "clip", "(", "image_shape", ")", "\n", "boxes", "=", "boxes", ".", "tensor", ".", "view", "(", "-", "1", ",", "num_bbox_reg_classes", ",", "B", ")", "# R x C x B", "\n", "# Filter results based on detection scores", "\n", "filter_mask", "=", "scores", ">", "score_thresh", "# R x K", "\n", "# R' x 2. First column contains indices of the R predictions;", "\n", "# Second column contains indices of classes.", "\n", "filter_inds", "=", "filter_mask", ".", "nonzero", "(", ")", "\n", "if", "num_bbox_reg_classes", "==", "1", ":", "\n", "        ", "boxes", "=", "boxes", "[", "filter_inds", "[", ":", ",", "0", "]", ",", "0", "]", "\n", "", "else", ":", "\n", "        ", "boxes", "=", "boxes", "[", "filter_mask", "]", "\n", "", "scores", "=", "scores", "[", "filter_mask", "]", "\n", "\n", "# Apply per-class Rotated NMS", "\n", "keep", "=", "batched_nms_rotated", "(", "boxes", ",", "scores", ",", "filter_inds", "[", ":", ",", "1", "]", ",", "nms_thresh", ")", "\n", "if", "topk_per_image", ">=", "0", ":", "\n", "        ", "keep", "=", "keep", "[", ":", "topk_per_image", "]", "\n", "", "boxes", ",", "scores", ",", "filter_inds", "=", "boxes", "[", "keep", "]", ",", "scores", "[", "keep", "]", ",", "filter_inds", "[", "keep", "]", "\n", "\n", "result", "=", "Instances", "(", "image_shape", ")", "\n", "result", ".", "pred_boxes", "=", "RotatedBoxes", "(", "boxes", ")", "\n", "result", ".", "scores", "=", "scores", "\n", "result", ".", "pred_classes", "=", "filter_inds", "[", ":", ",", "1", "]", "\n", "\n", "return", "result", ",", "filter_inds", "[", ":", ",", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.ROIHeads.__init__": [[138, 165], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "*", ",", "\n", "num_classes", ",", "\n", "batch_size_per_image", ",", "\n", "positive_fraction", ",", "\n", "proposal_matcher", ",", "\n", "proposal_append_gt", "=", "True", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            num_classes (int): number of classes. Used to label background proposals.\n            batch_size_per_image (int): number of proposals to sample for training\n            positive_fraction (float): fraction of positive (foreground) proposals\n                to sample for training.\n            proposal_matcher (Matcher): matcher that matches proposals and ground truth\n            proposal_append_gt (bool): whether to include ground truth as proposals as well\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "batch_size_per_image", "=", "batch_size_per_image", "\n", "self", ".", "positive_fraction", "=", "positive_fraction", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "proposal_matcher", "=", "proposal_matcher", "\n", "self", ".", "proposal_append_gt", "=", "proposal_append_gt", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.ROIHeads.from_config": [[166, 178], ["matcher.Matcher"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "return", "{", "\n", "\"batch_size_per_image\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "BATCH_SIZE_PER_IMAGE", ",", "\n", "\"positive_fraction\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "POSITIVE_FRACTION", ",", "\n", "\"num_classes\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NUM_CLASSES", ",", "\n", "\"proposal_append_gt\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "PROPOSAL_APPEND_GT", ",", "\n", "# Matcher to assign box proposals to gt boxes", "\n", "\"proposal_matcher\"", ":", "Matcher", "(", "\n", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IOU_THRESHOLDS", ",", "\n", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IOU_LABELS", ",", "\n", "allow_low_quality_matches", "=", "False", ",", "\n", ")", ",", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.ROIHeads._sample_proposals": [[181, 218], ["sampling.subsample_labels", "torch.cat", "gt_classes.numel", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.sampling.subsample_labels", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "def", "_sample_proposals", "(", "\n", "self", ",", "matched_idxs", ":", "torch", ".", "Tensor", ",", "matched_labels", ":", "torch", ".", "Tensor", ",", "gt_classes", ":", "torch", ".", "Tensor", "\n", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Based on the matching between N proposals and M groundtruth,\n        sample the proposals and set their classification labels.\n\n        Args:\n            matched_idxs (Tensor): a vector of length N, each is the best-matched\n                gt index in [0, M) for each proposal.\n            matched_labels (Tensor): a vector of length N, the matcher's label\n                (one of cfg.MODEL.ROI_HEADS.IOU_LABELS) for each proposal.\n            gt_classes (Tensor): a vector of length M.\n\n        Returns:\n            Tensor: a vector of indices of sampled proposals. Each is in [0, N).\n            Tensor: a vector of the same length, the classification label for\n                each sampled proposal. Each sample is labeled as either a category in\n                [0, num_classes) or the background (num_classes).\n        \"\"\"", "\n", "has_gt", "=", "gt_classes", ".", "numel", "(", ")", ">", "0", "\n", "# Get the corresponding GT for each proposal", "\n", "if", "has_gt", ":", "\n", "            ", "gt_classes", "=", "gt_classes", "[", "matched_idxs", "]", "\n", "# Label unmatched proposals (0 label from matcher) as background (label=num_classes)", "\n", "gt_classes", "[", "matched_labels", "==", "0", "]", "=", "self", ".", "num_classes", "\n", "# Label ignore proposals (-1 label)", "\n", "gt_classes", "[", "matched_labels", "==", "-", "1", "]", "=", "-", "1", "\n", "", "else", ":", "\n", "            ", "gt_classes", "=", "torch", ".", "zeros_like", "(", "matched_idxs", ")", "+", "self", ".", "num_classes", "\n", "\n", "", "sampled_fg_idxs", ",", "sampled_bg_idxs", "=", "subsample_labels", "(", "\n", "gt_classes", ",", "self", ".", "batch_size_per_image", ",", "self", ".", "positive_fraction", ",", "self", ".", "num_classes", "\n", ")", "\n", "\n", "sampled_idxs", "=", "torch", ".", "cat", "(", "[", "sampled_fg_idxs", ",", "sampled_bg_idxs", "]", ",", "dim", "=", "0", ")", "\n", "return", "sampled_idxs", ",", "gt_classes", "[", "sampled_idxs", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.ROIHeads.label_and_sample_proposals": [[219, 306], ["torch.no_grad", "zip", "detectron2.utils.events.get_event_storage", "detectron2.utils.events.get_event_storage.put_scalar", "detectron2.utils.events.get_event_storage.put_scalar", "proposal_generator.proposal_utils.add_ground_truth_to_proposals", "detectron2.structures.pairwise_iou", "roi_heads.ROIHeads.proposal_matcher", "roi_heads.ROIHeads._sample_proposals", "num_bg_samples.append", "num_fg_samples.append", "proposals_with_gt.append", "numpy.mean", "numpy.mean", "len", "targets_per_image.get_fields().items", "detectron2.structures.Boxes", "targets_per_image.gt_boxes.tensor.new_zeros", "gt_classes.numel", "targets_per_image.get_fields", "trg_name.startswith", "proposals_per_image.set", "proposals_per_image.has", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.get_event_storage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.proposal_generator.proposal_utils.add_ground_truth_to_proposals", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.pairwise_iou", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.ROIHeads._sample_proposals", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.get_fields", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "label_and_sample_proposals", "(", "\n", "self", ",", "proposals", ":", "List", "[", "Instances", "]", ",", "targets", ":", "List", "[", "Instances", "]", "\n", ")", "->", "List", "[", "Instances", "]", ":", "\n", "        ", "\"\"\"\n        Prepare some proposals to be used to train the ROI heads.\n        It performs box matching between `proposals` and `targets`, and assigns\n        training labels to the proposals.\n        It returns ``self.batch_size_per_image`` random samples from proposals and groundtruth\n        boxes, with a fraction of positives that is no larger than\n        ``self.positive_fraction``.\n\n        Args:\n            See :meth:`ROIHeads.forward`\n\n        Returns:\n            list[Instances]:\n                length `N` list of `Instances`s containing the proposals\n                sampled for training. Each `Instances` has the following fields:\n\n                - proposal_boxes: the proposal boxes\n                - gt_boxes: the ground-truth box that the proposal is assigned to\n                  (this is only meaningful if the proposal has a label > 0; if label = 0\n                  then the ground-truth box is random)\n\n                Other fields such as \"gt_classes\", \"gt_masks\", that's included in `targets`.\n        \"\"\"", "\n", "gt_boxes", "=", "[", "x", ".", "gt_boxes", "for", "x", "in", "targets", "]", "\n", "# Augment proposals with ground-truth boxes.", "\n", "# In the case of learned proposals (e.g., RPN), when training starts", "\n", "# the proposals will be low quality due to random initialization.", "\n", "# It's possible that none of these initial", "\n", "# proposals have high enough overlap with the gt objects to be used", "\n", "# as positive examples for the second stage components (box head,", "\n", "# cls head, mask head). Adding the gt boxes to the set of proposals", "\n", "# ensures that the second stage components will have some positive", "\n", "# examples from the start of training. For RPN, this augmentation improves", "\n", "# convergence and empirically improves box AP on COCO by about 0.5", "\n", "# points (under one tested configuration).", "\n", "if", "self", ".", "proposal_append_gt", ":", "\n", "            ", "proposals", "=", "add_ground_truth_to_proposals", "(", "gt_boxes", ",", "proposals", ")", "\n", "\n", "", "proposals_with_gt", "=", "[", "]", "\n", "\n", "num_fg_samples", "=", "[", "]", "\n", "num_bg_samples", "=", "[", "]", "\n", "for", "proposals_per_image", ",", "targets_per_image", "in", "zip", "(", "proposals", ",", "targets", ")", ":", "\n", "            ", "has_gt", "=", "len", "(", "targets_per_image", ")", ">", "0", "\n", "match_quality_matrix", "=", "pairwise_iou", "(", "\n", "targets_per_image", ".", "gt_boxes", ",", "proposals_per_image", ".", "proposal_boxes", "\n", ")", "\n", "matched_idxs", ",", "matched_labels", "=", "self", ".", "proposal_matcher", "(", "match_quality_matrix", ")", "\n", "sampled_idxs", ",", "gt_classes", "=", "self", ".", "_sample_proposals", "(", "\n", "matched_idxs", ",", "matched_labels", ",", "targets_per_image", ".", "gt_classes", "\n", ")", "\n", "\n", "# Set target attributes of the sampled proposals:", "\n", "proposals_per_image", "=", "proposals_per_image", "[", "sampled_idxs", "]", "\n", "proposals_per_image", ".", "gt_classes", "=", "gt_classes", "\n", "\n", "# We index all the attributes of targets that start with \"gt_\"", "\n", "# and have not been added to proposals yet (=\"gt_classes\").", "\n", "if", "has_gt", ":", "\n", "                ", "sampled_targets", "=", "matched_idxs", "[", "sampled_idxs", "]", "\n", "# NOTE: here the indexing waste some compute, because heads", "\n", "# like masks, keypoints, etc, will filter the proposals again,", "\n", "# (by foreground/background, or number of keypoints in the image, etc)", "\n", "# so we essentially index the data twice.", "\n", "for", "(", "trg_name", ",", "trg_value", ")", "in", "targets_per_image", ".", "get_fields", "(", ")", ".", "items", "(", ")", ":", "\n", "                    ", "if", "trg_name", ".", "startswith", "(", "\"gt_\"", ")", "and", "not", "proposals_per_image", ".", "has", "(", "trg_name", ")", ":", "\n", "                        ", "proposals_per_image", ".", "set", "(", "trg_name", ",", "trg_value", "[", "sampled_targets", "]", ")", "\n", "", "", "", "else", ":", "\n", "                ", "gt_boxes", "=", "Boxes", "(", "\n", "targets_per_image", ".", "gt_boxes", ".", "tensor", ".", "new_zeros", "(", "(", "len", "(", "sampled_idxs", ")", ",", "4", ")", ")", "\n", ")", "\n", "proposals_per_image", ".", "gt_boxes", "=", "gt_boxes", "\n", "\n", "", "num_bg_samples", ".", "append", "(", "(", "gt_classes", "==", "self", ".", "num_classes", ")", ".", "sum", "(", ")", ".", "item", "(", ")", ")", "\n", "num_fg_samples", ".", "append", "(", "gt_classes", ".", "numel", "(", ")", "-", "num_bg_samples", "[", "-", "1", "]", ")", "\n", "proposals_with_gt", ".", "append", "(", "proposals_per_image", ")", "\n", "\n", "# Log the number of fg/bg samples that are selected for training ROI heads", "\n", "", "storage", "=", "get_event_storage", "(", ")", "\n", "storage", ".", "put_scalar", "(", "\"roi_head/num_fg_samples\"", ",", "np", ".", "mean", "(", "num_fg_samples", ")", ")", "\n", "storage", ".", "put_scalar", "(", "\"roi_head/num_bg_samples\"", ",", "np", ".", "mean", "(", "num_bg_samples", ")", ")", "\n", "\n", "return", "proposals_with_gt", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.ROIHeads.forward": [[307, 342], ["NotImplementedError"], "methods", ["None"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "images", ":", "ImageList", ",", "\n", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "\n", "proposals", ":", "List", "[", "Instances", "]", ",", "\n", "targets", ":", "Optional", "[", "List", "[", "Instances", "]", "]", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "List", "[", "Instances", "]", ",", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", "]", ":", "\n", "        ", "\"\"\"\n        Args:\n            images (ImageList):\n            features (dict[str,Tensor]): input data as a mapping from feature\n                map name to tensor. Axis 0 represents the number of images `N` in\n                the input data; axes 1-3 are channels, height, and width, which may\n                vary between feature maps (e.g., if a feature pyramid is used).\n            proposals (list[Instances]): length `N` list of `Instances`. The i-th\n                `Instances` contains object proposals for the i-th input image,\n                with fields \"proposal_boxes\" and \"objectness_logits\".\n            targets (list[Instances], optional): length `N` list of `Instances`. The i-th\n                `Instances` contains the ground-truth per-instance annotations\n                for the i-th input image.  Specify `targets` during training only.\n                It may have the following fields:\n\n                - gt_boxes: the bounding box of each instance.\n                - gt_classes: the label for each instance with a category ranging in [0, #class].\n                - gt_masks: PolygonMasks or BitMasks, the ground-truth masks of each instance.\n                - gt_keypoints: NxKx3, the groud-truth keypoints for each instance.\n\n        Returns:\n            list[Instances]: length `N` list of `Instances` containing the\n            detected instances. Returned during inference only; may be [] during training.\n\n            dict[str->Tensor]:\n            mapping from a named loss to a tensor storing the loss. Used during training only.\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.Res5ROIHeads.__init__": [[352, 382], ["roi_heads.ROIHeads.__init__", "poolers.ROIPooler", "roi_heads.Res5ROIHeads._build_res5_block", "fast_rcnn.FastRCNNOutputLayers", "len", "detectron2.layers.ShapeSpec", "mask_head.build_mask_head", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.Res5ROIHeads._build_res5_block", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.mask_head.build_mask_head"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "cfg", ")", "\n", "\n", "# fmt: off", "\n", "self", ".", "in_features", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IN_FEATURES", "\n", "pooler_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_RESOLUTION", "\n", "pooler_type", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_TYPE", "\n", "pooler_scales", "=", "(", "1.0", "/", "input_shape", "[", "self", ".", "in_features", "[", "0", "]", "]", ".", "stride", ",", ")", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "self", ".", "mask_on", "=", "cfg", ".", "MODEL", ".", "MASK_ON", "\n", "# fmt: on", "\n", "assert", "not", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", "\n", "assert", "len", "(", "self", ".", "in_features", ")", "==", "1", "\n", "\n", "self", ".", "pooler", "=", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "pooler_type", ",", "\n", ")", "\n", "\n", "self", ".", "res5", ",", "out_channels", "=", "self", ".", "_build_res5_block", "(", "cfg", ")", "\n", "self", ".", "box_predictor", "=", "FastRCNNOutputLayers", "(", "\n", "cfg", ",", "ShapeSpec", "(", "channels", "=", "out_channels", ",", "height", "=", "1", ",", "width", "=", "1", ")", "\n", ")", "\n", "\n", "if", "self", ".", "mask_on", ":", "\n", "            ", "self", ".", "mask_head", "=", "build_mask_head", "(", "\n", "cfg", ",", "\n", "ShapeSpec", "(", "channels", "=", "out_channels", ",", "width", "=", "pooler_resolution", ",", "height", "=", "pooler_resolution", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.Res5ROIHeads._build_res5_block": [[384, 409], ["backbone.resnet.ResNet.make_stage", "torch.nn.Sequential"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.make_stage"], ["", "", "def", "_build_res5_block", "(", "self", ",", "cfg", ")", ":", "\n", "# fmt: off", "\n", "        ", "stage_channel_factor", "=", "2", "**", "3", "# res5 is 8x res2", "\n", "num_groups", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "NUM_GROUPS", "\n", "width_per_group", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "WIDTH_PER_GROUP", "\n", "bottleneck_channels", "=", "num_groups", "*", "width_per_group", "*", "stage_channel_factor", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "RES2_OUT_CHANNELS", "*", "stage_channel_factor", "\n", "stride_in_1x1", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "STRIDE_IN_1X1", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "NORM", "\n", "assert", "not", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DEFORM_ON_PER_STAGE", "[", "-", "1", "]", ",", "\"Deformable conv is not yet supported in res5 head.\"", "\n", "# fmt: on", "\n", "\n", "blocks", "=", "ResNet", ".", "make_stage", "(", "\n", "BottleneckBlock", ",", "\n", "3", ",", "\n", "stride_per_block", "=", "[", "2", ",", "1", ",", "1", "]", ",", "\n", "in_channels", "=", "out_channels", "//", "2", ",", "\n", "bottleneck_channels", "=", "bottleneck_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "num_groups", "=", "num_groups", ",", "\n", "norm", "=", "norm", ",", "\n", "stride_in_1x1", "=", "stride_in_1x1", ",", "\n", ")", "\n", "return", "nn", ".", "Sequential", "(", "*", "blocks", ")", ",", "out_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.Res5ROIHeads._shared_roi_transform": [[410, 413], ["roi_heads.Res5ROIHeads.pooler", "roi_heads.Res5ROIHeads.res5"], "methods", ["None"], ["", "def", "_shared_roi_transform", "(", "self", ",", "features", ",", "boxes", ")", ":", "\n", "        ", "x", "=", "self", ".", "pooler", "(", "features", ",", "boxes", ")", "\n", "return", "self", ".", "res5", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.Res5ROIHeads.forward": [[414, 450], ["roi_heads.Res5ROIHeads._shared_roi_transform", "roi_heads.Res5ROIHeads.box_predictor", "roi_heads.Res5ROIHeads.label_and_sample_proposals", "roi_heads.Res5ROIHeads.mean", "roi_heads.Res5ROIHeads.box_predictor.losses", "roi_heads.Res5ROIHeads.box_predictor.inference", "roi_heads.Res5ROIHeads.forward_with_given_boxes", "roi_heads.select_foreground_proposals", "roi_heads.Res5ROIHeads.update", "roi_heads.Res5ROIHeads.mask_head", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.Res5ROIHeads._shared_roi_transform", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.ROIHeads.label_and_sample_proposals", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3Head.losses", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.inference", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_head.DensePoseROIHeads.forward_with_given_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.select_foreground_proposals", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "def", "forward", "(", "self", ",", "images", ",", "features", ",", "proposals", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        See :meth:`ROIHeads.forward`.\n        \"\"\"", "\n", "del", "images", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "assert", "targets", "\n", "proposals", "=", "self", ".", "label_and_sample_proposals", "(", "proposals", ",", "targets", ")", "\n", "", "del", "targets", "\n", "\n", "proposal_boxes", "=", "[", "x", ".", "proposal_boxes", "for", "x", "in", "proposals", "]", "\n", "box_features", "=", "self", ".", "_shared_roi_transform", "(", "\n", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", ",", "proposal_boxes", "\n", ")", "\n", "predictions", "=", "self", ".", "box_predictor", "(", "box_features", ".", "mean", "(", "dim", "=", "[", "2", ",", "3", "]", ")", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "del", "features", "\n", "losses", "=", "self", ".", "box_predictor", ".", "losses", "(", "predictions", ",", "proposals", ")", "\n", "if", "self", ".", "mask_on", ":", "\n", "                ", "proposals", ",", "fg_selection_masks", "=", "select_foreground_proposals", "(", "\n", "proposals", ",", "self", ".", "num_classes", "\n", ")", "\n", "# Since the ROI feature transform is shared between boxes and masks,", "\n", "# we don't need to recompute features. The mask loss is only defined", "\n", "# on foreground proposals, so we need to select out the foreground", "\n", "# features.", "\n", "mask_features", "=", "box_features", "[", "torch", ".", "cat", "(", "fg_selection_masks", ",", "dim", "=", "0", ")", "]", "\n", "del", "box_features", "\n", "losses", ".", "update", "(", "self", ".", "mask_head", "(", "mask_features", ",", "proposals", ")", ")", "\n", "", "return", "[", "]", ",", "losses", "\n", "", "else", ":", "\n", "            ", "pred_instances", ",", "_", "=", "self", ".", "box_predictor", ".", "inference", "(", "predictions", ",", "proposals", ")", "\n", "pred_instances", "=", "self", ".", "forward_with_given_boxes", "(", "features", ",", "pred_instances", ")", "\n", "return", "pred_instances", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.Res5ROIHeads.forward_with_given_boxes": [[451, 474], ["instances[].has", "instances[].has", "roi_heads.Res5ROIHeads._shared_roi_transform", "roi_heads.Res5ROIHeads.mask_head"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.Res5ROIHeads._shared_roi_transform"], ["", "", "def", "forward_with_given_boxes", "(", "self", ",", "features", ",", "instances", ")", ":", "\n", "        ", "\"\"\"\n        Use the given boxes in `instances` to produce other (non-box) per-ROI outputs.\n\n        Args:\n            features: same as in `forward()`\n            instances (list[Instances]): instances to predict other outputs. Expect the keys\n                \"pred_boxes\" and \"pred_classes\" to exist.\n\n        Returns:\n            instances (Instances):\n                the same `Instances` object, with extra\n                fields such as `pred_masks` or `pred_keypoints`.\n        \"\"\"", "\n", "assert", "not", "self", ".", "training", "\n", "assert", "instances", "[", "0", "]", ".", "has", "(", "\"pred_boxes\"", ")", "and", "instances", "[", "0", "]", ".", "has", "(", "\"pred_classes\"", ")", "\n", "\n", "if", "self", ".", "mask_on", ":", "\n", "            ", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", "\n", "x", "=", "self", ".", "_shared_roi_transform", "(", "features", ",", "[", "x", ".", "pred_boxes", "for", "x", "in", "instances", "]", ")", "\n", "return", "self", ".", "mask_head", "(", "x", ",", "instances", ")", "\n", "", "else", ":", "\n", "            ", "return", "instances", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.StandardROIHeads.__init__": [[489, 545], ["roi_heads.ROIHeads.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "*", ",", "\n", "box_in_features", ":", "List", "[", "str", "]", ",", "\n", "box_pooler", ":", "ROIPooler", ",", "\n", "box_head", ":", "nn", ".", "Module", ",", "\n", "box_predictor", ":", "nn", ".", "Module", ",", "\n", "mask_in_features", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "mask_pooler", ":", "Optional", "[", "ROIPooler", "]", "=", "None", ",", "\n", "mask_head", ":", "Optional", "[", "nn", ".", "Module", "]", "=", "None", ",", "\n", "keypoint_in_features", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "keypoint_pooler", ":", "Optional", "[", "ROIPooler", "]", "=", "None", ",", "\n", "keypoint_head", ":", "Optional", "[", "nn", ".", "Module", "]", "=", "None", ",", "\n", "train_on_pred_boxes", ":", "bool", "=", "False", ",", "\n", "**", "kwargs", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            box_in_features (list[str]): list of feature names to use for the box head.\n            box_pooler (ROIPooler): pooler to extra region features for box head\n            box_head (nn.Module): transform features to make box predictions\n            box_predictor (nn.Module): make box predictions from the feature.\n                Should have the same interface as :class:`FastRCNNOutputLayers`.\n            mask_in_features (list[str]): list of feature names to use for the mask\n                pooler or mask head. None if not using mask head.\n            mask_pooler (ROIPooler): pooler to extract region features from image features.\n                The mask head will then take region features to make predictions.\n                If None, the mask head will directly take the dict of image features\n                defined by `mask_in_features`\n            mask_head (nn.Module): transform features to make mask predictions\n            keypoint_in_features, keypoint_pooler, keypoint_head: similar to ``mask_*``.\n            train_on_pred_boxes (bool): whether to use proposal boxes or\n                predicted boxes from the box head to train other heads.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "# keep self.in_features for backward compatibility", "\n", "self", ".", "in_features", "=", "self", ".", "box_in_features", "=", "box_in_features", "\n", "self", ".", "box_pooler", "=", "box_pooler", "\n", "self", ".", "box_head", "=", "box_head", "\n", "self", ".", "box_predictor", "=", "box_predictor", "\n", "\n", "self", ".", "mask_on", "=", "mask_in_features", "is", "not", "None", "\n", "if", "self", ".", "mask_on", ":", "\n", "            ", "self", ".", "mask_in_features", "=", "mask_in_features", "\n", "self", ".", "mask_pooler", "=", "mask_pooler", "\n", "self", ".", "mask_head", "=", "mask_head", "\n", "", "self", ".", "keypoint_on", "=", "keypoint_in_features", "is", "not", "None", "\n", "if", "self", ".", "keypoint_on", ":", "\n", "            ", "self", ".", "keypoint_in_features", "=", "keypoint_in_features", "\n", "self", ".", "keypoint_pooler", "=", "keypoint_pooler", "\n", "self", ".", "keypoint_head", "=", "keypoint_head", "\n", "\n", "", "self", ".", "train_on_pred_boxes", "=", "train_on_pred_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.StandardROIHeads.from_config": [[546, 562], ["roi_heads.ROIHeads.from_config", "inspect.ismethod", "inspect.ismethod", "inspect.ismethod", "super().from_config.update", "super().from_config.update", "super().from_config.update", "cls._init_box_head", "cls._init_mask_head", "cls._init_keypoint_head"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3PlusHead.from_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.cascade_rcnn.CascadeROIHeads._init_box_head", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.roi_heads.PointRendROIHeads._init_mask_head", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.StandardROIHeads._init_keypoint_head"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "ret", "=", "super", "(", ")", ".", "from_config", "(", "cfg", ")", "\n", "ret", "[", "\"train_on_pred_boxes\"", "]", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "TRAIN_ON_PRED_BOXES", "\n", "# Subclasses that have not been updated to use from_config style construction", "\n", "# may have overridden _init_*_head methods. In this case, those overridden methods", "\n", "# will not be classmethods and we need to avoid trying to call them here.", "\n", "# We test for this with ismethod which only returns True for bound methods of cls.", "\n", "# Such subclasses will need to handle calling their overridden _init_*_head methods.", "\n", "if", "inspect", ".", "ismethod", "(", "cls", ".", "_init_box_head", ")", ":", "\n", "            ", "ret", ".", "update", "(", "cls", ".", "_init_box_head", "(", "cfg", ",", "input_shape", ")", ")", "\n", "", "if", "inspect", ".", "ismethod", "(", "cls", ".", "_init_mask_head", ")", ":", "\n", "            ", "ret", ".", "update", "(", "cls", ".", "_init_mask_head", "(", "cfg", ",", "input_shape", ")", ")", "\n", "", "if", "inspect", ".", "ismethod", "(", "cls", ".", "_init_keypoint_head", ")", ":", "\n", "            ", "ret", ".", "update", "(", "cls", ".", "_init_keypoint_head", "(", "cfg", ",", "input_shape", ")", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.StandardROIHeads._init_box_head": [[563, 598], ["tuple", "poolers.ROIPooler", "box_head.build_box_head.build_box_head", "fast_rcnn.FastRCNNOutputLayers", "len", "detectron2.layers.ShapeSpec", "set"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.box_head.build_box_head", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["", "@", "classmethod", "\n", "def", "_init_box_head", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "# fmt: off", "\n", "        ", "in_features", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IN_FEATURES", "\n", "pooler_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_RESOLUTION", "\n", "pooler_scales", "=", "tuple", "(", "1.0", "/", "input_shape", "[", "k", "]", ".", "stride", "for", "k", "in", "in_features", ")", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "pooler_type", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_TYPE", "\n", "# fmt: on", "\n", "\n", "# If StandardROIHeads is applied on multiple feature maps (as in FPN),", "\n", "# then we share the same predictors and therefore the channel counts must be the same", "\n", "in_channels", "=", "[", "input_shape", "[", "f", "]", ".", "channels", "for", "f", "in", "in_features", "]", "\n", "# Check all channel counts are equal", "\n", "assert", "len", "(", "set", "(", "in_channels", ")", ")", "==", "1", ",", "in_channels", "\n", "in_channels", "=", "in_channels", "[", "0", "]", "\n", "\n", "box_pooler", "=", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "pooler_type", ",", "\n", ")", "\n", "# Here we split \"box head\" and \"box predictor\", which is mainly due to historical reasons.", "\n", "# They are used together so the \"box predictor\" layers should be part of the \"box head\".", "\n", "# New subclasses of ROIHeads do not need \"box predictor\"s.", "\n", "box_head", "=", "build_box_head", "(", "\n", "cfg", ",", "ShapeSpec", "(", "channels", "=", "in_channels", ",", "height", "=", "pooler_resolution", ",", "width", "=", "pooler_resolution", ")", "\n", ")", "\n", "box_predictor", "=", "FastRCNNOutputLayers", "(", "cfg", ",", "box_head", ".", "output_shape", ")", "\n", "return", "{", "\n", "\"box_in_features\"", ":", "in_features", ",", "\n", "\"box_pooler\"", ":", "box_pooler", ",", "\n", "\"box_head\"", ":", "box_head", ",", "\n", "\"box_predictor\"", ":", "box_predictor", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.StandardROIHeads._init_mask_head": [[600, 633], ["tuple", "mask_head.build_mask_head", "poolers.ROIPooler", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.mask_head.build_mask_head"], ["", "@", "classmethod", "\n", "def", "_init_mask_head", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "if", "not", "cfg", ".", "MODEL", ".", "MASK_ON", ":", "\n", "            ", "return", "{", "}", "\n", "# fmt: off", "\n", "", "in_features", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IN_FEATURES", "\n", "pooler_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_RESOLUTION", "\n", "pooler_scales", "=", "tuple", "(", "1.0", "/", "input_shape", "[", "k", "]", ".", "stride", "for", "k", "in", "in_features", ")", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "pooler_type", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_TYPE", "\n", "# fmt: on", "\n", "\n", "in_channels", "=", "[", "input_shape", "[", "f", "]", ".", "channels", "for", "f", "in", "in_features", "]", "[", "0", "]", "\n", "\n", "ret", "=", "{", "\"mask_in_features\"", ":", "in_features", "}", "\n", "ret", "[", "\"mask_pooler\"", "]", "=", "(", "\n", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "pooler_type", ",", "\n", ")", "\n", "if", "pooler_type", "\n", "else", "None", "\n", ")", "\n", "if", "pooler_type", ":", "\n", "            ", "shape", "=", "ShapeSpec", "(", "\n", "channels", "=", "in_channels", ",", "width", "=", "pooler_resolution", ",", "height", "=", "pooler_resolution", "\n", ")", "\n", "", "else", ":", "\n", "            ", "shape", "=", "{", "f", ":", "input_shape", "[", "f", "]", "for", "f", "in", "in_features", "}", "\n", "", "ret", "[", "\"mask_head\"", "]", "=", "build_mask_head", "(", "cfg", ",", "shape", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.StandardROIHeads._init_keypoint_head": [[634, 667], ["tuple", "keypoint_head.build_keypoint_head", "poolers.ROIPooler", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.keypoint_head.build_keypoint_head"], ["", "@", "classmethod", "\n", "def", "_init_keypoint_head", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "if", "not", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ":", "\n", "            ", "return", "{", "}", "\n", "# fmt: off", "\n", "", "in_features", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IN_FEATURES", "\n", "pooler_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "POOLER_RESOLUTION", "\n", "pooler_scales", "=", "tuple", "(", "1.0", "/", "input_shape", "[", "k", "]", ".", "stride", "for", "k", "in", "in_features", ")", "# noqa", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "pooler_type", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "POOLER_TYPE", "\n", "# fmt: on", "\n", "\n", "in_channels", "=", "[", "input_shape", "[", "f", "]", ".", "channels", "for", "f", "in", "in_features", "]", "[", "0", "]", "\n", "\n", "ret", "=", "{", "\"keypoint_in_features\"", ":", "in_features", "}", "\n", "ret", "[", "\"keypoint_pooler\"", "]", "=", "(", "\n", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "pooler_type", ",", "\n", ")", "\n", "if", "pooler_type", "\n", "else", "None", "\n", ")", "\n", "if", "pooler_type", ":", "\n", "            ", "shape", "=", "ShapeSpec", "(", "\n", "channels", "=", "in_channels", ",", "width", "=", "pooler_resolution", ",", "height", "=", "pooler_resolution", "\n", ")", "\n", "", "else", ":", "\n", "            ", "shape", "=", "{", "f", ":", "input_shape", "[", "f", "]", "for", "f", "in", "in_features", "}", "\n", "", "ret", "[", "\"keypoint_head\"", "]", "=", "build_keypoint_head", "(", "cfg", ",", "shape", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.StandardROIHeads.forward": [[668, 698], ["roi_heads.StandardROIHeads.label_and_sample_proposals", "roi_heads.StandardROIHeads._forward_box", "roi_heads.StandardROIHeads.update", "roi_heads.StandardROIHeads.update", "roi_heads.StandardROIHeads._forward_box", "roi_heads.StandardROIHeads.forward_with_given_boxes", "roi_heads.StandardROIHeads._forward_mask", "roi_heads.StandardROIHeads._forward_keypoint"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.ROIHeads.label_and_sample_proposals", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.cascade_rcnn.CascadeROIHeads._forward_box", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.cascade_rcnn.CascadeROIHeads._forward_box", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_head.DensePoseROIHeads.forward_with_given_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.roi_heads.PointRendROIHeads._forward_mask", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.StandardROIHeads._forward_keypoint"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "images", ":", "ImageList", ",", "\n", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "\n", "proposals", ":", "List", "[", "Instances", "]", ",", "\n", "targets", ":", "Optional", "[", "List", "[", "Instances", "]", "]", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "List", "[", "Instances", "]", ",", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", "]", ":", "\n", "        ", "\"\"\"\n        See :class:`ROIHeads.forward`.\n        \"\"\"", "\n", "del", "images", "\n", "if", "self", ".", "training", ":", "\n", "            ", "assert", "targets", "\n", "proposals", "=", "self", ".", "label_and_sample_proposals", "(", "proposals", ",", "targets", ")", "\n", "", "del", "targets", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "losses", "=", "self", ".", "_forward_box", "(", "features", ",", "proposals", ")", "\n", "# Usually the original proposals used by the box head are used by the mask, keypoint", "\n", "# heads. But when `self.train_on_pred_boxes is True`, proposals will contain boxes", "\n", "# predicted by the box head.", "\n", "losses", ".", "update", "(", "self", ".", "_forward_mask", "(", "features", ",", "proposals", ")", ")", "\n", "losses", ".", "update", "(", "self", ".", "_forward_keypoint", "(", "features", ",", "proposals", ")", ")", "\n", "return", "proposals", ",", "losses", "\n", "", "else", ":", "\n", "            ", "pred_instances", "=", "self", ".", "_forward_box", "(", "features", ",", "proposals", ")", "\n", "# During inference cascaded prediction is used: the mask and keypoints heads are only", "\n", "# applied to the top scoring box detections.", "\n", "pred_instances", "=", "self", ".", "forward_with_given_boxes", "(", "features", ",", "pred_instances", ")", "\n", "return", "pred_instances", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.StandardROIHeads.forward_with_given_boxes": [[699, 725], ["roi_heads.StandardROIHeads._forward_mask", "roi_heads.StandardROIHeads._forward_keypoint", "instances[].has", "instances[].has"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.roi_heads.PointRendROIHeads._forward_mask", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.StandardROIHeads._forward_keypoint", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has"], ["", "", "def", "forward_with_given_boxes", "(", "\n", "self", ",", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "instances", ":", "List", "[", "Instances", "]", "\n", ")", "->", "List", "[", "Instances", "]", ":", "\n", "        ", "\"\"\"\n        Use the given boxes in `instances` to produce other (non-box) per-ROI outputs.\n\n        This is useful for downstream tasks where a box is known, but need to obtain\n        other attributes (outputs of other heads).\n        Test-time augmentation also uses this.\n\n        Args:\n            features: same as in `forward()`\n            instances (list[Instances]): instances to predict other outputs. Expect the keys\n                \"pred_boxes\" and \"pred_classes\" to exist.\n\n        Returns:\n            instances (list[Instances]):\n                the same `Instances` objects, with extra\n                fields such as `pred_masks` or `pred_keypoints`.\n        \"\"\"", "\n", "assert", "not", "self", ".", "training", "\n", "assert", "instances", "[", "0", "]", ".", "has", "(", "\"pred_boxes\"", ")", "and", "instances", "[", "0", "]", ".", "has", "(", "\"pred_classes\"", ")", "\n", "\n", "instances", "=", "self", ".", "_forward_mask", "(", "features", ",", "instances", ")", "\n", "instances", "=", "self", ".", "_forward_keypoint", "(", "features", ",", "instances", ")", "\n", "return", "instances", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.StandardROIHeads._forward_box": [[726, 765], ["roi_heads.StandardROIHeads.box_pooler", "roi_heads.StandardROIHeads.box_head", "roi_heads.StandardROIHeads.box_predictor", "roi_heads.StandardROIHeads.box_predictor.losses", "roi_heads.StandardROIHeads.box_predictor.inference", "torch.no_grad", "roi_heads.StandardROIHeads.box_predictor.predict_boxes_for_gt_classes", "zip", "detectron2.structures.Boxes"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3Head.losses", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.inference", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_boxes_for_gt_classes"], ["", "def", "_forward_box", "(", "\n", "self", ",", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "proposals", ":", "List", "[", "Instances", "]", "\n", ")", "->", "Union", "[", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "List", "[", "Instances", "]", "]", ":", "\n", "        ", "\"\"\"\n        Forward logic of the box prediction branch. If `self.train_on_pred_boxes is True`,\n            the function puts predicted boxes in the `proposal_boxes` field of `proposals` argument.\n\n        Args:\n            features (dict[str, Tensor]): mapping from feature map names to tensor.\n                Same as in :meth:`ROIHeads.forward`.\n            proposals (list[Instances]): the per-image object proposals with\n                their matching ground truth.\n                Each has fields \"proposal_boxes\", and \"objectness_logits\",\n                \"gt_classes\", \"gt_boxes\".\n\n        Returns:\n            In training, a dict of losses.\n            In inference, a list of `Instances`, the predicted instances.\n        \"\"\"", "\n", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "box_in_features", "]", "\n", "box_features", "=", "self", ".", "box_pooler", "(", "features", ",", "[", "x", ".", "proposal_boxes", "for", "x", "in", "proposals", "]", ")", "\n", "box_features", "=", "self", ".", "box_head", "(", "box_features", ")", "\n", "predictions", "=", "self", ".", "box_predictor", "(", "box_features", ")", "\n", "del", "box_features", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "losses", "=", "self", ".", "box_predictor", ".", "losses", "(", "predictions", ",", "proposals", ")", "\n", "# proposals is modified in-place below, so losses must be computed first.", "\n", "if", "self", ".", "train_on_pred_boxes", ":", "\n", "                ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "pred_boxes", "=", "self", ".", "box_predictor", ".", "predict_boxes_for_gt_classes", "(", "\n", "predictions", ",", "proposals", "\n", ")", "\n", "for", "proposals_per_image", ",", "pred_boxes_per_image", "in", "zip", "(", "proposals", ",", "pred_boxes", ")", ":", "\n", "                        ", "proposals_per_image", ".", "proposal_boxes", "=", "Boxes", "(", "pred_boxes_per_image", ")", "\n", "", "", "", "return", "losses", "\n", "", "else", ":", "\n", "            ", "pred_instances", ",", "_", "=", "self", ".", "box_predictor", ".", "inference", "(", "predictions", ",", "proposals", ")", "\n", "return", "pred_instances", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.StandardROIHeads._forward_mask": [[766, 797], ["roi_heads.StandardROIHeads.mask_head", "roi_heads.select_foreground_proposals", "roi_heads.StandardROIHeads.mask_pooler"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.select_foreground_proposals"], ["", "", "def", "_forward_mask", "(", "\n", "self", ",", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "instances", ":", "List", "[", "Instances", "]", "\n", ")", "->", "Union", "[", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "List", "[", "Instances", "]", "]", ":", "\n", "        ", "\"\"\"\n        Forward logic of the mask prediction branch.\n\n        Args:\n            features (dict[str, Tensor]): mapping from feature map names to tensor.\n                Same as in :meth:`ROIHeads.forward`.\n            instances (list[Instances]): the per-image instances to train/predict masks.\n                In training, they can be the proposals.\n                In inference, they can be the boxes predicted by R-CNN box head.\n\n        Returns:\n            In training, a dict of losses.\n            In inference, update `instances` with new fields \"pred_masks\" and return it.\n        \"\"\"", "\n", "if", "not", "self", ".", "mask_on", ":", "\n", "            ", "return", "{", "}", "if", "self", ".", "training", "else", "instances", "\n", "\n", "", "if", "self", ".", "training", ":", "\n", "# head is only trained on positive proposals.", "\n", "            ", "instances", ",", "_", "=", "select_foreground_proposals", "(", "instances", ",", "self", ".", "num_classes", ")", "\n", "\n", "", "if", "self", ".", "mask_pooler", "is", "not", "None", ":", "\n", "            ", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "mask_in_features", "]", "\n", "boxes", "=", "[", "x", ".", "proposal_boxes", "if", "self", ".", "training", "else", "x", ".", "pred_boxes", "for", "x", "in", "instances", "]", "\n", "features", "=", "self", ".", "mask_pooler", "(", "features", ",", "boxes", ")", "\n", "", "else", ":", "\n", "            ", "features", "=", "{", "f", ":", "features", "[", "f", "]", "for", "f", "in", "self", ".", "mask_in_features", "}", "\n", "", "return", "self", ".", "mask_head", "(", "features", ",", "instances", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.StandardROIHeads._forward_keypoint": [[798, 830], ["roi_heads.StandardROIHeads.keypoint_head", "roi_heads.select_foreground_proposals", "roi_heads.select_proposals_with_visible_keypoints", "roi_heads.StandardROIHeads.keypoint_pooler"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.select_foreground_proposals", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.select_proposals_with_visible_keypoints"], ["", "def", "_forward_keypoint", "(", "\n", "self", ",", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "instances", ":", "List", "[", "Instances", "]", "\n", ")", "->", "Union", "[", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "List", "[", "Instances", "]", "]", ":", "\n", "        ", "\"\"\"\n        Forward logic of the keypoint prediction branch.\n\n        Args:\n            features (dict[str, Tensor]): mapping from feature map names to tensor.\n                Same as in :meth:`ROIHeads.forward`.\n            instances (list[Instances]): the per-image instances to train/predict keypoints.\n                In training, they can be the proposals.\n                In inference, they can be the boxes predicted by R-CNN box head.\n\n        Returns:\n            In training, a dict of losses.\n            In inference, update `instances` with new fields \"pred_keypoints\" and return it.\n        \"\"\"", "\n", "if", "not", "self", ".", "keypoint_on", ":", "\n", "            ", "return", "{", "}", "if", "self", ".", "training", "else", "instances", "\n", "\n", "", "if", "self", ".", "training", ":", "\n", "# head is only trained on positive proposals with >=1 visible keypoints.", "\n", "            ", "instances", ",", "_", "=", "select_foreground_proposals", "(", "instances", ",", "self", ".", "num_classes", ")", "\n", "instances", "=", "select_proposals_with_visible_keypoints", "(", "instances", ")", "\n", "\n", "", "if", "self", ".", "keypoint_pooler", "is", "not", "None", ":", "\n", "            ", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "keypoint_in_features", "]", "\n", "boxes", "=", "[", "x", ".", "proposal_boxes", "if", "self", ".", "training", "else", "x", ".", "pred_boxes", "for", "x", "in", "instances", "]", "\n", "features", "=", "self", ".", "keypoint_pooler", "(", "features", ",", "boxes", ")", "\n", "", "else", ":", "\n", "            ", "features", "=", "{", "f", ":", "features", "[", "f", "]", "for", "f", "in", "self", ".", "keypoint_in_features", "}", "\n", "", "return", "self", ".", "keypoint_head", "(", "features", ",", "instances", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.build_roi_heads": [[38, 44], ["ROI_HEADS_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["def", "build_roi_heads", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build ROIHeads defined by `cfg.MODEL.ROI_HEADS.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NAME", "\n", "return", "ROI_HEADS_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.select_foreground_proposals": [[46, 76], ["isinstance", "isinstance", "proposals[].has", "fg_selection_mask.nonzero().squeeze", "fg_proposals.append", "fg_selection_masks.append", "fg_selection_mask.nonzero"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has"], ["", "def", "select_foreground_proposals", "(", "\n", "proposals", ":", "List", "[", "Instances", "]", ",", "bg_label", ":", "int", "\n", ")", "->", "Tuple", "[", "List", "[", "Instances", "]", ",", "List", "[", "torch", ".", "Tensor", "]", "]", ":", "\n", "    ", "\"\"\"\n    Given a list of N Instances (for N images), each containing a `gt_classes` field,\n    return a list of Instances that contain only instances with `gt_classes != -1 &&\n    gt_classes != bg_label`.\n\n    Args:\n        proposals (list[Instances]): A list of N Instances, where N is the number of\n            images in the batch.\n        bg_label: label index of background class.\n\n    Returns:\n        list[Instances]: N Instances, each contains only the selected foreground instances.\n        list[Tensor]: N boolean vector, correspond to the selection mask of\n            each Instances object. True for selected instances.\n    \"\"\"", "\n", "assert", "isinstance", "(", "proposals", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "isinstance", "(", "proposals", "[", "0", "]", ",", "Instances", ")", "\n", "assert", "proposals", "[", "0", "]", ".", "has", "(", "\"gt_classes\"", ")", "\n", "fg_proposals", "=", "[", "]", "\n", "fg_selection_masks", "=", "[", "]", "\n", "for", "proposals_per_image", "in", "proposals", ":", "\n", "        ", "gt_classes", "=", "proposals_per_image", ".", "gt_classes", "\n", "fg_selection_mask", "=", "(", "gt_classes", "!=", "-", "1", ")", "&", "(", "gt_classes", "!=", "bg_label", ")", "\n", "fg_idxs", "=", "fg_selection_mask", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "fg_proposals", ".", "append", "(", "proposals_per_image", "[", "fg_idxs", "]", ")", "\n", "fg_selection_masks", ".", "append", "(", "fg_selection_mask", ")", "\n", "", "return", "fg_proposals", ",", "fg_selection_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.select_proposals_with_visible_keypoints": [[78, 121], ["detectron2.utils.events.get_event_storage", "detectron2.utils.events.get_event_storage.put_scalar", "proposals_per_image.proposal_boxes.tensor.unsqueeze", "all_num_fg.append", "ret.append", "numpy.mean", "len", "ret.append", "detectron2.layers.nonzero_tuple", "selection_idxs.numel"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.get_event_storage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.nonzero_tuple"], ["", "def", "select_proposals_with_visible_keypoints", "(", "proposals", ":", "List", "[", "Instances", "]", ")", "->", "List", "[", "Instances", "]", ":", "\n", "    ", "\"\"\"\n    Args:\n        proposals (list[Instances]): a list of N Instances, where N is the\n            number of images.\n\n    Returns:\n        proposals: only contains proposals with at least one visible keypoint.\n\n    Note that this is still slightly different from Detectron.\n    In Detectron, proposals for training keypoint head are re-sampled from\n    all the proposals with IOU>threshold & >=1 visible keypoint.\n\n    Here, the proposals are first sampled from all proposals with\n    IOU>threshold, then proposals with no visible keypoint are filtered out.\n    This strategy seems to make no difference on Detectron and is easier to implement.\n    \"\"\"", "\n", "ret", "=", "[", "]", "\n", "all_num_fg", "=", "[", "]", "\n", "for", "proposals_per_image", "in", "proposals", ":", "\n", "# If empty/unannotated image (hard negatives), skip filtering for train", "\n", "        ", "if", "len", "(", "proposals_per_image", ")", "==", "0", ":", "\n", "            ", "ret", ".", "append", "(", "proposals_per_image", ")", "\n", "continue", "\n", "", "gt_keypoints", "=", "proposals_per_image", ".", "gt_keypoints", ".", "tensor", "\n", "# #fg x K x 3", "\n", "vis_mask", "=", "gt_keypoints", "[", ":", ",", ":", ",", "2", "]", ">=", "1", "\n", "xs", ",", "ys", "=", "gt_keypoints", "[", ":", ",", ":", ",", "0", "]", ",", "gt_keypoints", "[", ":", ",", ":", ",", "1", "]", "\n", "proposal_boxes", "=", "proposals_per_image", ".", "proposal_boxes", ".", "tensor", ".", "unsqueeze", "(", "dim", "=", "1", ")", "# #fg x 1 x 4", "\n", "kp_in_box", "=", "(", "\n", "(", "xs", ">=", "proposal_boxes", "[", ":", ",", ":", ",", "0", "]", ")", "\n", "&", "(", "xs", "<=", "proposal_boxes", "[", ":", ",", ":", ",", "2", "]", ")", "\n", "&", "(", "ys", ">=", "proposal_boxes", "[", ":", ",", ":", ",", "1", "]", ")", "\n", "&", "(", "ys", "<=", "proposal_boxes", "[", ":", ",", ":", ",", "3", "]", ")", "\n", ")", "\n", "selection", "=", "(", "kp_in_box", "&", "vis_mask", ")", ".", "any", "(", "dim", "=", "1", ")", "\n", "selection_idxs", "=", "nonzero_tuple", "(", "selection", ")", "[", "0", "]", "\n", "all_num_fg", ".", "append", "(", "selection_idxs", ".", "numel", "(", ")", ")", "\n", "ret", ".", "append", "(", "proposals_per_image", "[", "selection_idxs", "]", ")", "\n", "\n", "", "storage", "=", "get_event_storage", "(", ")", "\n", "storage", ".", "put_scalar", "(", "\"keypoint_head/num_fg_samples\"", ",", "np", ".", "mean", "(", "all_num_fg", ")", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.keypoint_head.BaseKeypointRCNNHead.__init__": [[141, 159], ["torch.nn.Module.__init__", "isinstance"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "self", ",", "*", ",", "num_keypoints", ",", "loss_weight", "=", "1.0", ",", "loss_normalizer", "=", "1.0", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            num_keypoints (int): number of keypoints to predict\n            loss_weight (float): weight to multiple on the keypoint loss\n            loss_normalizer (float or str):\n                If float, divide the loss by `loss_normalizer * #images`.\n                If 'visible', the loss is normalized by the total number of\n                visible keypoints across images.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_keypoints", "=", "num_keypoints", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "assert", "loss_normalizer", "==", "\"visible\"", "or", "isinstance", "(", "loss_normalizer", ",", "float", ")", ",", "loss_normalizer", "\n", "self", ".", "loss_normalizer", "=", "loss_normalizer", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.keypoint_head.BaseKeypointRCNNHead.from_config": [[160, 178], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "ret", "=", "{", "\n", "\"loss_weight\"", ":", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "LOSS_WEIGHT", ",", "\n", "\"num_keypoints\"", ":", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "NUM_KEYPOINTS", ",", "\n", "}", "\n", "normalize_by_visible", "=", "(", "\n", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "NORMALIZE_LOSS_BY_VISIBLE_KEYPOINTS", "\n", ")", "# noqa", "\n", "if", "not", "normalize_by_visible", ":", "\n", "            ", "batch_size_per_image", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "BATCH_SIZE_PER_IMAGE", "\n", "positive_sample_fraction", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "POSITIVE_FRACTION", "\n", "ret", "[", "\"loss_normalizer\"", "]", "=", "(", "\n", "ret", "[", "\"num_keypoints\"", "]", "*", "batch_size_per_image", "*", "positive_sample_fraction", "\n", ")", "\n", "", "else", ":", "\n", "            ", "ret", "[", "\"loss_normalizer\"", "]", "=", "\"visible\"", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.keypoint_head.BaseKeypointRCNNHead.forward": [[179, 207], ["keypoint_head.BaseKeypointRCNNHead.layers", "len", "keypoint_head.keypoint_rcnn_inference", "torch.jit.is_scripting", "keypoint_head.keypoint_rcnn_loss"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3PlusHead.layers", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.keypoint_head.keypoint_rcnn_inference", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.keypoint_head.keypoint_rcnn_loss"], ["", "def", "forward", "(", "self", ",", "x", ",", "instances", ":", "List", "[", "Instances", "]", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x: input region feature(s) provided by :class:`ROIHeads`.\n            instances (list[Instances]): contains the boxes & labels corresponding\n                to the input features.\n                Exact format is up to its caller to decide.\n                Typically, this is the foreground instances in training, with\n                \"proposal_boxes\" field and other gt annotations.\n                In inference, it contains boxes that are already predicted.\n\n        Returns:\n            A dict of losses if in training. The predicted \"instances\" if in inference.\n        \"\"\"", "\n", "x", "=", "self", ".", "layers", "(", "x", ")", "\n", "if", "self", ".", "training", ":", "\n", "            ", "assert", "not", "torch", ".", "jit", ".", "is_scripting", "(", ")", "\n", "num_images", "=", "len", "(", "instances", ")", "\n", "normalizer", "=", "(", "\n", "None", "if", "self", ".", "loss_normalizer", "==", "\"visible\"", "else", "num_images", "*", "self", ".", "loss_normalizer", "\n", ")", "\n", "return", "{", "\n", "\"loss_keypoint\"", ":", "keypoint_rcnn_loss", "(", "x", ",", "instances", ",", "normalizer", "=", "normalizer", ")", "\n", "*", "self", ".", "loss_weight", "\n", "}", "\n", "", "else", ":", "\n", "            ", "keypoint_rcnn_inference", "(", "x", ",", "instances", ")", "\n", "return", "instances", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.keypoint_head.BaseKeypointRCNNHead.layers": [[208, 213], ["None"], "methods", ["None"], ["", "", "def", "layers", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Neural network layers that makes predictions from regional input features.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.keypoint_head.KRCNNConvDeconvUpsampleHead.__init__": [[226, 261], ["super().__init__", "enumerate", "detectron2.layers.ConvTranspose2d", "keypoint_head.KRCNNConvDeconvUpsampleHead.named_parameters", "detectron2.layers.Conv2d", "keypoint_head.KRCNNConvDeconvUpsampleHead.add_module", "keypoint_head.KRCNNConvDeconvUpsampleHead.add_module", "torch.nn.ReLU", "torch.nn.init.constant_", "torch.nn.init.kaiming_normal_"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "self", ",", "input_shape", ",", "*", ",", "num_keypoints", ",", "conv_dims", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            input_shape (ShapeSpec): shape of the input feature\n            conv_dims: an iterable of output channel counts for each conv in the head\n                         e.g. (512, 512, 512) for three convs outputting 512 channels.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "num_keypoints", "=", "num_keypoints", ",", "**", "kwargs", ")", "\n", "\n", "# default up_scale to 2.0 (this can be made an option)", "\n", "up_scale", "=", "2.0", "\n", "in_channels", "=", "input_shape", ".", "channels", "\n", "\n", "for", "idx", ",", "layer_channels", "in", "enumerate", "(", "conv_dims", ",", "1", ")", ":", "\n", "            ", "module", "=", "Conv2d", "(", "in_channels", ",", "layer_channels", ",", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "add_module", "(", "\"conv_fcn{}\"", ".", "format", "(", "idx", ")", ",", "module", ")", "\n", "self", ".", "add_module", "(", "\"conv_fcn_relu{}\"", ".", "format", "(", "idx", ")", ",", "nn", ".", "ReLU", "(", ")", ")", "\n", "in_channels", "=", "layer_channels", "\n", "\n", "", "deconv_kernel", "=", "4", "\n", "self", ".", "score_lowres", "=", "ConvTranspose2d", "(", "\n", "in_channels", ",", "num_keypoints", ",", "deconv_kernel", ",", "stride", "=", "2", ",", "padding", "=", "deconv_kernel", "//", "2", "-", "1", "\n", ")", "\n", "self", ".", "up_scale", "=", "up_scale", "\n", "\n", "for", "name", ",", "param", "in", "self", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "\"bias\"", "in", "name", ":", "\n", "                ", "nn", ".", "init", ".", "constant_", "(", "param", ",", "0", ")", "\n", "", "elif", "\"weight\"", "in", "name", ":", "\n", "# Caffe2 implementation uses MSRAFill, which in fact", "\n", "# corresponds to kaiming_normal_ in PyTorch", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "param", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.keypoint_head.KRCNNConvDeconvUpsampleHead.from_config": [[262, 268], ["super().from_config"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3PlusHead.from_config"], ["", "", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "ret", "=", "super", "(", ")", ".", "from_config", "(", "cfg", ",", "input_shape", ")", "\n", "ret", "[", "\"input_shape\"", "]", "=", "input_shape", "\n", "ret", "[", "\"conv_dims\"", "]", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "CONV_DIMS", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.keypoint_head.KRCNNConvDeconvUpsampleHead.layers": [[269, 274], ["detectron2.layers.interpolate", "layer"], "methods", ["None"], ["", "def", "layers", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "layer", "in", "self", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "", "x", "=", "interpolate", "(", "x", ",", "scale_factor", "=", "self", ".", "up_scale", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", "\n", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.keypoint_head.build_keypoint_head": [[32, 38], ["ROI_KEYPOINT_HEAD_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["def", "build_keypoint_head", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build a keypoint head from `cfg.MODEL.ROI_KEYPOINT_HEAD.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "NAME", "\n", "return", "ROI_KEYPOINT_HEAD_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.keypoint_head.keypoint_rcnn_loss": [[40, 97], ["len", "pred_keypoint_logits.view.view", "torch.nn.functional.cross_entropy", "keypoints.to_heatmap", "heatmaps.append", "torch.nonzero().squeeze.append", "detectron2.layers.cat", "detectron2.layers.cat().to", "torch.nonzero().squeeze", "detectron2.utils.events.get_event_storage", "detectron2.utils.events.get_event_storage.put_scalar", "torch.nonzero().squeeze.numel", "len", "heatmaps_per_image.view", "valid_per_image.view", "len", "torch.nonzero().squeeze.numel", "pred_keypoint_logits.view.sum", "detectron2.layers.cat", "torch.nonzero"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.keypoints.Keypoints.to_heatmap", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.get_event_storage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "def", "keypoint_rcnn_loss", "(", "pred_keypoint_logits", ",", "instances", ",", "normalizer", ")", ":", "\n", "    ", "\"\"\"\n    Arguments:\n        pred_keypoint_logits (Tensor): A tensor of shape (N, K, S, S) where N is the total number\n            of instances in the batch, K is the number of keypoints, and S is the side length\n            of the keypoint heatmap. The values are spatial logits.\n        instances (list[Instances]): A list of M Instances, where M is the batch size.\n            These instances are predictions from the model\n            that are in 1:1 correspondence with pred_keypoint_logits.\n            Each Instances should contain a `gt_keypoints` field containing a `structures.Keypoint`\n            instance.\n        normalizer (float): Normalize the loss by this amount.\n            If not specified, we normalize by the number of visible keypoints in the minibatch.\n\n    Returns a scalar tensor containing the loss.\n    \"\"\"", "\n", "heatmaps", "=", "[", "]", "\n", "valid", "=", "[", "]", "\n", "\n", "keypoint_side_len", "=", "pred_keypoint_logits", ".", "shape", "[", "2", "]", "\n", "for", "instances_per_image", "in", "instances", ":", "\n", "        ", "if", "len", "(", "instances_per_image", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "", "keypoints", "=", "instances_per_image", ".", "gt_keypoints", "\n", "heatmaps_per_image", ",", "valid_per_image", "=", "keypoints", ".", "to_heatmap", "(", "\n", "instances_per_image", ".", "proposal_boxes", ".", "tensor", ",", "keypoint_side_len", "\n", ")", "\n", "heatmaps", ".", "append", "(", "heatmaps_per_image", ".", "view", "(", "-", "1", ")", ")", "\n", "valid", ".", "append", "(", "valid_per_image", ".", "view", "(", "-", "1", ")", ")", "\n", "\n", "", "if", "len", "(", "heatmaps", ")", ":", "\n", "        ", "keypoint_targets", "=", "cat", "(", "heatmaps", ",", "dim", "=", "0", ")", "\n", "valid", "=", "cat", "(", "valid", ",", "dim", "=", "0", ")", ".", "to", "(", "dtype", "=", "torch", ".", "uint8", ")", "\n", "valid", "=", "torch", ".", "nonzero", "(", "valid", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "# torch.mean (in binary_cross_entropy_with_logits) doesn't", "\n", "# accept empty tensors, so handle it separately", "\n", "", "if", "len", "(", "heatmaps", ")", "==", "0", "or", "valid", ".", "numel", "(", ")", "==", "0", ":", "\n", "        ", "global", "_TOTAL_SKIPPED", "\n", "_TOTAL_SKIPPED", "+=", "1", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "storage", ".", "put_scalar", "(", "\"kpts_num_skipped_batches\"", ",", "_TOTAL_SKIPPED", ",", "smoothing_hint", "=", "False", ")", "\n", "return", "pred_keypoint_logits", ".", "sum", "(", ")", "*", "0", "\n", "\n", "", "N", ",", "K", ",", "H", ",", "W", "=", "pred_keypoint_logits", ".", "shape", "\n", "pred_keypoint_logits", "=", "pred_keypoint_logits", ".", "view", "(", "N", "*", "K", ",", "H", "*", "W", ")", "\n", "\n", "keypoint_loss", "=", "F", ".", "cross_entropy", "(", "\n", "pred_keypoint_logits", "[", "valid", "]", ",", "keypoint_targets", "[", "valid", "]", ",", "reduction", "=", "\"sum\"", "\n", ")", "\n", "\n", "# If a normalizer isn't specified, normalize by the number of visible keypoints in the minibatch", "\n", "if", "normalizer", "is", "None", ":", "\n", "        ", "normalizer", "=", "valid", ".", "numel", "(", ")", "\n", "", "keypoint_loss", "/=", "normalizer", "\n", "\n", "return", "keypoint_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.keypoint_head.keypoint_rcnn_inference": [[99, 133], ["detectron2.layers.cat", "pred_keypoint_logits.detach.detach", "detectron2.structures.heatmaps_to_keypoints", "keypoint_results[].split", "pred_keypoint_logits.detach.split", "zip", "detectron2.layers.cat.detach", "len"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.keypoints.heatmaps_to_keypoints"], ["", "def", "keypoint_rcnn_inference", "(", "pred_keypoint_logits", ":", "torch", ".", "Tensor", ",", "pred_instances", ":", "List", "[", "Instances", "]", ")", ":", "\n", "    ", "\"\"\"\n    Post process each predicted keypoint heatmap in `pred_keypoint_logits` into (x, y, score)\n        and add it to the `pred_instances` as a `pred_keypoints` field.\n\n    Args:\n        pred_keypoint_logits (Tensor): A tensor of shape (R, K, S, S) where R is the total number\n           of instances in the batch, K is the number of keypoints, and S is the side length of\n           the keypoint heatmap. The values are spatial logits.\n        pred_instances (list[Instances]): A list of N Instances, where N is the number of images.\n\n    Returns:\n        None. Each element in pred_instances will contain extra \"pred_keypoints\" and\n            \"pred_keypoint_heatmaps\" fields. \"pred_keypoints\" is a tensor of shape\n            (#instance, K, 3) where the last dimension corresponds to (x, y, score).\n            The scores are larger than 0. \"pred_keypoint_heatmaps\" contains the raw\n            keypoint logits as passed to this function.\n    \"\"\"", "\n", "# flatten all bboxes from all images together (list[Boxes] -> Rx4 tensor)", "\n", "bboxes_flat", "=", "cat", "(", "[", "b", ".", "pred_boxes", ".", "tensor", "for", "b", "in", "pred_instances", "]", ",", "dim", "=", "0", ")", "\n", "\n", "pred_keypoint_logits", "=", "pred_keypoint_logits", ".", "detach", "(", ")", "\n", "keypoint_results", "=", "heatmaps_to_keypoints", "(", "pred_keypoint_logits", ",", "bboxes_flat", ".", "detach", "(", ")", ")", "\n", "num_instances_per_image", "=", "[", "len", "(", "i", ")", "for", "i", "in", "pred_instances", "]", "\n", "keypoint_results", "=", "keypoint_results", "[", ":", ",", ":", ",", "[", "0", ",", "1", ",", "3", "]", "]", ".", "split", "(", "num_instances_per_image", ",", "dim", "=", "0", ")", "\n", "heatmap_results", "=", "pred_keypoint_logits", ".", "split", "(", "num_instances_per_image", ",", "dim", "=", "0", ")", "\n", "\n", "for", "keypoint_results_per_image", ",", "heatmap_results_per_image", ",", "instances_per_image", "in", "zip", "(", "\n", "keypoint_results", ",", "heatmap_results", ",", "pred_instances", "\n", ")", ":", "\n", "# keypoint_results_per_image is (num instances)x(num keypoints)x(x, y, score)", "\n", "# heatmap_results_per_image is (num instances)x(num keypoints)x(side)x(side)", "\n", "        ", "instances_per_image", ".", "pred_keypoints", "=", "keypoint_results_per_image", "\n", "instances_per_image", ".", "pred_keypoint_heatmaps", "=", "heatmap_results_per_image", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.box_head.FastRCNNConvFCHead.__init__": [[32, 80], ["torch.nn.Sequential.__init__", "enumerate", "enumerate", "detectron2.layers.Conv2d", "box_head.FastRCNNConvFCHead.add_module", "box_head.FastRCNNConvFCHead.conv_norm_relus.append", "detectron2.layers.Linear", "box_head.FastRCNNConvFCHead.add_module", "box_head.FastRCNNConvFCHead.add_module", "box_head.FastRCNNConvFCHead.fcs.append", "fvcore.c2_msra_fill", "fvcore.c2_xavier_fill", "len", "len", "box_head.FastRCNNConvFCHead.add_module", "int", "torch.nn.ReLU", "detectron2.layers.get_norm", "torch.nn.ReLU", "torch.nn.Flatten", "numpy.prod"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "input_shape", ":", "ShapeSpec", ",", "*", ",", "conv_dims", ":", "List", "[", "int", "]", ",", "fc_dims", ":", "List", "[", "int", "]", ",", "conv_norm", "=", "\"\"", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            input_shape (ShapeSpec): shape of the input feature.\n            conv_dims (list[int]): the output dimensions of the conv layers\n            fc_dims (list[int]): the output dimensions of the fc layers\n            conv_norm (str or callable): normalization for the conv layers.\n                See :func:`detectron2.layers.get_norm` for supported types.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "len", "(", "conv_dims", ")", "+", "len", "(", "fc_dims", ")", ">", "0", "\n", "\n", "self", ".", "_output_size", "=", "(", "input_shape", ".", "channels", ",", "input_shape", ".", "height", ",", "input_shape", ".", "width", ")", "\n", "\n", "self", ".", "conv_norm_relus", "=", "[", "]", "\n", "for", "k", ",", "conv_dim", "in", "enumerate", "(", "conv_dims", ")", ":", "\n", "            ", "conv", "=", "Conv2d", "(", "\n", "self", ".", "_output_size", "[", "0", "]", ",", "\n", "conv_dim", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "not", "conv_norm", ",", "\n", "norm", "=", "get_norm", "(", "conv_norm", ",", "conv_dim", ")", ",", "\n", "activation", "=", "nn", ".", "ReLU", "(", ")", ",", "\n", ")", "\n", "self", ".", "add_module", "(", "\"conv{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "conv", ")", "\n", "self", ".", "conv_norm_relus", ".", "append", "(", "conv", ")", "\n", "self", ".", "_output_size", "=", "(", "conv_dim", ",", "self", ".", "_output_size", "[", "1", "]", ",", "self", ".", "_output_size", "[", "2", "]", ")", "\n", "\n", "", "self", ".", "fcs", "=", "[", "]", "\n", "for", "k", ",", "fc_dim", "in", "enumerate", "(", "fc_dims", ")", ":", "\n", "            ", "if", "k", "==", "0", ":", "\n", "                ", "self", ".", "add_module", "(", "\"flatten\"", ",", "nn", ".", "Flatten", "(", ")", ")", "\n", "", "fc", "=", "Linear", "(", "int", "(", "np", ".", "prod", "(", "self", ".", "_output_size", ")", ")", ",", "fc_dim", ")", "\n", "self", ".", "add_module", "(", "\"fc{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "fc", ")", "\n", "self", ".", "add_module", "(", "\"fc_relu{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "nn", ".", "ReLU", "(", ")", ")", "\n", "self", ".", "fcs", ".", "append", "(", "fc", ")", "\n", "self", ".", "_output_size", "=", "fc_dim", "\n", "\n", "", "for", "layer", "in", "self", ".", "conv_norm_relus", ":", "\n", "            ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "", "for", "layer", "in", "self", ".", "fcs", ":", "\n", "            ", "weight_init", ".", "c2_xavier_fill", "(", "layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.box_head.FastRCNNConvFCHead.from_config": [[81, 92], ["None"], "methods", ["None"], ["", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "num_conv", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NUM_CONV", "\n", "conv_dim", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "CONV_DIM", "\n", "num_fc", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NUM_FC", "\n", "fc_dim", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "FC_DIM", "\n", "return", "{", "\n", "\"input_shape\"", ":", "input_shape", ",", "\n", "\"conv_dims\"", ":", "[", "conv_dim", "]", "*", "num_conv", ",", "\n", "\"fc_dims\"", ":", "[", "fc_dim", "]", "*", "num_fc", ",", "\n", "\"conv_norm\"", ":", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NORM", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.box_head.FastRCNNConvFCHead.forward": [[94, 98], ["layer"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "layer", "in", "self", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.box_head.FastRCNNConvFCHead.output_shape": [[99, 111], ["isinstance", "detectron2.layers.ShapeSpec", "detectron2.layers.ShapeSpec"], "methods", ["None"], ["", "@", "property", "\n", "@", "torch", ".", "jit", ".", "unused", "\n", "def", "output_shape", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            ShapeSpec: the output feature shape\n        \"\"\"", "\n", "o", "=", "self", ".", "_output_size", "\n", "if", "isinstance", "(", "o", ",", "int", ")", ":", "\n", "            ", "return", "ShapeSpec", "(", "channels", "=", "o", ")", "\n", "", "else", ":", "\n", "            ", "return", "ShapeSpec", "(", "channels", "=", "o", "[", "0", "]", ",", "height", "=", "o", "[", "1", "]", ",", "width", "=", "o", "[", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.box_head.build_box_head": [[113, 119], ["ROI_BOX_HEAD_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "", "", "def", "build_box_head", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build a box head defined by `cfg.MODEL.ROI_BOX_HEAD.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NAME", "\n", "return", "ROI_BOX_HEAD_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.cascade_rcnn._ScaleGradient.forward": [[21, 25], ["None"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "input", ",", "scale", ")", ":", "\n", "        ", "ctx", ".", "scale", "=", "scale", "\n", "return", "input", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.cascade_rcnn._ScaleGradient.backward": [[26, 29], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "return", "grad_output", "*", "ctx", ".", "scale", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.cascade_rcnn.CascadeROIHeads.__init__": [[37, 79], ["len", "torch.nn.ModuleList", "torch.nn.ModuleList", "roi_heads.StandardROIHeads.__init__", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "*", ",", "\n", "box_in_features", ":", "List", "[", "str", "]", ",", "\n", "box_pooler", ":", "ROIPooler", ",", "\n", "box_heads", ":", "List", "[", "nn", ".", "Module", "]", ",", "\n", "box_predictors", ":", "List", "[", "nn", ".", "Module", "]", ",", "\n", "proposal_matchers", ":", "List", "[", "Matcher", "]", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            box_pooler (ROIPooler): pooler that extracts region features from given boxes\n            box_heads (list[nn.Module]): box head for each cascade stage\n            box_predictors (list[nn.Module]): box predictor for each cascade stage\n            proposal_matchers (list[Matcher]): matcher with different IoU thresholds to\n                match boxes with ground truth for each stage. The first matcher matches\n                RPN proposals with ground truth, the other matchers use boxes predicted\n                by the previous stage as proposals and match them with ground truth.\n        \"\"\"", "\n", "assert", "\"proposal_matcher\"", "not", "in", "kwargs", ",", "(", "\n", "\"CascadeROIHeads takes 'proposal_matchers=' for each stage instead \"", "\n", "\"of one 'proposal_matcher='.\"", "\n", ")", "\n", "# The first matcher matches RPN proposals with ground truth, done in the base class", "\n", "kwargs", "[", "\"proposal_matcher\"", "]", "=", "proposal_matchers", "[", "0", "]", "\n", "num_stages", "=", "self", ".", "num_cascade_stages", "=", "len", "(", "box_heads", ")", "\n", "box_heads", "=", "nn", ".", "ModuleList", "(", "box_heads", ")", "\n", "box_predictors", "=", "nn", ".", "ModuleList", "(", "box_predictors", ")", "\n", "assert", "len", "(", "box_predictors", ")", "==", "num_stages", ",", "f\"{len(box_predictors)} != {num_stages}!\"", "\n", "assert", "len", "(", "proposal_matchers", ")", "==", "num_stages", ",", "f\"{len(proposal_matchers)} != {num_stages}!\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "box_in_features", "=", "box_in_features", ",", "\n", "box_pooler", "=", "box_pooler", ",", "\n", "box_head", "=", "box_heads", ",", "\n", "box_predictor", "=", "box_predictors", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "self", ".", "proposal_matchers", "=", "proposal_matchers", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.cascade_rcnn.CascadeROIHeads.from_config": [[80, 85], ["super().from_config", "super().from_config.pop"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3PlusHead.from_config"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "ret", "=", "super", "(", ")", ".", "from_config", "(", "cfg", ",", "input_shape", ")", "\n", "ret", ".", "pop", "(", "\"proposal_matcher\"", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.cascade_rcnn.CascadeROIHeads._init_box_head": [[86, 135], ["tuple", "poolers.ROIPooler", "detectron2.layers.ShapeSpec", "zip", "len", "len", "len", "box_head.build_box_head.build_box_head", "box_heads.append", "box_predictors.append", "proposal_matchers.append", "set", "fast_rcnn.FastRCNNOutputLayers", "matcher.Matcher", "box_regression.Box2BoxTransform"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.box_head.build_box_head", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["", "@", "classmethod", "\n", "def", "_init_box_head", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "# fmt: off", "\n", "        ", "in_features", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IN_FEATURES", "\n", "pooler_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_RESOLUTION", "\n", "pooler_scales", "=", "tuple", "(", "1.0", "/", "input_shape", "[", "k", "]", ".", "stride", "for", "k", "in", "in_features", ")", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "pooler_type", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_TYPE", "\n", "cascade_bbox_reg_weights", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_CASCADE_HEAD", ".", "BBOX_REG_WEIGHTS", "\n", "cascade_ious", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_CASCADE_HEAD", ".", "IOUS", "\n", "assert", "len", "(", "cascade_bbox_reg_weights", ")", "==", "len", "(", "cascade_ious", ")", "\n", "assert", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "CLS_AGNOSTIC_BBOX_REG", ",", "\"CascadeROIHeads only support class-agnostic regression now!\"", "\n", "assert", "cascade_ious", "[", "0", "]", "==", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IOU_THRESHOLDS", "[", "0", "]", "\n", "# fmt: on", "\n", "\n", "in_channels", "=", "[", "input_shape", "[", "f", "]", ".", "channels", "for", "f", "in", "in_features", "]", "\n", "# Check all channel counts are equal", "\n", "assert", "len", "(", "set", "(", "in_channels", ")", ")", "==", "1", ",", "in_channels", "\n", "in_channels", "=", "in_channels", "[", "0", "]", "\n", "\n", "box_pooler", "=", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "pooler_type", ",", "\n", ")", "\n", "pooled_shape", "=", "ShapeSpec", "(", "\n", "channels", "=", "in_channels", ",", "width", "=", "pooler_resolution", ",", "height", "=", "pooler_resolution", "\n", ")", "\n", "\n", "box_heads", ",", "box_predictors", ",", "proposal_matchers", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "match_iou", ",", "bbox_reg_weights", "in", "zip", "(", "cascade_ious", ",", "cascade_bbox_reg_weights", ")", ":", "\n", "            ", "box_head", "=", "build_box_head", "(", "cfg", ",", "pooled_shape", ")", "\n", "box_heads", ".", "append", "(", "box_head", ")", "\n", "box_predictors", ".", "append", "(", "\n", "FastRCNNOutputLayers", "(", "\n", "cfg", ",", "\n", "box_head", ".", "output_shape", ",", "\n", "box2box_transform", "=", "Box2BoxTransform", "(", "weights", "=", "bbox_reg_weights", ")", ",", "\n", ")", "\n", ")", "\n", "proposal_matchers", ".", "append", "(", "Matcher", "(", "[", "match_iou", "]", ",", "[", "0", ",", "1", "]", ",", "allow_low_quality_matches", "=", "False", ")", ")", "\n", "", "return", "{", "\n", "\"box_in_features\"", ":", "in_features", ",", "\n", "\"box_pooler\"", ":", "box_pooler", ",", "\n", "\"box_heads\"", ":", "box_heads", ",", "\n", "\"box_predictors\"", ":", "box_predictors", ",", "\n", "\"proposal_matchers\"", ":", "proposal_matchers", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.cascade_rcnn.CascadeROIHeads.forward": [[137, 152], ["cascade_rcnn.CascadeROIHeads.label_and_sample_proposals", "cascade_rcnn.CascadeROIHeads._forward_box", "cascade_rcnn.CascadeROIHeads.update", "cascade_rcnn.CascadeROIHeads.update", "cascade_rcnn.CascadeROIHeads._forward_box", "cascade_rcnn.CascadeROIHeads.forward_with_given_boxes", "cascade_rcnn.CascadeROIHeads._forward_mask", "cascade_rcnn.CascadeROIHeads._forward_keypoint"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.ROIHeads.label_and_sample_proposals", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.cascade_rcnn.CascadeROIHeads._forward_box", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.cascade_rcnn.CascadeROIHeads._forward_box", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_head.DensePoseROIHeads.forward_with_given_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.roi_heads.PointRendROIHeads._forward_mask", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.StandardROIHeads._forward_keypoint"], ["", "def", "forward", "(", "self", ",", "images", ",", "features", ",", "proposals", ",", "targets", "=", "None", ")", ":", "\n", "        ", "del", "images", "\n", "if", "self", ".", "training", ":", "\n", "            ", "proposals", "=", "self", ".", "label_and_sample_proposals", "(", "proposals", ",", "targets", ")", "\n", "\n", "", "if", "self", ".", "training", ":", "\n", "# Need targets to box head", "\n", "            ", "losses", "=", "self", ".", "_forward_box", "(", "features", ",", "proposals", ",", "targets", ")", "\n", "losses", ".", "update", "(", "self", ".", "_forward_mask", "(", "features", ",", "proposals", ")", ")", "\n", "losses", ".", "update", "(", "self", ".", "_forward_keypoint", "(", "features", ",", "proposals", ")", ")", "\n", "return", "proposals", ",", "losses", "\n", "", "else", ":", "\n", "            ", "pred_instances", "=", "self", ".", "_forward_box", "(", "features", ",", "proposals", ")", "\n", "pred_instances", "=", "self", ".", "forward_with_given_boxes", "(", "features", ",", "pred_instances", ")", "\n", "return", "pred_instances", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.cascade_rcnn.CascadeROIHeads._forward_box": [[153, 207], ["range", "cascade_rcnn.CascadeROIHeads._run_stage", "cascade_rcnn.CascadeROIHeads.box_predictor[].predict_boxes", "head_outputs.append", "detectron2.utils.events.get_event_storage", "enumerate", "predictor.predict_boxes", "fast_rcnn.fast_rcnn_inference", "cascade_rcnn.CascadeROIHeads._create_proposals_from_boxes", "losses.update", "h[].predict_probs", "cascade_rcnn.CascadeROIHeads._match_and_label_boxes", "detectron2.utils.events.get_event_storage.name_scope", "predictor.losses", "sum", "zip", "list", "predictor.losses.items"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.cascade_rcnn.CascadeROIHeads._run_stage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.get_event_storage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.fast_rcnn_inference", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.cascade_rcnn.CascadeROIHeads._create_proposals_from_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_probs", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.cascade_rcnn.CascadeROIHeads._match_and_label_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.name_scope", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3Head.losses"], ["", "", "def", "_forward_box", "(", "self", ",", "features", ",", "proposals", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            features, targets: the same as in\n                Same as in :meth:`ROIHeads.forward`.\n            proposals (list[Instances]): the per-image object proposals with\n                their matching ground truth.\n                Each has fields \"proposal_boxes\", and \"objectness_logits\",\n                \"gt_classes\", \"gt_boxes\".\n        \"\"\"", "\n", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "box_in_features", "]", "\n", "head_outputs", "=", "[", "]", "# (predictor, predictions, proposals)", "\n", "prev_pred_boxes", "=", "None", "\n", "image_sizes", "=", "[", "x", ".", "image_size", "for", "x", "in", "proposals", "]", "\n", "for", "k", "in", "range", "(", "self", ".", "num_cascade_stages", ")", ":", "\n", "            ", "if", "k", ">", "0", ":", "\n", "# The output boxes of the previous stage are used to create the input", "\n", "# proposals of the next stage.", "\n", "                ", "proposals", "=", "self", ".", "_create_proposals_from_boxes", "(", "prev_pred_boxes", ",", "image_sizes", ")", "\n", "if", "self", ".", "training", ":", "\n", "                    ", "proposals", "=", "self", ".", "_match_and_label_boxes", "(", "proposals", ",", "k", ",", "targets", ")", "\n", "", "", "predictions", "=", "self", ".", "_run_stage", "(", "features", ",", "proposals", ",", "k", ")", "\n", "prev_pred_boxes", "=", "self", ".", "box_predictor", "[", "k", "]", ".", "predict_boxes", "(", "predictions", ",", "proposals", ")", "\n", "head_outputs", ".", "append", "(", "(", "self", ".", "box_predictor", "[", "k", "]", ",", "predictions", ",", "proposals", ")", ")", "\n", "\n", "", "if", "self", ".", "training", ":", "\n", "            ", "losses", "=", "{", "}", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "for", "stage", ",", "(", "predictor", ",", "predictions", ",", "proposals", ")", "in", "enumerate", "(", "head_outputs", ")", ":", "\n", "                ", "with", "storage", ".", "name_scope", "(", "\"stage{}\"", ".", "format", "(", "stage", ")", ")", ":", "\n", "                    ", "stage_losses", "=", "predictor", ".", "losses", "(", "predictions", ",", "proposals", ")", "\n", "", "losses", ".", "update", "(", "{", "k", "+", "\"_stage{}\"", ".", "format", "(", "stage", ")", ":", "v", "for", "k", ",", "v", "in", "stage_losses", ".", "items", "(", ")", "}", ")", "\n", "", "return", "losses", "\n", "", "else", ":", "\n", "# Each is a list[Tensor] of length #image. Each tensor is Ri x (K+1)", "\n", "            ", "scores_per_stage", "=", "[", "h", "[", "0", "]", ".", "predict_probs", "(", "h", "[", "1", "]", ",", "h", "[", "2", "]", ")", "for", "h", "in", "head_outputs", "]", "\n", "\n", "# Average the scores across heads", "\n", "scores", "=", "[", "\n", "sum", "(", "list", "(", "scores_per_image", ")", ")", "*", "(", "1.0", "/", "self", ".", "num_cascade_stages", ")", "\n", "for", "scores_per_image", "in", "zip", "(", "*", "scores_per_stage", ")", "\n", "]", "\n", "# Use the boxes of the last head", "\n", "predictor", ",", "predictions", ",", "proposals", "=", "head_outputs", "[", "-", "1", "]", "\n", "boxes", "=", "predictor", ".", "predict_boxes", "(", "predictions", ",", "proposals", ")", "\n", "pred_instances", ",", "_", "=", "fast_rcnn_inference", "(", "\n", "boxes", ",", "\n", "scores", ",", "\n", "image_sizes", ",", "\n", "predictor", ".", "test_score_thresh", ",", "\n", "predictor", ".", "test_nms_thresh", ",", "\n", "predictor", ".", "test_topk_per_image", ",", "\n", ")", "\n", "return", "pred_instances", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.cascade_rcnn.CascadeROIHeads._match_and_label_boxes": [[208, 257], ["torch.no_grad", "zip", "detectron2.utils.events.get_event_storage", "detectron2.utils.events.get_event_storage.put_scalar", "detectron2.utils.events.get_event_storage.put_scalar", "detectron2.structures.pairwise_iou", "num_fg_samples.append", "num_bg_samples.append", "len", "detectron2.structures.Boxes", "sum", "len", "sum", "len", "torch.zeros_like", "targets_per_image.gt_boxes.tensor.new_zeros", "proposal_labels.numel", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.get_event_storage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.pairwise_iou"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_match_and_label_boxes", "(", "self", ",", "proposals", ",", "stage", ",", "targets", ")", ":", "\n", "        ", "\"\"\"\n        Match proposals with groundtruth using the matcher at the given stage.\n        Label the proposals as foreground or background based on the match.\n\n        Args:\n            proposals (list[Instances]): One Instances for each image, with\n                the field \"proposal_boxes\".\n            stage (int): the current stage\n            targets (list[Instances]): the ground truth instances\n\n        Returns:\n            list[Instances]: the same proposals, but with fields \"gt_classes\" and \"gt_boxes\"\n        \"\"\"", "\n", "num_fg_samples", ",", "num_bg_samples", "=", "[", "]", ",", "[", "]", "\n", "for", "proposals_per_image", ",", "targets_per_image", "in", "zip", "(", "proposals", ",", "targets", ")", ":", "\n", "            ", "match_quality_matrix", "=", "pairwise_iou", "(", "\n", "targets_per_image", ".", "gt_boxes", ",", "proposals_per_image", ".", "proposal_boxes", "\n", ")", "\n", "# proposal_labels are 0 or 1", "\n", "matched_idxs", ",", "proposal_labels", "=", "self", ".", "proposal_matchers", "[", "stage", "]", "(", "match_quality_matrix", ")", "\n", "if", "len", "(", "targets_per_image", ")", ">", "0", ":", "\n", "                ", "gt_classes", "=", "targets_per_image", ".", "gt_classes", "[", "matched_idxs", "]", "\n", "# Label unmatched proposals (0 label from matcher) as background (label=num_classes)", "\n", "gt_classes", "[", "proposal_labels", "==", "0", "]", "=", "self", ".", "num_classes", "\n", "gt_boxes", "=", "targets_per_image", ".", "gt_boxes", "[", "matched_idxs", "]", "\n", "", "else", ":", "\n", "                ", "gt_classes", "=", "torch", ".", "zeros_like", "(", "matched_idxs", ")", "+", "self", ".", "num_classes", "\n", "gt_boxes", "=", "Boxes", "(", "\n", "targets_per_image", ".", "gt_boxes", ".", "tensor", ".", "new_zeros", "(", "(", "len", "(", "proposals_per_image", ")", ",", "4", ")", ")", "\n", ")", "\n", "", "proposals_per_image", ".", "gt_classes", "=", "gt_classes", "\n", "proposals_per_image", ".", "gt_boxes", "=", "gt_boxes", "\n", "\n", "num_fg_samples", ".", "append", "(", "(", "proposal_labels", "==", "1", ")", ".", "sum", "(", ")", ".", "item", "(", ")", ")", "\n", "num_bg_samples", ".", "append", "(", "proposal_labels", ".", "numel", "(", ")", "-", "num_fg_samples", "[", "-", "1", "]", ")", "\n", "\n", "# Log the number of fg/bg samples in each stage", "\n", "", "storage", "=", "get_event_storage", "(", ")", "\n", "storage", ".", "put_scalar", "(", "\n", "\"stage{}/roi_head/num_fg_samples\"", ".", "format", "(", "stage", ")", ",", "\n", "sum", "(", "num_fg_samples", ")", "/", "len", "(", "num_fg_samples", ")", ",", "\n", ")", "\n", "storage", ".", "put_scalar", "(", "\n", "\"stage{}/roi_head/num_bg_samples\"", ".", "format", "(", "stage", ")", ",", "\n", "sum", "(", "num_bg_samples", ")", "/", "len", "(", "num_bg_samples", ")", ",", "\n", ")", "\n", "return", "proposals", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.cascade_rcnn.CascadeROIHeads._run_stage": [[258, 276], ["cascade_rcnn.CascadeROIHeads.box_pooler", "_ScaleGradient.apply"], "methods", ["None"], ["", "def", "_run_stage", "(", "self", ",", "features", ",", "proposals", ",", "stage", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            features (list[Tensor]): #lvl input features to ROIHeads\n            proposals (list[Instances]): #image Instances, with the field \"proposal_boxes\"\n            stage (int): the current stage\n\n        Returns:\n            Same output as `FastRCNNOutputLayers.forward()`.\n        \"\"\"", "\n", "box_features", "=", "self", ".", "box_pooler", "(", "features", ",", "[", "x", ".", "proposal_boxes", "for", "x", "in", "proposals", "]", ")", "\n", "# The original implementation averages the losses among heads,", "\n", "# but scale up the parameter gradients of the heads.", "\n", "# This is equivalent to adding the losses among heads,", "\n", "# but scale down the gradients on features.", "\n", "box_features", "=", "_ScaleGradient", ".", "apply", "(", "box_features", ",", "1.0", "/", "self", ".", "num_cascade_stages", ")", "\n", "box_features", "=", "self", ".", "box_head", "[", "stage", "]", "(", "box_features", ")", "\n", "return", "self", ".", "box_predictor", "[", "stage", "]", "(", "box_features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.cascade_rcnn.CascadeROIHeads._create_proposals_from_boxes": [[277, 299], ["zip", "detectron2.structures.Boxes", "boxes_per_image.clip", "detectron2.structures.Instances", "proposals.append", "b.detach", "boxes_per_image.nonempty"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.nonempty"], ["", "def", "_create_proposals_from_boxes", "(", "self", ",", "boxes", ",", "image_sizes", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            boxes (list[Tensor]): per-image predicted boxes, each of shape Ri x 4\n            image_sizes (list[tuple]): list of image shapes in (h, w)\n\n        Returns:\n            list[Instances]: per-image proposals with the given boxes.\n        \"\"\"", "\n", "# Just like RPN, the proposals should not have gradients", "\n", "boxes", "=", "[", "Boxes", "(", "b", ".", "detach", "(", ")", ")", "for", "b", "in", "boxes", "]", "\n", "proposals", "=", "[", "]", "\n", "for", "boxes_per_image", ",", "image_size", "in", "zip", "(", "boxes", ",", "image_sizes", ")", ":", "\n", "            ", "boxes_per_image", ".", "clip", "(", "image_size", ")", "\n", "if", "self", ".", "training", ":", "\n", "# do not filter empty boxes at inference time,", "\n", "# because the scores from each stage need to be aligned and added later", "\n", "                ", "boxes_per_image", "=", "boxes_per_image", "[", "boxes_per_image", ".", "nonempty", "(", ")", "]", "\n", "", "prop", "=", "Instances", "(", "image_size", ")", "\n", "prop", ".", "proposal_boxes", "=", "boxes_per_image", "\n", "proposals", ".", "append", "(", "prop", ")", "\n", "", "return", "proposals", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.v1convx.DensePoseV1ConvXHead.__init__": [[20, 43], ["torch.nn.Module.__init__", "range", "utils.initialize_module_params", "detectron2.layers.Conv2d", "v1convx.DensePoseV1ConvXHead._get_layer_name", "v1convx.DensePoseV1ConvXHead.add_module"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.utils.initialize_module_params", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.deeplab.DensePoseDeepLabHead._get_layer_name"], ["def", "__init__", "(", "self", ",", "cfg", ":", "CfgNode", ",", "input_channels", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Initialize DensePose fully convolutional head\n\n        Args:\n            cfg (CfgNode): configuration options\n            input_channels (int): number of input channels\n        \"\"\"", "\n", "super", "(", "DensePoseV1ConvXHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# fmt: off", "\n", "hidden_dim", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "CONV_HEAD_DIM", "\n", "kernel_size", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "CONV_HEAD_KERNEL", "\n", "self", ".", "n_stacked_convs", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "NUM_STACKED_CONVS", "\n", "# fmt: on", "\n", "pad_size", "=", "kernel_size", "//", "2", "\n", "n_channels", "=", "input_channels", "\n", "for", "i", "in", "range", "(", "self", ".", "n_stacked_convs", ")", ":", "\n", "            ", "layer", "=", "Conv2d", "(", "n_channels", ",", "hidden_dim", ",", "kernel_size", ",", "stride", "=", "1", ",", "padding", "=", "pad_size", ")", "\n", "layer_name", "=", "self", ".", "_get_layer_name", "(", "i", ")", "\n", "self", ".", "add_module", "(", "layer_name", ",", "layer", ")", "\n", "n_channels", "=", "hidden_dim", "\n", "", "self", ".", "n_out_channels", "=", "n_channels", "\n", "initialize_module_params", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.v1convx.DensePoseV1ConvXHead.forward": [[44, 61], ["range", "v1convx.DensePoseV1ConvXHead._get_layer_name", "torch.nn.functional.relu", "getattr"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.deeplab.DensePoseDeepLabHead._get_layer_name"], ["", "def", "forward", "(", "self", ",", "features", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Apply DensePose fully convolutional head to the input features\n\n        Args:\n            features (tensor): input features\n        Result:\n            A tensor of DensePose head outputs\n        \"\"\"", "\n", "x", "=", "features", "\n", "output", "=", "x", "\n", "for", "i", "in", "range", "(", "self", ".", "n_stacked_convs", ")", ":", "\n", "            ", "layer_name", "=", "self", ".", "_get_layer_name", "(", "i", ")", "\n", "x", "=", "getattr", "(", "self", ",", "layer_name", ")", "(", "x", ")", "\n", "x", "=", "F", ".", "relu", "(", "x", ")", "\n", "output", "=", "x", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.v1convx.DensePoseV1ConvXHead._get_layer_name": [[62, 65], ["None"], "methods", ["None"], ["", "def", "_get_layer_name", "(", "self", ",", "i", ":", "int", ")", ":", "\n", "        ", "layer_name", "=", "\"body_conv_fcn{}\"", ".", "format", "(", "i", "+", "1", ")", "\n", "return", "layer_name", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.deeplab.DensePoseDeepLabHead.__init__": [[22, 58], ["torch.nn.Module.__init__", "deeplab.ASPP", "deeplab.DensePoseDeepLabHead.add_module", "range", "deeplab.NONLocalBlock2D", "deeplab.DensePoseDeepLabHead.add_module", "detectron2.layers.Conv2d", "fvcore.c2_msra_fill", "deeplab.DensePoseDeepLabHead._get_layer_name", "deeplab.DensePoseDeepLabHead.add_module", "torch.nn.GroupNorm"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.deeplab.DensePoseDeepLabHead._get_layer_name"], ["def", "__init__", "(", "self", ",", "cfg", ":", "CfgNode", ",", "input_channels", ":", "int", ")", ":", "\n", "        ", "super", "(", "DensePoseDeepLabHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# fmt: off", "\n", "hidden_dim", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "CONV_HEAD_DIM", "\n", "kernel_size", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "CONV_HEAD_KERNEL", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "DEEPLAB", ".", "NORM", "\n", "self", ".", "n_stacked_convs", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "NUM_STACKED_CONVS", "\n", "self", ".", "use_nonlocal", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "DEEPLAB", ".", "NONLOCAL_ON", "\n", "# fmt: on", "\n", "pad_size", "=", "kernel_size", "//", "2", "\n", "n_channels", "=", "input_channels", "\n", "\n", "self", ".", "ASPP", "=", "ASPP", "(", "input_channels", ",", "[", "6", ",", "12", ",", "56", "]", ",", "n_channels", ")", "# 6, 12, 56", "\n", "self", ".", "add_module", "(", "\"ASPP\"", ",", "self", ".", "ASPP", ")", "\n", "\n", "if", "self", ".", "use_nonlocal", ":", "\n", "            ", "self", ".", "NLBlock", "=", "NONLocalBlock2D", "(", "input_channels", ",", "bn_layer", "=", "True", ")", "\n", "self", ".", "add_module", "(", "\"NLBlock\"", ",", "self", ".", "NLBlock", ")", "\n", "# weight_init.c2_msra_fill(self.ASPP)", "\n", "\n", "", "for", "i", "in", "range", "(", "self", ".", "n_stacked_convs", ")", ":", "\n", "            ", "norm_module", "=", "nn", ".", "GroupNorm", "(", "32", ",", "hidden_dim", ")", "if", "norm", "==", "\"GN\"", "else", "None", "\n", "layer", "=", "Conv2d", "(", "\n", "n_channels", ",", "\n", "hidden_dim", ",", "\n", "kernel_size", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "pad_size", ",", "\n", "bias", "=", "not", "norm", ",", "\n", "norm", "=", "norm_module", ",", "\n", ")", "\n", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "n_channels", "=", "hidden_dim", "\n", "layer_name", "=", "self", ".", "_get_layer_name", "(", "i", ")", "\n", "self", ".", "add_module", "(", "layer_name", ",", "layer", ")", "\n", "", "self", ".", "n_out_channels", "=", "hidden_dim", "\n", "# initialize_module_params(self)", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.deeplab.DensePoseDeepLabHead.forward": [[60, 72], ["deeplab.DensePoseDeepLabHead.ASPP", "range", "deeplab.DensePoseDeepLabHead.NLBlock", "deeplab.DensePoseDeepLabHead._get_layer_name", "torch.nn.functional.relu", "getattr"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.deeplab.DensePoseDeepLabHead._get_layer_name"], ["", "def", "forward", "(", "self", ",", "features", ")", ":", "\n", "        ", "x0", "=", "features", "\n", "x", "=", "self", ".", "ASPP", "(", "x0", ")", "\n", "if", "self", ".", "use_nonlocal", ":", "\n", "            ", "x", "=", "self", ".", "NLBlock", "(", "x", ")", "\n", "", "output", "=", "x", "\n", "for", "i", "in", "range", "(", "self", ".", "n_stacked_convs", ")", ":", "\n", "            ", "layer_name", "=", "self", ".", "_get_layer_name", "(", "i", ")", "\n", "x", "=", "getattr", "(", "self", ",", "layer_name", ")", "(", "x", ")", "\n", "x", "=", "F", ".", "relu", "(", "x", ")", "\n", "output", "=", "x", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.deeplab.DensePoseDeepLabHead._get_layer_name": [[73, 76], ["None"], "methods", ["None"], ["", "def", "_get_layer_name", "(", "self", ",", "i", ":", "int", ")", ":", "\n", "        ", "layer_name", "=", "\"body_conv_fcn{}\"", ".", "format", "(", "i", "+", "1", ")", "\n", "return", "layer_name", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.deeplab.ASPPConv.__init__": [[82, 91], ["torch.nn.Sequential.__init__", "torch.nn.Conv2d", "torch.nn.GroupNorm", "torch.nn.ReLU"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "dilation", ")", ":", "\n", "        ", "modules", "=", "[", "\n", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "out_channels", ",", "3", ",", "padding", "=", "dilation", ",", "dilation", "=", "dilation", ",", "bias", "=", "False", "\n", ")", ",", "\n", "nn", ".", "GroupNorm", "(", "32", ",", "out_channels", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "]", "\n", "super", "(", "ASPPConv", ",", "self", ")", ".", "__init__", "(", "*", "modules", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.deeplab.ASPPPooling.__init__": [[94, 100], ["torch.nn.Sequential.__init__", "torch.nn.AdaptiveAvgPool2d", "torch.nn.Conv2d", "torch.nn.GroupNorm", "torch.nn.ReLU"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ")", ":", "\n", "        ", "super", "(", "ASPPPooling", ",", "self", ")", ".", "__init__", "(", "\n", "nn", ".", "AdaptiveAvgPool2d", "(", "1", ")", ",", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "1", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "GroupNorm", "(", "32", ",", "out_channels", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.deeplab.ASPPPooling.forward": [[102, 106], ["super().forward", "torch.nn.functional.interpolate"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.forward"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "size", "=", "x", ".", "shape", "[", "-", "2", ":", "]", "\n", "x", "=", "super", "(", "ASPPPooling", ",", "self", ")", ".", "forward", "(", "x", ")", "\n", "return", "F", ".", "interpolate", "(", "x", ",", "size", "=", "size", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.deeplab.ASPP.__init__": [[109, 132], ["torch.nn.Module.__init__", "modules.append", "tuple", "modules.append", "modules.append", "modules.append", "modules.append", "torch.nn.ModuleList", "torch.nn.Sequential", "torch.nn.Sequential", "deeplab.ASPPConv", "deeplab.ASPPConv", "deeplab.ASPPConv", "deeplab.ASPPPooling", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.GroupNorm", "torch.nn.ReLU"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "atrous_rates", ",", "out_channels", ")", ":", "\n", "        ", "super", "(", "ASPP", ",", "self", ")", ".", "__init__", "(", ")", "\n", "modules", "=", "[", "]", "\n", "modules", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "1", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "GroupNorm", "(", "32", ",", "out_channels", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", ")", "\n", ")", "\n", "\n", "rate1", ",", "rate2", ",", "rate3", "=", "tuple", "(", "atrous_rates", ")", "\n", "modules", ".", "append", "(", "ASPPConv", "(", "in_channels", ",", "out_channels", ",", "rate1", ")", ")", "\n", "modules", ".", "append", "(", "ASPPConv", "(", "in_channels", ",", "out_channels", ",", "rate2", ")", ")", "\n", "modules", ".", "append", "(", "ASPPConv", "(", "in_channels", ",", "out_channels", ",", "rate3", ")", ")", "\n", "modules", ".", "append", "(", "ASPPPooling", "(", "in_channels", ",", "out_channels", ")", ")", "\n", "\n", "self", ".", "convs", "=", "nn", ".", "ModuleList", "(", "modules", ")", "\n", "\n", "self", ".", "project", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "5", "*", "out_channels", ",", "out_channels", ",", "1", ",", "bias", "=", "False", ")", ",", "\n", "# nn.BatchNorm2d(out_channels),", "\n", "nn", ".", "ReLU", "(", ")", "\n", "# nn.Dropout(0.5)", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.deeplab.ASPP.forward": [[135, 141], ["torch.cat", "deeplab.ASPP.project", "torch.cat.append", "conv"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "res", "=", "[", "]", "\n", "for", "conv", "in", "self", ".", "convs", ":", "\n", "            ", "res", ".", "append", "(", "conv", "(", "x", ")", ")", "\n", "", "res", "=", "torch", ".", "cat", "(", "res", ",", "dim", "=", "1", ")", "\n", "return", "self", ".", "project", "(", "res", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.deeplab._NonLocalBlockND.__init__": [[147, 228], ["torch.nn.Module.__init__", "conv_nd", "conv_nd", "conv_nd", "torch.nn.MaxPool3d", "torch.nn.Sequential", "torch.nn.init.constant_", "torch.nn.init.constant_", "conv_nd", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.MaxPool2d", "torch.nn.MaxPool1d", "conv_nd", "bn"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "in_channels", ",", "inter_channels", "=", "None", ",", "dimension", "=", "3", ",", "sub_sample", "=", "True", ",", "bn_layer", "=", "True", "\n", ")", ":", "\n", "        ", "super", "(", "_NonLocalBlockND", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "dimension", "in", "[", "1", ",", "2", ",", "3", "]", "\n", "\n", "self", ".", "dimension", "=", "dimension", "\n", "self", ".", "sub_sample", "=", "sub_sample", "\n", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "inter_channels", "=", "inter_channels", "\n", "\n", "if", "self", ".", "inter_channels", "is", "None", ":", "\n", "            ", "self", ".", "inter_channels", "=", "in_channels", "//", "2", "\n", "if", "self", ".", "inter_channels", "==", "0", ":", "\n", "                ", "self", ".", "inter_channels", "=", "1", "\n", "\n", "", "", "if", "dimension", "==", "3", ":", "\n", "            ", "conv_nd", "=", "nn", ".", "Conv3d", "\n", "max_pool_layer", "=", "nn", ".", "MaxPool3d", "(", "kernel_size", "=", "(", "1", ",", "2", ",", "2", ")", ")", "\n", "bn", "=", "nn", ".", "GroupNorm", "# (32, hidden_dim) #nn.BatchNorm3d", "\n", "", "elif", "dimension", "==", "2", ":", "\n", "            ", "conv_nd", "=", "nn", ".", "Conv2d", "\n", "max_pool_layer", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "(", "2", ",", "2", ")", ")", "\n", "bn", "=", "nn", ".", "GroupNorm", "# (32, hidden_dim)nn.BatchNorm2d", "\n", "", "else", ":", "\n", "            ", "conv_nd", "=", "nn", ".", "Conv1d", "\n", "max_pool_layer", "=", "nn", ".", "MaxPool1d", "(", "kernel_size", "=", "2", ")", "\n", "bn", "=", "nn", ".", "GroupNorm", "# (32, hidden_dim)nn.BatchNorm1d", "\n", "\n", "", "self", ".", "g", "=", "conv_nd", "(", "\n", "in_channels", "=", "self", ".", "in_channels", ",", "\n", "out_channels", "=", "self", ".", "inter_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", ")", "\n", "\n", "if", "bn_layer", ":", "\n", "            ", "self", ".", "W", "=", "nn", ".", "Sequential", "(", "\n", "conv_nd", "(", "\n", "in_channels", "=", "self", ".", "inter_channels", ",", "\n", "out_channels", "=", "self", ".", "in_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", ")", ",", "\n", "bn", "(", "32", ",", "self", ".", "in_channels", ")", ",", "\n", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "W", "[", "1", "]", ".", "weight", ",", "0", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "W", "[", "1", "]", ".", "bias", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "W", "=", "conv_nd", "(", "\n", "in_channels", "=", "self", ".", "inter_channels", ",", "\n", "out_channels", "=", "self", ".", "in_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "W", ".", "weight", ",", "0", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "W", ".", "bias", ",", "0", ")", "\n", "\n", "", "self", ".", "theta", "=", "conv_nd", "(", "\n", "in_channels", "=", "self", ".", "in_channels", ",", "\n", "out_channels", "=", "self", ".", "inter_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", ")", "\n", "self", ".", "phi", "=", "conv_nd", "(", "\n", "in_channels", "=", "self", ".", "in_channels", ",", "\n", "out_channels", "=", "self", ".", "inter_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", ")", "\n", "\n", "if", "sub_sample", ":", "\n", "            ", "self", ".", "g", "=", "nn", ".", "Sequential", "(", "self", ".", "g", ",", "max_pool_layer", ")", "\n", "self", ".", "phi", "=", "nn", ".", "Sequential", "(", "self", ".", "phi", ",", "max_pool_layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.deeplab._NonLocalBlockND.forward": [[229, 253], ["x.size", "deeplab._NonLocalBlockND.g().view", "g_x.permute.permute.permute", "deeplab._NonLocalBlockND.theta().view", "theta_x.permute.permute.permute", "deeplab._NonLocalBlockND.phi().view", "torch.matmul", "torch.nn.functional.softmax", "torch.matmul", "y.view.view.permute().contiguous", "y.view.view.view", "deeplab._NonLocalBlockND.W", "deeplab._NonLocalBlockND.g", "deeplab._NonLocalBlockND.theta", "deeplab._NonLocalBlockND.phi", "y.view.view.permute", "x.size"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        :param x: (b, c, t, h, w)\n        :return:\n        \"\"\"", "\n", "\n", "batch_size", "=", "x", ".", "size", "(", "0", ")", "\n", "\n", "g_x", "=", "self", ".", "g", "(", "x", ")", ".", "view", "(", "batch_size", ",", "self", ".", "inter_channels", ",", "-", "1", ")", "\n", "g_x", "=", "g_x", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "\n", "theta_x", "=", "self", ".", "theta", "(", "x", ")", ".", "view", "(", "batch_size", ",", "self", ".", "inter_channels", ",", "-", "1", ")", "\n", "theta_x", "=", "theta_x", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "phi_x", "=", "self", ".", "phi", "(", "x", ")", ".", "view", "(", "batch_size", ",", "self", ".", "inter_channels", ",", "-", "1", ")", "\n", "f", "=", "torch", ".", "matmul", "(", "theta_x", ",", "phi_x", ")", "\n", "f_div_C", "=", "F", ".", "softmax", "(", "f", ",", "dim", "=", "-", "1", ")", "\n", "\n", "y", "=", "torch", ".", "matmul", "(", "f_div_C", ",", "g_x", ")", "\n", "y", "=", "y", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "y", "=", "y", ".", "view", "(", "batch_size", ",", "self", ".", "inter_channels", ",", "*", "x", ".", "size", "(", ")", "[", "2", ":", "]", ")", "\n", "W_y", "=", "self", ".", "W", "(", "y", ")", "\n", "z", "=", "W_y", "+", "x", "\n", "\n", "return", "z", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.deeplab.NONLocalBlock2D.__init__": [[256, 263], ["deeplab._NonLocalBlockND.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "inter_channels", "=", "None", ",", "sub_sample", "=", "True", ",", "bn_layer", "=", "True", ")", ":", "\n", "        ", "super", "(", "NONLocalBlock2D", ",", "self", ")", ".", "__init__", "(", "\n", "in_channels", ",", "\n", "inter_channels", "=", "inter_channels", ",", "\n", "dimension", "=", "2", ",", "\n", "sub_sample", "=", "sub_sample", ",", "\n", "bn_layer", "=", "bn_layer", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_head.Decoder.__init__": [[32, 72], ["torch.Module.__init__", "detectron2.layers.Conv2d", "fvcore.c2_msra_fill", "max", "range", "roi_head.Decoder.scale_heads.append", "roi_head.Decoder.add_module", "input_shape.items", "input_shape.items", "int", "detectron2.layers.Conv2d", "fvcore.c2_msra_fill", "head_ops.append", "torch.Sequential", "torch.Sequential", "head_ops.append", "numpy.log2", "numpy.log2", "detectron2.layers.get_norm", "torch.Upsample", "torch.Upsample"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "Dict", "[", "str", ",", "ShapeSpec", "]", ",", "in_features", ")", ":", "\n", "        ", "super", "(", "Decoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "self", ".", "in_features", "=", "in_features", "\n", "feature_strides", "=", "{", "k", ":", "v", ".", "stride", "for", "k", ",", "v", "in", "input_shape", ".", "items", "(", ")", "}", "\n", "feature_channels", "=", "{", "k", ":", "v", ".", "channels", "for", "k", ",", "v", "in", "input_shape", ".", "items", "(", ")", "}", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "DECODER_NUM_CLASSES", "\n", "conv_dims", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "DECODER_CONV_DIMS", "\n", "self", ".", "common_stride", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "DECODER_COMMON_STRIDE", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "DECODER_NORM", "\n", "# fmt: on", "\n", "\n", "self", ".", "scale_heads", "=", "[", "]", "\n", "for", "in_feature", "in", "self", ".", "in_features", ":", "\n", "            ", "head_ops", "=", "[", "]", "\n", "head_length", "=", "max", "(", "\n", "1", ",", "int", "(", "np", ".", "log2", "(", "feature_strides", "[", "in_feature", "]", ")", "-", "np", ".", "log2", "(", "self", ".", "common_stride", ")", ")", "\n", ")", "\n", "for", "k", "in", "range", "(", "head_length", ")", ":", "\n", "                ", "conv", "=", "Conv2d", "(", "\n", "feature_channels", "[", "in_feature", "]", "if", "k", "==", "0", "else", "conv_dims", ",", "\n", "conv_dims", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "not", "norm", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "conv_dims", ")", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", "\n", "weight_init", ".", "c2_msra_fill", "(", "conv", ")", "\n", "head_ops", ".", "append", "(", "conv", ")", "\n", "if", "feature_strides", "[", "in_feature", "]", "!=", "self", ".", "common_stride", ":", "\n", "                    ", "head_ops", ".", "append", "(", "\n", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", "\n", ")", "\n", "", "", "self", ".", "scale_heads", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "head_ops", ")", ")", "\n", "self", ".", "add_module", "(", "in_feature", ",", "self", ".", "scale_heads", "[", "-", "1", "]", ")", "\n", "", "self", ".", "predictor", "=", "Conv2d", "(", "conv_dims", ",", "num_classes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "weight_init", ".", "c2_msra_fill", "(", "self", ".", "predictor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_head.Decoder.forward": [[73, 81], ["enumerate", "roi_head.Decoder.predictor"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "features", ":", "List", "[", "torch", ".", "Tensor", "]", ")", ":", "\n", "        ", "for", "i", ",", "_", "in", "enumerate", "(", "self", ".", "in_features", ")", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "                ", "x", "=", "self", ".", "scale_heads", "[", "i", "]", "(", "features", "[", "i", "]", ")", "\n", "", "else", ":", "\n", "                ", "x", "=", "x", "+", "self", ".", "scale_heads", "[", "i", "]", "(", "features", "[", "i", "]", ")", "\n", "", "", "x", "=", "self", ".", "predictor", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_head.DensePoseROIHeads.__init__": [[89, 92], ["detectron2.modeling.StandardROIHeads.__init__", "roi_head.DensePoseROIHeads._init_densepose_head"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_head.DensePoseROIHeads._init_densepose_head"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "cfg", ",", "input_shape", ")", "\n", "self", ".", "_init_densepose_head", "(", "cfg", ",", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_head.DensePoseROIHeads._init_densepose_head": [[93, 124], ["build_densepose_data_filter", "detectron2.modeling.poolers.ROIPooler", "build_densepose_head", "build_densepose_predictor", "build_densepose_losses", "tuple", "roi_head.Decoder"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.build.build_densepose_data_filter", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.build.build_densepose_head", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.build.build_densepose_predictor", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.build.build_densepose_losses"], ["", "def", "_init_densepose_head", "(", "self", ",", "cfg", ",", "input_shape", ")", ":", "\n", "# fmt: off", "\n", "        ", "self", ".", "densepose_on", "=", "cfg", ".", "MODEL", ".", "DENSEPOSE_ON", "\n", "if", "not", "self", ".", "densepose_on", ":", "\n", "            ", "return", "\n", "", "self", ".", "densepose_data_filter", "=", "build_densepose_data_filter", "(", "cfg", ")", "\n", "dp_pooler_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "POOLER_RESOLUTION", "\n", "dp_pooler_sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "dp_pooler_type", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "POOLER_TYPE", "\n", "self", ".", "use_decoder", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "DECODER_ON", "\n", "# fmt: on", "\n", "if", "self", ".", "use_decoder", ":", "\n", "            ", "dp_pooler_scales", "=", "(", "1.0", "/", "input_shape", "[", "self", ".", "in_features", "[", "0", "]", "]", ".", "stride", ",", ")", "\n", "", "else", ":", "\n", "            ", "dp_pooler_scales", "=", "tuple", "(", "1.0", "/", "input_shape", "[", "k", "]", ".", "stride", "for", "k", "in", "self", ".", "in_features", ")", "\n", "", "in_channels", "=", "[", "input_shape", "[", "f", "]", ".", "channels", "for", "f", "in", "self", ".", "in_features", "]", "[", "0", "]", "\n", "\n", "if", "self", ".", "use_decoder", ":", "\n", "            ", "self", ".", "decoder", "=", "Decoder", "(", "cfg", ",", "input_shape", ",", "self", ".", "in_features", ")", "\n", "\n", "", "self", ".", "densepose_pooler", "=", "ROIPooler", "(", "\n", "output_size", "=", "dp_pooler_resolution", ",", "\n", "scales", "=", "dp_pooler_scales", ",", "\n", "sampling_ratio", "=", "dp_pooler_sampling_ratio", ",", "\n", "pooler_type", "=", "dp_pooler_type", ",", "\n", ")", "\n", "self", ".", "densepose_head", "=", "build_densepose_head", "(", "cfg", ",", "in_channels", ")", "\n", "self", ".", "densepose_predictor", "=", "build_densepose_predictor", "(", "\n", "cfg", ",", "self", ".", "densepose_head", ".", "n_out_channels", "\n", ")", "\n", "self", ".", "densepose_losses", "=", "build_densepose_losses", "(", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_head.DensePoseROIHeads._forward_densepose": [[125, 176], ["detectron2.modeling.roi_heads.select_foreground_proposals", "roi_head.DensePoseROIHeads.densepose_data_filter", "roi_head.DensePoseROIHeads.densepose_pooler", "densepose_inference", "len", "roi_head.DensePoseROIHeads.densepose_pooler", "roi_head.DensePoseROIHeads.densepose_head", "roi_head.DensePoseROIHeads.densepose_predictor", "roi_head.DensePoseROIHeads.densepose_losses", "len", "roi_head.DensePoseROIHeads.densepose_head", "roi_head.DensePoseROIHeads.densepose_predictor", "roi_head.DensePoseROIHeads.decoder", "roi_head.DensePoseROIHeads.decoder"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.select_foreground_proposals", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.inference.densepose_inference"], ["", "def", "_forward_densepose", "(", "self", ",", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "instances", ":", "List", "[", "Instances", "]", ")", ":", "\n", "        ", "\"\"\"\n        Forward logic of the densepose prediction branch.\n\n        Args:\n            features (dict[str, Tensor]): input data as a mapping from feature\n                map name to tensor. Axis 0 represents the number of images `N` in\n                the input data; axes 1-3 are channels, height, and width, which may\n                vary between feature maps (e.g., if a feature pyramid is used).\n            instances (list[Instances]): length `N` list of `Instances`. The i-th\n                `Instances` contains instances for the i-th input image,\n                In training, they can be the proposals.\n                In inference, they can be the predicted boxes.\n\n        Returns:\n            In training, a dict of losses.\n            In inference, update `instances` with new fields \"densepose\" and return it.\n        \"\"\"", "\n", "if", "not", "self", ".", "densepose_on", ":", "\n", "            ", "return", "{", "}", "if", "self", ".", "training", "else", "instances", "\n", "\n", "", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", "\n", "if", "self", ".", "training", ":", "\n", "            ", "proposals", ",", "_", "=", "select_foreground_proposals", "(", "instances", ",", "self", ".", "num_classes", ")", "\n", "features", ",", "proposals", "=", "self", ".", "densepose_data_filter", "(", "features", ",", "proposals", ")", "\n", "if", "len", "(", "proposals", ")", ">", "0", ":", "\n", "                ", "proposal_boxes", "=", "[", "x", ".", "proposal_boxes", "for", "x", "in", "proposals", "]", "\n", "\n", "if", "self", ".", "use_decoder", ":", "\n", "                    ", "features", "=", "[", "self", ".", "decoder", "(", "features", ")", "]", "\n", "\n", "", "features_dp", "=", "self", ".", "densepose_pooler", "(", "features", ",", "proposal_boxes", ")", "\n", "densepose_head_outputs", "=", "self", ".", "densepose_head", "(", "features_dp", ")", "\n", "densepose_predictor_outputs", "=", "self", ".", "densepose_predictor", "(", "densepose_head_outputs", ")", "\n", "densepose_loss_dict", "=", "self", ".", "densepose_losses", "(", "proposals", ",", "densepose_predictor_outputs", ")", "\n", "return", "densepose_loss_dict", "\n", "", "", "else", ":", "\n", "            ", "pred_boxes", "=", "[", "x", ".", "pred_boxes", "for", "x", "in", "instances", "]", "\n", "\n", "if", "self", ".", "use_decoder", ":", "\n", "                ", "features", "=", "[", "self", ".", "decoder", "(", "features", ")", "]", "\n", "\n", "", "features_dp", "=", "self", ".", "densepose_pooler", "(", "features", ",", "pred_boxes", ")", "\n", "if", "len", "(", "features_dp", ")", ">", "0", ":", "\n", "                ", "densepose_head_outputs", "=", "self", ".", "densepose_head", "(", "features_dp", ")", "\n", "densepose_predictor_outputs", "=", "self", ".", "densepose_predictor", "(", "densepose_head_outputs", ")", "\n", "", "else", ":", "\n", "                ", "densepose_predictor_outputs", "=", "None", "\n", "\n", "", "densepose_inference", "(", "densepose_predictor_outputs", ",", "instances", ")", "\n", "return", "instances", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_head.DensePoseROIHeads.forward": [[177, 190], ["super().forward", "losses.update", "roi_head.DensePoseROIHeads._forward_densepose"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.forward", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_head.DensePoseROIHeads._forward_densepose"], ["", "", "def", "forward", "(", "\n", "self", ",", "\n", "images", ":", "ImageList", ",", "\n", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "\n", "proposals", ":", "List", "[", "Instances", "]", ",", "\n", "targets", ":", "Optional", "[", "List", "[", "Instances", "]", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "instances", ",", "losses", "=", "super", "(", ")", ".", "forward", "(", "images", ",", "features", ",", "proposals", ",", "targets", ")", "\n", "del", "targets", ",", "images", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "losses", ".", "update", "(", "self", ".", "_forward_densepose", "(", "features", ",", "instances", ")", ")", "\n", "", "return", "instances", ",", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_head.DensePoseROIHeads.forward_with_given_boxes": [[191, 215], ["super().forward_with_given_boxes", "roi_head.DensePoseROIHeads._forward_densepose"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_head.DensePoseROIHeads.forward_with_given_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_head.DensePoseROIHeads._forward_densepose"], ["", "def", "forward_with_given_boxes", "(", "\n", "self", ",", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "instances", ":", "List", "[", "Instances", "]", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Use the given boxes in `instances` to produce other (non-box) per-ROI outputs.\n\n        This is useful for downstream tasks where a box is known, but need to obtain\n        other attributes (outputs of other heads).\n        Test-time augmentation also uses this.\n\n        Args:\n            features: same as in `forward()`\n            instances (list[Instances]): instances to predict other outputs. Expect the keys\n                \"pred_boxes\" and \"pred_classes\" to exist.\n\n        Returns:\n            instances (list[Instances]):\n                the same `Instances` objects, with extra\n                fields such as `pred_masks` or `pred_keypoints`.\n        \"\"\"", "\n", "\n", "instances", "=", "super", "(", ")", ".", "forward_with_given_boxes", "(", "features", ",", "instances", ")", "\n", "instances", "=", "self", ".", "_forward_densepose", "(", "features", ",", "instances", ")", "\n", "return", "instances", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.build.build_backbone": [[20, 34], ["isinstance", "detectron2.layers.ShapeSpec", "BACKBONE_REGISTRY.get", "len"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["meta_arch", "=", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "\n", "model", "=", "META_ARCH_REGISTRY", ".", "get", "(", "meta_arch", ")", "(", "cfg", ")", "\n", "model", ".", "to", "(", "torch", ".", "device", "(", "cfg", ".", "MODEL", ".", "DEVICE", ")", ")", "\n", "return", "model", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.fpn.FPN.__init__": [[22, 105], ["backbone.Backbone.__init__", "isinstance", "bottom_up.output_shape", "fpn._assert_strides_are_log2_contiguous", "enumerate", "list", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "fvcore.c2_xavier_fill", "fvcore.c2_xavier_fill", "int", "fpn.FPN.add_module", "fpn.FPN.add_module", "lateral_convs.append", "output_convs.append", "range", "fpn.FPN._out_feature_strides.keys", "math.log2", "int", "math.log2"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.backbone.Backbone.output_shape", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.fpn._assert_strides_are_log2_contiguous", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm"], ["def", "__init__", "(", "\n", "self", ",", "bottom_up", ",", "in_features", ",", "out_channels", ",", "norm", "=", "\"\"", ",", "top_block", "=", "None", ",", "fuse_type", "=", "\"sum\"", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            bottom_up (Backbone): module representing the bottom up subnetwork.\n                Must be a subclass of :class:`Backbone`. The multi-scale feature\n                maps generated by the bottom up network, and listed in `in_features`,\n                are used to generate FPN levels.\n            in_features (list[str]): names of the input feature maps coming\n                from the backbone to which FPN is attached. For example, if the\n                backbone produces [\"res2\", \"res3\", \"res4\"], any *contiguous* sublist\n                of these may be used; order must be from high to low resolution.\n            out_channels (int): number of channels in the output feature maps.\n            norm (str): the normalization to use.\n            top_block (nn.Module or None): if provided, an extra operation will\n                be performed on the output of the last (smallest resolution)\n                FPN output, and the result will extend the result list. The top_block\n                further downsamples the feature map. It must have an attribute\n                \"num_levels\", meaning the number of extra FPN levels added by\n                this block, and \"in_feature\", which is a string representing\n                its input feature (e.g., p5).\n            fuse_type (str): types for fusing the top down features and the lateral\n                ones. It can be \"sum\" (default), which sums up element-wise; or \"avg\",\n                which takes the element-wise mean of the two.\n        \"\"\"", "\n", "super", "(", "FPN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "bottom_up", ",", "Backbone", ")", "\n", "assert", "in_features", ",", "in_features", "\n", "\n", "# Feature map strides and channels from the bottom up network (e.g. ResNet)", "\n", "input_shapes", "=", "bottom_up", ".", "output_shape", "(", ")", "\n", "strides", "=", "[", "input_shapes", "[", "f", "]", ".", "stride", "for", "f", "in", "in_features", "]", "\n", "in_channels_per_feature", "=", "[", "input_shapes", "[", "f", "]", ".", "channels", "for", "f", "in", "in_features", "]", "\n", "\n", "_assert_strides_are_log2_contiguous", "(", "strides", ")", "\n", "lateral_convs", "=", "[", "]", "\n", "output_convs", "=", "[", "]", "\n", "\n", "use_bias", "=", "norm", "==", "\"\"", "\n", "for", "idx", ",", "in_channels", "in", "enumerate", "(", "in_channels_per_feature", ")", ":", "\n", "            ", "lateral_norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", "\n", "output_norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", "\n", "\n", "lateral_conv", "=", "Conv2d", "(", "\n", "in_channels", ",", "out_channels", ",", "kernel_size", "=", "1", ",", "bias", "=", "use_bias", ",", "norm", "=", "lateral_norm", "\n", ")", "\n", "output_conv", "=", "Conv2d", "(", "\n", "out_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "use_bias", ",", "\n", "norm", "=", "output_norm", ",", "\n", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "lateral_conv", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "output_conv", ")", "\n", "stage", "=", "int", "(", "math", ".", "log2", "(", "strides", "[", "idx", "]", ")", ")", "\n", "self", ".", "add_module", "(", "\"fpn_lateral{}\"", ".", "format", "(", "stage", ")", ",", "lateral_conv", ")", "\n", "self", ".", "add_module", "(", "\"fpn_output{}\"", ".", "format", "(", "stage", ")", ",", "output_conv", ")", "\n", "\n", "lateral_convs", ".", "append", "(", "lateral_conv", ")", "\n", "output_convs", ".", "append", "(", "output_conv", ")", "\n", "# Place convs into top-down order (from low to high resolution)", "\n", "# to make the top-down computation in forward clearer.", "\n", "", "self", ".", "lateral_convs", "=", "lateral_convs", "[", ":", ":", "-", "1", "]", "\n", "self", ".", "output_convs", "=", "output_convs", "[", ":", ":", "-", "1", "]", "\n", "self", ".", "top_block", "=", "top_block", "\n", "self", ".", "in_features", "=", "in_features", "\n", "self", ".", "bottom_up", "=", "bottom_up", "\n", "# Return feature names are \"p<stage>\", like [\"p2\", \"p3\", ..., \"p6\"]", "\n", "self", ".", "_out_feature_strides", "=", "{", "\"p{}\"", ".", "format", "(", "int", "(", "math", ".", "log2", "(", "s", ")", ")", ")", ":", "s", "for", "s", "in", "strides", "}", "\n", "# top block output feature maps.", "\n", "if", "self", ".", "top_block", "is", "not", "None", ":", "\n", "            ", "for", "s", "in", "range", "(", "stage", ",", "stage", "+", "self", ".", "top_block", ".", "num_levels", ")", ":", "\n", "                ", "self", ".", "_out_feature_strides", "[", "\"p{}\"", ".", "format", "(", "s", "+", "1", ")", "]", "=", "2", "**", "(", "s", "+", "1", ")", "\n", "\n", "", "", "self", ".", "_out_features", "=", "list", "(", "self", ".", "_out_feature_strides", ".", "keys", "(", ")", ")", "\n", "self", ".", "_out_feature_channels", "=", "{", "k", ":", "out_channels", "for", "k", "in", "self", ".", "_out_features", "}", "\n", "self", ".", "_size_divisibility", "=", "strides", "[", "-", "1", "]", "\n", "assert", "fuse_type", "in", "{", "\"avg\"", ",", "\"sum\"", "}", "\n", "self", ".", "_fuse_type", "=", "fuse_type", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.fpn.FPN.size_divisibility": [[106, 109], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "size_divisibility", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_size_divisibility", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.fpn.FPN.forward": [[110, 146], ["fpn.FPN.bottom_up", "results.append", "zip", "dict", "torch.interpolate", "lateral_conv", "results.insert", "fpn.FPN.get", "results.extend", "len", "len", "zip", "output_conv", "fpn.FPN.top_block", "fpn.FPN._out_features.index"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input (dict[str->Tensor]): mapping feature map name (e.g., \"res5\") to\n                feature map tensor for each feature level in high to low resolution order.\n\n        Returns:\n            dict[str->Tensor]:\n                mapping from feature map name to FPN feature map tensor\n                in high to low resolution order. Returned feature names follow the FPN\n                paper convention: \"p<stage>\", where stage has stride = 2 ** stage e.g.,\n                [\"p2\", \"p3\", ..., \"p6\"].\n        \"\"\"", "\n", "# Reverse feature maps into top-down order (from low to high resolution)", "\n", "bottom_up_features", "=", "self", ".", "bottom_up", "(", "x", ")", "\n", "x", "=", "[", "bottom_up_features", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "[", ":", ":", "-", "1", "]", "]", "\n", "results", "=", "[", "]", "\n", "prev_features", "=", "self", ".", "lateral_convs", "[", "0", "]", "(", "x", "[", "0", "]", ")", "\n", "results", ".", "append", "(", "self", ".", "output_convs", "[", "0", "]", "(", "prev_features", ")", ")", "\n", "for", "features", ",", "lateral_conv", ",", "output_conv", "in", "zip", "(", "\n", "x", "[", "1", ":", "]", ",", "self", ".", "lateral_convs", "[", "1", ":", "]", ",", "self", ".", "output_convs", "[", "1", ":", "]", "\n", ")", ":", "\n", "            ", "top_down_features", "=", "F", ".", "interpolate", "(", "prev_features", ",", "scale_factor", "=", "2", ",", "mode", "=", "\"nearest\"", ")", "\n", "lateral_features", "=", "lateral_conv", "(", "features", ")", "\n", "prev_features", "=", "lateral_features", "+", "top_down_features", "\n", "if", "self", ".", "_fuse_type", "==", "\"avg\"", ":", "\n", "                ", "prev_features", "/=", "2", "\n", "", "results", ".", "insert", "(", "0", ",", "output_conv", "(", "prev_features", ")", ")", "\n", "\n", "", "if", "self", ".", "top_block", "is", "not", "None", ":", "\n", "            ", "top_block_in_feature", "=", "bottom_up_features", ".", "get", "(", "self", ".", "top_block", ".", "in_feature", ",", "None", ")", "\n", "if", "top_block_in_feature", "is", "None", ":", "\n", "                ", "top_block_in_feature", "=", "results", "[", "self", ".", "_out_features", ".", "index", "(", "self", ".", "top_block", ".", "in_feature", ")", "]", "\n", "", "results", ".", "extend", "(", "self", ".", "top_block", "(", "top_block_in_feature", ")", ")", "\n", "", "assert", "len", "(", "self", ".", "_out_features", ")", "==", "len", "(", "results", ")", "\n", "return", "dict", "(", "zip", "(", "self", ".", "_out_features", ",", "results", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.fpn.FPN.output_shape": [[147, 153], ["detectron2.layers.ShapeSpec"], "methods", ["None"], ["", "def", "output_shape", "(", "self", ")", ":", "\n", "        ", "return", "{", "\n", "name", ":", "ShapeSpec", "(", "\n", "channels", "=", "self", ".", "_out_feature_channels", "[", "name", "]", ",", "stride", "=", "self", ".", "_out_feature_strides", "[", "name", "]", "\n", ")", "\n", "for", "name", "in", "self", ".", "_out_features", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.fpn.LastLevelMaxPool.__init__": [[172, 176], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_levels", "=", "1", "\n", "self", ".", "in_feature", "=", "\"p5\"", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.fpn.LastLevelMaxPool.forward": [[177, 179], ["torch.max_pool2d"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "[", "F", ".", "max_pool2d", "(", "x", ",", "kernel_size", "=", "1", ",", "stride", "=", "2", ",", "padding", "=", "0", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.fpn.LastLevelP6P7.__init__": [[187, 195], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "fvcore.c2_xavier_fill"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "in_feature", "=", "\"res5\"", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_levels", "=", "2", "\n", "self", ".", "in_feature", "=", "in_feature", "\n", "self", ".", "p6", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "3", ",", "2", ",", "1", ")", "\n", "self", ".", "p7", "=", "nn", ".", "Conv2d", "(", "out_channels", ",", "out_channels", ",", "3", ",", "2", ",", "1", ")", "\n", "for", "module", "in", "[", "self", ".", "p6", ",", "self", ".", "p7", "]", ":", "\n", "            ", "weight_init", ".", "c2_xavier_fill", "(", "module", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.fpn.LastLevelP6P7.forward": [[196, 200], ["fpn.LastLevelP6P7.p6", "fpn.LastLevelP6P7.p7", "torch.relu"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "c5", ")", ":", "\n", "        ", "p6", "=", "self", ".", "p6", "(", "c5", ")", "\n", "p7", "=", "self", ".", "p7", "(", "F", ".", "relu", "(", "p6", ")", ")", "\n", "return", "[", "p6", ",", "p7", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.fpn._assert_strides_are_log2_contiguous": [[156, 163], ["enumerate"], "function", ["None"], ["", "", "def", "_assert_strides_are_log2_contiguous", "(", "strides", ")", ":", "\n", "    ", "\"\"\"\n    Assert that each stride is 2x times its preceding stride, i.e. \"contiguous in log2\".\n    \"\"\"", "\n", "for", "i", ",", "stride", "in", "enumerate", "(", "strides", "[", "1", ":", "]", ",", "1", ")", ":", "\n", "        ", "assert", "stride", "==", "2", "*", "strides", "[", "i", "-", "1", "]", ",", "\"Strides {} {} are not log2 contiguous\"", ".", "format", "(", "\n", "stride", ",", "strides", "[", "i", "-", "1", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.fpn.build_resnet_fpn_backbone": [[202, 223], ["build.BACKBONE_REGISTRY.register", "resnet.build_resnet_backbone", "fpn.FPN", "fpn.LastLevelMaxPool"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.base.BaseConverter.register", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.build_resnet_backbone"], ["", "", "@", "BACKBONE_REGISTRY", ".", "register", "(", ")", "\n", "def", "build_resnet_fpn_backbone", "(", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        cfg: a detectron2 CfgNode\n\n    Returns:\n        backbone (Backbone): backbone module, must be a subclass of :class:`Backbone`.\n    \"\"\"", "\n", "bottom_up", "=", "build_resnet_backbone", "(", "cfg", ",", "input_shape", ")", "\n", "in_features", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "IN_FEATURES", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "OUT_CHANNELS", "\n", "backbone", "=", "FPN", "(", "\n", "bottom_up", "=", "bottom_up", ",", "\n", "in_features", "=", "in_features", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "NORM", ",", "\n", "top_block", "=", "LastLevelMaxPool", "(", ")", ",", "\n", "fuse_type", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "FUSE_TYPE", ",", "\n", ")", "\n", "return", "backbone", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.fpn.build_retinanet_resnet_fpn_backbone": [[225, 247], ["build.BACKBONE_REGISTRY.register", "resnet.build_resnet_backbone", "fpn.FPN", "resnet.build_resnet_backbone.output_shape", "fpn.LastLevelP6P7"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.base.BaseConverter.register", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.build_resnet_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.backbone.Backbone.output_shape"], ["", "@", "BACKBONE_REGISTRY", ".", "register", "(", ")", "\n", "def", "build_retinanet_resnet_fpn_backbone", "(", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        cfg: a detectron2 CfgNode\n\n    Returns:\n        backbone (Backbone): backbone module, must be a subclass of :class:`Backbone`.\n    \"\"\"", "\n", "bottom_up", "=", "build_resnet_backbone", "(", "cfg", ",", "input_shape", ")", "\n", "in_features", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "IN_FEATURES", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "OUT_CHANNELS", "\n", "in_channels_p6p7", "=", "bottom_up", ".", "output_shape", "(", ")", "[", "\"res5\"", "]", ".", "channels", "\n", "backbone", "=", "FPN", "(", "\n", "bottom_up", "=", "bottom_up", ",", "\n", "in_features", "=", "in_features", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "NORM", ",", "\n", "top_block", "=", "LastLevelP6P7", "(", "in_channels_p6p7", ",", "out_channels", ")", ",", "\n", "fuse_type", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "FUSE_TYPE", ",", "\n", ")", "\n", "return", "backbone", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.BasicBlock.__init__": [[39, 85], ["detectron2.layers.CNNBlockBase.__init__", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "fvcore.c2_msra_fill", "detectron2.layers.get_norm"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "*", ",", "stride", "=", "1", ",", "norm", "=", "\"BN\"", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            in_channels (int): Number of input channels.\n            out_channels (int): Number of output channels.\n            stride (int): Stride for the first conv.\n            norm (str or callable): normalization for all conv layers.\n                See :func:`layers.get_norm` for supported format.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "stride", ")", "\n", "\n", "if", "in_channels", "!=", "out_channels", ":", "\n", "            ", "self", ".", "shortcut", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "shortcut", "=", "None", "\n", "\n", "", "self", ".", "conv1", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "\n", "self", ".", "conv2", "=", "Conv2d", "(", "\n", "out_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "\n", "for", "layer", "in", "[", "self", ".", "conv1", ",", "self", ".", "conv2", ",", "self", ".", "shortcut", "]", ":", "\n", "            ", "if", "layer", "is", "not", "None", ":", "# shortcut can be None", "\n", "                ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.BasicBlock.forward": [[86, 99], ["resnet.BasicBlock.conv1", "torch.relu_", "torch.relu_", "resnet.BasicBlock.conv2", "torch.relu_", "torch.relu_", "resnet.BasicBlock.shortcut"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "\n", "if", "self", ".", "shortcut", "is", "not", "None", ":", "\n", "            ", "shortcut", "=", "self", ".", "shortcut", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "shortcut", "=", "x", "\n", "\n", "", "out", "+=", "shortcut", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.BottleneckBlock.__init__": [[108, 182], ["detectron2.layers.CNNBlockBase.__init__", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "fvcore.c2_msra_fill", "detectron2.layers.get_norm"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "*", ",", "\n", "bottleneck_channels", ",", "\n", "stride", "=", "1", ",", "\n", "num_groups", "=", "1", ",", "\n", "norm", "=", "\"BN\"", ",", "\n", "stride_in_1x1", "=", "False", ",", "\n", "dilation", "=", "1", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            bottleneck_channels (int): number of output channels for the 3x3\n                \"bottleneck\" conv layers.\n            num_groups (int): number of groups for the 3x3 conv layer.\n            norm (str or callable): normalization for all conv layers.\n                See :func:`layers.get_norm` for supported format.\n            stride_in_1x1 (bool): when stride>1, whether to put stride in the\n                first 1x1 convolution or the bottleneck 3x3 convolution.\n            dilation (int): the dilation rate of the 3x3 conv layer.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "stride", ")", "\n", "\n", "if", "in_channels", "!=", "out_channels", ":", "\n", "            ", "self", ".", "shortcut", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "shortcut", "=", "None", "\n", "\n", "# The original MSRA ResNet models have stride in the first 1x1 conv", "\n", "# The subsequent fb.torch.resnet and Caffe2 ResNe[X]t implementations have", "\n", "# stride in the 3x3 conv", "\n", "", "stride_1x1", ",", "stride_3x3", "=", "(", "stride", ",", "1", ")", "if", "stride_in_1x1", "else", "(", "1", ",", "stride", ")", "\n", "\n", "self", ".", "conv1", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "bottleneck_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride_1x1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "bottleneck_channels", ")", ",", "\n", ")", "\n", "\n", "self", ".", "conv2", "=", "Conv2d", "(", "\n", "bottleneck_channels", ",", "\n", "bottleneck_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride_3x3", ",", "\n", "padding", "=", "1", "*", "dilation", ",", "\n", "bias", "=", "False", ",", "\n", "groups", "=", "num_groups", ",", "\n", "dilation", "=", "dilation", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "bottleneck_channels", ")", ",", "\n", ")", "\n", "\n", "self", ".", "conv3", "=", "Conv2d", "(", "\n", "bottleneck_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "\n", "for", "layer", "in", "[", "self", ".", "conv1", ",", "self", ".", "conv2", ",", "self", ".", "conv3", ",", "self", ".", "shortcut", "]", ":", "\n", "            ", "if", "layer", "is", "not", "None", ":", "# shortcut can be None", "\n", "                ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.BottleneckBlock.forward": [[195, 212], ["resnet.BottleneckBlock.conv1", "torch.relu_", "torch.relu_", "resnet.BottleneckBlock.conv2", "torch.relu_", "torch.relu_", "resnet.BottleneckBlock.conv3", "torch.relu_", "torch.relu_", "resnet.BottleneckBlock.shortcut"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "\n", "if", "self", ".", "shortcut", "is", "not", "None", ":", "\n", "            ", "shortcut", "=", "self", ".", "shortcut", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "shortcut", "=", "x", "\n", "\n", "", "out", "+=", "shortcut", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.DeformBottleneckBlock.__init__": [[220, 303], ["detectron2.layers.CNNBlockBase.__init__", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "deform_conv_op", "detectron2.layers.Conv2d", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "detectron2.layers.Conv2d", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "fvcore.c2_msra_fill", "detectron2.layers.get_norm"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "*", ",", "\n", "bottleneck_channels", ",", "\n", "stride", "=", "1", ",", "\n", "num_groups", "=", "1", ",", "\n", "norm", "=", "\"BN\"", ",", "\n", "stride_in_1x1", "=", "False", ",", "\n", "dilation", "=", "1", ",", "\n", "deform_modulated", "=", "False", ",", "\n", "deform_num_groups", "=", "1", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "stride", ")", "\n", "self", ".", "deform_modulated", "=", "deform_modulated", "\n", "\n", "if", "in_channels", "!=", "out_channels", ":", "\n", "            ", "self", ".", "shortcut", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "shortcut", "=", "None", "\n", "\n", "", "stride_1x1", ",", "stride_3x3", "=", "(", "stride", ",", "1", ")", "if", "stride_in_1x1", "else", "(", "1", ",", "stride", ")", "\n", "\n", "self", ".", "conv1", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "bottleneck_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride_1x1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "bottleneck_channels", ")", ",", "\n", ")", "\n", "\n", "if", "deform_modulated", ":", "\n", "            ", "deform_conv_op", "=", "ModulatedDeformConv", "\n", "# offset channels are 2 or 3 (if with modulated) * kernel_size * kernel_size", "\n", "offset_channels", "=", "27", "\n", "", "else", ":", "\n", "            ", "deform_conv_op", "=", "DeformConv", "\n", "offset_channels", "=", "18", "\n", "\n", "", "self", ".", "conv2_offset", "=", "Conv2d", "(", "\n", "bottleneck_channels", ",", "\n", "offset_channels", "*", "deform_num_groups", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride_3x3", ",", "\n", "padding", "=", "1", "*", "dilation", ",", "\n", "dilation", "=", "dilation", ",", "\n", ")", "\n", "self", ".", "conv2", "=", "deform_conv_op", "(", "\n", "bottleneck_channels", ",", "\n", "bottleneck_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride_3x3", ",", "\n", "padding", "=", "1", "*", "dilation", ",", "\n", "bias", "=", "False", ",", "\n", "groups", "=", "num_groups", ",", "\n", "dilation", "=", "dilation", ",", "\n", "deformable_groups", "=", "deform_num_groups", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "bottleneck_channels", ")", ",", "\n", ")", "\n", "\n", "self", ".", "conv3", "=", "Conv2d", "(", "\n", "bottleneck_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "\n", "for", "layer", "in", "[", "self", ".", "conv1", ",", "self", ".", "conv2", ",", "self", ".", "conv3", ",", "self", ".", "shortcut", "]", ":", "\n", "            ", "if", "layer", "is", "not", "None", ":", "# shortcut can be None", "\n", "                ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "\n", "", "", "nn", ".", "init", ".", "constant_", "(", "self", ".", "conv2_offset", ".", "weight", ",", "0", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "conv2_offset", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.DeformBottleneckBlock.forward": [[304, 329], ["resnet.DeformBottleneckBlock.conv1", "torch.relu_", "torch.relu_", "torch.relu_", "torch.relu_", "resnet.DeformBottleneckBlock.conv3", "torch.relu_", "torch.relu_", "resnet.DeformBottleneckBlock.conv2_offset", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mask.sigmoid.sigmoid.sigmoid", "resnet.DeformBottleneckBlock.conv2", "resnet.DeformBottleneckBlock.conv2_offset", "resnet.DeformBottleneckBlock.conv2", "resnet.DeformBottleneckBlock.shortcut"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "\n", "if", "self", ".", "deform_modulated", ":", "\n", "            ", "offset_mask", "=", "self", ".", "conv2_offset", "(", "out", ")", "\n", "offset_x", ",", "offset_y", ",", "mask", "=", "torch", ".", "chunk", "(", "offset_mask", ",", "3", ",", "dim", "=", "1", ")", "\n", "offset", "=", "torch", ".", "cat", "(", "(", "offset_x", ",", "offset_y", ")", ",", "dim", "=", "1", ")", "\n", "mask", "=", "mask", ".", "sigmoid", "(", ")", "\n", "out", "=", "self", ".", "conv2", "(", "out", ",", "offset", ",", "mask", ")", "\n", "", "else", ":", "\n", "            ", "offset", "=", "self", ".", "conv2_offset", "(", "out", ")", "\n", "out", "=", "self", ".", "conv2", "(", "out", ",", "offset", ")", "\n", "", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "\n", "if", "self", ".", "shortcut", "is", "not", "None", ":", "\n", "            ", "shortcut", "=", "self", ".", "shortcut", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "shortcut", "=", "x", "\n", "\n", "", "out", "+=", "shortcut", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.BasicStem.__init__": [[336, 354], ["detectron2.layers.CNNBlockBase.__init__", "detectron2.layers.Conv2d", "fvcore.c2_msra_fill", "detectron2.layers.get_norm"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm"], ["def", "__init__", "(", "self", ",", "in_channels", "=", "3", ",", "out_channels", "=", "64", ",", "norm", "=", "\"BN\"", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            norm (str or callable): norm after the first conv layer.\n                See :func:`layers.get_norm` for supported format.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "4", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "conv1", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "7", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "3", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "weight_init", ".", "c2_msra_fill", "(", "self", ".", "conv1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.BasicStem.forward": [[355, 360], ["resnet.BasicStem.conv1", "torch.relu_", "torch.relu_", "torch.max_pool2d", "torch.max_pool2d"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "F", ".", "relu_", "(", "x", ")", "\n", "x", "=", "F", ".", "max_pool2d", "(", "x", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.ResNet.__init__": [[367, 421], ["backbone.Backbone.__init__", "enumerate", "len", "len", "torch.nn.Sequential", "torch.nn.Sequential", "resnet.ResNet.add_module", "resnet.ResNet.stages_and_names.append", "int", "torch.nn.AdaptiveAvgPool2d", "torch.nn.AdaptiveAvgPool2d", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.init.normal_", "torch.nn.init.normal_", "len", "isinstance", "str", "resnet.ResNet.named_children", "numpy.prod"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "stem", ",", "stages", ",", "num_classes", "=", "None", ",", "out_features", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            stem (nn.Module): a stem module\n            stages (list[list[CNNBlockBase]]): several (typically 4) stages,\n                each contains multiple :class:`CNNBlockBase`.\n            num_classes (None or int): if None, will not perform classification.\n                Otherwise, will create a linear layer.\n            out_features (list[str]): name of the layers whose outputs should\n                be returned in forward. Can be anything in \"stem\", \"linear\", or \"res2\" ...\n                If None, will return the output of the last layer.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "stem", "=", "stem", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "\n", "current_stride", "=", "self", ".", "stem", ".", "stride", "\n", "self", ".", "_out_feature_strides", "=", "{", "\"stem\"", ":", "current_stride", "}", "\n", "self", ".", "_out_feature_channels", "=", "{", "\"stem\"", ":", "self", ".", "stem", ".", "out_channels", "}", "\n", "\n", "self", ".", "stages_and_names", "=", "[", "]", "\n", "for", "i", ",", "blocks", "in", "enumerate", "(", "stages", ")", ":", "\n", "            ", "assert", "len", "(", "blocks", ")", ">", "0", ",", "len", "(", "blocks", ")", "\n", "for", "block", "in", "blocks", ":", "\n", "                ", "assert", "isinstance", "(", "block", ",", "CNNBlockBase", ")", ",", "block", "\n", "\n", "", "name", "=", "\"res\"", "+", "str", "(", "i", "+", "2", ")", "\n", "stage", "=", "nn", ".", "Sequential", "(", "*", "blocks", ")", "\n", "\n", "self", ".", "add_module", "(", "name", ",", "stage", ")", "\n", "self", ".", "stages_and_names", ".", "append", "(", "(", "stage", ",", "name", ")", ")", "\n", "\n", "self", ".", "_out_feature_strides", "[", "name", "]", "=", "current_stride", "=", "int", "(", "\n", "current_stride", "*", "np", ".", "prod", "(", "[", "k", ".", "stride", "for", "k", "in", "blocks", "]", ")", "\n", ")", "\n", "self", ".", "_out_feature_channels", "[", "name", "]", "=", "curr_channels", "=", "blocks", "[", "-", "1", "]", ".", "out_channels", "\n", "\n", "", "if", "num_classes", "is", "not", "None", ":", "\n", "            ", "self", ".", "avgpool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "(", "1", ",", "1", ")", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "curr_channels", ",", "num_classes", ")", "\n", "\n", "# Sec 5.1 in \"Accurate, Large Minibatch SGD: Training ImageNet in 1 Hour\":", "\n", "# \"The 1000-way fully-connected layer is initialized by", "\n", "# drawing weights from a zero-mean Gaussian with standard deviation of 0.01.\"", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "linear", ".", "weight", ",", "std", "=", "0.01", ")", "\n", "name", "=", "\"linear\"", "\n", "\n", "", "if", "out_features", "is", "None", ":", "\n", "            ", "out_features", "=", "[", "name", "]", "\n", "", "self", ".", "_out_features", "=", "out_features", "\n", "assert", "len", "(", "self", ".", "_out_features", ")", "\n", "children", "=", "[", "x", "[", "0", "]", "for", "x", "in", "self", ".", "named_children", "(", ")", "]", "\n", "for", "out_feature", "in", "self", ".", "_out_features", ":", "\n", "            ", "assert", "out_feature", "in", "children", ",", "\"Available children: {}\"", ".", "format", "(", "\", \"", ".", "join", "(", "children", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.ResNet.forward": [[422, 446], ["resnet.ResNet.stem", "resnet.ResNet.dim", "stage", "resnet.ResNet.avgpool", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "resnet.ResNet.linear"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x: Tensor of shape (N,C,H,W). H, W must be a multiple of ``self.size_divisibility``.\n\n        Returns:\n            dict[str->Tensor]: names and the corresponding features\n        \"\"\"", "\n", "assert", "x", ".", "dim", "(", ")", "==", "4", ",", "f\"ResNet takes an input of shape (N, C, H, W). Got {x.shape} instead!\"", "\n", "outputs", "=", "{", "}", "\n", "x", "=", "self", ".", "stem", "(", "x", ")", "\n", "if", "\"stem\"", "in", "self", ".", "_out_features", ":", "\n", "            ", "outputs", "[", "\"stem\"", "]", "=", "x", "\n", "", "for", "stage", ",", "name", "in", "self", ".", "stages_and_names", ":", "\n", "            ", "x", "=", "stage", "(", "x", ")", "\n", "if", "name", "in", "self", ".", "_out_features", ":", "\n", "                ", "outputs", "[", "name", "]", "=", "x", "\n", "", "", "if", "self", ".", "num_classes", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "avgpool", "(", "x", ")", "\n", "x", "=", "torch", ".", "flatten", "(", "x", ",", "1", ")", "\n", "x", "=", "self", ".", "linear", "(", "x", ")", "\n", "if", "\"linear\"", "in", "self", ".", "_out_features", ":", "\n", "                ", "outputs", "[", "\"linear\"", "]", "=", "x", "\n", "", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.ResNet.output_shape": [[447, 453], ["detectron2.layers.ShapeSpec"], "methods", ["None"], ["", "def", "output_shape", "(", "self", ")", ":", "\n", "        ", "return", "{", "\n", "name", ":", "ShapeSpec", "(", "\n", "channels", "=", "self", ".", "_out_feature_channels", "[", "name", "]", ",", "stride", "=", "self", ".", "_out_feature_strides", "[", "name", "]", "\n", ")", "\n", "for", "name", "in", "self", ".", "_out_features", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.ResNet.freeze": [[455, 478], ["enumerate", "resnet.ResNet.stem.freeze", "stage.children", "block.freeze"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze"], ["", "def", "freeze", "(", "self", ",", "freeze_at", "=", "0", ")", ":", "\n", "        ", "\"\"\"\n        Freeze the first several stages of the ResNet. Commonly used in\n        fine-tuning.\n\n        Layers that produce the same feature map spatial size are defined as one\n        \"stage\" by :paper:`FPN`.\n\n        Args:\n            freeze_at (int): number of stages to freeze.\n                `1` means freezing the stem. `2` means freezing the stem and\n                one residual stage, etc.\n\n        Returns:\n            nn.Module: this ResNet itself\n        \"\"\"", "\n", "if", "freeze_at", ">=", "1", ":", "\n", "            ", "self", ".", "stem", ".", "freeze", "(", ")", "\n", "", "for", "idx", ",", "(", "stage", ",", "_", ")", "in", "enumerate", "(", "self", ".", "stages_and_names", ",", "start", "=", "2", ")", ":", "\n", "            ", "if", "freeze_at", ">=", "idx", ":", "\n", "                ", "for", "block", "in", "stage", ".", "children", "(", ")", ":", "\n", "                    ", "block", ".", "freeze", "(", ")", "\n", "", "", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.ResNet.make_stage": [[479, 545], ["range", "logging.getLogger", "logging.getLogger.warning", "kwargs.items", "blocks.append", "k.endswith", "block_class", "len", "len"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "make_stage", "(", "\n", "block_class", ",", "num_blocks", ",", "first_stride", "=", "None", ",", "*", ",", "in_channels", ",", "out_channels", ",", "**", "kwargs", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Create a list of blocks of the same type that forms one ResNet stage.\n\n        Args:\n            block_class (type): a subclass of CNNBlockBase that's used to create all blocks in this\n                stage. A module of this type must not change spatial resolution of inputs unless its\n                stride != 1.\n            num_blocks (int): number of blocks in this stage\n            first_stride (int): deprecated\n            in_channels (int): input channels of the entire stage.\n            out_channels (int): output channels of **every block** in the stage.\n            kwargs: other arguments passed to the constructor of\n                `block_class`. If the argument name is \"xx_per_block\", the\n                argument is a list of values to be passed to each block in the\n                stage. Otherwise, the same argument is passed to every block\n                in the stage.\n\n        Returns:\n            list[nn.Module]: a list of block module.\n\n        Examples:\n        ::\n            stages = ResNet.make_stage(\n                BottleneckBlock, 3, in_channels=16, out_channels=64,\n                bottleneck_channels=16, num_groups=1,\n                stride_per_block=[2, 1, 1],\n                dilations_per_block=[1, 1, 2]\n            )\n\n        Usually, layers that produce the same feature map spatial size are defined as one\n        \"stage\" (in :paper:`FPN`). Under such definition, ``stride_per_block[1:]`` should\n        all be 1.\n        \"\"\"", "\n", "if", "first_stride", "is", "not", "None", ":", "\n", "            ", "assert", "\"stride\"", "not", "in", "kwargs", "and", "\"stride_per_block\"", "not", "in", "kwargs", "\n", "kwargs", "[", "\"stride_per_block\"", "]", "=", "[", "first_stride", "]", "+", "[", "1", "]", "*", "(", "num_blocks", "-", "1", ")", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warning", "(", "\n", "\"ResNet.make_stage(first_stride=) is deprecated!  \"", "\n", "\"Use 'stride_per_block' or 'stride' instead.\"", "\n", ")", "\n", "\n", "", "blocks", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_blocks", ")", ":", "\n", "            ", "curr_kwargs", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "                ", "if", "k", ".", "endswith", "(", "\"_per_block\"", ")", ":", "\n", "                    ", "assert", "len", "(", "v", ")", "==", "num_blocks", ",", "(", "\n", "f\"Argument '{k}' of make_stage should have the \"", "\n", "f\"same length as num_blocks={num_blocks}.\"", "\n", ")", "\n", "newk", "=", "k", "[", ":", "-", "len", "(", "\"_per_block\"", ")", "]", "\n", "assert", "newk", "not", "in", "kwargs", ",", "f\"Cannot call make_stage with both {k} and {newk}!\"", "\n", "curr_kwargs", "[", "newk", "]", "=", "v", "[", "i", "]", "\n", "", "else", ":", "\n", "                    ", "curr_kwargs", "[", "k", "]", "=", "v", "\n", "\n", "", "", "blocks", ".", "append", "(", "\n", "block_class", "(", "in_channels", "=", "in_channels", ",", "out_channels", "=", "out_channels", ",", "**", "curr_kwargs", ")", "\n", ")", "\n", "in_channels", "=", "out_channels", "\n", "", "return", "blocks", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.make_stage": [[553, 558], ["resnet.ResNet.make_stage"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.make_stage"], ["def", "make_stage", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Deprecated alias for backward compatibiltiy.\n    \"\"\"", "\n", "return", "ResNet", ".", "make_stage", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.build_resnet_backbone": [[560, 647], ["build.BACKBONE_REGISTRY.register", "resnet.BasicStem", "max", "enumerate", "resnet.ResNet.freeze", "range", "resnet.ResNet.make_stage", "stages.append", "any", "resnet.ResNet"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.base.BaseConverter.register", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.make_stage"], ["", "@", "BACKBONE_REGISTRY", ".", "register", "(", ")", "\n", "def", "build_resnet_backbone", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Create a ResNet instance from config.\n\n    Returns:\n        ResNet: a :class:`ResNet` instance.\n    \"\"\"", "\n", "# need registration of new blocks/stems?", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "NORM", "\n", "stem", "=", "BasicStem", "(", "\n", "in_channels", "=", "input_shape", ".", "channels", ",", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "STEM_OUT_CHANNELS", ",", "\n", "norm", "=", "norm", ",", "\n", ")", "\n", "\n", "# fmt: off", "\n", "freeze_at", "=", "cfg", ".", "MODEL", ".", "BACKBONE", ".", "FREEZE_AT", "\n", "out_features", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "OUT_FEATURES", "\n", "depth", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DEPTH", "\n", "num_groups", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "NUM_GROUPS", "\n", "width_per_group", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "WIDTH_PER_GROUP", "\n", "bottleneck_channels", "=", "num_groups", "*", "width_per_group", "\n", "in_channels", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "STEM_OUT_CHANNELS", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "RES2_OUT_CHANNELS", "\n", "stride_in_1x1", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "STRIDE_IN_1X1", "\n", "res5_dilation", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "RES5_DILATION", "\n", "deform_on_per_stage", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DEFORM_ON_PER_STAGE", "\n", "deform_modulated", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DEFORM_MODULATED", "\n", "deform_num_groups", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DEFORM_NUM_GROUPS", "\n", "# fmt: on", "\n", "assert", "res5_dilation", "in", "{", "1", ",", "2", "}", ",", "\"res5_dilation cannot be {}.\"", ".", "format", "(", "res5_dilation", ")", "\n", "\n", "num_blocks_per_stage", "=", "{", "\n", "18", ":", "[", "2", ",", "2", ",", "2", ",", "2", "]", ",", "\n", "34", ":", "[", "3", ",", "4", ",", "6", ",", "3", "]", ",", "\n", "50", ":", "[", "3", ",", "4", ",", "6", ",", "3", "]", ",", "\n", "101", ":", "[", "3", ",", "4", ",", "23", ",", "3", "]", ",", "\n", "152", ":", "[", "3", ",", "8", ",", "36", ",", "3", "]", ",", "\n", "}", "[", "depth", "]", "\n", "\n", "if", "depth", "in", "[", "18", ",", "34", "]", ":", "\n", "        ", "assert", "out_channels", "==", "64", ",", "\"Must set MODEL.RESNETS.RES2_OUT_CHANNELS = 64 for R18/R34\"", "\n", "assert", "not", "any", "(", "\n", "deform_on_per_stage", "\n", ")", ",", "\"MODEL.RESNETS.DEFORM_ON_PER_STAGE unsupported for R18/R34\"", "\n", "assert", "res5_dilation", "==", "1", ",", "\"Must set MODEL.RESNETS.RES5_DILATION = 1 for R18/R34\"", "\n", "assert", "num_groups", "==", "1", ",", "\"Must set MODEL.RESNETS.NUM_GROUPS = 1 for R18/R34\"", "\n", "\n", "", "stages", "=", "[", "]", "\n", "\n", "# Avoid creating variables without gradients", "\n", "# It consumes extra memory and may cause allreduce to fail", "\n", "out_stage_idx", "=", "[", "\n", "{", "\"res2\"", ":", "2", ",", "\"res3\"", ":", "3", ",", "\"res4\"", ":", "4", ",", "\"res5\"", ":", "5", "}", "[", "f", "]", "for", "f", "in", "out_features", "if", "f", "!=", "\"stem\"", "\n", "]", "\n", "max_stage_idx", "=", "max", "(", "out_stage_idx", ")", "\n", "for", "idx", ",", "stage_idx", "in", "enumerate", "(", "range", "(", "2", ",", "max_stage_idx", "+", "1", ")", ")", ":", "\n", "        ", "dilation", "=", "res5_dilation", "if", "stage_idx", "==", "5", "else", "1", "\n", "first_stride", "=", "1", "if", "idx", "==", "0", "or", "(", "stage_idx", "==", "5", "and", "dilation", "==", "2", ")", "else", "2", "\n", "stage_kargs", "=", "{", "\n", "\"num_blocks\"", ":", "num_blocks_per_stage", "[", "idx", "]", ",", "\n", "\"stride_per_block\"", ":", "[", "first_stride", "]", "+", "[", "1", "]", "*", "(", "num_blocks_per_stage", "[", "idx", "]", "-", "1", ")", ",", "\n", "\"in_channels\"", ":", "in_channels", ",", "\n", "\"out_channels\"", ":", "out_channels", ",", "\n", "\"norm\"", ":", "norm", ",", "\n", "}", "\n", "# Use BasicBlock for R18 and R34.", "\n", "if", "depth", "in", "[", "18", ",", "34", "]", ":", "\n", "            ", "stage_kargs", "[", "\"block_class\"", "]", "=", "BasicBlock", "\n", "", "else", ":", "\n", "            ", "stage_kargs", "[", "\"bottleneck_channels\"", "]", "=", "bottleneck_channels", "\n", "stage_kargs", "[", "\"stride_in_1x1\"", "]", "=", "stride_in_1x1", "\n", "stage_kargs", "[", "\"dilation\"", "]", "=", "dilation", "\n", "stage_kargs", "[", "\"num_groups\"", "]", "=", "num_groups", "\n", "if", "deform_on_per_stage", "[", "idx", "]", ":", "\n", "                ", "stage_kargs", "[", "\"block_class\"", "]", "=", "DeformBottleneckBlock", "\n", "stage_kargs", "[", "\"deform_modulated\"", "]", "=", "deform_modulated", "\n", "stage_kargs", "[", "\"deform_num_groups\"", "]", "=", "deform_num_groups", "\n", "", "else", ":", "\n", "                ", "stage_kargs", "[", "\"block_class\"", "]", "=", "BottleneckBlock", "\n", "", "", "blocks", "=", "ResNet", ".", "make_stage", "(", "**", "stage_kargs", ")", "\n", "in_channels", "=", "out_channels", "\n", "out_channels", "*=", "2", "\n", "bottleneck_channels", "*=", "2", "\n", "stages", ".", "append", "(", "blocks", ")", "\n", "", "return", "ResNet", "(", "stem", ",", "stages", ",", "out_features", "=", "out_features", ")", ".", "freeze", "(", "freeze_at", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.backbone.Backbone.__init__": [[15, 20], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        The `__init__` method of any subclass can specify its own set of arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.backbone.Backbone.forward": [[21, 30], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "forward", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Subclasses must override this method, but adhere to the same return type.\n\n        Returns:\n            dict[str->Tensor]: mapping from feature name (e.g., \"res2\") to tensor\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.backbone.Backbone.size_divisibility": [[31, 41], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "size_divisibility", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Some backbones require the input height and width to be divisible by a\n        specific integer. This is typically true for encoder / decoder type networks\n        with lateral connection (e.g., FPN) for which feature maps need to match\n        dimension in the \"bottom up\" and \"top down\" paths. Set to 0 if no specific\n        input size divisibility is required.\n        \"\"\"", "\n", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.backbone.Backbone.output_shape": [[42, 53], ["detectron2.layers.ShapeSpec"], "methods", ["None"], ["", "def", "output_shape", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            dict[str->ShapeSpec]\n        \"\"\"", "\n", "# this is a backward-compatible default", "\n", "return", "{", "\n", "name", ":", "ShapeSpec", "(", "\n", "channels", "=", "self", ".", "_out_feature_channels", "[", "name", "]", ",", "stride", "=", "self", ".", "_out_feature_strides", "[", "name", "]", "\n", ")", "\n", "for", "name", "in", "self", ".", "_out_features", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.rotated_boxes.RotatedBoxes.__init__": [[20, 222], ["torch.as_tensor", "tensor.reshape().to.reshape().to.size", "isinstance", "torch.device", "tensor.reshape().to.reshape().to.numel", "tensor.reshape().to.reshape().to.reshape().to", "tensor.reshape().to.reshape().to.dim", "tensor.reshape().to.reshape().to.size", "tensor.reshape().to.reshape().to.reshape"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["def", "__init__", "(", "self", ",", "tensor", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            tensor (Tensor[float]): a Nx5 matrix.  Each row is\n                (x_center, y_center, width, height, angle),\n                in which angle is represented in degrees.\n                While there's no strict range restriction for it,\n                the recommended principal range is between [-180, 180) degrees.\n\n        Assume we have a horizontal box B = (x_center, y_center, width, height),\n        where width is along the x-axis and height is along the y-axis.\n        The rotated box B_rot (x_center, y_center, width, height, angle)\n        can be seen as:\n\n        1. When angle == 0:\n           B_rot == B\n        2. When angle > 0:\n           B_rot is obtained by rotating B w.r.t its center by :math:`|angle|` degrees CCW;\n        3. When angle < 0:\n           B_rot is obtained by rotating B w.r.t its center by :math:`|angle|` degrees CW.\n\n        Mathematically, since the right-handed coordinate system for image space\n        is (y, x), where y is top->down and x is left->right, the 4 vertices of the\n        rotated rectangle :math:`(yr_i, xr_i)` (i = 1, 2, 3, 4) can be obtained from\n        the vertices of the horizontal rectangle (y_i, x_i) (i = 1, 2, 3, 4)\n        in the following way (:math:`\\\\theta = angle*\\\\pi/180` is the angle in radians,\n        (y_c, x_c) is the center of the rectangle):\n\n        .. math::\n\n            yr_i = \\\\cos(\\\\theta) (y_i - y_c) - \\\\sin(\\\\theta) (x_i - x_c) + y_c,\n\n            xr_i = \\\\sin(\\\\theta) (y_i - y_c) + \\\\cos(\\\\theta) (x_i - x_c) + x_c,\n\n        which is the standard rigid-body rotation transformation.\n\n        Intuitively, the angle is\n        (1) the rotation angle from y-axis in image space\n        to the height vector (top->down in the box's local coordinate system)\n        of the box in CCW, and\n        (2) the rotation angle from x-axis in image space\n        to the width vector (left->right in the box's local coordinate system)\n        of the box in CCW.\n\n        More intuitively, consider the following horizontal box ABCD represented\n        in (x1, y1, x2, y2): (3, 2, 7, 4),\n        covering the [3, 7] x [2, 4] region of the continuous coordinate system\n        which looks like this:\n\n        .. code:: none\n\n            O--------> x\n            |\n            |  A---B\n            |  |   |\n            |  D---C\n            |\n            v y\n\n        Note that each capital letter represents one 0-dimensional geometric point\n        instead of a 'square pixel' here.\n\n        In the example above, using (x, y) to represent a point we have:\n\n        .. math::\n\n            O = (0, 0), A = (3, 2), B = (7, 2), C = (7, 4), D = (3, 4)\n\n        We name vector AB = vector DC as the width vector in box's local coordinate system, and\n        vector AD = vector BC as the height vector in box's local coordinate system. Initially,\n        when angle = 0 degree, they're aligned with the positive directions of x-axis and y-axis\n        in the image space, respectively.\n\n        For better illustration, we denote the center of the box as E,\n\n        .. code:: none\n\n            O--------> x\n            |\n            |  A---B\n            |  | E |\n            |  D---C\n            |\n            v y\n\n        where the center E = ((3+7)/2, (2+4)/2) = (5, 3).\n\n        Also,\n\n        .. math::\n\n            width = |AB| = |CD| = 7 - 3 = 4,\n            height = |AD| = |BC| = 4 - 2 = 2.\n\n        Therefore, the corresponding representation for the same shape in rotated box in\n        (x_center, y_center, width, height, angle) format is:\n\n        (5, 3, 4, 2, 0),\n\n        Now, let's consider (5, 3, 4, 2, 90), which is rotated by 90 degrees\n        CCW (counter-clockwise) by definition. It looks like this:\n\n        .. code:: none\n\n            O--------> x\n            |   B-C\n            |   | |\n            |   |E|\n            |   | |\n            |   A-D\n            v y\n\n        The center E is still located at the same point (5, 3), while the vertices\n        ABCD are rotated by 90 degrees CCW with regard to E:\n        A = (4, 5), B = (4, 1), C = (6, 1), D = (6, 5)\n\n        Here, 90 degrees can be seen as the CCW angle to rotate from y-axis to\n        vector AD or vector BC (the top->down height vector in box's local coordinate system),\n        or the CCW angle to rotate from x-axis to vector AB or vector DC (the left->right\n        width vector in box's local coordinate system).\n\n        .. math::\n\n            width = |AB| = |CD| = 5 - 1 = 4,\n            height = |AD| = |BC| = 6 - 4 = 2.\n\n        Next, how about (5, 3, 4, 2, -90), which is rotated by 90 degrees CW (clockwise)\n        by definition? It looks like this:\n\n        .. code:: none\n\n            O--------> x\n            |   D-A\n            |   | |\n            |   |E|\n            |   | |\n            |   C-B\n            v y\n\n        The center E is still located at the same point (5, 3), while the vertices\n        ABCD are rotated by 90 degrees CW with regard to E:\n        A = (6, 1), B = (6, 5), C = (4, 5), D = (4, 1)\n\n        .. math::\n\n            width = |AB| = |CD| = 5 - 1 = 4,\n            height = |AD| = |BC| = 6 - 4 = 2.\n\n        This covers exactly the same region as (5, 3, 4, 2, 90) does, and their IoU\n        will be 1. However, these two will generate different RoI Pooling results and\n        should not be treated as an identical box.\n\n        On the other hand, it's easy to see that (X, Y, W, H, A) is identical to\n        (X, Y, W, H, A+360N), for any integer N. For example (5, 3, 4, 2, 270) would be\n        identical to (5, 3, 4, 2, -90), because rotating the shape 270 degrees CCW is\n        equivalent to rotating the same shape 90 degrees CW.\n\n        We could rotate further to get (5, 3, 4, 2, 180), or (5, 3, 4, 2, -180):\n\n        .. code:: none\n\n            O--------> x\n            |\n            |  C---D\n            |  | E |\n            |  B---A\n            |\n            v y\n\n        .. math::\n\n            A = (7, 4), B = (3, 4), C = (3, 2), D = (7, 2),\n\n            width = |AB| = |CD| = 7 - 3 = 4,\n            height = |AD| = |BC| = 4 - 2 = 2.\n\n        Finally, this is a very inaccurate (heavily quantized) illustration of\n        how (5, 3, 4, 2, 60) looks like in case anyone wonders:\n\n        .. code:: none\n\n            O--------> x\n            |     B\\\n            |    /  C\n            |   /E /\n            |  A  /\n            |   `D\n            v y\n\n        It's still a rectangle with center of (5, 3), width of 4 and height of 2,\n        but its angle (and thus orientation) is somewhere between\n        (5, 3, 4, 2, 0) and (5, 3, 4, 2, 90).\n        \"\"\"", "\n", "device", "=", "tensor", ".", "device", "if", "isinstance", "(", "tensor", ",", "torch", ".", "Tensor", ")", "else", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "tensor", "=", "torch", ".", "as_tensor", "(", "tensor", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "if", "tensor", ".", "numel", "(", ")", "==", "0", ":", "\n", "# Use reshape, so we don't end up creating a new tensor that does not depend on", "\n", "# the inputs (and consequently confuses jit)", "\n", "            ", "tensor", "=", "tensor", ".", "reshape", "(", "(", "0", ",", "5", ")", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "", "assert", "tensor", ".", "dim", "(", ")", "==", "2", "and", "tensor", ".", "size", "(", "-", "1", ")", "==", "5", ",", "tensor", ".", "size", "(", ")", "\n", "\n", "self", ".", "tensor", "=", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.rotated_boxes.RotatedBoxes.clone": [[223, 231], ["rotated_boxes.RotatedBoxes", "rotated_boxes.RotatedBoxes.tensor.clone"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone"], ["", "def", "clone", "(", "self", ")", "->", "\"RotatedBoxes\"", ":", "\n", "        ", "\"\"\"\n        Clone the RotatedBoxes.\n\n        Returns:\n            RotatedBoxes\n        \"\"\"", "\n", "return", "RotatedBoxes", "(", "self", ".", "tensor", ".", "clone", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.rotated_boxes.RotatedBoxes.to": [[232, 234], ["rotated_boxes.RotatedBoxes", "rotated_boxes.RotatedBoxes.tensor.to"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "to", "(", "self", ",", "*", "args", ":", "Any", ",", "**", "kwargs", ":", "Any", ")", "->", "\"RotatedBoxes\"", ":", "\n", "        ", "return", "RotatedBoxes", "(", "self", ".", "tensor", ".", "to", "(", "*", "args", ",", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.rotated_boxes.RotatedBoxes.area": [[235, 245], ["None"], "methods", ["None"], ["", "def", "area", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Computes the area of all the boxes.\n\n        Returns:\n            torch.Tensor: a vector with areas of each box.\n        \"\"\"", "\n", "box", "=", "self", ".", "tensor", "\n", "area", "=", "box", "[", ":", ",", "2", "]", "*", "box", "[", ":", ",", "3", "]", "\n", "return", "area", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.rotated_boxes.RotatedBoxes.normalize_angles": [[246, 251], ["None"], "methods", ["None"], ["", "def", "normalize_angles", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Restrict angles to the range of [-180, 180) degrees\n        \"\"\"", "\n", "self", ".", "tensor", "[", ":", ",", "4", "]", "=", "(", "self", ".", "tensor", "[", ":", ",", "4", "]", "+", "180.0", ")", "%", "360.0", "-", "180.0", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.rotated_boxes.RotatedBoxes.clip": [[252, 301], ["rotated_boxes.RotatedBoxes.normalize_angles", "x1.clamp_", "y1.clamp_", "x2.clamp_", "y2.clamp_", "torch.min", "torch.min", "torch.where", "torch.abs"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.rotated_boxes.RotatedBoxes.normalize_angles"], ["", "def", "clip", "(", "self", ",", "box_size", ":", "Tuple", "[", "int", ",", "int", "]", ",", "clip_angle_threshold", ":", "float", "=", "1.0", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Clip (in place) the boxes by limiting x coordinates to the range [0, width]\n        and y coordinates to the range [0, height].\n\n        For RRPN:\n        Only clip boxes that are almost horizontal with a tolerance of\n        clip_angle_threshold to maintain backward compatibility.\n\n        Rotated boxes beyond this threshold are not clipped for two reasons:\n\n        1. There are potentially multiple ways to clip a rotated box to make it\n           fit within the image.\n        2. It's tricky to make the entire rectangular box fit within the image\n           and still be able to not leave out pixels of interest.\n\n        Therefore we rely on ops like RoIAlignRotated to safely handle this.\n\n        Args:\n            box_size (height, width): The clipping box's size.\n            clip_angle_threshold:\n                Iff. abs(normalized(angle)) <= clip_angle_threshold (in degrees),\n                we do the clipping as horizontal boxes.\n        \"\"\"", "\n", "h", ",", "w", "=", "box_size", "\n", "\n", "# normalize angles to be within (-180, 180] degrees", "\n", "self", ".", "normalize_angles", "(", ")", "\n", "\n", "idx", "=", "torch", ".", "where", "(", "torch", ".", "abs", "(", "self", ".", "tensor", "[", ":", ",", "4", "]", ")", "<=", "clip_angle_threshold", ")", "[", "0", "]", "\n", "\n", "# convert to (x1, y1, x2, y2)", "\n", "x1", "=", "self", ".", "tensor", "[", "idx", ",", "0", "]", "-", "self", ".", "tensor", "[", "idx", ",", "2", "]", "/", "2.0", "\n", "y1", "=", "self", ".", "tensor", "[", "idx", ",", "1", "]", "-", "self", ".", "tensor", "[", "idx", ",", "3", "]", "/", "2.0", "\n", "x2", "=", "self", ".", "tensor", "[", "idx", ",", "0", "]", "+", "self", ".", "tensor", "[", "idx", ",", "2", "]", "/", "2.0", "\n", "y2", "=", "self", ".", "tensor", "[", "idx", ",", "1", "]", "+", "self", ".", "tensor", "[", "idx", ",", "3", "]", "/", "2.0", "\n", "\n", "# clip", "\n", "x1", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "w", ")", "\n", "y1", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "h", ")", "\n", "x2", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "w", ")", "\n", "y2", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "h", ")", "\n", "\n", "# convert back to (xc, yc, w, h)", "\n", "self", ".", "tensor", "[", "idx", ",", "0", "]", "=", "(", "x1", "+", "x2", ")", "/", "2.0", "\n", "self", ".", "tensor", "[", "idx", ",", "1", "]", "=", "(", "y1", "+", "y2", ")", "/", "2.0", "\n", "# make sure widths and heights do not increase due to numerical errors", "\n", "self", ".", "tensor", "[", "idx", ",", "2", "]", "=", "torch", ".", "min", "(", "self", ".", "tensor", "[", "idx", ",", "2", "]", ",", "x2", "-", "x1", ")", "\n", "self", ".", "tensor", "[", "idx", ",", "3", "]", "=", "torch", ".", "min", "(", "self", ".", "tensor", "[", "idx", ",", "3", "]", ",", "y2", "-", "y1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.rotated_boxes.RotatedBoxes.nonempty": [[302, 316], ["None"], "methods", ["None"], ["", "def", "nonempty", "(", "self", ",", "threshold", ":", "float", "=", "0.0", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Find boxes that are non-empty.\n        A box is considered empty, if either of its side is no larger than threshold.\n\n        Returns:\n            Tensor: a binary vector which represents\n            whether each box is empty (False) or non-empty (True).\n        \"\"\"", "\n", "box", "=", "self", ".", "tensor", "\n", "widths", "=", "box", "[", ":", ",", "2", "]", "\n", "heights", "=", "box", "[", ":", ",", "3", "]", "\n", "keep", "=", "(", "widths", ">", "threshold", ")", "&", "(", "heights", ">", "threshold", ")", "\n", "return", "keep", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.rotated_boxes.RotatedBoxes.__getitem__": [[317, 339], ["isinstance", "rotated_boxes.RotatedBoxes", "rotated_boxes.RotatedBoxes", "b.dim", "rotated_boxes.RotatedBoxes.tensor[].view"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ":", "Union", "[", "int", ",", "slice", ",", "torch", ".", "BoolTensor", "]", ")", "->", "\"RotatedBoxes\"", ":", "\n", "        ", "\"\"\"\n        Returns:\n            RotatedBoxes: Create a new :class:`RotatedBoxes` by indexing.\n\n        The following usage are allowed:\n\n        1. `new_boxes = boxes[3]`: return a `RotatedBoxes` which contains only one box.\n        2. `new_boxes = boxes[2:10]`: return a slice of boxes.\n        3. `new_boxes = boxes[vector]`, where vector is a torch.ByteTensor\n           with `length = len(boxes)`. Nonzero elements in the vector will be selected.\n\n        Note that the returned RotatedBoxes might share storage with this RotatedBoxes,\n        subject to Pytorch's indexing semantics.\n        \"\"\"", "\n", "if", "isinstance", "(", "item", ",", "int", ")", ":", "\n", "            ", "return", "RotatedBoxes", "(", "self", ".", "tensor", "[", "item", "]", ".", "view", "(", "1", ",", "-", "1", ")", ")", "\n", "", "b", "=", "self", ".", "tensor", "[", "item", "]", "\n", "assert", "b", ".", "dim", "(", ")", "==", "2", ",", "\"Indexing on RotatedBoxes with {} failed to return a matrix!\"", ".", "format", "(", "\n", "item", "\n", ")", "\n", "return", "RotatedBoxes", "(", "b", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.rotated_boxes.RotatedBoxes.__len__": [[340, 342], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "self", ".", "tensor", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.rotated_boxes.RotatedBoxes.__repr__": [[343, 345], ["str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "\"RotatedBoxes(\"", "+", "str", "(", "self", ".", "tensor", ")", "+", "\")\"", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.rotated_boxes.RotatedBoxes.inside_box": [[346, 382], ["torch.abs", "torch.abs", "torch.cos", "torch.sin"], "methods", ["None"], ["", "def", "inside_box", "(", "self", ",", "box_size", ":", "Tuple", "[", "int", ",", "int", "]", ",", "boundary_threshold", ":", "int", "=", "0", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Args:\n            box_size (height, width): Size of the reference box covering\n                [0, width] x [0, height]\n            boundary_threshold (int): Boxes that extend beyond the reference box\n                boundary by more than boundary_threshold are considered \"outside\".\n\n        For RRPN, it might not be necessary to call this function since it's common\n        for rotated box to extend to outside of the image boundaries\n        (the clip function only clips the near-horizontal boxes)\n\n        Returns:\n            a binary vector, indicating whether each box is inside the reference box.\n        \"\"\"", "\n", "height", ",", "width", "=", "box_size", "\n", "\n", "cnt_x", "=", "self", ".", "tensor", "[", "...", ",", "0", "]", "\n", "cnt_y", "=", "self", ".", "tensor", "[", "...", ",", "1", "]", "\n", "half_w", "=", "self", ".", "tensor", "[", "...", ",", "2", "]", "/", "2.0", "\n", "half_h", "=", "self", ".", "tensor", "[", "...", ",", "3", "]", "/", "2.0", "\n", "a", "=", "self", ".", "tensor", "[", "...", ",", "4", "]", "\n", "c", "=", "torch", ".", "abs", "(", "torch", ".", "cos", "(", "a", "*", "math", ".", "pi", "/", "180.0", ")", ")", "\n", "s", "=", "torch", ".", "abs", "(", "torch", ".", "sin", "(", "a", "*", "math", ".", "pi", "/", "180.0", ")", ")", "\n", "# This basically computes the horizontal bounding rectangle of the rotated box", "\n", "max_rect_dx", "=", "c", "*", "half_w", "+", "s", "*", "half_h", "\n", "max_rect_dy", "=", "c", "*", "half_h", "+", "s", "*", "half_w", "\n", "\n", "inds_inside", "=", "(", "\n", "(", "cnt_x", "-", "max_rect_dx", ">=", "-", "boundary_threshold", ")", "\n", "&", "(", "cnt_y", "-", "max_rect_dy", ">=", "-", "boundary_threshold", ")", "\n", "&", "(", "cnt_x", "+", "max_rect_dx", "<", "width", "+", "boundary_threshold", ")", "\n", "&", "(", "cnt_y", "+", "max_rect_dy", "<", "height", "+", "boundary_threshold", ")", "\n", ")", "\n", "\n", "return", "inds_inside", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.rotated_boxes.RotatedBoxes.get_centers": [[383, 389], ["None"], "methods", ["None"], ["", "def", "get_centers", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Returns:\n            The box centers in a Nx2 array of (x, y).\n        \"\"\"", "\n", "return", "self", ".", "tensor", "[", ":", ",", ":", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.rotated_boxes.RotatedBoxes.scale": [[390, 454], ["torch.cos", "torch.sin", "torch.sqrt", "torch.sqrt", "torch.atan2"], "methods", ["None"], ["", "def", "scale", "(", "self", ",", "scale_x", ":", "float", ",", "scale_y", ":", "float", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Scale the rotated box with horizontal and vertical scaling factors\n        Note: when scale_factor_x != scale_factor_y,\n        the rotated box does not preserve the rectangular shape when the angle\n        is not a multiple of 90 degrees under resize transformation.\n        Instead, the shape is a parallelogram (that has skew)\n        Here we make an approximation by fitting a rotated rectangle to the parallelogram.\n        \"\"\"", "\n", "self", ".", "tensor", "[", ":", ",", "0", "]", "*=", "scale_x", "\n", "self", ".", "tensor", "[", ":", ",", "1", "]", "*=", "scale_y", "\n", "theta", "=", "self", ".", "tensor", "[", ":", ",", "4", "]", "*", "math", ".", "pi", "/", "180.0", "\n", "c", "=", "torch", ".", "cos", "(", "theta", ")", "\n", "s", "=", "torch", ".", "sin", "(", "theta", ")", "\n", "\n", "# In image space, y is top->down and x is left->right", "\n", "# Consider the local coordintate system for the rotated box,", "\n", "# where the box center is located at (0, 0), and the four vertices ABCD are", "\n", "# A(-w / 2, -h / 2), B(w / 2, -h / 2), C(w / 2, h / 2), D(-w / 2, h / 2)", "\n", "# the midpoint of the left edge AD of the rotated box E is:", "\n", "# E = (A+D)/2 = (-w / 2, 0)", "\n", "# the midpoint of the top edge AB of the rotated box F is:", "\n", "# F(0, -h / 2)", "\n", "# To get the old coordinates in the global system, apply the rotation transformation", "\n", "# (Note: the right-handed coordinate system for image space is yOx):", "\n", "# (old_x, old_y) = (s * y + c * x, c * y - s * x)", "\n", "# E(old) = (s * 0 + c * (-w/2), c * 0 - s * (-w/2)) = (-c * w / 2, s * w / 2)", "\n", "# F(old) = (s * (-h / 2) + c * 0, c * (-h / 2) - s * 0) = (-s * h / 2, -c * h / 2)", "\n", "# After applying the scaling factor (sfx, sfy):", "\n", "# E(new) = (-sfx * c * w / 2, sfy * s * w / 2)", "\n", "# F(new) = (-sfx * s * h / 2, -sfy * c * h / 2)", "\n", "# The new width after scaling tranformation becomes:", "\n", "\n", "# w(new) = |E(new) - O| * 2", "\n", "#        = sqrt[(sfx * c * w / 2)^2 + (sfy * s * w / 2)^2] * 2", "\n", "#        = sqrt[(sfx * c)^2 + (sfy * s)^2] * w", "\n", "# i.e., scale_factor_w = sqrt[(sfx * c)^2 + (sfy * s)^2]", "\n", "#", "\n", "# For example,", "\n", "# when angle = 0 or 180, |c| = 1, s = 0, scale_factor_w == scale_factor_x;", "\n", "# when |angle| = 90, c = 0, |s| = 1, scale_factor_w == scale_factor_y", "\n", "self", ".", "tensor", "[", ":", ",", "2", "]", "*=", "torch", ".", "sqrt", "(", "(", "scale_x", "*", "c", ")", "**", "2", "+", "(", "scale_y", "*", "s", ")", "**", "2", ")", "\n", "\n", "# h(new) = |F(new) - O| * 2", "\n", "#        = sqrt[(sfx * s * h / 2)^2 + (sfy * c * h / 2)^2] * 2", "\n", "#        = sqrt[(sfx * s)^2 + (sfy * c)^2] * h", "\n", "# i.e., scale_factor_h = sqrt[(sfx * s)^2 + (sfy * c)^2]", "\n", "#", "\n", "# For example,", "\n", "# when angle = 0 or 180, |c| = 1, s = 0, scale_factor_h == scale_factor_y;", "\n", "# when |angle| = 90, c = 0, |s| = 1, scale_factor_h == scale_factor_x", "\n", "self", ".", "tensor", "[", ":", ",", "3", "]", "*=", "torch", ".", "sqrt", "(", "(", "scale_x", "*", "s", ")", "**", "2", "+", "(", "scale_y", "*", "c", ")", "**", "2", ")", "\n", "\n", "# The angle is the rotation angle from y-axis in image space to the height", "\n", "# vector (top->down in the box's local coordinate system) of the box in CCW.", "\n", "#", "\n", "# angle(new) = angle_yOx(O - F(new))", "\n", "#            = angle_yOx( (sfx * s * h / 2, sfy * c * h / 2) )", "\n", "#            = atan2(sfx * s * h / 2, sfy * c * h / 2)", "\n", "#            = atan2(sfx * s, sfy * c)", "\n", "#", "\n", "# For example,", "\n", "# when sfx == sfy, angle(new) == atan2(s, c) == angle(old)", "\n", "self", ".", "tensor", "[", ":", ",", "4", "]", "=", "torch", ".", "atan2", "(", "scale_x", "*", "s", ",", "scale_y", "*", "c", ")", "*", "180", "/", "math", ".", "pi", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.rotated_boxes.RotatedBoxes.device": [[455, 458], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "self", ".", "tensor", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.rotated_boxes.RotatedBoxes.__iter__": [[459, 464], ["None"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", "->", "Iterator", "[", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Yield a box as a Tensor of shape (5,) at a time.\n        \"\"\"", "\n", "yield", "from", "self", ".", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.rotated_boxes.pairwise_iou": [[466, 482], ["detectron2.layers.rotated_boxes.pairwise_iou_rotated"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.rotated_boxes.pairwise_iou_rotated"], ["", "", "def", "pairwise_iou", "(", "boxes1", ":", "RotatedBoxes", ",", "boxes2", ":", "RotatedBoxes", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Given two lists of rotated boxes of size N and M,\n    compute the IoU (intersection over union)\n    between __all__ N x M pairs of boxes.\n    The box order must be (x_center, y_center, width, height, angle).\n\n    Args:\n        boxes1, boxes2 (RotatedBoxes):\n            two `RotatedBoxes`. Contains N & M rotated boxes, respectively.\n\n    Returns:\n        Tensor: IoU, sized [N,M].\n    \"\"\"", "\n", "\n", "return", "pairwise_iou_rotated", "(", "boxes1", ".", "tensor", ",", "boxes2", ".", "tensor", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.__init__": [[20, 29], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "tensor", ":", "torch", ".", "Tensor", ",", "image_sizes", ":", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            tensor (Tensor): of shape (N, H, W) or (N, C_1, ..., C_K, H, W) where K >= 1\n            image_sizes (list[tuple[int, int]]): Each tuple is (h, w). It can\n                be smaller than (H, W) due to padding.\n        \"\"\"", "\n", "self", ".", "tensor", "=", "tensor", "\n", "self", ".", "image_sizes", "=", "image_sizes", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.__len__": [[30, 32], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "len", "(", "self", ".", "image_sizes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.__getitem__": [[33, 45], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Access the individual image in its original size.\n\n        Args:\n            idx: int or slice\n\n        Returns:\n            Tensor: an image of shape (H, W) or (C_1, ..., C_K, H, W) where K >= 1\n        \"\"\"", "\n", "size", "=", "self", ".", "image_sizes", "[", "idx", "]", "\n", "return", "self", ".", "tensor", "[", "idx", ",", "...", ",", ":", "size", "[", "0", "]", ",", ":", "size", "[", "1", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.to": [[46, 50], ["image_list.ImageList.tensor.to", "image_list.ImageList"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "@", "torch", ".", "jit", ".", "unused", "\n", "def", "to", "(", "self", ",", "*", "args", ":", "Any", ",", "**", "kwargs", ":", "Any", ")", "->", "\"ImageList\"", ":", "\n", "        ", "cast_tensor", "=", "self", ".", "tensor", ".", "to", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "return", "ImageList", "(", "cast_tensor", ",", "self", ".", "image_sizes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.device": [[51, 54], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", "->", "device", ":", "\n", "        ", "return", "self", ".", "tensor", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.from_tensors": [[55, 121], ["isinstance", "image_list.ImageList", "len", "isinstance", "type", "torch.stack().max", "torch.cat", "tuple", "len", "all", "tensors[].new_full", "zip", "F.pad.unsqueeze_.contiguous", "tensors[].unsqueeze", "torch.nn.functional.pad", "torch.nn.functional.pad.unsqueeze_", "tuple", "pad_img[].copy_", "torch.stack", "len", "torch.stack", "torch.as_tensor", "tuple"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "@", "staticmethod", "\n", "# https://github.com/pytorch/pytorch/issues/39308", "\n", "@", "torch", ".", "jit", ".", "unused", "\n", "def", "from_tensors", "(", "\n", "tensors", ":", "Sequence", "[", "torch", ".", "Tensor", "]", ",", "size_divisibility", ":", "int", "=", "0", ",", "pad_value", ":", "float", "=", "0.0", "\n", ")", "->", "\"ImageList\"", ":", "\n", "        ", "\"\"\"\n        Args:\n            tensors: a tuple or list of `torch.Tensors`, each of shape (Hi, Wi) or\n                (C_1, ..., C_K, Hi, Wi) where K >= 1. The Tensors will be padded\n                to the same shape with `pad_value`.\n            size_divisibility (int): If `size_divisibility > 0`, add padding to ensure\n                the common height and width is divisible by `size_divisibility`.\n                This depends on the model and many models need a divisibility of 32.\n            pad_value (float): value to pad\n\n        Returns:\n            an `ImageList`.\n        \"\"\"", "\n", "assert", "len", "(", "tensors", ")", ">", "0", "\n", "assert", "isinstance", "(", "tensors", ",", "(", "tuple", ",", "list", ")", ")", "\n", "for", "t", "in", "tensors", ":", "\n", "            ", "assert", "isinstance", "(", "t", ",", "torch", ".", "Tensor", ")", ",", "type", "(", "t", ")", "\n", "assert", "t", ".", "shape", "[", "1", ":", "-", "2", "]", "==", "tensors", "[", "0", "]", ".", "shape", "[", "1", ":", "-", "2", "]", ",", "t", ".", "shape", "\n", "# per dimension maximum (H, W) or (C_1, ..., C_K, H, W) where K >= 1 among all tensors", "\n", "", "max_size", "=", "(", "\n", "# In tracing mode, x.shape[i] is Tensor, and should not be converted", "\n", "# to int: this will cause the traced graph to have hard-coded shapes.", "\n", "# Instead we should make max_size a Tensor that depends on these tensors.", "\n", "# Using torch.stack twice seems to be the best way to convert", "\n", "# list[list[ScalarTensor]] to a Tensor", "\n", "torch", ".", "stack", "(", "\n", "[", "\n", "torch", ".", "stack", "(", "[", "torch", ".", "as_tensor", "(", "dim", ")", "for", "dim", "in", "size", "]", ")", "\n", "for", "size", "in", "[", "tuple", "(", "img", ".", "shape", ")", "for", "img", "in", "tensors", "]", "\n", "]", "\n", ")", "\n", ".", "max", "(", "0", ")", "\n", ".", "values", "\n", ")", "\n", "\n", "if", "size_divisibility", ">", "1", ":", "\n", "            ", "stride", "=", "size_divisibility", "\n", "# the last two dims are H,W, both subject to divisibility requirement", "\n", "max_size", "=", "torch", ".", "cat", "(", "[", "max_size", "[", ":", "-", "2", "]", ",", "(", "max_size", "[", "-", "2", ":", "]", "+", "(", "stride", "-", "1", ")", ")", "//", "stride", "*", "stride", "]", ")", "\n", "\n", "", "image_sizes", "=", "[", "tuple", "(", "im", ".", "shape", "[", "-", "2", ":", "]", ")", "for", "im", "in", "tensors", "]", "\n", "\n", "if", "len", "(", "tensors", ")", "==", "1", ":", "\n", "# This seems slightly (2%) faster.", "\n", "# TODO: check whether it's faster for multiple images as well", "\n", "            ", "image_size", "=", "image_sizes", "[", "0", "]", "\n", "padding_size", "=", "[", "0", ",", "max_size", "[", "-", "1", "]", "-", "image_size", "[", "1", "]", ",", "0", ",", "max_size", "[", "-", "2", "]", "-", "image_size", "[", "0", "]", "]", "\n", "if", "all", "(", "x", "==", "0", "for", "x", "in", "padding_size", ")", ":", "# https://github.com/pytorch/pytorch/issues/31734", "\n", "                ", "batched_imgs", "=", "tensors", "[", "0", "]", ".", "unsqueeze", "(", "0", ")", "\n", "", "else", ":", "\n", "                ", "padded", "=", "F", ".", "pad", "(", "tensors", "[", "0", "]", ",", "padding_size", ",", "value", "=", "pad_value", ")", "\n", "batched_imgs", "=", "padded", ".", "unsqueeze_", "(", "0", ")", "\n", "", "", "else", ":", "\n", "# max_size can be a tensor in tracing mode, therefore use tuple()", "\n", "            ", "batch_shape", "=", "(", "len", "(", "tensors", ")", ",", ")", "+", "tuple", "(", "max_size", ")", "\n", "batched_imgs", "=", "tensors", "[", "0", "]", ".", "new_full", "(", "batch_shape", ",", "pad_value", ")", "\n", "for", "img", ",", "pad_img", "in", "zip", "(", "tensors", ",", "batched_imgs", ")", ":", "\n", "                ", "pad_img", "[", "...", ",", ":", "img", ".", "shape", "[", "-", "2", "]", ",", ":", "img", ".", "shape", "[", "-", "1", "]", "]", ".", "copy_", "(", "img", ")", "\n", "\n", "", "", "return", "ImageList", "(", "batched_imgs", ".", "contiguous", "(", ")", ",", "image_sizes", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.__init__": [[38, 48], ["kwargs.items", "instances.Instances.set"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["def", "__init__", "(", "self", ",", "image_size", ":", "Tuple", "[", "int", ",", "int", "]", ",", "**", "kwargs", ":", "Any", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image_size (height, width): the spatial size of the image.\n            kwargs: fields to add to this `Instances`.\n        \"\"\"", "\n", "self", ".", "_image_size", "=", "image_size", "\n", "self", ".", "_fields", ":", "Dict", "[", "str", ",", "Any", "]", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "set", "(", "k", ",", "v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.image_size": [[49, 56], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "image_size", "(", "self", ")", "->", "Tuple", "[", "int", ",", "int", "]", ":", "\n", "        ", "\"\"\"\n        Returns:\n            tuple: height, width\n        \"\"\"", "\n", "return", "self", ".", "_image_size", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.__setattr__": [[57, 62], ["name.startswith", "super().__setattr__", "instances.Instances.set"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.__setattr__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["", "def", "__setattr__", "(", "self", ",", "name", ":", "str", ",", "val", ":", "Any", ")", "->", "None", ":", "\n", "        ", "if", "name", ".", "startswith", "(", "\"_\"", ")", ":", "\n", "            ", "super", "(", ")", ".", "__setattr__", "(", "name", ",", "val", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "set", "(", "name", ",", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.__getattr__": [[63, 67], ["AttributeError"], "methods", ["None"], ["", "", "def", "__getattr__", "(", "self", ",", "name", ":", "str", ")", "->", "Any", ":", "\n", "        ", "if", "name", "==", "\"_fields\"", "or", "name", "not", "in", "self", ".", "_fields", ":", "\n", "            ", "raise", "AttributeError", "(", "\"Cannot find field '{}' in the given Instances!\"", ".", "format", "(", "name", ")", ")", "\n", "", "return", "self", ".", "_fields", "[", "name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.set": [[68, 80], ["len", "len", "len", "len"], "methods", ["None"], ["", "def", "set", "(", "self", ",", "name", ":", "str", ",", "value", ":", "Any", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Set the field named `name` to `value`.\n        The length of `value` must be the number of instances,\n        and must agree with other existing fields in this object.\n        \"\"\"", "\n", "data_len", "=", "len", "(", "value", ")", "\n", "if", "len", "(", "self", ".", "_fields", ")", ":", "\n", "            ", "assert", "(", "\n", "len", "(", "self", ")", "==", "data_len", "\n", ")", ",", "\"Adding a field of length {} to a Instances of length {}\"", ".", "format", "(", "data_len", ",", "len", "(", "self", ")", ")", "\n", "", "self", ".", "_fields", "[", "name", "]", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.has": [[81, 87], ["None"], "methods", ["None"], ["", "def", "has", "(", "self", ",", "name", ":", "str", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        Returns:\n            bool: whether the field called `name` exists.\n        \"\"\"", "\n", "return", "name", "in", "self", ".", "_fields", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.remove": [[88, 93], ["None"], "methods", ["None"], ["", "def", "remove", "(", "self", ",", "name", ":", "str", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Remove the field called `name`.\n        \"\"\"", "\n", "del", "self", ".", "_fields", "[", "name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.get": [[94, 99], ["None"], "methods", ["None"], ["", "def", "get", "(", "self", ",", "name", ":", "str", ")", "->", "Any", ":", "\n", "        ", "\"\"\"\n        Returns the field called `name`.\n        \"\"\"", "\n", "return", "self", ".", "_fields", "[", "name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.get_fields": [[100, 108], ["None"], "methods", ["None"], ["", "def", "get_fields", "(", "self", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "\"\"\"\n        Returns:\n            dict: a dict which maps names (str) to data of the fields\n\n        Modifying the returned dict will modify this instance.\n        \"\"\"", "\n", "return", "self", ".", "_fields", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.to": [[110, 121], ["instances.Instances", "instances.Instances._fields.items", "hasattr", "instances.Instances.set", "v.to.to.to"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "to", "(", "self", ",", "*", "args", ":", "Any", ",", "**", "kwargs", ":", "Any", ")", "->", "\"Instances\"", ":", "\n", "        ", "\"\"\"\n        Returns:\n            Instances: all fields are called with a `to(device)`, if the field has this method.\n        \"\"\"", "\n", "ret", "=", "Instances", "(", "self", ".", "_image_size", ")", "\n", "for", "k", ",", "v", "in", "self", ".", "_fields", ".", "items", "(", ")", ":", "\n", "            ", "if", "hasattr", "(", "v", ",", "\"to\"", ")", ":", "\n", "                ", "v", "=", "v", ".", "to", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "ret", ".", "set", "(", "k", ",", "v", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.__getitem__": [[122, 141], ["instances.Instances", "instances.Instances._fields.items", "type", "instances.Instances.set", "IndexError", "slice", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["", "def", "__getitem__", "(", "self", ",", "item", ":", "Union", "[", "int", ",", "slice", ",", "torch", ".", "BoolTensor", "]", ")", "->", "\"Instances\"", ":", "\n", "        ", "\"\"\"\n        Args:\n            item: an index-like object and will be used to index all the fields.\n\n        Returns:\n            If `item` is a string, return the data in the corresponding field.\n            Otherwise, returns an `Instances` where all fields are indexed by `item`.\n        \"\"\"", "\n", "if", "type", "(", "item", ")", "==", "int", ":", "\n", "            ", "if", "item", ">=", "len", "(", "self", ")", "or", "item", "<", "-", "len", "(", "self", ")", ":", "\n", "                ", "raise", "IndexError", "(", "\"Instances index out of range!\"", ")", "\n", "", "else", ":", "\n", "                ", "item", "=", "slice", "(", "item", ",", "None", ",", "len", "(", "self", ")", ")", "\n", "\n", "", "", "ret", "=", "Instances", "(", "self", ".", "_image_size", ")", "\n", "for", "k", ",", "v", "in", "self", ".", "_fields", ".", "items", "(", ")", ":", "\n", "            ", "ret", ".", "set", "(", "k", ",", "v", "[", "item", "]", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.__len__": [[142, 146], ["instances.Instances._fields.values", "NotImplementedError", "len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", "->", "int", ":", "\n", "        ", "for", "v", "in", "self", ".", "_fields", ".", "values", "(", ")", ":", "\n", "            ", "return", "len", "(", "v", ")", "\n", "", "raise", "NotImplementedError", "(", "\"Empty Instances does not support __len__!\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.__iter__": [[147, 149], ["NotImplementedError"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"`Instances` object is not iterable!\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.cat": [[150, 181], ["all", "instances.Instances", "instance_lists[]._fields.keys", "len", "len", "isinstance", "instances.Instances.set", "isinstance", "i.get", "torch.cat", "isinstance", "list", "hasattr", "itertools.chain", "type", "type().cat", "ValueError", "type", "type"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "@", "staticmethod", "\n", "def", "cat", "(", "instance_lists", ":", "List", "[", "\"Instances\"", "]", ")", "->", "\"Instances\"", ":", "\n", "        ", "\"\"\"\n        Args:\n            instance_lists (list[Instances])\n\n        Returns:\n            Instances\n        \"\"\"", "\n", "assert", "all", "(", "isinstance", "(", "i", ",", "Instances", ")", "for", "i", "in", "instance_lists", ")", "\n", "assert", "len", "(", "instance_lists", ")", ">", "0", "\n", "if", "len", "(", "instance_lists", ")", "==", "1", ":", "\n", "            ", "return", "instance_lists", "[", "0", "]", "\n", "\n", "", "image_size", "=", "instance_lists", "[", "0", "]", ".", "image_size", "\n", "for", "i", "in", "instance_lists", "[", "1", ":", "]", ":", "\n", "            ", "assert", "i", ".", "image_size", "==", "image_size", "\n", "", "ret", "=", "Instances", "(", "image_size", ")", "\n", "for", "k", "in", "instance_lists", "[", "0", "]", ".", "_fields", ".", "keys", "(", ")", ":", "\n", "            ", "values", "=", "[", "i", ".", "get", "(", "k", ")", "for", "i", "in", "instance_lists", "]", "\n", "v0", "=", "values", "[", "0", "]", "\n", "if", "isinstance", "(", "v0", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "values", "=", "torch", ".", "cat", "(", "values", ",", "dim", "=", "0", ")", "\n", "", "elif", "isinstance", "(", "v0", ",", "list", ")", ":", "\n", "                ", "values", "=", "list", "(", "itertools", ".", "chain", "(", "*", "values", ")", ")", "\n", "", "elif", "hasattr", "(", "type", "(", "v0", ")", ",", "\"cat\"", ")", ":", "\n", "                ", "values", "=", "type", "(", "v0", ")", ".", "cat", "(", "values", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\"Unsupported type {} for concatenation\"", ".", "format", "(", "type", "(", "v0", ")", ")", ")", "\n", "", "ret", ".", "set", "(", "k", ",", "values", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.__str__": [[182, 189], ["len", "instances.Instances._fields.items"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", "->", "str", ":", "\n", "        ", "s", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "s", "+=", "\"num_instances={}, \"", ".", "format", "(", "len", "(", "self", ")", ")", "\n", "s", "+=", "\"image_height={}, \"", ".", "format", "(", "self", ".", "_image_size", "[", "0", "]", ")", "\n", "s", "+=", "\"image_width={}, \"", ".", "format", "(", "self", ".", "_image_size", "[", "1", "]", ")", "\n", "s", "+=", "\"fields=[{}])\"", ".", "format", "(", "\", \"", ".", "join", "(", "(", "f\"{k}: {v}\"", "for", "k", ",", "v", "in", "self", ".", "_fields", ".", "items", "(", ")", ")", ")", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.keypoints.Keypoints.__init__": [[21, 32], ["torch.as_tensor", "isinstance", "torch.device", "torch.as_tensor.dim"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device"], ["def", "__init__", "(", "self", ",", "keypoints", ":", "Union", "[", "torch", ".", "Tensor", ",", "np", ".", "ndarray", ",", "List", "[", "List", "[", "float", "]", "]", "]", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            keypoints: A Tensor, numpy array, or list of the x, y, and visibility of each keypoint.\n                The shape should be (N, K, 3) where N is the number of\n                instances, and K is the number of keypoints per instance.\n        \"\"\"", "\n", "device", "=", "keypoints", ".", "device", "if", "isinstance", "(", "keypoints", ",", "torch", ".", "Tensor", ")", "else", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "keypoints", "=", "torch", ".", "as_tensor", "(", "keypoints", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "assert", "keypoints", ".", "dim", "(", ")", "==", "3", "and", "keypoints", ".", "shape", "[", "2", "]", "==", "3", ",", "keypoints", ".", "shape", "\n", "self", ".", "tensor", "=", "keypoints", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.keypoints.Keypoints.__len__": [[33, 35], ["keypoints.Keypoints.tensor.size"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "self", ".", "tensor", ".", "size", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.keypoints.Keypoints.to": [[36, 38], ["type", "keypoints.Keypoints.tensor.to"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "to", "(", "self", ",", "*", "args", ":", "Any", ",", "**", "kwargs", ":", "Any", ")", "->", "\"Keypoints\"", ":", "\n", "        ", "return", "type", "(", "self", ")", "(", "self", ".", "tensor", ".", "to", "(", "*", "args", ",", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.keypoints.Keypoints.device": [[39, 42], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", "->", "torch", ".", "device", ":", "\n", "        ", "return", "self", ".", "tensor", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.keypoints.Keypoints.to_heatmap": [[43, 59], ["keypoints._keypoints_to_heatmap"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.keypoints._keypoints_to_heatmap"], ["", "def", "to_heatmap", "(", "self", ",", "boxes", ":", "torch", ".", "Tensor", ",", "heatmap_size", ":", "int", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Convert keypoint annotations to a heatmap of one-hot labels for training,\n        as described in :paper:`Mask R-CNN`.\n\n        Arguments:\n            boxes: Nx4 tensor, the boxes to draw the keypoints to\n\n        Returns:\n            heatmaps:\n                A tensor of shape (N, K), each element is integer spatial label\n                in the range [0, heatmap_size**2 - 1] for each keypoint in the input.\n            valid:\n                A tensor of shape (N, K) containing whether each keypoint is in the roi or not.\n        \"\"\"", "\n", "return", "_keypoints_to_heatmap", "(", "self", ".", "tensor", ",", "boxes", ",", "heatmap_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.keypoints.Keypoints.__getitem__": [[60, 77], ["isinstance", "keypoints.Keypoints", "keypoints.Keypoints"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ":", "Union", "[", "int", ",", "slice", ",", "torch", ".", "BoolTensor", "]", ")", "->", "\"Keypoints\"", ":", "\n", "        ", "\"\"\"\n        Create a new `Keypoints` by indexing on this `Keypoints`.\n\n        The following usage are allowed:\n\n        1. `new_kpts = kpts[3]`: return a `Keypoints` which contains only one instance.\n        2. `new_kpts = kpts[2:10]`: return a slice of key points.\n        3. `new_kpts = kpts[vector]`, where vector is a torch.ByteTensor\n           with `length = len(kpts)`. Nonzero elements in the vector will be selected.\n\n        Note that the returned Keypoints might share storage with this Keypoints,\n        subject to Pytorch's indexing semantics.\n        \"\"\"", "\n", "if", "isinstance", "(", "item", ",", "int", ")", ":", "\n", "            ", "return", "Keypoints", "(", "[", "self", ".", "tensor", "[", "item", "]", "]", ")", "\n", "", "return", "Keypoints", "(", "self", ".", "tensor", "[", "item", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.keypoints.Keypoints.__repr__": [[78, 82], ["len"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", "->", "str", ":", "\n", "        ", "s", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "s", "+=", "\"num_instances={})\"", ".", "format", "(", "len", "(", "self", ".", "tensor", ")", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.keypoints._keypoints_to_heatmap": [[85, 142], ["x.floor().long.floor().long", "y.floor().long.floor().long", "rois.numel", "rois.new().long", "rois.new().long", "x.floor().long.floor", "y.floor().long.floor", "rois.new", "rois.new"], "function", ["None"], ["", "", "def", "_keypoints_to_heatmap", "(", "\n", "keypoints", ":", "torch", ".", "Tensor", ",", "rois", ":", "torch", ".", "Tensor", ",", "heatmap_size", ":", "int", "\n", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ":", "\n", "    ", "\"\"\"\n    Encode keypoint locations into a target heatmap for use in SoftmaxWithLoss across space.\n\n    Maps keypoints from the half-open interval [x1, x2) on continuous image coordinates to the\n    closed interval [0, heatmap_size - 1] on discrete image coordinates. We use the\n    continuous-discrete conversion from Heckbert 1990 (\"What is the coordinate of a pixel?\"):\n    d = floor(c) and c = d + 0.5, where d is a discrete coordinate and c is a continuous coordinate.\n\n    Arguments:\n        keypoints: tensor of keypoint locations in of shape (N, K, 3).\n        rois: Nx4 tensor of rois in xyxy format\n        heatmap_size: integer side length of square heatmap.\n\n    Returns:\n        heatmaps: A tensor of shape (N, K) containing an integer spatial label\n            in the range [0, heatmap_size**2 - 1] for each keypoint in the input.\n        valid: A tensor of shape (N, K) containing whether each keypoint is in\n            the roi or not.\n    \"\"\"", "\n", "\n", "if", "rois", ".", "numel", "(", ")", "==", "0", ":", "\n", "        ", "return", "rois", ".", "new", "(", ")", ".", "long", "(", ")", ",", "rois", ".", "new", "(", ")", ".", "long", "(", ")", "\n", "", "offset_x", "=", "rois", "[", ":", ",", "0", "]", "\n", "offset_y", "=", "rois", "[", ":", ",", "1", "]", "\n", "scale_x", "=", "heatmap_size", "/", "(", "rois", "[", ":", ",", "2", "]", "-", "rois", "[", ":", ",", "0", "]", ")", "\n", "scale_y", "=", "heatmap_size", "/", "(", "rois", "[", ":", ",", "3", "]", "-", "rois", "[", ":", ",", "1", "]", ")", "\n", "\n", "offset_x", "=", "offset_x", "[", ":", ",", "None", "]", "\n", "offset_y", "=", "offset_y", "[", ":", ",", "None", "]", "\n", "scale_x", "=", "scale_x", "[", ":", ",", "None", "]", "\n", "scale_y", "=", "scale_y", "[", ":", ",", "None", "]", "\n", "\n", "x", "=", "keypoints", "[", "...", ",", "0", "]", "\n", "y", "=", "keypoints", "[", "...", ",", "1", "]", "\n", "\n", "x_boundary_inds", "=", "x", "==", "rois", "[", ":", ",", "2", "]", "[", ":", ",", "None", "]", "\n", "y_boundary_inds", "=", "y", "==", "rois", "[", ":", ",", "3", "]", "[", ":", ",", "None", "]", "\n", "\n", "x", "=", "(", "x", "-", "offset_x", ")", "*", "scale_x", "\n", "x", "=", "x", ".", "floor", "(", ")", ".", "long", "(", ")", "\n", "y", "=", "(", "y", "-", "offset_y", ")", "*", "scale_y", "\n", "y", "=", "y", ".", "floor", "(", ")", ".", "long", "(", ")", "\n", "\n", "x", "[", "x_boundary_inds", "]", "=", "heatmap_size", "-", "1", "\n", "y", "[", "y_boundary_inds", "]", "=", "heatmap_size", "-", "1", "\n", "\n", "valid_loc", "=", "(", "x", ">=", "0", ")", "&", "(", "y", ">=", "0", ")", "&", "(", "x", "<", "heatmap_size", ")", "&", "(", "y", "<", "heatmap_size", ")", "\n", "vis", "=", "keypoints", "[", "...", ",", "2", "]", ">", "0", "\n", "valid", "=", "(", "valid_loc", "&", "vis", ")", ".", "long", "(", ")", "\n", "\n", "lin_ind", "=", "y", "*", "heatmap_size", "+", "x", "\n", "heatmaps", "=", "lin_ind", "*", "valid", "\n", "\n", "return", "heatmaps", ",", "valid", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.keypoints.heatmaps_to_keypoints": [[144, 217], ["maps.detach.detach", "rois.detach.detach", "widths.ceil", "heights.ceil", "maps.detach.new_zeros", "torch.arange", "range", "detectron2.layers.interpolate().squeeze", "interpolate().squeeze.view().max", "max_score.view.view", "interpolate().squeeze.view().argmax", "int", "int", "tmp_pool_resolution.sum", "detectron2.layers.interpolate", "interpolate().squeeze.view", "interpolate().squeeze.view", "x_int.float", "y_int.float", "roi_map_scores.view().max", "roi_map_scores.view"], "function", ["None"], ["", "def", "heatmaps_to_keypoints", "(", "maps", ":", "torch", ".", "Tensor", ",", "rois", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Extract predicted keypoint locations from heatmaps.\n\n    Args:\n        maps (Tensor): (#ROIs, #keypoints, POOL_H, POOL_W). The predicted heatmap of logits for\n            each ROI and each keypoint.\n        rois (Tensor): (#ROIs, 4). The box of each ROI.\n\n    Returns:\n        Tensor of shape (#ROIs, #keypoints, 4) with the last dimension corresponding to\n        (x, y, logit, score) for each keypoint.\n\n    When converting discrete pixel indices in an NxN image to a continuous keypoint coordinate,\n    we maintain consistency with :meth:`Keypoints.to_heatmap` by using the conversion from\n    Heckbert 1990: c = d + 0.5, where d is a discrete coordinate and c is a continuous coordinate.\n    \"\"\"", "\n", "# The decorator use of torch.no_grad() was not supported by torchscript.", "\n", "# https://github.com/pytorch/pytorch/pull/41371", "\n", "maps", "=", "maps", ".", "detach", "(", ")", "\n", "rois", "=", "rois", ".", "detach", "(", ")", "\n", "\n", "offset_x", "=", "rois", "[", ":", ",", "0", "]", "\n", "offset_y", "=", "rois", "[", ":", ",", "1", "]", "\n", "\n", "widths", "=", "(", "rois", "[", ":", ",", "2", "]", "-", "rois", "[", ":", ",", "0", "]", ")", ".", "clamp", "(", "min", "=", "1", ")", "\n", "heights", "=", "(", "rois", "[", ":", ",", "3", "]", "-", "rois", "[", ":", ",", "1", "]", ")", ".", "clamp", "(", "min", "=", "1", ")", "\n", "widths_ceil", "=", "widths", ".", "ceil", "(", ")", "\n", "heights_ceil", "=", "heights", ".", "ceil", "(", ")", "\n", "\n", "num_rois", ",", "num_keypoints", "=", "maps", ".", "shape", "[", ":", "2", "]", "\n", "xy_preds", "=", "maps", ".", "new_zeros", "(", "rois", ".", "shape", "[", "0", "]", ",", "num_keypoints", ",", "4", ")", "\n", "\n", "width_corrections", "=", "widths", "/", "widths_ceil", "\n", "height_corrections", "=", "heights", "/", "heights_ceil", "\n", "\n", "keypoints_idx", "=", "torch", ".", "arange", "(", "num_keypoints", ",", "device", "=", "maps", ".", "device", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_rois", ")", ":", "\n", "        ", "outsize", "=", "(", "int", "(", "heights_ceil", "[", "i", "]", ")", ",", "int", "(", "widths_ceil", "[", "i", "]", ")", ")", "\n", "roi_map", "=", "interpolate", "(", "maps", "[", "[", "i", "]", "]", ",", "size", "=", "outsize", ",", "mode", "=", "\"bicubic\"", ",", "align_corners", "=", "False", ")", ".", "squeeze", "(", "\n", "0", "\n", ")", "# #keypoints x H x W", "\n", "\n", "# softmax over the spatial region", "\n", "max_score", ",", "_", "=", "roi_map", ".", "view", "(", "num_keypoints", ",", "-", "1", ")", ".", "max", "(", "1", ")", "\n", "max_score", "=", "max_score", ".", "view", "(", "num_keypoints", ",", "1", ",", "1", ")", "\n", "tmp_full_resolution", "=", "(", "roi_map", "-", "max_score", ")", ".", "exp_", "(", ")", "\n", "tmp_pool_resolution", "=", "(", "maps", "[", "i", "]", "-", "max_score", ")", ".", "exp_", "(", ")", "\n", "# Produce scores over the region H x W, but normalize with POOL_H x POOL_W,", "\n", "# so that the scores of objects of different absolute sizes will be more comparable", "\n", "roi_map_scores", "=", "tmp_full_resolution", "/", "tmp_pool_resolution", ".", "sum", "(", "(", "1", ",", "2", ")", ",", "keepdim", "=", "True", ")", "\n", "\n", "w", "=", "roi_map", ".", "shape", "[", "2", "]", "\n", "pos", "=", "roi_map", ".", "view", "(", "num_keypoints", ",", "-", "1", ")", ".", "argmax", "(", "1", ")", "\n", "\n", "x_int", "=", "pos", "%", "w", "\n", "y_int", "=", "(", "pos", "-", "x_int", ")", "//", "w", "\n", "\n", "assert", "(", "\n", "roi_map_scores", "[", "keypoints_idx", ",", "y_int", ",", "x_int", "]", "\n", "==", "roi_map_scores", ".", "view", "(", "num_keypoints", ",", "-", "1", ")", ".", "max", "(", "1", ")", "[", "0", "]", "\n", ")", ".", "all", "(", ")", "\n", "\n", "x", "=", "(", "x_int", ".", "float", "(", ")", "+", "0.5", ")", "*", "width_corrections", "[", "i", "]", "\n", "y", "=", "(", "y_int", ".", "float", "(", ")", "+", "0.5", ")", "*", "height_corrections", "[", "i", "]", "\n", "\n", "xy_preds", "[", "i", ",", ":", ",", "0", "]", "=", "x", "+", "offset_x", "[", "i", "]", "\n", "xy_preds", "[", "i", ",", ":", ",", "1", "]", "=", "y", "+", "offset_y", "[", "i", "]", "\n", "xy_preds", "[", "i", ",", ":", ",", "2", "]", "=", "roi_map", "[", "keypoints_idx", ",", "y_int", ",", "x_int", "]", "\n", "xy_preds", "[", "i", ",", ":", ",", "3", "]", "=", "roi_map_scores", "[", "keypoints_idx", ",", "y_int", ",", "x_int", "]", "\n", "\n", "", "return", "xy_preds", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.BitMasks.__init__": [[93, 103], ["torch.as_tensor", "torch.as_tensor.size", "isinstance", "torch.device", "torch.as_tensor.dim"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device"], ["def", "__init__", "(", "self", ",", "tensor", ":", "Union", "[", "torch", ".", "Tensor", ",", "np", ".", "ndarray", "]", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            tensor: bool Tensor of N,H,W, representing N instances in the image.\n        \"\"\"", "\n", "device", "=", "tensor", ".", "device", "if", "isinstance", "(", "tensor", ",", "torch", ".", "Tensor", ")", "else", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "tensor", "=", "torch", ".", "as_tensor", "(", "tensor", ",", "dtype", "=", "torch", ".", "bool", ",", "device", "=", "device", ")", "\n", "assert", "tensor", ".", "dim", "(", ")", "==", "3", ",", "tensor", ".", "size", "(", ")", "\n", "self", ".", "image_size", "=", "tensor", ".", "shape", "[", "1", ":", "]", "\n", "self", ".", "tensor", "=", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.BitMasks.to": [[104, 106], ["masks.BitMasks", "masks.BitMasks.tensor.to"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "to", "(", "self", ",", "*", "args", ":", "Any", ",", "**", "kwargs", ":", "Any", ")", "->", "\"BitMasks\"", ":", "\n", "        ", "return", "BitMasks", "(", "self", ".", "tensor", ".", "to", "(", "*", "args", ",", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.BitMasks.device": [[107, 110], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", "->", "torch", ".", "device", ":", "\n", "        ", "return", "self", ".", "tensor", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.BitMasks.__getitem__": [[111, 133], ["isinstance", "masks.BitMasks", "masks.BitMasks", "m.dim", "masks.BitMasks.tensor[].view"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ":", "Union", "[", "int", ",", "slice", ",", "torch", ".", "BoolTensor", "]", ")", "->", "\"BitMasks\"", ":", "\n", "        ", "\"\"\"\n        Returns:\n            BitMasks: Create a new :class:`BitMasks` by indexing.\n\n        The following usage are allowed:\n\n        1. `new_masks = masks[3]`: return a `BitMasks` which contains only one mask.\n        2. `new_masks = masks[2:10]`: return a slice of masks.\n        3. `new_masks = masks[vector]`, where vector is a torch.BoolTensor\n           with `length = len(masks)`. Nonzero elements in the vector will be selected.\n\n        Note that the returned object might share storage with this object,\n        subject to Pytorch's indexing semantics.\n        \"\"\"", "\n", "if", "isinstance", "(", "item", ",", "int", ")", ":", "\n", "            ", "return", "BitMasks", "(", "self", ".", "tensor", "[", "item", "]", ".", "view", "(", "1", ",", "-", "1", ")", ")", "\n", "", "m", "=", "self", ".", "tensor", "[", "item", "]", "\n", "assert", "m", ".", "dim", "(", ")", "==", "3", ",", "\"Indexing on BitMasks with {} returns a tensor with shape {}!\"", ".", "format", "(", "\n", "item", ",", "m", ".", "shape", "\n", ")", "\n", "return", "BitMasks", "(", "m", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.BitMasks.__iter__": [[134, 136], ["None"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "yield", "from", "self", ".", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.BitMasks.__repr__": [[137, 141], ["len"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", "->", "str", ":", "\n", "        ", "s", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "s", "+=", "\"num_instances={})\"", ".", "format", "(", "len", "(", "self", ".", "tensor", ")", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.BitMasks.__len__": [[142, 144], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "self", ".", "tensor", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.BitMasks.nonempty": [[145, 154], ["masks.BitMasks.tensor.flatten().any", "masks.BitMasks.tensor.flatten"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten"], ["", "def", "nonempty", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Find masks that are non-empty.\n\n        Returns:\n            Tensor: a BoolTensor which represents\n                whether each mask is empty (False) or non-empty (True).\n        \"\"\"", "\n", "return", "self", ".", "tensor", ".", "flatten", "(", "1", ")", ".", "any", "(", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.BitMasks.from_polygon_masks": [[155, 168], ["isinstance", "masks.BitMasks", "masks.polygons_to_bitmask", "torch.stack", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.polygons_to_bitmask"], ["", "@", "staticmethod", "\n", "def", "from_polygon_masks", "(", "\n", "polygon_masks", ":", "Union", "[", "\"PolygonMasks\"", ",", "List", "[", "List", "[", "np", ".", "ndarray", "]", "]", "]", ",", "height", ":", "int", ",", "width", ":", "int", "\n", ")", "->", "\"BitMasks\"", ":", "\n", "        ", "\"\"\"\n        Args:\n            polygon_masks (list[list[ndarray]] or PolygonMasks)\n            height, width (int)\n        \"\"\"", "\n", "if", "isinstance", "(", "polygon_masks", ",", "PolygonMasks", ")", ":", "\n", "            ", "polygon_masks", "=", "polygon_masks", ".", "polygons", "\n", "", "masks", "=", "[", "polygons_to_bitmask", "(", "p", ",", "height", ",", "width", ")", "for", "p", "in", "polygon_masks", "]", "\n", "return", "BitMasks", "(", "torch", ".", "stack", "(", "[", "torch", ".", "from_numpy", "(", "x", ")", "for", "x", "in", "masks", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.BitMasks.crop_and_resize": [[169, 201], ["torch.cat", "masks.BitMasks.tensor.to", "rois.to.to.to", "detectron2.layers.roi_align.ROIAlign().forward().squeeze", "len", "len", "len", "len", "torch.arange().to", "detectron2.layers.roi_align.ROIAlign().forward", "torch.arange", "len", "detectron2.layers.roi_align.ROIAlign"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.forward"], ["", "def", "crop_and_resize", "(", "self", ",", "boxes", ":", "torch", ".", "Tensor", ",", "mask_size", ":", "int", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Crop each bitmask by the given box, and resize results to (mask_size, mask_size).\n        This can be used to prepare training targets for Mask R-CNN.\n        It has less reconstruction error compared to rasterization with polygons.\n        However we observe no difference in accuracy,\n        but BitMasks requires more memory to store all the masks.\n\n        Args:\n            boxes (Tensor): Nx4 tensor storing the boxes for each mask\n            mask_size (int): the size of the rasterized mask.\n\n        Returns:\n            Tensor:\n                A bool tensor of shape (N, mask_size, mask_size), where\n                N is the number of predicted boxes for this image.\n        \"\"\"", "\n", "assert", "len", "(", "boxes", ")", "==", "len", "(", "self", ")", ",", "\"{} != {}\"", ".", "format", "(", "len", "(", "boxes", ")", ",", "len", "(", "self", ")", ")", "\n", "device", "=", "self", ".", "tensor", ".", "device", "\n", "\n", "batch_inds", "=", "torch", ".", "arange", "(", "len", "(", "boxes", ")", ",", "device", "=", "device", ")", ".", "to", "(", "dtype", "=", "boxes", ".", "dtype", ")", "[", ":", ",", "None", "]", "\n", "rois", "=", "torch", ".", "cat", "(", "[", "batch_inds", ",", "boxes", "]", ",", "dim", "=", "1", ")", "# Nx5", "\n", "\n", "bit_masks", "=", "self", ".", "tensor", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", "\n", "rois", "=", "rois", ".", "to", "(", "device", "=", "device", ")", "\n", "output", "=", "(", "\n", "ROIAlign", "(", "(", "mask_size", ",", "mask_size", ")", ",", "1.0", ",", "0", ",", "aligned", "=", "True", ")", "\n", ".", "forward", "(", "bit_masks", "[", ":", ",", "None", ",", ":", ",", ":", "]", ",", "rois", ")", "\n", ".", "squeeze", "(", "1", ")", "\n", ")", "\n", "output", "=", "output", ">=", "0.5", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.BitMasks.get_bounding_boxes": [[202, 219], ["torch.zeros", "torch.any", "torch.any", "range", "torch.zeros.Boxes", "torch.where", "torch.where", "torch.as_tensor", "len", "len"], "methods", ["None"], ["", "def", "get_bounding_boxes", "(", "self", ")", "->", "Boxes", ":", "\n", "        ", "\"\"\"\n        Returns:\n            Boxes: tight bounding boxes around bitmasks.\n            If a mask is empty, it's bounding box will be all zero.\n        \"\"\"", "\n", "boxes", "=", "torch", ".", "zeros", "(", "self", ".", "tensor", ".", "shape", "[", "0", "]", ",", "4", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "x_any", "=", "torch", ".", "any", "(", "self", ".", "tensor", ",", "dim", "=", "1", ")", "\n", "y_any", "=", "torch", ".", "any", "(", "self", ".", "tensor", ",", "dim", "=", "2", ")", "\n", "for", "idx", "in", "range", "(", "self", ".", "tensor", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "x", "=", "torch", ".", "where", "(", "x_any", "[", "idx", ",", ":", "]", ")", "[", "0", "]", "\n", "y", "=", "torch", ".", "where", "(", "y_any", "[", "idx", ",", ":", "]", ")", "[", "0", "]", "\n", "if", "len", "(", "x", ")", ">", "0", "and", "len", "(", "y", ")", ">", "0", ":", "\n", "                ", "boxes", "[", "idx", ",", ":", "]", "=", "torch", ".", "as_tensor", "(", "\n", "[", "x", "[", "0", "]", ",", "y", "[", "0", "]", ",", "x", "[", "-", "1", "]", "+", "1", ",", "y", "[", "-", "1", "]", "+", "1", "]", ",", "dtype", "=", "torch", ".", "float32", "\n", ")", "\n", "", "", "return", "Boxes", "(", "boxes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.BitMasks.cat": [[220, 237], ["isinstance", "all", "len", "type", "torch.cat", "isinstance"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "@", "staticmethod", "\n", "def", "cat", "(", "bitmasks_list", ":", "List", "[", "\"BitMasks\"", "]", ")", "->", "\"BitMasks\"", ":", "\n", "        ", "\"\"\"\n        Concatenates a list of BitMasks into a single BitMasks\n\n        Arguments:\n            bitmasks_list (list[BitMasks])\n\n        Returns:\n            BitMasks: the concatenated BitMasks\n        \"\"\"", "\n", "assert", "isinstance", "(", "bitmasks_list", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "len", "(", "bitmasks_list", ")", ">", "0", "\n", "assert", "all", "(", "isinstance", "(", "bitmask", ",", "BitMasks", ")", "for", "bitmask", "in", "bitmasks_list", ")", "\n", "\n", "cat_bitmasks", "=", "type", "(", "bitmasks_list", "[", "0", "]", ")", "(", "torch", ".", "cat", "(", "[", "bm", ".", "tensor", "for", "bm", "in", "bitmasks_list", "]", ",", "dim", "=", "0", ")", ")", "\n", "return", "cat_bitmasks", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.PolygonMasks.__init__": [[247, 286], ["isinstance", "type", "isinstance", "numpy.asarray().astype", "isinstance", "masks.PolygonMasks.__init__.process_polygons"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "polygons", ":", "List", "[", "List", "[", "Union", "[", "torch", ".", "Tensor", ",", "np", ".", "ndarray", "]", "]", "]", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            polygons (list[list[np.ndarray]]): The first\n                level of the list correspond to individual instances,\n                the second level to all the polygons that compose the\n                instance, and the third level to the polygon coordinates.\n                The third level array should have the format of\n                [x0, y0, x1, y1, ..., xn, yn] (n >= 3).\n        \"\"\"", "\n", "assert", "isinstance", "(", "polygons", ",", "list", ")", ",", "(", "\n", "\"Cannot create PolygonMasks: Expect a list of list of polygons per image. \"", "\n", "\"Got '{}' instead.\"", ".", "format", "(", "type", "(", "polygons", ")", ")", "\n", ")", "\n", "\n", "def", "_make_array", "(", "t", ":", "Union", "[", "torch", ".", "Tensor", ",", "np", ".", "ndarray", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "# Use float64 for higher precision, because why not?", "\n", "# Always put polygons on CPU (self.to is a no-op) since they", "\n", "# are supposed to be small tensors.", "\n", "# May need to change this assumption if GPU placement becomes useful", "\n", "            ", "if", "isinstance", "(", "t", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "t", "=", "t", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "return", "np", ".", "asarray", "(", "t", ")", ".", "astype", "(", "\"float64\"", ")", "\n", "\n", "", "def", "process_polygons", "(", "\n", "polygons_per_instance", ":", "List", "[", "Union", "[", "torch", ".", "Tensor", ",", "np", ".", "ndarray", "]", "]", "\n", ")", "->", "List", "[", "np", ".", "ndarray", "]", ":", "\n", "            ", "assert", "isinstance", "(", "polygons_per_instance", ",", "list", ")", ",", "(", "\n", "\"Cannot create polygons: Expect a list of polygons per instance. \"", "\n", "\"Got '{}' instead.\"", ".", "format", "(", "type", "(", "polygons_per_instance", ")", ")", "\n", ")", "\n", "# transform the polygon to a tensor", "\n", "polygons_per_instance", "=", "[", "_make_array", "(", "p", ")", "for", "p", "in", "polygons_per_instance", "]", "\n", "for", "polygon", "in", "polygons_per_instance", ":", "\n", "                ", "assert", "len", "(", "polygon", ")", "%", "2", "==", "0", "and", "len", "(", "polygon", ")", ">=", "6", "\n", "", "return", "polygons_per_instance", "\n", "\n", "", "self", ".", "polygons", ":", "List", "[", "List", "[", "np", ".", "ndarray", "]", "]", "=", "[", "\n", "process_polygons", "(", "polygons_per_instance", ")", "for", "polygons_per_instance", "in", "polygons", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.PolygonMasks.to": [[288, 290], ["None"], "methods", ["None"], ["", "def", "to", "(", "self", ",", "*", "args", ":", "Any", ",", "**", "kwargs", ":", "Any", ")", "->", "\"PolygonMasks\"", ":", "\n", "        ", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.PolygonMasks.device": [[291, 294], ["torch.device"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", "->", "torch", ".", "device", ":", "\n", "        ", "return", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.PolygonMasks.get_bounding_boxes": [[295, 311], ["torch.zeros", "enumerate", "torch.zeros.Boxes", "len", "torch.as_tensor", "torch.zeros", "torch.from_numpy().view().to", "torch.min", "torch.max", "float", "float", "torch.from_numpy().view", "torch.min", "torch.max", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "get_bounding_boxes", "(", "self", ")", "->", "Boxes", ":", "\n", "        ", "\"\"\"\n        Returns:\n            Boxes: tight bounding boxes around polygon masks.\n        \"\"\"", "\n", "boxes", "=", "torch", ".", "zeros", "(", "len", "(", "self", ".", "polygons", ")", ",", "4", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "for", "idx", ",", "polygons_per_instance", "in", "enumerate", "(", "self", ".", "polygons", ")", ":", "\n", "            ", "minxy", "=", "torch", ".", "as_tensor", "(", "[", "float", "(", "\"inf\"", ")", ",", "float", "(", "\"inf\"", ")", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "maxxy", "=", "torch", ".", "zeros", "(", "2", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "for", "polygon", "in", "polygons_per_instance", ":", "\n", "                ", "coords", "=", "torch", ".", "from_numpy", "(", "polygon", ")", ".", "view", "(", "-", "1", ",", "2", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", "\n", "minxy", "=", "torch", ".", "min", "(", "minxy", ",", "torch", ".", "min", "(", "coords", ",", "dim", "=", "0", ")", ".", "values", ")", "\n", "maxxy", "=", "torch", ".", "max", "(", "maxxy", ",", "torch", ".", "max", "(", "coords", ",", "dim", "=", "0", ")", ".", "values", ")", "\n", "", "boxes", "[", "idx", ",", ":", "2", "]", "=", "minxy", "\n", "boxes", "[", "idx", ",", "2", ":", "]", "=", "maxxy", "\n", "", "return", "Boxes", "(", "boxes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.PolygonMasks.nonempty": [[312, 322], ["torch.from_numpy", "numpy.asarray", "len"], "methods", ["None"], ["", "def", "nonempty", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Find masks that are non-empty.\n\n        Returns:\n            Tensor:\n                a BoolTensor which represents whether each mask is empty (False) or not (True).\n        \"\"\"", "\n", "keep", "=", "[", "1", "if", "len", "(", "polygon", ")", ">", "0", "else", "0", "for", "polygon", "in", "self", ".", "polygons", "]", "\n", "return", "torch", ".", "from_numpy", "(", "np", ".", "asarray", "(", "keep", ",", "dtype", "=", "np", ".", "bool", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.PolygonMasks.__getitem__": [[323, 352], ["isinstance", "masks.PolygonMasks", "isinstance", "isinstance", "isinstance", "item.cpu().numpy().tolist.cpu().numpy().tolist.nonzero().squeeze().cpu().numpy().tolist", "item.cpu().numpy().tolist.cpu().numpy().tolist.dim", "item.cpu().numpy().tolist.cpu().numpy().tolist.cpu().numpy().tolist", "ValueError", "item.cpu().numpy().tolist.cpu().numpy().tolist.nonzero().squeeze().cpu().numpy", "item.cpu().numpy().tolist.cpu().numpy().tolist.cpu().numpy", "item.cpu().numpy().tolist.cpu().numpy().tolist.nonzero().squeeze().cpu", "item.cpu().numpy().tolist.cpu().numpy().tolist.cpu", "item.cpu().numpy().tolist.cpu().numpy().tolist.nonzero().squeeze", "item.cpu().numpy().tolist.cpu().numpy().tolist.nonzero"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ":", "Union", "[", "int", ",", "slice", ",", "List", "[", "int", "]", ",", "torch", ".", "BoolTensor", "]", ")", "->", "\"PolygonMasks\"", ":", "\n", "        ", "\"\"\"\n        Support indexing over the instances and return a `PolygonMasks` object.\n        `item` can be:\n\n        1. An integer. It will return an object with only one instance.\n        2. A slice. It will return an object with the selected instances.\n        3. A list[int]. It will return an object with the selected instances,\n           correpsonding to the indices in the list.\n        4. A vector mask of type BoolTensor, whose length is num_instances.\n           It will return an object with the instances whose mask is nonzero.\n        \"\"\"", "\n", "if", "isinstance", "(", "item", ",", "int", ")", ":", "\n", "            ", "selected_polygons", "=", "[", "self", ".", "polygons", "[", "item", "]", "]", "\n", "", "elif", "isinstance", "(", "item", ",", "slice", ")", ":", "\n", "            ", "selected_polygons", "=", "self", ".", "polygons", "[", "item", "]", "\n", "", "elif", "isinstance", "(", "item", ",", "list", ")", ":", "\n", "            ", "selected_polygons", "=", "[", "self", ".", "polygons", "[", "i", "]", "for", "i", "in", "item", "]", "\n", "", "elif", "isinstance", "(", "item", ",", "torch", ".", "Tensor", ")", ":", "\n", "# Polygons is a list, so we have to move the indices back to CPU.", "\n", "            ", "if", "item", ".", "dtype", "==", "torch", ".", "bool", ":", "\n", "                ", "assert", "item", ".", "dim", "(", ")", "==", "1", ",", "item", ".", "shape", "\n", "item", "=", "item", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "", "elif", "item", ".", "dtype", "in", "[", "torch", ".", "int32", ",", "torch", ".", "int64", "]", ":", "\n", "                ", "item", "=", "item", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\"Unsupported tensor dtype={} for indexing!\"", ".", "format", "(", "item", ".", "dtype", ")", ")", "\n", "", "selected_polygons", "=", "[", "self", ".", "polygons", "[", "i", "]", "for", "i", "in", "item", "]", "\n", "", "return", "PolygonMasks", "(", "selected_polygons", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.PolygonMasks.__iter__": [[353, 360], ["iter"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.iter"], ["", "def", "__iter__", "(", "self", ")", "->", "Iterator", "[", "List", "[", "np", ".", "ndarray", "]", "]", ":", "\n", "        ", "\"\"\"\n        Yields:\n            list[ndarray]: the polygons for one instance.\n            Each Tensor is a float64 vector representing a polygon.\n        \"\"\"", "\n", "return", "iter", "(", "self", ".", "polygons", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.PolygonMasks.__repr__": [[361, 365], ["len"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", "->", "str", ":", "\n", "        ", "s", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "s", "+=", "\"num_instances={})\"", ".", "format", "(", "len", "(", "self", ".", "polygons", ")", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.PolygonMasks.__len__": [[366, 368], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "len", "(", "self", ".", "polygons", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.PolygonMasks.crop_and_resize": [[369, 400], ["boxes.to.to.to", "torch.stack().to", "len", "len", "len", "len", "torch.device", "masks.rasterize_polygons_within_box", "len", "torch.empty", "box.numpy", "zip", "torch.stack"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.rasterize_polygons_within_box"], ["", "def", "crop_and_resize", "(", "self", ",", "boxes", ":", "torch", ".", "Tensor", ",", "mask_size", ":", "int", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Crop each mask by the given box, and resize results to (mask_size, mask_size).\n        This can be used to prepare training targets for Mask R-CNN.\n\n        Args:\n            boxes (Tensor): Nx4 tensor storing the boxes for each mask\n            mask_size (int): the size of the rasterized mask.\n\n        Returns:\n            Tensor: A bool tensor of shape (N, mask_size, mask_size), where\n            N is the number of predicted boxes for this image.\n        \"\"\"", "\n", "assert", "len", "(", "boxes", ")", "==", "len", "(", "self", ")", ",", "\"{} != {}\"", ".", "format", "(", "len", "(", "boxes", ")", ",", "len", "(", "self", ")", ")", "\n", "\n", "device", "=", "boxes", ".", "device", "\n", "# Put boxes on the CPU, as the polygon representation is not efficient GPU-wise", "\n", "# (several small tensors for representing a single instance mask)", "\n", "boxes", "=", "boxes", ".", "to", "(", "torch", ".", "device", "(", "\"cpu\"", ")", ")", "\n", "\n", "results", "=", "[", "\n", "rasterize_polygons_within_box", "(", "poly", ",", "box", ".", "numpy", "(", ")", ",", "mask_size", ")", "\n", "for", "poly", ",", "box", "in", "zip", "(", "self", ".", "polygons", ",", "boxes", ")", "\n", "]", "\n", "\"\"\"\n        poly: list[list[float]], the polygons for one instance\n        box: a tensor of shape (4,)\n        \"\"\"", "\n", "if", "len", "(", "results", ")", "==", "0", ":", "\n", "            ", "return", "torch", ".", "empty", "(", "0", ",", "mask_size", ",", "mask_size", ",", "dtype", "=", "torch", ".", "bool", ",", "device", "=", "device", ")", "\n", "", "return", "torch", ".", "stack", "(", "results", ",", "dim", "=", "0", ")", ".", "to", "(", "device", "=", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.PolygonMasks.area": [[401, 419], ["torch.tensor", "area.append", "masks.polygon_area"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.polygon_area"], ["", "def", "area", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Computes area of the mask.\n        Only works with Polygons, using the shoelace formula:\n        https://stackoverflow.com/questions/24467972/calculate-area-of-polygon-given-x-y-coordinates\n\n        Returns:\n            Tensor: a vector, area for each instance\n        \"\"\"", "\n", "\n", "area", "=", "[", "]", "\n", "for", "polygons_per_instance", "in", "self", ".", "polygons", ":", "\n", "            ", "area_per_instance", "=", "0", "\n", "for", "p", "in", "polygons_per_instance", ":", "\n", "                ", "area_per_instance", "+=", "polygon_area", "(", "p", "[", "0", ":", ":", "2", "]", ",", "p", "[", "1", ":", ":", "2", "]", ")", "\n", "", "area", ".", "append", "(", "area_per_instance", ")", "\n", "\n", "", "return", "torch", ".", "tensor", "(", "area", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.PolygonMasks.cat": [[420, 439], ["isinstance", "all", "len", "type", "list", "isinstance", "itertools.chain.from_iterable"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "cat", "(", "polymasks_list", ":", "List", "[", "\"PolygonMasks\"", "]", ")", "->", "\"PolygonMasks\"", ":", "\n", "        ", "\"\"\"\n        Concatenates a list of PolygonMasks into a single PolygonMasks\n\n        Arguments:\n            polymasks_list (list[PolygonMasks])\n\n        Returns:\n            PolygonMasks: the concatenated PolygonMasks\n        \"\"\"", "\n", "assert", "isinstance", "(", "polymasks_list", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "len", "(", "polymasks_list", ")", ">", "0", "\n", "assert", "all", "(", "isinstance", "(", "polymask", ",", "PolygonMasks", ")", "for", "polymask", "in", "polymasks_list", ")", "\n", "\n", "cat_polymasks", "=", "type", "(", "polymasks_list", "[", "0", "]", ")", "(", "\n", "list", "(", "itertools", ".", "chain", ".", "from_iterable", "(", "pm", ".", "polygons", "for", "pm", "in", "polymasks_list", ")", ")", "\n", ")", "\n", "return", "cat_polymasks", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.polygon_area": [[14, 18], ["numpy.abs", "numpy.dot", "numpy.dot", "numpy.roll", "numpy.roll"], "function", ["None"], ["def", "polygon_area", "(", "x", ",", "y", ")", ":", "\n", "# Using the shoelace formula", "\n", "# https://stackoverflow.com/questions/24467972/calculate-area-of-polygon-given-x-y-coordinates", "\n", "    ", "return", "0.5", "*", "np", ".", "abs", "(", "np", ".", "dot", "(", "x", ",", "np", ".", "roll", "(", "y", ",", "1", ")", ")", "-", "np", ".", "dot", "(", "y", ",", "np", ".", "roll", "(", "x", ",", "1", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.polygons_to_bitmask": [[20, 33], ["pycocotools.frPyObjects", "pycocotools.merge", "pycocotools.decode().astype", "len", "pycocotools.decode"], "function", ["None"], ["", "def", "polygons_to_bitmask", "(", "polygons", ":", "List", "[", "np", ".", "ndarray", "]", ",", "height", ":", "int", ",", "width", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Args:\n        polygons (list[ndarray]): each array has shape (Nx2,)\n        height, width (int)\n\n    Returns:\n        ndarray: a bool mask of shape (height, width)\n    \"\"\"", "\n", "assert", "len", "(", "polygons", ")", ">", "0", ",", "\"COCOAPI does not support empty polygons\"", "\n", "rles", "=", "mask_util", ".", "frPyObjects", "(", "polygons", ",", "height", ",", "width", ")", "\n", "rle", "=", "mask_util", ".", "merge", "(", "rles", ")", "\n", "return", "mask_util", ".", "decode", "(", "rle", ")", ".", "astype", "(", "np", ".", "bool", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.rasterize_polygons_within_box": [[35, 82], ["copy.deepcopy", "masks.polygons_to_bitmask", "torch.from_numpy", "max", "max"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.polygons_to_bitmask"], ["", "def", "rasterize_polygons_within_box", "(", "\n", "polygons", ":", "List", "[", "np", ".", "ndarray", "]", ",", "box", ":", "np", ".", "ndarray", ",", "mask_size", ":", "int", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Rasterize the polygons into a mask image and\n    crop the mask content in the given box.\n    The cropped mask is resized to (mask_size, mask_size).\n\n    This function is used when generating training targets for mask head in Mask R-CNN.\n    Given original ground-truth masks for an image, new ground-truth mask\n    training targets in the size of `mask_size x mask_size`\n    must be provided for each predicted box. This function will be called to\n    produce such targets.\n\n    Args:\n        polygons (list[ndarray[float]]): a list of polygons, which represents an instance.\n        box: 4-element numpy array\n        mask_size (int):\n\n    Returns:\n        Tensor: BoolTensor of shape (mask_size, mask_size)\n    \"\"\"", "\n", "# 1. Shift the polygons w.r.t the boxes", "\n", "w", ",", "h", "=", "box", "[", "2", "]", "-", "box", "[", "0", "]", ",", "box", "[", "3", "]", "-", "box", "[", "1", "]", "\n", "\n", "polygons", "=", "copy", ".", "deepcopy", "(", "polygons", ")", "\n", "for", "p", "in", "polygons", ":", "\n", "        ", "p", "[", "0", ":", ":", "2", "]", "=", "p", "[", "0", ":", ":", "2", "]", "-", "box", "[", "0", "]", "\n", "p", "[", "1", ":", ":", "2", "]", "=", "p", "[", "1", ":", ":", "2", "]", "-", "box", "[", "1", "]", "\n", "\n", "# 2. Rescale the polygons to the new box size", "\n", "# max() to avoid division by small number", "\n", "", "ratio_h", "=", "mask_size", "/", "max", "(", "h", ",", "0.1", ")", "\n", "ratio_w", "=", "mask_size", "/", "max", "(", "w", ",", "0.1", ")", "\n", "\n", "if", "ratio_h", "==", "ratio_w", ":", "\n", "        ", "for", "p", "in", "polygons", ":", "\n", "            ", "p", "*=", "ratio_h", "\n", "", "", "else", ":", "\n", "        ", "for", "p", "in", "polygons", ":", "\n", "            ", "p", "[", "0", ":", ":", "2", "]", "*=", "ratio_w", "\n", "p", "[", "1", ":", ":", "2", "]", "*=", "ratio_h", "\n", "\n", "# 3. Rasterize the polygons with coco api", "\n", "", "", "mask", "=", "polygons_to_bitmask", "(", "polygons", ",", "mask_size", ",", "mask_size", ")", "\n", "mask", "=", "torch", ".", "from_numpy", "(", "mask", ")", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.BoxMode.convert": [[43, 131], ["type", "isinstance", "isinstance", "torch.cat().to.double", "torch.abs", "torch.abs", "arr[].to", "type.", "torch.cat().to.numpy", "torch.tensor", "torch.from_numpy().clone", "box.clone", "torch.cos", "torch.sin", "torch.cat().to.double", "torch.zeros", "torch.cat().to", "torch.cat().to.flatten().tolist", "len", "len", "torch.from_numpy", "torch.cat", "NotImplementedError", "torch.cat().to.flatten", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten"], ["@", "staticmethod", "\n", "def", "convert", "(", "box", ":", "_RawBoxType", ",", "from_mode", ":", "\"BoxMode\"", ",", "to_mode", ":", "\"BoxMode\"", ")", "->", "_RawBoxType", ":", "\n", "        ", "\"\"\"\n        Args:\n            box: can be a k-tuple, k-list or an Nxk array/tensor, where k = 4 or 5\n            from_mode, to_mode (BoxMode)\n\n        Returns:\n            The converted box of the same type.\n        \"\"\"", "\n", "if", "from_mode", "==", "to_mode", ":", "\n", "            ", "return", "box", "\n", "\n", "", "original_type", "=", "type", "(", "box", ")", "\n", "is_numpy", "=", "isinstance", "(", "box", ",", "np", ".", "ndarray", ")", "\n", "single_box", "=", "isinstance", "(", "box", ",", "(", "list", ",", "tuple", ")", ")", "\n", "if", "single_box", ":", "\n", "            ", "assert", "len", "(", "box", ")", "==", "4", "or", "len", "(", "box", ")", "==", "5", ",", "(", "\n", "\"BoxMode.convert takes either a k-tuple/list or an Nxk array/tensor,\"", "\n", "\" where k == 4 or 5\"", "\n", ")", "\n", "arr", "=", "torch", ".", "tensor", "(", "box", ")", "[", "None", ",", ":", "]", "\n", "", "else", ":", "\n", "# avoid modifying the input box", "\n", "            ", "if", "is_numpy", ":", "\n", "                ", "arr", "=", "torch", ".", "from_numpy", "(", "np", ".", "asarray", "(", "box", ")", ")", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "                ", "arr", "=", "box", ".", "clone", "(", ")", "\n", "\n", "", "", "assert", "to_mode", ".", "value", "not", "in", "[", "\n", "BoxMode", ".", "XYXY_REL", ",", "\n", "BoxMode", ".", "XYWH_REL", ",", "\n", "]", "and", "from_mode", ".", "value", "not", "in", "[", "\n", "BoxMode", ".", "XYXY_REL", ",", "\n", "BoxMode", ".", "XYWH_REL", ",", "\n", "]", ",", "\"Relative mode not yet supported!\"", "\n", "\n", "if", "from_mode", "==", "BoxMode", ".", "XYWHA_ABS", "and", "to_mode", "==", "BoxMode", ".", "XYXY_ABS", ":", "\n", "            ", "assert", "(", "\n", "arr", ".", "shape", "[", "-", "1", "]", "==", "5", "\n", ")", ",", "\"The last dimension of input shape must be 5 for XYWHA format\"", "\n", "original_dtype", "=", "arr", ".", "dtype", "\n", "arr", "=", "arr", ".", "double", "(", ")", "\n", "\n", "w", "=", "arr", "[", ":", ",", "2", "]", "\n", "h", "=", "arr", "[", ":", ",", "3", "]", "\n", "a", "=", "arr", "[", ":", ",", "4", "]", "\n", "c", "=", "torch", ".", "abs", "(", "torch", ".", "cos", "(", "a", "*", "math", ".", "pi", "/", "180.0", ")", ")", "\n", "s", "=", "torch", ".", "abs", "(", "torch", ".", "sin", "(", "a", "*", "math", ".", "pi", "/", "180.0", ")", ")", "\n", "# This basically computes the horizontal bounding rectangle of the rotated box", "\n", "new_w", "=", "c", "*", "w", "+", "s", "*", "h", "\n", "new_h", "=", "c", "*", "h", "+", "s", "*", "w", "\n", "\n", "# convert center to top-left corner", "\n", "arr", "[", ":", ",", "0", "]", "-=", "new_w", "/", "2.0", "\n", "arr", "[", ":", ",", "1", "]", "-=", "new_h", "/", "2.0", "\n", "# bottom-right corner", "\n", "arr", "[", ":", ",", "2", "]", "=", "arr", "[", ":", ",", "0", "]", "+", "new_w", "\n", "arr", "[", ":", ",", "3", "]", "=", "arr", "[", ":", ",", "1", "]", "+", "new_h", "\n", "\n", "arr", "=", "arr", "[", ":", ",", ":", "4", "]", ".", "to", "(", "dtype", "=", "original_dtype", ")", "\n", "", "elif", "from_mode", "==", "BoxMode", ".", "XYWH_ABS", "and", "to_mode", "==", "BoxMode", ".", "XYWHA_ABS", ":", "\n", "            ", "original_dtype", "=", "arr", ".", "dtype", "\n", "arr", "=", "arr", ".", "double", "(", ")", "\n", "arr", "[", ":", ",", "0", "]", "+=", "arr", "[", ":", ",", "2", "]", "/", "2.0", "\n", "arr", "[", ":", ",", "1", "]", "+=", "arr", "[", ":", ",", "3", "]", "/", "2.0", "\n", "angles", "=", "torch", ".", "zeros", "(", "(", "arr", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "dtype", "=", "arr", ".", "dtype", ")", "\n", "arr", "=", "torch", ".", "cat", "(", "(", "arr", ",", "angles", ")", ",", "axis", "=", "1", ")", ".", "to", "(", "dtype", "=", "original_dtype", ")", "\n", "", "else", ":", "\n", "            ", "if", "to_mode", "==", "BoxMode", ".", "XYXY_ABS", "and", "from_mode", "==", "BoxMode", ".", "XYWH_ABS", ":", "\n", "                ", "arr", "[", ":", ",", "2", "]", "+=", "arr", "[", ":", ",", "0", "]", "\n", "arr", "[", ":", ",", "3", "]", "+=", "arr", "[", ":", ",", "1", "]", "\n", "", "elif", "from_mode", "==", "BoxMode", ".", "XYXY_ABS", "and", "to_mode", "==", "BoxMode", ".", "XYWH_ABS", ":", "\n", "                ", "arr", "[", ":", ",", "2", "]", "-=", "arr", "[", ":", ",", "0", "]", "\n", "arr", "[", ":", ",", "3", "]", "-=", "arr", "[", ":", ",", "1", "]", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "(", "\n", "\"Conversion from BoxMode {} to {} is not supported yet\"", ".", "format", "(", "\n", "from_mode", ",", "to_mode", "\n", ")", "\n", ")", "\n", "\n", "", "", "if", "single_box", ":", "\n", "            ", "return", "original_type", "(", "arr", ".", "flatten", "(", ")", ".", "tolist", "(", ")", ")", "\n", "", "if", "is_numpy", ":", "\n", "            ", "return", "arr", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "            ", "return", "arr", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.__init__": [[145, 159], ["torch.as_tensor", "tensor.reshape().to.reshape().to.size", "isinstance", "torch.device", "tensor.reshape().to.reshape().to.numel", "tensor.reshape().to.reshape().to.reshape().to", "tensor.reshape().to.reshape().to.dim", "tensor.reshape().to.reshape().to.size", "tensor.reshape().to.reshape().to.reshape"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["def", "__init__", "(", "self", ",", "tensor", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            tensor (Tensor[float]): a Nx4 matrix.  Each row is (x1, y1, x2, y2).\n        \"\"\"", "\n", "device", "=", "tensor", ".", "device", "if", "isinstance", "(", "tensor", ",", "torch", ".", "Tensor", ")", "else", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "tensor", "=", "torch", ".", "as_tensor", "(", "tensor", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "if", "tensor", ".", "numel", "(", ")", "==", "0", ":", "\n", "# Use reshape, so we don't end up creating a new tensor that does not depend on", "\n", "# the inputs (and consequently confuses jit)", "\n", "            ", "tensor", "=", "tensor", ".", "reshape", "(", "(", "0", ",", "4", ")", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "", "assert", "tensor", ".", "dim", "(", ")", "==", "2", "and", "tensor", ".", "size", "(", "-", "1", ")", "==", "4", ",", "tensor", ".", "size", "(", ")", "\n", "\n", "self", ".", "tensor", "=", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone": [[160, 168], ["boxes.Boxes", "boxes.Boxes.tensor.clone"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone"], ["", "def", "clone", "(", "self", ")", "->", "\"Boxes\"", ":", "\n", "        ", "\"\"\"\n        Clone the Boxes.\n\n        Returns:\n            Boxes\n        \"\"\"", "\n", "return", "Boxes", "(", "self", ".", "tensor", ".", "clone", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to": [[169, 172], ["boxes.Boxes", "boxes.Boxes.tensor.to"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "@", "torch", ".", "jit", ".", "unused", "\n", "def", "to", "(", "self", ",", "*", "args", ":", "Any", ",", "**", "kwargs", ":", "Any", ")", ":", "\n", "        ", "return", "Boxes", "(", "self", ".", "tensor", ".", "to", "(", "*", "args", ",", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.area": [[173, 183], ["None"], "methods", ["None"], ["", "def", "area", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Computes the area of all the boxes.\n\n        Returns:\n            torch.Tensor: a vector with areas of each box.\n        \"\"\"", "\n", "box", "=", "self", ".", "tensor", "\n", "area", "=", "(", "box", "[", ":", ",", "2", "]", "-", "box", "[", ":", ",", "0", "]", ")", "*", "(", "box", "[", ":", ",", "3", "]", "-", "box", "[", ":", ",", "1", "]", ")", "\n", "return", "area", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clip": [[184, 198], ["torch.isfinite().all", "boxes.Boxes.tensor[].clamp_", "boxes.Boxes.tensor[].clamp_", "boxes.Boxes.tensor[].clamp_", "boxes.Boxes.tensor[].clamp_", "torch.isfinite"], "methods", ["None"], ["", "def", "clip", "(", "self", ",", "box_size", ":", "Tuple", "[", "int", ",", "int", "]", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Clip (in place) the boxes by limiting x coordinates to the range [0, width]\n        and y coordinates to the range [0, height].\n\n        Args:\n            box_size (height, width): The clipping box's size.\n        \"\"\"", "\n", "assert", "torch", ".", "isfinite", "(", "self", ".", "tensor", ")", ".", "all", "(", ")", ",", "\"Box tensor contains infinite or NaN!\"", "\n", "h", ",", "w", "=", "box_size", "\n", "self", ".", "tensor", "[", ":", ",", "0", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "w", ")", "\n", "self", ".", "tensor", "[", ":", ",", "1", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "h", ")", "\n", "self", ".", "tensor", "[", ":", ",", "2", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "w", ")", "\n", "self", ".", "tensor", "[", ":", ",", "3", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "h", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.nonempty": [[199, 214], ["None"], "methods", ["None"], ["", "def", "nonempty", "(", "self", ",", "threshold", ":", "float", "=", "0.0", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Find boxes that are non-empty.\n        A box is considered empty, if either of its side is no larger than threshold.\n\n        Returns:\n            Tensor:\n                a binary vector which represents whether each box is empty\n                (False) or non-empty (True).\n        \"\"\"", "\n", "box", "=", "self", ".", "tensor", "\n", "widths", "=", "box", "[", ":", ",", "2", "]", "-", "box", "[", ":", ",", "0", "]", "\n", "heights", "=", "box", "[", ":", ",", "3", "]", "-", "box", "[", ":", ",", "1", "]", "\n", "keep", "=", "(", "widths", ">", "threshold", ")", "&", "(", "heights", ">", "threshold", ")", "\n", "return", "keep", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.__getitem__": [[215, 238], ["isinstance", "boxes.Boxes", "boxes.Boxes", "b.dim", "boxes.Boxes.tensor[].view"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            item: int, slice, or a BoolTensor\n\n        Returns:\n            Boxes: Create a new :class:`Boxes` by indexing.\n\n        The following usage are allowed:\n\n        1. `new_boxes = boxes[3]`: return a `Boxes` which contains only one box.\n        2. `new_boxes = boxes[2:10]`: return a slice of boxes.\n        3. `new_boxes = boxes[vector]`, where vector is a torch.BoolTensor\n           with `length = len(boxes)`. Nonzero elements in the vector will be selected.\n\n        Note that the returned Boxes might share storage with this Boxes,\n        subject to Pytorch's indexing semantics.\n        \"\"\"", "\n", "if", "isinstance", "(", "item", ",", "int", ")", ":", "\n", "            ", "return", "Boxes", "(", "self", ".", "tensor", "[", "item", "]", ".", "view", "(", "1", ",", "-", "1", ")", ")", "\n", "", "b", "=", "self", ".", "tensor", "[", "item", "]", "\n", "assert", "b", ".", "dim", "(", ")", "==", "2", ",", "\"Indexing on Boxes with {} failed to return a matrix!\"", ".", "format", "(", "item", ")", "\n", "return", "Boxes", "(", "b", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.__len__": [[239, 241], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "self", ".", "tensor", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.__repr__": [[242, 244], ["str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "\"Boxes(\"", "+", "str", "(", "self", ".", "tensor", ")", "+", "\")\"", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.inside_box": [[245, 263], ["None"], "methods", ["None"], ["", "def", "inside_box", "(", "self", ",", "box_size", ":", "Tuple", "[", "int", ",", "int", "]", ",", "boundary_threshold", ":", "int", "=", "0", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Args:\n            box_size (height, width): Size of the reference box.\n            boundary_threshold (int): Boxes that extend beyond the reference box\n                boundary by more than boundary_threshold are considered \"outside\".\n\n        Returns:\n            a binary vector, indicating whether each box is inside the reference box.\n        \"\"\"", "\n", "height", ",", "width", "=", "box_size", "\n", "inds_inside", "=", "(", "\n", "(", "self", ".", "tensor", "[", "...", ",", "0", "]", ">=", "-", "boundary_threshold", ")", "\n", "&", "(", "self", ".", "tensor", "[", "...", ",", "1", "]", ">=", "-", "boundary_threshold", ")", "\n", "&", "(", "self", ".", "tensor", "[", "...", ",", "2", "]", "<", "width", "+", "boundary_threshold", ")", "\n", "&", "(", "self", ".", "tensor", "[", "...", ",", "3", "]", "<", "height", "+", "boundary_threshold", ")", "\n", ")", "\n", "return", "inds_inside", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.get_centers": [[264, 270], ["None"], "methods", ["None"], ["", "def", "get_centers", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Returns:\n            The box centers in a Nx2 array of (x, y).\n        \"\"\"", "\n", "return", "(", "self", ".", "tensor", "[", ":", ",", ":", "2", "]", "+", "self", ".", "tensor", "[", ":", ",", "2", ":", "]", ")", "/", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.scale": [[271, 277], ["None"], "methods", ["None"], ["", "def", "scale", "(", "self", ",", "scale_x", ":", "float", ",", "scale_y", ":", "float", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Scale the box with horizontal and vertical scaling factors\n        \"\"\"", "\n", "self", ".", "tensor", "[", ":", ",", "0", ":", ":", "2", "]", "*=", "scale_x", "\n", "self", ".", "tensor", "[", ":", ",", "1", ":", ":", "2", "]", "*=", "scale_y", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.cat": [[278, 305], ["torch.jit.is_scripting", "isinstance", "all", "cls", "len", "cls", "torch.cat", "torch.empty", "isinstance"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "@", "classmethod", "\n", "def", "cat", "(", "cls", ",", "boxes_list", ":", "List", "[", "\"Boxes\"", "]", ")", "->", "\"Boxes\"", ":", "\n", "        ", "\"\"\"\n        Concatenates a list of Boxes into a single Boxes\n\n        Arguments:\n            boxes_list (list[Boxes])\n\n        Returns:\n            Boxes: the concatenated Boxes\n        \"\"\"", "\n", "if", "torch", ".", "jit", ".", "is_scripting", "(", ")", ":", "\n", "# https://github.com/pytorch/pytorch/issues/18627", "\n", "# 1. staticmethod can be used in torchscript, But we can not use", "\n", "# `type(boxes).staticmethod` because torchscript only supports function", "\n", "# `type` with input type `torch.Tensor`.", "\n", "# 2. classmethod is not fully supported by torchscript. We explicitly assign", "\n", "# cls to Box as a workaround to get torchscript support.", "\n", "            ", "cls", "=", "Boxes", "\n", "", "assert", "isinstance", "(", "boxes_list", ",", "(", "list", ",", "tuple", ")", ")", "\n", "if", "len", "(", "boxes_list", ")", "==", "0", ":", "\n", "            ", "return", "cls", "(", "torch", ".", "empty", "(", "0", ")", ")", "\n", "", "assert", "all", "(", "[", "isinstance", "(", "box", ",", "Boxes", ")", "for", "box", "in", "boxes_list", "]", ")", "\n", "\n", "# use torch.cat (v.s. layers.cat) so the returned boxes never share storage with input", "\n", "cat_boxes", "=", "cls", "(", "torch", ".", "cat", "(", "[", "b", ".", "tensor", "for", "b", "in", "boxes_list", "]", ",", "dim", "=", "0", ")", ")", "\n", "return", "cat_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.device": [[306, 309], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", "->", "device", ":", "\n", "        ", "return", "self", ".", "tensor", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.__iter__": [[312, 318], ["None"], "methods", ["None"], ["", "@", "torch", ".", "jit", ".", "unused", "\n", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Yield a box as a Tensor of shape (4,) at a time.\n        \"\"\"", "\n", "yield", "from", "self", ".", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.pairwise_intersection": [[320, 340], ["width_height.clamp_", "width_height.prod", "torch.min", "torch.max"], "function", ["None"], ["", "", "def", "pairwise_intersection", "(", "boxes1", ":", "Boxes", ",", "boxes2", ":", "Boxes", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Given two lists of boxes of size N and M,\n    compute the intersection area between __all__ N x M pairs of boxes.\n    The box order must be (xmin, ymin, xmax, ymax)\n\n    Args:\n        boxes1,boxes2 (Boxes): two `Boxes`. Contains N & M boxes, respectively.\n\n    Returns:\n        Tensor: intersection, sized [N,M].\n    \"\"\"", "\n", "boxes1", ",", "boxes2", "=", "boxes1", ".", "tensor", ",", "boxes2", ".", "tensor", "\n", "width_height", "=", "torch", ".", "min", "(", "boxes1", "[", ":", ",", "None", ",", "2", ":", "]", ",", "boxes2", "[", ":", ",", "2", ":", "]", ")", "-", "torch", ".", "max", "(", "\n", "boxes1", "[", ":", ",", "None", ",", ":", "2", "]", ",", "boxes2", "[", ":", ",", ":", "2", "]", "\n", ")", "# [N,M,2]", "\n", "\n", "width_height", ".", "clamp_", "(", "min", "=", "0", ")", "# [N,M,2]", "\n", "intersection", "=", "width_height", ".", "prod", "(", "dim", "=", "2", ")", "# [N,M]", "\n", "return", "intersection", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.pairwise_iou": [[344, 367], ["boxes1.area", "boxes2.area", "boxes.pairwise_intersection", "torch.where", "torch.zeros"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.pairwise_intersection"], ["", "def", "pairwise_iou", "(", "boxes1", ":", "Boxes", ",", "boxes2", ":", "Boxes", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Given two lists of boxes of size N and M,\n    compute the IoU (intersection over union)\n    between __all__ N x M pairs of boxes.\n    The box order must be (xmin, ymin, xmax, ymax).\n    Args:\n        boxes1,boxes2 (Boxes): two `Boxes`. Contains N & M boxes, respectively.\n\n    Returns:\n        Tensor: IoU, sized [N,M].\n    \"\"\"", "\n", "area1", "=", "boxes1", ".", "area", "(", ")", "# [N]", "\n", "area2", "=", "boxes2", ".", "area", "(", ")", "# [M]", "\n", "inter", "=", "pairwise_intersection", "(", "boxes1", ",", "boxes2", ")", "\n", "\n", "# handle empty boxes", "\n", "iou", "=", "torch", ".", "where", "(", "\n", "inter", ">", "0", ",", "\n", "inter", "/", "(", "area1", "[", ":", ",", "None", "]", "+", "area2", "-", "inter", ")", ",", "\n", "torch", ".", "zeros", "(", "1", ",", "dtype", "=", "inter", ".", "dtype", ",", "device", "=", "inter", ".", "device", ")", ",", "\n", ")", "\n", "return", "iou", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.pairwise_ioa": [[369, 387], ["boxes2.area", "boxes.pairwise_intersection", "torch.where", "torch.zeros"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.pairwise_intersection"], ["", "def", "pairwise_ioa", "(", "boxes1", ":", "Boxes", ",", "boxes2", ":", "Boxes", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Similar to pariwise_iou but compute the IoA (intersection over boxes2 area).\n\n    Args:\n        boxes1,boxes2 (Boxes): two `Boxes`. Contains N & M boxes, respectively.\n\n    Returns:\n        Tensor: IoA, sized [N,M].\n    \"\"\"", "\n", "area2", "=", "boxes2", ".", "area", "(", ")", "# [M]", "\n", "inter", "=", "pairwise_intersection", "(", "boxes1", ",", "boxes2", ")", "\n", "\n", "# handle empty boxes", "\n", "ioa", "=", "torch", ".", "where", "(", "\n", "inter", ">", "0", ",", "inter", "/", "area2", ",", "torch", ".", "zeros", "(", "1", ",", "dtype", "=", "inter", ".", "dtype", ",", "device", "=", "inter", ".", "device", ")", "\n", ")", "\n", "return", "ioa", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.matched_boxlist_iou": [[389, 415], ["boxes1.area", "boxes2.area", "torch.max", "torch.min", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.area"], ["", "def", "matched_boxlist_iou", "(", "boxes1", ":", "Boxes", ",", "boxes2", ":", "Boxes", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Compute pairwise intersection over union (IOU) of two sets of matched\n    boxes. The box order must be (xmin, ymin, xmax, ymax).\n    Similar to boxlist_iou, but computes only diagonal elements of the matrix\n\n    Args:\n        boxes1: (Boxes) bounding boxes, sized [N,4].\n        boxes2: (Boxes) bounding boxes, sized [N,4].\n    Returns:\n        Tensor: iou, sized [N].\n    \"\"\"", "\n", "assert", "len", "(", "boxes1", ")", "==", "len", "(", "\n", "boxes2", "\n", ")", ",", "\"boxlists should have the same\"", "\"number of entries, got {}, {}\"", ".", "format", "(", "\n", "len", "(", "boxes1", ")", ",", "len", "(", "boxes2", ")", "\n", ")", "\n", "area1", "=", "boxes1", ".", "area", "(", ")", "# [N]", "\n", "area2", "=", "boxes2", ".", "area", "(", ")", "# [N]", "\n", "box1", ",", "box2", "=", "boxes1", ".", "tensor", ",", "boxes2", ".", "tensor", "\n", "lt", "=", "torch", ".", "max", "(", "box1", "[", ":", ",", ":", "2", "]", ",", "box2", "[", ":", ",", ":", "2", "]", ")", "# [N,2]", "\n", "rb", "=", "torch", ".", "min", "(", "box1", "[", ":", ",", "2", ":", "]", ",", "box2", "[", ":", ",", "2", ":", "]", ")", "# [N,2]", "\n", "wh", "=", "(", "rb", "-", "lt", ")", ".", "clamp", "(", "min", "=", "0", ")", "# [N,2]", "\n", "inter", "=", "wh", "[", ":", ",", "0", "]", "*", "wh", "[", ":", ",", "1", "]", "# [N]", "\n", "iou", "=", "inter", "/", "(", "area1", "+", "area2", "-", "inter", ")", "# [N]", "\n", "return", "iou", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.chart_confidence.decorate_predictor_output_class_with_confidences": [[9, 75], ["functools.lru_cache", "dataclasses.make_dataclass", "isinstance", "type", "super().__getitem__", "type.", "data[].unsqueeze", "chart_confidence.decorate_predictor_output_class_with_confidences.slice_if_not_none"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.chart.DensePoseChartPredictorOutput.__getitem__"], ["\n", "from", "...", "structures", "import", "decorate_predictor_output_class_with_confidences", "\n", "from", ".", ".", "confidence", "import", "DensePoseConfidenceModelConfig", ",", "DensePoseUVConfidenceType", "\n", "from", ".", ".", "utils", "import", "initialize_module_params", "\n", "\n", "\n", "class", "DensePoseChartConfidencePredictorMixin", ":", "\n", "    ", "\"\"\"\n    Predictor contains the last layers of a DensePose model that take DensePose head\n    outputs as an input and produce model outputs. Confidence predictor mixin is used\n    to generate confidences for segmentation and UV tensors estimated by some\n    base predictor. Several assumptions need to hold for the base predictor:\n    1) the `forward` method must return SIUV tuple as the first result (\n        S = coarse segmentation, I = fine segmentation, U and V are intrinsic\n        chart coordinates)\n    2) `interp2d` method must be defined to perform bilinear interpolation;\n        the same method is typically used for SIUV and confidences\n    Confidence predictor mixin provides confidence estimates, as described in:\n        N. Neverova et al., Correlated Uncertainty for Learning Dense Correspondences\n            from Noisy Labels, NeurIPS 2019\n        A. Sanakoyeu et al., Transferring Dense Pose to Proximal Animal Classes, CVPR 2020\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "cfg", ":", "CfgNode", ",", "input_channels", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Initialize confidence predictor using configuration options.\n\n        Args:\n            cfg (CfgNode): configuration options\n            input_channels (int): number of input channels\n        \"\"\"", "\n", "# we rely on base predictor to call nn.Module.__init__", "\n", "super", "(", ")", ".", "__init__", "(", "cfg", ",", "input_channels", ")", "\n", "self", ".", "confidence_model_cfg", "=", "DensePoseConfidenceModelConfig", ".", "from_cfg", "(", "cfg", ")", "\n", "self", ".", "_initialize_confidence_estimation_layers", "(", "cfg", ",", "input_channels", ")", "\n", "self", ".", "_registry", "=", "{", "}", "\n", "initialize_module_params", "(", "self", ")", "\n", "\n", "", "def", "_initialize_confidence_estimation_layers", "(", "self", ",", "cfg", ":", "CfgNode", ",", "dim_in", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Initialize confidence estimation layers based on configuration options\n\n        Args:\n            cfg (CfgNode): configuration options\n            dim_in (int): number of input channels\n        \"\"\"", "\n", "dim_out_patches", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "NUM_PATCHES", "+", "1", "\n", "kernel_size", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "DECONV_KERNEL", "\n", "if", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "enabled", ":", "\n", "            ", "if", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "type", "==", "DensePoseUVConfidenceType", ".", "IID_ISO", ":", "\n", "                ", "self", ".", "sigma_2_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "", "elif", "(", "\n", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "type", "\n", "==", "DensePoseUVConfidenceType", ".", "INDEP_ANISO", "\n", ")", ":", "\n", "                ", "self", ".", "sigma_2_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "self", ".", "kappa_u_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "self", ".", "kappa_v_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.chart.DensePoseChartPredictorOutput.__len__": [[32, 37], ["chart.DensePoseChartPredictorOutput.coarse_segm.size"], "methods", ["None"], ["\n", "\n", "def", "__init__", "(", "self", ",", "cfg", ":", "CfgNode", ",", "input_channels", ":", "int", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.chart.DensePoseChartPredictorOutput.__getitem__": [[38, 60], ["isinstance", "chart.DensePoseChartPredictorOutput", "chart.DensePoseChartPredictorOutput", "chart.DensePoseChartPredictorOutput.coarse_segm[].unsqueeze", "chart.DensePoseChartPredictorOutput.fine_segm[].unsqueeze", "chart.DensePoseChartPredictorOutput.u[].unsqueeze", "chart.DensePoseChartPredictorOutput.v[].unsqueeze"], "methods", ["None"], ["\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "dim_in", "=", "input_channels", "\n", "n_segm_chan", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "NUM_COARSE_SEGM_CHANNELS", "\n", "dim_out_patches", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "NUM_PATCHES", "+", "1", "\n", "kernel_size", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "DECONV_KERNEL", "\n", "# coarse segmentation", "\n", "self", ".", "ann_index_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "n_segm_chan", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "# fine segmentation", "\n", "self", ".", "index_uv_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "# U", "\n", "self", ".", "u_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "# V", "\n", "self", ".", "v_lowres", "=", "ConvTranspose2d", "(", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.chart_result.quantize_densepose_chart_result": [[62, 76], ["torch.zeros", "chart_result.DensePoseChartResultQuantized"], "function", ["None"], ["", "def", "quantize_densepose_chart_result", "(", "result", ":", "DensePoseChartResult", ")", "->", "DensePoseChartResultQuantized", ":", "\n", "    ", "\"\"\"\n    Applies quantization to DensePose chart-based result.\n\n    Args:\n        result (DensePoseChartResult): DensePose chart-based result\n    Return:\n        Quantized DensePose chart-based result (DensePoseChartResultQuantized)\n    \"\"\"", "\n", "h", ",", "w", "=", "result", ".", "labels", ".", "shape", "\n", "labels_uv_uint8", "=", "torch", ".", "zeros", "(", "[", "3", ",", "h", ",", "w", "]", ",", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "result", ".", "labels", ".", "device", ")", "\n", "labels_uv_uint8", "[", "0", "]", "=", "result", ".", "labels", "\n", "labels_uv_uint8", "[", "1", ":", "]", "=", "(", "result", ".", "uv", "*", "255", ")", ".", "clamp", "(", "0", ",", "255", ")", ".", "byte", "(", ")", "\n", "return", "DensePoseChartResultQuantized", "(", "labels_uv_uint8", "=", "labels_uv_uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.chart_result.compress_quantized_densepose_chart_result": [[78, 102], ["result.labels_uv_uint8.cpu().numpy", "np.moveaxis", "Image.fromarray", "BytesIO", "Image.fromarray.save", "base64.encodebytes().decode", "chart_result.DensePoseChartResultCompressed", "result.labels_uv_uint8.cpu", "base64.encodebytes", "BytesIO.getvalue"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save"], ["", "def", "compress_quantized_densepose_chart_result", "(", "\n", "result", ":", "DensePoseChartResultQuantized", ",", "\n", ")", "->", "DensePoseChartResultCompressed", ":", "\n", "    ", "\"\"\"\n    Compresses quantized DensePose chart-based result\n\n    Args:\n        result (DensePoseChartResultQuantized): quantized DensePose chart-based result\n    Return:\n        Compressed DensePose chart-based result (DensePoseChartResultCompressed)\n    \"\"\"", "\n", "import", "base64", "\n", "import", "numpy", "as", "np", "\n", "from", "io", "import", "BytesIO", "\n", "from", "PIL", "import", "Image", "\n", "\n", "labels_uv_uint8_np_chw", "=", "result", ".", "labels_uv_uint8", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "labels_uv_uint8_np_hwc", "=", "np", ".", "moveaxis", "(", "labels_uv_uint8_np_chw", ",", "0", ",", "-", "1", ")", "\n", "im", "=", "Image", ".", "fromarray", "(", "labels_uv_uint8_np_hwc", ")", "\n", "fstream", "=", "BytesIO", "(", ")", "\n", "im", ".", "save", "(", "fstream", ",", "format", "=", "\"png\"", ",", "optimize", "=", "True", ")", "\n", "labels_uv_str", "=", "base64", ".", "encodebytes", "(", "fstream", ".", "getvalue", "(", ")", ")", ".", "decode", "(", ")", "\n", "shape_chw", "=", "labels_uv_uint8_np_chw", ".", "shape", "\n", "return", "DensePoseChartResultCompressed", "(", "labels_uv_str", "=", "labels_uv_str", ",", "shape_chw", "=", "shape_chw", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.chart_result.decompress_compressed_densepose_chart_result": [[104, 125], ["BytesIO", "Image.open", "np.moveaxis", "chart_result.DensePoseChartResultQuantized", "base64.decodebytes", "np.array", "result.labels_uv_str.encode", "Image.open.getdata", "torch.from_numpy", "np.moveaxis.reshape"], "function", ["None"], ["", "def", "decompress_compressed_densepose_chart_result", "(", "\n", "result", ":", "DensePoseChartResultCompressed", ",", "\n", ")", "->", "DensePoseChartResultQuantized", ":", "\n", "    ", "\"\"\"\n    Decompresses DensePose chart-based result encoded into a base64 string\n\n    Args:\n        result (DensePoseChartResultCompressed): compressed DensePose chart result\n    Return:\n        Quantized DensePose chart-based result (DensePoseChartResultQuantized)\n    \"\"\"", "\n", "import", "base64", "\n", "import", "numpy", "as", "np", "\n", "from", "io", "import", "BytesIO", "\n", "from", "PIL", "import", "Image", "\n", "\n", "fstream", "=", "BytesIO", "(", "base64", ".", "decodebytes", "(", "result", ".", "labels_uv_str", ".", "encode", "(", ")", ")", ")", "\n", "im", "=", "Image", ".", "open", "(", "fstream", ")", "\n", "labels_uv_uint8_np_chw", "=", "np", ".", "moveaxis", "(", "np", ".", "array", "(", "im", ".", "getdata", "(", ")", ",", "dtype", "=", "np", ".", "uint8", ")", ",", "-", "1", ",", "0", ")", "\n", "return", "DensePoseChartResultQuantized", "(", "\n", "labels_uv_uint8", "=", "torch", ".", "from_numpy", "(", "labels_uv_uint8_np_chw", ".", "reshape", "(", "result", ".", "shape_chw", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode._convert_xy_to_wh": [[13, 15], ["detectron2.structures.BoxMode.convert"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["    ", "def", "_convert_xy_to_wh", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "BoxMode", ".", "convert", "(", "x", ",", "BoxMode", ".", "XYXY_ABS", ",", "BoxMode", ".", "XYWH_ABS", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode._convert_xywha_to_xyxy": [[16, 18], ["detectron2.structures.BoxMode.convert"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "def", "_convert_xywha_to_xyxy", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "BoxMode", ".", "convert", "(", "x", ",", "BoxMode", ".", "XYWHA_ABS", ",", "BoxMode", ".", "XYXY_ABS", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode._convert_xywh_to_xywha": [[19, 21], ["detectron2.structures.BoxMode.convert"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "def", "_convert_xywh_to_xywha", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "BoxMode", ".", "convert", "(", "x", ",", "BoxMode", ".", "XYWH_ABS", ",", "BoxMode", ".", "XYWHA_ABS", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode.test_box_convert_list": [[22, 32], ["tp", "test_boxes.TestBoxMode._convert_xy_to_wh", "test_boxes.TestBoxMode.assertIsInstance", "test_boxes.TestBoxMode.assertIsInstance", "test_boxes.TestBoxMode.assertEqual", "tp", "test_boxes.TestBoxMode.assertRaises", "test_boxes.TestBoxMode._convert_xy_to_wh"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode._convert_xy_to_wh", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode._convert_xy_to_wh"], ["", "def", "test_box_convert_list", "(", "self", ")", ":", "\n", "        ", "for", "tp", "in", "[", "list", ",", "tuple", "]", ":", "\n", "            ", "box", "=", "tp", "(", "[", "5.0", ",", "5.0", ",", "10.0", ",", "10.0", "]", ")", "\n", "output", "=", "self", ".", "_convert_xy_to_wh", "(", "box", ")", "\n", "self", ".", "assertIsInstance", "(", "output", ",", "tp", ")", "\n", "self", ".", "assertIsInstance", "(", "output", "[", "0", "]", ",", "float", ")", "\n", "self", ".", "assertEqual", "(", "output", ",", "tp", "(", "[", "5.0", ",", "5.0", ",", "5.0", ",", "5.0", "]", ")", ")", "\n", "\n", "with", "self", ".", "assertRaises", "(", "Exception", ")", ":", "\n", "                ", "self", ".", "_convert_xy_to_wh", "(", "[", "box", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode.test_box_convert_array": [[33, 40], ["numpy.asarray", "test_boxes.TestBoxMode._convert_xy_to_wh", "test_boxes.TestBoxMode.assertEqual", "test_boxes.TestBoxMode.assertEqual", "test_boxes.TestBoxMode.assertTrue", "test_boxes.TestBoxMode.assertTrue"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode._convert_xy_to_wh"], ["", "", "", "def", "test_box_convert_array", "(", "self", ")", ":", "\n", "        ", "box", "=", "np", ".", "asarray", "(", "[", "[", "5", ",", "5", ",", "10", ",", "10", "]", ",", "[", "1", ",", "1", ",", "2", ",", "3", "]", "]", ")", "\n", "output", "=", "self", ".", "_convert_xy_to_wh", "(", "box", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "dtype", ",", "box", ".", "dtype", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "shape", ",", "box", ".", "shape", ")", "\n", "self", ".", "assertTrue", "(", "(", "output", "[", "0", "]", "==", "[", "5", ",", "5", ",", "5", ",", "5", "]", ")", ".", "all", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "(", "output", "[", "1", "]", "==", "[", "1", ",", "1", ",", "1", ",", "2", "]", ")", ".", "all", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode.test_box_convert_cpu_tensor": [[41, 49], ["torch.tensor", "test_boxes.TestBoxMode._convert_xy_to_wh", "test_boxes.TestBoxMode.assertEqual", "test_boxes.TestBoxMode.assertEqual", "output.numpy.numpy.numpy", "test_boxes.TestBoxMode.assertTrue", "test_boxes.TestBoxMode.assertTrue"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode._convert_xy_to_wh"], ["", "def", "test_box_convert_cpu_tensor", "(", "self", ")", ":", "\n", "        ", "box", "=", "torch", ".", "tensor", "(", "[", "[", "5", ",", "5", ",", "10", ",", "10", "]", ",", "[", "1", ",", "1", ",", "2", ",", "3", "]", "]", ")", "\n", "output", "=", "self", ".", "_convert_xy_to_wh", "(", "box", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "dtype", ",", "box", ".", "dtype", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "shape", ",", "box", ".", "shape", ")", "\n", "output", "=", "output", ".", "numpy", "(", ")", "\n", "self", ".", "assertTrue", "(", "(", "output", "[", "0", "]", "==", "[", "5", ",", "5", ",", "5", ",", "5", "]", ")", ".", "all", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "(", "output", "[", "1", "]", "==", "[", "1", ",", "1", ",", "1", ",", "2", "]", ")", ".", "all", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode.test_box_convert_cuda_tensor": [[50, 60], ["unittest.skipIf", "torch.tensor().cuda", "test_boxes.TestBoxMode._convert_xy_to_wh", "test_boxes.TestBoxMode.assertEqual", "test_boxes.TestBoxMode.assertEqual", "test_boxes.TestBoxMode.assertEqual", "output.cpu().numpy.cpu().numpy.cpu().numpy", "test_boxes.TestBoxMode.assertTrue", "test_boxes.TestBoxMode.assertTrue", "torch.cuda.is_available", "torch.tensor", "output.cpu().numpy.cpu().numpy.cpu"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode._convert_xy_to_wh"], ["", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_box_convert_cuda_tensor", "(", "self", ")", ":", "\n", "        ", "box", "=", "torch", ".", "tensor", "(", "[", "[", "5", ",", "5", ",", "10", ",", "10", "]", ",", "[", "1", ",", "1", ",", "2", ",", "3", "]", "]", ")", ".", "cuda", "(", ")", "\n", "output", "=", "self", ".", "_convert_xy_to_wh", "(", "box", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "dtype", ",", "box", ".", "dtype", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "shape", ",", "box", ".", "shape", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "device", ",", "box", ".", "device", ")", "\n", "output", "=", "output", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "self", ".", "assertTrue", "(", "(", "output", "[", "0", "]", "==", "[", "5", ",", "5", ",", "5", ",", "5", "]", ")", ".", "all", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "(", "output", "[", "1", "]", "==", "[", "1", ",", "1", ",", "1", ",", "2", "]", ")", ".", "all", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode.test_box_convert_xywha_to_xyxy_list": [[61, 70], ["tp", "test_boxes.TestBoxMode._convert_xywha_to_xyxy", "test_boxes.TestBoxMode.assertIsInstance", "test_boxes.TestBoxMode.assertEqual", "tp", "test_boxes.TestBoxMode.assertRaises", "test_boxes.TestBoxMode._convert_xywha_to_xyxy"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode._convert_xywha_to_xyxy", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode._convert_xywha_to_xyxy"], ["", "def", "test_box_convert_xywha_to_xyxy_list", "(", "self", ")", ":", "\n", "        ", "for", "tp", "in", "[", "list", ",", "tuple", "]", ":", "\n", "            ", "box", "=", "tp", "(", "[", "50", ",", "50", ",", "30", ",", "20", ",", "0", "]", ")", "\n", "output", "=", "self", ".", "_convert_xywha_to_xyxy", "(", "box", ")", "\n", "self", ".", "assertIsInstance", "(", "output", ",", "tp", ")", "\n", "self", ".", "assertEqual", "(", "output", ",", "tp", "(", "[", "35", ",", "40", ",", "65", ",", "60", "]", ")", ")", "\n", "\n", "with", "self", ".", "assertRaises", "(", "Exception", ")", ":", "\n", "                ", "self", ".", "_convert_xywha_to_xyxy", "(", "[", "box", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode.test_box_convert_xywha_to_xyxy_array": [[71, 85], ["numpy.asarray", "test_boxes.TestBoxMode._convert_xywha_to_xyxy", "test_boxes.TestBoxMode.assertEqual", "numpy.asarray", "test_boxes.TestBoxMode.assertTrue", "numpy.allclose", "math.sqrt", "math.sqrt"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode._convert_xywha_to_xyxy"], ["", "", "", "def", "test_box_convert_xywha_to_xyxy_array", "(", "self", ")", ":", "\n", "        ", "for", "dtype", "in", "[", "np", ".", "float64", ",", "np", ".", "float32", "]", ":", "\n", "            ", "box", "=", "np", ".", "asarray", "(", "\n", "[", "\n", "[", "50", ",", "50", ",", "30", ",", "20", ",", "0", "]", ",", "\n", "[", "50", ",", "50", ",", "30", ",", "20", ",", "90", "]", ",", "\n", "[", "1", ",", "1", ",", "math", ".", "sqrt", "(", "2", ")", ",", "math", ".", "sqrt", "(", "2", ")", ",", "-", "45", "]", ",", "\n", "]", ",", "\n", "dtype", "=", "dtype", ",", "\n", ")", "\n", "output", "=", "self", ".", "_convert_xywha_to_xyxy", "(", "box", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "dtype", ",", "box", ".", "dtype", ")", "\n", "expected", "=", "np", ".", "asarray", "(", "[", "[", "35", ",", "40", ",", "65", ",", "60", "]", ",", "[", "40", ",", "35", ",", "60", ",", "65", "]", ",", "[", "0", ",", "0", ",", "2", ",", "2", "]", "]", ",", "dtype", "=", "dtype", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "allclose", "(", "output", ",", "expected", ",", "atol", "=", "1e-6", ")", ",", "\"output={}\"", ".", "format", "(", "output", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode.test_box_convert_xywha_to_xyxy_tensor": [[86, 101], ["torch.tensor", "test_boxes.TestBoxMode._convert_xywha_to_xyxy", "test_boxes.TestBoxMode.assertEqual", "torch.tensor", "test_boxes.TestBoxMode.assertTrue", "torch.allclose", "math.sqrt", "math.sqrt"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode._convert_xywha_to_xyxy"], ["", "", "def", "test_box_convert_xywha_to_xyxy_tensor", "(", "self", ")", ":", "\n", "        ", "for", "dtype", "in", "[", "torch", ".", "float32", ",", "torch", ".", "float64", "]", ":", "\n", "            ", "box", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "50", ",", "50", ",", "30", ",", "20", ",", "0", "]", ",", "\n", "[", "50", ",", "50", ",", "30", ",", "20", ",", "90", "]", ",", "\n", "[", "1", ",", "1", ",", "math", ".", "sqrt", "(", "2", ")", ",", "math", ".", "sqrt", "(", "2", ")", ",", "-", "45", "]", ",", "\n", "]", ",", "\n", "dtype", "=", "dtype", ",", "\n", ")", "\n", "output", "=", "self", ".", "_convert_xywha_to_xyxy", "(", "box", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "dtype", ",", "box", ".", "dtype", ")", "\n", "expected", "=", "torch", ".", "tensor", "(", "[", "[", "35", ",", "40", ",", "65", ",", "60", "]", ",", "[", "40", ",", "35", ",", "60", ",", "65", "]", ",", "[", "0", ",", "0", ",", "2", ",", "2", "]", "]", ",", "dtype", "=", "dtype", ")", "\n", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "output", ",", "expected", ",", "atol", "=", "1e-6", ")", ",", "\"output={}\"", ".", "format", "(", "output", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode.test_box_convert_xywh_to_xywha_list": [[102, 111], ["tp", "test_boxes.TestBoxMode._convert_xywh_to_xywha", "test_boxes.TestBoxMode.assertIsInstance", "test_boxes.TestBoxMode.assertEqual", "tp", "test_boxes.TestBoxMode.assertRaises", "test_boxes.TestBoxMode._convert_xywh_to_xywha"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode._convert_xywh_to_xywha", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode._convert_xywh_to_xywha"], ["", "", "def", "test_box_convert_xywh_to_xywha_list", "(", "self", ")", ":", "\n", "        ", "for", "tp", "in", "[", "list", ",", "tuple", "]", ":", "\n", "            ", "box", "=", "tp", "(", "[", "50", ",", "50", ",", "30", ",", "20", "]", ")", "\n", "output", "=", "self", ".", "_convert_xywh_to_xywha", "(", "box", ")", "\n", "self", ".", "assertIsInstance", "(", "output", ",", "tp", ")", "\n", "self", ".", "assertEqual", "(", "output", ",", "tp", "(", "[", "65", ",", "60", ",", "30", ",", "20", ",", "0", "]", ")", ")", "\n", "\n", "with", "self", ".", "assertRaises", "(", "Exception", ")", ":", "\n", "                ", "self", ".", "_convert_xywh_to_xywha", "(", "[", "box", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode.test_box_convert_xywh_to_xywha_array": [[112, 121], ["numpy.asarray", "test_boxes.TestBoxMode._convert_xywh_to_xywha", "test_boxes.TestBoxMode.assertEqual", "numpy.asarray", "test_boxes.TestBoxMode.assertTrue", "numpy.allclose"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode._convert_xywh_to_xywha"], ["", "", "", "def", "test_box_convert_xywh_to_xywha_array", "(", "self", ")", ":", "\n", "        ", "for", "dtype", "in", "[", "np", ".", "float64", ",", "np", ".", "float32", "]", ":", "\n", "            ", "box", "=", "np", ".", "asarray", "(", "[", "[", "30", ",", "40", ",", "70", ",", "60", "]", ",", "[", "30", ",", "40", ",", "60", ",", "70", "]", ",", "[", "-", "1", ",", "-", "1", ",", "2", ",", "2", "]", "]", ",", "dtype", "=", "dtype", ")", "\n", "output", "=", "self", ".", "_convert_xywh_to_xywha", "(", "box", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "dtype", ",", "box", ".", "dtype", ")", "\n", "expected", "=", "np", ".", "asarray", "(", "\n", "[", "[", "65", ",", "70", ",", "70", ",", "60", ",", "0", "]", ",", "[", "60", ",", "75", ",", "60", ",", "70", ",", "0", "]", ",", "[", "0", ",", "0", ",", "2", ",", "2", ",", "0", "]", "]", ",", "dtype", "=", "dtype", "\n", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "allclose", "(", "output", ",", "expected", ",", "atol", "=", "1e-6", ")", ",", "\"output={}\"", ".", "format", "(", "output", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode.test_box_convert_xywh_to_xywha_tensor": [[122, 132], ["torch.tensor", "test_boxes.TestBoxMode._convert_xywh_to_xywha", "test_boxes.TestBoxMode.assertEqual", "torch.tensor", "test_boxes.TestBoxMode.assertTrue", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode._convert_xywh_to_xywha"], ["", "", "def", "test_box_convert_xywh_to_xywha_tensor", "(", "self", ")", ":", "\n", "        ", "for", "dtype", "in", "[", "torch", ".", "float32", ",", "torch", ".", "float64", "]", ":", "\n", "            ", "box", "=", "torch", ".", "tensor", "(", "[", "[", "30", ",", "40", ",", "70", ",", "60", "]", ",", "[", "30", ",", "40", ",", "60", ",", "70", "]", ",", "[", "-", "1", ",", "-", "1", ",", "2", ",", "2", "]", "]", ",", "dtype", "=", "dtype", ")", "\n", "output", "=", "self", ".", "_convert_xywh_to_xywha", "(", "box", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "dtype", ",", "box", ".", "dtype", ")", "\n", "expected", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "65", ",", "70", ",", "70", ",", "60", ",", "0", "]", ",", "[", "60", ",", "75", ",", "60", ",", "70", ",", "0", "]", ",", "[", "0", ",", "0", ",", "2", ",", "2", ",", "0", "]", "]", ",", "dtype", "=", "dtype", "\n", ")", "\n", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "output", ",", "expected", ",", "atol", "=", "1e-6", ")", ",", "\"output={}\"", ".", "format", "(", "output", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode.test_json_serializable": [[133, 139], ["json.dumps", "test_boxes.TestBoxMode.fail"], "methods", ["None"], ["", "", "def", "test_json_serializable", "(", "self", ")", ":", "\n", "        ", "payload", "=", "{", "\"box_mode\"", ":", "BoxMode", ".", "XYWH_REL", "}", "\n", "try", ":", "\n", "            ", "json", ".", "dumps", "(", "payload", ")", "\n", "", "except", "Exception", ":", "\n", "            ", "self", ".", "fail", "(", "\"JSON serialization failed\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxMode.test_json_deserializable": [[140, 147], ["json.loads", "detectron2.structures.BoxMode", "test_boxes.TestBoxMode.fail"], "methods", ["None"], ["", "", "def", "test_json_deserializable", "(", "self", ")", ":", "\n", "        ", "payload", "=", "'{\"box_mode\": 2}'", "\n", "obj", "=", "json", ".", "loads", "(", "payload", ")", "\n", "try", ":", "\n", "            ", "obj", "[", "\"box_mode\"", "]", "=", "BoxMode", "(", "obj", "[", "\"box_mode\"", "]", ")", "\n", "", "except", "Exception", ":", "\n", "            ", "self", ".", "fail", "(", "\"JSON deserialization failed\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxIOU.create_boxes": [[150, 164], ["torch.tensor", "torch.tensor"], "methods", ["None"], ["    ", "def", "create_boxes", "(", "self", ")", ":", "\n", "        ", "boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "1.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", ",", "1.0", ",", "1.0", "]", "]", ")", "\n", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "0.0", ",", "0.0", ",", "1.0", ",", "1.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "0.5", ",", "1.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "1.0", ",", "0.5", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "0.5", ",", "0.5", "]", ",", "\n", "[", "0.5", ",", "0.5", ",", "1.0", ",", "1.0", "]", ",", "\n", "[", "0.5", ",", "0.5", ",", "1.5", ",", "1.5", "]", ",", "\n", "]", "\n", ")", "\n", "return", "boxes1", ",", "boxes2", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxIOU.test_pairwise_iou": [[165, 176], ["test_boxes.TestBoxIOU.create_boxes", "torch.tensor", "detectron2.structures.pairwise_iou", "test_boxes.TestBoxIOU.assertTrue", "detectron2.structures.Boxes", "detectron2.structures.Boxes", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxIOU.create_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.pairwise_iou"], ["", "def", "test_pairwise_iou", "(", "self", ")", ":", "\n", "        ", "boxes1", ",", "boxes2", "=", "self", ".", "create_boxes", "(", ")", "\n", "expected_ious", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "1.0", ",", "0.5", ",", "0.5", ",", "0.25", ",", "0.25", ",", "0.25", "/", "(", "2", "-", "0.25", ")", "]", ",", "\n", "[", "1.0", ",", "0.5", ",", "0.5", ",", "0.25", ",", "0.25", ",", "0.25", "/", "(", "2", "-", "0.25", ")", "]", ",", "\n", "]", "\n", ")", "\n", "\n", "ious", "=", "pairwise_iou", "(", "Boxes", "(", "boxes1", ")", ",", "Boxes", "(", "boxes2", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxIOU.test_pairwise_ioa": [[177, 184], ["test_boxes.TestBoxIOU.create_boxes", "torch.tensor", "detectron2.structures.pairwise_ioa", "test_boxes.TestBoxIOU.assertTrue", "detectron2.structures.Boxes", "detectron2.structures.Boxes", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxIOU.create_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.pairwise_ioa"], ["", "def", "test_pairwise_ioa", "(", "self", ")", ":", "\n", "        ", "boxes1", ",", "boxes2", "=", "self", ".", "create_boxes", "(", ")", "\n", "expected_ioas", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ",", "0.25", "]", ",", "[", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ",", "0.25", "]", "]", "\n", ")", "\n", "ioas", "=", "pairwise_ioa", "(", "Boxes", "(", "boxes1", ")", ",", "Boxes", "(", "boxes2", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ioas", ",", "expected_ioas", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxes.test_empty_cat": [[187, 190], ["detectron2.structures.Boxes.cat", "test_boxes.TestBoxes.assertTrue"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["    ", "def", "test_empty_cat", "(", "self", ")", ":", "\n", "        ", "x", "=", "Boxes", ".", "cat", "(", "[", "]", ")", "\n", "self", ".", "assertTrue", "(", "x", ".", "tensor", ".", "shape", ",", "(", "0", ",", "4", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_boxes.TestBoxes.test_scriptability": [[192, 213], ["unittest.skipIf", "torch.jit.script", "torch.jit.script.", "torch.rand", "torch.jit.script", "torch.jit.script.", "test_boxes.TestBoxes.assertTrue", "detectron2.structures.Boxes", "detectron2.structures.Boxes.area", "torch.rand", "detectron2.structures.Boxes", "detectron2.structures.Boxes", "detectron2.structures.Boxes.cat", "torch.equal", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "6", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_scriptability", "(", "self", ")", ":", "\n", "        ", "def", "func", "(", "x", ")", ":", "\n", "            ", "boxes", "=", "Boxes", "(", "x", ")", "\n", "return", "boxes", ".", "area", "(", ")", "\n", "\n", "", "f", "=", "torch", ".", "jit", ".", "script", "(", "func", ")", "\n", "f", "(", "torch", ".", "rand", "(", "(", "3", ",", "4", ")", ")", ")", "\n", "\n", "data", "=", "torch", ".", "rand", "(", "(", "3", ",", "4", ")", ")", "\n", "\n", "def", "func_cat", "(", "x", ":", "torch", ".", "Tensor", ")", ":", "\n", "            ", "boxes1", "=", "Boxes", "(", "x", ")", "\n", "boxes2", "=", "Boxes", "(", "x", ")", "\n", "# boxes3 = Boxes.cat([boxes1, boxes2])  # this is not supported by torchsript for now.", "\n", "boxes3", "=", "boxes1", ".", "cat", "(", "[", "boxes1", ",", "boxes2", "]", ")", "\n", "return", "boxes3", "\n", "\n", "", "f", "=", "torch", ".", "jit", ".", "script", "(", "func_cat", ")", "\n", "script_box", "=", "f", "(", "data", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "equal", "(", "torch", ".", "cat", "(", "[", "data", ",", "data", "]", ")", ",", "script_box", ".", "tensor", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_imagelist.TestImageList.test_imagelist_padding_shape": [[12, 40], ["torch.jit.trace", "torch.jit.trace.", "test_imagelist.TestImageList.assertEqual", "torch.jit.trace", "torch.jit.trace.", "test_imagelist.TestImageList.assertEqual", "TensorToImageList", "list", "str", "TensorToImageList", "list", "str", "torch.ones", "torch.ones", "torch.ones", "detectron2.structures.ImageList.from_tensors", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.from_tensors"], ["    ", "def", "test_imagelist_padding_shape", "(", "self", ")", ":", "\n", "        ", "class", "TensorToImageList", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "forward", "(", "self", ",", "tensors", ":", "Sequence", "[", "torch", ".", "Tensor", "]", ")", ":", "\n", "                ", "return", "ImageList", ".", "from_tensors", "(", "tensors", ",", "4", ")", ".", "tensor", "\n", "\n", "", "", "func", "=", "torch", ".", "jit", ".", "trace", "(", "\n", "TensorToImageList", "(", ")", ",", "(", "[", "torch", ".", "ones", "(", "(", "3", ",", "10", ",", "10", ")", ",", "dtype", "=", "torch", ".", "float32", ")", "]", ",", ")", "\n", ")", "\n", "ret", "=", "func", "(", "[", "torch", ".", "ones", "(", "(", "3", ",", "15", ",", "20", ")", ",", "dtype", "=", "torch", ".", "float32", ")", "]", ")", "\n", "self", ".", "assertEqual", "(", "list", "(", "ret", ".", "shape", ")", ",", "[", "1", ",", "3", ",", "16", ",", "20", "]", ",", "str", "(", "ret", ".", "shape", ")", ")", "\n", "\n", "func", "=", "torch", ".", "jit", ".", "trace", "(", "\n", "TensorToImageList", "(", ")", ",", "\n", "(", "\n", "[", "\n", "torch", ".", "ones", "(", "(", "3", ",", "16", ",", "10", ")", ",", "dtype", "=", "torch", ".", "float32", ")", ",", "\n", "torch", ".", "ones", "(", "(", "3", ",", "13", ",", "11", ")", ",", "dtype", "=", "torch", ".", "float32", ")", ",", "\n", "]", ",", "\n", ")", ",", "\n", ")", "\n", "ret", "=", "func", "(", "\n", "[", "\n", "torch", ".", "ones", "(", "(", "3", ",", "25", ",", "20", ")", ",", "dtype", "=", "torch", ".", "float32", ")", ",", "\n", "torch", ".", "ones", "(", "(", "3", ",", "10", ",", "10", ")", ",", "dtype", "=", "torch", ".", "float32", ")", ",", "\n", "]", "\n", ")", "\n", "# does not support calling with different #images", "\n", "self", ".", "assertEqual", "(", "list", "(", "ret", ".", "shape", ")", ",", "[", "2", ",", "3", ",", "28", ",", "20", "]", ",", "str", "(", "ret", ".", "shape", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_imagelist.TestImageList.test_imagelist_scriptability": [[41, 56], ["unittest.skipIf", "torch.randn", "test_imagelist.TestImageList.test_imagelist_scriptability.f"], "methods", ["None"], ["", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "6", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_imagelist_scriptability", "(", "self", ")", ":", "\n", "        ", "image_nums", "=", "2", "\n", "image_tensor", "=", "torch", ".", "randn", "(", "(", "image_nums", ",", "10", ",", "20", ")", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "image_shape", "=", "[", "(", "10", ",", "20", ")", "]", "*", "image_nums", "\n", "\n", "def", "f", "(", "image_tensor", ",", "image_shape", ":", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", ")", ":", "\n", "            ", "return", "ImageList", "(", "image_tensor", ",", "image_shape", ")", "\n", "\n", "", "ret", "=", "f", "(", "image_tensor", ",", "image_shape", ")", "\n", "ret_script", "=", "torch", ".", "jit", ".", "script", "(", "f", ")", "(", "image_tensor", ",", "image_shape", ")", "\n", "\n", "self", ".", "assertEqual", "(", "len", "(", "ret", ")", ",", "len", "(", "ret_script", ")", ")", "\n", "for", "i", "in", "range", "(", "image_nums", ")", ":", "\n", "            ", "self", ".", "assertTrue", "(", "torch", ".", "equal", "(", "ret", "[", "i", "]", ",", "ret_script", "[", "i", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_masks.TestBitMask.test_get_bounding_box": [[8, 39], ["torch.tensor", "detectron2.structures.masks.BitMasks", "torch.tensor", "detectron2.structures.masks.BitMasks.get_bounding_boxes", "test_masks.TestBitMask.assertTrue", "torch.all().item", "box[].numpy", "detectron2.structures.masks.polygons_to_bitmask", "test_masks.TestBitMask.assertTrue", "test_masks.TestBitMask.assertTrue", "torch.zeros", "torch.all().item", "torch.all().item", "torch.all", "detectron2.structures.masks.BitMasks().get_bounding_boxes", "detectron2.structures.masks.PolygonMasks().get_bounding_boxes", "torch.all", "torch.all", "detectron2.structures.masks.BitMasks", "detectron2.structures.masks.PolygonMasks"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.PolygonMasks.get_bounding_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.polygons_to_bitmask", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.PolygonMasks.get_bounding_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.PolygonMasks.get_bounding_boxes"], ["    ", "def", "test_get_bounding_box", "(", "self", ")", ":", "\n", "        ", "masks", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "\n", "[", "False", ",", "False", ",", "False", ",", "True", "]", ",", "\n", "[", "False", ",", "False", ",", "True", ",", "True", "]", ",", "\n", "[", "False", ",", "True", ",", "True", ",", "False", "]", ",", "\n", "[", "False", ",", "True", ",", "True", ",", "False", "]", ",", "\n", "]", ",", "\n", "[", "\n", "[", "False", ",", "False", ",", "False", ",", "False", "]", ",", "\n", "[", "False", ",", "False", ",", "True", ",", "False", "]", ",", "\n", "[", "False", ",", "True", ",", "True", ",", "False", "]", ",", "\n", "[", "False", ",", "True", ",", "True", ",", "False", "]", ",", "\n", "]", ",", "\n", "torch", ".", "zeros", "(", "4", ",", "4", ")", ",", "\n", "]", "\n", ")", "\n", "bitmask", "=", "BitMasks", "(", "masks", ")", "\n", "box_true", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "0", ",", "4", ",", "4", "]", ",", "[", "1", ",", "1", ",", "3", ",", "4", "]", ",", "[", "0", ",", "0", ",", "0", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "box", "=", "bitmask", ".", "get_bounding_boxes", "(", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "all", "(", "box", ".", "tensor", "==", "box_true", ")", ".", "item", "(", ")", ")", "\n", "\n", "for", "box", "in", "box_true", ":", "\n", "            ", "poly", "=", "box", "[", "[", "0", ",", "1", ",", "2", ",", "1", ",", "2", ",", "3", ",", "0", ",", "3", "]", "]", ".", "numpy", "(", ")", "\n", "mask", "=", "polygons_to_bitmask", "(", "[", "poly", "]", ",", "4", ",", "4", ")", "\n", "reconstruct_box", "=", "BitMasks", "(", "mask", "[", "None", ",", ":", ",", ":", "]", ")", ".", "get_bounding_boxes", "(", ")", "[", "0", "]", ".", "tensor", "\n", "self", ".", "assertTrue", "(", "torch", ".", "all", "(", "box", "==", "reconstruct_box", ")", ".", "item", "(", ")", ")", "\n", "\n", "reconstruct_box", "=", "PolygonMasks", "(", "[", "[", "poly", "]", "]", ")", ".", "get_bounding_boxes", "(", ")", "[", "0", "]", ".", "tensor", "\n", "self", ".", "assertTrue", "(", "torch", ".", "all", "(", "box", "==", "reconstruct_box", ")", ".", "item", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_instances.TestInstances.test_int_indexing": [[11, 24], ["torch.tensor", "torch.tensor", "detectron2.structures.Instances", "range", "test_instances.TestInstances.assertRaises", "test_instances.TestInstances.assertRaises", "len", "test_instances.TestInstances.assertEqual", "test_instances.TestInstances.assertEqual", "len", "len", "len"], "methods", ["None"], ["    ", "def", "test_int_indexing", "(", "self", ")", ":", "\n", "        ", "attr1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", ",", "0.5", "]", ",", "[", "0.0", ",", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.5", ",", "0.5", "]", "]", ")", "\n", "attr2", "=", "torch", ".", "tensor", "(", "[", "0.1", ",", "0.2", ",", "0.3", ",", "0.4", "]", ")", "\n", "instances", "=", "Instances", "(", "(", "100", ",", "100", ")", ")", "\n", "instances", ".", "attr1", "=", "attr1", "\n", "instances", ".", "attr2", "=", "attr2", "\n", "for", "i", "in", "range", "(", "-", "len", "(", "instances", ")", ",", "len", "(", "instances", ")", ")", ":", "\n", "            ", "inst", "=", "instances", "[", "i", "]", "\n", "self", ".", "assertEqual", "(", "(", "inst", ".", "attr1", "==", "attr1", "[", "i", "]", ")", ".", "all", "(", ")", ",", "True", ")", "\n", "self", ".", "assertEqual", "(", "(", "inst", ".", "attr2", "==", "attr2", "[", "i", "]", ")", ".", "all", "(", ")", ",", "True", ")", "\n", "\n", "", "self", ".", "assertRaises", "(", "IndexError", ",", "lambda", ":", "instances", "[", "len", "(", "instances", ")", "]", ")", "\n", "self", ".", "assertRaises", "(", "IndexError", ",", "lambda", ":", "instances", "[", "-", "len", "(", "instances", ")", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_instances.TestInstances.test_script_new_fields": [[25, 56], ["unittest.skipIf", "detectron2.export.torchscript.patch_instances", "torch.jit.script", "test_instances.TestInstances.assertRaises", "torch.jit.script", "detectron2.export.torchscript.patch_instances", "torch.jit.script", "f", "g2", "g", "test_instances.TestInstances.assertRaises", "torch.jit.script", "g2"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript_patch.patch_instances", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript_patch.patch_instances"], ["", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "7", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_script_new_fields", "(", "self", ")", ":", "\n", "        ", "class", "f", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "forward", "(", "self", ",", "x", ":", "Instances", ")", ":", "\n", "                ", "proposal_boxes", "=", "x", ".", "proposal_boxes", "# noqa F841", "\n", "objectness_logits", "=", "x", ".", "objectness_logits", "# noqa F841", "\n", "return", "x", "\n", "\n", "", "", "class", "g", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "forward", "(", "self", ",", "x", ":", "Instances", ")", ":", "\n", "                ", "mask", "=", "x", ".", "mask", "# noqa F841", "\n", "return", "x", "\n", "\n", "", "", "class", "g2", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "forward", "(", "self", ",", "x", ":", "Instances", ")", ":", "\n", "                ", "proposal_boxes", "=", "x", ".", "proposal_boxes", "# noqa F841", "\n", "return", "x", "\n", "\n", "", "", "fields", "=", "{", "\"proposal_boxes\"", ":", "\"Boxes\"", ",", "\"objectness_logits\"", ":", "\"Tensor\"", "}", "\n", "with", "patch_instances", "(", "fields", ")", ":", "\n", "            ", "torch", ".", "jit", ".", "script", "(", "f", "(", ")", ")", "\n", "\n", "# can't script anymore after exiting the context", "\n", "", "with", "self", ".", "assertRaises", "(", "Exception", ")", ":", "\n", "            ", "torch", ".", "jit", ".", "script", "(", "g2", "(", ")", ")", "\n", "\n", "", "new_fields", "=", "{", "\"mask\"", ":", "\"Tensor\"", "}", "\n", "with", "patch_instances", "(", "new_fields", ")", ":", "\n", "            ", "torch", ".", "jit", ".", "script", "(", "g", "(", ")", ")", "\n", "with", "self", ".", "assertRaises", "(", "Exception", ")", ":", "\n", "                ", "torch", ".", "jit", ".", "script", "(", "g2", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_instances.TestInstances.test_script_access_fields": [[57, 68], ["unittest.skipIf", "detectron2.export.torchscript.patch_instances", "torch.jit.script", "f"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript_patch.patch_instances"], ["", "", "", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "7", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_script_access_fields", "(", "self", ")", ":", "\n", "        ", "class", "f", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "forward", "(", "self", ",", "x", ":", "Instances", ")", ":", "\n", "                ", "proposal_boxes", "=", "x", ".", "proposal_boxes", "\n", "objectness_logits", "=", "x", ".", "objectness_logits", "\n", "return", "proposal_boxes", ".", "tensor", "+", "objectness_logits", "\n", "\n", "", "", "fields", "=", "{", "\"proposal_boxes\"", ":", "\"Boxes\"", ",", "\"objectness_logits\"", ":", "\"Tensor\"", "}", "\n", "with", "patch_instances", "(", "fields", ")", ":", "\n", "            ", "torch", ".", "jit", ".", "script", "(", "f", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_instances.TestInstances.test_script_len": [[69, 100], ["unittest.skipIf", "detectron2.export.torchscript.patch_instances", "torch.jit.script", "new_instance", "torch.tensor", "detectron2.structures.Boxes", "torch.jit.script.", "test_instances.TestInstances.assertEqual", "detectron2.export.torchscript.patch_instances", "torch.jit.script", "new_instance", "torch.tensor().reshape", "torch.jit.script.", "test_instances.TestInstances.assertEqual", "len", "len", "f", "test_instances.TestInstances.assertRaises", "torch.jit.script.", "g", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript_patch.patch_instances", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript_patch.patch_instances"], ["", "", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "7", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_script_len", "(", "self", ")", ":", "\n", "        ", "class", "f", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "forward", "(", "self", ",", "x", ":", "Instances", ")", ":", "\n", "                ", "return", "len", "(", "x", ")", "\n", "\n", "", "", "class", "g", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "forward", "(", "self", ",", "x", ":", "Instances", ")", ":", "\n", "                ", "return", "len", "(", "x", ")", "\n", "\n", "", "", "image_shape", "=", "(", "15", ",", "15", ")", "\n", "\n", "fields", "=", "{", "\"proposal_boxes\"", ":", "\"Boxes\"", "}", "\n", "with", "patch_instances", "(", "fields", ")", "as", "new_instance", ":", "\n", "            ", "script_module", "=", "torch", ".", "jit", ".", "script", "(", "f", "(", ")", ")", "\n", "x", "=", "new_instance", "(", "image_shape", ")", "\n", "with", "self", ".", "assertRaises", "(", "Exception", ")", ":", "\n", "                ", "script_module", "(", "x", ")", "\n", "", "box_tensors", "=", "torch", ".", "tensor", "(", "[", "[", "5", ",", "5", ",", "10", ",", "10", "]", ",", "[", "1", ",", "1", ",", "2", ",", "3", "]", "]", ")", "\n", "x", ".", "proposal_boxes", "=", "Boxes", "(", "box_tensors", ")", "\n", "length", "=", "script_module", "(", "x", ")", "\n", "self", ".", "assertEqual", "(", "length", ",", "2", ")", "\n", "\n", "", "fields", "=", "{", "\"objectness_logits\"", ":", "\"Tensor\"", "}", "\n", "with", "patch_instances", "(", "fields", ")", "as", "new_instance", ":", "\n", "            ", "script_module", "=", "torch", ".", "jit", ".", "script", "(", "g", "(", ")", ")", "\n", "x", "=", "new_instance", "(", "image_shape", ")", "\n", "objectness_logits", "=", "torch", ".", "tensor", "(", "[", "1.0", "]", ")", ".", "reshape", "(", "1", ",", "1", ")", "\n", "x", ".", "objectness_logits", "=", "objectness_logits", "\n", "length", "=", "script_module", "(", "x", ")", "\n", "self", ".", "assertEqual", "(", "length", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_instances.TestInstances.test_script_has": [[101, 117], ["unittest.skipIf", "detectron2.export.torchscript.patch_instances", "torch.jit.script", "new_instance", "test_instances.TestInstances.assertFalse", "torch.tensor", "detectron2.structures.Boxes", "test_instances.TestInstances.assertTrue", "new_instance.has", "f", "torch.jit.script.", "torch.jit.script."], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript_patch.patch_instances", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has"], ["", "", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "7", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_script_has", "(", "self", ")", ":", "\n", "        ", "class", "f", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "forward", "(", "self", ",", "x", ":", "Instances", ")", ":", "\n", "                ", "return", "x", ".", "has", "(", "\"proposal_boxes\"", ")", "\n", "\n", "", "", "image_shape", "=", "(", "15", ",", "15", ")", "\n", "fields", "=", "{", "\"proposal_boxes\"", ":", "\"Boxes\"", "}", "\n", "with", "patch_instances", "(", "fields", ")", "as", "new_instance", ":", "\n", "            ", "script_module", "=", "torch", ".", "jit", ".", "script", "(", "f", "(", ")", ")", "\n", "x", "=", "new_instance", "(", "image_shape", ")", "\n", "self", ".", "assertFalse", "(", "script_module", "(", "x", ")", ")", "\n", "\n", "box_tensors", "=", "torch", ".", "tensor", "(", "[", "[", "5", ",", "5", ",", "10", ",", "10", "]", ",", "[", "1", ",", "1", ",", "2", ",", "3", "]", "]", ")", "\n", "x", ".", "proposal_boxes", "=", "Boxes", "(", "box_tensors", ")", "\n", "self", ".", "assertTrue", "(", "script_module", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_rotated_boxes.TestRotatedBoxesLayer.test_iou_0_dim_cpu": [[18, 30], ["torch.rand", "torch.rand", "torch.zeros", "detectron2.layers.rotated_boxes.pairwise_iou_rotated", "test_rotated_boxes.TestRotatedBoxesLayer.assertTrue", "torch.rand", "torch.rand", "torch.zeros", "detectron2.layers.rotated_boxes.pairwise_iou_rotated", "test_rotated_boxes.TestRotatedBoxesLayer.assertTrue", "torch.allclose", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.rotated_boxes.pairwise_iou_rotated", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.rotated_boxes.pairwise_iou_rotated"], ["    ", "def", "test_iou_0_dim_cpu", "(", "self", ")", ":", "\n", "        ", "boxes1", "=", "torch", ".", "rand", "(", "0", ",", "5", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "boxes2", "=", "torch", ".", "rand", "(", "10", ",", "5", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "expected_ious", "=", "torch", ".", "zeros", "(", "0", ",", "10", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "ious", "=", "pairwise_iou_rotated", "(", "boxes1", ",", "boxes2", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n", "boxes1", "=", "torch", ".", "rand", "(", "10", ",", "5", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "boxes2", "=", "torch", ".", "rand", "(", "0", ",", "5", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "expected_ious", "=", "torch", ".", "zeros", "(", "10", ",", "0", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "ious", "=", "pairwise_iou_rotated", "(", "boxes1", ",", "boxes2", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_rotated_boxes.TestRotatedBoxesLayer.test_iou_0_dim_cuda": [[31, 44], ["unittest.skipIf", "torch.rand", "torch.rand", "torch.zeros", "detectron2.layers.rotated_boxes.pairwise_iou_rotated", "test_rotated_boxes.TestRotatedBoxesLayer.assertTrue", "torch.rand", "torch.rand", "torch.zeros", "detectron2.layers.rotated_boxes.pairwise_iou_rotated", "test_rotated_boxes.TestRotatedBoxesLayer.assertTrue", "torch.rand.cuda", "torch.rand.cuda", "torch.allclose", "torch.rand.cuda", "torch.rand.cuda", "torch.allclose", "torch.cuda.is_available", "detectron2.layers.rotated_boxes.pairwise_iou_rotated.cpu", "detectron2.layers.rotated_boxes.pairwise_iou_rotated.cpu"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.rotated_boxes.pairwise_iou_rotated", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.rotated_boxes.pairwise_iou_rotated", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda"], ["", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_iou_0_dim_cuda", "(", "self", ")", ":", "\n", "        ", "boxes1", "=", "torch", ".", "rand", "(", "0", ",", "5", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "boxes2", "=", "torch", ".", "rand", "(", "10", ",", "5", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "expected_ious", "=", "torch", ".", "zeros", "(", "0", ",", "10", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "ious_cuda", "=", "pairwise_iou_rotated", "(", "boxes1", ".", "cuda", "(", ")", ",", "boxes2", ".", "cuda", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious_cuda", ".", "cpu", "(", ")", ",", "expected_ious", ")", ")", "\n", "\n", "boxes1", "=", "torch", ".", "rand", "(", "10", ",", "5", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "boxes2", "=", "torch", ".", "rand", "(", "0", ",", "5", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "expected_ious", "=", "torch", ".", "zeros", "(", "10", ",", "0", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "ious_cuda", "=", "pairwise_iou_rotated", "(", "boxes1", ".", "cuda", "(", ")", ",", "boxes2", ".", "cuda", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious_cuda", ".", "cpu", "(", ")", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_rotated_boxes.TestRotatedBoxesLayer.test_iou_half_overlap_cpu": [[45, 51], ["torch.tensor", "torch.tensor", "torch.tensor", "detectron2.layers.rotated_boxes.pairwise_iou_rotated", "test_rotated_boxes.TestRotatedBoxesLayer.assertTrue", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.rotated_boxes.pairwise_iou_rotated"], ["", "def", "test_iou_half_overlap_cpu", "(", "self", ")", ":", "\n", "        ", "boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "0.5", ",", "0.5", ",", "1.0", ",", "1.0", ",", "0.0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "[", "[", "0.25", ",", "0.5", ",", "0.5", ",", "1.0", ",", "0.0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "expected_ious", "=", "torch", ".", "tensor", "(", "[", "[", "0.5", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "ious", "=", "pairwise_iou_rotated", "(", "boxes1", ",", "boxes2", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_rotated_boxes.TestRotatedBoxesLayer.test_iou_half_overlap_cuda": [[52, 59], ["unittest.skipIf", "torch.tensor", "torch.tensor", "torch.tensor", "detectron2.layers.rotated_boxes.pairwise_iou_rotated", "test_rotated_boxes.TestRotatedBoxesLayer.assertTrue", "torch.tensor.cuda", "torch.tensor.cuda", "torch.allclose", "torch.cuda.is_available", "detectron2.layers.rotated_boxes.pairwise_iou_rotated.cpu"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.rotated_boxes.pairwise_iou_rotated", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda"], ["", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_iou_half_overlap_cuda", "(", "self", ")", ":", "\n", "        ", "boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "0.5", ",", "0.5", ",", "1.0", ",", "1.0", ",", "0.0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "[", "[", "0.25", ",", "0.5", ",", "0.5", ",", "1.0", ",", "0.0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "expected_ious", "=", "torch", ".", "tensor", "(", "[", "[", "0.5", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "ious_cuda", "=", "pairwise_iou_rotated", "(", "boxes1", ".", "cuda", "(", ")", ",", "boxes2", ".", "cuda", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious_cuda", ".", "cpu", "(", ")", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_rotated_boxes.TestRotatedBoxesLayer.test_iou_precision": [[60, 68], ["torch.cuda.is_available", "torch.tensor", "torch.tensor", "torch.tensor", "detectron2.layers.rotated_boxes.pairwise_iou_rotated", "test_rotated_boxes.TestRotatedBoxesLayer.assertTrue", "torch.allclose", "detectron2.layers.rotated_boxes.pairwise_iou_rotated.cpu"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.rotated_boxes.pairwise_iou_rotated"], ["", "def", "test_iou_precision", "(", "self", ")", ":", "\n", "        ", "for", "device", "in", "[", "\"cpu\"", "]", "+", "[", "\"cuda\"", "]", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "[", "]", ":", "\n", "            ", "boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "565", ",", "565", ",", "10", ",", "10.0", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "[", "[", "565", ",", "565", ",", "10", ",", "8.3", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "iou", "=", "8.3", "/", "10.0", "\n", "expected_ious", "=", "torch", ".", "tensor", "(", "[", "[", "iou", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "ious", "=", "pairwise_iou_rotated", "(", "boxes1", ",", "boxes2", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ".", "cpu", "(", ")", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_rotated_boxes.TestRotatedBoxesLayer.test_iou_too_many_boxes_cuda": [[69, 76], ["unittest.skipIf", "torch.zeros", "torch.zeros", "detectron2.layers.rotated_boxes.pairwise_iou_rotated", "test_rotated_boxes.TestRotatedBoxesLayer.assertTupleEqual", "torch.zeros.cuda", "torch.zeros.cuda", "tuple", "torch.cuda.is_available"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.rotated_boxes.pairwise_iou_rotated", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda"], ["", "", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_iou_too_many_boxes_cuda", "(", "self", ")", ":", "\n", "        ", "s1", ",", "s2", "=", "5", ",", "1289035", "\n", "boxes1", "=", "torch", ".", "zeros", "(", "s1", ",", "5", ")", "\n", "boxes2", "=", "torch", ".", "zeros", "(", "s2", ",", "5", ")", "\n", "ious_cuda", "=", "pairwise_iou_rotated", "(", "boxes1", ".", "cuda", "(", ")", ",", "boxes2", ".", "cuda", "(", ")", ")", "\n", "self", ".", "assertTupleEqual", "(", "tuple", "(", "ious_cuda", ".", "shape", ")", ",", "(", "s1", ",", "s2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_rotated_boxes.TestRotatedBoxesLayer.test_iou_extreme": [[77, 95], ["torch.cuda.is_available", "torch.tensor", "torch.tensor", "detectron2.layers.rotated_boxes.pairwise_iou_rotated", "test_rotated_boxes.TestRotatedBoxesLayer.assertTrue", "detectron2.layers.rotated_boxes.pairwise_iou_rotated.min"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.rotated_boxes.pairwise_iou_rotated"], ["", "def", "test_iou_extreme", "(", "self", ")", ":", "\n", "# Cause floating point issues in cuda kernels (#1266)", "\n", "        ", "for", "device", "in", "[", "\"cpu\"", "]", "+", "[", "\"cuda\"", "]", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "[", "]", ":", "\n", "            ", "boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "160.0", ",", "153.0", ",", "230.0", ",", "23.0", ",", "-", "37.0", "]", "]", ",", "device", "=", "device", ")", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "\n", "-", "1.117407639806935e17", ",", "\n", "1.3858420478349148e18", ",", "\n", "1000.0000610351562", ",", "\n", "1000.0000610351562", ",", "\n", "1612.0", ",", "\n", "]", "\n", "]", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "ious", "=", "pairwise_iou_rotated", "(", "boxes1", ",", "boxes2", ")", "\n", "self", ".", "assertTrue", "(", "ious", ".", "min", "(", ")", ">=", "0", ",", "ious", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_clip_area_0_degree": [[98, 126], ["range", "torch.zeros", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.zeros", "detectron2.structures.boxes.Boxes", "detectron2.structures.rotated_boxes.RotatedBoxes", "detectron2.structures.boxes.Boxes.area", "detectron2.structures.rotated_boxes.RotatedBoxes.area", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "detectron2.structures.boxes.Boxes.clip", "detectron2.structures.rotated_boxes.RotatedBoxes.clip", "detectron2.structures.boxes.Boxes.area", "detectron2.structures.rotated_boxes.RotatedBoxes.area", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "torch.allclose", "torch.allclose", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.area"], ["    ", "def", "test_clip_area_0_degree", "(", "self", ")", ":", "\n", "        ", "for", "_", "in", "range", "(", "50", ")", ":", "\n", "            ", "num_boxes", "=", "100", "\n", "boxes_5d", "=", "torch", ".", "zeros", "(", "num_boxes", ",", "5", ")", "\n", "boxes_5d", "[", ":", ",", "0", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "100", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "1", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "100", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "2", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "0", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "3", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "0", ",", "500", ")", "\n", "# Convert from (x_ctr, y_ctr, w, h, 0) to  (x1, y1, x2, y2)", "\n", "boxes_4d", "=", "torch", ".", "zeros", "(", "num_boxes", ",", "4", ")", "\n", "boxes_4d", "[", ":", ",", "0", "]", "=", "boxes_5d", "[", ":", ",", "0", "]", "-", "boxes_5d", "[", ":", ",", "2", "]", "/", "2.0", "\n", "boxes_4d", "[", ":", ",", "1", "]", "=", "boxes_5d", "[", ":", ",", "1", "]", "-", "boxes_5d", "[", ":", ",", "3", "]", "/", "2.0", "\n", "boxes_4d", "[", ":", ",", "2", "]", "=", "boxes_5d", "[", ":", ",", "0", "]", "+", "boxes_5d", "[", ":", ",", "2", "]", "/", "2.0", "\n", "boxes_4d", "[", ":", ",", "3", "]", "=", "boxes_5d", "[", ":", ",", "1", "]", "+", "boxes_5d", "[", ":", ",", "3", "]", "/", "2.0", "\n", "\n", "image_size", "=", "(", "500", ",", "600", ")", "\n", "test_boxes_4d", "=", "Boxes", "(", "boxes_4d", ")", "\n", "test_boxes_5d", "=", "RotatedBoxes", "(", "boxes_5d", ")", "\n", "# Before clip", "\n", "areas_4d", "=", "test_boxes_4d", ".", "area", "(", ")", "\n", "areas_5d", "=", "test_boxes_5d", ".", "area", "(", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "areas_4d", ",", "areas_5d", ",", "atol", "=", "1e-1", ",", "rtol", "=", "1e-5", ")", ")", "\n", "# After clip", "\n", "test_boxes_4d", ".", "clip", "(", "image_size", ")", "\n", "test_boxes_5d", ".", "clip", "(", "image_size", ")", "\n", "areas_4d", "=", "test_boxes_4d", ".", "area", "(", ")", "\n", "areas_5d", "=", "test_boxes_5d", ".", "area", "(", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "areas_4d", ",", "areas_5d", ",", "atol", "=", "1e-1", ",", "rtol", "=", "1e-5", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_clip_area_arbitrary_angle": [[127, 153], ["torch.zeros", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "random.uniform", "detectron2.structures.rotated_boxes.RotatedBoxes", "detectron2.structures.rotated_boxes.RotatedBoxes.area", "detectron2.structures.rotated_boxes.RotatedBoxes.clip", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "detectron2.structures.rotated_boxes.RotatedBoxes.area", "torch.all", "torch.all", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.abs", "torch.where"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.area"], ["", "", "def", "test_clip_area_arbitrary_angle", "(", "self", ")", ":", "\n", "        ", "num_boxes", "=", "100", "\n", "boxes_5d", "=", "torch", ".", "zeros", "(", "num_boxes", ",", "5", ")", "\n", "boxes_5d", "[", ":", ",", "0", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "100", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "1", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "100", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "2", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "0", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "3", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "0", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "4", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "1800", ",", "1800", ")", "\n", "clip_angle_threshold", "=", "random", ".", "uniform", "(", "0", ",", "180", ")", "\n", "\n", "image_size", "=", "(", "500", ",", "600", ")", "\n", "test_boxes_5d", "=", "RotatedBoxes", "(", "boxes_5d", ")", "\n", "# Before clip", "\n", "areas_before", "=", "test_boxes_5d", ".", "area", "(", ")", "\n", "# After clip", "\n", "test_boxes_5d", ".", "clip", "(", "image_size", ",", "clip_angle_threshold", ")", "\n", "areas_diff", "=", "test_boxes_5d", ".", "area", "(", ")", "-", "areas_before", "\n", "\n", "# the areas should only decrease after clipping", "\n", "self", ".", "assertTrue", "(", "torch", ".", "all", "(", "areas_diff", "<=", "0", ")", ")", "\n", "# whenever the box is clipped (thus the area shrinks),", "\n", "# the angle for the box must be within the clip_angle_threshold", "\n", "# Note that the clip function will normalize the angle range", "\n", "# to be within (-180, 180]", "\n", "self", ".", "assertTrue", "(", "\n", "torch", ".", "all", "(", "torch", ".", "abs", "(", "boxes_5d", "[", ":", ",", "4", "]", "[", "torch", ".", "where", "(", "areas_diff", "<", "0", ")", "]", ")", "<", "clip_angle_threshold", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_normalize_angles": [[155, 187], ["range", "torch.zeros", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "detectron2.structures.rotated_boxes.RotatedBoxes", "detectron2.structures.rotated_boxes.RotatedBoxes.clone", "detectron2.structures.rotated_boxes.RotatedBoxes.clone.normalize_angles", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "torch.all", "torch.all", "torch.allclose", "torch.allclose", "torch.allclose", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.cos", "torch.cos", "torch.sin", "torch.sin"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.rotated_boxes.RotatedBoxes.normalize_angles"], ["", "def", "test_normalize_angles", "(", "self", ")", ":", "\n", "# torch.manual_seed(0)", "\n", "        ", "for", "_", "in", "range", "(", "50", ")", ":", "\n", "            ", "num_boxes", "=", "100", "\n", "boxes_5d", "=", "torch", ".", "zeros", "(", "num_boxes", ",", "5", ")", "\n", "boxes_5d", "[", ":", ",", "0", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "100", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "1", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "100", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "2", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "0", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "3", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "0", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "4", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "1800", ",", "1800", ")", "\n", "rotated_boxes", "=", "RotatedBoxes", "(", "boxes_5d", ")", "\n", "normalized_boxes", "=", "rotated_boxes", ".", "clone", "(", ")", "\n", "normalized_boxes", ".", "normalize_angles", "(", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "all", "(", "normalized_boxes", ".", "tensor", "[", ":", ",", "4", "]", ">=", "-", "180", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "all", "(", "normalized_boxes", ".", "tensor", "[", ":", ",", "4", "]", "<", "180", ")", ")", "\n", "# x, y, w, h should not change", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "boxes_5d", "[", ":", ",", ":", "4", "]", ",", "normalized_boxes", ".", "tensor", "[", ":", ",", ":", "4", "]", ")", ")", "\n", "# the cos/sin values of the angles should stay the same", "\n", "\n", "self", ".", "assertTrue", "(", "\n", "torch", ".", "allclose", "(", "\n", "torch", ".", "cos", "(", "boxes_5d", "[", ":", ",", "4", "]", "*", "math", ".", "pi", "/", "180", ")", ",", "\n", "torch", ".", "cos", "(", "normalized_boxes", ".", "tensor", "[", ":", ",", "4", "]", "*", "math", ".", "pi", "/", "180", ")", ",", "\n", "atol", "=", "1e-5", ",", "\n", ")", "\n", ")", "\n", "\n", "self", ".", "assertTrue", "(", "\n", "torch", ".", "allclose", "(", "\n", "torch", ".", "sin", "(", "boxes_5d", "[", ":", ",", "4", "]", "*", "math", ".", "pi", "/", "180", ")", ",", "\n", "torch", ".", "sin", "(", "normalized_boxes", ".", "tensor", "[", ":", ",", "4", "]", "*", "math", ".", "pi", "/", "180", ")", ",", "\n", "atol", "=", "1e-5", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_pairwise_iou_0_degree": [[190, 219], ["torch.cuda.is_available", "torch.tensor", "torch.tensor", "torch.tensor", "detectron2.structures.rotated_boxes.pairwise_iou", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "detectron2.structures.rotated_boxes.RotatedBoxes", "detectron2.structures.rotated_boxes.RotatedBoxes", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.pairwise_iou"], ["", "", "def", "test_pairwise_iou_0_degree", "(", "self", ")", ":", "\n", "        ", "for", "device", "in", "[", "\"cpu\"", "]", "+", "[", "\"cuda\"", "]", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "[", "]", ":", "\n", "            ", "boxes1", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "0.5", ",", "0.5", ",", "1.0", ",", "1.0", ",", "0.0", "]", ",", "[", "0.5", ",", "0.5", ",", "1.0", ",", "1.0", ",", "0.0", "]", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "0.5", ",", "0.5", ",", "1.0", ",", "1.0", ",", "0.0", "]", ",", "\n", "[", "0.25", ",", "0.5", ",", "0.5", ",", "1.0", ",", "0.0", "]", ",", "\n", "[", "0.5", ",", "0.25", ",", "1.0", ",", "0.5", ",", "0.0", "]", ",", "\n", "[", "0.25", ",", "0.25", ",", "0.5", ",", "0.5", ",", "0.0", "]", ",", "\n", "[", "0.75", ",", "0.75", ",", "0.5", ",", "0.5", ",", "0.0", "]", ",", "\n", "[", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ",", "0.0", "]", ",", "\n", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "expected_ious", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "1.0", ",", "0.5", ",", "0.5", ",", "0.25", ",", "0.25", ",", "0.25", "/", "(", "2", "-", "0.25", ")", "]", ",", "\n", "[", "1.0", ",", "0.5", ",", "0.5", ",", "0.25", ",", "0.25", ",", "0.25", "/", "(", "2", "-", "0.25", ")", "]", ",", "\n", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "ious", "=", "pairwise_iou", "(", "RotatedBoxes", "(", "boxes1", ")", ",", "RotatedBoxes", "(", "boxes2", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_pairwise_iou_45_degrees": [[220, 234], ["torch.cuda.is_available", "torch.tensor", "torch.tensor", "torch.tensor", "detectron2.structures.rotated_boxes.pairwise_iou", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "detectron2.structures.rotated_boxes.RotatedBoxes", "detectron2.structures.rotated_boxes.RotatedBoxes", "torch.allclose", "math.sqrt", "math.sqrt", "math.sqrt", "math.sqrt"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.pairwise_iou"], ["", "", "def", "test_pairwise_iou_45_degrees", "(", "self", ")", ":", "\n", "        ", "for", "device", "in", "[", "\"cpu\"", "]", "+", "[", "\"cuda\"", "]", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "[", "]", ":", "\n", "            ", "boxes1", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "1", ",", "1", ",", "math", ".", "sqrt", "(", "2", ")", ",", "math", ".", "sqrt", "(", "2", ")", ",", "45", "]", ",", "\n", "[", "1", ",", "1", ",", "2", "*", "math", ".", "sqrt", "(", "2", ")", ",", "2", "*", "math", ".", "sqrt", "(", "2", ")", ",", "-", "45", "]", ",", "\n", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "2", ",", "2", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "expected_ious", "=", "torch", ".", "tensor", "(", "[", "[", "0.5", "]", ",", "[", "0.5", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "ious", "=", "pairwise_iou", "(", "RotatedBoxes", "(", "boxes1", ")", ",", "RotatedBoxes", "(", "boxes2", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_pairwise_iou_orthogonal": [[235, 243], ["torch.cuda.is_available", "torch.tensor", "torch.tensor", "torch.tensor", "detectron2.structures.rotated_boxes.pairwise_iou", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "detectron2.structures.rotated_boxes.RotatedBoxes", "detectron2.structures.rotated_boxes.RotatedBoxes", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.pairwise_iou"], ["", "", "def", "test_pairwise_iou_orthogonal", "(", "self", ")", ":", "\n", "        ", "for", "device", "in", "[", "\"cpu\"", "]", "+", "[", "\"cuda\"", "]", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "[", "]", ":", "\n", "            ", "boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "5", ",", "5", ",", "10", ",", "6", ",", "55", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "[", "[", "5", ",", "5", ",", "10", ",", "6", ",", "-", "35", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "iou", "=", "(", "6.0", "*", "6.0", ")", "/", "(", "6.0", "*", "6.0", "+", "4.0", "*", "6.0", "+", "4.0", "*", "6.0", ")", "\n", "expected_ious", "=", "torch", ".", "tensor", "(", "[", "[", "iou", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "ious", "=", "pairwise_iou", "(", "RotatedBoxes", "(", "boxes1", ")", ",", "RotatedBoxes", "(", "boxes2", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_pairwise_iou_large_close_boxes": [[244, 260], ["torch.cuda.is_available", "torch.tensor", "torch.tensor", "torch.tensor", "detectron2.structures.rotated_boxes.pairwise_iou", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "detectron2.structures.rotated_boxes.RotatedBoxes", "detectron2.structures.rotated_boxes.RotatedBoxes", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.pairwise_iou"], ["", "", "def", "test_pairwise_iou_large_close_boxes", "(", "self", ")", ":", "\n", "        ", "for", "device", "in", "[", "\"cpu\"", "]", "+", "[", "\"cuda\"", "]", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "[", "]", ":", "\n", "            ", "boxes1", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "299.500000", ",", "417.370422", ",", "600.000000", ",", "364.259186", ",", "27.1828", "]", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "299.500000", ",", "417.370422", ",", "600.000000", ",", "364.259155", ",", "27.1828", "]", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "iou", "=", "364.259155", "/", "364.259186", "\n", "expected_ious", "=", "torch", ".", "tensor", "(", "[", "[", "iou", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "ious", "=", "pairwise_iou", "(", "RotatedBoxes", "(", "boxes1", ")", ",", "RotatedBoxes", "(", "boxes2", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_pairwise_iou_many_boxes": [[261, 288], ["torch.cuda.is_available", "torch.stack", "torch.stack", "torch.zeros", "range", "detectron2.structures.rotated_boxes.pairwise_iou", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "min", "detectron2.structures.rotated_boxes.RotatedBoxes", "detectron2.structures.rotated_boxes.RotatedBoxes", "torch.allclose", "torch.tensor", "torch.tensor", "range", "range"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.pairwise_iou"], ["", "", "def", "test_pairwise_iou_many_boxes", "(", "self", ")", ":", "\n", "        ", "for", "device", "in", "[", "\"cpu\"", "]", "+", "[", "\"cuda\"", "]", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "[", "]", ":", "\n", "            ", "num_boxes1", "=", "100", "\n", "num_boxes2", "=", "200", "\n", "boxes1", "=", "torch", ".", "stack", "(", "\n", "[", "\n", "torch", ".", "tensor", "(", "\n", "[", "5", "+", "20", "*", "i", ",", "5", "+", "20", "*", "i", ",", "10", ",", "10", ",", "0", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", "\n", ")", "\n", "for", "i", "in", "range", "(", "num_boxes1", ")", "\n", "]", "\n", ")", "\n", "boxes2", "=", "torch", ".", "stack", "(", "\n", "[", "\n", "torch", ".", "tensor", "(", "\n", "[", "5", "+", "20", "*", "i", ",", "5", "+", "20", "*", "i", ",", "10", ",", "1", "+", "9", "*", "i", "/", "num_boxes2", ",", "0", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "for", "i", "in", "range", "(", "num_boxes2", ")", "\n", "]", "\n", ")", "\n", "expected_ious", "=", "torch", ".", "zeros", "(", "num_boxes1", ",", "num_boxes2", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "for", "i", "in", "range", "(", "min", "(", "num_boxes1", ",", "num_boxes2", ")", ")", ":", "\n", "                ", "expected_ious", "[", "i", "]", "[", "i", "]", "=", "(", "1", "+", "9", "*", "i", "/", "num_boxes2", ")", "/", "10.0", "\n", "", "ious", "=", "pairwise_iou", "(", "RotatedBoxes", "(", "boxes1", ")", ",", "RotatedBoxes", "(", "boxes2", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_pairwise_iou_issue1207_simplified": [[289, 299], ["torch.cuda.is_available", "torch.tensor", "torch.tensor", "torch.tensor", "detectron2.structures.rotated_boxes.pairwise_iou", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "detectron2.structures.rotated_boxes.RotatedBoxes", "detectron2.structures.rotated_boxes.RotatedBoxes", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.pairwise_iou"], ["", "", "def", "test_pairwise_iou_issue1207_simplified", "(", "self", ")", ":", "\n", "        ", "for", "device", "in", "[", "\"cpu\"", "]", "+", "[", "\"cuda\"", "]", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "[", "]", ":", "\n", "# Simplified test case of D2-issue-1207", "\n", "            ", "boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "3", ",", "3", ",", "8", ",", "2", ",", "-", "45.0", "]", "]", ",", "device", "=", "device", ")", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "[", "[", "6", ",", "0", ",", "8", ",", "2", ",", "-", "45.0", "]", "]", ",", "device", "=", "device", ")", "\n", "iou", "=", "0.0", "\n", "expected_ious", "=", "torch", ".", "tensor", "(", "[", "[", "iou", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "\n", "ious", "=", "pairwise_iou", "(", "RotatedBoxes", "(", "boxes1", ")", ",", "RotatedBoxes", "(", "boxes2", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_pairwise_iou_issue1207": [[300, 311], ["torch.cuda.is_available", "torch.tensor", "torch.tensor", "torch.tensor", "detectron2.structures.rotated_boxes.pairwise_iou", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "detectron2.structures.rotated_boxes.RotatedBoxes", "detectron2.structures.rotated_boxes.RotatedBoxes", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.pairwise_iou"], ["", "", "def", "test_pairwise_iou_issue1207", "(", "self", ")", ":", "\n", "        ", "for", "device", "in", "[", "\"cpu\"", "]", "+", "[", "\"cuda\"", "]", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "[", "]", ":", "\n", "# The original test case in D2-issue-1207", "\n", "            ", "boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "160.0", ",", "153.0", ",", "230.0", ",", "23.0", ",", "-", "37.0", "]", "]", ",", "device", "=", "device", ")", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "[", "[", "190.0", ",", "127.0", ",", "80.0", ",", "21.0", ",", "-", "46.0", "]", "]", ",", "device", "=", "device", ")", "\n", "\n", "iou", "=", "0.0", "\n", "expected_ious", "=", "torch", ".", "tensor", "(", "[", "[", "iou", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "\n", "ious", "=", "pairwise_iou", "(", "RotatedBoxes", "(", "boxes1", ")", ",", "RotatedBoxes", "(", "boxes2", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_empty_cat": [[312, 315], ["detectron2.structures.rotated_boxes.RotatedBoxes.cat", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "", "def", "test_empty_cat", "(", "self", ")", ":", "\n", "        ", "x", "=", "RotatedBoxes", ".", "cat", "(", "[", "]", ")", "\n", "self", ".", "assertTrue", "(", "x", ".", "tensor", ".", "shape", ",", "(", "0", ",", "5", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.test_rotated_boxes.benchmark_rotated_iou": [[317, 353], ["torch.stack", "torch.stack", "torch.cuda.is_available", "fvcore.common.benchmark.benchmark", "torch.stack.to", "torch.stack.to", "args.append", "torch.tensor", "torch.tensor", "range", "torch.device", "range", "range", "detectron2.layers.rotated_boxes.pairwise_iou_rotated", "torch.cuda.synchronize", "torch.device"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.rotated_boxes.pairwise_iou_rotated", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.synchronize", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device"], ["", "", "def", "benchmark_rotated_iou", "(", ")", ":", "\n", "    ", "num_boxes1", "=", "200", "\n", "num_boxes2", "=", "500", "\n", "boxes1", "=", "torch", ".", "stack", "(", "\n", "[", "\n", "torch", ".", "tensor", "(", "[", "5", "+", "20", "*", "i", ",", "5", "+", "20", "*", "i", ",", "10", ",", "10", ",", "0", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "for", "i", "in", "range", "(", "num_boxes1", ")", "\n", "]", "\n", ")", "\n", "boxes2", "=", "torch", ".", "stack", "(", "\n", "[", "\n", "torch", ".", "tensor", "(", "\n", "[", "5", "+", "20", "*", "i", ",", "5", "+", "20", "*", "i", ",", "10", ",", "1", "+", "9", "*", "i", "/", "num_boxes2", ",", "0", "]", ",", "dtype", "=", "torch", ".", "float32", "\n", ")", "\n", "for", "i", "in", "range", "(", "num_boxes2", ")", "\n", "]", "\n", ")", "\n", "\n", "def", "func", "(", "dev", ",", "n", "=", "1", ")", ":", "\n", "        ", "b1", "=", "boxes1", ".", "to", "(", "device", "=", "dev", ")", "\n", "b2", "=", "boxes2", ".", "to", "(", "device", "=", "dev", ")", "\n", "\n", "def", "bench", "(", ")", ":", "\n", "            ", "for", "_", "in", "range", "(", "n", ")", ":", "\n", "                ", "pairwise_iou_rotated", "(", "b1", ",", "b2", ")", "\n", "", "if", "dev", ".", "type", "==", "\"cuda\"", ":", "\n", "                ", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "\n", "", "", "return", "bench", "\n", "\n", "# only run it once per timed loop, since it's slow", "\n", "", "args", "=", "[", "{", "\"dev\"", ":", "torch", ".", "device", "(", "\"cpu\"", ")", ",", "\"n\"", ":", "1", "}", "]", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "args", ".", "append", "(", "{", "\"dev\"", ":", "torch", ".", "device", "(", "\"cuda\"", ")", ",", "\"n\"", ":", "10", "}", ")", "\n", "\n", "", "benchmark", "(", "func", ",", "\"rotated_iou\"", ",", "args", ",", "warmup_iters", "=", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file": [[24, 66], ["fvcore.common.file_io.PathManager.isfile", "fvcore.common.config.CfgNode.load_yaml_with_base", "logging.getLogger", "fvcore.common.config.CfgNode.load_yaml_with_base.get", "type", "guess_version", "config.CfgNode.merge_from_other_cfg", "logging.getLogger.warning", "downgrade_config", "downgrade_config.merge_from_other_cfg", "upgrade_config", "config.CfgNode.clear", "config.CfgNode.update"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat.guess_version", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat.downgrade_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat.upgrade_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update"], ["def", "merge_from_file", "(", "self", ",", "cfg_filename", ":", "str", ",", "allow_unsafe", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "        ", "assert", "PathManager", ".", "isfile", "(", "cfg_filename", ")", ",", "f\"Config file '{cfg_filename}' does not exist!\"", "\n", "loaded_cfg", "=", "_CfgNode", ".", "load_yaml_with_base", "(", "cfg_filename", ",", "allow_unsafe", "=", "allow_unsafe", ")", "\n", "loaded_cfg", "=", "type", "(", "self", ")", "(", "loaded_cfg", ")", "\n", "\n", "# defaults.py needs to import CfgNode", "\n", "from", ".", "defaults", "import", "_C", "\n", "\n", "latest_ver", "=", "_C", ".", "VERSION", "\n", "assert", "(", "\n", "latest_ver", "==", "self", ".", "VERSION", "\n", ")", ",", "\"CfgNode.merge_from_file is only allowed on a config object of latest version!\"", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "loaded_ver", "=", "loaded_cfg", ".", "get", "(", "\"VERSION\"", ",", "None", ")", "\n", "if", "loaded_ver", "is", "None", ":", "\n", "            ", "from", ".", "compat", "import", "guess_version", "\n", "\n", "loaded_ver", "=", "guess_version", "(", "loaded_cfg", ",", "cfg_filename", ")", "\n", "", "assert", "loaded_ver", "<=", "self", ".", "VERSION", ",", "\"Cannot merge a v{} config into a v{} config.\"", ".", "format", "(", "\n", "loaded_ver", ",", "self", ".", "VERSION", "\n", ")", "\n", "\n", "if", "loaded_ver", "==", "self", ".", "VERSION", ":", "\n", "            ", "self", ".", "merge_from_other_cfg", "(", "loaded_cfg", ")", "\n", "", "else", ":", "\n", "# compat.py needs to import CfgNode", "\n", "            ", "from", ".", "compat", "import", "upgrade_config", ",", "downgrade_config", "\n", "\n", "logger", ".", "warning", "(", "\n", "\"Loading an old v{} config file '{}' by automatically upgrading to v{}. \"", "\n", "\"See docs/CHANGELOG.md for instructions to update your files.\"", ".", "format", "(", "\n", "loaded_ver", ",", "cfg_filename", ",", "self", ".", "VERSION", "\n", ")", "\n", ")", "\n", "# To convert, first obtain a full config at an old version", "\n", "old_self", "=", "downgrade_config", "(", "self", ",", "to_version", "=", "loaded_ver", ")", "\n", "old_self", ".", "merge_from_other_cfg", "(", "loaded_cfg", ")", "\n", "new_config", "=", "upgrade_config", "(", "old_self", ")", "\n", "self", ".", "clear", "(", ")", "\n", "self", ".", "update", "(", "new_config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.dump": [[67, 74], ["super().dump"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.dump"], ["", "", "def", "dump", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            str: a yaml string representation of the config\n        \"\"\"", "\n", "# to make it show up in docs", "\n", "return", "super", "(", ")", ".", "dump", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg": [[79, 89], ["_C.clone"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone"], ["def", "get_cfg", "(", ")", "->", "CfgNode", ":", "\n", "    ", "\"\"\"\n    Get a copy of the default config.\n\n    Returns:\n        a detectron2 CfgNode instance.\n    \"\"\"", "\n", "from", ".", "defaults", "import", "_C", "\n", "\n", "return", "_C", ".", "clone", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.set_global_cfg": [[91, 108], ["global_cfg.clear", "global_cfg.update"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update"], ["", "def", "set_global_cfg", "(", "cfg", ":", "CfgNode", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Let the global config point to the given cfg.\n\n    Assume that the given \"cfg\" has the key \"KEY\", after calling\n    `set_global_cfg(cfg)`, the key can be accessed by:\n    ::\n        from detectron2.config import global_cfg\n        print(global_cfg.KEY)\n\n    By using a hacky global config, you can access these configs anywhere,\n    without having to pass the config object or the values deep into the code.\n    This is a hacky feature introduced for quick prototyping / research exploration.\n    \"\"\"", "\n", "global", "global_cfg", "\n", "global_cfg", ".", "clear", "(", ")", "\n", "global_cfg", ".", "update", "(", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.configurable": [[110, 155], ["init_func.__module__.startswith", "functools.wraps", "config._called_with_cfg", "inspect.ismethod", "TypeError", "config._get_args_from_config", "init_func", "init_func", "type", "AttributeError"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config._called_with_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config._get_args_from_config"], ["", "def", "configurable", "(", "init_func", ")", ":", "\n", "    ", "\"\"\"\n    Decorate a class's __init__ method so that it can be called with a CfgNode\n    object using the class's from_config classmethod.\n\n    Examples:\n    ::\n        class A:\n            @configurable\n            def __init__(self, a, b=2, c=3):\n                pass\n\n            @classmethod\n            def from_config(cls, cfg):\n                # Returns kwargs to be passed to __init__\n                return {\"a\": cfg.A, \"b\": cfg.B}\n\n        a1 = A(a=1, b=2)  # regular construction\n        a2 = A(cfg)       # construct with a cfg\n        a3 = A(cfg, b=3, c=4)  # construct with extra overwrite\n    \"\"\"", "\n", "assert", "init_func", ".", "__name__", "==", "\"__init__\"", ",", "\"@configurable should only be used for __init__!\"", "\n", "if", "init_func", ".", "__module__", ".", "startswith", "(", "\"detectron2.\"", ")", ":", "\n", "        ", "assert", "(", "\n", "init_func", ".", "__doc__", "is", "not", "None", "and", "\"experimental\"", "in", "init_func", ".", "__doc__", "\n", ")", ",", "f\"configurable {init_func} should be marked experimental\"", "\n", "\n", "", "@", "functools", ".", "wraps", "(", "init_func", ")", "\n", "def", "wrapped", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "from_config_func", "=", "type", "(", "self", ")", ".", "from_config", "\n", "", "except", "AttributeError", "as", "e", ":", "\n", "            ", "raise", "AttributeError", "(", "\n", "\"Class with @configurable must have a 'from_config' classmethod.\"", "\n", ")", "from", "e", "\n", "", "if", "not", "inspect", ".", "ismethod", "(", "from_config_func", ")", ":", "\n", "            ", "raise", "TypeError", "(", "\"Class with @configurable must have a 'from_config' classmethod.\"", ")", "\n", "\n", "", "if", "_called_with_cfg", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "            ", "explicit_args", "=", "_get_args_from_config", "(", "from_config_func", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "init_func", "(", "self", ",", "**", "explicit_args", ")", "\n", "", "else", ":", "\n", "            ", "init_func", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "", "return", "wrapped", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config._get_args_from_config": [[157, 186], ["inspect.signature", "any", "TypeError", "from_config_func", "set", "list", "from_config_func", "from_config_func.update", "list", "inspect.signature.parameters.keys", "kwargs.keys", "inspect.signature.parameters.keys", "inspect.signature.parameters.values", "kwargs.pop"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update"], ["", "def", "_get_args_from_config", "(", "from_config_func", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Use `from_config` to obtain explicit arguments.\n\n    Returns:\n        dict: arguments to be used for cls.__init__\n    \"\"\"", "\n", "signature", "=", "inspect", ".", "signature", "(", "from_config_func", ")", "\n", "if", "list", "(", "signature", ".", "parameters", ".", "keys", "(", ")", ")", "[", "0", "]", "!=", "\"cfg\"", ":", "\n", "        ", "raise", "TypeError", "(", "\n", "f\"{from_config_func.__self__}.from_config must take 'cfg' as the first argument!\"", "\n", ")", "\n", "", "support_var_arg", "=", "any", "(", "\n", "param", ".", "kind", "in", "[", "param", ".", "VAR_POSITIONAL", ",", "param", ".", "VAR_KEYWORD", "]", "\n", "for", "param", "in", "signature", ".", "parameters", ".", "values", "(", ")", "\n", ")", "\n", "if", "support_var_arg", ":", "# forward all arguments to from_config, if from_config accepts them", "\n", "        ", "ret", "=", "from_config_func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "# forward supported arguments to from_config", "\n", "        ", "supported_arg_names", "=", "set", "(", "signature", ".", "parameters", ".", "keys", "(", ")", ")", "\n", "extra_kwargs", "=", "{", "}", "\n", "for", "name", "in", "list", "(", "kwargs", ".", "keys", "(", ")", ")", ":", "\n", "            ", "if", "name", "not", "in", "supported_arg_names", ":", "\n", "                ", "extra_kwargs", "[", "name", "]", "=", "kwargs", ".", "pop", "(", "name", ")", "\n", "", "", "ret", "=", "from_config_func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "# forward the other arguments to __init__", "\n", "ret", ".", "update", "(", "extra_kwargs", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config._called_with_cfg": [[188, 201], ["isinstance", "len", "isinstance", "kwargs.pop"], "function", ["None"], ["", "def", "_called_with_cfg", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Returns:\n        bool: whether the arguments contain CfgNode and should be considered\n            forwarded to from_config.\n    \"\"\"", "\n", "if", "len", "(", "args", ")", "and", "isinstance", "(", "args", "[", "0", "]", ",", "_CfgNode", ")", ":", "\n", "        ", "return", "True", "\n", "", "if", "isinstance", "(", "kwargs", ".", "pop", "(", "\"cfg\"", ",", "None", ")", ",", "_CfgNode", ")", ":", "\n", "        ", "return", "True", "\n", "# `from_config`'s first argument is forced to be \"cfg\".", "\n", "# So the above check covers all cases.", "\n", "", "return", "False", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat._RenameConverter.upgrade": [[153, 157], ["compat._rename"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat._rename"], ["@", "classmethod", "\n", "def", "upgrade", "(", "cls", ",", "cfg", ":", "CN", ")", "->", "None", ":", "\n", "        ", "for", "old", ",", "new", "in", "cls", ".", "RENAME", ":", "\n", "            ", "_rename", "(", "cfg", ",", "old", ",", "new", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat._RenameConverter.downgrade": [[158, 162], ["compat._rename"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat._rename"], ["", "", "@", "classmethod", "\n", "def", "downgrade", "(", "cls", ",", "cfg", ":", "CN", ")", "->", "None", ":", "\n", "        ", "for", "old", ",", "new", "in", "cls", ".", "RENAME", "[", ":", ":", "-", "1", "]", ":", "\n", "            ", "_rename", "(", "cfg", ",", "new", ",", "old", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat.ConverterV2.upgrade": [[203, 220], ["compat._RenameConverter.upgrade", "compat._rename", "compat._rename", "compat._rename", "compat._rename"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat.ConverterV2.upgrade", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat._rename", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat._rename", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat._rename", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat._rename"], ["@", "classmethod", "\n", "def", "upgrade", "(", "cls", ",", "cfg", ":", "CN", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "upgrade", "(", "cfg", ")", "\n", "\n", "if", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "==", "\"RetinaNet\"", ":", "\n", "            ", "_rename", "(", "\n", "cfg", ",", "\"MODEL.RETINANET.ANCHOR_ASPECT_RATIOS\"", ",", "\"MODEL.ANCHOR_GENERATOR.ASPECT_RATIOS\"", "\n", ")", "\n", "_rename", "(", "cfg", ",", "\"MODEL.RETINANET.ANCHOR_SIZES\"", ",", "\"MODEL.ANCHOR_GENERATOR.SIZES\"", ")", "\n", "del", "cfg", "[", "\"MODEL\"", "]", "[", "\"RPN\"", "]", "[", "\"ANCHOR_SIZES\"", "]", "\n", "del", "cfg", "[", "\"MODEL\"", "]", "[", "\"RPN\"", "]", "[", "\"ANCHOR_ASPECT_RATIOS\"", "]", "\n", "", "else", ":", "\n", "            ", "_rename", "(", "cfg", ",", "\"MODEL.RPN.ANCHOR_ASPECT_RATIOS\"", ",", "\"MODEL.ANCHOR_GENERATOR.ASPECT_RATIOS\"", ")", "\n", "_rename", "(", "cfg", ",", "\"MODEL.RPN.ANCHOR_SIZES\"", ",", "\"MODEL.ANCHOR_GENERATOR.SIZES\"", ")", "\n", "del", "cfg", "[", "\"MODEL\"", "]", "[", "\"RETINANET\"", "]", "[", "\"ANCHOR_SIZES\"", "]", "\n", "del", "cfg", "[", "\"MODEL\"", "]", "[", "\"RETINANET\"", "]", "[", "\"ANCHOR_ASPECT_RATIOS\"", "]", "\n", "", "del", "cfg", "[", "\"MODEL\"", "]", "[", "\"RETINANET\"", "]", "[", "\"ANCHOR_STRIDES\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat.ConverterV2.downgrade": [[221, 230], ["compat._RenameConverter.downgrade", "compat._rename", "compat._rename"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat.ConverterV2.downgrade", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat._rename", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat._rename"], ["", "@", "classmethod", "\n", "def", "downgrade", "(", "cls", ",", "cfg", ":", "CN", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "downgrade", "(", "cfg", ")", "\n", "\n", "_rename", "(", "cfg", ",", "\"MODEL.ANCHOR_GENERATOR.ASPECT_RATIOS\"", ",", "\"MODEL.RPN.ANCHOR_ASPECT_RATIOS\"", ")", "\n", "_rename", "(", "cfg", ",", "\"MODEL.ANCHOR_GENERATOR.SIZES\"", ",", "\"MODEL.RPN.ANCHOR_SIZES\"", ")", "\n", "cfg", ".", "MODEL", ".", "RETINANET", ".", "ANCHOR_ASPECT_RATIOS", "=", "cfg", ".", "MODEL", ".", "RPN", ".", "ANCHOR_ASPECT_RATIOS", "\n", "cfg", ".", "MODEL", ".", "RETINANET", ".", "ANCHOR_SIZES", "=", "cfg", ".", "MODEL", ".", "RPN", ".", "ANCHOR_SIZES", "\n", "cfg", ".", "MODEL", ".", "RETINANET", ".", "ANCHOR_STRIDES", "=", "[", "]", "# this is not used anywhere in any version", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat.upgrade_config": [[33, 53], ["cfg.clone.clone", "range", "converter.upgrade", "globals", "str"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat.ConverterV2.upgrade"], ["def", "upgrade_config", "(", "cfg", ":", "CN", ",", "to_version", ":", "Optional", "[", "int", "]", "=", "None", ")", "->", "CN", ":", "\n", "    ", "\"\"\"\n    Upgrade a config from its current version to a newer version.\n\n    Args:\n        cfg (CfgNode):\n        to_version (int): defaults to the latest version.\n    \"\"\"", "\n", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "if", "to_version", "is", "None", ":", "\n", "        ", "to_version", "=", "_C", ".", "VERSION", "\n", "\n", "", "assert", "cfg", ".", "VERSION", "<=", "to_version", ",", "\"Cannot upgrade from v{} to v{}!\"", ".", "format", "(", "\n", "cfg", ".", "VERSION", ",", "to_version", "\n", ")", "\n", "for", "k", "in", "range", "(", "cfg", ".", "VERSION", ",", "to_version", ")", ":", "\n", "        ", "converter", "=", "globals", "(", ")", "[", "\"ConverterV\"", "+", "str", "(", "k", "+", "1", ")", "]", "\n", "converter", ".", "upgrade", "(", "cfg", ")", "\n", "cfg", ".", "VERSION", "=", "k", "+", "1", "\n", "", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat.downgrade_config": [[55, 80], ["cfg.clone.clone", "range", "converter.downgrade", "globals", "str"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat.ConverterV2.downgrade"], ["", "def", "downgrade_config", "(", "cfg", ":", "CN", ",", "to_version", ":", "int", ")", "->", "CN", ":", "\n", "    ", "\"\"\"\n    Downgrade a config from its current version to an older version.\n\n    Args:\n        cfg (CfgNode):\n        to_version (int):\n\n    Note:\n        A general downgrade of arbitrary configs is not always possible due to the\n        different functionalities in different versions.\n        The purpose of downgrade is only to recover the defaults in old versions,\n        allowing it to load an old partial yaml config.\n        Therefore, the implementation only needs to fill in the default values\n        in the old version when a general downgrade is not possible.\n    \"\"\"", "\n", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "assert", "cfg", ".", "VERSION", ">=", "to_version", ",", "\"Cannot downgrade from v{} to v{}!\"", ".", "format", "(", "\n", "cfg", ".", "VERSION", ",", "to_version", "\n", ")", "\n", "for", "k", "in", "range", "(", "cfg", ".", "VERSION", ",", "to_version", ",", "-", "1", ")", ":", "\n", "        ", "converter", "=", "globals", "(", ")", "[", "\"ConverterV\"", "+", "str", "(", "k", ")", "]", "\n", "converter", ".", "downgrade", "(", "cfg", ")", "\n", "cfg", ".", "VERSION", "=", "k", "-", "1", "\n", "", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat.guess_version": [[82, 114], ["logging.getLogger", "name.split", "compat.guess_version._has"], "function", ["None"], ["", "def", "guess_version", "(", "cfg", ":", "CN", ",", "filename", ":", "str", ")", "->", "int", ":", "\n", "    ", "\"\"\"\n    Guess the version of a partial config where the VERSION field is not specified.\n    Returns the version, or the latest if cannot make a guess.\n\n    This makes it easier for users to migrate.\n    \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "def", "_has", "(", "name", ":", "str", ")", "->", "bool", ":", "\n", "        ", "cur", "=", "cfg", "\n", "for", "n", "in", "name", ".", "split", "(", "\".\"", ")", ":", "\n", "            ", "if", "n", "not", "in", "cur", ":", "\n", "                ", "return", "False", "\n", "", "cur", "=", "cur", "[", "n", "]", "\n", "", "return", "True", "\n", "\n", "# Most users' partial configs have \"MODEL.WEIGHT\", so guess on it", "\n", "", "ret", "=", "None", "\n", "if", "_has", "(", "\"MODEL.WEIGHT\"", ")", "or", "_has", "(", "\"TEST.AUG_ON\"", ")", ":", "\n", "        ", "ret", "=", "1", "\n", "\n", "", "if", "ret", "is", "not", "None", ":", "\n", "        ", "logger", ".", "warning", "(", "\"Config '{}' has no VERSION. Assuming it to be v{}.\"", ".", "format", "(", "filename", ",", "ret", ")", ")", "\n", "", "else", ":", "\n", "        ", "ret", "=", "_C", ".", "VERSION", "\n", "logger", ".", "warning", "(", "\n", "\"Config '{}' has no VERSION. Assuming it to be compatible with latest v{}.\"", ".", "format", "(", "\n", "filename", ",", "ret", "\n", ")", "\n", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat._rename": [[116, 144], ["old.split", "new.split", "compat._rename._set"], "function", ["None"], ["", "def", "_rename", "(", "cfg", ":", "CN", ",", "old", ":", "str", ",", "new", ":", "str", ")", "->", "None", ":", "\n", "    ", "old_keys", "=", "old", ".", "split", "(", "\".\"", ")", "\n", "new_keys", "=", "new", ".", "split", "(", "\".\"", ")", "\n", "\n", "def", "_set", "(", "key_seq", ":", "List", "[", "str", "]", ",", "val", ":", "str", ")", "->", "None", ":", "\n", "        ", "cur", "=", "cfg", "\n", "for", "k", "in", "key_seq", "[", ":", "-", "1", "]", ":", "\n", "            ", "if", "k", "not", "in", "cur", ":", "\n", "                ", "cur", "[", "k", "]", "=", "CN", "(", ")", "\n", "", "cur", "=", "cur", "[", "k", "]", "\n", "", "cur", "[", "key_seq", "[", "-", "1", "]", "]", "=", "val", "\n", "\n", "", "def", "_get", "(", "key_seq", ":", "List", "[", "str", "]", ")", "->", "CN", ":", "\n", "        ", "cur", "=", "cfg", "\n", "for", "k", "in", "key_seq", ":", "\n", "            ", "cur", "=", "cur", "[", "k", "]", "\n", "", "return", "cur", "\n", "\n", "", "def", "_del", "(", "key_seq", ":", "List", "[", "str", "]", ")", "->", "None", ":", "\n", "        ", "cur", "=", "cfg", "\n", "for", "k", "in", "key_seq", "[", ":", "-", "1", "]", ":", "\n", "            ", "cur", "=", "cur", "[", "k", "]", "\n", "", "del", "cur", "[", "key_seq", "[", "-", "1", "]", "]", "\n", "if", "len", "(", "cur", ")", "==", "0", "and", "len", "(", "key_seq", ")", ">", "1", ":", "\n", "            ", "_del", "(", "key_seq", "[", ":", "-", "1", "]", ")", "\n", "\n", "", "", "_set", "(", "new_keys", ",", "_get", "(", "old_keys", ")", ")", "\n", "_del", "(", "old_keys", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers._NewEmptyTensorOp.forward": [[31, 35], ["x.new_empty"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "x", ",", "new_shape", ")", ":", "\n", "        ", "ctx", ".", "shape", "=", "x", ".", "shape", "\n", "return", "x", ".", "new_empty", "(", "new_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers._NewEmptyTensorOp.backward": [[36, 40], ["_NewEmptyTensorOp.apply"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad", ")", ":", "\n", "        ", "shape", "=", "ctx", ".", "shape", "\n", "return", "_NewEmptyTensorOp", ".", "apply", "(", "grad", ",", "shape", ")", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.Conv2d.__init__": [[47, 63], ["kwargs.pop", "kwargs.pop", "super().__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Extra keyword arguments supported in addition to those in `torch.nn.Conv2d`:\n\n        Args:\n            norm (nn.Module, optional): a normalization layer\n            activation (callable(Tensor) -> Tensor): a callable activation function\n\n        It assumes that norm layer is used before activation.\n        \"\"\"", "\n", "norm", "=", "kwargs", ".", "pop", "(", "\"norm\"", ",", "None", ")", "\n", "activation", "=", "kwargs", ".", "pop", "(", "\"activation\"", ",", "None", ")", "\n", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "norm", "=", "norm", "\n", "self", ".", "activation", "=", "activation", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.Conv2d.forward": [[64, 110], ["torch.conv2d", "torch.conv2d", "torch.jit.is_scripting", "torch.jit.is_scripting", "torch.jit.is_scripting", "torch.jit.is_scripting", "wrappers.Conv2d.norm", "wrappers.Conv2d.activation", "_NewEmptyTensorOp.apply", "wrappers.Conv2d.numel", "isinstance", "wrappers.Conv2d.numel", "isinstance", "zip", "sum", "wrappers.Conv2d.view", "wrappers.Conv2d.parameters"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.norm"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "# torchscript does not support SyncBatchNorm yet", "\n", "# https://github.com/pytorch/pytorch/issues/40507", "\n", "# and we skip these codes in torchscript since:", "\n", "# 1. currently we only support torchscript in evaluation mode", "\n", "# 2. features needed by exporting module to torchscript are added in PyTorch 1.6 or", "\n", "# later version, `Conv2d` in these PyTorch versions has already supported empty inputs.", "\n", "        ", "if", "not", "torch", ".", "jit", ".", "is_scripting", "(", ")", ":", "\n", "            ", "if", "x", ".", "numel", "(", ")", "==", "0", "and", "self", ".", "training", ":", "\n", "# https://github.com/pytorch/pytorch/issues/12013", "\n", "                ", "assert", "not", "isinstance", "(", "\n", "self", ".", "norm", ",", "torch", ".", "nn", ".", "SyncBatchNorm", "\n", ")", ",", "\"SyncBatchNorm does not support empty inputs!\"", "\n", "\n", "", "if", "x", ".", "numel", "(", ")", "==", "0", "and", "TORCH_VERSION", "<=", "(", "1", ",", "4", ")", ":", "\n", "                ", "assert", "not", "isinstance", "(", "\n", "self", ".", "norm", ",", "torch", ".", "nn", ".", "GroupNorm", "\n", ")", ",", "\"GroupNorm does not support empty inputs in PyTorch <=1.4!\"", "\n", "# When input is empty, we want to return a empty tensor with \"correct\" shape,", "\n", "# So that the following operations will not panic", "\n", "# if they check for the shape of the tensor.", "\n", "# This computes the height and width of the output tensor", "\n", "output_shape", "=", "[", "\n", "(", "i", "+", "2", "*", "p", "-", "(", "di", "*", "(", "k", "-", "1", ")", "+", "1", ")", ")", "//", "s", "+", "1", "\n", "for", "i", ",", "p", ",", "di", ",", "k", ",", "s", "in", "zip", "(", "\n", "x", ".", "shape", "[", "-", "2", ":", "]", ",", "self", ".", "padding", ",", "self", ".", "dilation", ",", "self", ".", "kernel_size", ",", "self", ".", "stride", "\n", ")", "\n", "]", "\n", "output_shape", "=", "[", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "weight", ".", "shape", "[", "0", "]", "]", "+", "output_shape", "\n", "empty", "=", "_NewEmptyTensorOp", ".", "apply", "(", "x", ",", "output_shape", ")", "\n", "if", "self", ".", "training", ":", "\n", "# This is to make DDP happy.", "\n", "# DDP expects all workers to have gradient w.r.t the same set of parameters.", "\n", "                    ", "_dummy", "=", "sum", "(", "[", "x", ".", "view", "(", "-", "1", ")", "[", "0", "]", "for", "x", "in", "self", ".", "parameters", "(", ")", "]", ")", "*", "0.0", "\n", "return", "empty", "+", "_dummy", "\n", "", "else", ":", "\n", "                    ", "return", "empty", "\n", "\n", "", "", "", "x", "=", "F", ".", "conv2d", "(", "\n", "x", ",", "self", ".", "weight", ",", "self", ".", "bias", ",", "self", ".", "stride", ",", "self", ".", "padding", ",", "self", ".", "dilation", ",", "self", ".", "groups", "\n", ")", "\n", "if", "self", ".", "norm", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "norm", "(", "x", ")", "\n", "", "if", "self", ".", "activation", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "activation", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat": [[20, 28], ["isinstance", "torch.cat", "torch.cat", "len"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["def", "cat", "(", "tensors", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "dim", ":", "int", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Efficient version of torch.cat that avoids a copy if there is only a single element in a list\n    \"\"\"", "\n", "assert", "isinstance", "(", "tensors", ",", "(", "list", ",", "tuple", ")", ")", "\n", "if", "len", "(", "tensors", ")", "==", "1", ":", "\n", "        ", "return", "tensors", "[", "0", "]", "\n", "", "return", "torch", ".", "cat", "(", "tensors", ",", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.nonzero_tuple": [[233, 241], ["x.nonzero().unbind", "x.dim", "x.unsqueeze().nonzero().unbind", "x.nonzero", "x.unsqueeze().nonzero", "x.unsqueeze"], "function", ["None"], ["", "", "def", "nonzero_tuple", "(", "x", ")", ":", "\n", "    ", "\"\"\"\n    A 'as_tuple=True' version of torch.nonzero to support torchscript.\n    because of https://github.com/pytorch/pytorch/issues/38718\n    \"\"\"", "\n", "if", "x", ".", "dim", "(", ")", "==", "0", ":", "\n", "        ", "return", "x", ".", "unsqueeze", "(", "0", ")", ".", "nonzero", "(", ")", ".", "unbind", "(", "1", ")", "\n", "", "return", "x", ".", "nonzero", "(", ")", ".", "unbind", "(", "1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.batched_nms": [[10, 30], ["scores.new_zeros", "torch.jit.annotate", "scores.new_zeros.nonzero().view", "len", "torchvision.ops.boxes.batched_nms", "scores.size", "torch.unique().cpu().tolist", "torchvision.ops.nms", "scores.new_zeros.nonzero", "scores[].argsort", "torch.unique().cpu", "torch.unique"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.batched_nms"], ["def", "batched_nms", "(", "\n", "boxes", ":", "torch", ".", "Tensor", ",", "scores", ":", "torch", ".", "Tensor", ",", "idxs", ":", "torch", ".", "Tensor", ",", "iou_threshold", ":", "float", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Same as torchvision.ops.boxes.batched_nms, but safer.\n    \"\"\"", "\n", "assert", "boxes", ".", "shape", "[", "-", "1", "]", "==", "4", "\n", "# TODO may need better strategy.", "\n", "# Investigate after having a fully-cuda NMS op.", "\n", "if", "len", "(", "boxes", ")", "<", "40000", ":", "\n", "        ", "return", "box_ops", ".", "batched_nms", "(", "boxes", ",", "scores", ",", "idxs", ",", "iou_threshold", ")", "\n", "\n", "", "result_mask", "=", "scores", ".", "new_zeros", "(", "scores", ".", "size", "(", ")", ",", "dtype", "=", "torch", ".", "bool", ")", "\n", "for", "id", "in", "torch", ".", "jit", ".", "annotate", "(", "List", "[", "int", "]", ",", "torch", ".", "unique", "(", "idxs", ")", ".", "cpu", "(", ")", ".", "tolist", "(", ")", ")", ":", "\n", "        ", "mask", "=", "(", "idxs", "==", "id", ")", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "keep", "=", "nms", "(", "boxes", "[", "mask", "]", ",", "scores", "[", "mask", "]", ",", "iou_threshold", ")", "\n", "result_mask", "[", "mask", "[", "keep", "]", "]", "=", "True", "\n", "", "keep", "=", "result_mask", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "keep", "=", "keep", "[", "scores", "[", "keep", "]", ".", "argsort", "(", "descending", "=", "True", ")", "]", "\n", "return", "keep", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.nms_rotated": [[34, 98], ["_C.nms_rotated"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.nms_rotated"], ["", "def", "nms_rotated", "(", "boxes", ",", "scores", ",", "iou_threshold", ")", ":", "\n", "    ", "\"\"\"\n    Performs non-maximum suppression (NMS) on the rotated boxes according\n    to their intersection-over-union (IoU).\n\n    Rotated NMS iteratively removes lower scoring rotated boxes which have an\n    IoU greater than iou_threshold with another (higher scoring) rotated box.\n\n    Note that RotatedBox (5, 3, 4, 2, -90) covers exactly the same region as\n    RotatedBox (5, 3, 4, 2, 90) does, and their IoU will be 1. However, they\n    can be representing completely different objects in certain tasks, e.g., OCR.\n\n    As for the question of whether rotated-NMS should treat them as faraway boxes\n    even though their IOU is 1, it depends on the application and/or ground truth annotation.\n\n    As an extreme example, consider a single character v and the square box around it.\n\n    If the angle is 0 degree, the object (text) would be read as 'v';\n\n    If the angle is 90 degrees, the object (text) would become '>';\n\n    If the angle is 180 degrees, the object (text) would become '^';\n\n    If the angle is 270/-90 degrees, the object (text) would become '<'\n\n    All of these cases have IoU of 1 to each other, and rotated NMS that only\n    uses IoU as criterion would only keep one of them with the highest score -\n    which, practically, still makes sense in most cases because typically\n    only one of theses orientations is the correct one. Also, it does not matter\n    as much if the box is only used to classify the object (instead of transcribing\n    them with a sequential OCR recognition model) later.\n\n    On the other hand, when we use IoU to filter proposals that are close to the\n    ground truth during training, we should definitely take the angle into account if\n    we know the ground truth is labeled with the strictly correct orientation (as in,\n    upside-down words are annotated with -180 degrees even though they can be covered\n    with a 0/90/-90 degree box, etc.)\n\n    The way the original dataset is annotated also matters. For example, if the dataset\n    is a 4-point polygon dataset that does not enforce ordering of vertices/orientation,\n    we can estimate a minimum rotated bounding box to this polygon, but there's no way\n    we can tell the correct angle with 100% confidence (as shown above, there could be 4 different\n    rotated boxes, with angles differed by 90 degrees to each other, covering the exactly\n    same region). In that case we have to just use IoU to determine the box\n    proximity (as many detection benchmarks (even for text) do) unless there're other\n    assumptions we can make (like width is always larger than height, or the object is not\n    rotated by more than 90 degrees CCW/CW, etc.)\n\n    In summary, not considering angles in rotated NMS seems to be a good option for now,\n    but we should be aware of its implications.\n\n    Args:\n        boxes (Tensor[N, 5]): Rotated boxes to perform NMS on. They are expected to be in\n           (x_center, y_center, width, height, angle_degrees) format.\n        scores (Tensor[N]): Scores for each one of the rotated boxes\n        iou_threshold (float): Discards all overlapping rotated boxes with IoU < iou_threshold\n\n    Returns:\n        keep (Tensor): int64 tensor with the indices of the elements that have been kept\n        by Rotated NMS, sorted in decreasing order of scores\n    \"\"\"", "\n", "from", "detectron2", "import", "_C", "\n", "\n", "return", "_C", ".", "nms_rotated", "(", "boxes", ",", "scores", ",", "iou_threshold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.batched_nms_rotated": [[102, 150], ["torchvision.ops.boxes.clone", "nms.nms_rotated", "torchvision.ops.boxes.numel", "torch.empty", "idxs.to", "torch.max", "torch.min", "torch.max", "torch.max"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.nms_rotated", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "batched_nms_rotated", "(", "boxes", ",", "scores", ",", "idxs", ",", "iou_threshold", ")", ":", "\n", "    ", "\"\"\"\n    Performs non-maximum suppression in a batched fashion.\n\n    Each index value correspond to a category, and NMS\n    will not be applied between elements of different categories.\n\n    Args:\n        boxes (Tensor[N, 5]):\n           boxes where NMS will be performed. They\n           are expected to be in (x_ctr, y_ctr, width, height, angle_degrees) format\n        scores (Tensor[N]):\n           scores for each one of the boxes\n        idxs (Tensor[N]):\n           indices of the categories for each one of the boxes.\n        iou_threshold (float):\n           discards all overlapping boxes\n           with IoU < iou_threshold\n\n    Returns:\n        Tensor:\n            int64 tensor with the indices of the elements that have been kept\n            by NMS, sorted in decreasing order of scores\n    \"\"\"", "\n", "assert", "boxes", ".", "shape", "[", "-", "1", "]", "==", "5", "\n", "\n", "if", "boxes", ".", "numel", "(", ")", "==", "0", ":", "\n", "        ", "return", "torch", ".", "empty", "(", "(", "0", ",", ")", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "boxes", ".", "device", ")", "\n", "# Strategy: in order to perform NMS independently per class,", "\n", "# we add an offset to all the boxes. The offset is dependent", "\n", "# only on the class idx, and is large enough so that boxes", "\n", "# from different classes do not overlap", "\n", "\n", "# Note that batched_nms in torchvision/ops/boxes.py only uses max_coordinate,", "\n", "# which won't handle negative coordinates correctly.", "\n", "# Here by using min_coordinate we can make sure the negative coordinates are", "\n", "# correctly handled.", "\n", "", "max_coordinate", "=", "(", "\n", "torch", ".", "max", "(", "boxes", "[", ":", ",", "0", "]", ",", "boxes", "[", ":", ",", "1", "]", ")", "+", "torch", ".", "max", "(", "boxes", "[", ":", ",", "2", "]", ",", "boxes", "[", ":", ",", "3", "]", ")", "/", "2", "\n", ")", ".", "max", "(", ")", "\n", "min_coordinate", "=", "(", "\n", "torch", ".", "min", "(", "boxes", "[", ":", ",", "0", "]", ",", "boxes", "[", ":", ",", "1", "]", ")", "-", "torch", ".", "max", "(", "boxes", "[", ":", ",", "2", "]", ",", "boxes", "[", ":", ",", "3", "]", ")", "/", "2", "\n", ")", ".", "min", "(", ")", "\n", "offsets", "=", "idxs", ".", "to", "(", "boxes", ")", "*", "(", "max_coordinate", "-", "min_coordinate", "+", "1", ")", "\n", "boxes_for_nms", "=", "boxes", ".", "clone", "(", ")", "# avoid modifying the original values in boxes", "\n", "boxes_for_nms", "[", ":", ",", ":", "2", "]", "+=", "offsets", "[", ":", ",", "None", "]", "\n", "keep", "=", "nms_rotated", "(", "boxes_for_nms", ",", "scores", ",", "iou_threshold", ")", "\n", "return", "keep", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.aspp.ASPP.__init__": [[17, 107], ["torch.nn.Module.__init__", "torch.nn.ModuleList", "aspp.ASPP.convs.append", "fvcore.c2_xavier_fill", "fvcore.c2_xavier_fill", "aspp.ASPP.convs.append", "wrappers.Conv2d", "fvcore.c2_xavier_fill", "len", "len", "wrappers.Conv2d", "aspp.ASPP.convs.append", "fvcore.c2_xavier_fill", "torch.nn.Sequential", "torch.nn.Sequential", "wrappers.Conv2d", "torch.nn.AdaptiveAvgPool2d", "wrappers.Conv2d", "torch.nn.AvgPool2d", "wrappers.Conv2d", "batch_norm.get_norm", "batch_norm.get_norm", "batch_norm.get_norm"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "dilations", ",", "\n", "norm", ",", "\n", "activation", ",", "\n", "pool_kernel_size", "=", "None", ",", "\n", "dropout", ":", "float", "=", "0.0", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            in_channels (int): number of input channels for ASPP.\n            out_channels (int): number of output channels.\n            dilations (list): a list of 3 dilations in ASPP.\n            norm (str or callable): normalization for all conv layers.\n                See :func:`layers.get_norm` for supported format. norm is\n                applied to all conv layers except the conv following\n                global average pooling.\n            activation (callable): activation function.\n            pool_kernel_size (tuple, list): the average pooling size (kh, kw)\n                for image pooling layer in ASPP. If set to None, it always\n                performs global average pooling. If not None, it must be\n                divisible by the shape of inputs in forward(). It is recommended\n                to use a fixed input feature size in training, and set this\n                option to match this size, so that it performs global average\n                pooling in training, and the size of the pooling window stays\n                consistent in inference.\n            dropout (float): apply dropout on the output of ASPP. It is used in\n                the official DeepLab implementation with a rate of 0.1:\n                https://github.com/tensorflow/models/blob/21b73d22f3ed05b650e85ac50849408dd36de32e/research/deeplab/model.py#L532  # noqa\n        \"\"\"", "\n", "super", "(", "ASPP", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "len", "(", "dilations", ")", "==", "3", ",", "\"ASPP expects 3 dilations, got {}\"", ".", "format", "(", "len", "(", "dilations", ")", ")", "\n", "self", ".", "pool_kernel_size", "=", "pool_kernel_size", "\n", "self", ".", "dropout", "=", "dropout", "\n", "use_bias", "=", "norm", "==", "\"\"", "\n", "self", ".", "convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "# conv 1x1", "\n", "self", ".", "convs", ".", "append", "(", "\n", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "bias", "=", "use_bias", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", "activation", "=", "activation", ",", "\n", ")", "\n", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "convs", "[", "-", "1", "]", ")", "\n", "# atrous convs", "\n", "for", "dilation", "in", "dilations", ":", "\n", "            ", "self", ".", "convs", ".", "append", "(", "\n", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "dilation", ",", "\n", "dilation", "=", "dilation", ",", "\n", "bias", "=", "use_bias", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", "activation", "=", "activation", ",", "\n", ")", "\n", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "convs", "[", "-", "1", "]", ")", "\n", "# image pooling", "\n", "# We do not add BatchNorm because the spatial resolution is 1x1,", "\n", "# the original TF implementation has BatchNorm.", "\n", "", "if", "pool_kernel_size", "is", "None", ":", "\n", "            ", "image_pooling", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "AdaptiveAvgPool2d", "(", "1", ")", ",", "\n", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "1", ",", "bias", "=", "True", ",", "activation", "=", "activation", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "image_pooling", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "AvgPool2d", "(", "kernel_size", "=", "pool_kernel_size", ",", "stride", "=", "1", ")", ",", "\n", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "1", ",", "bias", "=", "True", ",", "activation", "=", "activation", ")", ",", "\n", ")", "\n", "", "weight_init", ".", "c2_xavier_fill", "(", "image_pooling", "[", "1", "]", ")", "\n", "self", ".", "convs", ".", "append", "(", "image_pooling", ")", "\n", "\n", "self", ".", "project", "=", "Conv2d", "(", "\n", "5", "*", "out_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "bias", "=", "use_bias", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", "activation", "=", "activation", ",", "\n", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "project", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.aspp.ASPP.forward": [[108, 124], ["torch.nn.functional.interpolate", "torch.cat", "aspp.ASPP.project", "aspp.ASPP.append", "torch.nn.functional.dropout", "ValueError", "conv"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "size", "=", "x", ".", "shape", "[", "-", "2", ":", "]", "\n", "if", "self", ".", "pool_kernel_size", "is", "not", "None", ":", "\n", "            ", "if", "size", "[", "0", "]", "%", "self", ".", "pool_kernel_size", "[", "0", "]", "or", "size", "[", "1", "]", "%", "self", ".", "pool_kernel_size", "[", "1", "]", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"`pool_kernel_size` must be divisible by the shape of inputs. \"", "\n", "\"Input size: {} `pool_kernel_size`: {}\"", ".", "format", "(", "size", ",", "self", ".", "pool_kernel_size", ")", "\n", ")", "\n", "", "", "res", "=", "[", "]", "\n", "for", "conv", "in", "self", ".", "convs", ":", "\n", "            ", "res", ".", "append", "(", "conv", "(", "x", ")", ")", "\n", "", "res", "[", "-", "1", "]", "=", "F", ".", "interpolate", "(", "res", "[", "-", "1", "]", ",", "size", "=", "size", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", "\n", "res", "=", "torch", ".", "cat", "(", "res", ",", "dim", "=", "1", ")", "\n", "res", "=", "self", ".", "project", "(", "res", ")", "\n", "res", "=", "F", ".", "dropout", "(", "res", ",", "self", ".", "dropout", ",", "training", "=", "self", ".", "training", ")", "if", "self", ".", "dropout", ">", "0", "else", "res", "\n", "return", "res", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.rotated_boxes.pairwise_iou_rotated": [[7, 23], ["detectron2._C.box_iou_rotated"], "function", ["None"], ["\n", "from", ".", "boxes", "import", "Boxes", "\n", "\n", "\n", "class", "RotatedBoxes", "(", "Boxes", ")", ":", "\n", "    ", "\"\"\"\n    This structure stores a list of rotated boxes as a Nx5 torch.Tensor.\n    It supports some common methods about boxes\n    (`area`, `clip`, `nonempty`, etc),\n    and also behaves like a Tensor\n    (support indexing, `to(device)`, `.device`, and iteration over all boxes)\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "tensor", ":", "torch", ".", "Tensor", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.deform_conv._DeformConv.forward": [[16, 74], ["torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "ctx.save_for_backward", "input.new_empty", "ValueError", "deform_conv._DeformConv._output_size", "input.new_empty", "input.new_empty", "NotImplementedError", "deform_conv._DeformConv._cal_im2col_step", "detectron2._C.deform_conv_forward", "input.dim", "weight.size", "weight.size", "input.dim"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.deform_conv._DeformConv._output_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.deform_conv._DeformConv._cal_im2col_step"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "\n", "ctx", ",", "\n", "input", ",", "\n", "offset", ",", "\n", "weight", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "deformable_groups", "=", "1", ",", "\n", "im2col_step", "=", "64", ",", "\n", ")", ":", "\n", "        ", "if", "input", "is", "not", "None", "and", "input", ".", "dim", "(", ")", "!=", "4", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Expected 4D tensor as input, got {}D tensor instead.\"", ".", "format", "(", "input", ".", "dim", "(", ")", ")", "\n", ")", "\n", "", "ctx", ".", "stride", "=", "_pair", "(", "stride", ")", "\n", "ctx", ".", "padding", "=", "_pair", "(", "padding", ")", "\n", "ctx", ".", "dilation", "=", "_pair", "(", "dilation", ")", "\n", "ctx", ".", "groups", "=", "groups", "\n", "ctx", ".", "deformable_groups", "=", "deformable_groups", "\n", "ctx", ".", "im2col_step", "=", "im2col_step", "\n", "\n", "ctx", ".", "save_for_backward", "(", "input", ",", "offset", ",", "weight", ")", "\n", "\n", "output", "=", "input", ".", "new_empty", "(", "\n", "_DeformConv", ".", "_output_size", "(", "input", ",", "weight", ",", "ctx", ".", "padding", ",", "ctx", ".", "dilation", ",", "ctx", ".", "stride", ")", "\n", ")", "\n", "\n", "ctx", ".", "bufs_", "=", "[", "input", ".", "new_empty", "(", "0", ")", ",", "input", ".", "new_empty", "(", "0", ")", "]", "# columns, ones", "\n", "\n", "if", "not", "input", ".", "is_cuda", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Deformable Conv is not supported on CPUs!\"", ")", "\n", "", "else", ":", "\n", "            ", "cur_im2col_step", "=", "_DeformConv", ".", "_cal_im2col_step", "(", "input", ".", "shape", "[", "0", "]", ",", "ctx", ".", "im2col_step", ")", "\n", "assert", "(", "input", ".", "shape", "[", "0", "]", "%", "cur_im2col_step", ")", "==", "0", ",", "\"im2col step must divide batchsize\"", "\n", "\n", "_C", ".", "deform_conv_forward", "(", "\n", "input", ",", "\n", "weight", ",", "\n", "offset", ",", "\n", "output", ",", "\n", "ctx", ".", "bufs_", "[", "0", "]", ",", "\n", "ctx", ".", "bufs_", "[", "1", "]", ",", "\n", "weight", ".", "size", "(", "3", ")", ",", "\n", "weight", ".", "size", "(", "2", ")", ",", "\n", "ctx", ".", "stride", "[", "1", "]", ",", "\n", "ctx", ".", "stride", "[", "0", "]", ",", "\n", "ctx", ".", "padding", "[", "1", "]", ",", "\n", "ctx", ".", "padding", "[", "0", "]", ",", "\n", "ctx", ".", "dilation", "[", "1", "]", ",", "\n", "ctx", ".", "dilation", "[", "0", "]", ",", "\n", "ctx", ".", "groups", ",", "\n", "ctx", ".", "deformable_groups", ",", "\n", "cur_im2col_step", ",", "\n", ")", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.deform_conv._DeformConv.backward": [[75, 136], ["NotImplementedError", "deform_conv._DeformConv._cal_im2col_step", "torch.zeros_like", "torch.zeros_like", "detectron2._C.deform_conv_backward_input", "torch.zeros_like", "detectron2._C.deform_conv_backward_filter", "weight.size", "weight.size", "weight.size", "weight.size"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.deform_conv._DeformConv._cal_im2col_step"], ["", "@", "staticmethod", "\n", "@", "once_differentiable", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "input", ",", "offset", ",", "weight", "=", "ctx", ".", "saved_tensors", "\n", "\n", "grad_input", "=", "grad_offset", "=", "grad_weight", "=", "None", "\n", "\n", "if", "not", "grad_output", ".", "is_cuda", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Deformable Conv is not supported on CPUs!\"", ")", "\n", "", "else", ":", "\n", "            ", "cur_im2col_step", "=", "_DeformConv", ".", "_cal_im2col_step", "(", "input", ".", "shape", "[", "0", "]", ",", "ctx", ".", "im2col_step", ")", "\n", "assert", "(", "input", ".", "shape", "[", "0", "]", "%", "cur_im2col_step", ")", "==", "0", ",", "\"im2col step must divide batchsize\"", "\n", "\n", "if", "ctx", ".", "needs_input_grad", "[", "0", "]", "or", "ctx", ".", "needs_input_grad", "[", "1", "]", ":", "\n", "                ", "grad_input", "=", "torch", ".", "zeros_like", "(", "input", ")", "\n", "grad_offset", "=", "torch", ".", "zeros_like", "(", "offset", ")", "\n", "_C", ".", "deform_conv_backward_input", "(", "\n", "input", ",", "\n", "offset", ",", "\n", "grad_output", ",", "\n", "grad_input", ",", "\n", "grad_offset", ",", "\n", "weight", ",", "\n", "ctx", ".", "bufs_", "[", "0", "]", ",", "\n", "weight", ".", "size", "(", "3", ")", ",", "\n", "weight", ".", "size", "(", "2", ")", ",", "\n", "ctx", ".", "stride", "[", "1", "]", ",", "\n", "ctx", ".", "stride", "[", "0", "]", ",", "\n", "ctx", ".", "padding", "[", "1", "]", ",", "\n", "ctx", ".", "padding", "[", "0", "]", ",", "\n", "ctx", ".", "dilation", "[", "1", "]", ",", "\n", "ctx", ".", "dilation", "[", "0", "]", ",", "\n", "ctx", ".", "groups", ",", "\n", "ctx", ".", "deformable_groups", ",", "\n", "cur_im2col_step", ",", "\n", ")", "\n", "\n", "", "if", "ctx", ".", "needs_input_grad", "[", "2", "]", ":", "\n", "                ", "grad_weight", "=", "torch", ".", "zeros_like", "(", "weight", ")", "\n", "_C", ".", "deform_conv_backward_filter", "(", "\n", "input", ",", "\n", "offset", ",", "\n", "grad_output", ",", "\n", "grad_weight", ",", "\n", "ctx", ".", "bufs_", "[", "0", "]", ",", "\n", "ctx", ".", "bufs_", "[", "1", "]", ",", "\n", "weight", ".", "size", "(", "3", ")", ",", "\n", "weight", ".", "size", "(", "2", ")", ",", "\n", "ctx", ".", "stride", "[", "1", "]", ",", "\n", "ctx", ".", "stride", "[", "0", "]", ",", "\n", "ctx", ".", "padding", "[", "1", "]", ",", "\n", "ctx", ".", "padding", "[", "0", "]", ",", "\n", "ctx", ".", "dilation", "[", "1", "]", ",", "\n", "ctx", ".", "dilation", "[", "0", "]", ",", "\n", "ctx", ".", "groups", ",", "\n", "ctx", ".", "deformable_groups", ",", "\n", "1", ",", "\n", "cur_im2col_step", ",", "\n", ")", "\n", "\n", "", "", "return", "grad_input", ",", "grad_offset", ",", "grad_weight", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.deform_conv._DeformConv._output_size": [[137, 154], ["weight.size", "range", "input.size", "input.size", "all", "ValueError", "input.dim", "map", "weight.size", "map"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_output_size", "(", "input", ",", "weight", ",", "padding", ",", "dilation", ",", "stride", ")", ":", "\n", "        ", "channels", "=", "weight", ".", "size", "(", "0", ")", "\n", "output_size", "=", "(", "input", ".", "size", "(", "0", ")", ",", "channels", ")", "\n", "for", "d", "in", "range", "(", "input", ".", "dim", "(", ")", "-", "2", ")", ":", "\n", "            ", "in_size", "=", "input", ".", "size", "(", "d", "+", "2", ")", "\n", "pad", "=", "padding", "[", "d", "]", "\n", "kernel", "=", "dilation", "[", "d", "]", "*", "(", "weight", ".", "size", "(", "d", "+", "2", ")", "-", "1", ")", "+", "1", "\n", "stride_", "=", "stride", "[", "d", "]", "\n", "output_size", "+=", "(", "(", "in_size", "+", "(", "2", "*", "pad", ")", "-", "kernel", ")", "//", "stride_", "+", "1", ",", ")", "\n", "", "if", "not", "all", "(", "map", "(", "lambda", "s", ":", "s", ">", "0", ",", "output_size", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"convolution input is too small (output would be {})\"", ".", "format", "(", "\n", "\"x\"", ".", "join", "(", "map", "(", "str", ",", "output_size", ")", ")", "\n", ")", "\n", ")", "\n", "", "return", "output_size", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.deform_conv._DeformConv._cal_im2col_step": [[155, 177], ["functools.lru_cache", "range", "min", "int", "math.sqrt"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "lru_cache", "(", "maxsize", "=", "128", ")", "\n", "def", "_cal_im2col_step", "(", "input_size", ",", "default_size", ")", ":", "\n", "        ", "\"\"\"\n        Calculate proper im2col step size, which should be divisible by input_size and not larger\n        than prefer_size. Meanwhile the step size should be as large as possible to be more\n        efficient. So we choose the largest one among all divisors of input_size which are smaller\n        than prefer_size.\n        :param input_size: input batch size .\n        :param default_size: default preferred im2col step size.\n        :return: the largest proper step size.\n        \"\"\"", "\n", "if", "input_size", "<=", "default_size", ":", "\n", "            ", "return", "input_size", "\n", "", "best_step", "=", "1", "\n", "for", "step", "in", "range", "(", "2", ",", "min", "(", "int", "(", "math", ".", "sqrt", "(", "input_size", ")", ")", "+", "1", ",", "default_size", ")", ")", ":", "\n", "            ", "if", "input_size", "%", "step", "==", "0", ":", "\n", "                ", "if", "input_size", "//", "step", "<=", "default_size", ":", "\n", "                    ", "return", "input_size", "//", "step", "\n", "", "best_step", "=", "step", "\n", "\n", "", "", "return", "best_step", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.deform_conv._ModulatedDeformConv.forward": [[180, 235], ["input.new_empty", "detectron2._C.modulated_deform_conv_forward", "input.new_empty", "NotImplementedError", "ctx.save_for_backward", "deform_conv._ModulatedDeformConv._infer_shape", "input.new_empty", "input.new_empty"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.deform_conv._ModulatedDeformConv._infer_shape"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "\n", "ctx", ",", "\n", "input", ",", "\n", "offset", ",", "\n", "mask", ",", "\n", "weight", ",", "\n", "bias", "=", "None", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "deformable_groups", "=", "1", ",", "\n", ")", ":", "\n", "        ", "ctx", ".", "stride", "=", "stride", "\n", "ctx", ".", "padding", "=", "padding", "\n", "ctx", ".", "dilation", "=", "dilation", "\n", "ctx", ".", "groups", "=", "groups", "\n", "ctx", ".", "deformable_groups", "=", "deformable_groups", "\n", "ctx", ".", "with_bias", "=", "bias", "is", "not", "None", "\n", "if", "not", "ctx", ".", "with_bias", ":", "\n", "            ", "bias", "=", "input", ".", "new_empty", "(", "1", ")", "# fake tensor", "\n", "", "if", "not", "input", ".", "is_cuda", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Deformable Conv is not supported on CPUs!\"", ")", "\n", "", "if", "(", "\n", "weight", ".", "requires_grad", "\n", "or", "mask", ".", "requires_grad", "\n", "or", "offset", ".", "requires_grad", "\n", "or", "input", ".", "requires_grad", "\n", ")", ":", "\n", "            ", "ctx", ".", "save_for_backward", "(", "input", ",", "offset", ",", "mask", ",", "weight", ",", "bias", ")", "\n", "", "output", "=", "input", ".", "new_empty", "(", "_ModulatedDeformConv", ".", "_infer_shape", "(", "ctx", ",", "input", ",", "weight", ")", ")", "\n", "ctx", ".", "_bufs", "=", "[", "input", ".", "new_empty", "(", "0", ")", ",", "input", ".", "new_empty", "(", "0", ")", "]", "\n", "_C", ".", "modulated_deform_conv_forward", "(", "\n", "input", ",", "\n", "weight", ",", "\n", "bias", ",", "\n", "ctx", ".", "_bufs", "[", "0", "]", ",", "\n", "offset", ",", "\n", "mask", ",", "\n", "output", ",", "\n", "ctx", ".", "_bufs", "[", "1", "]", ",", "\n", "weight", ".", "shape", "[", "2", "]", ",", "\n", "weight", ".", "shape", "[", "3", "]", ",", "\n", "ctx", ".", "stride", ",", "\n", "ctx", ".", "stride", ",", "\n", "ctx", ".", "padding", ",", "\n", "ctx", ".", "padding", ",", "\n", "ctx", ".", "dilation", ",", "\n", "ctx", ".", "dilation", ",", "\n", "ctx", ".", "groups", ",", "\n", "ctx", ".", "deformable_groups", ",", "\n", "ctx", ".", "with_bias", ",", "\n", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.deform_conv._ModulatedDeformConv.backward": [[236, 287], ["torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "detectron2._C.modulated_deform_conv_backward", "NotImplementedError"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "once_differentiable", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "if", "not", "grad_output", ".", "is_cuda", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Deformable Conv is not supported on CPUs!\"", ")", "\n", "", "input", ",", "offset", ",", "mask", ",", "weight", ",", "bias", "=", "ctx", ".", "saved_tensors", "\n", "grad_input", "=", "torch", ".", "zeros_like", "(", "input", ")", "\n", "grad_offset", "=", "torch", ".", "zeros_like", "(", "offset", ")", "\n", "grad_mask", "=", "torch", ".", "zeros_like", "(", "mask", ")", "\n", "grad_weight", "=", "torch", ".", "zeros_like", "(", "weight", ")", "\n", "grad_bias", "=", "torch", ".", "zeros_like", "(", "bias", ")", "\n", "_C", ".", "modulated_deform_conv_backward", "(", "\n", "input", ",", "\n", "weight", ",", "\n", "bias", ",", "\n", "ctx", ".", "_bufs", "[", "0", "]", ",", "\n", "offset", ",", "\n", "mask", ",", "\n", "ctx", ".", "_bufs", "[", "1", "]", ",", "\n", "grad_input", ",", "\n", "grad_weight", ",", "\n", "grad_bias", ",", "\n", "grad_offset", ",", "\n", "grad_mask", ",", "\n", "grad_output", ",", "\n", "weight", ".", "shape", "[", "2", "]", ",", "\n", "weight", ".", "shape", "[", "3", "]", ",", "\n", "ctx", ".", "stride", ",", "\n", "ctx", ".", "stride", ",", "\n", "ctx", ".", "padding", ",", "\n", "ctx", ".", "padding", ",", "\n", "ctx", ".", "dilation", ",", "\n", "ctx", ".", "dilation", ",", "\n", "ctx", ".", "groups", ",", "\n", "ctx", ".", "deformable_groups", ",", "\n", "ctx", ".", "with_bias", ",", "\n", ")", "\n", "if", "not", "ctx", ".", "with_bias", ":", "\n", "            ", "grad_bias", "=", "None", "\n", "\n", "", "return", "(", "\n", "grad_input", ",", "\n", "grad_offset", ",", "\n", "grad_mask", ",", "\n", "grad_weight", ",", "\n", "grad_bias", ",", "\n", "None", ",", "\n", "None", ",", "\n", "None", ",", "\n", "None", ",", "\n", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.deform_conv._ModulatedDeformConv._infer_shape": [[289, 302], ["input.size", "weight.size"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_infer_shape", "(", "ctx", ",", "input", ",", "weight", ")", ":", "\n", "        ", "n", "=", "input", ".", "size", "(", "0", ")", "\n", "channels_out", "=", "weight", ".", "size", "(", "0", ")", "\n", "height", ",", "width", "=", "input", ".", "shape", "[", "2", ":", "4", "]", "\n", "kernel_h", ",", "kernel_w", "=", "weight", ".", "shape", "[", "2", ":", "4", "]", "\n", "height_out", "=", "(", "\n", "height", "+", "2", "*", "ctx", ".", "padding", "-", "(", "ctx", ".", "dilation", "*", "(", "kernel_h", "-", "1", ")", "+", "1", ")", "\n", ")", "//", "ctx", ".", "stride", "+", "1", "\n", "width_out", "=", "(", "\n", "width", "+", "2", "*", "ctx", ".", "padding", "-", "(", "ctx", ".", "dilation", "*", "(", "kernel_w", "-", "1", ")", "+", "1", ")", "\n", ")", "//", "ctx", ".", "stride", "+", "1", "\n", "return", "n", ",", "channels_out", ",", "height_out", ",", "width_out", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.deform_conv.DeformConv.__init__": [[309, 360], ["torch.nn.Module.__init__", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.Parameter", "torch.nn.init.kaiming_uniform_", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "deformable_groups", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "None", ",", "\n", "activation", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Deformable convolution from :paper:`deformconv`.\n\n        Arguments are similar to :class:`Conv2D`. Extra arguments:\n\n        Args:\n            deformable_groups (int): number of groups used in deformable convolution.\n            norm (nn.Module, optional): a normalization layer\n            activation (callable(Tensor) -> Tensor): a callable activation function\n        \"\"\"", "\n", "super", "(", "DeformConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "not", "bias", "\n", "assert", "in_channels", "%", "groups", "==", "0", ",", "\"in_channels {} cannot be divisible by groups {}\"", ".", "format", "(", "\n", "in_channels", ",", "groups", "\n", ")", "\n", "assert", "(", "\n", "out_channels", "%", "groups", "==", "0", "\n", ")", ",", "\"out_channels {} cannot be divisible by groups {}\"", ".", "format", "(", "out_channels", ",", "groups", ")", "\n", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "kernel_size", "=", "_pair", "(", "kernel_size", ")", "\n", "self", ".", "stride", "=", "_pair", "(", "stride", ")", "\n", "self", ".", "padding", "=", "_pair", "(", "padding", ")", "\n", "self", ".", "dilation", "=", "_pair", "(", "dilation", ")", "\n", "self", ".", "groups", "=", "groups", "\n", "self", ".", "deformable_groups", "=", "deformable_groups", "\n", "self", ".", "norm", "=", "norm", "\n", "self", ".", "activation", "=", "activation", "\n", "\n", "self", ".", "weight", "=", "nn", ".", "Parameter", "(", "\n", "torch", ".", "Tensor", "(", "out_channels", ",", "in_channels", "//", "self", ".", "groups", ",", "*", "self", ".", "kernel_size", ")", "\n", ")", "\n", "self", ".", "bias", "=", "None", "\n", "\n", "nn", ".", "init", ".", "kaiming_uniform_", "(", "self", ".", "weight", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.deform_conv.DeformConv.forward": [[361, 391], ["deform_conv", "deform_conv.DeformConv.numel", "wrappers._NewEmptyTensorOp.apply", "deform_conv.DeformConv.norm", "deform_conv.DeformConv.activation", "zip"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.norm"], ["", "def", "forward", "(", "self", ",", "x", ",", "offset", ")", ":", "\n", "        ", "if", "x", ".", "numel", "(", ")", "==", "0", ":", "\n", "# When input is empty, we want to return a empty tensor with \"correct\" shape,", "\n", "# So that the following operations will not panic", "\n", "# if they check for the shape of the tensor.", "\n", "# This computes the height and width of the output tensor", "\n", "            ", "output_shape", "=", "[", "\n", "(", "i", "+", "2", "*", "p", "-", "(", "di", "*", "(", "k", "-", "1", ")", "+", "1", ")", ")", "//", "s", "+", "1", "\n", "for", "i", ",", "p", ",", "di", ",", "k", ",", "s", "in", "zip", "(", "\n", "x", ".", "shape", "[", "-", "2", ":", "]", ",", "self", ".", "padding", ",", "self", ".", "dilation", ",", "self", ".", "kernel_size", ",", "self", ".", "stride", "\n", ")", "\n", "]", "\n", "output_shape", "=", "[", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "weight", ".", "shape", "[", "0", "]", "]", "+", "output_shape", "\n", "return", "_NewEmptyTensorOp", ".", "apply", "(", "x", ",", "output_shape", ")", "\n", "\n", "", "x", "=", "deform_conv", "(", "\n", "x", ",", "\n", "offset", ",", "\n", "self", ".", "weight", ",", "\n", "self", ".", "stride", ",", "\n", "self", ".", "padding", ",", "\n", "self", ".", "dilation", ",", "\n", "self", ".", "groups", ",", "\n", "self", ".", "deformable_groups", ",", "\n", ")", "\n", "if", "self", ".", "norm", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "norm", "(", "x", ")", "\n", "", "if", "self", ".", "activation", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "activation", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.deform_conv.DeformConv.extra_repr": [[392, 403], ["str", "str", "str", "str", "str", "str", "str", "str"], "methods", ["None"], ["", "def", "extra_repr", "(", "self", ")", ":", "\n", "        ", "tmpstr", "=", "\"in_channels=\"", "+", "str", "(", "self", ".", "in_channels", ")", "\n", "tmpstr", "+=", "\", out_channels=\"", "+", "str", "(", "self", ".", "out_channels", ")", "\n", "tmpstr", "+=", "\", kernel_size=\"", "+", "str", "(", "self", ".", "kernel_size", ")", "\n", "tmpstr", "+=", "\", stride=\"", "+", "str", "(", "self", ".", "stride", ")", "\n", "tmpstr", "+=", "\", padding=\"", "+", "str", "(", "self", ".", "padding", ")", "\n", "tmpstr", "+=", "\", dilation=\"", "+", "str", "(", "self", ".", "dilation", ")", "\n", "tmpstr", "+=", "\", groups=\"", "+", "str", "(", "self", ".", "groups", ")", "\n", "tmpstr", "+=", "\", deformable_groups=\"", "+", "str", "(", "self", ".", "deformable_groups", ")", "\n", "tmpstr", "+=", "\", bias=False\"", "\n", "return", "tmpstr", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.deform_conv.ModulatedDeformConv.__init__": [[406, 454], ["torch.nn.Module.__init__", "torch.nn.modules.utils._pair", "torch.nn.Parameter", "torch.nn.init.kaiming_uniform_", "torch.Tensor", "torch.nn.Parameter", "torch.nn.init.constant_", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "deformable_groups", "=", "1", ",", "\n", "bias", "=", "True", ",", "\n", "norm", "=", "None", ",", "\n", "activation", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Modulated deformable convolution from :paper:`deformconv2`.\n\n        Arguments are similar to :class:`Conv2D`. Extra arguments:\n\n        Args:\n            deformable_groups (int): number of groups used in deformable convolution.\n            norm (nn.Module, optional): a normalization layer\n            activation (callable(Tensor) -> Tensor): a callable activation function\n        \"\"\"", "\n", "super", "(", "ModulatedDeformConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "kernel_size", "=", "_pair", "(", "kernel_size", ")", "\n", "self", ".", "stride", "=", "stride", "\n", "self", ".", "padding", "=", "padding", "\n", "self", ".", "dilation", "=", "dilation", "\n", "self", ".", "groups", "=", "groups", "\n", "self", ".", "deformable_groups", "=", "deformable_groups", "\n", "self", ".", "with_bias", "=", "bias", "\n", "self", ".", "norm", "=", "norm", "\n", "self", ".", "activation", "=", "activation", "\n", "\n", "self", ".", "weight", "=", "nn", ".", "Parameter", "(", "\n", "torch", ".", "Tensor", "(", "out_channels", ",", "in_channels", "//", "groups", ",", "*", "self", ".", "kernel_size", ")", "\n", ")", "\n", "if", "bias", ":", "\n", "            ", "self", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "out_channels", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "bias", "=", "None", "\n", "\n", "", "nn", ".", "init", ".", "kaiming_uniform_", "(", "self", ".", "weight", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "if", "self", ".", "bias", "is", "not", "None", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "self", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.deform_conv.ModulatedDeformConv.forward": [[455, 483], ["modulated_deform_conv", "deform_conv.ModulatedDeformConv.numel", "wrappers._NewEmptyTensorOp.apply", "deform_conv.ModulatedDeformConv.norm", "deform_conv.ModulatedDeformConv.activation", "zip"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.norm"], ["", "", "def", "forward", "(", "self", ",", "x", ",", "offset", ",", "mask", ")", ":", "\n", "        ", "if", "x", ".", "numel", "(", ")", "==", "0", ":", "\n", "            ", "output_shape", "=", "[", "\n", "(", "i", "+", "2", "*", "p", "-", "(", "di", "*", "(", "k", "-", "1", ")", "+", "1", ")", ")", "//", "s", "+", "1", "\n", "for", "i", ",", "p", ",", "di", ",", "k", ",", "s", "in", "zip", "(", "\n", "x", ".", "shape", "[", "-", "2", ":", "]", ",", "self", ".", "padding", ",", "self", ".", "dilation", ",", "self", ".", "kernel_size", ",", "self", ".", "stride", "\n", ")", "\n", "]", "\n", "output_shape", "=", "[", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "weight", ".", "shape", "[", "0", "]", "]", "+", "output_shape", "\n", "return", "_NewEmptyTensorOp", ".", "apply", "(", "x", ",", "output_shape", ")", "\n", "\n", "", "x", "=", "modulated_deform_conv", "(", "\n", "x", ",", "\n", "offset", ",", "\n", "mask", ",", "\n", "self", ".", "weight", ",", "\n", "self", ".", "bias", ",", "\n", "self", ".", "stride", ",", "\n", "self", ".", "padding", ",", "\n", "self", ".", "dilation", ",", "\n", "self", ".", "groups", ",", "\n", "self", ".", "deformable_groups", ",", "\n", ")", "\n", "if", "self", ".", "norm", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "norm", "(", "x", ")", "\n", "", "if", "self", ".", "activation", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "activation", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.deform_conv.ModulatedDeformConv.extra_repr": [[484, 495], ["str", "str", "str", "str", "str", "str", "str", "str", "str"], "methods", ["None"], ["", "def", "extra_repr", "(", "self", ")", ":", "\n", "        ", "tmpstr", "=", "\"in_channels=\"", "+", "str", "(", "self", ".", "in_channels", ")", "\n", "tmpstr", "+=", "\", out_channels=\"", "+", "str", "(", "self", ".", "out_channels", ")", "\n", "tmpstr", "+=", "\", kernel_size=\"", "+", "str", "(", "self", ".", "kernel_size", ")", "\n", "tmpstr", "+=", "\", stride=\"", "+", "str", "(", "self", ".", "stride", ")", "\n", "tmpstr", "+=", "\", padding=\"", "+", "str", "(", "self", ".", "padding", ")", "\n", "tmpstr", "+=", "\", dilation=\"", "+", "str", "(", "self", ".", "dilation", ")", "\n", "tmpstr", "+=", "\", groups=\"", "+", "str", "(", "self", ".", "groups", ")", "\n", "tmpstr", "+=", "\", deformable_groups=\"", "+", "str", "(", "self", ".", "deformable_groups", ")", "\n", "tmpstr", "+=", "\", bias=\"", "+", "str", "(", "self", ".", "with_bias", ")", "\n", "return", "tmpstr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.__init__": [[22, 35], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "stride", ")", ":", "\n", "        ", "\"\"\"\n        The `__init__` method of any subclass should also contain these arguments.\n\n        Args:\n            in_channels (int):\n            out_channels (int):\n            stride (int):\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "stride", "=", "stride", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze": [[36, 49], ["blocks.CNNBlockBase.parameters", "batch_norm.FrozenBatchNorm2d.convert_frozen_batchnorm"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.FrozenBatchNorm2d.convert_frozen_batchnorm"], ["", "def", "freeze", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Make this block not trainable.\n        This method sets all parameters to `requires_grad=False`,\n        and convert all BatchNorm layers to FrozenBatchNorm\n\n        Returns:\n            the block itself\n        \"\"\"", "\n", "for", "p", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "p", ".", "requires_grad", "=", "False", "\n", "", "FrozenBatchNorm2d", ".", "convert_frozen_batchnorm", "(", "self", ")", "\n", "return", "self", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.mask_ops._do_paste_mask": [[16, 65], ["torch.split", "img_x[].expand", "img_y[].expand", "torch.stack", "torch.nn.functional.grid_sample", "torch.clamp().to", "torch.clamp().to", "torch.clamp().to", "torch.arange", "torch.arange", "img_y.size", "img_x.size", "img_y.size", "img_x.size", "masks.to", "torch.clamp", "torch.clamp", "torch.clamp", "slice", "slice", "boxes[].max().ceil", "boxes[].max().ceil", "boxes.min().values.floor", "boxes[].max", "boxes[].max", "boxes.min"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["def", "_do_paste_mask", "(", "masks", ",", "boxes", ",", "img_h", ",", "img_w", ",", "skip_empty", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        masks: N, 1, H, W\n        boxes: N, 4\n        img_h, img_w (int):\n        skip_empty (bool): only paste masks within the region that\n            tightly bound all boxes, and returns the results this region only.\n            An important optimization for CPU.\n\n    Returns:\n        if skip_empty == False, a mask of shape (N, img_h, img_w)\n        if skip_empty == True, a mask of shape (N, h', w'), and the slice\n            object for the corresponding region.\n    \"\"\"", "\n", "# On GPU, paste all masks together (up to chunk size)", "\n", "# by using the entire image to sample the masks", "\n", "# Compared to pasting them one by one,", "\n", "# this has more operations but is faster on COCO-scale dataset.", "\n", "device", "=", "masks", ".", "device", "\n", "if", "skip_empty", ":", "\n", "        ", "x0_int", ",", "y0_int", "=", "torch", ".", "clamp", "(", "boxes", ".", "min", "(", "dim", "=", "0", ")", ".", "values", ".", "floor", "(", ")", "[", ":", "2", "]", "-", "1", ",", "min", "=", "0", ")", ".", "to", "(", "\n", "dtype", "=", "torch", ".", "int32", "\n", ")", "\n", "x1_int", "=", "torch", ".", "clamp", "(", "boxes", "[", ":", ",", "2", "]", ".", "max", "(", ")", ".", "ceil", "(", ")", "+", "1", ",", "max", "=", "img_w", ")", ".", "to", "(", "dtype", "=", "torch", ".", "int32", ")", "\n", "y1_int", "=", "torch", ".", "clamp", "(", "boxes", "[", ":", ",", "3", "]", ".", "max", "(", ")", ".", "ceil", "(", ")", "+", "1", ",", "max", "=", "img_h", ")", ".", "to", "(", "dtype", "=", "torch", ".", "int32", ")", "\n", "", "else", ":", "\n", "        ", "x0_int", ",", "y0_int", "=", "0", ",", "0", "\n", "x1_int", ",", "y1_int", "=", "img_w", ",", "img_h", "\n", "", "x0", ",", "y0", ",", "x1", ",", "y1", "=", "torch", ".", "split", "(", "boxes", ",", "1", ",", "dim", "=", "1", ")", "# each is Nx1", "\n", "\n", "N", "=", "masks", ".", "shape", "[", "0", "]", "\n", "\n", "img_y", "=", "torch", ".", "arange", "(", "y0_int", ",", "y1_int", ",", "device", "=", "device", ",", "dtype", "=", "torch", ".", "float32", ")", "+", "0.5", "\n", "img_x", "=", "torch", ".", "arange", "(", "x0_int", ",", "x1_int", ",", "device", "=", "device", ",", "dtype", "=", "torch", ".", "float32", ")", "+", "0.5", "\n", "img_y", "=", "(", "img_y", "-", "y0", ")", "/", "(", "y1", "-", "y0", ")", "*", "2", "-", "1", "\n", "img_x", "=", "(", "img_x", "-", "x0", ")", "/", "(", "x1", "-", "x0", ")", "*", "2", "-", "1", "\n", "# img_x, img_y have shapes (N, w), (N, h)", "\n", "\n", "gx", "=", "img_x", "[", ":", ",", "None", ",", ":", "]", ".", "expand", "(", "N", ",", "img_y", ".", "size", "(", "1", ")", ",", "img_x", ".", "size", "(", "1", ")", ")", "\n", "gy", "=", "img_y", "[", ":", ",", ":", ",", "None", "]", ".", "expand", "(", "N", ",", "img_y", ".", "size", "(", "1", ")", ",", "img_x", ".", "size", "(", "1", ")", ")", "\n", "grid", "=", "torch", ".", "stack", "(", "[", "gx", ",", "gy", "]", ",", "dim", "=", "3", ")", "\n", "\n", "img_masks", "=", "F", ".", "grid_sample", "(", "masks", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", ",", "grid", ",", "align_corners", "=", "False", ")", "\n", "\n", "if", "skip_empty", ":", "\n", "        ", "return", "img_masks", "[", ":", ",", "0", "]", ",", "(", "slice", "(", "y0_int", ",", "y1_int", ")", ",", "slice", "(", "x0_int", ",", "x1_int", ")", ")", "\n", "", "else", ":", "\n", "        ", "return", "img_masks", "[", ":", ",", "0", "]", ",", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.mask_ops.paste_masks_in_image": [[67, 136], ["len", "torch.chunk", "torch.zeros", "masks.new_empty", "isinstance", "len", "int", "torch.arange", "mask_ops._do_paste_mask", "numpy.ceil", "int", "int"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.mask_ops._do_paste_mask"], ["", "", "def", "paste_masks_in_image", "(", "masks", ",", "boxes", ",", "image_shape", ",", "threshold", "=", "0.5", ")", ":", "\n", "    ", "\"\"\"\n    Paste a set of masks that are of a fixed resolution (e.g., 28 x 28) into an image.\n    The location, height, and width for pasting each mask is determined by their\n    corresponding bounding boxes in boxes.\n\n    Note:\n        This is a complicated but more accurate implementation. In actual deployment, it is\n        often enough to use a faster but less accurate implementation.\n        See :func:`paste_mask_in_image_old` in this file for an alternative implementation.\n\n    Args:\n        masks (tensor): Tensor of shape (Bimg, Hmask, Wmask), where Bimg is the number of\n            detected object instances in the image and Hmask, Wmask are the mask width and mask\n            height of the predicted mask (e.g., Hmask = Wmask = 28). Values are in [0, 1].\n        boxes (Boxes or Tensor): A Boxes of length Bimg or Tensor of shape (Bimg, 4).\n            boxes[i] and masks[i] correspond to the same object instance.\n        image_shape (tuple): height, width\n        threshold (float): A threshold in [0, 1] for converting the (soft) masks to\n            binary masks.\n\n    Returns:\n        img_masks (Tensor): A tensor of shape (Bimg, Himage, Wimage), where Bimg is the\n        number of detected object instances and Himage, Wimage are the image width\n        and height. img_masks[i] is a binary mask for object instance i.\n    \"\"\"", "\n", "\n", "assert", "masks", ".", "shape", "[", "-", "1", "]", "==", "masks", ".", "shape", "[", "-", "2", "]", ",", "\"Only square mask predictions are supported\"", "\n", "N", "=", "len", "(", "masks", ")", "\n", "if", "N", "==", "0", ":", "\n", "        ", "return", "masks", ".", "new_empty", "(", "(", "0", ",", ")", "+", "image_shape", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "", "if", "not", "isinstance", "(", "boxes", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "boxes", "=", "boxes", ".", "tensor", "\n", "", "device", "=", "boxes", ".", "device", "\n", "assert", "len", "(", "boxes", ")", "==", "N", ",", "boxes", ".", "shape", "\n", "\n", "img_h", ",", "img_w", "=", "image_shape", "\n", "\n", "# The actual implementation split the input into chunks,", "\n", "# and paste them chunk by chunk.", "\n", "if", "device", ".", "type", "==", "\"cpu\"", ":", "\n", "# CPU is most efficient when they are pasted one by one with skip_empty=True", "\n", "# so that it performs minimal number of operations.", "\n", "        ", "num_chunks", "=", "N", "\n", "", "else", ":", "\n", "# GPU benefits from parallelism for larger chunks, but may have memory issue", "\n", "# int(img_h) because shape may be tensors in tracing", "\n", "        ", "num_chunks", "=", "int", "(", "np", ".", "ceil", "(", "N", "*", "int", "(", "img_h", ")", "*", "int", "(", "img_w", ")", "*", "BYTES_PER_FLOAT", "/", "GPU_MEM_LIMIT", ")", ")", "\n", "assert", "(", "\n", "num_chunks", "<=", "N", "\n", ")", ",", "\"Default GPU_MEM_LIMIT in mask_ops.py is too small; try increasing it\"", "\n", "", "chunks", "=", "torch", ".", "chunk", "(", "torch", ".", "arange", "(", "N", ",", "device", "=", "device", ")", ",", "num_chunks", ")", "\n", "\n", "img_masks", "=", "torch", ".", "zeros", "(", "\n", "N", ",", "img_h", ",", "img_w", ",", "device", "=", "device", ",", "dtype", "=", "torch", ".", "bool", "if", "threshold", ">=", "0", "else", "torch", ".", "uint8", "\n", ")", "\n", "for", "inds", "in", "chunks", ":", "\n", "        ", "masks_chunk", ",", "spatial_inds", "=", "_do_paste_mask", "(", "\n", "masks", "[", "inds", ",", "None", ",", ":", ",", ":", "]", ",", "boxes", "[", "inds", "]", ",", "img_h", ",", "img_w", ",", "skip_empty", "=", "device", ".", "type", "==", "\"cpu\"", "\n", ")", "\n", "\n", "if", "threshold", ">=", "0", ":", "\n", "            ", "masks_chunk", "=", "(", "masks_chunk", ">=", "threshold", ")", ".", "to", "(", "dtype", "=", "torch", ".", "bool", ")", "\n", "", "else", ":", "\n", "# for visualization and debugging", "\n", "            ", "masks_chunk", "=", "(", "masks_chunk", "*", "255", ")", ".", "to", "(", "dtype", "=", "torch", ".", "uint8", ")", "\n", "\n", "", "img_masks", "[", "(", "inds", ",", ")", "+", "spatial_inds", "]", "=", "masks_chunk", "\n", "", "return", "img_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.mask_ops.paste_mask_in_image_old": [[143, 196], ["box.to.to", "PIL.Image.fromarray", "torch.from_numpy().to.resize", "numpy.array", "torch.zeros", "max", "min", "max", "min", "torch.from_numpy().to.cpu().numpy", "numpy.array", "torch.from_numpy", "torch.from_numpy().to", "torch.from_numpy().to.cpu", "torch.from_numpy"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "paste_mask_in_image_old", "(", "mask", ",", "box", ",", "img_h", ",", "img_w", ",", "threshold", ")", ":", "\n", "    ", "\"\"\"\n    Paste a single mask in an image.\n    This is a per-box implementation of :func:`paste_masks_in_image`.\n    This function has larger quantization error due to incorrect pixel\n    modeling and is not used any more.\n\n    Args:\n        mask (Tensor): A tensor of shape (Hmask, Wmask) storing the mask of a single\n            object instance. Values are in [0, 1].\n        box (Tensor): A tensor of shape (4, ) storing the x0, y0, x1, y1 box corners\n            of the object instance.\n        img_h, img_w (int): Image height and width.\n        threshold (float): Mask binarization threshold in [0, 1].\n\n    Returns:\n        im_mask (Tensor):\n            The resized and binarized object mask pasted into the original\n            image plane (a tensor of shape (img_h, img_w)).\n    \"\"\"", "\n", "# Conversion from continuous box coordinates to discrete pixel coordinates", "\n", "# via truncation (cast to int32). This determines which pixels to paste the", "\n", "# mask onto.", "\n", "box", "=", "box", ".", "to", "(", "dtype", "=", "torch", ".", "int32", ")", "# Continuous to discrete coordinate conversion", "\n", "# An example (1D) box with continuous coordinates (x0=0.7, x1=4.3) will map to", "\n", "# a discrete coordinates (x0=0, x1=4). Note that box is mapped to 5 = x1 - x0 + 1", "\n", "# pixels (not x1 - x0 pixels).", "\n", "samples_w", "=", "box", "[", "2", "]", "-", "box", "[", "0", "]", "+", "1", "# Number of pixel samples, *not* geometric width", "\n", "samples_h", "=", "box", "[", "3", "]", "-", "box", "[", "1", "]", "+", "1", "# Number of pixel samples, *not* geometric height", "\n", "\n", "# Resample the mask from it's original grid to the new samples_w x samples_h grid", "\n", "mask", "=", "Image", ".", "fromarray", "(", "mask", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "mask", "=", "mask", ".", "resize", "(", "(", "samples_w", ",", "samples_h", ")", ",", "resample", "=", "Image", ".", "BILINEAR", ")", "\n", "mask", "=", "np", ".", "array", "(", "mask", ",", "copy", "=", "False", ")", "\n", "\n", "if", "threshold", ">=", "0", ":", "\n", "        ", "mask", "=", "np", ".", "array", "(", "mask", ">", "threshold", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "mask", "=", "torch", ".", "from_numpy", "(", "mask", ")", "\n", "", "else", ":", "\n", "# for visualization and debugging, we also", "\n", "# allow it to return an unmodified mask", "\n", "        ", "mask", "=", "torch", ".", "from_numpy", "(", "mask", "*", "255", ")", ".", "to", "(", "torch", ".", "uint8", ")", "\n", "\n", "", "im_mask", "=", "torch", ".", "zeros", "(", "(", "img_h", ",", "img_w", ")", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "x_0", "=", "max", "(", "box", "[", "0", "]", ",", "0", ")", "\n", "x_1", "=", "min", "(", "box", "[", "2", "]", "+", "1", ",", "img_w", ")", "\n", "y_0", "=", "max", "(", "box", "[", "1", "]", ",", "0", ")", "\n", "y_1", "=", "min", "(", "box", "[", "3", "]", "+", "1", ",", "img_h", ")", "\n", "\n", "im_mask", "[", "y_0", ":", "y_1", ",", "x_0", ":", "x_1", "]", "=", "mask", "[", "\n", "(", "y_0", "-", "box", "[", "1", "]", ")", ":", "(", "y_1", "-", "box", "[", "1", "]", ")", ",", "(", "x_0", "-", "box", "[", "0", "]", ")", ":", "(", "x_1", "-", "box", "[", "0", "]", ")", "\n", "]", "\n", "return", "im_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.mask_ops.pad_masks": [[207, 223], ["masks.new_zeros", "float"], "function", ["None"], ["", "def", "pad_masks", "(", "masks", ",", "padding", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        masks (tensor): A tensor of shape (B, M, M) representing B masks.\n        padding (int): Number of cells to pad on all sides.\n\n    Returns:\n        The padded masks and the scale factor of the padding size / original size.\n    \"\"\"", "\n", "B", "=", "masks", ".", "shape", "[", "0", "]", "\n", "M", "=", "masks", ".", "shape", "[", "-", "1", "]", "\n", "pad2", "=", "2", "*", "padding", "\n", "scale", "=", "float", "(", "M", "+", "pad2", ")", "/", "M", "\n", "padded_masks", "=", "masks", ".", "new_zeros", "(", "(", "B", ",", "M", "+", "pad2", ",", "M", "+", "pad2", ")", ")", "\n", "padded_masks", "[", ":", ",", "padding", ":", "-", "padding", ",", "padding", ":", "-", "padding", "]", "=", "masks", "\n", "return", "padded_masks", ",", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.mask_ops.scale_boxes": [[225, 249], ["torch.zeros_like"], "function", ["None"], ["", "def", "scale_boxes", "(", "boxes", ",", "scale", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        boxes (tensor): A tensor of shape (B, 4) representing B boxes with 4\n            coords representing the corners x0, y0, x1, y1,\n        scale (float): The box scaling factor.\n\n    Returns:\n        Scaled boxes.\n    \"\"\"", "\n", "w_half", "=", "(", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", ")", "*", "0.5", "\n", "h_half", "=", "(", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", ")", "*", "0.5", "\n", "x_c", "=", "(", "boxes", "[", ":", ",", "2", "]", "+", "boxes", "[", ":", ",", "0", "]", ")", "*", "0.5", "\n", "y_c", "=", "(", "boxes", "[", ":", ",", "3", "]", "+", "boxes", "[", ":", ",", "1", "]", ")", "*", "0.5", "\n", "\n", "w_half", "*=", "scale", "\n", "h_half", "*=", "scale", "\n", "\n", "scaled_boxes", "=", "torch", ".", "zeros_like", "(", "boxes", ")", "\n", "scaled_boxes", "[", ":", ",", "0", "]", "=", "x_c", "-", "w_half", "\n", "scaled_boxes", "[", ":", ",", "2", "]", "=", "x_c", "+", "w_half", "\n", "scaled_boxes", "[", ":", ",", "1", "]", "=", "y_c", "-", "h_half", "\n", "scaled_boxes", "[", ":", ",", "3", "]", "=", "y_c", "+", "h_half", "\n", "return", "scaled_boxes", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.FrozenBatchNorm2d.__init__": [[36, 44], ["torch.nn.Module.__init__", "batch_norm.FrozenBatchNorm2d.register_buffer", "batch_norm.FrozenBatchNorm2d.register_buffer", "batch_norm.FrozenBatchNorm2d.register_buffer", "batch_norm.FrozenBatchNorm2d.register_buffer", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "num_features", ",", "eps", "=", "1e-5", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_features", "=", "num_features", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "register_buffer", "(", "\"weight\"", ",", "torch", ".", "ones", "(", "num_features", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"bias\"", ",", "torch", ".", "zeros", "(", "num_features", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"running_mean\"", ",", "torch", ".", "zeros", "(", "num_features", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"running_var\"", ",", "torch", ".", "ones", "(", "num_features", ")", "-", "eps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.FrozenBatchNorm2d.forward": [[45, 65], ["scale.reshape.reshape.reshape", "bias.reshape.reshape.reshape", "torch.nn.functional.batch_norm", "torch.nn.functional.batch_norm"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "x", ".", "requires_grad", ":", "\n", "# When gradients are needed, F.batch_norm will use extra memory", "\n", "# because its backward op computes gradients for weight/bias as well.", "\n", "            ", "scale", "=", "self", ".", "weight", "*", "(", "self", ".", "running_var", "+", "self", ".", "eps", ")", ".", "rsqrt", "(", ")", "\n", "bias", "=", "self", ".", "bias", "-", "self", ".", "running_mean", "*", "scale", "\n", "scale", "=", "scale", ".", "reshape", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", "\n", "bias", "=", "bias", ".", "reshape", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", "\n", "return", "x", "*", "scale", "+", "bias", "\n", "", "else", ":", "\n", "# When gradients are not needed, F.batch_norm is a single fused op", "\n", "# and provide more optimization opportunities.", "\n", "            ", "return", "F", ".", "batch_norm", "(", "\n", "x", ",", "\n", "self", ".", "running_mean", ",", "\n", "self", ".", "running_var", ",", "\n", "self", ".", "weight", ",", "\n", "self", ".", "bias", ",", "\n", "training", "=", "False", ",", "\n", "eps", "=", "self", ".", "eps", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.FrozenBatchNorm2d._load_from_state_dict": [[67, 88], ["local_metadata.get", "super()._load_from_state_dict", "logging.getLogger", "logging.getLogger.info", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "prefix.rstrip"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.FrozenBatchNorm2d._load_from_state_dict"], ["", "", "def", "_load_from_state_dict", "(", "\n", "self", ",", "state_dict", ",", "prefix", ",", "local_metadata", ",", "strict", ",", "missing_keys", ",", "unexpected_keys", ",", "error_msgs", "\n", ")", ":", "\n", "        ", "version", "=", "local_metadata", ".", "get", "(", "\"version\"", ",", "None", ")", "\n", "\n", "if", "version", "is", "None", "or", "version", "<", "2", ":", "\n", "# No running_mean/var in early versions", "\n", "# This will silent the warnings", "\n", "            ", "if", "prefix", "+", "\"running_mean\"", "not", "in", "state_dict", ":", "\n", "                ", "state_dict", "[", "prefix", "+", "\"running_mean\"", "]", "=", "torch", ".", "zeros_like", "(", "self", ".", "running_mean", ")", "\n", "", "if", "prefix", "+", "\"running_var\"", "not", "in", "state_dict", ":", "\n", "                ", "state_dict", "[", "prefix", "+", "\"running_var\"", "]", "=", "torch", ".", "ones_like", "(", "self", ".", "running_var", ")", "\n", "\n", "", "", "if", "version", "is", "not", "None", "and", "version", "<", "3", ":", "\n", "            ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"FrozenBatchNorm {} is upgraded to version 3.\"", ".", "format", "(", "prefix", ".", "rstrip", "(", "\".\"", ")", ")", ")", "\n", "# In version < 3, running_var are used without +eps.", "\n", "state_dict", "[", "prefix", "+", "\"running_var\"", "]", "-=", "self", ".", "eps", "\n", "\n", "", "super", "(", ")", ".", "_load_from_state_dict", "(", "\n", "state_dict", ",", "prefix", ",", "local_metadata", ",", "strict", ",", "missing_keys", ",", "unexpected_keys", ",", "error_msgs", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.FrozenBatchNorm2d.__repr__": [[90, 92], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "\"FrozenBatchNorm2d(num_features={}, eps={})\"", ".", "format", "(", "self", ".", "num_features", ",", "self", ".", "eps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.FrozenBatchNorm2d.convert_frozen_batchnorm": [[93, 125], ["isinstance", "cls", "module.named_children", "module.weight.data.clone().detach", "module.bias.data.clone().detach", "cls.convert_frozen_batchnorm", "cls.add_module", "module.weight.data.clone", "module.bias.data.clone"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.FrozenBatchNorm2d.convert_frozen_batchnorm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone"], ["", "@", "classmethod", "\n", "def", "convert_frozen_batchnorm", "(", "cls", ",", "module", ")", ":", "\n", "        ", "\"\"\"\n        Convert BatchNorm/SyncBatchNorm in module into FrozenBatchNorm.\n\n        Args:\n            module (torch.nn.Module):\n\n        Returns:\n            If module is BatchNorm/SyncBatchNorm, returns a new module.\n            Otherwise, in-place convert module and return it.\n\n        Similar to convert_sync_batchnorm in\n        https://github.com/pytorch/pytorch/blob/master/torch/nn/modules/batchnorm.py\n        \"\"\"", "\n", "bn_module", "=", "nn", ".", "modules", ".", "batchnorm", "\n", "bn_module", "=", "(", "bn_module", ".", "BatchNorm2d", ",", "bn_module", ".", "SyncBatchNorm", ")", "\n", "res", "=", "module", "\n", "if", "isinstance", "(", "module", ",", "bn_module", ")", ":", "\n", "            ", "res", "=", "cls", "(", "module", ".", "num_features", ")", "\n", "if", "module", ".", "affine", ":", "\n", "                ", "res", ".", "weight", ".", "data", "=", "module", ".", "weight", ".", "data", ".", "clone", "(", ")", ".", "detach", "(", ")", "\n", "res", ".", "bias", ".", "data", "=", "module", ".", "bias", ".", "data", ".", "clone", "(", ")", ".", "detach", "(", ")", "\n", "", "res", ".", "running_mean", ".", "data", "=", "module", ".", "running_mean", ".", "data", "\n", "res", ".", "running_var", ".", "data", "=", "module", ".", "running_var", ".", "data", "\n", "res", ".", "eps", "=", "module", ".", "eps", "\n", "", "else", ":", "\n", "            ", "for", "name", ",", "child", "in", "module", ".", "named_children", "(", ")", ":", "\n", "                ", "new_child", "=", "cls", ".", "convert_frozen_batchnorm", "(", "child", ")", "\n", "if", "new_child", "is", "not", "child", ":", "\n", "                    ", "res", ".", "add_module", "(", "name", ",", "new_child", ")", "\n", "", "", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.AllReduce.forward": [[154, 161], ["torch.all_gather", "torch.all_gather", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "range", "torch.get_world_size", "torch.get_world_size"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "input", ")", ":", "\n", "        ", "input_list", "=", "[", "torch", ".", "zeros_like", "(", "input", ")", "for", "k", "in", "range", "(", "dist", ".", "get_world_size", "(", ")", ")", "]", "\n", "# Use allgather instead of allreduce since I don't trust in-place operations ..", "\n", "dist", ".", "all_gather", "(", "input_list", ",", "input", ",", "async_op", "=", "False", ")", "\n", "inputs", "=", "torch", ".", "stack", "(", "input_list", ",", "dim", "=", "0", ")", "\n", "return", "torch", ".", "sum", "(", "inputs", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.AllReduce.backward": [[162, 166], ["torch.all_reduce", "torch.all_reduce"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "dist", ".", "all_reduce", "(", "grad_output", ",", "async_op", "=", "False", ")", "\n", "return", "grad_output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.NaiveSyncBatchNorm.__init__": [[196, 200], ["wrappers.BatchNorm2d.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "stats_mode", "=", "\"\"", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "assert", "stats_mode", "in", "[", "\"\"", ",", "\"N\"", "]", "\n", "self", ".", "_stats_mode", "=", "stats_mode", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.NaiveSyncBatchNorm.forward": [[201, 241], ["torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.rsqrt", "torch.rsqrt", "torch.rsqrt", "torch.rsqrt", "scale.reshape.reshape.reshape", "bias.reshape.reshape.reshape", "super().forward", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.split", "torch.split", "torch.split", "torch.split", "AllReduce.apply", "vec[].detach", "torch.max", "torch.max", "torch.max", "torch.max", "torch.split", "torch.split", "torch.split", "torch.split", "detectron2.utils.comm.get_world_size", "AllReduce.apply", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.max.clamp", "torch.max.clamp", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.mean.detach", "torch.mean.detach", "var.detach", "torch.get_world_size", "torch.get_world_size", "input.sum", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.forward", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "if", "comm", ".", "get_world_size", "(", ")", "==", "1", "or", "not", "self", ".", "training", ":", "\n", "            ", "return", "super", "(", ")", ".", "forward", "(", "input", ")", "\n", "\n", "", "B", ",", "C", "=", "input", ".", "shape", "[", "0", "]", ",", "input", ".", "shape", "[", "1", "]", "\n", "\n", "mean", "=", "torch", ".", "mean", "(", "input", ",", "dim", "=", "[", "0", ",", "2", ",", "3", "]", ")", "\n", "meansqr", "=", "torch", ".", "mean", "(", "input", "*", "input", ",", "dim", "=", "[", "0", ",", "2", ",", "3", "]", ")", "\n", "\n", "if", "self", ".", "_stats_mode", "==", "\"\"", ":", "\n", "            ", "assert", "B", ">", "0", ",", "'SyncBatchNorm(stats_mode=\"\") does not support zero batch size.'", "\n", "vec", "=", "torch", ".", "cat", "(", "[", "mean", ",", "meansqr", "]", ",", "dim", "=", "0", ")", "\n", "vec", "=", "AllReduce", ".", "apply", "(", "vec", ")", "*", "(", "1.0", "/", "dist", ".", "get_world_size", "(", ")", ")", "\n", "mean", ",", "meansqr", "=", "torch", ".", "split", "(", "vec", ",", "C", ")", "\n", "momentum", "=", "self", ".", "momentum", "\n", "", "else", ":", "\n", "            ", "if", "B", "==", "0", ":", "\n", "                ", "vec", "=", "torch", ".", "zeros", "(", "[", "2", "*", "C", "+", "1", "]", ",", "device", "=", "mean", ".", "device", ",", "dtype", "=", "mean", ".", "dtype", ")", "\n", "vec", "=", "vec", "+", "input", ".", "sum", "(", ")", "# make sure there is gradient w.r.t input", "\n", "", "else", ":", "\n", "                ", "vec", "=", "torch", ".", "cat", "(", "\n", "[", "mean", ",", "meansqr", ",", "torch", ".", "ones", "(", "[", "1", "]", ",", "device", "=", "mean", ".", "device", ",", "dtype", "=", "mean", ".", "dtype", ")", "]", ",", "dim", "=", "0", "\n", ")", "\n", "", "vec", "=", "AllReduce", ".", "apply", "(", "vec", "*", "B", ")", "\n", "\n", "total_batch", "=", "vec", "[", "-", "1", "]", ".", "detach", "(", ")", "\n", "momentum", "=", "total_batch", ".", "clamp", "(", "max", "=", "1", ")", "*", "self", ".", "momentum", "# no update if total_batch is 0", "\n", "total_batch", "=", "torch", ".", "max", "(", "total_batch", ",", "torch", ".", "ones_like", "(", "total_batch", ")", ")", "# avoid div-by-zero", "\n", "mean", ",", "meansqr", ",", "_", "=", "torch", ".", "split", "(", "vec", "/", "total_batch", ",", "C", ")", "\n", "\n", "", "var", "=", "meansqr", "-", "mean", "*", "mean", "\n", "invstd", "=", "torch", ".", "rsqrt", "(", "var", "+", "self", ".", "eps", ")", "\n", "scale", "=", "self", ".", "weight", "*", "invstd", "\n", "bias", "=", "self", ".", "bias", "-", "mean", "*", "scale", "\n", "scale", "=", "scale", ".", "reshape", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", "\n", "bias", "=", "bias", ".", "reshape", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", "\n", "\n", "self", ".", "running_mean", "+=", "momentum", "*", "(", "mean", ".", "detach", "(", ")", "-", "self", ".", "running_mean", ")", "\n", "self", ".", "running_var", "+=", "momentum", "*", "(", "var", ".", "detach", "(", ")", "-", "self", ".", "running_var", ")", "\n", "return", "input", "*", "scale", "+", "bias", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm": [[127, 151], ["isinstance", "norm", "len", "torch.nn.GroupNorm"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.norm"], ["", "", "def", "get_norm", "(", "norm", ",", "out_channels", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        norm (str or callable): either one of BN, SyncBN, FrozenBN, GN;\n            or a callable that takes a channel number and returns\n            the normalization layer as a nn.Module.\n\n    Returns:\n        nn.Module or None: the normalization layer\n    \"\"\"", "\n", "if", "isinstance", "(", "norm", ",", "str", ")", ":", "\n", "        ", "if", "len", "(", "norm", ")", "==", "0", ":", "\n", "            ", "return", "None", "\n", "", "norm", "=", "{", "\n", "\"BN\"", ":", "BatchNorm2d", ",", "\n", "# Fixed in https://github.com/pytorch/pytorch/pull/36382", "\n", "\"SyncBN\"", ":", "NaiveSyncBatchNorm", "if", "env", ".", "TORCH_VERSION", "<=", "(", "1", ",", "5", ")", "else", "nn", ".", "SyncBatchNorm", ",", "\n", "\"FrozenBN\"", ":", "FrozenBatchNorm2d", ",", "\n", "\"GN\"", ":", "lambda", "channels", ":", "nn", ".", "GroupNorm", "(", "32", ",", "channels", ")", ",", "\n", "# for debugging:", "\n", "\"nnSyncBN\"", ":", "nn", ".", "SyncBatchNorm", ",", "\n", "\"naiveSyncBN\"", ":", "NaiveSyncBatchNorm", ",", "\n", "}", "[", "norm", "]", "\n", "", "return", "norm", "(", "out_channels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.roi_align.ROIAlign.__init__": [[64, 98], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "output_size", ",", "spatial_scale", ",", "sampling_ratio", ",", "aligned", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            output_size (tuple): h, w\n            spatial_scale (float): scale the input boxes by this number\n            sampling_ratio (int): number of inputs samples to take for each output\n                sample. 0 to take samples densely.\n            aligned (bool): if False, use the legacy implementation in\n                Detectron. If True, align the results more perfectly.\n\n        Note:\n            The meaning of aligned=True:\n\n            Given a continuous coordinate c, its two neighboring pixel indices (in our\n            pixel model) are computed by floor(c - 0.5) and ceil(c - 0.5). For example,\n            c=1.3 has pixel neighbors with discrete indices [0] and [1] (which are sampled\n            from the underlying signal at continuous coordinates 0.5 and 1.5). But the original\n            roi_align (aligned=False) does not subtract the 0.5 when computing neighboring\n            pixel indices and therefore it uses pixels with a slightly incorrect alignment\n            (relative to our pixel model) when performing bilinear interpolation.\n\n            With `aligned=True`,\n            we first appropriately scale the ROI and then shift it by -0.5\n            prior to calling roi_align. This produces the correct neighbors; see\n            detectron2/tests/test_roi_align.py for verification.\n\n            The difference does not make a difference to the model's performance if\n            ROIAlign is used together with conv layers.\n        \"\"\"", "\n", "super", "(", "ROIAlign", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "output_size", "=", "output_size", "\n", "self", ".", "spatial_scale", "=", "spatial_scale", "\n", "self", ".", "sampling_ratio", "=", "sampling_ratio", "\n", "self", ".", "aligned", "=", "aligned", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.roi_align.ROIAlign.forward": [[99, 108], ["torchvision.ops.roi_align", "rois.dim", "rois.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "rois", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input: NCHW images\n            rois: Bx5 boxes. First column is the index into N. The other 4 columns are xyxy.\n        \"\"\"", "\n", "assert", "rois", ".", "dim", "(", ")", "==", "2", "and", "rois", ".", "size", "(", "1", ")", "==", "5", "\n", "return", "roi_align", "(", "\n", "input", ",", "rois", ",", "self", ".", "output_size", ",", "self", ".", "spatial_scale", ",", "self", ".", "sampling_ratio", ",", "self", ".", "aligned", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.roi_align.ROIAlign.__repr__": [[110, 118], ["str", "str", "str", "str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "tmpstr", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "tmpstr", "+=", "\"output_size=\"", "+", "str", "(", "self", ".", "output_size", ")", "\n", "tmpstr", "+=", "\", spatial_scale=\"", "+", "str", "(", "self", ".", "spatial_scale", ")", "\n", "tmpstr", "+=", "\", sampling_ratio=\"", "+", "str", "(", "self", ".", "sampling_ratio", ")", "\n", "tmpstr", "+=", "\", aligned=\"", "+", "str", "(", "self", ".", "aligned", ")", "\n", "tmpstr", "+=", "\")\"", "\n", "return", "tmpstr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.shape_spec.ShapeSpec.__new__": [[19, 21], ["super().__new__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.shape_spec.ShapeSpec.__new__"], ["def", "__new__", "(", "cls", ",", "*", ",", "channels", "=", "None", ",", "height", "=", "None", ",", "width", "=", "None", ",", "stride", "=", "None", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "__new__", "(", "cls", ",", "channels", ",", "height", ",", "width", ",", "stride", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.roi_align_rotated._ROIAlignRotated.forward": [[11, 22], ["ctx.save_for_backward", "torch.nn.modules.utils._pair", "input.size", "detectron2._C.roi_align_rotated_forward"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "input", ",", "roi", ",", "output_size", ",", "spatial_scale", ",", "sampling_ratio", ")", ":", "\n", "        ", "ctx", ".", "save_for_backward", "(", "roi", ")", "\n", "ctx", ".", "output_size", "=", "_pair", "(", "output_size", ")", "\n", "ctx", ".", "spatial_scale", "=", "spatial_scale", "\n", "ctx", ".", "sampling_ratio", "=", "sampling_ratio", "\n", "ctx", ".", "input_shape", "=", "input", ".", "size", "(", ")", "\n", "output", "=", "_C", ".", "roi_align_rotated_forward", "(", "\n", "input", ",", "roi", ",", "spatial_scale", ",", "output_size", "[", "0", "]", ",", "output_size", "[", "1", "]", ",", "sampling_ratio", "\n", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.roi_align_rotated._ROIAlignRotated.backward": [[23, 44], ["detectron2._C.roi_align_rotated_backward"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "once_differentiable", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "(", "rois", ",", ")", "=", "ctx", ".", "saved_tensors", "\n", "output_size", "=", "ctx", ".", "output_size", "\n", "spatial_scale", "=", "ctx", ".", "spatial_scale", "\n", "sampling_ratio", "=", "ctx", ".", "sampling_ratio", "\n", "bs", ",", "ch", ",", "h", ",", "w", "=", "ctx", ".", "input_shape", "\n", "grad_input", "=", "_C", ".", "roi_align_rotated_backward", "(", "\n", "grad_output", ",", "\n", "rois", ",", "\n", "spatial_scale", ",", "\n", "output_size", "[", "0", "]", ",", "\n", "output_size", "[", "1", "]", ",", "\n", "bs", ",", "\n", "ch", ",", "\n", "h", ",", "\n", "w", ",", "\n", "sampling_ratio", ",", "\n", ")", "\n", "return", "grad_input", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.roi_align_rotated.ROIAlignRotated.__init__": [[50, 69], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "output_size", ",", "spatial_scale", ",", "sampling_ratio", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            output_size (tuple): h, w\n            spatial_scale (float): scale the input boxes by this number\n            sampling_ratio (int): number of inputs samples to take for each output\n                sample. 0 to take samples densely.\n\n        Note:\n            ROIAlignRotated supports continuous coordinate by default:\n            Given a continuous coordinate c, its two neighboring pixel indices (in our\n            pixel model) are computed by floor(c - 0.5) and ceil(c - 0.5). For example,\n            c=1.3 has pixel neighbors with discrete indices [0] and [1] (which are sampled\n            from the underlying signal at continuous coordinates 0.5 and 1.5).\n        \"\"\"", "\n", "super", "(", "ROIAlignRotated", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "output_size", "=", "output_size", "\n", "self", ".", "spatial_scale", "=", "spatial_scale", "\n", "self", ".", "sampling_ratio", "=", "sampling_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.roi_align_rotated.ROIAlignRotated.forward": [[70, 80], ["roi_align_rotated", "rois.dim", "rois.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "rois", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input: NCHW images\n            rois: Bx6 boxes. First column is the index into N.\n                The other 5 columns are (x_ctr, y_ctr, width, height, angle_degrees).\n        \"\"\"", "\n", "assert", "rois", ".", "dim", "(", ")", "==", "2", "and", "rois", ".", "size", "(", "1", ")", "==", "6", "\n", "return", "roi_align_rotated", "(", "\n", "input", ",", "rois", ",", "self", ".", "output_size", ",", "self", ".", "spatial_scale", ",", "self", ".", "sampling_ratio", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.roi_align_rotated.ROIAlignRotated.__repr__": [[82, 89], ["str", "str", "str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "tmpstr", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "tmpstr", "+=", "\"output_size=\"", "+", "str", "(", "self", ".", "output_size", ")", "\n", "tmpstr", "+=", "\", spatial_scale=\"", "+", "str", "(", "self", ".", "spatial_scale", ")", "\n", "tmpstr", "+=", "\", sampling_ratio=\"", "+", "str", "(", "self", ".", "sampling_ratio", ")", "\n", "tmpstr", "+=", "\")\"", "\n", "return", "tmpstr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.swap_align2nat._SwapAlign2Nat.forward": [[10, 17], ["X.size", "tensormask._C.swap_align2nat_forward"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "X", ",", "lambda_val", ",", "pad_val", ")", ":", "\n", "        ", "ctx", ".", "lambda_val", "=", "lambda_val", "\n", "ctx", ".", "input_shape", "=", "X", ".", "size", "(", ")", "\n", "\n", "Y", "=", "_C", ".", "swap_align2nat_forward", "(", "X", ",", "lambda_val", ",", "pad_val", ")", "\n", "return", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.swap_align2nat._SwapAlign2Nat.backward": [[18, 27], ["tensormask._C.swap_align2nat_backward"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "once_differentiable", "\n", "def", "backward", "(", "ctx", ",", "gY", ")", ":", "\n", "        ", "lambda_val", "=", "ctx", ".", "lambda_val", "\n", "bs", ",", "ch", ",", "h", ",", "w", "=", "ctx", ".", "input_shape", "\n", "\n", "gX", "=", "_C", ".", "swap_align2nat_backward", "(", "gY", ",", "lambda_val", ",", "bs", ",", "ch", ",", "h", ",", "w", ")", "\n", "\n", "return", "gX", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.swap_align2nat.SwapAlign2Nat.__init__": [[48, 52], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "lambda_val", ",", "pad_val", "=", "-", "6.0", ")", ":", "\n", "        ", "super", "(", "SwapAlign2Nat", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "lambda_val", "=", "lambda_val", "\n", "self", ".", "pad_val", "=", "pad_val", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.swap_align2nat.SwapAlign2Nat.forward": [[53, 55], ["swap_align2nat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "X", ")", ":", "\n", "        ", "return", "swap_align2nat", "(", "X", ",", "self", ".", "lambda_val", ",", "self", ".", "pad_val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.swap_align2nat.SwapAlign2Nat.__repr__": [[56, 62], ["str", "str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "tmpstr", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "tmpstr", "+=", "\"lambda_val=\"", "+", "str", "(", "self", ".", "lambda_val", ")", "\n", "tmpstr", "+=", "\", pad_val=\"", "+", "str", "(", "self", ".", "pad_val", ")", "\n", "tmpstr", "+=", "\")\"", "\n", "return", "tmpstr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align.ROIAlignTest.test_forward_output": [[12, 45], ["numpy.arange().reshape().astype", "test_roi_align.ROIAlignTest._simple_roialign", "test_roi_align.ROIAlignTest._simple_roialign", "test_roi_align.ROIAlignTest.assertTrue", "test_roi_align.ROIAlignTest.assertTrue", "numpy.allclose", "numpy.allclose", "numpy.arange().reshape", "test_roi_align.ROIAlignTest.flatten", "numpy.asarray().flatten", "test_roi_align.ROIAlignTest.flatten", "numpy.asarray().flatten", "numpy.arange", "numpy.asarray", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align.ROIAlignTest._simple_roialign", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align.ROIAlignTest._simple_roialign", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten"], ["    ", "def", "test_forward_output", "(", "self", ")", ":", "\n", "        ", "input", "=", "np", ".", "arange", "(", "25", ")", ".", "reshape", "(", "5", ",", "5", ")", ".", "astype", "(", "\"float32\"", ")", "\n", "\"\"\"\n        0  1  2   3 4\n        5  6  7   8 9\n        10 11 12 13 14\n        15 16 17 18 19\n        20 21 22 23 24\n        \"\"\"", "\n", "\n", "output", "=", "self", ".", "_simple_roialign", "(", "input", ",", "[", "1", ",", "1", ",", "3", ",", "3", "]", ",", "(", "4", ",", "4", ")", ",", "aligned", "=", "False", ")", "\n", "output_correct", "=", "self", ".", "_simple_roialign", "(", "input", ",", "[", "1", ",", "1", ",", "3", ",", "3", "]", ",", "(", "4", ",", "4", ")", ",", "aligned", "=", "True", ")", "\n", "\n", "# without correction:", "\n", "old_results", "=", "[", "\n", "[", "7.5", ",", "8", ",", "8.5", ",", "9", "]", ",", "\n", "[", "10", ",", "10.5", ",", "11", ",", "11.5", "]", ",", "\n", "[", "12.5", ",", "13", ",", "13.5", ",", "14", "]", ",", "\n", "[", "15", ",", "15.5", ",", "16", ",", "16.5", "]", ",", "\n", "]", "\n", "\n", "# with 0.5 correction:", "\n", "correct_results", "=", "[", "\n", "[", "4.5", ",", "5.0", ",", "5.5", ",", "6.0", "]", ",", "\n", "[", "7.0", ",", "7.5", ",", "8.0", ",", "8.5", "]", ",", "\n", "[", "9.5", ",", "10.0", ",", "10.5", ",", "11.0", "]", ",", "\n", "[", "12.0", ",", "12.5", ",", "13.0", ",", "13.5", "]", ",", "\n", "]", "\n", "# This is an upsampled version of [[6, 7], [11, 12]]", "\n", "\n", "self", ".", "assertTrue", "(", "np", ".", "allclose", "(", "output", ".", "flatten", "(", ")", ",", "np", ".", "asarray", "(", "old_results", ")", ".", "flatten", "(", ")", ")", ")", "\n", "self", ".", "assertTrue", "(", "\n", "np", ".", "allclose", "(", "output_correct", ".", "flatten", "(", ")", ",", "np", ".", "asarray", "(", "correct_results", ")", ".", "flatten", "(", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align.ROIAlignTest.test_resize": [[50, 61], ["test_roi_align.ROIAlignTest._simple_roialign", "cv2.resize", "test_roi_align.ROIAlignTest._simple_roialign", "numpy.abs", "test_roi_align.ROIAlignTest.assertTrue", "numpy.random.rand().astype", "numpy.abs.max", "numpy.random.rand"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align.ROIAlignTest._simple_roialign", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align.ROIAlignTest._simple_roialign"], ["", "def", "test_resize", "(", "self", ")", ":", "\n", "        ", "H", ",", "W", "=", "30", ",", "30", "\n", "input", "=", "np", ".", "random", ".", "rand", "(", "H", ",", "W", ")", ".", "astype", "(", "\"float32\"", ")", "*", "100", "\n", "box", "=", "[", "10", ",", "10", ",", "20", ",", "20", "]", "\n", "output", "=", "self", ".", "_simple_roialign", "(", "input", ",", "box", ",", "(", "5", ",", "5", ")", ",", "aligned", "=", "True", ")", "\n", "\n", "input2x", "=", "cv2", ".", "resize", "(", "input", ",", "(", "W", "//", "2", ",", "H", "//", "2", ")", ",", "interpolation", "=", "cv2", ".", "INTER_LINEAR", ")", "\n", "box2x", "=", "[", "x", "/", "2", "for", "x", "in", "box", "]", "\n", "output2x", "=", "self", ".", "_simple_roialign", "(", "input2x", ",", "box2x", ",", "(", "5", ",", "5", ")", ",", "aligned", "=", "True", ")", "\n", "diff", "=", "np", ".", "abs", "(", "output2x", "-", "output", ")", "\n", "self", ".", "assertTrue", "(", "diff", ".", "max", "(", ")", "<", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align.ROIAlignTest._simple_roialign": [[62, 78], ["isinstance", "detectron2.layers.roi_align.ROIAlign", "torch.from_numpy", "torch.from_numpy", "detectron2.layers.roi_align.ROIAlign.forward", "torch.cuda.is_available", "img[].astype", "list", "[].astype", "detectron2.layers.roi_align.ROIAlign.forward().cpu", "test_roi_align.ROIAlignTest.assertTrue", "torch.allclose", "detectron2.layers.roi_align.ROIAlign.forward", "numpy.asarray", "torch.from_numpy.cuda", "torch.from_numpy.cuda"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.forward", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.forward", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda"], ["", "def", "_simple_roialign", "(", "self", ",", "img", ",", "box", ",", "resolution", ",", "aligned", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        RoiAlign with scale 1.0 and 0 sample ratio.\n        \"\"\"", "\n", "if", "isinstance", "(", "resolution", ",", "int", ")", ":", "\n", "            ", "resolution", "=", "(", "resolution", ",", "resolution", ")", "\n", "", "op", "=", "ROIAlign", "(", "resolution", ",", "1.0", ",", "0", ",", "aligned", "=", "aligned", ")", "\n", "input", "=", "torch", ".", "from_numpy", "(", "img", "[", "None", ",", "None", ",", ":", ",", ":", "]", ".", "astype", "(", "\"float32\"", ")", ")", "\n", "\n", "rois", "=", "[", "0", "]", "+", "list", "(", "box", ")", "\n", "rois", "=", "torch", ".", "from_numpy", "(", "np", ".", "asarray", "(", "rois", ")", "[", "None", ",", ":", "]", ".", "astype", "(", "\"float32\"", ")", ")", "\n", "output", "=", "op", ".", "forward", "(", "input", ",", "rois", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "output_cuda", "=", "op", ".", "forward", "(", "input", ".", "cuda", "(", ")", ",", "rois", ".", "cuda", "(", ")", ")", ".", "cpu", "(", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "output", ",", "output_cuda", ")", ")", "\n", "", "return", "output", "[", "0", ",", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align.ROIAlignTest._simple_roialign_with_grad": [[79, 93], ["isinstance", "detectron2.layers.roi_align.ROIAlign", "torch.from_numpy", "torch.from_numpy", "input.to.to.to", "rois.to.to.to", "detectron2.layers.roi_align.ROIAlign.forward", "img[].astype", "list", "[].astype", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.forward"], ["", "def", "_simple_roialign_with_grad", "(", "self", ",", "img", ",", "box", ",", "resolution", ",", "device", ")", ":", "\n", "        ", "if", "isinstance", "(", "resolution", ",", "int", ")", ":", "\n", "            ", "resolution", "=", "(", "resolution", ",", "resolution", ")", "\n", "\n", "", "op", "=", "ROIAlign", "(", "resolution", ",", "1.0", ",", "0", ",", "aligned", "=", "True", ")", "\n", "input", "=", "torch", ".", "from_numpy", "(", "img", "[", "None", ",", "None", ",", ":", ",", ":", "]", ".", "astype", "(", "\"float32\"", ")", ")", "\n", "\n", "rois", "=", "[", "0", "]", "+", "list", "(", "box", ")", "\n", "rois", "=", "torch", ".", "from_numpy", "(", "np", ".", "asarray", "(", "rois", ")", "[", "None", ",", ":", "]", ".", "astype", "(", "\"float32\"", ")", ")", "\n", "input", "=", "input", ".", "to", "(", "device", "=", "device", ")", "\n", "rois", "=", "rois", ".", "to", "(", "device", "=", "device", ")", "\n", "input", ".", "requires_grad", "=", "True", "\n", "output", "=", "op", ".", "forward", "(", "input", ",", "rois", ")", "\n", "return", "input", ",", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align.ROIAlignTest.test_empty_box": [[94, 105], ["numpy.random.rand", "test_roi_align.ROIAlignTest._simple_roialign", "test_roi_align.ROIAlignTest.assertTrue", "test_roi_align.ROIAlignTest.assertTrue", "torch.cuda.is_available", "test_roi_align.ROIAlignTest._simple_roialign_with_grad", "output.sum().backward", "test_roi_align.ROIAlignTest.assertTrue", "torch.device", "torch.allclose", "output.sum", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align.ROIAlignTest._simple_roialign", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align.ROIAlignTest._simple_roialign_with_grad", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.swap_align2nat._SwapAlign2Nat.backward", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device"], ["", "def", "test_empty_box", "(", "self", ")", ":", "\n", "        ", "img", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "5", ")", "\n", "box", "=", "[", "3", ",", "4", ",", "5", ",", "4", "]", "\n", "o", "=", "self", ".", "_simple_roialign", "(", "img", ",", "box", ",", "7", ")", "\n", "self", ".", "assertTrue", "(", "o", ".", "shape", "==", "(", "7", ",", "7", ")", ")", "\n", "self", ".", "assertTrue", "(", "(", "o", "==", "0", ")", ".", "all", "(", ")", ")", "\n", "\n", "for", "dev", "in", "[", "\"cpu\"", "]", "+", "[", "\"cuda\"", "]", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "[", "]", ":", "\n", "            ", "input", ",", "output", "=", "self", ".", "_simple_roialign_with_grad", "(", "img", ",", "box", ",", "7", ",", "torch", ".", "device", "(", "dev", ")", ")", "\n", "output", ".", "sum", "(", ")", ".", "backward", "(", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "input", ".", "grad", ",", "torch", ".", "zeros_like", "(", "input", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align.ROIAlignTest.test_empty_batch": [[106, 112], ["torch.zeros", "torch.zeros", "detectron2.layers.roi_align.ROIAlign", "detectron2.layers.roi_align.ROIAlign.forward", "test_roi_align.ROIAlignTest.assertTrue"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.forward"], ["", "", "def", "test_empty_batch", "(", "self", ")", ":", "\n", "        ", "input", "=", "torch", ".", "zeros", "(", "0", ",", "3", ",", "10", ",", "10", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "rois", "=", "torch", ".", "zeros", "(", "0", ",", "5", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "op", "=", "ROIAlign", "(", "(", "7", ",", "7", ")", ",", "1.0", ",", "0", ",", "aligned", "=", "True", ")", "\n", "output", "=", "op", ".", "forward", "(", "input", ",", "rois", ")", "\n", "self", ".", "assertTrue", "(", "output", ".", "shape", "==", "(", "0", ",", "3", ",", "7", ",", "7", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align.benchmark_roi_align": [[114, 147], ["fvcore.common.benchmark.benchmark", "ret.clamp_", "torch.rand", "range", "torch.cat", "torch.cat", "torch.cat", "input.cuda.cuda", "boxes.cuda.cuda", "dict", "torch.tensor", "test_roi_align.benchmark_roi_align.random_boxes"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.test_box2box_transform.random_boxes"], ["", "", "def", "benchmark_roi_align", "(", ")", ":", "\n", "    ", "from", "detectron2", "import", "_C", "\n", "\n", "def", "random_boxes", "(", "mean_box", ",", "stdev", ",", "N", ",", "maxsize", ")", ":", "\n", "        ", "ret", "=", "torch", ".", "rand", "(", "N", ",", "4", ")", "*", "stdev", "+", "torch", ".", "tensor", "(", "mean_box", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "ret", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "maxsize", ")", "\n", "return", "ret", "\n", "\n", "", "def", "func", "(", "N", ",", "C", ",", "H", ",", "W", ",", "nboxes_per_img", ")", ":", "\n", "        ", "input", "=", "torch", ".", "rand", "(", "N", ",", "C", ",", "H", ",", "W", ")", "\n", "boxes", "=", "[", "]", "\n", "batch_idx", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "N", ")", ":", "\n", "            ", "b", "=", "random_boxes", "(", "[", "80", ",", "80", ",", "130", ",", "130", "]", ",", "24", ",", "nboxes_per_img", ",", "H", ")", "\n", "# try smaller boxes:", "\n", "# b = random_boxes([100, 100, 110, 110], 4, nboxes_per_img, H)", "\n", "boxes", ".", "append", "(", "b", ")", "\n", "batch_idx", ".", "append", "(", "torch", ".", "zeros", "(", "nboxes_per_img", ",", "1", ",", "dtype", "=", "torch", ".", "float32", ")", "+", "k", ")", "\n", "", "boxes", "=", "torch", ".", "cat", "(", "boxes", ",", "axis", "=", "0", ")", "\n", "batch_idx", "=", "torch", ".", "cat", "(", "batch_idx", ",", "axis", "=", "0", ")", "\n", "boxes", "=", "torch", ".", "cat", "(", "[", "batch_idx", ",", "boxes", "]", ",", "axis", "=", "1", ")", "\n", "\n", "input", "=", "input", ".", "cuda", "(", ")", "\n", "boxes", "=", "boxes", ".", "cuda", "(", ")", "\n", "\n", "def", "bench", "(", ")", ":", "\n", "            ", "_C", ".", "roi_align_forward", "(", "input", ",", "boxes", ",", "1.0", ",", "7", ",", "7", ",", "0", ",", "True", ")", "\n", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "\n", "", "return", "bench", "\n", "\n", "", "args", "=", "[", "dict", "(", "N", "=", "2", ",", "C", "=", "512", ",", "H", "=", "256", ",", "W", "=", "256", ",", "nboxes_per_img", "=", "500", ")", "]", "\n", "benchmark", "(", "func", ",", "\"cuda_roialign\"", ",", "args", ",", "num_iters", "=", "20", ",", "warmup_iters", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align_rotated.ROIAlignRotatedTest._box_to_rotated_box": [[15, 22], ["None"], "methods", ["None"], ["    ", "def", "_box_to_rotated_box", "(", "self", ",", "box", ",", "angle", ")", ":", "\n", "        ", "return", "[", "\n", "(", "box", "[", "0", "]", "+", "box", "[", "2", "]", ")", "/", "2.0", ",", "\n", "(", "box", "[", "1", "]", "+", "box", "[", "3", "]", ")", "/", "2.0", ",", "\n", "box", "[", "2", "]", "-", "box", "[", "0", "]", ",", "\n", "box", "[", "3", "]", "-", "box", "[", "1", "]", ",", "\n", "angle", ",", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align_rotated.ROIAlignRotatedTest._rot90": [[24, 29], ["range", "img.transpose().flip.transpose().flip.transpose().flip", "img.transpose().flip.transpose().flip.transpose"], "methods", ["None"], ["", "def", "_rot90", "(", "self", ",", "img", ",", "num", ")", ":", "\n", "        ", "num", "=", "num", "%", "4", "# note: -1 % 4 == 3", "\n", "for", "_", "in", "range", "(", "num", ")", ":", "\n", "            ", "img", "=", "img", ".", "transpose", "(", "0", ",", "1", ")", ".", "flip", "(", "0", ")", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align_rotated.ROIAlignRotatedTest.test_forward_output_0_90_180_270": [[30, 72], ["range", "torch.arange().reshape", "test_roi_align_rotated.ROIAlignRotatedTest._box_to_rotated_box", "test_roi_align_rotated.ROIAlignRotatedTest._simple_roi_align_rotated", "torch.tensor", "test_roi_align_rotated.ROIAlignRotatedTest._rot90", "torch.allclose", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align_rotated.ROIAlignRotatedTest._box_to_rotated_box", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align_rotated.ROIAlignRotatedTest._simple_roi_align_rotated", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align_rotated.ROIAlignRotatedTest._rot90"], ["", "def", "test_forward_output_0_90_180_270", "(", "self", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "# i = 0, 1, 2, 3 corresponding to 0, 90, 180, 270 degrees", "\n", "            ", "img", "=", "torch", ".", "arange", "(", "25", ",", "dtype", "=", "torch", ".", "float32", ")", ".", "reshape", "(", "5", ",", "5", ")", "\n", "\"\"\"\n            0  1  2   3 4\n            5  6  7   8 9\n            10 11 12 13 14\n            15 16 17 18 19\n            20 21 22 23 24\n            \"\"\"", "\n", "box", "=", "[", "1", ",", "1", ",", "3", ",", "3", "]", "\n", "rotated_box", "=", "self", ".", "_box_to_rotated_box", "(", "box", "=", "box", ",", "angle", "=", "90", "*", "i", ")", "\n", "\n", "result", "=", "self", ".", "_simple_roi_align_rotated", "(", "img", "=", "img", ",", "box", "=", "rotated_box", ",", "resolution", "=", "(", "4", ",", "4", ")", ")", "\n", "\n", "# Here's an explanation for 0 degree case:", "\n", "# point 0 in the original input lies at [0.5, 0.5]", "\n", "# (the center of bin [0, 1] x [0, 1])", "\n", "# point 1 in the original input lies at [1.5, 0.5], etc.", "\n", "# since the resolution is (4, 4) that divides [1, 3] x [1, 3]", "\n", "# into 4 x 4 equal bins,", "\n", "# the top-left bin is [1, 1.5] x [1, 1.5], and its center", "\n", "# (1.25, 1.25) lies at the 3/4 position", "\n", "# between point 0 and point 1, point 5 and point 6,", "\n", "# point 0 and point 5, point 1 and point 6, so it can be calculated as", "\n", "# 0.25*(0*0.25+1*0.75)+(5*0.25+6*0.75)*0.75 = 4.5", "\n", "result_expected", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "4.5", ",", "5.0", ",", "5.5", ",", "6.0", "]", ",", "\n", "[", "7.0", ",", "7.5", ",", "8.0", ",", "8.5", "]", ",", "\n", "[", "9.5", ",", "10.0", ",", "10.5", ",", "11.0", "]", ",", "\n", "[", "12.0", ",", "12.5", ",", "13.0", ",", "13.5", "]", ",", "\n", "]", "\n", ")", "\n", "# This is also an upsampled version of [[6, 7], [11, 12]]", "\n", "\n", "# When the box is rotated by 90 degrees CCW,", "\n", "# the result would be rotated by 90 degrees CW, thus it's -i here", "\n", "result_expected", "=", "self", ".", "_rot90", "(", "result_expected", ",", "-", "i", ")", "\n", "\n", "assert", "torch", ".", "allclose", "(", "result", ",", "result_expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align_rotated.ROIAlignRotatedTest.test_resize": [[73, 86], ["test_roi_align_rotated.ROIAlignRotatedTest._box_to_rotated_box", "test_roi_align_rotated.ROIAlignRotatedTest._simple_roi_align_rotated", "cv2.resize", "torch.from_numpy", "test_roi_align_rotated.ROIAlignRotatedTest._box_to_rotated_box", "test_roi_align_rotated.ROIAlignRotatedTest._simple_roi_align_rotated", "torch.allclose", "torch.rand", "input.numpy"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align_rotated.ROIAlignRotatedTest._box_to_rotated_box", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align_rotated.ROIAlignRotatedTest._simple_roi_align_rotated", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align_rotated.ROIAlignRotatedTest._box_to_rotated_box", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align_rotated.ROIAlignRotatedTest._simple_roi_align_rotated"], ["", "", "def", "test_resize", "(", "self", ")", ":", "\n", "        ", "H", ",", "W", "=", "30", ",", "30", "\n", "input", "=", "torch", ".", "rand", "(", "H", ",", "W", ")", "*", "100", "\n", "box", "=", "[", "10", ",", "10", ",", "20", ",", "20", "]", "\n", "rotated_box", "=", "self", ".", "_box_to_rotated_box", "(", "box", ",", "angle", "=", "0", ")", "\n", "output", "=", "self", ".", "_simple_roi_align_rotated", "(", "img", "=", "input", ",", "box", "=", "rotated_box", ",", "resolution", "=", "(", "5", ",", "5", ")", ")", "\n", "\n", "input2x", "=", "cv2", ".", "resize", "(", "input", ".", "numpy", "(", ")", ",", "(", "W", "//", "2", ",", "H", "//", "2", ")", ",", "interpolation", "=", "cv2", ".", "INTER_LINEAR", ")", "\n", "input2x", "=", "torch", ".", "from_numpy", "(", "input2x", ")", "\n", "box2x", "=", "[", "x", "/", "2", "for", "x", "in", "box", "]", "\n", "rotated_box2x", "=", "self", ".", "_box_to_rotated_box", "(", "box2x", ",", "angle", "=", "0", ")", "\n", "output2x", "=", "self", ".", "_simple_roi_align_rotated", "(", "img", "=", "input2x", ",", "box", "=", "rotated_box2x", ",", "resolution", "=", "(", "5", ",", "5", ")", ")", "\n", "assert", "torch", ".", "allclose", "(", "output2x", ",", "output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align_rotated.ROIAlignRotatedTest._simple_roi_align_rotated": [[87, 101], ["detectron2.layers.roi_align_rotated.ROIAlignRotated", "detectron2.layers.roi_align_rotated.ROIAlignRotated.forward", "torch.cuda.is_available", "list", "torch.tensor", "detectron2.layers.roi_align_rotated.ROIAlignRotated.forward", "torch.allclose", "input.cuda", "rois.cuda", "detectron2.layers.roi_align_rotated.ROIAlignRotated.forward.cpu"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.forward", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.forward", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda"], ["", "def", "_simple_roi_align_rotated", "(", "self", ",", "img", ",", "box", ",", "resolution", ")", ":", "\n", "        ", "\"\"\"\n        RoiAlignRotated with scale 1.0 and 0 sample ratio.\n        \"\"\"", "\n", "op", "=", "ROIAlignRotated", "(", "output_size", "=", "resolution", ",", "spatial_scale", "=", "1.0", ",", "sampling_ratio", "=", "0", ")", "\n", "input", "=", "img", "[", "None", ",", "None", ",", ":", ",", ":", "]", "\n", "\n", "rois", "=", "[", "0", "]", "+", "list", "(", "box", ")", "\n", "rois", "=", "torch", ".", "tensor", "(", "rois", ",", "dtype", "=", "torch", ".", "float32", ")", "[", "None", ",", ":", "]", "\n", "result_cpu", "=", "op", ".", "forward", "(", "input", ",", "rois", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "result_cuda", "=", "op", ".", "forward", "(", "input", ".", "cuda", "(", ")", ",", "rois", ".", "cuda", "(", ")", ")", "\n", "assert", "torch", ".", "allclose", "(", "result_cpu", ",", "result_cuda", ".", "cpu", "(", ")", ")", "\n", "", "return", "result_cpu", "[", "0", ",", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align_rotated.ROIAlignRotatedTest.test_empty_box": [[102, 106], ["torch.rand", "test_roi_align_rotated.ROIAlignRotatedTest._simple_roi_align_rotated", "test_roi_align_rotated.ROIAlignRotatedTest.assertTrue"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align_rotated.ROIAlignRotatedTest._simple_roi_align_rotated"], ["", "def", "test_empty_box", "(", "self", ")", ":", "\n", "        ", "img", "=", "torch", ".", "rand", "(", "5", ",", "5", ")", "\n", "out", "=", "self", ".", "_simple_roi_align_rotated", "(", "img", ",", "[", "2", ",", "3", ",", "0", ",", "0", ",", "0", "]", ",", "(", "7", ",", "7", ")", ")", "\n", "self", ".", "assertTrue", "(", "(", "out", "==", "0", ")", ".", "all", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align_rotated.ROIAlignRotatedTest.test_roi_align_rotated_gradcheck_cpu": [[107, 126], ["torch.device", "detectron2.layers.roi_align_rotated.ROIAlignRotated().to", "torch.rand", "torch.tensor", "torch.autograd.gradcheck", "torch.autograd.gradcheck", "detectron2.layers.roi_align_rotated.ROIAlignRotated().to.", "detectron2.layers.roi_align_rotated.ROIAlignRotated", "torch.rand.transpose"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "test_roi_align_rotated_gradcheck_cpu", "(", "self", ")", ":", "\n", "        ", "dtype", "=", "torch", ".", "float64", "\n", "device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "roi_align_rotated_op", "=", "ROIAlignRotated", "(", "\n", "output_size", "=", "(", "5", ",", "5", ")", ",", "spatial_scale", "=", "0.5", ",", "sampling_ratio", "=", "1", "\n", ")", ".", "to", "(", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "x", "=", "torch", ".", "rand", "(", "1", ",", "1", ",", "10", ",", "10", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ",", "requires_grad", "=", "True", ")", "\n", "# roi format is (batch index, x_center, y_center, width, height, angle)", "\n", "rois", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "0", ",", "4.5", ",", "4.5", ",", "9", ",", "9", ",", "0", "]", ",", "[", "0", ",", "2", ",", "7", ",", "4", ",", "4", ",", "0", "]", ",", "[", "0", ",", "7", ",", "7", ",", "4", ",", "4", ",", "0", "]", "]", ",", "\n", "dtype", "=", "dtype", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "\n", "def", "func", "(", "input", ")", ":", "\n", "            ", "return", "roi_align_rotated_op", "(", "input", ",", "rois", ")", "\n", "\n", "", "assert", "gradcheck", "(", "func", ",", "(", "x", ",", ")", ")", ",", "\"gradcheck failed for RoIAlignRotated CPU\"", "\n", "assert", "gradcheck", "(", "func", ",", "(", "x", ".", "transpose", "(", "2", ",", "3", ")", ",", ")", ")", ",", "\"gradcheck failed for RoIAlignRotated CPU\"", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_roi_align_rotated.ROIAlignRotatedTest.test_roi_align_rotated_gradient_cuda": [[127, 173], ["unittest.skipIf", "torch.device", "detectron2.layers.roi_align.ROIAlign().to", "detectron2.layers.roi_align_rotated.ROIAlignRotated().to", "torch.rand", "torch.autograd.Variable", "torch.tensor", "detectron2.layers.roi_align_rotated.ROIAlignRotated().to.", "ROIAlignRotated().to.sum", "roi_align_rotated.sum.backward", "torch.tensor", "detectron2.layers.roi_align.ROIAlign().to.", "ROIAlign().to.sum", "roi_align.sum.backward", "torch.allclose", "torch.rand.data.clone", "torch.cuda.is_available", "detectron2.layers.roi_align.ROIAlign", "detectron2.layers.roi_align_rotated.ROIAlignRotated"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.swap_align2nat._SwapAlign2Nat.backward", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.swap_align2nat._SwapAlign2Nat.backward", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone"], ["", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_roi_align_rotated_gradient_cuda", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Compute gradients for ROIAlignRotated with multiple bounding boxes on the GPU,\n        and compare the result with ROIAlign\n        \"\"\"", "\n", "# torch.manual_seed(123)", "\n", "dtype", "=", "torch", ".", "float64", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda\"", ")", "\n", "pool_h", ",", "pool_w", "=", "(", "5", ",", "5", ")", "\n", "\n", "roi_align", "=", "ROIAlign", "(", "output_size", "=", "(", "pool_h", ",", "pool_w", ")", ",", "spatial_scale", "=", "1", ",", "sampling_ratio", "=", "2", ")", ".", "to", "(", "\n", "device", "=", "device", "\n", ")", "\n", "\n", "roi_align_rotated", "=", "ROIAlignRotated", "(", "\n", "output_size", "=", "(", "pool_h", ",", "pool_w", ")", ",", "spatial_scale", "=", "1", ",", "sampling_ratio", "=", "2", "\n", ")", ".", "to", "(", "device", "=", "device", ")", "\n", "\n", "x", "=", "torch", ".", "rand", "(", "1", ",", "1", ",", "10", ",", "10", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ",", "requires_grad", "=", "True", ")", "\n", "# x_rotated = x.clone() won't work (will lead to grad_fun=CloneBackward)!", "\n", "x_rotated", "=", "Variable", "(", "x", ".", "data", ".", "clone", "(", ")", ",", "requires_grad", "=", "True", ")", "\n", "\n", "# roi_rotated format is (batch index, x_center, y_center, width, height, angle)", "\n", "rois_rotated", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "0", ",", "4.5", ",", "4.5", ",", "9", ",", "9", ",", "0", "]", ",", "[", "0", ",", "2", ",", "7", ",", "4", ",", "4", ",", "0", "]", ",", "[", "0", ",", "7", ",", "7", ",", "4", ",", "4", ",", "0", "]", "]", ",", "\n", "dtype", "=", "dtype", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "\n", "y_rotated", "=", "roi_align_rotated", "(", "x_rotated", ",", "rois_rotated", ")", "\n", "s_rotated", "=", "y_rotated", ".", "sum", "(", ")", "\n", "s_rotated", ".", "backward", "(", ")", "\n", "\n", "# roi format is (batch index, x1, y1, x2, y2)", "\n", "rois", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "0", ",", "0", ",", "0", ",", "9", ",", "9", "]", ",", "[", "0", ",", "0", ",", "5", ",", "4", ",", "9", "]", ",", "[", "0", ",", "5", ",", "5", ",", "9", ",", "9", "]", "]", ",", "dtype", "=", "dtype", ",", "device", "=", "device", "\n", ")", "\n", "\n", "y", "=", "roi_align", "(", "x", ",", "rois", ")", "\n", "s", "=", "y", ".", "sum", "(", ")", "\n", "s", ".", "backward", "(", ")", "\n", "\n", "assert", "torch", ".", "allclose", "(", "\n", "x", ".", "grad", ",", "x_rotated", ".", "grad", "\n", ")", ",", "\"gradients for ROIAlign and ROIAlignRotated mismatch on CUDA\"", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_mask_ops.TestMaskCropPaste.setUp": [[60, 67], ["detectron2.data.MetadataCatalog.get", "fvcore.common.file_io.PathManager.isfile", "unittest.SkipTest", "contextlib.redirect_stdout", "fvcore.common.file_io.PathManager.get_local_path", "pycocotools.coco.COCO", "io.StringIO"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "json_file", "=", "MetadataCatalog", ".", "get", "(", "\"coco_2017_val_100\"", ")", ".", "json_file", "\n", "if", "not", "PathManager", ".", "isfile", "(", "json_file", ")", ":", "\n", "            ", "raise", "unittest", ".", "SkipTest", "(", "\"{} not found\"", ".", "format", "(", "json_file", ")", ")", "\n", "", "with", "contextlib", ".", "redirect_stdout", "(", "io", ".", "StringIO", "(", ")", ")", ":", "\n", "            ", "json_file", "=", "PathManager", ".", "get_local_path", "(", "json_file", ")", "\n", "self", ".", "coco", "=", "COCO", "(", "json_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_mask_ops.TestMaskCropPaste.test_crop_paste_consistency": [[68, 99], ["test_mask_ops.TestMaskCropPaste.coco.loadAnns", "tqdm.tqdm", "numpy.array", "numpy.array.mean", "collections.defaultdict", "zip", "print", "test_mask_ops.TestMaskCropPaste.assertTrue", "test_mask_ops.TestMaskCropPaste.assertTrue", "test_mask_ops.TestMaskCropPaste.coco.getAnnIds", "test_mask_ops.TestMaskCropPaste.process_annotation", "numpy.array.append", "table.append", "tabulate.tabulate.tabulate"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_mask_ops.TestMaskCropPaste.process_annotation"], ["", "", "def", "test_crop_paste_consistency", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        rasterize_polygons_within_box (used in training)\n        and\n        paste_masks_in_image (used in inference)\n        should be inverse operations to each other.\n\n        This function runs several implementation of the above two operations and prints\n        the reconstruction error.\n        \"\"\"", "\n", "\n", "anns", "=", "self", ".", "coco", ".", "loadAnns", "(", "self", ".", "coco", ".", "getAnnIds", "(", "iscrowd", "=", "False", ")", ")", "# avoid crowd annotations", "\n", "\n", "selected_anns", "=", "anns", "[", ":", "100", "]", "\n", "\n", "ious", "=", "[", "]", "\n", "for", "ann", "in", "tqdm", ".", "tqdm", "(", "selected_anns", ")", ":", "\n", "            ", "results", "=", "self", ".", "process_annotation", "(", "ann", ")", "\n", "ious", ".", "append", "(", "[", "k", "[", "2", "]", "for", "k", "in", "results", "]", ")", "\n", "\n", "", "ious", "=", "np", ".", "array", "(", "ious", ")", "\n", "mean_ious", "=", "ious", ".", "mean", "(", "axis", "=", "0", ")", "\n", "table", "=", "[", "]", "\n", "res_dic", "=", "defaultdict", "(", "dict", ")", "\n", "for", "row", ",", "iou", "in", "zip", "(", "results", ",", "mean_ious", ")", ":", "\n", "            ", "table", ".", "append", "(", "(", "row", "[", "0", "]", ",", "row", "[", "1", "]", ",", "iou", ")", ")", "\n", "res_dic", "[", "row", "[", "0", "]", "]", "[", "row", "[", "1", "]", "]", "=", "iou", "\n", "", "print", "(", "tabulate", "(", "table", ",", "headers", "=", "[", "\"rasterize\"", ",", "\"paste\"", ",", "\"iou\"", "]", ",", "tablefmt", "=", "\"simple\"", ")", ")", "\n", "# assert that the reconstruction is good:", "\n", "self", ".", "assertTrue", "(", "res_dic", "[", "\"polygon\"", "]", "[", "\"aligned\"", "]", ">", "0.94", ")", "\n", "self", ".", "assertTrue", "(", "res_dic", "[", "\"roialign\"", "]", "[", "\"aligned\"", "]", ">", "0.95", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_mask_ops.TestMaskCropPaste.process_annotation": [[100, 139], ["detectron2.structures.BoxMode.convert", "detectron2.structures.masks.polygons_to_bitmask", "torch.tensor().to().reshape", "collections.defaultdict", "box_bitmasks.items", "collections.defaultdict.items", "test_mask_ops.TestMaskCropPaste.coco.loadImgs", "numpy.array", "test_mask_ops.rasterize_polygons_with_grid_sample", "detectron2.layers.mask_ops.pad_masks", "detectron2.layers.mask_ops.scale_boxes", "detectron2.layers.mask_ops.paste_mask_in_image_old", "r.items", "torch.tensor().to", "detectron2.structures.PolygonMasks().crop_and_resize", "detectron2.structures.BitMasks().crop_and_resize", "detectron2.layers.mask_ops.paste_masks_in_image", "numpy.asarray", "test_mask_ops.iou_between_full_image_bit_masks", "table.append", "detectron2.structures.Boxes", "detectron2.structures.masks.polygons_to_bitmask.astype", "torch.tensor", "detectron2.structures.PolygonMasks", "detectron2.structures.BitMasks", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.polygons_to_bitmask", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_mask_ops.rasterize_polygons_with_grid_sample", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.mask_ops.pad_masks", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.mask_ops.scale_boxes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.mask_ops.paste_mask_in_image_old", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.PolygonMasks.crop_and_resize", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.PolygonMasks.crop_and_resize", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.mask_ops.paste_masks_in_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_mask_ops.iou_between_full_image_bit_masks"], ["", "def", "process_annotation", "(", "self", ",", "ann", ",", "mask_side_len", "=", "28", ")", ":", "\n", "# Parse annotation data", "\n", "        ", "img_info", "=", "self", ".", "coco", ".", "loadImgs", "(", "ids", "=", "[", "ann", "[", "\"image_id\"", "]", "]", ")", "[", "0", "]", "\n", "height", ",", "width", "=", "img_info", "[", "\"height\"", "]", ",", "img_info", "[", "\"width\"", "]", "\n", "gt_polygons", "=", "[", "np", ".", "array", "(", "p", ",", "dtype", "=", "np", ".", "float64", ")", "for", "p", "in", "ann", "[", "\"segmentation\"", "]", "]", "\n", "gt_bbox", "=", "BoxMode", ".", "convert", "(", "ann", "[", "\"bbox\"", "]", ",", "BoxMode", ".", "XYWH_ABS", ",", "BoxMode", ".", "XYXY_ABS", ")", "\n", "gt_bit_mask", "=", "polygons_to_bitmask", "(", "gt_polygons", ",", "height", ",", "width", ")", "\n", "\n", "# Run rasterize ..", "\n", "torch_gt_bbox", "=", "torch", ".", "tensor", "(", "gt_bbox", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "box_bitmasks", "=", "{", "\n", "\"polygon\"", ":", "PolygonMasks", "(", "[", "gt_polygons", "]", ")", ".", "crop_and_resize", "(", "torch_gt_bbox", ",", "mask_side_len", ")", "[", "0", "]", ",", "\n", "\"gridsample\"", ":", "rasterize_polygons_with_grid_sample", "(", "gt_bit_mask", ",", "gt_bbox", ",", "mask_side_len", ")", ",", "\n", "\"roialign\"", ":", "BitMasks", "(", "torch", ".", "from_numpy", "(", "gt_bit_mask", "[", "None", ",", ":", ",", ":", "]", ")", ")", ".", "crop_and_resize", "(", "\n", "torch_gt_bbox", ",", "mask_side_len", "\n", ")", "[", "0", "]", ",", "\n", "}", "\n", "\n", "# Run paste ..", "\n", "results", "=", "defaultdict", "(", "dict", ")", "\n", "for", "k", ",", "box_bitmask", "in", "box_bitmasks", ".", "items", "(", ")", ":", "\n", "            ", "padded_bitmask", ",", "scale", "=", "pad_masks", "(", "box_bitmask", "[", "None", ",", ":", ",", ":", "]", ",", "1", ")", "\n", "scaled_boxes", "=", "scale_boxes", "(", "torch_gt_bbox", ",", "scale", ")", "\n", "\n", "r", "=", "results", "[", "k", "]", "\n", "r", "[", "\"old\"", "]", "=", "paste_mask_in_image_old", "(", "\n", "padded_bitmask", "[", "0", "]", ",", "scaled_boxes", "[", "0", "]", ",", "height", ",", "width", ",", "threshold", "=", "0.5", "\n", ")", "\n", "r", "[", "\"aligned\"", "]", "=", "paste_masks_in_image", "(", "\n", "box_bitmask", "[", "None", ",", ":", ",", ":", "]", ",", "Boxes", "(", "torch_gt_bbox", ")", ",", "(", "height", ",", "width", ")", "\n", ")", "[", "0", "]", "\n", "\n", "", "table", "=", "[", "]", "\n", "for", "rasterize_method", ",", "r", "in", "results", ".", "items", "(", ")", ":", "\n", "            ", "for", "paste_method", ",", "mask", "in", "r", ".", "items", "(", ")", ":", "\n", "                ", "mask", "=", "np", ".", "asarray", "(", "mask", ")", "\n", "iou", "=", "iou_between_full_image_bit_masks", "(", "gt_bit_mask", ".", "astype", "(", "\"uint8\"", ")", ",", "mask", ")", "\n", "table", ".", "append", "(", "(", "rasterize_method", ",", "paste_method", ",", "iou", ")", ")", "\n", "", "", "return", "table", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_mask_ops.TestMaskCropPaste.test_polygon_area": [[140, 154], ["detectron2.structures.PolygonMasks", "test_mask_ops.TestMaskCropPaste.assertEqual", "detectron2.structures.PolygonMasks", "test_mask_ops.TestMaskCropPaste.assertEqual", "detectron2.structures.PolygonMasks.area", "detectron2.structures.PolygonMasks.area"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.area"], ["", "def", "test_polygon_area", "(", "self", ")", ":", "\n", "# Draw polygon boxes", "\n", "        ", "for", "d", "in", "[", "5.0", ",", "10.0", ",", "1000.0", "]", ":", "\n", "            ", "polygon", "=", "PolygonMasks", "(", "[", "[", "[", "0", ",", "0", ",", "0", ",", "d", ",", "d", ",", "d", ",", "d", ",", "0", "]", "]", "]", ")", "\n", "area", "=", "polygon", ".", "area", "(", ")", "[", "0", "]", "\n", "target", "=", "d", "**", "2", "\n", "self", ".", "assertEqual", "(", "area", ",", "target", ")", "\n", "\n", "# Draw polygon triangles", "\n", "", "for", "d", "in", "[", "5.0", ",", "10.0", ",", "1000.0", "]", ":", "\n", "            ", "polygon", "=", "PolygonMasks", "(", "[", "[", "[", "0", ",", "0", ",", "0", ",", "d", ",", "d", ",", "d", "]", "]", "]", ")", "\n", "area", "=", "polygon", ".", "area", "(", ")", "[", "0", "]", "\n", "target", "=", "d", "**", "2", "/", "2", "\n", "self", ".", "assertEqual", "(", "area", ",", "target", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_mask_ops.iou_between_full_image_bit_masks": [[28, 32], ["None"], "function", ["None"], ["def", "iou_between_full_image_bit_masks", "(", "a", ",", "b", ")", ":", "\n", "    ", "intersect", "=", "(", "a", "&", "b", ")", ".", "sum", "(", ")", "\n", "union", "=", "(", "a", "|", "b", ")", ".", "sum", "(", ")", "\n", "return", "intersect", "/", "union", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_mask_ops.rasterize_polygons_with_grid_sample": [[34, 57], ["torch.meshgrid", "torch.stack().to", "torch.from_numpy", "torch.nn.functional.grid_sample", "numpy.arange", "numpy.arange", "torch.from_numpy", "torch.from_numpy", "full_image_bit_mask[].to", "torch.stack"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "rasterize_polygons_with_grid_sample", "(", "full_image_bit_mask", ",", "box", ",", "mask_size", ",", "threshold", "=", "0.5", ")", ":", "\n", "    ", "x0", ",", "y0", ",", "x1", ",", "y1", "=", "box", "[", "0", "]", ",", "box", "[", "1", "]", ",", "box", "[", "2", "]", ",", "box", "[", "3", "]", "\n", "\n", "img_h", ",", "img_w", "=", "full_image_bit_mask", ".", "shape", "\n", "\n", "mask_y", "=", "np", ".", "arange", "(", "0.0", ",", "mask_size", ")", "+", "0.5", "# mask y sample coords in [0.5, mask_size - 0.5]", "\n", "mask_x", "=", "np", ".", "arange", "(", "0.0", ",", "mask_size", ")", "+", "0.5", "# mask x sample coords in [0.5, mask_size - 0.5]", "\n", "mask_y", "=", "mask_y", "/", "mask_size", "*", "(", "y1", "-", "y0", ")", "+", "y0", "\n", "mask_x", "=", "mask_x", "/", "mask_size", "*", "(", "x1", "-", "x0", ")", "+", "x0", "\n", "\n", "mask_x", "=", "(", "mask_x", "-", "0.5", ")", "/", "(", "img_w", "-", "1", ")", "*", "2", "+", "-", "1", "\n", "mask_y", "=", "(", "mask_y", "-", "0.5", ")", "/", "(", "img_h", "-", "1", ")", "*", "2", "+", "-", "1", "\n", "gy", ",", "gx", "=", "torch", ".", "meshgrid", "(", "torch", ".", "from_numpy", "(", "mask_y", ")", ",", "torch", ".", "from_numpy", "(", "mask_x", ")", ")", "\n", "ind", "=", "torch", ".", "stack", "(", "[", "gx", ",", "gy", "]", ",", "dim", "=", "-", "1", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "full_image_bit_mask", "=", "torch", ".", "from_numpy", "(", "full_image_bit_mask", ")", "\n", "mask", "=", "F", ".", "grid_sample", "(", "\n", "full_image_bit_mask", "[", "None", ",", "None", ",", ":", ",", ":", "]", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", ",", "\n", "ind", "[", "None", ",", ":", ",", ":", ",", ":", "]", ",", "\n", "align_corners", "=", "True", ",", "\n", ")", "\n", "\n", "return", "mask", "[", "0", ",", "0", "]", ">=", "threshold", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_mask_ops.benchmark_paste": [[156, 186], ["torch.manual_seed", "torch.rand", "torch.clamp", "torch.clamp", "torch.clamp", "detectron2.structures.Boxes", "torch.cuda.is_available", "fvcore.common.benchmark.benchmark", "torch.cat", "torch.rand.to", "detectron2.structures.Boxes.to", "specs.append", "torch.rand", "range", "torch.device", "torch.randn", "detectron2.layers.mask_ops.paste_masks_in_image", "torch.cuda.synchronize", "torch.device"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.mask_ops.paste_masks_in_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.synchronize", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device"], ["", "", "", "def", "benchmark_paste", "(", ")", ":", "\n", "    ", "S", "=", "800", "\n", "H", ",", "W", "=", "image_shape", "=", "(", "S", ",", "S", ")", "\n", "N", "=", "64", "\n", "torch", ".", "manual_seed", "(", "42", ")", "\n", "masks", "=", "torch", ".", "rand", "(", "N", ",", "28", ",", "28", ")", "\n", "\n", "center", "=", "torch", ".", "rand", "(", "N", ",", "2", ")", "*", "600", "+", "100", "\n", "wh", "=", "torch", ".", "clamp", "(", "torch", ".", "randn", "(", "N", ",", "2", ")", "*", "40", "+", "200", ",", "min", "=", "50", ")", "\n", "x0y0", "=", "torch", ".", "clamp", "(", "center", "-", "wh", "*", "0.5", ",", "min", "=", "0.0", ")", "\n", "x1y1", "=", "torch", ".", "clamp", "(", "center", "+", "wh", "*", "0.5", ",", "max", "=", "S", ")", "\n", "boxes", "=", "Boxes", "(", "torch", ".", "cat", "(", "[", "x0y0", ",", "x1y1", "]", ",", "axis", "=", "1", ")", ")", "\n", "\n", "def", "func", "(", "device", ",", "n", "=", "3", ")", ":", "\n", "        ", "m", "=", "masks", ".", "to", "(", "device", "=", "device", ")", "\n", "b", "=", "boxes", ".", "to", "(", "device", "=", "device", ")", "\n", "\n", "def", "bench", "(", ")", ":", "\n", "            ", "for", "_", "in", "range", "(", "n", ")", ":", "\n", "                ", "paste_masks_in_image", "(", "m", ",", "b", ",", "image_shape", ")", "\n", "", "if", "device", ".", "type", "==", "\"cuda\"", ":", "\n", "                ", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "\n", "", "", "return", "bench", "\n", "\n", "", "specs", "=", "[", "{", "\"device\"", ":", "torch", ".", "device", "(", "\"cpu\"", ")", ",", "\"n\"", ":", "3", "}", "]", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "specs", ".", "append", "(", "{", "\"device\"", ":", "torch", ".", "device", "(", "\"cuda\"", ")", ",", "\"n\"", ":", "3", "}", ")", "\n", "\n", "", "benchmark", "(", "func", ",", "\"paste_masks\"", ",", "specs", ",", "num_iters", "=", "10", ",", "warmup_iters", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms.TestNMS._create_tensors": [[11, 20], ["torch.rand", "torch.rand"], "methods", ["None"], ["    ", "def", "_create_tensors", "(", "self", ",", "N", ")", ":", "\n", "        ", "boxes", "=", "torch", ".", "rand", "(", "N", ",", "4", ")", "*", "100", "\n", "# Note: the implementation of this function in torchvision is:", "\n", "# boxes[:, 2:] += torch.rand(N, 2) * 100", "\n", "# but it does not guarantee non-negative widths/heights constraints:", "\n", "# boxes[:, 2] >= boxes[:, 0] and boxes[:, 3] >= boxes[:, 1]:", "\n", "boxes", "[", ":", ",", "2", ":", "]", "+=", "boxes", "[", ":", ",", ":", "2", "]", "\n", "scores", "=", "torch", ".", "rand", "(", "N", ")", "\n", "return", "boxes", ",", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms.TestNMS.test_nms_scriptability": [[21, 36], ["unittest.skipIf", "test_nms.TestNMS._create_tensors", "torch.randint", "torch.jit.script", "detectron2.layers.batched_nms", "boxes.clone", "torch.jit.script.", "torch.allclose", "test_nms.TestNMS.assertTrue", "torch.equal", "err_msg.format"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.TestNMSRotated._create_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.batched_nms", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone"], ["", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "6", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_nms_scriptability", "(", "self", ")", ":", "\n", "        ", "N", "=", "2000", "\n", "num_classes", "=", "50", "\n", "boxes", ",", "scores", "=", "self", ".", "_create_tensors", "(", "N", ")", "\n", "idxs", "=", "torch", ".", "randint", "(", "0", ",", "num_classes", ",", "(", "N", ",", ")", ")", "\n", "scripted_batched_nms", "=", "torch", ".", "jit", ".", "script", "(", "batched_nms", ")", "\n", "err_msg", "=", "\"NMS is incompatible with jit-scripted NMS for IoU={}\"", "\n", "\n", "for", "iou", "in", "[", "0.2", ",", "0.5", ",", "0.8", "]", ":", "\n", "            ", "keep_ref", "=", "batched_nms", "(", "boxes", ",", "scores", ",", "idxs", ",", "iou", ")", "\n", "backup", "=", "boxes", ".", "clone", "(", ")", "\n", "scripted_keep", "=", "scripted_batched_nms", "(", "boxes", ",", "scores", ",", "idxs", ",", "iou", ")", "\n", "assert", "torch", ".", "allclose", "(", "boxes", ",", "backup", ")", ",", "\"boxes modified by jit-scripted batched_nms\"", "\n", "self", ".", "assertTrue", "(", "torch", ".", "equal", "(", "keep_ref", ",", "scripted_keep", ")", ",", "err_msg", ".", "format", "(", "iou", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.TestNMSRotated.reference_horizontal_nms": [[41, 64], ["scores.sort", "torch.as_tensor", "len", "picked.append", "torchvision.ops.box_iou().squeeze", "current.item", "len", "torchvision.ops.box_iou", "current_box.unsqueeze"], "methods", ["None"], ["    ", "def", "reference_horizontal_nms", "(", "self", ",", "boxes", ",", "scores", ",", "iou_threshold", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            box_scores (N, 5): boxes in corner-form and probabilities.\n                (Note here 5 == 4 + 1, i.e., 4-dim horizontal box + 1-dim prob)\n            iou_threshold: intersection over union threshold.\n        Returns:\n             picked: a list of indexes of the kept boxes\n        \"\"\"", "\n", "picked", "=", "[", "]", "\n", "_", ",", "indexes", "=", "scores", ".", "sort", "(", "descending", "=", "True", ")", "\n", "while", "len", "(", "indexes", ")", ">", "0", ":", "\n", "            ", "current", "=", "indexes", "[", "0", "]", "\n", "picked", ".", "append", "(", "current", ".", "item", "(", ")", ")", "\n", "if", "len", "(", "indexes", ")", "==", "1", ":", "\n", "                ", "break", "\n", "", "current_box", "=", "boxes", "[", "current", ",", ":", "]", "\n", "indexes", "=", "indexes", "[", "1", ":", "]", "\n", "rest_boxes", "=", "boxes", "[", "indexes", ",", ":", "]", "\n", "iou", "=", "ops", ".", "box_iou", "(", "rest_boxes", ",", "current_box", ".", "unsqueeze", "(", "0", ")", ")", ".", "squeeze", "(", "1", ")", "\n", "indexes", "=", "indexes", "[", "iou", "<=", "iou_threshold", "]", "\n", "\n", "", "return", "torch", ".", "as_tensor", "(", "picked", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.TestNMSRotated._create_tensors": [[65, 74], ["torch.rand", "torch.rand"], "methods", ["None"], ["", "def", "_create_tensors", "(", "self", ",", "N", ")", ":", "\n", "        ", "boxes", "=", "torch", ".", "rand", "(", "N", ",", "4", ")", "*", "100", "\n", "# Note: the implementation of this function in torchvision is:", "\n", "# boxes[:, 2:] += torch.rand(N, 2) * 100", "\n", "# but it does not guarantee non-negative widths/heights constraints:", "\n", "# boxes[:, 2] >= boxes[:, 0] and boxes[:, 3] >= boxes[:, 1]:", "\n", "boxes", "[", ":", ",", "2", ":", "]", "+=", "boxes", "[", ":", ",", ":", "2", "]", "\n", "scores", "=", "torch", ".", "rand", "(", "N", ")", "\n", "return", "boxes", ",", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.TestNMSRotated.test_batched_nms_rotated_0_degree_cpu": [[75, 96], ["test_nms_rotated.TestNMSRotated._create_tensors", "torch.randint", "torch.zeros", "boxes.clone", "detectron2.layers.batched_nms", "torch.allclose", "torch.zeros.clone", "detectron2.layers.batched_nms_rotated", "torch.allclose", "test_nms_rotated.TestNMSRotated.assertLessEqual", "test_nms_rotated.nms_edit_distance", "err_msg.format"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.TestNMSRotated._create_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.batched_nms", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.batched_nms_rotated", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.nms_edit_distance"], ["", "def", "test_batched_nms_rotated_0_degree_cpu", "(", "self", ")", ":", "\n", "        ", "N", "=", "2000", "\n", "num_classes", "=", "50", "\n", "boxes", ",", "scores", "=", "self", ".", "_create_tensors", "(", "N", ")", "\n", "idxs", "=", "torch", ".", "randint", "(", "0", ",", "num_classes", ",", "(", "N", ",", ")", ")", "\n", "rotated_boxes", "=", "torch", ".", "zeros", "(", "N", ",", "5", ")", "\n", "rotated_boxes", "[", ":", ",", "0", "]", "=", "(", "boxes", "[", ":", ",", "0", "]", "+", "boxes", "[", ":", ",", "2", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "1", "]", "=", "(", "boxes", "[", ":", ",", "1", "]", "+", "boxes", "[", ":", ",", "3", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "2", "]", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "\n", "rotated_boxes", "[", ":", ",", "3", "]", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "\n", "err_msg", "=", "\"Rotated NMS with 0 degree is incompatible with horizontal NMS for IoU={}\"", "\n", "for", "iou", "in", "[", "0.2", ",", "0.5", ",", "0.8", "]", ":", "\n", "            ", "backup", "=", "boxes", ".", "clone", "(", ")", "\n", "keep_ref", "=", "batched_nms", "(", "boxes", ",", "scores", ",", "idxs", ",", "iou", ")", "\n", "assert", "torch", ".", "allclose", "(", "boxes", ",", "backup", ")", ",", "\"boxes modified by batched_nms\"", "\n", "backup", "=", "rotated_boxes", ".", "clone", "(", ")", "\n", "keep", "=", "batched_nms_rotated", "(", "rotated_boxes", ",", "scores", ",", "idxs", ",", "iou", ")", "\n", "assert", "torch", ".", "allclose", "(", "\n", "rotated_boxes", ",", "backup", "\n", ")", ",", "\"rotated_boxes modified by batched_nms_rotated\"", "\n", "self", ".", "assertLessEqual", "(", "nms_edit_distance", "(", "keep", ",", "keep_ref", ")", ",", "1", ",", "err_msg", ".", "format", "(", "iou", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.TestNMSRotated.test_batched_nms_rotated_0_degree_cuda": [[97, 120], ["unittest.skipIf", "test_nms_rotated.TestNMSRotated._create_tensors", "torch.randint", "torch.zeros", "boxes.clone", "detectron2.layers.batched_nms", "test_nms_rotated.TestNMSRotated.assertTrue", "torch.zeros.clone", "detectron2.layers.batched_nms_rotated", "test_nms_rotated.TestNMSRotated.assertTrue", "test_nms_rotated.TestNMSRotated.assertLessEqual", "torch.cuda.is_available", "boxes.cuda", "scores.cuda", "torch.allclose", "torch.zeros.cuda", "scores.cuda", "torch.allclose", "test_nms_rotated.nms_edit_distance", "err_msg.format"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.TestNMSRotated._create_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.batched_nms", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.batched_nms_rotated", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.nms_edit_distance"], ["", "", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_batched_nms_rotated_0_degree_cuda", "(", "self", ")", ":", "\n", "        ", "N", "=", "2000", "\n", "num_classes", "=", "50", "\n", "boxes", ",", "scores", "=", "self", ".", "_create_tensors", "(", "N", ")", "\n", "idxs", "=", "torch", ".", "randint", "(", "0", ",", "num_classes", ",", "(", "N", ",", ")", ")", "\n", "rotated_boxes", "=", "torch", ".", "zeros", "(", "N", ",", "5", ")", "\n", "rotated_boxes", "[", ":", ",", "0", "]", "=", "(", "boxes", "[", ":", ",", "0", "]", "+", "boxes", "[", ":", ",", "2", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "1", "]", "=", "(", "boxes", "[", ":", ",", "1", "]", "+", "boxes", "[", ":", ",", "3", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "2", "]", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "\n", "rotated_boxes", "[", ":", ",", "3", "]", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "\n", "err_msg", "=", "\"Rotated NMS with 0 degree is incompatible with horizontal NMS for IoU={}\"", "\n", "for", "iou", "in", "[", "0.2", ",", "0.5", ",", "0.8", "]", ":", "\n", "            ", "backup", "=", "boxes", ".", "clone", "(", ")", "\n", "keep_ref", "=", "batched_nms", "(", "boxes", ".", "cuda", "(", ")", ",", "scores", ".", "cuda", "(", ")", ",", "idxs", ",", "iou", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "boxes", ",", "backup", ")", ",", "\"boxes modified by batched_nms\"", ")", "\n", "backup", "=", "rotated_boxes", ".", "clone", "(", ")", "\n", "keep", "=", "batched_nms_rotated", "(", "rotated_boxes", ".", "cuda", "(", ")", ",", "scores", ".", "cuda", "(", ")", ",", "idxs", ",", "iou", ")", "\n", "self", ".", "assertTrue", "(", "\n", "torch", ".", "allclose", "(", "rotated_boxes", ",", "backup", ")", ",", "\n", "\"rotated_boxes modified by batched_nms_rotated\"", ",", "\n", ")", "\n", "self", ".", "assertLessEqual", "(", "nms_edit_distance", "(", "keep", ",", "keep_ref", ")", ",", "2", ",", "err_msg", ".", "format", "(", "iou", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.TestNMSRotated.test_nms_rotated_0_degree_cpu": [[121, 134], ["test_nms_rotated.TestNMSRotated._create_tensors", "torch.zeros", "test_nms_rotated.TestNMSRotated.reference_horizontal_nms", "detectron2.layers.nms_rotated", "test_nms_rotated.TestNMSRotated.assertLessEqual", "test_nms_rotated.nms_edit_distance", "err_msg.format"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.TestNMSRotated._create_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.TestNMSRotated.reference_horizontal_nms", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.nms_rotated", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.nms_edit_distance"], ["", "", "def", "test_nms_rotated_0_degree_cpu", "(", "self", ")", ":", "\n", "        ", "N", "=", "1000", "\n", "boxes", ",", "scores", "=", "self", ".", "_create_tensors", "(", "N", ")", "\n", "rotated_boxes", "=", "torch", ".", "zeros", "(", "N", ",", "5", ")", "\n", "rotated_boxes", "[", ":", ",", "0", "]", "=", "(", "boxes", "[", ":", ",", "0", "]", "+", "boxes", "[", ":", ",", "2", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "1", "]", "=", "(", "boxes", "[", ":", ",", "1", "]", "+", "boxes", "[", ":", ",", "3", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "2", "]", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "\n", "rotated_boxes", "[", ":", ",", "3", "]", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "\n", "err_msg", "=", "\"Rotated NMS incompatible between CPU and reference implementation for IoU={}\"", "\n", "for", "iou", "in", "[", "0.5", "]", ":", "\n", "            ", "keep_ref", "=", "self", ".", "reference_horizontal_nms", "(", "boxes", ",", "scores", ",", "iou", ")", "\n", "keep", "=", "nms_rotated", "(", "rotated_boxes", ",", "scores", ",", "iou", ")", "\n", "self", ".", "assertLessEqual", "(", "nms_edit_distance", "(", "keep", ",", "keep_ref", ")", ",", "1", ",", "err_msg", ".", "format", "(", "iou", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.TestNMSRotated.test_nms_rotated_90_degrees_cpu": [[135, 153], ["test_nms_rotated.TestNMSRotated._create_tensors", "torch.zeros", "torch.ones", "test_nms_rotated.TestNMSRotated.reference_horizontal_nms", "detectron2.layers.nms_rotated", "test_nms_rotated.TestNMSRotated.assertLessEqual", "test_nms_rotated.nms_edit_distance", "err_msg.format"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.TestNMSRotated._create_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.TestNMSRotated.reference_horizontal_nms", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.nms_rotated", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.nms_edit_distance"], ["", "", "def", "test_nms_rotated_90_degrees_cpu", "(", "self", ")", ":", "\n", "        ", "N", "=", "1000", "\n", "boxes", ",", "scores", "=", "self", ".", "_create_tensors", "(", "N", ")", "\n", "rotated_boxes", "=", "torch", ".", "zeros", "(", "N", ",", "5", ")", "\n", "rotated_boxes", "[", ":", ",", "0", "]", "=", "(", "boxes", "[", ":", ",", "0", "]", "+", "boxes", "[", ":", ",", "2", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "1", "]", "=", "(", "boxes", "[", ":", ",", "1", "]", "+", "boxes", "[", ":", ",", "3", "]", ")", "/", "2.0", "\n", "# Note for rotated_boxes[:, 2] and rotated_boxes[:, 3]:", "\n", "# widths and heights are intentionally swapped here for 90 degrees case", "\n", "# so that the reference horizontal nms could be used", "\n", "rotated_boxes", "[", ":", ",", "2", "]", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "\n", "rotated_boxes", "[", ":", ",", "3", "]", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "\n", "\n", "rotated_boxes", "[", ":", ",", "4", "]", "=", "torch", ".", "ones", "(", "N", ")", "*", "90", "\n", "err_msg", "=", "\"Rotated NMS incompatible between CPU and reference implementation for IoU={}\"", "\n", "for", "iou", "in", "[", "0.2", ",", "0.5", ",", "0.8", "]", ":", "\n", "            ", "keep_ref", "=", "self", ".", "reference_horizontal_nms", "(", "boxes", ",", "scores", ",", "iou", ")", "\n", "keep", "=", "nms_rotated", "(", "rotated_boxes", ",", "scores", ",", "iou", ")", "\n", "self", ".", "assertLessEqual", "(", "nms_edit_distance", "(", "keep", ",", "keep_ref", ")", ",", "1", ",", "err_msg", ".", "format", "(", "iou", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.TestNMSRotated.test_nms_rotated_180_degrees_cpu": [[154, 168], ["test_nms_rotated.TestNMSRotated._create_tensors", "torch.zeros", "torch.ones", "test_nms_rotated.TestNMSRotated.reference_horizontal_nms", "detectron2.layers.nms_rotated", "test_nms_rotated.TestNMSRotated.assertLessEqual", "test_nms_rotated.nms_edit_distance", "err_msg.format"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.TestNMSRotated._create_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.TestNMSRotated.reference_horizontal_nms", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.nms_rotated", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.nms_edit_distance"], ["", "", "def", "test_nms_rotated_180_degrees_cpu", "(", "self", ")", ":", "\n", "        ", "N", "=", "1000", "\n", "boxes", ",", "scores", "=", "self", ".", "_create_tensors", "(", "N", ")", "\n", "rotated_boxes", "=", "torch", ".", "zeros", "(", "N", ",", "5", ")", "\n", "rotated_boxes", "[", ":", ",", "0", "]", "=", "(", "boxes", "[", ":", ",", "0", "]", "+", "boxes", "[", ":", ",", "2", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "1", "]", "=", "(", "boxes", "[", ":", ",", "1", "]", "+", "boxes", "[", ":", ",", "3", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "2", "]", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "\n", "rotated_boxes", "[", ":", ",", "3", "]", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "\n", "rotated_boxes", "[", ":", ",", "4", "]", "=", "torch", ".", "ones", "(", "N", ")", "*", "180", "\n", "err_msg", "=", "\"Rotated NMS incompatible between CPU and reference implementation for IoU={}\"", "\n", "for", "iou", "in", "[", "0.2", ",", "0.5", ",", "0.8", "]", ":", "\n", "            ", "keep_ref", "=", "self", ".", "reference_horizontal_nms", "(", "boxes", ",", "scores", ",", "iou", ")", "\n", "keep", "=", "nms_rotated", "(", "rotated_boxes", ",", "scores", ",", "iou", ")", "\n", "self", ".", "assertLessEqual", "(", "nms_edit_distance", "(", "keep", ",", "keep_ref", ")", ",", "1", ",", "err_msg", ".", "format", "(", "iou", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.TestNMSRotated.test_nms_rotated_0_degree_cuda": [[169, 184], ["unittest.skipIf", "test_nms_rotated.TestNMSRotated._create_tensors", "torch.zeros", "detectron2.layers.nms_rotated", "detectron2.layers.nms_rotated", "test_nms_rotated.TestNMSRotated.assertLessEqual", "torch.cuda.is_available", "torch.zeros.cuda", "scores.cuda", "test_nms_rotated.nms_edit_distance", "err_msg.format", "detectron2.layers.nms_rotated.cpu"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.TestNMSRotated._create_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.nms_rotated", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.nms_rotated", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.nms_edit_distance"], ["", "", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_nms_rotated_0_degree_cuda", "(", "self", ")", ":", "\n", "        ", "N", "=", "1000", "\n", "boxes", ",", "scores", "=", "self", ".", "_create_tensors", "(", "N", ")", "\n", "rotated_boxes", "=", "torch", ".", "zeros", "(", "N", ",", "5", ")", "\n", "rotated_boxes", "[", ":", ",", "0", "]", "=", "(", "boxes", "[", ":", ",", "0", "]", "+", "boxes", "[", ":", ",", "2", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "1", "]", "=", "(", "boxes", "[", ":", ",", "1", "]", "+", "boxes", "[", ":", ",", "3", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "2", "]", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "\n", "rotated_boxes", "[", ":", ",", "3", "]", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "\n", "err_msg", "=", "\"Rotated NMS incompatible between CPU and CUDA for IoU={}\"", "\n", "\n", "for", "iou", "in", "[", "0.2", ",", "0.5", ",", "0.8", "]", ":", "\n", "            ", "r_cpu", "=", "nms_rotated", "(", "rotated_boxes", ",", "scores", ",", "iou", ")", "\n", "r_cuda", "=", "nms_rotated", "(", "rotated_boxes", ".", "cuda", "(", ")", ",", "scores", ".", "cuda", "(", ")", ",", "iou", ")", "\n", "self", ".", "assertLessEqual", "(", "nms_edit_distance", "(", "r_cpu", ",", "r_cuda", ".", "cpu", "(", ")", ")", ",", "1", ",", "err_msg", ".", "format", "(", "iou", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.test_nms_rotated.nms_edit_distance": [[11, 38], ["torch.equal", "range", "tuple", "tuple", "len", "len", "numpy.arange", "numpy.arange", "range", "keep1.cpu", "keep2.cpu", "min", "min"], "function", ["None"], ["def", "nms_edit_distance", "(", "keep1", ",", "keep2", ")", ":", "\n", "    ", "\"\"\"\n    Compare the \"keep\" result of two nms call.\n    They are allowed to be different in terms of edit distance\n    due to floating point precision issues, e.g.,\n    if a box happen to have an IoU of 0.5 with another box,\n    one implentation may choose to keep it while another may discard it.\n    \"\"\"", "\n", "if", "torch", ".", "equal", "(", "keep1", ",", "keep2", ")", ":", "\n", "# they should be equal most of the time", "\n", "        ", "return", "0", "\n", "", "keep1", ",", "keep2", "=", "tuple", "(", "keep1", ".", "cpu", "(", ")", ")", ",", "tuple", "(", "keep2", ".", "cpu", "(", ")", ")", "\n", "m", ",", "n", "=", "len", "(", "keep1", ")", ",", "len", "(", "keep2", ")", "\n", "\n", "# edit distance with DP", "\n", "f", "=", "[", "np", ".", "arange", "(", "n", "+", "1", ")", ",", "np", ".", "arange", "(", "n", "+", "1", ")", "]", "\n", "for", "i", "in", "range", "(", "m", ")", ":", "\n", "        ", "cur_row", "=", "i", "%", "2", "\n", "other_row", "=", "(", "i", "+", "1", ")", "%", "2", "\n", "f", "[", "other_row", "]", "[", "0", "]", "=", "i", "+", "1", "\n", "for", "j", "in", "range", "(", "n", ")", ":", "\n", "            ", "f", "[", "other_row", "]", "[", "j", "+", "1", "]", "=", "(", "\n", "f", "[", "cur_row", "]", "[", "j", "]", "\n", "if", "keep1", "[", "i", "]", "==", "keep2", "[", "j", "]", "\n", "else", "min", "(", "min", "(", "f", "[", "cur_row", "]", "[", "j", "]", ",", "f", "[", "cur_row", "]", "[", "j", "+", "1", "]", ")", ",", "f", "[", "other_row", "]", "[", "j", "]", ")", "+", "1", "\n", ")", "\n", "", "", "return", "f", "[", "m", "%", "2", "]", "[", "n", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.catalog.ModelCatalog.get": [[56, 63], ["name.startswith", "name.startswith", "RuntimeError", "catalog.ModelCatalog._get_c2_detectron_baseline", "catalog.ModelCatalog._get_c2_imagenet_pretrained"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.catalog.ModelCatalog._get_c2_detectron_baseline", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.catalog.ModelCatalog._get_c2_imagenet_pretrained"], ["@", "staticmethod", "\n", "def", "get", "(", "name", ")", ":", "\n", "        ", "if", "name", ".", "startswith", "(", "\"Caffe2Detectron/COCO\"", ")", ":", "\n", "            ", "return", "ModelCatalog", ".", "_get_c2_detectron_baseline", "(", "name", ")", "\n", "", "if", "name", ".", "startswith", "(", "\"ImageNetPretrained/\"", ")", ":", "\n", "            ", "return", "ModelCatalog", ".", "_get_c2_imagenet_pretrained", "(", "name", ")", "\n", "", "raise", "RuntimeError", "(", "\"model not present in the catalog: {}\"", ".", "format", "(", "name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.catalog.ModelCatalog._get_c2_imagenet_pretrained": [[64, 71], ["len"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_get_c2_imagenet_pretrained", "(", "name", ")", ":", "\n", "        ", "prefix", "=", "ModelCatalog", ".", "S3_C2_DETECTRON_PREFIX", "\n", "name", "=", "name", "[", "len", "(", "\"ImageNetPretrained/\"", ")", ":", "]", "\n", "name", "=", "ModelCatalog", ".", "C2_IMAGENET_MODELS", "[", "name", "]", "\n", "url", "=", "\"/\"", ".", "join", "(", "[", "prefix", ",", "name", "]", ")", "\n", "return", "url", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.catalog.ModelCatalog._get_c2_detectron_baseline": [[72, 92], ["ModelCatalog.C2_DETECTRON_PATH_FORMAT.format", "len"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_get_c2_detectron_baseline", "(", "name", ")", ":", "\n", "        ", "name", "=", "name", "[", "len", "(", "\"Caffe2Detectron/COCO/\"", ")", ":", "]", "\n", "url", "=", "ModelCatalog", ".", "C2_DETECTRON_MODELS", "[", "name", "]", "\n", "if", "\"keypoint_rcnn\"", "in", "name", ":", "\n", "            ", "dataset", "=", "ModelCatalog", ".", "C2_DATASET_COCO_KEYPOINTS", "\n", "", "else", ":", "\n", "            ", "dataset", "=", "ModelCatalog", ".", "C2_DATASET_COCO", "\n", "\n", "", "if", "\"35998355/rpn_R-50-C4_1x\"", "in", "name", ":", "\n", "# this one model is somehow different from others ..", "\n", "            ", "type", "=", "\"rpn\"", "\n", "", "else", ":", "\n", "            ", "type", "=", "\"generalized_rcnn\"", "\n", "\n", "# Detectron C2 models are stored in the structure defined in `C2_DETECTRON_PATH_FORMAT`.", "\n", "", "url", "=", "ModelCatalog", ".", "C2_DETECTRON_PATH_FORMAT", ".", "format", "(", "\n", "prefix", "=", "ModelCatalog", ".", "S3_C2_DETECTRON_PREFIX", ",", "url", "=", "url", ",", "type", "=", "type", ",", "dataset", "=", "dataset", "\n", ")", "\n", "return", "url", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.catalog.ModelCatalogHandler._get_supported_prefixes": [[101, 103], ["None"], "methods", ["None"], ["def", "_get_supported_prefixes", "(", "self", ")", ":", "\n", "        ", "return", "[", "self", ".", "PREFIX", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.catalog.ModelCatalogHandler._get_local_path": [[104, 109], ["logging.getLogger", "catalog.ModelCatalog.get", "logging.getLogger.info", "fvcore.common.file_io.PathManager.get_local_path", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "def", "_get_local_path", "(", "self", ",", "path", ")", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "catalog_path", "=", "ModelCatalog", ".", "get", "(", "path", "[", "len", "(", "self", ".", "PREFIX", ")", ":", "]", ")", "\n", "logger", ".", "info", "(", "\"Catalog entry {} points to {}\"", ".", "format", "(", "path", ",", "catalog_path", ")", ")", "\n", "return", "PathManager", ".", "get_local_path", "(", "catalog_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.catalog.ModelCatalogHandler._open": [[110, 112], ["fvcore.common.file_io.PathManager.open", "catalog.ModelCatalogHandler._get_local_path"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.catalog.Detectron2Handler._get_local_path"], ["", "def", "_open", "(", "self", ",", "path", ",", "mode", "=", "\"r\"", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "PathManager", ".", "open", "(", "self", ".", "_get_local_path", "(", "path", ")", ",", "mode", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.catalog.Detectron2Handler._get_supported_prefixes": [[122, 124], ["None"], "methods", ["None"], ["def", "_get_supported_prefixes", "(", "self", ")", ":", "\n", "        ", "return", "[", "self", ".", "PREFIX", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.catalog.Detectron2Handler._get_local_path": [[125, 128], ["fvcore.common.file_io.PathManager.get_local_path", "len"], "methods", ["None"], ["", "def", "_get_local_path", "(", "self", ",", "path", ")", ":", "\n", "        ", "name", "=", "path", "[", "len", "(", "self", ".", "PREFIX", ")", ":", "]", "\n", "return", "PathManager", ".", "get_local_path", "(", "self", ".", "S3_DETECTRON2_PREFIX", "+", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.catalog.Detectron2Handler._open": [[129, 131], ["fvcore.common.file_io.PathManager.open", "catalog.Detectron2Handler._get_local_path"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.catalog.Detectron2Handler._get_local_path"], ["", "def", "_open", "(", "self", ",", "path", ",", "mode", "=", "\"r\"", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "PathManager", ".", "open", "(", "self", ".", "_get_local_path", "(", "path", ")", ",", "mode", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.detection_checkpoint.DetectionCheckpointer.__init__": [[17, 24], ["detectron2.is_main_process", "fvcore.common.checkpoint.Checkpointer.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "save_dir", "=", "\"\"", ",", "*", ",", "save_to_disk", "=", "None", ",", "**", "checkpointables", ")", ":", "\n", "        ", "is_main_process", "=", "comm", ".", "is_main_process", "(", ")", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "model", ",", "\n", "save_dir", ",", "\n", "save_to_disk", "=", "is_main_process", "if", "save_to_disk", "is", "None", "else", "save_to_disk", ",", "\n", "**", "checkpointables", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.detection_checkpoint.DetectionCheckpointer._load_file": [[26, 46], ["filename.endswith", "super()._load_file", "fvcore.common.file_io.PathManager.open", "pickle.load", "detection_checkpoint.DetectionCheckpointer.logger.info", "pickle.load.items", "k.endswith"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.detection_checkpoint.DetectionCheckpointer._load_file"], ["", "def", "_load_file", "(", "self", ",", "filename", ")", ":", "\n", "        ", "if", "filename", ".", "endswith", "(", "\".pkl\"", ")", ":", "\n", "            ", "with", "PathManager", ".", "open", "(", "filename", ",", "\"rb\"", ")", "as", "f", ":", "\n", "                ", "data", "=", "pickle", ".", "load", "(", "f", ",", "encoding", "=", "\"latin1\"", ")", "\n", "", "if", "\"model\"", "in", "data", "and", "\"__author__\"", "in", "data", ":", "\n", "# file is in Detectron2 model zoo format", "\n", "                ", "self", ".", "logger", ".", "info", "(", "\"Reading a file from '{}'\"", ".", "format", "(", "data", "[", "\"__author__\"", "]", ")", ")", "\n", "return", "data", "\n", "", "else", ":", "\n", "# assume file is from Caffe2 / Detectron1 model zoo", "\n", "                ", "if", "\"blobs\"", "in", "data", ":", "\n", "# Detection models have \"blobs\", but ImageNet models don't", "\n", "                    ", "data", "=", "data", "[", "\"blobs\"", "]", "\n", "", "data", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "data", ".", "items", "(", ")", "if", "not", "k", ".", "endswith", "(", "\"_momentum\"", ")", "}", "\n", "return", "{", "\"model\"", ":", "data", ",", "\"__author__\"", ":", "\"Caffe2\"", ",", "\"matching_heuristics\"", ":", "True", "}", "\n", "\n", "", "", "loaded", "=", "super", "(", ")", ".", "_load_file", "(", "filename", ")", "# load native pth checkpoint", "\n", "if", "\"model\"", "not", "in", "loaded", ":", "\n", "            ", "loaded", "=", "{", "\"model\"", ":", "loaded", "}", "\n", "", "return", "loaded", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.detection_checkpoint.DetectionCheckpointer._load_model": [[47, 74], ["checkpoint.get", "super()._load_model", "dict", "detection_checkpoint.DetectionCheckpointer._convert_ndarray_to_tensor", "detection_checkpoint.DetectionCheckpointer.model.state_dict", "c2_model_loading.align_and_update_state_dicts", "detection_checkpoint.DetectionCheckpointer.model.named_buffers", "super()._load_model.missing_keys.remove", "checkpoint.get"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.detection_checkpoint.DetectionCheckpointer._load_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.c2_model_loading.align_and_update_state_dicts", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.remove", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "def", "_load_model", "(", "self", ",", "checkpoint", ")", ":", "\n", "        ", "if", "checkpoint", ".", "get", "(", "\"matching_heuristics\"", ",", "False", ")", ":", "\n", "            ", "self", ".", "_convert_ndarray_to_tensor", "(", "checkpoint", "[", "\"model\"", "]", ")", "\n", "# convert weights by name-matching heuristics", "\n", "model_state_dict", "=", "self", ".", "model", ".", "state_dict", "(", ")", "\n", "align_and_update_state_dicts", "(", "\n", "model_state_dict", ",", "\n", "checkpoint", "[", "\"model\"", "]", ",", "\n", "c2_conversion", "=", "checkpoint", ".", "get", "(", "\"__author__\"", ",", "None", ")", "==", "\"Caffe2\"", ",", "\n", ")", "\n", "checkpoint", "[", "\"model\"", "]", "=", "model_state_dict", "\n", "# for non-caffe2 models, use standard ways to load it", "\n", "", "incompatible", "=", "super", "(", ")", ".", "_load_model", "(", "checkpoint", ")", "\n", "if", "incompatible", "is", "None", ":", "# support older versions of fvcore", "\n", "            ", "return", "None", "\n", "\n", "", "model_buffers", "=", "dict", "(", "self", ".", "model", ".", "named_buffers", "(", "recurse", "=", "False", ")", ")", "\n", "for", "k", "in", "[", "\"pixel_mean\"", ",", "\"pixel_std\"", "]", ":", "\n", "# Ignore missing key message about pixel_mean/std.", "\n", "# Though they may be missing in old checkpoints, they will be correctly", "\n", "# initialized from config anyway.", "\n", "            ", "if", "k", "in", "model_buffers", ":", "\n", "                ", "try", ":", "\n", "                    ", "incompatible", ".", "missing_keys", ".", "remove", "(", "k", ")", "\n", "", "except", "ValueError", ":", "\n", "                    ", "pass", "\n", "", "", "", "return", "incompatible", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.c2_model_loading.convert_basic_c2_names": [[12, 66], ["copy.deepcopy", "k.replace", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "k.replace", "k.replace", "k.replace", "k.replace", "re.sub", "k.replace", "k.replace", "k.replace", "k.replace"], "function", ["None"], ["def", "convert_basic_c2_names", "(", "original_keys", ")", ":", "\n", "    ", "\"\"\"\n    Apply some basic name conversion to names in C2 weights.\n    It only deals with typical backbone models.\n\n    Args:\n        original_keys (list[str]):\n    Returns:\n        list[str]: The same number of strings matching those in original_keys.\n    \"\"\"", "\n", "layer_keys", "=", "copy", ".", "deepcopy", "(", "original_keys", ")", "\n", "layer_keys", "=", "[", "\n", "{", "\"pred_b\"", ":", "\"linear_b\"", ",", "\"pred_w\"", ":", "\"linear_w\"", "}", ".", "get", "(", "k", ",", "k", ")", "for", "k", "in", "layer_keys", "\n", "]", "# some hard-coded mappings", "\n", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"_\"", ",", "\".\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"\\\\.b$\"", ",", "\".bias\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"\\\\.w$\"", ",", "\".weight\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "# Uniform both bn and gn names to \"norm\"", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"bn\\\\.s$\"", ",", "\"norm.weight\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"bn\\\\.bias$\"", ",", "\"norm.bias\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"bn\\\\.rm\"", ",", "\"norm.running_mean\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"bn\\\\.running.mean$\"", ",", "\"norm.running_mean\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"bn\\\\.riv$\"", ",", "\"norm.running_var\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"bn\\\\.running.var$\"", ",", "\"norm.running_var\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"bn\\\\.gamma$\"", ",", "\"norm.weight\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"bn\\\\.beta$\"", ",", "\"norm.bias\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"gn\\\\.s$\"", ",", "\"norm.weight\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"gn\\\\.bias$\"", ",", "\"norm.bias\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# stem", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"^res\\\\.conv1\\\\.norm\\\\.\"", ",", "\"conv1.norm.\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "# to avoid mis-matching with \"conv1\" in other components (e.g. detection head)", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"^conv1\\\\.\"", ",", "\"stem.conv1.\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# layer1-4 is used by torchvision, however we follow the C2 naming strategy (res2-5)", "\n", "# layer_keys = [re.sub(\"^res2.\", \"layer1.\", k) for k in layer_keys]", "\n", "# layer_keys = [re.sub(\"^res3.\", \"layer2.\", k) for k in layer_keys]", "\n", "# layer_keys = [re.sub(\"^res4.\", \"layer3.\", k) for k in layer_keys]", "\n", "# layer_keys = [re.sub(\"^res5.\", \"layer4.\", k) for k in layer_keys]", "\n", "\n", "# blocks", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".branch1.\"", ",", "\".shortcut.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".branch2a.\"", ",", "\".conv1.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".branch2b.\"", ",", "\".conv2.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".branch2c.\"", ",", "\".conv3.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# DensePose substitutions", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"^body.conv.fcn\"", ",", "\"body_conv_fcn\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"AnnIndex.lowres\"", ",", "\"ann_index_lowres\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"Index.UV.lowres\"", ",", "\"index_uv_lowres\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"U.lowres\"", ",", "\"u_lowres\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"V.lowres\"", ",", "\"v_lowres\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "return", "layer_keys", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.c2_model_loading.convert_c2_detectron_names": [[68, 207], ["logging.getLogger", "logging.getLogger.info", "sorted", "copy.deepcopy", "c2_model_loading.convert_basic_c2_names", "zip", "weights.keys", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "name.split", "name.startswith", "c2_model_loading.convert_c2_detectron_names.fpn_map"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.c2_model_loading.convert_basic_c2_names"], ["", "def", "convert_c2_detectron_names", "(", "weights", ")", ":", "\n", "    ", "\"\"\"\n    Map Caffe2 Detectron weight names to Detectron2 names.\n\n    Args:\n        weights (dict): name -> tensor\n\n    Returns:\n        dict: detectron2 names -> tensor\n        dict: detectron2 names -> C2 names\n    \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Remapping C2 weights ......\"", ")", "\n", "original_keys", "=", "sorted", "(", "weights", ".", "keys", "(", ")", ")", "\n", "layer_keys", "=", "copy", ".", "deepcopy", "(", "original_keys", ")", "\n", "\n", "layer_keys", "=", "convert_basic_c2_names", "(", "layer_keys", ")", "\n", "\n", "# --------------------------------------------------------------------------", "\n", "# RPN hidden representation conv", "\n", "# --------------------------------------------------------------------------", "\n", "# FPN case", "\n", "# In the C2 model, the RPN hidden layer conv is defined for FPN level 2 and then", "\n", "# shared for all other levels, hence the appearance of \"fpn2\"", "\n", "layer_keys", "=", "[", "\n", "k", ".", "replace", "(", "\"conv.rpn.fpn2\"", ",", "\"proposal_generator.rpn_head.conv\"", ")", "for", "k", "in", "layer_keys", "\n", "]", "\n", "# Non-FPN case", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"conv.rpn\"", ",", "\"proposal_generator.rpn_head.conv\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# --------------------------------------------------------------------------", "\n", "# RPN box transformation conv", "\n", "# --------------------------------------------------------------------------", "\n", "# FPN case (see note above about \"fpn2\")", "\n", "layer_keys", "=", "[", "\n", "k", ".", "replace", "(", "\"rpn.bbox.pred.fpn2\"", ",", "\"proposal_generator.rpn_head.anchor_deltas\"", ")", "\n", "for", "k", "in", "layer_keys", "\n", "]", "\n", "layer_keys", "=", "[", "\n", "k", ".", "replace", "(", "\"rpn.cls.logits.fpn2\"", ",", "\"proposal_generator.rpn_head.objectness_logits\"", ")", "\n", "for", "k", "in", "layer_keys", "\n", "]", "\n", "# Non-FPN case", "\n", "layer_keys", "=", "[", "\n", "k", ".", "replace", "(", "\"rpn.bbox.pred\"", ",", "\"proposal_generator.rpn_head.anchor_deltas\"", ")", "for", "k", "in", "layer_keys", "\n", "]", "\n", "layer_keys", "=", "[", "\n", "k", ".", "replace", "(", "\"rpn.cls.logits\"", ",", "\"proposal_generator.rpn_head.objectness_logits\"", ")", "\n", "for", "k", "in", "layer_keys", "\n", "]", "\n", "\n", "# --------------------------------------------------------------------------", "\n", "# Fast R-CNN box head", "\n", "# --------------------------------------------------------------------------", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"^bbox\\\\.pred\"", ",", "\"bbox_pred\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"^cls\\\\.score\"", ",", "\"cls_score\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"^fc6\\\\.\"", ",", "\"box_head.fc1.\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"^fc7\\\\.\"", ",", "\"box_head.fc2.\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "# 4conv1fc head tensor names: head_conv1_w, head_conv1_gn_s", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"^head\\\\.conv\"", ",", "\"box_head.conv\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# --------------------------------------------------------------------------", "\n", "# FPN lateral and output convolutions", "\n", "# --------------------------------------------------------------------------", "\n", "def", "fpn_map", "(", "name", ")", ":", "\n", "        ", "\"\"\"\n        Look for keys with the following patterns:\n        1) Starts with \"fpn.inner.\"\n           Example: \"fpn.inner.res2.2.sum.lateral.weight\"\n           Meaning: These are lateral pathway convolutions\n        2) Starts with \"fpn.res\"\n           Example: \"fpn.res2.2.sum.weight\"\n           Meaning: These are FPN output convolutions\n        \"\"\"", "\n", "splits", "=", "name", ".", "split", "(", "\".\"", ")", "\n", "norm", "=", "\".norm\"", "if", "\"norm\"", "in", "splits", "else", "\"\"", "\n", "if", "name", ".", "startswith", "(", "\"fpn.inner.\"", ")", ":", "\n", "# splits example: ['fpn', 'inner', 'res2', '2', 'sum', 'lateral', 'weight']", "\n", "            ", "stage", "=", "int", "(", "splits", "[", "2", "]", "[", "len", "(", "\"res\"", ")", ":", "]", ")", "\n", "return", "\"fpn_lateral{}{}.{}\"", ".", "format", "(", "stage", ",", "norm", ",", "splits", "[", "-", "1", "]", ")", "\n", "", "elif", "name", ".", "startswith", "(", "\"fpn.res\"", ")", ":", "\n", "# splits example: ['fpn', 'res2', '2', 'sum', 'weight']", "\n", "            ", "stage", "=", "int", "(", "splits", "[", "1", "]", "[", "len", "(", "\"res\"", ")", ":", "]", ")", "\n", "return", "\"fpn_output{}{}.{}\"", ".", "format", "(", "stage", ",", "norm", ",", "splits", "[", "-", "1", "]", ")", "\n", "", "return", "name", "\n", "\n", "", "layer_keys", "=", "[", "fpn_map", "(", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# --------------------------------------------------------------------------", "\n", "# Mask R-CNN mask head", "\n", "# --------------------------------------------------------------------------", "\n", "# roi_heads.StandardROIHeads case", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".[mask].fcn\"", ",", "\"mask_head.mask_fcn\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"^\\\\.mask\\\\.fcn\"", ",", "\"mask_head.mask_fcn\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"mask.fcn.logits\"", ",", "\"mask_head.predictor\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "# roi_heads.Res5ROIHeads case", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"conv5.mask\"", ",", "\"mask_head.deconv\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# --------------------------------------------------------------------------", "\n", "# Keypoint R-CNN head", "\n", "# --------------------------------------------------------------------------", "\n", "# interestingly, the keypoint head convs have blob names that are simply \"conv_fcnX\"", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"conv.fcn\"", ",", "\"roi_heads.keypoint_head.conv_fcn\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "\n", "k", ".", "replace", "(", "\"kps.score.lowres\"", ",", "\"roi_heads.keypoint_head.score_lowres\"", ")", "for", "k", "in", "layer_keys", "\n", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"kps.score.\"", ",", "\"roi_heads.keypoint_head.score.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# --------------------------------------------------------------------------", "\n", "# Done with replacements", "\n", "# --------------------------------------------------------------------------", "\n", "assert", "len", "(", "set", "(", "layer_keys", ")", ")", "==", "len", "(", "layer_keys", ")", "\n", "assert", "len", "(", "original_keys", ")", "==", "len", "(", "layer_keys", ")", "\n", "\n", "new_weights", "=", "{", "}", "\n", "new_keys_to_original_keys", "=", "{", "}", "\n", "for", "orig", ",", "renamed", "in", "zip", "(", "original_keys", ",", "layer_keys", ")", ":", "\n", "        ", "new_keys_to_original_keys", "[", "renamed", "]", "=", "orig", "\n", "if", "renamed", ".", "startswith", "(", "\"bbox_pred.\"", ")", "or", "renamed", ".", "startswith", "(", "\"mask_head.predictor.\"", ")", ":", "\n", "# remove the meaningless prediction weight for background class", "\n", "            ", "new_start_idx", "=", "4", "if", "renamed", ".", "startswith", "(", "\"bbox_pred.\"", ")", "else", "1", "\n", "new_weights", "[", "renamed", "]", "=", "weights", "[", "orig", "]", "[", "new_start_idx", ":", "]", "\n", "logger", ".", "info", "(", "\n", "\"Remove prediction weight for background class in {}. The shape changes from \"", "\n", "\"{} to {}.\"", ".", "format", "(", "\n", "renamed", ",", "tuple", "(", "weights", "[", "orig", "]", ".", "shape", ")", ",", "tuple", "(", "new_weights", "[", "renamed", "]", ".", "shape", ")", "\n", ")", "\n", ")", "\n", "", "elif", "renamed", ".", "startswith", "(", "\"cls_score.\"", ")", ":", "\n", "# move weights of bg class from original index 0 to last index", "\n", "            ", "logger", ".", "info", "(", "\n", "\"Move classification weights for background class in {} from index 0 to \"", "\n", "\"index {}.\"", ".", "format", "(", "renamed", ",", "weights", "[", "orig", "]", ".", "shape", "[", "0", "]", "-", "1", ")", "\n", ")", "\n", "new_weights", "[", "renamed", "]", "=", "torch", ".", "cat", "(", "[", "weights", "[", "orig", "]", "[", "1", ":", "]", ",", "weights", "[", "orig", "]", "[", ":", "1", "]", "]", ")", "\n", "", "else", ":", "\n", "            ", "new_weights", "[", "renamed", "]", "=", "weights", "[", "orig", "]", "\n", "\n", "", "", "return", "new_weights", ",", "new_keys_to_original_keys", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.c2_model_loading.align_and_update_state_dicts": [[211, 313], ["sorted", "sorted", "torch.as_tensor().view", "torch.as_tensor().view.max", "logging.getLogger", "enumerate", "matched_keys.values", "matched_keys.keys", "len", "len", "model_state_dict.keys", "c2_model_loading.convert_c2_detectron_names", "ckpt_state_dict.keys", "len", "len", "max", "max", "idxs.tolist", "value_ckpt.clone", "logging.getLogger.info", "logging.getLogger.info", "logging.getLogger.info", "a.endswith", "c2_model_loading.align_and_update_state_dicts.match"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.c2_model_loading.convert_c2_detectron_names", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone"], ["", "def", "align_and_update_state_dicts", "(", "model_state_dict", ",", "ckpt_state_dict", ",", "c2_conversion", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Match names between the two state-dict, and update the values of model_state_dict in-place with\n    copies of the matched tensor in ckpt_state_dict.\n    If `c2_conversion==True`, `ckpt_state_dict` is assumed to be a Caffe2\n    model and will be renamed at first.\n\n    Strategy: suppose that the models that we will create will have prefixes appended\n    to each of its keys, for example due to an extra level of nesting that the original\n    pre-trained weights from ImageNet won't contain. For example, model.state_dict()\n    might return backbone[0].body.res2.conv1.weight, while the pre-trained model contains\n    res2.conv1.weight. We thus want to match both parameters together.\n    For that, we look for each model weight, look among all loaded keys if there is one\n    that is a suffix of the current weight name, and use it if that's the case.\n    If multiple matches exist, take the one with longest size\n    of the corresponding name. For example, for the same model as before, the pretrained\n    weight file can contain both res2.conv1.weight, as well as conv1.weight. In this case,\n    we want to match backbone[0].body.conv1.weight to conv1.weight, and\n    backbone[0].body.res2.conv1.weight to res2.conv1.weight.\n    \"\"\"", "\n", "model_keys", "=", "sorted", "(", "model_state_dict", ".", "keys", "(", ")", ")", "\n", "if", "c2_conversion", ":", "\n", "        ", "ckpt_state_dict", ",", "original_keys", "=", "convert_c2_detectron_names", "(", "ckpt_state_dict", ")", "\n", "# original_keys: the name in the original dict (before renaming)", "\n", "", "else", ":", "\n", "        ", "original_keys", "=", "{", "x", ":", "x", "for", "x", "in", "ckpt_state_dict", ".", "keys", "(", ")", "}", "\n", "", "ckpt_keys", "=", "sorted", "(", "ckpt_state_dict", ".", "keys", "(", ")", ")", "\n", "\n", "def", "match", "(", "a", ",", "b", ")", ":", "\n", "# Matched ckpt_key should be a complete (starts with '.') suffix.", "\n", "# For example, roi_heads.mesh_head.whatever_conv1 does not match conv1,", "\n", "# but matches whatever_conv1 or mesh_head.whatever_conv1.", "\n", "        ", "return", "a", "==", "b", "or", "a", ".", "endswith", "(", "\".\"", "+", "b", ")", "\n", "\n", "# get a matrix of string matches, where each (i, j) entry correspond to the size of the", "\n", "# ckpt_key string, if it matches", "\n", "", "match_matrix", "=", "[", "len", "(", "j", ")", "if", "match", "(", "i", ",", "j", ")", "else", "0", "for", "i", "in", "model_keys", "for", "j", "in", "ckpt_keys", "]", "\n", "match_matrix", "=", "torch", ".", "as_tensor", "(", "match_matrix", ")", ".", "view", "(", "len", "(", "model_keys", ")", ",", "len", "(", "ckpt_keys", ")", ")", "\n", "# use the matched one with longest size in case of multiple matches", "\n", "max_match_size", ",", "idxs", "=", "match_matrix", ".", "max", "(", "1", ")", "\n", "# remove indices that correspond to no-match", "\n", "idxs", "[", "max_match_size", "==", "0", "]", "=", "-", "1", "\n", "\n", "# used for logging", "\n", "max_len_model", "=", "max", "(", "len", "(", "key", ")", "for", "key", "in", "model_keys", ")", "if", "model_keys", "else", "1", "\n", "max_len_ckpt", "=", "max", "(", "len", "(", "key", ")", "for", "key", "in", "ckpt_keys", ")", "if", "ckpt_keys", "else", "1", "\n", "log_str_template", "=", "\"{: <{}} loaded from {: <{}} of shape {}\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "# matched_pairs (matched checkpoint key --> matched model key)", "\n", "matched_keys", "=", "{", "}", "\n", "for", "idx_model", ",", "idx_ckpt", "in", "enumerate", "(", "idxs", ".", "tolist", "(", ")", ")", ":", "\n", "        ", "if", "idx_ckpt", "==", "-", "1", ":", "\n", "            ", "continue", "\n", "", "key_model", "=", "model_keys", "[", "idx_model", "]", "\n", "key_ckpt", "=", "ckpt_keys", "[", "idx_ckpt", "]", "\n", "value_ckpt", "=", "ckpt_state_dict", "[", "key_ckpt", "]", "\n", "shape_in_model", "=", "model_state_dict", "[", "key_model", "]", ".", "shape", "\n", "\n", "if", "shape_in_model", "!=", "value_ckpt", ".", "shape", ":", "\n", "            ", "logger", ".", "warning", "(", "\n", "\"Shape of {} in checkpoint is {}, while shape of {} in model is {}.\"", ".", "format", "(", "\n", "key_ckpt", ",", "value_ckpt", ".", "shape", ",", "key_model", ",", "shape_in_model", "\n", ")", "\n", ")", "\n", "logger", ".", "warning", "(", "\n", "\"{} will not be loaded. Please double check and see if this is desired.\"", ".", "format", "(", "\n", "key_ckpt", "\n", ")", "\n", ")", "\n", "continue", "\n", "\n", "", "model_state_dict", "[", "key_model", "]", "=", "value_ckpt", ".", "clone", "(", ")", "\n", "if", "key_ckpt", "in", "matched_keys", ":", "# already added to matched_keys", "\n", "            ", "logger", ".", "error", "(", "\n", "\"Ambiguity found for {} in checkpoint!\"", "\n", "\"It matches at least two keys in the model ({} and {}).\"", ".", "format", "(", "\n", "key_ckpt", ",", "key_model", ",", "matched_keys", "[", "key_ckpt", "]", "\n", ")", "\n", ")", "\n", "raise", "ValueError", "(", "\"Cannot match one checkpoint key to multiple keys in the model.\"", ")", "\n", "\n", "", "matched_keys", "[", "key_ckpt", "]", "=", "key_model", "\n", "logger", ".", "info", "(", "\n", "log_str_template", ".", "format", "(", "\n", "key_model", ",", "\n", "max_len_model", ",", "\n", "original_keys", "[", "key_ckpt", "]", ",", "\n", "max_len_ckpt", ",", "\n", "tuple", "(", "shape_in_model", ")", ",", "\n", ")", "\n", ")", "\n", "", "matched_model_keys", "=", "matched_keys", ".", "values", "(", ")", "\n", "matched_ckpt_keys", "=", "matched_keys", ".", "keys", "(", ")", "\n", "# print warnings about unmatched keys on both side", "\n", "unmatched_model_keys", "=", "[", "k", "for", "k", "in", "model_keys", "if", "k", "not", "in", "matched_model_keys", "]", "\n", "if", "len", "(", "unmatched_model_keys", ")", ":", "\n", "        ", "logger", ".", "info", "(", "get_missing_parameters_message", "(", "unmatched_model_keys", ")", ")", "\n", "\n", "", "unmatched_ckpt_keys", "=", "[", "k", "for", "k", "in", "ckpt_keys", "if", "k", "not", "in", "matched_ckpt_keys", "]", "\n", "if", "len", "(", "unmatched_ckpt_keys", ")", ":", "\n", "        ", "logger", ".", "info", "(", "\n", "get_unexpected_parameters_message", "(", "original_keys", "[", "x", "]", "for", "x", "in", "unmatched_ckpt_keys", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get_checkpoint_url": [[85, 101], ["config_path.replace", "RuntimeError"], "function", ["None"], ["", "def", "get_checkpoint_url", "(", "config_path", ")", ":", "\n", "    ", "\"\"\"\n    Returns the URL to the model trained using the given config\n\n    Args:\n        config_path (str): config file name relative to detectron2's \"configs/\"\n            directory, e.g., \"COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_1x.yaml\"\n\n    Returns:\n        str: a URL to the model\n    \"\"\"", "\n", "name", "=", "config_path", ".", "replace", "(", "\".yaml\"", ",", "\"\"", ")", "\n", "if", "config_path", "in", "_ModelZooUrls", ".", "CONFIG_PATH_TO_URL_SUFFIX", ":", "\n", "        ", "suffix", "=", "_ModelZooUrls", ".", "CONFIG_PATH_TO_URL_SUFFIX", "[", "config_path", "]", "\n", "return", "_ModelZooUrls", ".", "S3_PREFIX", "+", "name", "+", "\"/\"", "+", "suffix", "\n", "", "raise", "RuntimeError", "(", "\"{} not available in Model Zoo!\"", ".", "format", "(", "name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get_config_file": [[103, 120], ["pkg_resources.resource_filename", "os.path.join", "os.path.exists", "RuntimeError"], "function", ["None"], ["", "def", "get_config_file", "(", "config_path", ")", ":", "\n", "    ", "\"\"\"\n    Returns path to a builtin config file.\n\n    Args:\n        config_path (str): config file name relative to detectron2's \"configs/\"\n            directory, e.g., \"COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_1x.yaml\"\n\n    Returns:\n        str: the real path to the config file.\n    \"\"\"", "\n", "cfg_file", "=", "pkg_resources", ".", "resource_filename", "(", "\n", "\"detectron2.model_zoo\"", ",", "os", ".", "path", ".", "join", "(", "\"configs\"", ",", "config_path", ")", "\n", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "cfg_file", ")", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"{} not available in Model Zoo!\"", ".", "format", "(", "config_path", ")", ")", "\n", "", "return", "cfg_file", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get": [[122, 154], ["model_zoo.get_config_file", "detectron2.config.get_cfg", "detectron2.config.get_cfg.merge_from_file", "detectron2.modeling.build_model", "detectron2.checkpoint.DetectionCheckpointer().load", "model_zoo.get_checkpoint_url", "torch.cuda.is_available", "detectron2.checkpoint.DetectionCheckpointer"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get_config_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get_checkpoint_url"], ["", "def", "get", "(", "config_path", ",", "trained", ":", "bool", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Get a model specified by relative path under Detectron2's official ``configs/`` directory.\n\n    Args:\n        config_path (str): config file name relative to detectron2's \"configs/\"\n            directory, e.g., \"COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_1x.yaml\"\n        trained (bool): If True, will initialize the model with the trained model zoo weights.\n            If False, the checkpoint specified in the config file's ``MODEL.WEIGHTS`` is used\n            instead; this will typically (though not always) initialize a subset of weights using\n            an ImageNet pre-trained model, while randomly initializing the other weights.\n\n    Returns:\n        nn.Module: a detectron2 model\n\n    Example:\n    ::\n        from detectron2 import model_zoo\n        model = model_zoo.get(\"COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_1x.yaml\", trained=True)\n    \"\"\"", "\n", "cfg_file", "=", "get_config_file", "(", "config_path", ")", "\n", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "cfg_file", ")", "\n", "if", "trained", ":", "\n", "        ", "cfg", ".", "MODEL", ".", "WEIGHTS", "=", "get_checkpoint_url", "(", "config_path", ")", "\n", "", "if", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "cfg", ".", "MODEL", ".", "DEVICE", "=", "\"cpu\"", "\n", "\n", "", "model", "=", "build_model", "(", "cfg", ")", "\n", "DetectionCheckpointer", "(", "model", ")", ".", "load", "(", "cfg", ".", "MODEL", ".", "WEIGHTS", ")", "\n", "return", "model", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript.export_torchscript_with_instances": [[10, 56], ["torchscript_patch.patch_instances", "torch.jit.script"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript_patch.patch_instances"], ["def", "export_torchscript_with_instances", "(", "model", ",", "fields", ")", ":", "\n", "    ", "\"\"\"\n    Run :func:`torch.jit.script` on a model that uses the :class:`Instances` class. Since\n    attributes of :class:`Instances` are \"dynamically\" added in eager mode\uff0cit is difficult\n    for torchscript to support it out of the box. This function is made to support scripting\n    a model that uses :class:`Instances`. It does the following:\n\n    1. Create a scriptable ``new_Instances`` class which behaves similarly to ``Instances``,\n       but with all attributes been \"static\".\n       The attributes need to be statically declared in the ``fields`` argument.\n    2. Register ``new_Instances`` to torchscript, and force torchscript to\n       use it when trying to compile ``Instances``.\n\n    After this function, the process will be reverted. User should be able to script another model\n    using different fields.\n\n    Example:\n        Assume that ``Instances`` in the model consist of two attributes named\n        ``proposal_boxes`` and ``objectness_logits`` with type :class:`Boxes` and\n        :class:`Tensor` respectively during inference. You can call this function like:\n\n        ::\n            fields = {\"proposal_boxes\": \"Boxes\", \"objectness_logits\": \"Tensor\"}\n            torchscipt_model =  export_torchscript_with_instances(model, fields)\n\n    Note:\n        Currently we only support models in evaluation mode.\n\n    Args:\n        model (nn.Module): The input model to be exported to torchscript.\n        fields (Dict[str, str]): Attribute names and corresponding type annotations that\n            ``Instances`` will use in the model. Note that all attributes used in ``Instances``\n            need to be added, regarldess of whether they are inputs/outputs of the model.\n            Custom data type is not supported for now.\n\n    Returns:\n        torch.jit.ScriptModule: the input model in torchscript format\n    \"\"\"", "\n", "\n", "assert", "(", "\n", "not", "model", ".", "training", "\n", ")", ",", "\"Currently we only support exporting models in evaluation mode to torchscript\"", "\n", "\n", "with", "patch_instances", "(", "fields", ")", ":", "\n", "        ", "scripted_model", "=", "torch", ".", "jit", ".", "script", "(", "model", ")", "\n", "return", "scripted_model", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript.dump_torchscript_IR": [[58, 120], ["fvcore.common.file_io.PathManager.mkdirs", "isinstance", "fvcore.common.file_io.PathManager.open", "torchscript.dump_torchscript_IR.dump_code"], "function", ["None"], ["", "", "def", "dump_torchscript_IR", "(", "model", ",", "dir", ")", ":", "\n", "    ", "\"\"\"\n    Dump IR of a TracedModule/ScriptModule at various levels.\n    Useful for debugging.\n\n    Args:\n        model (TracedModule or ScriptModule): traced or scripted module\n        dir (str): output directory to dump files.\n    \"\"\"", "\n", "PathManager", ".", "mkdirs", "(", "dir", ")", "\n", "\n", "def", "_get_script_mod", "(", "mod", ")", ":", "\n", "        ", "if", "isinstance", "(", "mod", ",", "torch", ".", "jit", ".", "TracedModule", ")", ":", "\n", "            ", "return", "mod", ".", "_actual_script_module", "\n", "", "return", "mod", "\n", "\n", "# Dump pretty-printed code: https://pytorch.org/docs/stable/jit.html#inspecting-code", "\n", "", "with", "PathManager", ".", "open", "(", "os", ".", "path", ".", "join", "(", "dir", ",", "\"model_ts_code.txt\"", ")", ",", "\"w\"", ")", "as", "f", ":", "\n", "\n", "        ", "def", "get_code", "(", "mod", ")", ":", "\n", "# Try a few ways to get code using private attributes.", "\n", "            ", "try", ":", "\n", "# This contains more information than just `mod.code`", "\n", "                ", "return", "_get_script_mod", "(", "mod", ")", ".", "_c", ".", "code", "\n", "", "except", "AttributeError", ":", "\n", "                ", "pass", "\n", "", "try", ":", "\n", "                ", "return", "mod", ".", "code", "\n", "", "except", "AttributeError", ":", "\n", "                ", "return", "None", "\n", "\n", "", "", "def", "dump_code", "(", "prefix", ",", "mod", ")", ":", "\n", "            ", "code", "=", "get_code", "(", "mod", ")", "\n", "name", "=", "prefix", "or", "\"root model\"", "\n", "if", "code", "is", "None", ":", "\n", "                ", "f", ".", "write", "(", "f\"Could not found code for {name} (type={mod.original_name})\\n\"", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "", "else", ":", "\n", "                ", "f", ".", "write", "(", "f\"\\nCode for {name}, type={mod.original_name}:\\n\"", ")", "\n", "f", ".", "write", "(", "code", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "f", ".", "write", "(", "\"-\"", "*", "80", ")", "\n", "\n", "", "for", "name", ",", "m", "in", "mod", ".", "named_children", "(", ")", ":", "\n", "                ", "dump_code", "(", "prefix", "+", "\".\"", "+", "name", ",", "m", ")", "\n", "\n", "", "", "dump_code", "(", "\"\"", ",", "model", ")", "\n", "\n", "# Recursively dump IR of all modules", "\n", "", "with", "PathManager", ".", "open", "(", "os", ".", "path", ".", "join", "(", "dir", ",", "\"model_ts_IR.txt\"", ")", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "try", ":", "\n", "            ", "f", ".", "write", "(", "_get_script_mod", "(", "model", ")", ".", "_c", ".", "dump_to_str", "(", "True", ",", "False", ",", "False", ")", ")", "\n", "", "except", "AttributeError", ":", "\n", "            ", "pass", "\n", "\n", "# Dump IR of the entire graph (all submodules inlined)", "\n", "", "", "with", "PathManager", ".", "open", "(", "os", ".", "path", ".", "join", "(", "dir", ",", "\"model_ts_IR_inlined.txt\"", ")", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "model", ".", "inlined_graph", ")", ")", "\n", "\n", "# Dump the model structure in pytorch style", "\n", "", "with", "PathManager", ".", "open", "(", "os", ".", "path", ".", "join", "(", "dir", ",", "\"model.txt\"", ")", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "model", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.ScopedWS.__init__": [[130, 135], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "ws_name", ",", "is_reset", ",", "is_cleanup", "=", "False", ")", ":", "\n", "        ", "self", ".", "ws_name", "=", "ws_name", "\n", "self", ".", "is_reset", "=", "is_reset", "\n", "self", ".", "is_cleanup", "=", "is_cleanup", "\n", "self", ".", "org_ws", "=", "\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.ScopedWS.__enter__": [[136, 144], ["caffe2.python.workspace.CurrentWorkspace", "caffe2.python.workspace.SwitchWorkspace", "caffe2.python.workspace.ResetWorkspace"], "methods", ["None"], ["", "def", "__enter__", "(", "self", ")", ":", "\n", "        ", "self", ".", "org_ws", "=", "workspace", ".", "CurrentWorkspace", "(", ")", "\n", "if", "self", ".", "ws_name", "is", "not", "None", ":", "\n", "            ", "workspace", ".", "SwitchWorkspace", "(", "self", ".", "ws_name", ",", "True", ")", "\n", "", "if", "self", ".", "is_reset", ":", "\n", "            ", "workspace", ".", "ResetWorkspace", "(", ")", "\n", "\n", "", "return", "workspace", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.ScopedWS.__exit__": [[145, 150], ["caffe2.python.workspace.ResetWorkspace", "caffe2.python.workspace.SwitchWorkspace"], "methods", ["None"], ["", "def", "__exit__", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "if", "self", ".", "is_cleanup", ":", "\n", "            ", "workspace", ".", "ResetWorkspace", "(", ")", "\n", "", "if", "self", ".", "ws_name", "is", "not", "None", ":", "\n", "            ", "workspace", ".", "SwitchWorkspace", "(", "self", ".", "org_ws", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.DiGraph.__init__": [[785, 788], ["set", "collections.defaultdict"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "vertices", "=", "set", "(", ")", "\n", "self", ".", "graph", "=", "collections", ".", "defaultdict", "(", "list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.DiGraph.add_edge": [[789, 793], ["shared.DiGraph.graph[].append", "shared.DiGraph.vertices.add", "shared.DiGraph.vertices.add"], "methods", ["None"], ["", "def", "add_edge", "(", "self", ",", "u", ",", "v", ")", ":", "\n", "        ", "self", ".", "graph", "[", "u", "]", ".", "append", "(", "v", ")", "\n", "self", ".", "vertices", ".", "add", "(", "u", ")", "\n", "self", ".", "vertices", ".", "add", "(", "v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.DiGraph.get_all_paths": [[795, 814], ["shared.DiGraph.get_all_paths._get_all_paths_util"], "methods", ["None"], ["", "def", "get_all_paths", "(", "self", ",", "s", ",", "d", ")", ":", "\n", "        ", "visited", "=", "{", "k", ":", "False", "for", "k", "in", "self", ".", "vertices", "}", "\n", "path", "=", "[", "]", "\n", "all_paths", "=", "[", "]", "\n", "\n", "def", "_get_all_paths_util", "(", "graph", ",", "u", ",", "d", ",", "visited", ",", "path", ")", ":", "\n", "            ", "visited", "[", "u", "]", "=", "True", "\n", "path", ".", "append", "(", "u", ")", "\n", "if", "u", "==", "d", ":", "\n", "                ", "all_paths", ".", "append", "(", "copy", ".", "deepcopy", "(", "path", ")", ")", "\n", "", "else", ":", "\n", "                ", "for", "i", "in", "graph", "[", "u", "]", ":", "\n", "                    ", "if", "not", "visited", "[", "i", "]", ":", "\n", "                        ", "_get_all_paths_util", "(", "graph", ",", "i", ",", "d", ",", "visited", ",", "path", ")", "\n", "", "", "", "path", ".", "pop", "(", ")", "\n", "visited", "[", "u", "]", "=", "False", "\n", "\n", "", "_get_all_paths_util", "(", "self", ".", "graph", ",", "s", ",", "d", ",", "visited", ",", "path", ")", "\n", "return", "all_paths", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.DiGraph.from_ssa": [[815, 823], ["shared.DiGraph", "range", "len", "shared.DiGraph.add_edge"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.DiGraph.add_edge"], ["", "@", "staticmethod", "\n", "def", "from_ssa", "(", "ssa", ")", ":", "\n", "        ", "graph", "=", "DiGraph", "(", ")", "\n", "for", "op_id", "in", "range", "(", "len", "(", "ssa", ")", ")", ":", "\n", "            ", "for", "inp", "in", "ssa", "[", "op_id", "]", "[", "0", "]", ":", "\n", "                ", "for", "outp", "in", "ssa", "[", "op_id", "]", "[", "1", "]", ":", "\n", "                    ", "graph", ".", "add_edge", "(", "inp", ",", "outp", ")", "\n", "", "", "", "return", "graph", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.to_device": [[25, 42], ["torch.device", "torch.device", "torch.ops._caffe2.CopyGPUToCPU", "torch.ops._caffe2.CopyGPUToCPU", "torch.ops._caffe2.CopyCPUToGPU", "torch.ops._caffe2.CopyCPUToGPU", "RuntimeError"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device"], ["def", "to_device", "(", "t", ",", "device_str", ")", ":", "\n", "    ", "\"\"\"\n    This function is a replacement of .to(another_device) such that it allows the\n    casting to be traced properly by explicitly calling the underlying copy ops.\n    It also avoids introducing unncessary op when casting to the same device.\n    \"\"\"", "\n", "src", "=", "t", ".", "device", "\n", "dst", "=", "torch", ".", "device", "(", "device_str", ")", "\n", "\n", "if", "src", "==", "dst", ":", "\n", "        ", "return", "t", "\n", "", "elif", "src", ".", "type", "==", "\"cuda\"", "and", "dst", ".", "type", "==", "\"cpu\"", ":", "\n", "        ", "return", "torch", ".", "ops", ".", "_caffe2", ".", "CopyGPUToCPU", "(", "t", ")", "\n", "", "elif", "src", ".", "type", "==", "\"cpu\"", "and", "dst", ".", "type", "==", "\"cuda\"", ":", "\n", "        ", "return", "torch", ".", "ops", ".", "_caffe2", ".", "CopyCPUToGPU", "(", "t", ")", "\n", "", "else", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"Can't cast tensor from device {} to device {}\"", ".", "format", "(", "src", ",", "dst", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.BilinearInterpolation": [[48, 77], ["shared.BilinearInterpolation.upsample_filt"], "function", ["None"], ["", "", "def", "BilinearInterpolation", "(", "tensor_in", ",", "up_scale", ")", ":", "\n", "    ", "assert", "up_scale", "%", "2", "==", "0", ",", "\"Scale should be even\"", "\n", "\n", "def", "upsample_filt", "(", "size", ")", ":", "\n", "        ", "factor", "=", "(", "size", "+", "1", ")", "//", "2", "\n", "if", "size", "%", "2", "==", "1", ":", "\n", "            ", "center", "=", "factor", "-", "1", "\n", "", "else", ":", "\n", "            ", "center", "=", "factor", "-", "0.5", "\n", "\n", "", "og", "=", "np", ".", "ogrid", "[", ":", "size", ",", ":", "size", "]", "\n", "return", "(", "1", "-", "abs", "(", "og", "[", "0", "]", "-", "center", ")", "/", "factor", ")", "*", "(", "1", "-", "abs", "(", "og", "[", "1", "]", "-", "center", ")", "/", "factor", ")", "\n", "\n", "", "kernel_size", "=", "int", "(", "up_scale", ")", "*", "2", "\n", "bil_filt", "=", "upsample_filt", "(", "kernel_size", ")", "\n", "\n", "dim", "=", "int", "(", "tensor_in", ".", "shape", "[", "1", "]", ")", "\n", "kernel", "=", "np", ".", "zeros", "(", "(", "dim", ",", "dim", ",", "kernel_size", ",", "kernel_size", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "kernel", "[", "range", "(", "dim", ")", ",", "range", "(", "dim", ")", ",", ":", ",", ":", "]", "=", "bil_filt", "\n", "\n", "tensor_out", "=", "F", ".", "conv_transpose2d", "(", "\n", "tensor_in", ",", "\n", "weight", "=", "to_device", "(", "torch", ".", "Tensor", "(", "kernel", ")", ",", "tensor_in", ".", "device", ")", ",", "\n", "bias", "=", "None", ",", "\n", "stride", "=", "int", "(", "up_scale", ")", ",", "\n", "padding", "=", "int", "(", "up_scale", "/", "2", ")", ",", "\n", ")", "\n", "\n", "return", "tensor_out", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.onnx_compatibale_interpolate": [[82, 113], ["torch.nn.functional.interpolate", "logger.warning", "input.dim", "isinstance", "isinstance", "torch.ops._caffe2.ResizeNearest", "torch.ops._caffe2.ResizeNearest", "len", "logger.warning", "shared.BilinearInterpolation"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.BilinearInterpolation"], ["", "def", "onnx_compatibale_interpolate", "(", "\n", "input", ",", "size", "=", "None", ",", "scale_factor", "=", "None", ",", "mode", "=", "\"nearest\"", ",", "align_corners", "=", "None", "\n", ")", ":", "\n", "# NOTE: The input dimensions are interpreted in the form:", "\n", "# `mini-batch x channels x [optional depth] x [optional height] x width`.", "\n", "    ", "if", "size", "is", "None", "and", "scale_factor", "is", "not", "None", ":", "\n", "        ", "if", "input", ".", "dim", "(", ")", "==", "4", ":", "\n", "            ", "if", "isinstance", "(", "scale_factor", ",", "(", "int", ",", "float", ")", ")", ":", "\n", "                ", "height_scale", ",", "width_scale", "=", "(", "scale_factor", ",", "scale_factor", ")", "\n", "", "else", ":", "\n", "                ", "assert", "isinstance", "(", "scale_factor", ",", "(", "tuple", ",", "list", ")", ")", "\n", "assert", "len", "(", "scale_factor", ")", "==", "2", "\n", "height_scale", ",", "width_scale", "=", "scale_factor", "\n", "\n", "", "assert", "not", "align_corners", ",", "\"No matching C2 op for align_corners == True\"", "\n", "if", "mode", "==", "\"nearest\"", ":", "\n", "                ", "return", "torch", ".", "ops", ".", "_caffe2", ".", "ResizeNearest", "(", "\n", "input", ",", "order", "=", "\"NCHW\"", ",", "width_scale", "=", "width_scale", ",", "height_scale", "=", "height_scale", "\n", ")", "\n", "", "elif", "mode", "==", "\"bilinear\"", ":", "\n", "                ", "logger", ".", "warning", "(", "\n", "\"Use F.conv_transpose2d for bilinear interpolate\"", "\n", "\" because there's no such C2 op, this may cause significant\"", "\n", "\" slowdown and the boundary pixels won't be as same as\"", "\n", "\" using F.interpolate due to padding.\"", "\n", ")", "\n", "assert", "height_scale", "==", "width_scale", "\n", "return", "BilinearInterpolation", "(", "input", ",", "up_scale", "=", "height_scale", ")", "\n", "", "", "logger", ".", "warning", "(", "\"Output size is not static, it might cause ONNX conversion issue\"", ")", "\n", "\n", "", "return", "interp", "(", "input", ",", "size", ",", "scale_factor", ",", "mode", ",", "align_corners", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.mock_torch_nn_functional_interpolate": [[115, 124], ["torch.onnx.is_in_onnx_export", "torch.onnx.is_in_onnx_export", "unittest.mock.patch"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.patch"], ["", "@", "contextlib", ".", "contextmanager", "\n", "def", "mock_torch_nn_functional_interpolate", "(", ")", ":", "\n", "    ", "if", "torch", ".", "onnx", ".", "is_in_onnx_export", "(", ")", ":", "\n", "        ", "with", "mock", ".", "patch", "(", "\n", "\"torch.nn.functional.interpolate\"", ",", "side_effect", "=", "onnx_compatibale_interpolate", "\n", ")", ":", "\n", "            ", "yield", "\n", "", "", "else", ":", "\n", "        ", "yield", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.fetch_any_blob": [[152, 162], ["caffe2.python.workspace.FetchBlob", "caffe2.python.workspace.FetchInt8Blob", "logger.error"], "function", ["None"], ["", "", "", "def", "fetch_any_blob", "(", "name", ")", ":", "\n", "    ", "bb", "=", "None", "\n", "try", ":", "\n", "        ", "bb", "=", "workspace", ".", "FetchBlob", "(", "name", ")", "\n", "", "except", "TypeError", ":", "\n", "        ", "bb", "=", "workspace", ".", "FetchInt8Blob", "(", "name", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "logger", ".", "error", "(", "\"Get blob {} error: {}\"", ".", "format", "(", "name", ",", "e", ")", ")", "\n", "\n", "", "return", "bb", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg": [[167, 172], ["None"], "function", ["None"], ["", "def", "get_pb_arg", "(", "pb", ",", "arg_name", ")", ":", "\n", "    ", "for", "x", "in", "pb", ".", "arg", ":", "\n", "        ", "if", "x", ".", "name", "==", "arg_name", ":", "\n", "            ", "return", "x", "\n", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_valf": [[174, 177], ["shared.get_pb_arg"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg"], ["", "def", "get_pb_arg_valf", "(", "pb", ",", "arg_name", ",", "default_val", ")", ":", "\n", "    ", "arg", "=", "get_pb_arg", "(", "pb", ",", "arg_name", ")", "\n", "return", "arg", ".", "f", "if", "arg", "is", "not", "None", "else", "default_val", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_floats": [[179, 182], ["shared.get_pb_arg", "list", "map"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg"], ["", "def", "get_pb_arg_floats", "(", "pb", ",", "arg_name", ",", "default_val", ")", ":", "\n", "    ", "arg", "=", "get_pb_arg", "(", "pb", ",", "arg_name", ")", "\n", "return", "list", "(", "map", "(", "float", ",", "arg", ".", "floats", ")", ")", "if", "arg", "is", "not", "None", "else", "default_val", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_ints": [[184, 187], ["shared.get_pb_arg", "list", "map"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg"], ["", "def", "get_pb_arg_ints", "(", "pb", ",", "arg_name", ",", "default_val", ")", ":", "\n", "    ", "arg", "=", "get_pb_arg", "(", "pb", ",", "arg_name", ")", "\n", "return", "list", "(", "map", "(", "int", ",", "arg", ".", "ints", ")", ")", "if", "arg", "is", "not", "None", "else", "default_val", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_vali": [[189, 192], ["shared.get_pb_arg"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg"], ["", "def", "get_pb_arg_vali", "(", "pb", ",", "arg_name", ",", "default_val", ")", ":", "\n", "    ", "arg", "=", "get_pb_arg", "(", "pb", ",", "arg_name", ")", "\n", "return", "arg", ".", "i", "if", "arg", "is", "not", "None", "else", "default_val", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_vals": [[194, 197], ["shared.get_pb_arg"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg"], ["", "def", "get_pb_arg_vals", "(", "pb", ",", "arg_name", ",", "default_val", ")", ":", "\n", "    ", "arg", "=", "get_pb_arg", "(", "pb", ",", "arg_name", ")", "\n", "return", "arg", ".", "s", "if", "arg", "is", "not", "None", "else", "default_val", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_valstrings": [[199, 202], ["shared.get_pb_arg", "list"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg"], ["", "def", "get_pb_arg_valstrings", "(", "pb", ",", "arg_name", ",", "default_val", ")", ":", "\n", "    ", "arg", "=", "get_pb_arg", "(", "pb", ",", "arg_name", ")", "\n", "return", "list", "(", "arg", ".", "strings", ")", "if", "arg", "is", "not", "None", "else", "default_val", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.check_set_pb_arg": [[204, 219], ["shared.get_pb_arg", "caffe2.MakeArgument", "hasattr", "pb.arg.extend", "logger.warning", "setattr", "getattr", "getattr", "getattr", "getattr"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg"], ["", "def", "check_set_pb_arg", "(", "pb", ",", "arg_name", ",", "arg_attr", ",", "arg_value", ",", "allow_override", "=", "False", ")", ":", "\n", "    ", "arg", "=", "get_pb_arg", "(", "pb", ",", "arg_name", ")", "\n", "if", "arg", "is", "None", ":", "\n", "        ", "arg", "=", "putils", ".", "MakeArgument", "(", "arg_name", ",", "arg_value", ")", "\n", "assert", "hasattr", "(", "arg", ",", "arg_attr", ")", "\n", "pb", ".", "arg", ".", "extend", "(", "[", "arg", "]", ")", "\n", "", "if", "allow_override", "and", "getattr", "(", "arg", ",", "arg_attr", ")", "!=", "arg_value", ":", "\n", "        ", "logger", ".", "warning", "(", "\n", "\"Override argument {}: {} -> {}\"", ".", "format", "(", "arg_name", ",", "getattr", "(", "arg", ",", "arg_attr", ")", ",", "arg_value", ")", "\n", ")", "\n", "setattr", "(", "arg", ",", "arg_attr", ",", "arg_value", ")", "\n", "", "else", ":", "\n", "        ", "assert", "arg", "is", "not", "None", "\n", "assert", "getattr", "(", "arg", ",", "arg_attr", ")", "==", "arg_value", ",", "\"Existing value {}, new value {}\"", ".", "format", "(", "\n", "getattr", "(", "arg", ",", "arg_attr", ")", ",", "arg_value", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared._create_const_fill_op_from_numpy": [[222, 241], ["caffe2.python.core.CreateOperator", "type", "numpy.dtype", "numpy.dtype", "numpy.dtype", "numpy.dtype", "numpy.dtype", "args_dict.update", "args_dict.update", "str"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update"], ["", "", "def", "_create_const_fill_op_from_numpy", "(", "name", ",", "tensor", ",", "device_option", "=", "None", ")", ":", "\n", "    ", "assert", "type", "(", "tensor", ")", "==", "np", ".", "ndarray", "\n", "kTypeNameMapper", "=", "{", "\n", "np", ".", "dtype", "(", "\"float32\"", ")", ":", "\"GivenTensorFill\"", ",", "\n", "np", ".", "dtype", "(", "\"int32\"", ")", ":", "\"GivenTensorIntFill\"", ",", "\n", "np", ".", "dtype", "(", "\"int64\"", ")", ":", "\"GivenTensorInt64Fill\"", ",", "\n", "np", ".", "dtype", "(", "\"uint8\"", ")", ":", "\"GivenTensorStringFill\"", ",", "\n", "}", "\n", "\n", "args_dict", "=", "{", "}", "\n", "if", "tensor", ".", "dtype", "==", "np", ".", "dtype", "(", "\"uint8\"", ")", ":", "\n", "        ", "args_dict", ".", "update", "(", "{", "\"values\"", ":", "[", "str", "(", "tensor", ".", "data", ")", "]", ",", "\"shape\"", ":", "[", "1", "]", "}", ")", "\n", "", "else", ":", "\n", "        ", "args_dict", ".", "update", "(", "{", "\"values\"", ":", "tensor", ",", "\"shape\"", ":", "tensor", ".", "shape", "}", ")", "\n", "\n", "", "if", "device_option", "is", "not", "None", ":", "\n", "        ", "args_dict", "[", "\"device_option\"", "]", "=", "device_option", "\n", "\n", "", "return", "core", ".", "CreateOperator", "(", "kTypeNameMapper", "[", "tensor", ".", "dtype", "]", ",", "[", "]", ",", "[", "name", "]", ",", "**", "args_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared._create_const_fill_op_from_c2_int8_tensor": [[243, 262], ["caffe2.python.core.CreateOperator", "type", "numpy.dtype", "numpy.dtype", "tensor.tobytes", "numpy.dtype", "numpy.dtype", "numpy.dtype"], "function", ["None"], ["", "def", "_create_const_fill_op_from_c2_int8_tensor", "(", "name", ",", "int8_tensor", ")", ":", "\n", "    ", "assert", "type", "(", "int8_tensor", ")", "==", "workspace", ".", "Int8Tensor", "\n", "kTypeNameMapper", "=", "{", "\n", "np", ".", "dtype", "(", "\"int32\"", ")", ":", "\"Int8GivenIntTensorFill\"", ",", "\n", "np", ".", "dtype", "(", "\"uint8\"", ")", ":", "\"Int8GivenTensorFill\"", ",", "\n", "}", "\n", "\n", "tensor", "=", "int8_tensor", ".", "data", "\n", "assert", "tensor", ".", "dtype", "in", "[", "np", ".", "dtype", "(", "\"uint8\"", ")", ",", "np", ".", "dtype", "(", "\"int32\"", ")", "]", "\n", "values", "=", "tensor", ".", "tobytes", "(", ")", "if", "tensor", ".", "dtype", "==", "np", ".", "dtype", "(", "\"uint8\"", ")", "else", "tensor", "\n", "\n", "return", "core", ".", "CreateOperator", "(", "\n", "kTypeNameMapper", "[", "tensor", ".", "dtype", "]", ",", "\n", "[", "]", ",", "\n", "[", "name", "]", ",", "\n", "values", "=", "values", ",", "\n", "shape", "=", "tensor", ".", "shape", ",", "\n", "Y_scale", "=", "int8_tensor", ".", "scale", ",", "\n", "Y_zero_point", "=", "int8_tensor", ".", "zero_point", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.create_const_fill_op": [[265, 288], ["type", "type", "shared._create_const_fill_op_from_numpy", "shared._create_const_fill_op_from_c2_int8_tensor"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared._create_const_fill_op_from_numpy", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared._create_const_fill_op_from_c2_int8_tensor"], ["", "def", "create_const_fill_op", "(", "\n", "name", ":", "str", ",", "\n", "blob", ":", "Union", "[", "np", ".", "ndarray", ",", "workspace", ".", "Int8Tensor", "]", ",", "\n", "device_option", ":", "Optional", "[", "caffe2_pb2", ".", "DeviceOption", "]", "=", "None", ",", "\n", ")", "->", "caffe2_pb2", ".", "OperatorDef", ":", "\n", "    ", "\"\"\"\n    Given a blob object, return the Caffe2 operator that creates this blob\n    as constant. Currently support NumPy tensor and Caffe2 Int8Tensor.\n    \"\"\"", "\n", "\n", "tensor_type", "=", "type", "(", "blob", ")", "\n", "assert", "tensor_type", "in", "[", "\n", "np", ".", "ndarray", ",", "\n", "workspace", ".", "Int8Tensor", ",", "\n", "]", ",", "'Error when creating const fill op for \"{}\", unsupported blob type: {}'", ".", "format", "(", "\n", "name", ",", "type", "(", "blob", ")", "\n", ")", "\n", "\n", "if", "tensor_type", "==", "np", ".", "ndarray", ":", "\n", "        ", "return", "_create_const_fill_op_from_numpy", "(", "name", ",", "blob", ",", "device_option", ")", "\n", "", "elif", "tensor_type", "==", "workspace", ".", "Int8Tensor", ":", "\n", "        ", "assert", "device_option", "is", "None", "\n", "return", "_create_const_fill_op_from_c2_int8_tensor", "(", "name", ",", "blob", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.construct_init_net_from_params": [[290, 312], ["caffe2.proto.caffe2_pb2.NetDef", "params.items", "isinstance", "caffe2_pb2.NetDef.op.extend", "caffe2_pb2.NetDef.external_output.append", "logger.warning", "shared.create_const_fill_op", "type", "device_options.get"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.create_const_fill_op", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "", "def", "construct_init_net_from_params", "(", "\n", "params", ":", "Dict", "[", "str", ",", "Any", "]", ",", "device_options", ":", "Optional", "[", "Dict", "[", "str", ",", "caffe2_pb2", ".", "DeviceOption", "]", "]", "=", "None", "\n", ")", "->", "caffe2_pb2", ".", "NetDef", ":", "\n", "    ", "\"\"\"\n    Construct the init_net from params dictionary\n    \"\"\"", "\n", "init_net", "=", "caffe2_pb2", ".", "NetDef", "(", ")", "\n", "device_options", "=", "device_options", "or", "{", "}", "\n", "for", "name", ",", "blob", "in", "params", ".", "items", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "blob", ",", "str", ")", ":", "\n", "            ", "logger", ".", "warning", "(", "\n", "(", "\n", "\"Blob {} with type {} is not supported in generating init net,\"", "\n", "\" skipped.\"", ".", "format", "(", "name", ",", "type", "(", "blob", ")", ")", "\n", ")", "\n", ")", "\n", "continue", "\n", "", "init_net", ".", "op", ".", "extend", "(", "\n", "[", "create_const_fill_op", "(", "name", ",", "blob", ",", "device_option", "=", "device_options", ".", "get", "(", "name", ",", "None", ")", ")", "]", "\n", ")", "\n", "init_net", ".", "external_output", ".", "append", "(", "name", ")", "\n", "", "return", "init_net", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_producer_map": [[314, 325], ["range", "len", "enumerate"], "function", ["None"], ["", "def", "get_producer_map", "(", "ssa", ")", ":", "\n", "    ", "\"\"\"\n    Return dict from versioned blob to (i, j),\n        where i is index of producer op, j is the index of output of that op.\n    \"\"\"", "\n", "producer_map", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "len", "(", "ssa", ")", ")", ":", "\n", "        ", "outputs", "=", "ssa", "[", "i", "]", "[", "1", "]", "\n", "for", "j", ",", "outp", "in", "enumerate", "(", "outputs", ")", ":", "\n", "            ", "producer_map", "[", "outp", "]", "=", "(", "i", ",", "j", ")", "\n", "", "", "return", "producer_map", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_consumer_map": [[327, 338], ["collections.defaultdict", "range", "len", "enumerate", "consumer_map[].append"], "function", ["None"], ["", "def", "get_consumer_map", "(", "ssa", ")", ":", "\n", "    ", "\"\"\"\n    Return dict from versioned blob to list of (i, j),\n        where i is index of consumer op, j is the index of input of that op.\n    \"\"\"", "\n", "consumer_map", "=", "collections", ".", "defaultdict", "(", "list", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "ssa", ")", ")", ":", "\n", "        ", "inputs", "=", "ssa", "[", "i", "]", "[", "0", "]", "\n", "for", "j", ",", "inp", "in", "enumerate", "(", "inputs", ")", ":", "\n", "            ", "consumer_map", "[", "inp", "]", ".", "append", "(", "(", "i", ",", "j", ")", ")", "\n", "", "", "return", "consumer_map", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_params_from_init_net": [[340, 367], ["caffe2.python.core.get_ssa", "shared.get_producer_map", "shared.ScopedWS", "ws.RunNetOnce", "shared.get_params_from_init_net._get_device_option"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_producer_map"], ["", "def", "get_params_from_init_net", "(", "\n", "init_net", ":", "caffe2_pb2", ".", "NetDef", ",", "\n", ")", "->", "[", "Dict", "[", "str", ",", "Any", "]", ",", "Dict", "[", "str", ",", "caffe2_pb2", ".", "DeviceOption", "]", "]", ":", "\n", "    ", "\"\"\"\n    Take the output blobs from init_net by running it.\n    Outputs:\n        params: dict from blob name to numpy array\n        device_options: dict from blob name to the device option of its creating op\n    \"\"\"", "\n", "# NOTE: this assumes that the params is determined by producer op with the", "\n", "# only exception be CopyGPUToCPU which is CUDA op but returns CPU tensor.", "\n", "def", "_get_device_option", "(", "producer_op", ")", ":", "\n", "        ", "if", "producer_op", ".", "type", "==", "\"CopyGPUToCPU\"", ":", "\n", "            ", "return", "caffe2_pb2", ".", "DeviceOption", "(", ")", "\n", "", "else", ":", "\n", "            ", "return", "producer_op", ".", "device_option", "\n", "\n", "", "", "with", "ScopedWS", "(", "\"__get_params_from_init_net__\"", ",", "is_reset", "=", "True", ",", "is_cleanup", "=", "True", ")", "as", "ws", ":", "\n", "        ", "ws", ".", "RunNetOnce", "(", "init_net", ")", "\n", "params", "=", "{", "b", ":", "fetch_any_blob", "(", "b", ")", "for", "b", "in", "init_net", ".", "external_output", "}", "\n", "", "ssa", ",", "versions", "=", "core", ".", "get_ssa", "(", "init_net", ")", "\n", "producer_map", "=", "get_producer_map", "(", "ssa", ")", "\n", "device_options", "=", "{", "\n", "b", ":", "_get_device_option", "(", "init_net", ".", "op", "[", "producer_map", "[", "(", "b", ",", "versions", "[", "b", "]", ")", "]", "[", "0", "]", "]", ")", "\n", "for", "b", "in", "init_net", ".", "external_output", "\n", "}", "\n", "return", "params", ",", "device_options", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared._updater_raise": [[369, 373], ["RuntimeError"], "function", ["None"], ["", "def", "_updater_raise", "(", "op", ",", "input_types", ",", "output_types", ")", ":", "\n", "    ", "raise", "RuntimeError", "(", "\n", "\"Failed to apply updater for op {} given input_types {} and\"", "\n", "\" output_types {}\"", ".", "format", "(", "op", ",", "input_types", ",", "output_types", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared._generic_status_identifier": [[376, 446], ["caffe2.python.core.get_ssa", "set().union", "set().union.union().union", "all", "all", "copy.deepcopy", "zip", "zip", "status_updater", "zip", "shared._generic_status_identifier._update_i"], "function", ["None"], ["", "def", "_generic_status_identifier", "(", "\n", "predict_net", ":", "caffe2_pb2", ".", "NetDef", ",", "\n", "status_updater", ":", "Callable", ",", "\n", "known_status", ":", "Dict", "[", "Tuple", "[", "str", ",", "int", "]", ",", "Any", "]", ",", "\n", ")", "->", "Dict", "[", "Tuple", "[", "str", ",", "int", "]", ",", "Any", "]", ":", "\n", "    ", "\"\"\"\n    Statically infer the status of each blob, the status can be such as device type\n        (CPU/GPU), layout (NCHW/NHWC), data type (float32/int8), etc. \"Blob\" here\n        is versioned blob (Tuple[str, int]) in the format compatible with ssa.\n    Inputs:\n        predict_net: the caffe2 network\n        status_updater: a callable, given an op and the status of its input/output,\n            it returns the updated status of input/output. `None` is used for\n            representing unknown status.\n        known_status: a dict containing known status, used as initialization.\n    Outputs:\n        A dict mapping from versioned blob to its status\n    \"\"\"", "\n", "ssa", ",", "versions", "=", "core", ".", "get_ssa", "(", "predict_net", ")", "\n", "versioned_ext_input", "=", "[", "(", "b", ",", "0", ")", "for", "b", "in", "predict_net", ".", "external_input", "]", "\n", "versioned_ext_output", "=", "[", "(", "b", ",", "versions", "[", "b", "]", ")", "for", "b", "in", "predict_net", ".", "external_output", "]", "\n", "all_versioned_blobs", "=", "set", "(", ")", ".", "union", "(", "*", "[", "set", "(", "x", "[", "0", "]", "+", "x", "[", "1", "]", ")", "for", "x", "in", "ssa", "]", ")", "\n", "\n", "allowed_vbs", "=", "all_versioned_blobs", ".", "union", "(", "versioned_ext_input", ")", ".", "union", "(", "versioned_ext_output", ")", "\n", "assert", "all", "(", "k", "in", "allowed_vbs", "for", "k", "in", "known_status", ")", "\n", "assert", "all", "(", "v", "is", "not", "None", "for", "v", "in", "known_status", ".", "values", "(", ")", ")", "\n", "_known_status", "=", "copy", ".", "deepcopy", "(", "known_status", ")", "\n", "\n", "def", "_check_and_update", "(", "key", ",", "value", ")", ":", "\n", "        ", "assert", "value", "is", "not", "None", "\n", "if", "key", "in", "_known_status", ":", "\n", "            ", "if", "not", "_known_status", "[", "key", "]", "==", "value", ":", "\n", "                ", "raise", "RuntimeError", "(", "\n", "\"Confilict status for {}, existing status {}, new status {}\"", ".", "format", "(", "\n", "key", ",", "_known_status", "[", "key", "]", ",", "value", "\n", ")", "\n", ")", "\n", "", "", "_known_status", "[", "key", "]", "=", "value", "\n", "\n", "", "def", "_update_i", "(", "op", ",", "ssa_i", ")", ":", "\n", "        ", "versioned_inputs", "=", "ssa_i", "[", "0", "]", "\n", "versioned_outputs", "=", "ssa_i", "[", "1", "]", "\n", "\n", "inputs_status", "=", "[", "_known_status", ".", "get", "(", "b", ",", "None", ")", "for", "b", "in", "versioned_inputs", "]", "\n", "outputs_status", "=", "[", "_known_status", ".", "get", "(", "b", ",", "None", ")", "for", "b", "in", "versioned_outputs", "]", "\n", "\n", "new_inputs_status", ",", "new_outputs_status", "=", "status_updater", "(", "op", ",", "inputs_status", ",", "outputs_status", ")", "\n", "\n", "for", "versioned_blob", ",", "status", "in", "zip", "(", "\n", "versioned_inputs", "+", "versioned_outputs", ",", "new_inputs_status", "+", "new_outputs_status", "\n", ")", ":", "\n", "            ", "if", "status", "is", "not", "None", ":", "\n", "                ", "_check_and_update", "(", "versioned_blob", ",", "status", ")", "\n", "\n", "", "", "", "for", "op", ",", "ssa_i", "in", "zip", "(", "predict_net", ".", "op", ",", "ssa", ")", ":", "\n", "        ", "_update_i", "(", "op", ",", "ssa_i", ")", "\n", "", "for", "op", ",", "ssa_i", "in", "zip", "(", "reversed", "(", "predict_net", ".", "op", ")", ",", "reversed", "(", "ssa", ")", ")", ":", "\n", "        ", "_update_i", "(", "op", ",", "ssa_i", ")", "\n", "\n", "# NOTE: This strictly checks all the blob from predict_net must be assgined", "\n", "# a known status. However sometimes it's impossible (eg. having deadend op),", "\n", "# we may relax this constraint if", "\n", "", "for", "k", "in", "all_versioned_blobs", ":", "\n", "        ", "if", "k", "not", "in", "_known_status", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"Can not infer the status for {}. Currently only support the case where\"", "\n", "\" a single forward and backward pass can identify status for all blobs.\"", ".", "format", "(", "k", ")", "\n", ")", "\n", "\n", "", "", "return", "_known_status", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.infer_device_type": [[448, 486], ["shared._generic_status_identifier", "shared._updater_raise", "shared._updater_raise", "len", "all", "shared._updater_raise"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared._generic_status_identifier", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared._updater_raise", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared._updater_raise", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared._updater_raise"], ["", "def", "infer_device_type", "(", "\n", "predict_net", ":", "caffe2_pb2", ".", "NetDef", ",", "\n", "known_status", ":", "Dict", "[", "Tuple", "[", "str", ",", "int", "]", ",", "Any", "]", ",", "\n", "device_name_style", ":", "str", "=", "\"caffe2\"", ",", "\n", ")", "->", "Dict", "[", "Tuple", "[", "str", ",", "int", "]", ",", "str", "]", ":", "\n", "    ", "\"\"\" Return the device type (\"cpu\" or \"gpu\"/\"cuda\") of each (versioned) blob \"\"\"", "\n", "\n", "assert", "device_name_style", "in", "[", "\"caffe2\"", ",", "\"pytorch\"", "]", "\n", "_CPU_STR", "=", "\"cpu\"", "\n", "_GPU_STR", "=", "\"gpu\"", "if", "device_name_style", "==", "\"caffe2\"", "else", "\"cuda\"", "\n", "\n", "def", "_copy_cpu_to_gpu_updater", "(", "op", ",", "input_types", ",", "output_types", ")", ":", "\n", "        ", "if", "input_types", "[", "0", "]", "==", "_GPU_STR", "or", "output_types", "[", "0", "]", "==", "_CPU_STR", ":", "\n", "            ", "_updater_raise", "(", "op", ",", "input_types", ",", "output_types", ")", "\n", "", "return", "(", "[", "_CPU_STR", "]", ",", "[", "_GPU_STR", "]", ")", "\n", "\n", "", "def", "_copy_gpu_to_cpu_updater", "(", "op", ",", "input_types", ",", "output_types", ")", ":", "\n", "        ", "if", "input_types", "[", "0", "]", "==", "_CPU_STR", "or", "output_types", "[", "0", "]", "==", "_GPU_STR", ":", "\n", "            ", "_updater_raise", "(", "op", ",", "input_types", ",", "output_types", ")", "\n", "", "return", "(", "[", "_GPU_STR", "]", ",", "[", "_CPU_STR", "]", ")", "\n", "\n", "", "def", "_other_ops_updater", "(", "op", ",", "input_types", ",", "output_types", ")", ":", "\n", "        ", "non_none_types", "=", "[", "x", "for", "x", "in", "input_types", "+", "output_types", "if", "x", "is", "not", "None", "]", "\n", "if", "len", "(", "non_none_types", ")", ">", "0", ":", "\n", "            ", "the_type", "=", "non_none_types", "[", "0", "]", "\n", "if", "not", "all", "(", "x", "==", "the_type", "for", "x", "in", "non_none_types", ")", ":", "\n", "                ", "_updater_raise", "(", "op", ",", "input_types", ",", "output_types", ")", "\n", "", "", "else", ":", "\n", "            ", "the_type", "=", "None", "\n", "", "return", "(", "[", "the_type", "for", "_", "in", "op", ".", "input", "]", ",", "[", "the_type", "for", "_", "in", "op", ".", "output", "]", ")", "\n", "\n", "", "def", "_device_updater", "(", "op", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "{", "\n", "\"CopyCPUToGPU\"", ":", "_copy_cpu_to_gpu_updater", ",", "\n", "\"CopyGPUToCPU\"", ":", "_copy_gpu_to_cpu_updater", ",", "\n", "}", ".", "get", "(", "op", ".", "type", ",", "_other_ops_updater", ")", "(", "op", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "return", "_generic_status_identifier", "(", "predict_net", ",", "_device_updater", ",", "known_status", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared._modify_blob_names": [[491, 505], ["blob_list.extend", "copy.deepcopy", "shared._modify_blob_names._replace_list"], "function", ["None"], ["", "def", "_modify_blob_names", "(", "ops", ",", "blob_rename_f", ")", ":", "\n", "    ", "ret", "=", "[", "]", "\n", "\n", "def", "_replace_list", "(", "blob_list", ",", "replaced_list", ")", ":", "\n", "        ", "del", "blob_list", "[", ":", "]", "\n", "blob_list", ".", "extend", "(", "replaced_list", ")", "\n", "\n", "", "for", "x", "in", "ops", ":", "\n", "        ", "cur", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "_replace_list", "(", "cur", ".", "input", ",", "list", "(", "map", "(", "blob_rename_f", ",", "cur", ".", "input", ")", ")", ")", "\n", "_replace_list", "(", "cur", ".", "output", ",", "list", "(", "map", "(", "blob_rename_f", ",", "cur", ".", "output", ")", ")", ")", "\n", "ret", ".", "append", "(", "cur", ")", "\n", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared._rename_blob": [[507, 520], ["shared._rename_blob._list_to_str"], "function", ["None"], ["", "def", "_rename_blob", "(", "name", ",", "blob_sizes", ",", "blob_ranges", ")", ":", "\n", "    ", "def", "_list_to_str", "(", "bsize", ")", ":", "\n", "        ", "ret", "=", "\", \"", ".", "join", "(", "[", "str", "(", "x", ")", "for", "x", "in", "bsize", "]", ")", "\n", "ret", "=", "\"[\"", "+", "ret", "+", "\"]\"", "\n", "return", "ret", "\n", "\n", "", "ret", "=", "name", "\n", "if", "blob_sizes", "is", "not", "None", "and", "name", "in", "blob_sizes", ":", "\n", "        ", "ret", "+=", "\"\\n\"", "+", "_list_to_str", "(", "blob_sizes", "[", "name", "]", ")", "\n", "", "if", "blob_ranges", "is", "not", "None", "and", "name", "in", "blob_ranges", ":", "\n", "        ", "ret", "+=", "\"\\n\"", "+", "_list_to_str", "(", "blob_ranges", "[", "name", "]", ")", "\n", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.save_graph": [[523, 526], ["functools.partial", "shared.save_graph_base"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.save_graph_base"], ["", "def", "save_graph", "(", "net", ",", "file_name", ",", "graph_name", "=", "\"net\"", ",", "op_only", "=", "True", ",", "blob_sizes", "=", "None", ",", "blob_ranges", "=", "None", ")", ":", "\n", "    ", "blob_rename_f", "=", "functools", ".", "partial", "(", "_rename_blob", ",", "blob_sizes", "=", "blob_sizes", ",", "blob_ranges", "=", "blob_ranges", ")", "\n", "return", "save_graph_base", "(", "net", ",", "file_name", ",", "graph_name", ",", "op_only", ",", "blob_rename_f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.save_graph_base": [[528, 558], ["shared._modify_blob_names", "caffe2.python.net_drawer.GetPydotGraph", "caffe2.python.net_drawer.GetPydotGraphMinimal", "os.path.dirname", "os.path.exists", "os.makedirs", "os.path.splitext", "net_drawer.GetPydotGraphMinimal.write_png", "print", "os.path.basename", "net_drawer.GetPydotGraphMinimal.write_pdf", "net_drawer.GetPydotGraphMinimal.write_svg", "print"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared._modify_blob_names"], ["", "def", "save_graph_base", "(", "net", ",", "file_name", ",", "graph_name", "=", "\"net\"", ",", "op_only", "=", "True", ",", "blob_rename_func", "=", "None", ")", ":", "\n", "    ", "graph", "=", "None", "\n", "ops", "=", "net", ".", "op", "\n", "if", "blob_rename_func", "is", "not", "None", ":", "\n", "        ", "ops", "=", "_modify_blob_names", "(", "ops", ",", "blob_rename_func", ")", "\n", "", "if", "not", "op_only", ":", "\n", "        ", "graph", "=", "net_drawer", ".", "GetPydotGraph", "(", "ops", ",", "graph_name", ",", "rankdir", "=", "\"TB\"", ")", "\n", "", "else", ":", "\n", "        ", "graph", "=", "net_drawer", ".", "GetPydotGraphMinimal", "(", "\n", "ops", ",", "graph_name", ",", "rankdir", "=", "\"TB\"", ",", "minimal_dependency", "=", "True", "\n", ")", "\n", "\n", "", "try", ":", "\n", "        ", "par_dir", "=", "os", ".", "path", ".", "dirname", "(", "file_name", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "par_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "par_dir", ")", "\n", "\n", "", "format", "=", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "basename", "(", "file_name", ")", ")", "[", "-", "1", "]", "\n", "if", "format", "==", "\".png\"", ":", "\n", "            ", "graph", ".", "write_png", "(", "file_name", ")", "\n", "", "elif", "format", "==", "\".pdf\"", ":", "\n", "            ", "graph", ".", "write_pdf", "(", "file_name", ")", "\n", "", "elif", "format", "==", "\".svg\"", ":", "\n", "            ", "graph", ".", "write_svg", "(", "file_name", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"Incorrect format {}\"", ".", "format", "(", "format", ")", ")", "\n", "", "", "except", "Exception", "as", "e", ":", "\n", "        ", "print", "(", "\"Error when writing graph to image {}\"", ".", "format", "(", "e", ")", ")", "\n", "\n", "", "return", "graph", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.group_norm_replace_aten_with_caffe2": [[563, 587], ["logger.info", "shared.get_pb_arg_vals", "op.arg.remove", "shared.get_pb_arg_vali", "shared.get_pb_arg_vali", "get_pb_arg_vals.decode", "shared.get_pb_arg", "op.arg.remove", "op.arg.remove", "shared.check_set_pb_arg", "shared.get_pb_arg", "shared.get_pb_arg"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_vals", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.remove", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_vali", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_vali", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.remove", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.remove", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg"], ["", "def", "group_norm_replace_aten_with_caffe2", "(", "predict_net", ":", "caffe2_pb2", ".", "NetDef", ")", ":", "\n", "    ", "\"\"\"\n    For ONNX exported model, GroupNorm will be represented as ATen op,\n        this can be a drop in replacement from ATen to GroupNorm\n    \"\"\"", "\n", "count", "=", "0", "\n", "for", "op", "in", "predict_net", ".", "op", ":", "\n", "        ", "if", "op", ".", "type", "==", "\"ATen\"", ":", "\n", "            ", "op_name", "=", "get_pb_arg_vals", "(", "op", ",", "\"operator\"", ",", "None", ")", "# return byte in py3", "\n", "if", "op_name", "and", "op_name", ".", "decode", "(", ")", "==", "\"group_norm\"", ":", "\n", "                ", "op", ".", "arg", ".", "remove", "(", "get_pb_arg", "(", "op", ",", "\"operator\"", ")", ")", "\n", "\n", "if", "get_pb_arg_vali", "(", "op", ",", "\"cudnn_enabled\"", ",", "None", ")", ":", "\n", "                    ", "op", ".", "arg", ".", "remove", "(", "get_pb_arg", "(", "op", ",", "\"cudnn_enabled\"", ")", ")", "\n", "\n", "", "num_groups", "=", "get_pb_arg_vali", "(", "op", ",", "\"num_groups\"", ",", "None", ")", "\n", "if", "num_groups", "is", "not", "None", ":", "\n", "                    ", "op", ".", "arg", ".", "remove", "(", "get_pb_arg", "(", "op", ",", "\"num_groups\"", ")", ")", "\n", "check_set_pb_arg", "(", "op", ",", "\"group\"", ",", "\"i\"", ",", "num_groups", ")", "\n", "\n", "", "op", ".", "type", "=", "\"GroupNorm\"", "\n", "count", "+=", "1", "\n", "", "", "", "if", "count", ">", "1", ":", "\n", "        ", "logger", ".", "info", "(", "\"Replaced {} ATen operator to GroupNormOp\"", ".", "format", "(", "count", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.alias": [[592, 597], ["isinstance", "torch.ops._caffe2.AliasWithName", "torch.ops._caffe2.AliasWithName", "torch.onnx.is_in_onnx_export", "torch.onnx.is_in_onnx_export"], "function", ["None"], ["", "", "def", "alias", "(", "x", ",", "name", ",", "is_backward", "=", "False", ")", ":", "\n", "    ", "if", "not", "torch", ".", "onnx", ".", "is_in_onnx_export", "(", ")", ":", "\n", "        ", "return", "x", "\n", "", "assert", "isinstance", "(", "x", ",", "torch", ".", "Tensor", ")", "\n", "return", "torch", ".", "ops", ".", "_caffe2", ".", "AliasWithName", "(", "x", ",", "name", ",", "is_backward", "=", "is_backward", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.fuse_alias_placeholder": [[599, 622], ["enumerate", "predict_net.op.extend", "get_pb_arg_vals().decode", "bool", "shared.rename_op_input", "shared.rename_op_output", "new_ops.append", "len", "len", "shared.get_pb_arg_vali", "op.arg[].s.decode", "shared.get_pb_arg_vals"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.rename_op_input", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.rename_op_output", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_vali", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_vals"], ["", "def", "fuse_alias_placeholder", "(", "predict_net", ",", "init_net", ")", ":", "\n", "    ", "\"\"\" Remove AliasWithName placeholder and rename the input/output of it \"\"\"", "\n", "# First we finish all the re-naming", "\n", "for", "i", ",", "op", "in", "enumerate", "(", "predict_net", ".", "op", ")", ":", "\n", "        ", "if", "op", ".", "type", "==", "\"AliasWithName\"", ":", "\n", "            ", "assert", "len", "(", "op", ".", "input", ")", "==", "1", "\n", "assert", "len", "(", "op", ".", "output", ")", "==", "1", "\n", "name", "=", "get_pb_arg_vals", "(", "op", ",", "\"name\"", ",", "None", ")", ".", "decode", "(", ")", "\n", "is_backward", "=", "bool", "(", "get_pb_arg_vali", "(", "op", ",", "\"is_backward\"", ",", "0", ")", ")", "\n", "rename_op_input", "(", "predict_net", ",", "init_net", ",", "i", ",", "0", ",", "name", ",", "from_producer", "=", "is_backward", ")", "\n", "rename_op_output", "(", "predict_net", ",", "i", ",", "0", ",", "name", ")", "\n", "\n", "# Remove AliasWithName, should be very safe since it's a non-op", "\n", "", "", "new_ops", "=", "[", "]", "\n", "for", "op", "in", "predict_net", ".", "op", ":", "\n", "        ", "if", "op", ".", "type", "!=", "\"AliasWithName\"", ":", "\n", "            ", "new_ops", ".", "append", "(", "op", ")", "\n", "", "else", ":", "\n", "# safety check", "\n", "            ", "assert", "op", ".", "input", "==", "op", ".", "output", "\n", "assert", "op", ".", "input", "[", "0", "]", "==", "op", ".", "arg", "[", "0", "]", ".", "s", ".", "decode", "(", ")", "\n", "", "", "del", "predict_net", ".", "op", "[", ":", "]", "\n", "predict_net", ".", "op", ".", "extend", "(", "new_ops", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared._rename_versioned_blob_in_proto": [[631, 660], ["zip", "range", "range", "start_versions.get", "range", "end_versions.get", "range", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "def", "_rename_versioned_blob_in_proto", "(", "\n", "proto", ":", "caffe2_pb2", ".", "NetDef", ",", "\n", "old_name", ":", "str", ",", "\n", "new_name", ":", "str", ",", "\n", "version", ":", "int", ",", "\n", "ssa", ":", "List", "[", "Tuple", "[", "List", "[", "Tuple", "[", "str", ",", "int", "]", "]", ",", "List", "[", "Tuple", "[", "str", ",", "int", "]", "]", "]", "]", ",", "\n", "start_versions", ":", "Dict", "[", "str", ",", "int", "]", ",", "\n", "end_versions", ":", "Dict", "[", "str", ",", "int", "]", ",", "\n", ")", ":", "\n", "    ", "\"\"\" In given proto, rename all blobs with matched version \"\"\"", "\n", "# Operater list", "\n", "for", "op", ",", "i_th_ssa", "in", "zip", "(", "proto", ".", "op", ",", "ssa", ")", ":", "\n", "        ", "versioned_inputs", ",", "versioned_outputs", "=", "i_th_ssa", "\n", "for", "i", "in", "range", "(", "len", "(", "op", ".", "input", ")", ")", ":", "\n", "            ", "if", "versioned_inputs", "[", "i", "]", "==", "(", "old_name", ",", "version", ")", ":", "\n", "                ", "op", ".", "input", "[", "i", "]", "=", "new_name", "\n", "", "", "for", "i", "in", "range", "(", "len", "(", "op", ".", "output", ")", ")", ":", "\n", "            ", "if", "versioned_outputs", "[", "i", "]", "==", "(", "old_name", ",", "version", ")", ":", "\n", "                ", "op", ".", "output", "[", "i", "]", "=", "new_name", "\n", "# external_input", "\n", "", "", "", "if", "start_versions", ".", "get", "(", "old_name", ",", "0", ")", "==", "version", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "proto", ".", "external_input", ")", ")", ":", "\n", "            ", "if", "proto", ".", "external_input", "[", "i", "]", "==", "old_name", ":", "\n", "                ", "proto", ".", "external_input", "[", "i", "]", "=", "new_name", "\n", "# external_output", "\n", "", "", "", "if", "end_versions", ".", "get", "(", "old_name", ",", "0", ")", "==", "version", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "proto", ".", "external_output", ")", ")", ":", "\n", "            ", "if", "proto", ".", "external_output", "[", "i", "]", "==", "old_name", ":", "\n", "                ", "proto", ".", "external_output", "[", "i", "]", "=", "new_name", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.rename_op_input": [[662, 726], ["isinstance", "isinstance", "caffe2.python.core.get_ssa", "caffe2.python.core.get_ssa", "shared._rename_versioned_blob_in_proto", "shared._rename_versioned_blob_in_proto", "copy.deepcopy", "shared.get_producer_map", "shared.rename_op_output", "shared.rename_op_input.contain_targets"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared._rename_versioned_blob_in_proto", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared._rename_versioned_blob_in_proto", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_producer_map", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.rename_op_output"], ["", "", "", "", "def", "rename_op_input", "(", "\n", "predict_net", ":", "caffe2_pb2", ".", "NetDef", ",", "\n", "init_net", ":", "caffe2_pb2", ".", "NetDef", ",", "\n", "op_id", ":", "int", ",", "\n", "input_id", ":", "int", ",", "\n", "new_name", ":", "str", ",", "\n", "from_producer", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Rename the op_id-th operator in predict_net, change it's input_id-th input's\n        name to the new_name. It also does automatic re-route and change\n        external_input and init_net if necessary.\n    - It requires the input is only consumed by this op.\n    - This function modifies predict_net and init_net in-place.\n    - When from_producer is enable, this also updates other operators that consumes\n        the same input. Be cautious because may trigger unintended behavior.\n    \"\"\"", "\n", "assert", "isinstance", "(", "predict_net", ",", "caffe2_pb2", ".", "NetDef", ")", "\n", "assert", "isinstance", "(", "init_net", ",", "caffe2_pb2", ".", "NetDef", ")", "\n", "\n", "init_net_ssa", ",", "init_net_versions", "=", "core", ".", "get_ssa", "(", "init_net", ")", "\n", "predict_net_ssa", ",", "predict_net_versions", "=", "core", ".", "get_ssa", "(", "\n", "predict_net", ",", "copy", ".", "deepcopy", "(", "init_net_versions", ")", "\n", ")", "\n", "\n", "versioned_inputs", ",", "versioned_outputs", "=", "predict_net_ssa", "[", "op_id", "]", "\n", "old_name", ",", "version", "=", "versioned_inputs", "[", "input_id", "]", "\n", "\n", "if", "from_producer", ":", "\n", "        ", "producer_map", "=", "get_producer_map", "(", "predict_net_ssa", ")", "\n", "if", "not", "(", "old_name", ",", "version", ")", "in", "producer_map", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"Can't find producer, the input {} is probably from\"", "\n", "\" init_net, this is not supported yet.\"", ".", "format", "(", "old_name", ")", "\n", ")", "\n", "", "producer", "=", "producer_map", "[", "(", "old_name", ",", "version", ")", "]", "\n", "rename_op_output", "(", "predict_net", ",", "producer", "[", "0", "]", ",", "producer", "[", "1", "]", ",", "new_name", ")", "\n", "return", "\n", "\n", "", "def", "contain_targets", "(", "op_ssa", ")", ":", "\n", "        ", "return", "(", "old_name", ",", "version", ")", "in", "op_ssa", "[", "0", "]", "\n", "\n", "", "is_consumer", "=", "[", "contain_targets", "(", "op_ssa", ")", "for", "op_ssa", "in", "predict_net_ssa", "]", "\n", "if", "sum", "(", "is_consumer", ")", ">", "1", ":", "\n", "        ", "raise", "IllegalGraphTransformError", "(", "\n", "(", "\n", "\"Input '{}' of operator(#{}) are consumed by other ops, please use\"", "\n", "+", "\" rename_op_output on the producer instead. Offending op: \\n{}\"", "\n", ")", ".", "format", "(", "old_name", ",", "op_id", ",", "predict_net", ".", "op", "[", "op_id", "]", ")", "\n", ")", "\n", "\n", "# update init_net", "\n", "", "_rename_versioned_blob_in_proto", "(", "\n", "init_net", ",", "old_name", ",", "new_name", ",", "version", ",", "init_net_ssa", ",", "{", "}", ",", "init_net_versions", "\n", ")", "\n", "# update predict_net", "\n", "_rename_versioned_blob_in_proto", "(", "\n", "predict_net", ",", "\n", "old_name", ",", "\n", "new_name", ",", "\n", "version", ",", "\n", "predict_net_ssa", ",", "\n", "init_net_versions", ",", "\n", "predict_net_versions", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.rename_op_output": [[729, 747], ["isinstance", "caffe2.python.core.get_ssa", "shared._rename_versioned_blob_in_proto"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared._rename_versioned_blob_in_proto"], ["", "def", "rename_op_output", "(", "predict_net", ":", "caffe2_pb2", ".", "NetDef", ",", "op_id", ":", "int", ",", "output_id", ":", "int", ",", "new_name", ":", "str", ")", ":", "\n", "    ", "\"\"\"\n    Rename the op_id-th operator in predict_net, change it's output_id-th input's\n        name to the new_name. It also does automatic re-route and change\n        external_output and if necessary.\n    - It allows multiple consumers of its output.\n    - This function modifies predict_net in-place, doesn't need init_net.\n    \"\"\"", "\n", "assert", "isinstance", "(", "predict_net", ",", "caffe2_pb2", ".", "NetDef", ")", "\n", "\n", "ssa", ",", "blob_versions", "=", "core", ".", "get_ssa", "(", "predict_net", ")", "\n", "\n", "versioned_inputs", ",", "versioned_outputs", "=", "ssa", "[", "op_id", "]", "\n", "old_name", ",", "version", "=", "versioned_outputs", "[", "output_id", "]", "\n", "\n", "# update predict_net", "\n", "_rename_versioned_blob_in_proto", "(", "\n", "predict_net", ",", "old_name", ",", "new_name", ",", "version", ",", "ssa", ",", "{", "}", ",", "blob_versions", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_sub_graph_external_input_output": [[750, 780], ["caffe2.python.core.get_ssa", "sum", "list", "range", "set", "len"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["", "def", "get_sub_graph_external_input_output", "(", "\n", "predict_net", ":", "caffe2_pb2", ".", "NetDef", ",", "sub_graph_op_indices", ":", "List", "[", "int", "]", "\n", ")", "->", "Tuple", "[", "List", "[", "Tuple", "[", "str", ",", "int", "]", "]", ",", "List", "[", "Tuple", "[", "str", ",", "int", "]", "]", "]", ":", "\n", "    ", "\"\"\"\n    Return the list of external input/output of sub-graph,\n    each element is tuple of the name and corresponding version in predict_net.\n\n    external input/output is defined the same way as caffe2 NetDef.\n    \"\"\"", "\n", "ssa", ",", "versions", "=", "core", ".", "get_ssa", "(", "predict_net", ")", "\n", "\n", "all_inputs", "=", "[", "]", "\n", "all_outputs", "=", "[", "]", "\n", "for", "op_id", "in", "sub_graph_op_indices", ":", "\n", "        ", "all_inputs", "+=", "[", "inp", "for", "inp", "in", "ssa", "[", "op_id", "]", "[", "0", "]", "if", "inp", "not", "in", "all_inputs", "]", "\n", "all_outputs", "+=", "list", "(", "ssa", "[", "op_id", "]", "[", "1", "]", ")", "# ssa output won't repeat", "\n", "\n", "# for versioned blobs, external inputs are just those blob in all_inputs", "\n", "# but not in all_outputs", "\n", "", "ext_inputs", "=", "[", "inp", "for", "inp", "in", "all_inputs", "if", "inp", "not", "in", "all_outputs", "]", "\n", "\n", "# external outputs are essentially outputs of this subgraph that are used", "\n", "# outside of this sub-graph (including predict_net.external_output)", "\n", "all_other_inputs", "=", "sum", "(", "\n", "(", "ssa", "[", "i", "]", "[", "0", "]", "for", "i", "in", "range", "(", "len", "(", "ssa", ")", ")", "if", "i", "not", "in", "sub_graph_op_indices", ")", ",", "\n", "[", "(", "outp", ",", "versions", "[", "outp", "]", ")", "for", "outp", "in", "predict_net", ".", "external_output", "]", ",", "\n", ")", "\n", "ext_outputs", "=", "[", "outp", "for", "outp", "in", "all_outputs", "if", "outp", "in", "set", "(", "all_other_inputs", ")", "]", "\n", "\n", "return", "ext_inputs", ",", "ext_outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared._get_dependency_chain": [[825, 853], ["shared.get_consumer_map", "shared.get_producer_map", "shared.DiGraph.from_ssa", "DiGraph.from_ssa.get_all_paths", "sorted", "min", "len", "logger.warning", "set().union", "set", "set"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_consumer_map", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_producer_map", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.DiGraph.from_ssa", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.DiGraph.get_all_paths", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["", "", "def", "_get_dependency_chain", "(", "ssa", ",", "versioned_target", ",", "versioned_source", ")", ":", "\n", "    ", "\"\"\"\n    Return the index list of relevant operator to produce target blob from source blob,\n        if there's no dependency, return empty list.\n    \"\"\"", "\n", "\n", "# finding all paths between nodes can be O(N!), thus we can only search", "\n", "# in the subgraph using the op starting from the first consumer of source blob", "\n", "# to the producer of the target blob.", "\n", "consumer_map", "=", "get_consumer_map", "(", "ssa", ")", "\n", "producer_map", "=", "get_producer_map", "(", "ssa", ")", "\n", "start_op", "=", "min", "(", "x", "[", "0", "]", "for", "x", "in", "consumer_map", "[", "versioned_source", "]", ")", "-", "15", "\n", "end_op", "=", "(", "\n", "producer_map", "[", "versioned_target", "]", "[", "0", "]", "+", "15", "if", "versioned_target", "in", "producer_map", "else", "start_op", "\n", ")", "\n", "sub_graph_ssa", "=", "ssa", "[", "start_op", ":", "end_op", "+", "1", "]", "\n", "if", "len", "(", "sub_graph_ssa", ")", ">", "30", ":", "\n", "        ", "logger", ".", "warning", "(", "\n", "\"Subgraph bebetween {} and {} is large (from op#{} to op#{}), it\"", "\n", "\" might take non-trival time to find all paths between them.\"", ".", "format", "(", "\n", "versioned_source", ",", "versioned_target", ",", "start_op", ",", "end_op", "\n", ")", "\n", ")", "\n", "\n", "", "dag", "=", "DiGraph", ".", "from_ssa", "(", "sub_graph_ssa", ")", "\n", "paths", "=", "dag", ".", "get_all_paths", "(", "versioned_source", ",", "versioned_target", ")", "# include two ends", "\n", "ops_in_paths", "=", "[", "[", "producer_map", "[", "blob", "]", "[", "0", "]", "for", "blob", "in", "path", "[", "1", ":", "]", "]", "for", "path", "in", "paths", "]", "\n", "return", "sorted", "(", "set", "(", ")", ".", "union", "(", "*", "[", "set", "(", "ops", ")", "for", "ops", "in", "ops_in_paths", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.identify_reshape_sub_graph": [[855, 880], ["caffe2.python.core.get_ssa", "enumerate", "shared._get_dependency_chain", "ret.append", "len"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared._get_dependency_chain"], ["", "def", "identify_reshape_sub_graph", "(", "predict_net", ":", "caffe2_pb2", ".", "NetDef", ")", "->", "List", "[", "List", "[", "int", "]", "]", ":", "\n", "    ", "\"\"\"\n    Idenfity the reshape sub-graph in a protobuf.\n    The reshape sub-graph is defined as matching the following pattern:\n\n    (input_blob) -> Op_1 -> ... -> Op_N -> (new_shape) -\u2500\u2510\n        \u2514-------------------------------------------> Reshape -> (output_blob)\n\n    Return:\n        List of sub-graphs, each sub-graph is represented as a list of indices\n        of the relavent ops, [Op_1, Op_2, ..., Op_N, Reshape]\n    \"\"\"", "\n", "\n", "ssa", ",", "_", "=", "core", ".", "get_ssa", "(", "predict_net", ")", "\n", "\n", "ret", "=", "[", "]", "\n", "for", "i", ",", "op", "in", "enumerate", "(", "predict_net", ".", "op", ")", ":", "\n", "        ", "if", "op", ".", "type", "==", "\"Reshape\"", ":", "\n", "            ", "assert", "len", "(", "op", ".", "input", ")", "==", "2", "\n", "input_ssa", "=", "ssa", "[", "i", "]", "[", "0", "]", "\n", "data_source", "=", "input_ssa", "[", "0", "]", "\n", "shape_source", "=", "input_ssa", "[", "1", "]", "\n", "op_indices", "=", "_get_dependency_chain", "(", "ssa", ",", "shape_source", ",", "data_source", ")", "\n", "ret", ".", "append", "(", "op_indices", "+", "[", "i", "]", ")", "\n", "", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.remove_reshape_for_fc": [[882, 950], ["shared.identify_reshape_sub_graph", "copy.deepcopy", "copy.deepcopy.op.extend", "caffe2.python.core.get_ssa", "all", "logger.info", "shared.rename_op_output", "shared.get_sub_graph_external_input_output", "remove_op_ids.extend", "params_to_remove.extend", "logger.info", "copy.deepcopy.external_input.remove", "shared.get_sub_graph_external_input_output", "enumerate", "range", "sub_graphs_to_remove.append", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.identify_reshape_sub_graph", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.rename_op_output", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_sub_graph_external_input_output", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.remove", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_sub_graph_external_input_output"], ["", "def", "remove_reshape_for_fc", "(", "predict_net", ",", "params", ")", ":", "\n", "    ", "\"\"\"\n    In PyTorch nn.Linear has to take 2D tensor, this often leads to reshape\n        a 4D tensor to 2D by calling .view(). However this (dynamic) reshaping\n        doesn't work well with ONNX and Int8 tools, and cause using extra\n        ops (eg. ExpandDims) that might not be available on mobile.\n    Luckily Caffe2 supports 4D tensor for FC, so we can remove those reshape\n        after exporting ONNX model.\n    \"\"\"", "\n", "from", "caffe2", ".", "python", "import", "core", "\n", "\n", "# find all reshape sub-graph that can be removed, which is now all Reshape", "\n", "# sub-graph whose output is only consumed by FC.", "\n", "# TODO: to make it safer, we may need the actually value to better determine", "\n", "# if a Reshape before FC is removable.", "\n", "reshape_sub_graphs", "=", "identify_reshape_sub_graph", "(", "predict_net", ")", "\n", "sub_graphs_to_remove", "=", "[", "]", "\n", "for", "reshape_sub_graph", "in", "reshape_sub_graphs", ":", "\n", "        ", "reshape_op_id", "=", "reshape_sub_graph", "[", "-", "1", "]", "\n", "assert", "predict_net", ".", "op", "[", "reshape_op_id", "]", ".", "type", "==", "\"Reshape\"", "\n", "ssa", ",", "_", "=", "core", ".", "get_ssa", "(", "predict_net", ")", "\n", "reshape_output", "=", "ssa", "[", "reshape_op_id", "]", "[", "1", "]", "[", "0", "]", "\n", "consumers", "=", "[", "i", "for", "i", "in", "range", "(", "len", "(", "ssa", ")", ")", "if", "reshape_output", "in", "ssa", "[", "i", "]", "[", "0", "]", "]", "\n", "if", "all", "(", "predict_net", ".", "op", "[", "consumer", "]", ".", "type", "==", "\"FC\"", "for", "consumer", "in", "consumers", ")", ":", "\n", "# safety check if the sub-graph is isolated, for this reshape sub-graph,", "\n", "# it means it has one non-param external input and one external output.", "\n", "            ", "ext_inputs", ",", "ext_outputs", "=", "get_sub_graph_external_input_output", "(", "\n", "predict_net", ",", "reshape_sub_graph", "\n", ")", "\n", "non_params_ext_inputs", "=", "[", "inp", "for", "inp", "in", "ext_inputs", "if", "inp", "[", "1", "]", "!=", "0", "]", "\n", "if", "len", "(", "non_params_ext_inputs", ")", "==", "1", "and", "len", "(", "ext_outputs", ")", "==", "1", ":", "\n", "                ", "sub_graphs_to_remove", ".", "append", "(", "reshape_sub_graph", ")", "\n", "\n", "# perform removing subgraph by:", "\n", "# 1: rename the Reshape's output to its input, then the graph can be", "\n", "#   seen as in-place itentify, meaning whose external input/output are the same.", "\n", "# 2: simply remove those ops.", "\n", "", "", "", "remove_op_ids", "=", "[", "]", "\n", "params_to_remove", "=", "[", "]", "\n", "for", "sub_graph", "in", "sub_graphs_to_remove", ":", "\n", "        ", "logger", ".", "info", "(", "\n", "\"Remove Reshape sub-graph:\\n{}\"", ".", "format", "(", "\n", "\"\"", ".", "join", "(", "[", "\"(#{:>4})\\n{}\"", ".", "format", "(", "i", ",", "predict_net", ".", "op", "[", "i", "]", ")", "for", "i", "in", "sub_graph", "]", ")", "\n", ")", "\n", ")", "\n", "reshape_op_id", "=", "sub_graph", "[", "-", "1", "]", "\n", "new_reshap_output", "=", "predict_net", ".", "op", "[", "reshape_op_id", "]", ".", "input", "[", "0", "]", "\n", "rename_op_output", "(", "predict_net", ",", "reshape_op_id", ",", "0", ",", "new_reshap_output", ")", "\n", "ext_inputs", ",", "ext_outputs", "=", "get_sub_graph_external_input_output", "(", "predict_net", ",", "sub_graph", ")", "\n", "non_params_ext_inputs", "=", "[", "inp", "for", "inp", "in", "ext_inputs", "if", "inp", "[", "1", "]", "!=", "0", "]", "\n", "params_ext_inputs", "=", "[", "inp", "for", "inp", "in", "ext_inputs", "if", "inp", "[", "1", "]", "==", "0", "]", "\n", "assert", "len", "(", "non_params_ext_inputs", ")", "==", "1", "and", "len", "(", "ext_outputs", ")", "==", "1", "\n", "assert", "ext_outputs", "[", "0", "]", "[", "0", "]", "==", "non_params_ext_inputs", "[", "0", "]", "[", "0", "]", "\n", "assert", "ext_outputs", "[", "0", "]", "[", "1", "]", "==", "non_params_ext_inputs", "[", "0", "]", "[", "1", "]", "+", "1", "\n", "remove_op_ids", ".", "extend", "(", "sub_graph", ")", "\n", "params_to_remove", ".", "extend", "(", "params_ext_inputs", ")", "\n", "\n", "", "predict_net", "=", "copy", ".", "deepcopy", "(", "predict_net", ")", "\n", "new_ops", "=", "[", "op", "for", "i", ",", "op", "in", "enumerate", "(", "predict_net", ".", "op", ")", "if", "i", "not", "in", "remove_op_ids", "]", "\n", "del", "predict_net", ".", "op", "[", ":", "]", "\n", "predict_net", ".", "op", ".", "extend", "(", "new_ops", ")", "\n", "for", "versioned_params", "in", "params_to_remove", ":", "\n", "        ", "name", "=", "versioned_params", "[", "0", "]", "\n", "logger", ".", "info", "(", "\"Remove params: {} from init_net and predict_net.external_input\"", ".", "format", "(", "name", ")", ")", "\n", "del", "params", "[", "name", "]", "\n", "predict_net", ".", "external_input", ".", "remove", "(", "name", ")", "\n", "\n", "", "return", "predict_net", ",", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.fuse_copy_between_cpu_and_gpu": [[952, 1008], ["shared.fuse_copy_between_cpu_and_gpu._fuse_once"], "function", ["None"], ["", "def", "fuse_copy_between_cpu_and_gpu", "(", "predict_net", ":", "caffe2_pb2", ".", "NetDef", ")", ":", "\n", "    ", "\"\"\"\n    In-place fuse extra copy ops between cpu/gpu for the following case:\n        a -CopyAToB-> b -CopyBToA> c1 -NextOp1-> d1\n                        -CopyBToA> c2 -NextOp2-> d2\n    The fused network will look like:\n        a -NextOp1-> d1\n          -NextOp2-> d2\n    \"\"\"", "\n", "\n", "_COPY_OPS", "=", "[", "\"CopyCPUToGPU\"", ",", "\"CopyGPUToCPU\"", "]", "\n", "\n", "def", "_fuse_once", "(", "predict_net", ")", ":", "\n", "        ", "ssa", ",", "blob_versions", "=", "core", ".", "get_ssa", "(", "predict_net", ")", "\n", "consumer_map", "=", "get_consumer_map", "(", "ssa", ")", "\n", "versioned_external_output", "=", "[", "\n", "(", "name", ",", "blob_versions", "[", "name", "]", ")", "for", "name", "in", "predict_net", ".", "external_output", "\n", "]", "\n", "\n", "for", "op_id", ",", "op", "in", "enumerate", "(", "predict_net", ".", "op", ")", ":", "\n", "            ", "if", "op", ".", "type", "in", "_COPY_OPS", ":", "\n", "                ", "fw_copy_versioned_output", "=", "ssa", "[", "op_id", "]", "[", "1", "]", "[", "0", "]", "\n", "consumer_ids", "=", "[", "x", "[", "0", "]", "for", "x", "in", "consumer_map", "[", "fw_copy_versioned_output", "]", "]", "\n", "reverse_op_type", "=", "_COPY_OPS", "[", "1", "-", "_COPY_OPS", ".", "index", "(", "op", ".", "type", ")", "]", "\n", "\n", "is_fusable", "=", "(", "\n", "len", "(", "consumer_ids", ")", ">", "0", "\n", "and", "fw_copy_versioned_output", "not", "in", "versioned_external_output", "\n", "and", "all", "(", "\n", "predict_net", ".", "op", "[", "_op_id", "]", ".", "type", "==", "reverse_op_type", "\n", "and", "ssa", "[", "_op_id", "]", "[", "1", "]", "[", "0", "]", "not", "in", "versioned_external_output", "\n", "for", "_op_id", "in", "consumer_ids", "\n", ")", "\n", ")", "\n", "\n", "if", "is_fusable", ":", "\n", "                    ", "for", "rv_copy_op_id", "in", "consumer_ids", ":", "\n", "# making each NextOp uses \"a\" directly and removing Copy ops", "\n", "                        ", "rs_copy_versioned_output", "=", "ssa", "[", "rv_copy_op_id", "]", "[", "1", "]", "[", "0", "]", "\n", "next_op_id", ",", "inp_id", "=", "consumer_map", "[", "rs_copy_versioned_output", "]", "[", "0", "]", "\n", "predict_net", ".", "op", "[", "next_op_id", "]", ".", "input", "[", "inp_id", "]", "=", "op", ".", "input", "[", "0", "]", "\n", "# remove CopyOps", "\n", "", "new_ops", "=", "[", "\n", "op", "\n", "for", "i", ",", "op", "in", "enumerate", "(", "predict_net", ".", "op", ")", "\n", "if", "i", "!=", "op_id", "and", "i", "not", "in", "consumer_ids", "\n", "]", "\n", "del", "predict_net", ".", "op", "[", ":", "]", "\n", "predict_net", ".", "op", ".", "extend", "(", "new_ops", ")", "\n", "return", "True", "\n", "\n", "", "", "", "return", "False", "\n", "\n", "# _fuse_once returns False is nothing can be fused", "\n", "", "while", "_fuse_once", "(", "predict_net", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.remove_dead_end_ops": [[1010, 1035], ["caffe2.python.core.get_ssa", "shared.get_consumer_map", "set", "reversed", "net_def.op.extend", "list", "all", "enumerate", "set.add", "enumerate", "shared.remove_dead_end_ops._is_dead_end"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_consumer_map", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["", "", "def", "remove_dead_end_ops", "(", "net_def", ":", "caffe2_pb2", ".", "NetDef", ")", ":", "\n", "    ", "\"\"\" remove ops if its output is not used or not in external_output \"\"\"", "\n", "ssa", ",", "versions", "=", "core", ".", "get_ssa", "(", "net_def", ")", "\n", "versioned_external_output", "=", "[", "(", "name", ",", "versions", "[", "name", "]", ")", "for", "name", "in", "net_def", ".", "external_output", "]", "\n", "consumer_map", "=", "get_consumer_map", "(", "ssa", ")", "\n", "removed_op_ids", "=", "set", "(", ")", "\n", "\n", "def", "_is_dead_end", "(", "versioned_blob", ")", ":", "\n", "        ", "return", "not", "(", "\n", "versioned_blob", "in", "versioned_external_output", "\n", "or", "(", "\n", "len", "(", "consumer_map", "[", "versioned_blob", "]", ")", ">", "0", "\n", "and", "all", "(", "x", "[", "0", "]", "not", "in", "removed_op_ids", "for", "x", "in", "consumer_map", "[", "versioned_blob", "]", ")", "\n", ")", "\n", ")", "\n", "\n", "", "for", "i", ",", "ssa_i", "in", "reversed", "(", "list", "(", "enumerate", "(", "ssa", ")", ")", ")", ":", "\n", "        ", "versioned_outputs", "=", "ssa_i", "[", "1", "]", "\n", "if", "all", "(", "_is_dead_end", "(", "outp", ")", "for", "outp", "in", "versioned_outputs", ")", ":", "\n", "            ", "removed_op_ids", ".", "add", "(", "i", ")", "\n", "\n", "# simply removing those deadend ops should have no effect to external_output", "\n", "", "", "new_ops", "=", "[", "op", "for", "i", ",", "op", "in", "enumerate", "(", "net_def", ".", "op", ")", "if", "i", "not", "in", "removed_op_ids", "]", "\n", "del", "net_def", ".", "op", "[", ":", "]", "\n", "net_def", ".", "op", ".", "extend", "(", "new_ops", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.Caffe2CompatibleConverter.__init__": [[32, 34], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "replaceCls", ")", ":", "\n", "        ", "self", ".", "replaceCls", "=", "replaceCls", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.Caffe2CompatibleConverter.create_from": [[35, 55], ["isinstance", "issubclass", "isinstance", "type"], "methods", ["None"], ["", "def", "create_from", "(", "self", ",", "module", ")", ":", "\n", "# update module's class to the new class", "\n", "        ", "assert", "isinstance", "(", "module", ",", "torch", ".", "nn", ".", "Module", ")", "\n", "if", "issubclass", "(", "self", ".", "replaceCls", ",", "GenericMixin", ")", ":", "\n", "# replaceCls should act as mixin, create a new class on-the-fly", "\n", "            ", "new_class", "=", "type", "(", "\n", "\"{}MixedWith{}\"", ".", "format", "(", "self", ".", "replaceCls", ".", "__name__", ",", "module", ".", "__class__", ".", "__name__", ")", ",", "\n", "(", "self", ".", "replaceCls", ",", "module", ".", "__class__", ")", ",", "\n", "{", "}", ",", "# {\"new_method\": lambda self: ...},", "\n", ")", "\n", "module", ".", "__class__", "=", "new_class", "\n", "", "else", ":", "\n", "# replaceCls is complete class, this allow arbitrary class swap", "\n", "            ", "module", ".", "__class__", "=", "self", ".", "replaceCls", "\n", "\n", "# initialize Caffe2Compatible", "\n", "", "if", "isinstance", "(", "module", ",", "Caffe2Compatible", ")", ":", "\n", "            ", "module", ".", "tensor_mode", "=", "False", "\n", "\n", "", "return", "module", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.ROIHeadsPatcher.__init__": [[115, 119], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "heads", ")", ":", "\n", "        ", "self", ".", "heads", "=", "heads", "\n", "\n", "self", ".", "use_heatmap_max_keypoint", "=", "cfg", ".", "EXPORT_CAFFE2", ".", "USE_HEATMAP_MAX_KEYPOINT", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.ROIHeadsPatcher.mock_roi_heads": [[120, 154], ["getattr", "getattr", "caffe2_patch.mock_fastrcnn_outputs_inference", "contextlib.ExitStack", "caffe2_patch.mock_keypoint_rcnn_inference", "caffe2_patch.mock_mask_rcnn_inference", "stack.enter_context", "type"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.mock_fastrcnn_outputs_inference", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.mock_keypoint_rcnn_inference", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.mock_mask_rcnn_inference"], ["", "@", "contextlib", ".", "contextmanager", "\n", "def", "mock_roi_heads", "(", "self", ",", "tensor_mode", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Patching several inference functions inside ROIHeads and its subclasses\n\n        Args:\n            tensor_mode (bool): whether the inputs/outputs are caffe2's tensor\n                format or not. Default to True.\n        \"\"\"", "\n", "# NOTE: this requries the `keypoint_rcnn_inference` and `mask_rcnn_inference`", "\n", "# are called inside the same file as BaseXxxHead due to using mock.patch.", "\n", "kpt_heads_mod", "=", "keypoint_head", ".", "BaseKeypointRCNNHead", ".", "__module__", "\n", "mask_head_mod", "=", "mask_head", ".", "BaseMaskRCNNHead", ".", "__module__", "\n", "\n", "mock_ctx_managers", "=", "[", "\n", "mock_fastrcnn_outputs_inference", "(", "\n", "tensor_mode", "=", "tensor_mode", ",", "\n", "check", "=", "True", ",", "\n", "box_predictor_type", "=", "type", "(", "self", ".", "heads", ".", "box_predictor", ")", ",", "\n", ")", "\n", "]", "\n", "if", "getattr", "(", "self", ".", "heads", ",", "\"keypoint_on\"", ",", "False", ")", ":", "\n", "            ", "mock_ctx_managers", "+=", "[", "\n", "mock_keypoint_rcnn_inference", "(", "\n", "tensor_mode", ",", "kpt_heads_mod", ",", "self", ".", "use_heatmap_max_keypoint", "\n", ")", "\n", "]", "\n", "", "if", "getattr", "(", "self", ".", "heads", ",", "\"mask_on\"", ",", "False", ")", ":", "\n", "            ", "mock_ctx_managers", "+=", "[", "mock_mask_rcnn_inference", "(", "tensor_mode", ",", "mask_head_mod", ")", "]", "\n", "\n", "", "with", "contextlib", ".", "ExitStack", "(", ")", "as", "stack", ":", "# python 3.3+", "\n", "            ", "for", "mgr", "in", "mock_ctx_managers", ":", "\n", "                ", "stack", ".", "enter_context", "(", "mgr", ")", "\n", "", "yield", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.patch": [[57, 68], ["model.named_children", "isinstance", "caffe2_patch.patch", "updater.create_from", "detectron2.modeling.proposal_generator.rpn.RPN", "detectron2.modeling.poolers.ROIPooler"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.patch", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.Caffe2CompatibleConverter.create_from"], ["", "", "def", "patch", "(", "model", ",", "target", ",", "updater", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    recursively (post-order) update all modules with the target type and its\n    subclasses, make a initialization/composition/inheritance/... via the\n    updater.create_from.\n    \"\"\"", "\n", "for", "name", ",", "module", "in", "model", ".", "named_children", "(", ")", ":", "\n", "        ", "model", ".", "_modules", "[", "name", "]", "=", "patch", "(", "module", ",", "target", ",", "updater", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "if", "isinstance", "(", "model", ",", "target", ")", ":", "\n", "        ", "return", "updater", ".", "create_from", "(", "model", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.patch_generalized_rcnn": [[70, 76], ["caffe2_patch.patch", "caffe2_patch.patch", "ccc", "ccc"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.patch", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.patch"], ["", "def", "patch_generalized_rcnn", "(", "model", ")", ":", "\n", "    ", "ccc", "=", "Caffe2CompatibleConverter", "\n", "model", "=", "patch", "(", "model", ",", "rpn", ".", "RPN", ",", "ccc", "(", "Caffe2RPN", ")", ")", "\n", "model", "=", "patch", "(", "model", ",", "poolers", ".", "ROIPooler", ",", "ccc", "(", "Caffe2ROIPooler", ")", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.mock_fastrcnn_outputs_inference": [[78, 91], ["unittest.mock.patch.object", "c10.Caffe2FastRCNNOutputsInference"], "function", ["None"], ["", "@", "contextlib", ".", "contextmanager", "\n", "def", "mock_fastrcnn_outputs_inference", "(", "\n", "tensor_mode", ",", "check", "=", "True", ",", "box_predictor_type", "=", "FastRCNNOutputLayers", "\n", ")", ":", "\n", "    ", "with", "mock", ".", "patch", ".", "object", "(", "\n", "box_predictor_type", ",", "\n", "\"inference\"", ",", "\n", "autospec", "=", "True", ",", "\n", "side_effect", "=", "Caffe2FastRCNNOutputsInference", "(", "tensor_mode", ")", ",", "\n", ")", "as", "mocked_func", ":", "\n", "        ", "yield", "\n", "", "if", "check", ":", "\n", "        ", "assert", "mocked_func", ".", "call_count", ">", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.mock_mask_rcnn_inference": [[93, 101], ["unittest.mock.patch", "c10.Caffe2MaskRCNNInference"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.patch"], ["", "", "@", "contextlib", ".", "contextmanager", "\n", "def", "mock_mask_rcnn_inference", "(", "tensor_mode", ",", "patched_module", ",", "check", "=", "True", ")", ":", "\n", "    ", "with", "mock", ".", "patch", "(", "\n", "\"{}.mask_rcnn_inference\"", ".", "format", "(", "patched_module", ")", ",", "side_effect", "=", "Caffe2MaskRCNNInference", "(", ")", "\n", ")", "as", "mocked_func", ":", "\n", "        ", "yield", "\n", "", "if", "check", ":", "\n", "        ", "assert", "mocked_func", ".", "call_count", ">", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.mock_keypoint_rcnn_inference": [[103, 112], ["unittest.mock.patch", "c10.Caffe2KeypointRCNNInference"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.patch"], ["", "", "@", "contextlib", ".", "contextmanager", "\n", "def", "mock_keypoint_rcnn_inference", "(", "tensor_mode", ",", "patched_module", ",", "use_heatmap_max_keypoint", ",", "check", "=", "True", ")", ":", "\n", "    ", "with", "mock", ".", "patch", "(", "\n", "\"{}.keypoint_rcnn_inference\"", ".", "format", "(", "patched_module", ")", ",", "\n", "side_effect", "=", "Caffe2KeypointRCNNInference", "(", "use_heatmap_max_keypoint", ")", ",", "\n", ")", "as", "mocked_func", ":", "\n", "        ", "yield", "\n", "", "if", "check", ":", "\n", "        ", "assert", "mocked_func", ".", "call_count", ">", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2MetaArch.__init__": [[145, 156], ["super().__init__", "caffe2_modeling.Caffe2MetaArch.eval", "caffe2_modeling.set_caffe2_compatible_tensor_mode"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.set_caffe2_compatible_tensor_mode"], ["def", "__init__", "(", "self", ",", "cfg", ",", "torch_model", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            cfg (CfgNode):\n            torch_model (nn.Module): the detectron2 model (meta_arch) to be\n                converted.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_wrapped_model", "=", "torch_model", "\n", "self", ".", "eval", "(", ")", "\n", "set_caffe2_compatible_tensor_mode", "(", "self", ",", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2MetaArch.get_caffe2_inputs": [[157, 179], ["caffe2_modeling.convert_batched_inputs_to_c2_format"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.convert_batched_inputs_to_c2_format"], ["", "def", "get_caffe2_inputs", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Convert pytorch-style structured inputs to caffe2-style inputs that\n        are tuples of tensors.\n\n        Args:\n            batched_inputs (list[dict]): inputs to a detectron2 model\n                in its standard format. Each dict has \"image\" (CHW tensor), and optionally\n                \"height\" and \"width\".\n\n        Returns:\n            tuple[Tensor]:\n                tuple of tensors that will be the inputs to the\n                :meth:`forward` method. For existing models, the first\n                is an NCHW tensor (padded and batched); the second is\n                a im_info Nx3 tensor, where the rows are\n                (height, width, unused legacy parameter)\n        \"\"\"", "\n", "return", "convert_batched_inputs_to_c2_format", "(", "\n", "batched_inputs", ",", "\n", "self", ".", "_wrapped_model", ".", "backbone", ".", "size_divisibility", ",", "\n", "self", ".", "_wrapped_model", ".", "device", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2MetaArch.encode_additional_info": [[181, 186], ["None"], "methods", ["None"], ["", "def", "encode_additional_info", "(", "self", ",", "predict_net", ",", "init_net", ")", ":", "\n", "        ", "\"\"\"\n        Save extra metadata that will be used by inference in the output protobuf.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2MetaArch.forward": [[187, 201], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"\n        Run the forward in caffe2-style. It has to use caffe2-compatible ops\n        and the method will be used for tracing.\n\n        Args:\n            inputs (tuple[Tensor]): inputs defined by :meth:`get_caffe2_input`.\n                They will be the inputs of the converted caffe2 graph.\n\n        Returns:\n            tuple[Tensor]: output tensors. They will be the outputs of the\n                converted caffe2 graph.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2MetaArch._caffe2_preprocess_image": [[202, 218], ["shared.alias", "shared.alias", "shared.alias", "detectron2.structures.ImageList"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.alias", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.alias", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.alias"], ["", "def", "_caffe2_preprocess_image", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"\n        Caffe2 implementation of preprocess_image, which is called inside each MetaArch's forward.\n        It normalizes the input images, and the final caffe2 graph assumes the\n        inputs have been batched already.\n        \"\"\"", "\n", "data", ",", "im_info", "=", "inputs", "\n", "data", "=", "alias", "(", "data", ",", "\"data\"", ")", "\n", "im_info", "=", "alias", "(", "im_info", ",", "\"im_info\"", ")", "\n", "mean", ",", "std", "=", "self", ".", "_wrapped_model", ".", "pixel_mean", ",", "self", ".", "_wrapped_model", ".", "pixel_std", "\n", "normalized_data", "=", "(", "data", "-", "mean", ")", "/", "std", "\n", "normalized_data", "=", "alias", "(", "normalized_data", ",", "\"normalized_data\"", ")", "\n", "\n", "# Pack (data, im_info) into ImageList which is recognized by self.inference.", "\n", "images", "=", "ImageList", "(", "tensor", "=", "normalized_data", ",", "image_sizes", "=", "im_info", ")", "\n", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2MetaArch.get_outputs_converter": [[219, 246], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_outputs_converter", "(", "predict_net", ",", "init_net", ")", ":", "\n", "        ", "\"\"\"\n        Creates a function that converts outputs of the caffe2 model to\n        detectron2's standard format.\n        The function uses information in `predict_net` and `init_net` that are\n        available at inferene time. Therefore the function logic can be used in inference.\n\n        The returned function has the following signature:\n\n            def convert(batched_inputs, c2_inputs, c2_results) -> detectron2_outputs\n\n        Where\n\n            * batched_inputs (list[dict]): the original input format of the meta arch\n            * c2_inputs (dict[str, Tensor]): the caffe2 inputs.\n            * c2_results (dict[str, Tensor]): the caffe2 output format,\n                corresponding to the outputs of the :meth:`forward` function.\n            * detectron2_outputs: the original output format of the meta arch.\n\n        This function can be used to compare the outputs of the original meta arch and\n        the converted caffe2 graph.\n\n        Returns:\n            callable: a callable of the above signature.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2GeneralizedRCNN.__init__": [[249, 255], ["isinstance", "caffe2_patch.patch_generalized_rcnn", "caffe2_modeling.Caffe2MetaArch.__init__", "caffe2_patch.ROIHeadsPatcher"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.patch_generalized_rcnn", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "torch_model", ")", ":", "\n", "        ", "assert", "isinstance", "(", "torch_model", ",", "meta_arch", ".", "GeneralizedRCNN", ")", "\n", "torch_model", "=", "patch_generalized_rcnn", "(", "torch_model", ")", "\n", "super", "(", ")", ".", "__init__", "(", "cfg", ",", "torch_model", ")", "\n", "\n", "self", ".", "roi_heads_patcher", "=", "ROIHeadsPatcher", "(", "cfg", ",", "self", ".", "_wrapped_model", ".", "roi_heads", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2GeneralizedRCNN.encode_additional_info": [[256, 263], ["shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "str.encode", "str"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.check_set_pb_arg"], ["", "def", "encode_additional_info", "(", "self", ",", "predict_net", ",", "init_net", ")", ":", "\n", "        ", "size_divisibility", "=", "self", ".", "_wrapped_model", ".", "backbone", ".", "size_divisibility", "\n", "check_set_pb_arg", "(", "predict_net", ",", "\"size_divisibility\"", ",", "\"i\"", ",", "size_divisibility", ")", "\n", "check_set_pb_arg", "(", "\n", "predict_net", ",", "\"device\"", ",", "\"s\"", ",", "str", ".", "encode", "(", "str", "(", "self", ".", "_wrapped_model", ".", "device", ")", ",", "\"ascii\"", ")", "\n", ")", "\n", "check_set_pb_arg", "(", "predict_net", ",", "\"meta_architecture\"", ",", "\"s\"", ",", "b\"GeneralizedRCNN\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2GeneralizedRCNN.forward": [[264, 274], ["shared.mock_torch_nn_functional_interpolate", "caffe2_modeling.Caffe2GeneralizedRCNN._caffe2_preprocess_image", "caffe2_modeling.Caffe2GeneralizedRCNN._wrapped_model.backbone", "caffe2_modeling.Caffe2GeneralizedRCNN._wrapped_model.proposal_generator", "tuple", "caffe2_modeling.Caffe2GeneralizedRCNN._wrapped_model.inference", "caffe2_modeling.Caffe2GeneralizedRCNN.roi_heads_patcher.mock_roi_heads", "caffe2_modeling.Caffe2GeneralizedRCNN._wrapped_model.roi_heads", "detector_results[].flatten"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.mock_torch_nn_functional_interpolate", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2MetaArch._caffe2_preprocess_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.inference", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.ROIHeadsPatcher.mock_roi_heads", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten"], ["", "@", "mock_torch_nn_functional_interpolate", "(", ")", "\n", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "if", "not", "self", ".", "tensor_mode", ":", "\n", "            ", "return", "self", ".", "_wrapped_model", ".", "inference", "(", "inputs", ")", "\n", "", "images", "=", "self", ".", "_caffe2_preprocess_image", "(", "inputs", ")", "\n", "features", "=", "self", ".", "_wrapped_model", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "proposals", ",", "_", "=", "self", ".", "_wrapped_model", ".", "proposal_generator", "(", "images", ",", "features", ")", "\n", "with", "self", ".", "roi_heads_patcher", ".", "mock_roi_heads", "(", ")", ":", "\n", "            ", "detector_results", ",", "_", "=", "self", ".", "_wrapped_model", ".", "roi_heads", "(", "images", ",", "features", ",", "proposals", ")", "\n", "", "return", "tuple", "(", "detector_results", "[", "0", "]", ".", "flatten", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2GeneralizedRCNN.get_outputs_converter": [[275, 283], ["caffe2_modeling.assemble_rcnn_outputs_by_name", "detectron2.modeling.meta_arch.GeneralizedRCNN._postprocess", "int", "int"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.assemble_rcnn_outputs_by_name", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch._postprocess"], ["", "@", "staticmethod", "\n", "def", "get_outputs_converter", "(", "predict_net", ",", "init_net", ")", ":", "\n", "        ", "def", "f", "(", "batched_inputs", ",", "c2_inputs", ",", "c2_results", ")", ":", "\n", "            ", "image_sizes", "=", "[", "[", "int", "(", "im", "[", "0", "]", ")", ",", "int", "(", "im", "[", "1", "]", ")", "]", "for", "im", "in", "c2_inputs", "[", "\"im_info\"", "]", "]", "\n", "results", "=", "assemble_rcnn_outputs_by_name", "(", "image_sizes", ",", "c2_results", ")", "\n", "return", "meta_arch", ".", "GeneralizedRCNN", ".", "_postprocess", "(", "results", ",", "batched_inputs", ",", "image_sizes", ")", "\n", "\n", "", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2PanopticFPN.__init__": [[286, 292], ["isinstance", "caffe2_patch.patch_generalized_rcnn", "caffe2_modeling.Caffe2MetaArch.__init__", "caffe2_patch.ROIHeadsPatcher"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.patch_generalized_rcnn", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "torch_model", ")", ":", "\n", "        ", "assert", "isinstance", "(", "torch_model", ",", "meta_arch", ".", "PanopticFPN", ")", "\n", "torch_model", "=", "patch_generalized_rcnn", "(", "torch_model", ")", "\n", "super", "(", ")", ".", "__init__", "(", "cfg", ",", "torch_model", ")", "\n", "\n", "self", ".", "roi_heads_patcher", "=", "ROIHeadsPatcher", "(", "cfg", ",", "self", ".", "_wrapped_model", ".", "roi_heads", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2PanopticFPN.forward": [[293, 308], ["shared.mock_torch_nn_functional_interpolate", "caffe2_modeling.Caffe2PanopticFPN._caffe2_preprocess_image", "caffe2_modeling.Caffe2PanopticFPN._wrapped_model.backbone", "caffe2_modeling.Caffe2PanopticFPN._wrapped_model.sem_seg_head", "shared.alias", "caffe2_modeling.Caffe2PanopticFPN._wrapped_model.proposal_generator", "caffe2_modeling.Caffe2PanopticFPN.roi_heads_patcher.mock_roi_heads", "caffe2_modeling.Caffe2PanopticFPN._wrapped_model.roi_heads", "tuple", "detector_results[].flatten"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.mock_torch_nn_functional_interpolate", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2MetaArch._caffe2_preprocess_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.alias", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_patch.ROIHeadsPatcher.mock_roi_heads", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten"], ["", "@", "mock_torch_nn_functional_interpolate", "(", ")", "\n", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "assert", "self", ".", "tensor_mode", "\n", "images", "=", "self", ".", "_caffe2_preprocess_image", "(", "inputs", ")", "\n", "features", "=", "self", ".", "_wrapped_model", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "\n", "sem_seg_results", ",", "_", "=", "self", ".", "_wrapped_model", ".", "sem_seg_head", "(", "features", ")", "\n", "sem_seg_results", "=", "alias", "(", "sem_seg_results", ",", "\"sem_seg\"", ")", "\n", "\n", "proposals", ",", "_", "=", "self", ".", "_wrapped_model", ".", "proposal_generator", "(", "images", ",", "features", ")", "\n", "\n", "with", "self", ".", "roi_heads_patcher", ".", "mock_roi_heads", "(", "self", ".", "tensor_mode", ")", ":", "\n", "            ", "detector_results", ",", "_", "=", "self", ".", "_wrapped_model", ".", "roi_heads", "(", "images", ",", "features", ",", "proposals", ")", "\n", "\n", "", "return", "tuple", "(", "detector_results", "[", "0", "]", ".", "flatten", "(", ")", ")", "+", "(", "sem_seg_results", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2PanopticFPN.encode_additional_info": [[309, 336], ["shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "str.encode", "caffe2_modeling._cast_to_f32", "caffe2_modeling._cast_to_f32", "str"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling._cast_to_f32", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling._cast_to_f32"], ["", "def", "encode_additional_info", "(", "self", ",", "predict_net", ",", "init_net", ")", ":", "\n", "        ", "size_divisibility", "=", "self", ".", "_wrapped_model", ".", "backbone", ".", "size_divisibility", "\n", "check_set_pb_arg", "(", "predict_net", ",", "\"size_divisibility\"", ",", "\"i\"", ",", "size_divisibility", ")", "\n", "check_set_pb_arg", "(", "\n", "predict_net", ",", "\"device\"", ",", "\"s\"", ",", "str", ".", "encode", "(", "str", "(", "self", ".", "_wrapped_model", ".", "device", ")", ",", "\"ascii\"", ")", "\n", ")", "\n", "check_set_pb_arg", "(", "predict_net", ",", "\"meta_architecture\"", ",", "\"s\"", ",", "b\"PanopticFPN\"", ")", "\n", "\n", "# Inference parameters:", "\n", "check_set_pb_arg", "(", "predict_net", ",", "\"combine_on\"", ",", "\"i\"", ",", "self", ".", "_wrapped_model", ".", "combine_on", ")", "\n", "check_set_pb_arg", "(", "\n", "predict_net", ",", "\n", "\"combine_overlap_threshold\"", ",", "\n", "\"f\"", ",", "\n", "_cast_to_f32", "(", "self", ".", "_wrapped_model", ".", "combine_overlap_threshold", ")", ",", "\n", ")", "\n", "check_set_pb_arg", "(", "\n", "predict_net", ",", "\n", "\"combine_stuff_area_limit\"", ",", "\n", "\"i\"", ",", "\n", "self", ".", "_wrapped_model", ".", "combine_stuff_area_limit", ",", "\n", ")", "\n", "check_set_pb_arg", "(", "\n", "predict_net", ",", "\n", "\"combine_instances_confidence_threshold\"", ",", "\n", "\"f\"", ",", "\n", "_cast_to_f32", "(", "self", ".", "_wrapped_model", ".", "combine_instances_confidence_threshold", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2PanopticFPN.get_outputs_converter": [[338, 378], ["shared.get_pb_arg_vali", "shared.get_pb_arg_valf", "shared.get_pb_arg_vali", "shared.get_pb_arg_valf", "caffe2_modeling.assemble_rcnn_outputs_by_name", "zip", "input_per_image.get", "input_per_image.get", "detectron2.modeling.postprocessing.sem_seg_postprocess", "detectron2.modeling.postprocessing.detector_postprocess", "processed_results.append", "int", "int", "detectron2.modeling.meta_arch.panoptic_fpn.combine_semantic_and_instance_outputs", "detectron2.modeling.postprocessing.sem_seg_postprocess.argmax"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_vali", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_valf", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_vali", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_valf", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.assemble_rcnn_outputs_by_name", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.postprocessing.sem_seg_postprocess", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.postprocessing.detector_postprocess", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.panoptic_fpn.combine_semantic_and_instance_outputs"], ["", "@", "staticmethod", "\n", "def", "get_outputs_converter", "(", "predict_net", ",", "init_net", ")", ":", "\n", "        ", "combine_on", "=", "get_pb_arg_vali", "(", "predict_net", ",", "\"combine_on\"", ",", "None", ")", "\n", "combine_overlap_threshold", "=", "get_pb_arg_valf", "(", "predict_net", ",", "\"combine_overlap_threshold\"", ",", "None", ")", "\n", "combine_stuff_area_limit", "=", "get_pb_arg_vali", "(", "predict_net", ",", "\"combine_stuff_area_limit\"", ",", "None", ")", "\n", "combine_instances_confidence_threshold", "=", "get_pb_arg_valf", "(", "\n", "predict_net", ",", "\"combine_instances_confidence_threshold\"", ",", "None", "\n", ")", "\n", "\n", "def", "f", "(", "batched_inputs", ",", "c2_inputs", ",", "c2_results", ")", ":", "\n", "            ", "image_sizes", "=", "[", "[", "int", "(", "im", "[", "0", "]", ")", ",", "int", "(", "im", "[", "1", "]", ")", "]", "for", "im", "in", "c2_inputs", "[", "\"im_info\"", "]", "]", "\n", "detector_results", "=", "assemble_rcnn_outputs_by_name", "(", "\n", "image_sizes", ",", "c2_results", ",", "force_mask_on", "=", "True", "\n", ")", "\n", "sem_seg_results", "=", "c2_results", "[", "\"sem_seg\"", "]", "\n", "\n", "# copied from meta_arch/panoptic_fpn.py ...", "\n", "processed_results", "=", "[", "]", "\n", "for", "sem_seg_result", ",", "detector_result", ",", "input_per_image", ",", "image_size", "in", "zip", "(", "\n", "sem_seg_results", ",", "detector_results", ",", "batched_inputs", ",", "image_sizes", "\n", ")", ":", "\n", "                ", "height", "=", "input_per_image", ".", "get", "(", "\"height\"", ",", "image_size", "[", "0", "]", ")", "\n", "width", "=", "input_per_image", ".", "get", "(", "\"width\"", ",", "image_size", "[", "1", "]", ")", "\n", "sem_seg_r", "=", "sem_seg_postprocess", "(", "sem_seg_result", ",", "image_size", ",", "height", ",", "width", ")", "\n", "detector_r", "=", "detector_postprocess", "(", "detector_result", ",", "height", ",", "width", ")", "\n", "\n", "processed_results", ".", "append", "(", "{", "\"sem_seg\"", ":", "sem_seg_r", ",", "\"instances\"", ":", "detector_r", "}", ")", "\n", "\n", "if", "combine_on", ":", "\n", "                    ", "panoptic_r", "=", "combine_semantic_and_instance_outputs", "(", "\n", "detector_r", ",", "\n", "sem_seg_r", ".", "argmax", "(", "dim", "=", "0", ")", ",", "\n", "combine_overlap_threshold", ",", "\n", "combine_stuff_area_limit", ",", "\n", "combine_instances_confidence_threshold", ",", "\n", ")", "\n", "processed_results", "[", "-", "1", "]", "[", "\"panoptic_seg\"", "]", "=", "panoptic_r", "\n", "", "", "return", "processed_results", "\n", "\n", "", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2RetinaNet.__init__": [[381, 384], ["isinstance", "caffe2_modeling.Caffe2MetaArch.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "torch_model", ")", ":", "\n", "        ", "assert", "isinstance", "(", "torch_model", ",", "meta_arch", ".", "RetinaNet", ")", "\n", "super", "(", ")", ".", "__init__", "(", "cfg", ",", "torch_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2RetinaNet.forward": [[385, 406], ["shared.mock_torch_nn_functional_interpolate", "caffe2_modeling.Caffe2RetinaNet._caffe2_preprocess_image", "caffe2_modeling.Caffe2RetinaNet._wrapped_model.backbone", "enumerate", "caffe2_modeling.Caffe2RetinaNet._wrapped_model.head", "enumerate", "tuple", "shared.alias", "return_tensors.append", "zip", "return_tensors.append", "return_tensors.append", "shared.alias", "shared.alias"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.mock_torch_nn_functional_interpolate", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2MetaArch._caffe2_preprocess_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.alias", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.alias", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.alias"], ["", "@", "mock_torch_nn_functional_interpolate", "(", ")", "\n", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "assert", "self", ".", "tensor_mode", "\n", "images", "=", "self", ".", "_caffe2_preprocess_image", "(", "inputs", ")", "\n", "\n", "# explicitly return the images sizes to avoid removing \"im_info\" by ONNX", "\n", "# since it's not used in the forward path", "\n", "return_tensors", "=", "[", "images", ".", "image_sizes", "]", "\n", "\n", "features", "=", "self", ".", "_wrapped_model", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "_wrapped_model", ".", "in_features", "]", "\n", "for", "i", ",", "feature_i", "in", "enumerate", "(", "features", ")", ":", "\n", "            ", "features", "[", "i", "]", "=", "alias", "(", "feature_i", ",", "\"feature_{}\"", ".", "format", "(", "i", ")", ",", "is_backward", "=", "True", ")", "\n", "return_tensors", ".", "append", "(", "features", "[", "i", "]", ")", "\n", "\n", "", "pred_logits", ",", "pred_anchor_deltas", "=", "self", ".", "_wrapped_model", ".", "head", "(", "features", ")", "\n", "for", "i", ",", "(", "box_cls_i", ",", "box_delta_i", ")", "in", "enumerate", "(", "zip", "(", "pred_logits", ",", "pred_anchor_deltas", ")", ")", ":", "\n", "            ", "return_tensors", ".", "append", "(", "alias", "(", "box_cls_i", ",", "\"box_cls_{}\"", ".", "format", "(", "i", ")", ")", ")", "\n", "return_tensors", ".", "append", "(", "alias", "(", "box_delta_i", ",", "\"box_delta_{}\"", ".", "format", "(", "i", ")", ")", ")", "\n", "\n", "", "return", "tuple", "(", "return_tensors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2RetinaNet.encode_additional_info": [[407, 437], ["shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "caffe2_modeling.Caffe2RetinaNet._encode_anchor_generator_cfg", "str.encode", "caffe2_modeling._cast_to_f32", "caffe2_modeling._cast_to_f32", "str", "caffe2_modeling._cast_to_f32"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2RetinaNet._encode_anchor_generator_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling._cast_to_f32", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling._cast_to_f32", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling._cast_to_f32"], ["", "def", "encode_additional_info", "(", "self", ",", "predict_net", ",", "init_net", ")", ":", "\n", "        ", "size_divisibility", "=", "self", ".", "_wrapped_model", ".", "backbone", ".", "size_divisibility", "\n", "check_set_pb_arg", "(", "predict_net", ",", "\"size_divisibility\"", ",", "\"i\"", ",", "size_divisibility", ")", "\n", "check_set_pb_arg", "(", "\n", "predict_net", ",", "\"device\"", ",", "\"s\"", ",", "str", ".", "encode", "(", "str", "(", "self", ".", "_wrapped_model", ".", "device", ")", ",", "\"ascii\"", ")", "\n", ")", "\n", "check_set_pb_arg", "(", "predict_net", ",", "\"meta_architecture\"", ",", "\"s\"", ",", "b\"RetinaNet\"", ")", "\n", "\n", "# Inference parameters:", "\n", "check_set_pb_arg", "(", "\n", "predict_net", ",", "\"score_threshold\"", ",", "\"f\"", ",", "_cast_to_f32", "(", "self", ".", "_wrapped_model", ".", "score_threshold", ")", "\n", ")", "\n", "check_set_pb_arg", "(", "predict_net", ",", "\"topk_candidates\"", ",", "\"i\"", ",", "self", ".", "_wrapped_model", ".", "topk_candidates", ")", "\n", "check_set_pb_arg", "(", "\n", "predict_net", ",", "\"nms_threshold\"", ",", "\"f\"", ",", "_cast_to_f32", "(", "self", ".", "_wrapped_model", ".", "nms_threshold", ")", "\n", ")", "\n", "check_set_pb_arg", "(", "\n", "predict_net", ",", "\n", "\"max_detections_per_image\"", ",", "\n", "\"i\"", ",", "\n", "self", ".", "_wrapped_model", ".", "max_detections_per_image", ",", "\n", ")", "\n", "\n", "check_set_pb_arg", "(", "\n", "predict_net", ",", "\n", "\"bbox_reg_weights\"", ",", "\n", "\"floats\"", ",", "\n", "[", "_cast_to_f32", "(", "w", ")", "for", "w", "in", "self", ".", "_wrapped_model", ".", "box2box_transform", ".", "weights", "]", ",", "\n", ")", "\n", "self", ".", "_encode_anchor_generator_cfg", "(", "predict_net", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2RetinaNet._encode_anchor_generator_cfg": [[438, 446], ["io.BytesIO", "torch.save", "io.BytesIO.getvalue", "shared.check_set_pb_arg"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.check_set_pb_arg"], ["", "def", "_encode_anchor_generator_cfg", "(", "self", ",", "predict_net", ")", ":", "\n", "# serialize anchor_generator for future use", "\n", "        ", "serialized_anchor_generator", "=", "io", ".", "BytesIO", "(", ")", "\n", "torch", ".", "save", "(", "self", ".", "_wrapped_model", ".", "anchor_generator", ",", "serialized_anchor_generator", ")", "\n", "# Ideally we can put anchor generating inside the model, then we don't", "\n", "# need to store this information.", "\n", "bytes", "=", "serialized_anchor_generator", ".", "getvalue", "(", ")", "\n", "check_set_pb_arg", "(", "predict_net", ",", "\"serialized_anchor_generator\"", ",", "\"s\"", ",", "bytes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2RetinaNet.get_outputs_converter": [[447, 491], ["types.SimpleNamespace", "io.BytesIO", "torch.load", "shared.get_pb_arg_floats", "detectron2.modeling.box_regression.Box2BoxTransform", "shared.get_pb_arg_valf", "shared.get_pb_arg_vali", "shared.get_pb_arg_valf", "shared.get_pb_arg_vali", "functools.partial", "functools.partial", "shared.get_pb_arg_vals", "len", "types.SimpleNamespace.anchor_generator", "types.SimpleNamespace.inference", "detectron2.modeling.meta_arch.GeneralizedRCNN._postprocess", "tuple", "detectron2.modeling.meta_arch.retinanet.permute_to_N_HWA_K", "detectron2.modeling.meta_arch.retinanet.permute_to_N_HWA_K", "int", "int", "range", "range", "x.clone", "c2_results.keys", "x.startswith"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_floats", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_valf", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_vali", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_valf", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_vali", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_vals", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.inference", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch._postprocess", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.permute_to_N_HWA_K", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.permute_to_N_HWA_K", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone"], ["", "@", "staticmethod", "\n", "def", "get_outputs_converter", "(", "predict_net", ",", "init_net", ")", ":", "\n", "        ", "self", "=", "types", ".", "SimpleNamespace", "(", ")", "\n", "serialized_anchor_generator", "=", "io", ".", "BytesIO", "(", "\n", "get_pb_arg_vals", "(", "predict_net", ",", "\"serialized_anchor_generator\"", ",", "None", ")", "\n", ")", "\n", "self", ".", "anchor_generator", "=", "torch", ".", "load", "(", "serialized_anchor_generator", ")", "\n", "bbox_reg_weights", "=", "get_pb_arg_floats", "(", "predict_net", ",", "\"bbox_reg_weights\"", ",", "None", ")", "\n", "self", ".", "box2box_transform", "=", "Box2BoxTransform", "(", "weights", "=", "tuple", "(", "bbox_reg_weights", ")", ")", "\n", "self", ".", "score_threshold", "=", "get_pb_arg_valf", "(", "predict_net", ",", "\"score_threshold\"", ",", "None", ")", "\n", "self", ".", "topk_candidates", "=", "get_pb_arg_vali", "(", "predict_net", ",", "\"topk_candidates\"", ",", "None", ")", "\n", "self", ".", "nms_threshold", "=", "get_pb_arg_valf", "(", "predict_net", ",", "\"nms_threshold\"", ",", "None", ")", "\n", "self", ".", "max_detections_per_image", "=", "get_pb_arg_vali", "(", "\n", "predict_net", ",", "\"max_detections_per_image\"", ",", "None", "\n", ")", "\n", "\n", "# hack to reuse inference code from RetinaNet", "\n", "self", ".", "inference", "=", "functools", ".", "partial", "(", "meta_arch", ".", "RetinaNet", ".", "inference", ",", "self", ")", "\n", "self", ".", "inference_single_image", "=", "functools", ".", "partial", "(", "\n", "meta_arch", ".", "RetinaNet", ".", "inference_single_image", ",", "self", "\n", ")", "\n", "\n", "def", "f", "(", "batched_inputs", ",", "c2_inputs", ",", "c2_results", ")", ":", "\n", "            ", "image_sizes", "=", "[", "[", "int", "(", "im", "[", "0", "]", ")", ",", "int", "(", "im", "[", "1", "]", ")", "]", "for", "im", "in", "c2_inputs", "[", "\"im_info\"", "]", "]", "\n", "\n", "num_features", "=", "len", "(", "[", "x", "for", "x", "in", "c2_results", ".", "keys", "(", ")", "if", "x", ".", "startswith", "(", "\"box_cls_\"", ")", "]", ")", "\n", "pred_logits", "=", "[", "c2_results", "[", "\"box_cls_{}\"", ".", "format", "(", "i", ")", "]", "for", "i", "in", "range", "(", "num_features", ")", "]", "\n", "pred_anchor_deltas", "=", "[", "c2_results", "[", "\"box_delta_{}\"", ".", "format", "(", "i", ")", "]", "for", "i", "in", "range", "(", "num_features", ")", "]", "\n", "\n", "# For each feature level, feature should have the same batch size and", "\n", "# spatial dimension as the box_cls and box_delta.", "\n", "dummy_features", "=", "[", "x", ".", "clone", "(", ")", "[", ":", ",", "0", ":", "0", ",", ":", ",", ":", "]", "for", "x", "in", "pred_logits", "]", "\n", "anchors", "=", "self", ".", "anchor_generator", "(", "dummy_features", ")", "\n", "\n", "# self.num_classess can be inferred", "\n", "self", ".", "num_classes", "=", "pred_logits", "[", "0", "]", ".", "shape", "[", "1", "]", "//", "(", "pred_anchor_deltas", "[", "0", "]", ".", "shape", "[", "1", "]", "//", "4", ")", "\n", "\n", "pred_logits", "=", "[", "permute_to_N_HWA_K", "(", "x", ",", "self", ".", "num_classes", ")", "for", "x", "in", "pred_logits", "]", "\n", "pred_anchor_deltas", "=", "[", "permute_to_N_HWA_K", "(", "x", ",", "4", ")", "for", "x", "in", "pred_anchor_deltas", "]", "\n", "\n", "results", "=", "self", ".", "inference", "(", "anchors", ",", "pred_logits", ",", "pred_anchor_deltas", ",", "image_sizes", ")", "\n", "return", "meta_arch", ".", "GeneralizedRCNN", ".", "_postprocess", "(", "results", ",", "batched_inputs", ",", "image_sizes", ")", "\n", "\n", "", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.assemble_rcnn_outputs_by_name": [[30, 96], ["tensor_outputs.get", "class_nms.to", "tensor_outputs.get", "tensor_outputs.get", "tensor_outputs.get", "detectron2.structures.Instances", "NotImplementedError", "len", "detectron2.structures.RotatedBoxes", "detectron2.structures.Boxes", "torch.arange", "torch.zeros", "keypoints_tensor.transpose", "detectron2.modeling.roi_heads.keypoint_head.keypoint_rcnn_inference"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.keypoint_head.keypoint_rcnn_inference"], ["def", "assemble_rcnn_outputs_by_name", "(", "image_sizes", ",", "tensor_outputs", ",", "force_mask_on", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    A function to assemble caffe2 model's outputs (i.e. Dict[str, Tensor])\n    to detectron2's format (i.e. list of Instances instance).\n    This only works when the model follows the Caffe2 detectron's naming convention.\n\n    Args:\n        image_sizes (List[List[int, int]]): [H, W] of every image.\n        tensor_outputs (Dict[str, Tensor]): external_output to its tensor.\n\n        force_mask_on (Bool): if true, the it make sure there'll be pred_masks even\n            if the mask is not found from tensor_outputs (usually due to model crash)\n    \"\"\"", "\n", "\n", "results", "=", "[", "Instances", "(", "image_size", ")", "for", "image_size", "in", "image_sizes", "]", "\n", "\n", "batch_splits", "=", "tensor_outputs", ".", "get", "(", "\"batch_splits\"", ",", "None", ")", "\n", "if", "batch_splits", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "", "assert", "len", "(", "image_sizes", ")", "==", "1", "\n", "result", "=", "results", "[", "0", "]", "\n", "\n", "bbox_nms", "=", "tensor_outputs", "[", "\"bbox_nms\"", "]", "\n", "score_nms", "=", "tensor_outputs", "[", "\"score_nms\"", "]", "\n", "class_nms", "=", "tensor_outputs", "[", "\"class_nms\"", "]", "\n", "# Detection will always success because Conv support 0-batch", "\n", "assert", "bbox_nms", "is", "not", "None", "\n", "assert", "score_nms", "is", "not", "None", "\n", "assert", "class_nms", "is", "not", "None", "\n", "if", "bbox_nms", ".", "shape", "[", "1", "]", "==", "5", ":", "\n", "        ", "result", ".", "pred_boxes", "=", "RotatedBoxes", "(", "bbox_nms", ")", "\n", "", "else", ":", "\n", "        ", "result", ".", "pred_boxes", "=", "Boxes", "(", "bbox_nms", ")", "\n", "", "result", ".", "scores", "=", "score_nms", "\n", "result", ".", "pred_classes", "=", "class_nms", ".", "to", "(", "torch", ".", "int64", ")", "\n", "\n", "mask_fcn_probs", "=", "tensor_outputs", ".", "get", "(", "\"mask_fcn_probs\"", ",", "None", ")", "\n", "if", "mask_fcn_probs", "is", "not", "None", ":", "\n", "# finish the mask pred", "\n", "        ", "mask_probs_pred", "=", "mask_fcn_probs", "\n", "num_masks", "=", "mask_probs_pred", ".", "shape", "[", "0", "]", "\n", "class_pred", "=", "result", ".", "pred_classes", "\n", "indices", "=", "torch", ".", "arange", "(", "num_masks", ",", "device", "=", "class_pred", ".", "device", ")", "\n", "mask_probs_pred", "=", "mask_probs_pred", "[", "indices", ",", "class_pred", "]", "[", ":", ",", "None", "]", "\n", "result", ".", "pred_masks", "=", "mask_probs_pred", "\n", "", "elif", "force_mask_on", ":", "\n", "# NOTE: there's no way to know the height/width of mask here, it won't be", "\n", "# used anyway when batch size is 0, so just set them to 0.", "\n", "        ", "result", ".", "pred_masks", "=", "torch", ".", "zeros", "(", "[", "0", ",", "1", ",", "0", ",", "0", "]", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "\n", "", "keypoints_out", "=", "tensor_outputs", ".", "get", "(", "\"keypoints_out\"", ",", "None", ")", "\n", "kps_score", "=", "tensor_outputs", ".", "get", "(", "\"kps_score\"", ",", "None", ")", "\n", "if", "keypoints_out", "is", "not", "None", ":", "\n", "# keypoints_out: [N, 4, #kypoints], where 4 is in order of (x, y, score, prob)", "\n", "        ", "keypoints_tensor", "=", "keypoints_out", "\n", "# NOTE: it's possible that prob is not calculated if \"should_output_softmax\"", "\n", "# is set to False in HeatmapMaxKeypoint, so just using raw score, seems", "\n", "# it doesn't affect mAP. TODO: check more carefully.", "\n", "keypoint_xyp", "=", "keypoints_tensor", ".", "transpose", "(", "1", ",", "2", ")", "[", ":", ",", ":", ",", "[", "0", ",", "1", ",", "2", "]", "]", "\n", "result", ".", "pred_keypoints", "=", "keypoint_xyp", "\n", "", "elif", "kps_score", "is", "not", "None", ":", "\n", "# keypoint heatmap to sparse data structure", "\n", "        ", "pred_keypoint_logits", "=", "kps_score", "\n", "keypoint_head", ".", "keypoint_rcnn_inference", "(", "pred_keypoint_logits", ",", "[", "result", "]", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling._cast_to_f32": [[98, 100], ["struct.unpack", "struct.pack"], "function", ["None"], ["", "def", "_cast_to_f32", "(", "f64", ")", ":", "\n", "    ", "return", "struct", ".", "unpack", "(", "\"f\"", ",", "struct", ".", "pack", "(", "\"f\"", ",", "f64", ")", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.set_caffe2_compatible_tensor_mode": [[102, 108], ["model.apply", "isinstance"], "function", ["None"], ["", "def", "set_caffe2_compatible_tensor_mode", "(", "model", ",", "enable", "=", "True", ")", ":", "\n", "    ", "def", "_fn", "(", "m", ")", ":", "\n", "        ", "if", "isinstance", "(", "m", ",", "Caffe2Compatible", ")", ":", "\n", "            ", "m", ".", "tensor_mode", "=", "enable", "\n", "\n", "", "", "model", ".", "apply", "(", "_fn", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.convert_batched_inputs_to_c2_format": [[110, 136], ["all", "all", "detectron2.structures.ImageList.from_tensors", "zip", "torch.Tensor", "input_per_image.get", "input_per_image.get", "torch.Tensor.append", "ImageList.from_tensors.tensor.to", "torch.Tensor.to", "isinstance", "x[].dim"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "convert_batched_inputs_to_c2_format", "(", "batched_inputs", ",", "size_divisibility", ",", "device", ")", ":", "\n", "    ", "\"\"\"\n    See get_caffe2_inputs() below.\n    \"\"\"", "\n", "assert", "all", "(", "isinstance", "(", "x", ",", "dict", ")", "for", "x", "in", "batched_inputs", ")", "\n", "assert", "all", "(", "x", "[", "\"image\"", "]", ".", "dim", "(", ")", "==", "3", "for", "x", "in", "batched_inputs", ")", "\n", "\n", "images", "=", "[", "x", "[", "\"image\"", "]", "for", "x", "in", "batched_inputs", "]", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "size_divisibility", ")", "\n", "\n", "im_info", "=", "[", "]", "\n", "for", "input_per_image", ",", "image_size", "in", "zip", "(", "batched_inputs", ",", "images", ".", "image_sizes", ")", ":", "\n", "        ", "target_height", "=", "input_per_image", ".", "get", "(", "\"height\"", ",", "image_size", "[", "0", "]", ")", "\n", "target_width", "=", "input_per_image", ".", "get", "(", "\"width\"", ",", "image_size", "[", "1", "]", ")", "# noqa", "\n", "# NOTE: The scale inside im_info is kept as convention and for providing", "\n", "# post-processing information if further processing is needed. For", "\n", "# current Caffe2 model definitions that don't include post-processing inside", "\n", "# the model, this number is not used.", "\n", "# NOTE: There can be a slight difference between width and height", "\n", "# scales, using a single number can results in numerical difference", "\n", "# compared with D2's post-processing.", "\n", "scale", "=", "target_height", "/", "image_size", "[", "0", "]", "\n", "im_info", ".", "append", "(", "[", "image_size", "[", "0", "]", ",", "image_size", "[", "1", "]", ",", "scale", "]", ")", "\n", "", "im_info", "=", "torch", ".", "Tensor", "(", "im_info", ")", "\n", "\n", "return", "images", ".", "tensor", ".", "to", "(", "device", ")", ",", "im_info", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript_patch.patch_instances": [[16, 48], ["tempfile.TemporaryDirectory", "tempfile.NamedTemporaryFile", "torchscript_patch._gen_module", "f.write", "f.flush", "f.close", "torchscript_patch._import", "getattr", "torch.jit.script", "torch._jit_internal._qualified_name", "sys.modules.pop"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript_patch._gen_module", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.TensorboardXWriter.close", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript_patch._import"], ["@", "contextmanager", "\n", "def", "patch_instances", "(", "fields", ")", ":", "\n", "    ", "\"\"\"\n    A contextmanager, under which the Instances class in detectron2 is replaced\n    by a statically-typed scriptable class, defined by `fields`.\n    See more in `export_torchscript_with_instances`.\n    \"\"\"", "\n", "with", "tempfile", ".", "TemporaryDirectory", "(", "prefix", "=", "\"detectron2\"", ")", "as", "dir", ",", "tempfile", ".", "NamedTemporaryFile", "(", "\n", "mode", "=", "\"w\"", ",", "encoding", "=", "\"utf-8\"", ",", "suffix", "=", "\".py\"", ",", "dir", "=", "dir", ",", "delete", "=", "False", "\n", ")", "as", "f", ":", "\n", "        ", "try", ":", "\n", "            ", "cls_name", ",", "s", "=", "_gen_module", "(", "fields", ")", "\n", "f", ".", "write", "(", "s", ")", "\n", "f", ".", "flush", "(", ")", "\n", "f", ".", "close", "(", ")", "\n", "\n", "module", "=", "_import", "(", "f", ".", "name", ")", "\n", "new_instances", "=", "getattr", "(", "module", ",", "cls_name", ")", "\n", "_", "=", "torch", ".", "jit", ".", "script", "(", "new_instances", ")", "\n", "\n", "# let torchscript think Instances was scripted already", "\n", "Instances", ".", "__torch_script_class__", "=", "True", "\n", "# let torchscript find new_instances when looking for the jit type of Instances", "\n", "Instances", ".", "_jit_override_qualname", "=", "torch", ".", "_jit_internal", ".", "_qualified_name", "(", "new_instances", ")", "\n", "yield", "new_instances", "\n", "", "finally", ":", "\n", "            ", "try", ":", "\n", "                ", "del", "Instances", ".", "__torch_script_class__", "\n", "del", "Instances", ".", "_jit_override_qualname", "\n", "", "except", "AttributeError", ":", "\n", "                ", "pass", "\n", "", "sys", ".", "modules", ".", "pop", "(", "module", ".", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript_patch._gen_imports": [[51, 63], ["None"], "function", ["None"], ["", "", "", "def", "_gen_imports", "(", ")", ":", "\n", "    ", "imports_str", "=", "\"\"\"\nfrom copy import deepcopy\nimport torch\nfrom torch import Tensor\nimport typing\nfrom typing import *\n\nfrom detectron2.structures import Boxes, Instances\n\n\"\"\"", "\n", "return", "imports_str", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript_patch._gen_class": [[65, 160], ["lines.append", "fields.items", "fields.items", "lines.append", "fields.items", "lines.append", "lines.append", "fields.items", "lines.append", "lines.append", "lines.append", "lines.append", "lines.append", "lines.append", "os.linesep.join", "torchscript_patch._gen_class.indent"], "function", ["None"], ["", "def", "_gen_class", "(", "fields", ")", ":", "\n", "    ", "def", "indent", "(", "level", ",", "s", ")", ":", "\n", "        ", "return", "\" \"", "*", "4", "*", "level", "+", "s", "\n", "\n", "", "lines", "=", "[", "]", "\n", "\n", "global", "_counter", "\n", "_counter", "+=", "1", "\n", "\n", "cls_name", "=", "\"Instances_patched{}\"", ".", "format", "(", "_counter", ")", "\n", "\n", "lines", ".", "append", "(", "\n", "f\"\"\"\nclass {cls_name}:\n    def __init__(self, image_size: Tuple[int, int]):\n        self.image_size = image_size\n\"\"\"", "\n", ")", "\n", "\n", "for", "name", ",", "type_", "in", "fields", ".", "items", "(", ")", ":", "\n", "        ", "lines", ".", "append", "(", "indent", "(", "2", ",", "f\"self._{name} = torch.jit.annotate(Optional[{type_}], None)\"", ")", ")", "\n", "\n", "", "for", "name", ",", "type_", "in", "fields", ".", "items", "(", ")", ":", "\n", "        ", "lines", ".", "append", "(", "\n", "f\"\"\"\n    @property\n    def {name}(self) -> {type_}:\n        # has to use a local for type refinement\n        # https://pytorch.org/docs/stable/jit_language_reference.html#optional-type-refinement\n        t = self._{name}\n        assert t is not None\n        return t\n\n    @{name}.setter\n    def {name}(self, value: {type_}) -> None:\n        self._{name} = value\n\"\"\"", "\n", ")", "\n", "\n", "# support function attribute `__len__`", "\n", "", "lines", ".", "append", "(", "\n", "\"\"\"\n    def __len__(self) -> int:\n\"\"\"", "\n", ")", "\n", "for", "name", ",", "_", "in", "fields", ".", "items", "(", ")", ":", "\n", "        ", "lines", ".", "append", "(", "\n", "f\"\"\"\n        t = self._{name}\n        if t is not None:\n            return len(t)\n\"\"\"", "\n", ")", "\n", "", "lines", ".", "append", "(", "\n", "\"\"\"\n        raise NotImplementedError(\"Empty Instances does not support __len__!\")\n\"\"\"", "\n", ")", "\n", "\n", "# support function attribute `has`", "\n", "lines", ".", "append", "(", "\n", "\"\"\"\n    def has(self, name: str) -> bool:\n\"\"\"", "\n", ")", "\n", "for", "name", ",", "_", "in", "fields", ".", "items", "(", ")", ":", "\n", "        ", "lines", ".", "append", "(", "\n", "f\"\"\"\n        if name == \"{name}\":\n            return self._{name} is not None\n\"\"\"", "\n", ")", "\n", "", "lines", ".", "append", "(", "\n", "\"\"\"\n        return False\n\"\"\"", "\n", ")", "\n", "\n", "# support function attribute `from_instances`", "\n", "lines", ".", "append", "(", "\n", "f\"\"\"\n    @torch.jit.unused\n    @staticmethod\n    def from_instances(instances: Instances) -> \"{cls_name}\":\n        fields = instances.get_fields()\n        image_size = instances.image_size\n        new_instances = {cls_name}(image_size)\n        for name, val in fields.items():\n            assert hasattr(new_instances, '_{{}}'.format(name)), \\\\\n                \"No attribute named {{}} in {cls_name}\".format(name)\n            setattr(new_instances, name, deepcopy(val))\n        return new_instances\n\"\"\"", "\n", ")", "\n", "return", "cls_name", ",", "os", ".", "linesep", ".", "join", "(", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript_patch._gen_module": [[162, 168], ["torchscript_patch._gen_imports", "torchscript_patch._gen_class"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript_patch._gen_imports", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript_patch._gen_class"], ["", "def", "_gen_module", "(", "fields", ")", ":", "\n", "    ", "s", "=", "\"\"", "\n", "s", "+=", "_gen_imports", "(", ")", "\n", "cls_name", ",", "cls_def", "=", "_gen_class", "(", "fields", ")", "\n", "s", "+=", "cls_def", "\n", "return", "cls_name", ",", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript_patch._import": [[170, 179], ["importlib.util.spec_from_file_location", "importlib.util.module_from_spec", "importlib.util.spec_from_file_location.loader.exec_module"], "function", ["None"], ["", "def", "_import", "(", "path", ")", ":", "\n", "# https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly", "\n", "    ", "spec", "=", "importlib", ".", "util", ".", "spec_from_file_location", "(", "\n", "\"{}{}\"", ".", "format", "(", "sys", ".", "modules", "[", "__name__", "]", ".", "__name__", ",", "_counter", ")", ",", "path", "\n", ")", "\n", "module", "=", "importlib", ".", "util", ".", "module_from_spec", "(", "spec", ")", "\n", "sys", ".", "modules", "[", "module", ".", "__name__", "]", "=", "module", "\n", "spec", ".", "loader", ".", "exec_module", "(", "module", ")", "\n", "return", "module", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_export.export_onnx_model": [[33, 72], ["isinstance", "model.apply", "onnx.optimizer.get_available_passes", "all", "onnx.optimizer.optimize", "torch.no_grad", "io.BytesIO", "torch.onnx.export", "onnx.load_from_string", "f.getvalue"], "function", ["None"], ["def", "export_onnx_model", "(", "model", ",", "inputs", ")", ":", "\n", "    ", "\"\"\"\n    Trace and export a model to onnx format.\n\n    Args:\n        model (nn.Module):\n        inputs (tuple[args]): the model will be called by `model(*inputs)`\n\n    Returns:\n        an onnx model\n    \"\"\"", "\n", "assert", "isinstance", "(", "model", ",", "torch", ".", "nn", ".", "Module", ")", "\n", "\n", "# make sure all modules are in eval mode, onnx may change the training state", "\n", "# of the module if the states are not consistent", "\n", "def", "_check_eval", "(", "module", ")", ":", "\n", "        ", "assert", "not", "module", ".", "training", "\n", "\n", "", "model", ".", "apply", "(", "_check_eval", ")", "\n", "\n", "# Export the model to ONNX", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "with", "io", ".", "BytesIO", "(", ")", "as", "f", ":", "\n", "            ", "torch", ".", "onnx", ".", "export", "(", "\n", "model", ",", "\n", "inputs", ",", "\n", "f", ",", "\n", "operator_export_type", "=", "OperatorExportTypes", ".", "ONNX_ATEN_FALLBACK", ",", "\n", "# verbose=True,  # NOTE: uncomment this for debugging", "\n", "# export_params=True,", "\n", ")", "\n", "onnx_model", "=", "onnx", ".", "load_from_string", "(", "f", ".", "getvalue", "(", ")", ")", "\n", "\n", "# Apply ONNX's Optimization", "\n", "", "", "all_passes", "=", "onnx", ".", "optimizer", ".", "get_available_passes", "(", ")", "\n", "passes", "=", "[", "\"fuse_bn_into_conv\"", "]", "\n", "assert", "all", "(", "p", "in", "all_passes", "for", "p", "in", "passes", ")", "\n", "onnx_model", "=", "onnx", ".", "optimizer", ".", "optimize", "(", "onnx_model", ",", "passes", ")", "\n", "return", "onnx_model", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_export._op_stats": [[74, 81], ["sorted", "sorted", "type_count.items", "type_count.get"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "def", "_op_stats", "(", "net_def", ")", ":", "\n", "    ", "type_count", "=", "{", "}", "\n", "for", "t", "in", "[", "op", ".", "type", "for", "op", "in", "net_def", ".", "op", "]", ":", "\n", "        ", "type_count", "[", "t", "]", "=", "type_count", ".", "get", "(", "t", ",", "0", ")", "+", "1", "\n", "", "type_count_list", "=", "sorted", "(", "type_count", ".", "items", "(", ")", ",", "key", "=", "lambda", "kv", ":", "kv", "[", "0", "]", ")", "# alphabet", "\n", "type_count_list", "=", "sorted", "(", "type_count_list", ",", "key", "=", "lambda", "kv", ":", "-", "kv", "[", "1", "]", ")", "# count", "\n", "return", "\"\\n\"", ".", "join", "(", "\"{:>4}x {}\"", ".", "format", "(", "count", ",", "name", ")", "for", "name", ",", "count", "in", "type_count_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_export._assign_device_option": [[83, 127], ["shared.infer_device_type", "caffe2.python.core.get_ssa", "caffe2_export._assign_device_option._assign_op_device_option"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.infer_device_type"], ["", "def", "_assign_device_option", "(", "\n", "predict_net", ":", "caffe2_pb2", ".", "NetDef", ",", "init_net", ":", "caffe2_pb2", ".", "NetDef", ",", "tensor_inputs", ":", "List", "[", "torch", ".", "Tensor", "]", "\n", ")", ":", "\n", "    ", "\"\"\"\n    ONNX exported network doesn't have concept of device, assign necessary\n    device option for each op in order to make it runable on GPU runtime.\n    \"\"\"", "\n", "\n", "def", "_get_device_type", "(", "torch_tensor", ")", ":", "\n", "        ", "assert", "torch_tensor", ".", "device", ".", "type", "in", "[", "\"cpu\"", ",", "\"cuda\"", "]", "\n", "assert", "torch_tensor", ".", "device", ".", "index", "==", "0", "\n", "return", "torch_tensor", ".", "device", ".", "type", "\n", "\n", "", "def", "_assign_op_device_option", "(", "net_proto", ",", "net_ssa", ",", "blob_device_types", ")", ":", "\n", "        ", "for", "op", ",", "ssa_i", "in", "zip", "(", "net_proto", ".", "op", ",", "net_ssa", ")", ":", "\n", "            ", "if", "op", ".", "type", "in", "[", "\"CopyCPUToGPU\"", ",", "\"CopyGPUToCPU\"", "]", ":", "\n", "                ", "op", ".", "device_option", ".", "CopyFrom", "(", "core", ".", "DeviceOption", "(", "caffe2_pb2", ".", "CUDA", ",", "0", ")", ")", "\n", "", "else", ":", "\n", "                ", "devices", "=", "[", "blob_device_types", "[", "b", "]", "for", "b", "in", "ssa_i", "[", "0", "]", "+", "ssa_i", "[", "1", "]", "]", "\n", "assert", "all", "(", "d", "==", "devices", "[", "0", "]", "for", "d", "in", "devices", ")", "\n", "if", "devices", "[", "0", "]", "==", "\"cuda\"", ":", "\n", "                    ", "op", ".", "device_option", ".", "CopyFrom", "(", "core", ".", "DeviceOption", "(", "caffe2_pb2", ".", "CUDA", ",", "0", ")", ")", "\n", "\n", "# update ops in predict_net", "\n", "", "", "", "", "predict_net_input_device_types", "=", "{", "\n", "(", "name", ",", "0", ")", ":", "_get_device_type", "(", "tensor", ")", "\n", "for", "name", ",", "tensor", "in", "zip", "(", "predict_net", ".", "external_input", ",", "tensor_inputs", ")", "\n", "}", "\n", "predict_net_device_types", "=", "infer_device_type", "(", "\n", "predict_net", ",", "known_status", "=", "predict_net_input_device_types", ",", "device_name_style", "=", "\"pytorch\"", "\n", ")", "\n", "predict_net_ssa", ",", "_", "=", "core", ".", "get_ssa", "(", "predict_net", ")", "\n", "_assign_op_device_option", "(", "predict_net", ",", "predict_net_ssa", ",", "predict_net_device_types", ")", "\n", "\n", "# update ops in init_net", "\n", "init_net_ssa", ",", "versions", "=", "core", ".", "get_ssa", "(", "init_net", ")", "\n", "init_net_output_device_types", "=", "{", "\n", "(", "name", ",", "versions", "[", "name", "]", ")", ":", "predict_net_device_types", "[", "(", "name", ",", "0", ")", "]", "\n", "for", "name", "in", "init_net", ".", "external_output", "\n", "}", "\n", "init_net_device_types", "=", "infer_device_type", "(", "\n", "init_net", ",", "known_status", "=", "init_net_output_device_types", ",", "device_name_style", "=", "\"pytorch\"", "\n", ")", "\n", "_assign_op_device_option", "(", "init_net", ",", "init_net_ssa", ",", "init_net_device_types", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_export.export_caffe2_detection_model": [[129, 173], ["copy.deepcopy", "isinstance", "hasattr", "logger.info", "caffe2_export.export_onnx_model", "caffe2.python.onnx.backend.Caffe2Backend.onnx_graph_to_caffe2_net", "tabulate.tabulate", "logger.info", "shared.fuse_alias_placeholder", "any", "shared.get_params_from_init_net", "shared.remove_reshape_for_fc", "shared.construct_init_net_from_params", "shared.group_norm_replace_aten_with_caffe2", "copy.deepcopy.encode_additional_info", "logger.info", "logger.info", "shared.fuse_copy_between_cpu_and_gpu", "shared.remove_dead_end_ops", "caffe2_export._assign_device_option", "termcolor.colored", "caffe2_export._op_stats", "caffe2_export._op_stats", "type"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.export_onnx_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.fuse_alias_placeholder", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_params_from_init_net", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.remove_reshape_for_fc", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.construct_init_net_from_params", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.group_norm_replace_aten_with_caffe2", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2RetinaNet.encode_additional_info", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.fuse_copy_between_cpu_and_gpu", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.remove_dead_end_ops", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_export._assign_device_option", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_export._op_stats", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_export._op_stats"], ["", "def", "export_caffe2_detection_model", "(", "model", ":", "torch", ".", "nn", ".", "Module", ",", "tensor_inputs", ":", "List", "[", "torch", ".", "Tensor", "]", ")", ":", "\n", "    ", "\"\"\"\n    Export a caffe2-compatible Detectron2 model to caffe2 format via ONNX.\n\n    Arg:\n        model: a caffe2-compatible version of detectron2 model, defined in caffe2_modeling.py\n        tensor_inputs: a list of tensors that caffe2 model takes as input.\n    \"\"\"", "\n", "model", "=", "copy", ".", "deepcopy", "(", "model", ")", "\n", "assert", "isinstance", "(", "model", ",", "torch", ".", "nn", ".", "Module", ")", "\n", "assert", "hasattr", "(", "model", ",", "\"encode_additional_info\"", ")", "\n", "\n", "# Export via ONNX", "\n", "logger", ".", "info", "(", "\n", "\"Exporting a {} model via ONNX ...\"", ".", "format", "(", "type", "(", "model", ")", ".", "__name__", ")", "\n", "+", "\" Some warnings from ONNX are expected and are usually not to worry about.\"", "\n", ")", "\n", "onnx_model", "=", "export_onnx_model", "(", "model", ",", "(", "tensor_inputs", ",", ")", ")", "\n", "# Convert ONNX model to Caffe2 protobuf", "\n", "init_net", ",", "predict_net", "=", "Caffe2Backend", ".", "onnx_graph_to_caffe2_net", "(", "onnx_model", ")", "\n", "ops_table", "=", "[", "[", "op", ".", "type", ",", "op", ".", "input", ",", "op", ".", "output", "]", "for", "op", "in", "predict_net", ".", "op", "]", "\n", "table", "=", "tabulate", "(", "ops_table", ",", "headers", "=", "[", "\"type\"", ",", "\"input\"", ",", "\"output\"", "]", ",", "tablefmt", "=", "\"pipe\"", ")", "\n", "logger", ".", "info", "(", "\n", "\"ONNX export Done. Exported predict_net (before optimizations):\\n\"", "+", "colored", "(", "table", ",", "\"cyan\"", ")", "\n", ")", "\n", "\n", "# Apply protobuf optimization", "\n", "fuse_alias_placeholder", "(", "predict_net", ",", "init_net", ")", "\n", "if", "any", "(", "t", ".", "device", ".", "type", "!=", "\"cpu\"", "for", "t", "in", "tensor_inputs", ")", ":", "\n", "        ", "fuse_copy_between_cpu_and_gpu", "(", "predict_net", ")", "\n", "remove_dead_end_ops", "(", "init_net", ")", "\n", "_assign_device_option", "(", "predict_net", ",", "init_net", ",", "tensor_inputs", ")", "\n", "", "params", ",", "device_options", "=", "get_params_from_init_net", "(", "init_net", ")", "\n", "predict_net", ",", "params", "=", "remove_reshape_for_fc", "(", "predict_net", ",", "params", ")", "\n", "init_net", "=", "construct_init_net_from_params", "(", "params", ",", "device_options", ")", "\n", "group_norm_replace_aten_with_caffe2", "(", "predict_net", ")", "\n", "\n", "# Record necessary information for running the pb model in Detectron2 system.", "\n", "model", ".", "encode_additional_info", "(", "predict_net", ",", "init_net", ")", "\n", "\n", "logger", ".", "info", "(", "\"Operators used in predict_net: \\n{}\"", ".", "format", "(", "_op_stats", "(", "predict_net", ")", ")", ")", "\n", "logger", ".", "info", "(", "\"Operators used in init_net: \\n{}\"", ".", "format", "(", "_op_stats", "(", "init_net", ")", ")", ")", "\n", "\n", "return", "predict_net", ",", "init_net", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_export.run_and_save_graph": [[175, 208], ["logger.info", "shared.save_graph", "logger.info", "shared.ScopedWS", "ws.RunNetOnce", "set", "zip", "logger.info", "shared.save_graph", "ws.Blobs", "ws.FeedBlob", "ws.RunNetOnce", "ws.FetchBlob", "logger.warning", "ws.Blobs", "isinstance", "str"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Model.save_graph", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Model.save_graph"], ["", "def", "run_and_save_graph", "(", "predict_net", ",", "init_net", ",", "tensor_inputs", ",", "graph_save_path", ")", ":", "\n", "    ", "\"\"\"\n    Run the caffe2 model on given inputs, recording the shape and draw the graph.\n\n    predict_net/init_net: caffe2 model.\n    tensor_inputs: a list of tensors that caffe2 model takes as input.\n    graph_save_path: path for saving graph of exported model.\n    \"\"\"", "\n", "\n", "logger", ".", "info", "(", "\"Saving graph of ONNX exported model to {} ...\"", ".", "format", "(", "graph_save_path", ")", ")", "\n", "save_graph", "(", "predict_net", ",", "graph_save_path", ",", "op_only", "=", "False", ")", "\n", "\n", "# Run the exported Caffe2 net", "\n", "logger", ".", "info", "(", "\"Running ONNX exported model ...\"", ")", "\n", "with", "ScopedWS", "(", "\"__ws_tmp__\"", ",", "True", ")", "as", "ws", ":", "\n", "        ", "ws", ".", "RunNetOnce", "(", "init_net", ")", "\n", "initialized_blobs", "=", "set", "(", "ws", ".", "Blobs", "(", ")", ")", "\n", "uninitialized", "=", "[", "inp", "for", "inp", "in", "predict_net", ".", "external_input", "if", "inp", "not", "in", "initialized_blobs", "]", "\n", "for", "name", ",", "blob", "in", "zip", "(", "uninitialized", ",", "tensor_inputs", ")", ":", "\n", "            ", "ws", ".", "FeedBlob", "(", "name", ",", "blob", ")", "\n", "\n", "", "try", ":", "\n", "            ", "ws", ".", "RunNetOnce", "(", "predict_net", ")", "\n", "", "except", "RuntimeError", "as", "e", ":", "\n", "            ", "logger", ".", "warning", "(", "\"Encountered RuntimeError: \\n{}\"", ".", "format", "(", "str", "(", "e", ")", ")", ")", "\n", "\n", "", "ws_blobs", "=", "{", "b", ":", "ws", ".", "FetchBlob", "(", "b", ")", "for", "b", "in", "ws", ".", "Blobs", "(", ")", "}", "\n", "blob_sizes", "=", "{", "b", ":", "ws_blobs", "[", "b", "]", ".", "shape", "for", "b", "in", "ws_blobs", "if", "isinstance", "(", "ws_blobs", "[", "b", "]", ",", "np", ".", "ndarray", ")", "}", "\n", "\n", "logger", ".", "info", "(", "\"Saving graph with blob shapes to {} ...\"", ".", "format", "(", "graph_save_path", ")", ")", "\n", "save_graph", "(", "predict_net", ",", "graph_save_path", ",", "op_only", "=", "False", ",", "blob_sizes", "=", "blob_sizes", ")", "\n", "\n", "return", "ws_blobs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.Caffe2Boxes.__init__": [[29, 35], ["isinstance", "tensor.size", "tensor.dim", "tensor.size"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "tensor", ")", ":", "\n", "        ", "assert", "isinstance", "(", "tensor", ",", "torch", ".", "Tensor", ")", "\n", "assert", "tensor", ".", "dim", "(", ")", "==", "2", "and", "tensor", ".", "size", "(", "-", "1", ")", "in", "[", "4", ",", "5", ",", "6", "]", ",", "tensor", ".", "size", "(", ")", "\n", "# TODO: make tensor immutable when dim is Nx5 for Boxes,", "\n", "# and Nx6 for RotatedBoxes?", "\n", "self", ".", "tensor", "=", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.__init__": [[48, 57], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "im_info", ",", "indices", ",", "extra_fields", "=", "None", ")", ":", "\n", "# [N, 3] -> (H, W, Scale)", "\n", "        ", "self", ".", "im_info", "=", "im_info", "\n", "# [N,] -> indice of batch to which the instance belongs", "\n", "self", ".", "indices", "=", "indices", "\n", "# [N, ...]", "\n", "self", ".", "batch_extra_fields", "=", "extra_fields", "or", "{", "}", "\n", "\n", "self", ".", "image_size", "=", "self", ".", "im_info", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.get_fields": [[58, 71], ["c10.InstancesList.batch_extra_fields.items"], "methods", ["None"], ["", "def", "get_fields", "(", "self", ")", ":", "\n", "        ", "\"\"\" like `get_fields` in the Instances object,\n        but return each field in tensor representations \"\"\"", "\n", "ret", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "self", ".", "batch_extra_fields", ".", "items", "(", ")", ":", "\n", "# if isinstance(v, torch.Tensor):", "\n", "#     tensor_rep = v", "\n", "# elif isinstance(v, (Boxes, Keypoints)):", "\n", "#     tensor_rep = v.tensor", "\n", "# else:", "\n", "#     raise ValueError(\"Can't find tensor representation for: {}\".format())", "\n", "            ", "ret", "[", "k", "]", "=", "v", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has": [[72, 74], ["None"], "methods", ["None"], ["", "def", "has", "(", "self", ",", "name", ")", ":", "\n", "        ", "return", "name", "in", "self", ".", "batch_extra_fields", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set": [[75, 82], ["len", "len", "len", "len"], "methods", ["None"], ["", "def", "set", "(", "self", ",", "name", ",", "value", ")", ":", "\n", "        ", "data_len", "=", "len", "(", "value", ")", "\n", "if", "len", "(", "self", ".", "batch_extra_fields", ")", ":", "\n", "            ", "assert", "(", "\n", "len", "(", "self", ")", "==", "data_len", "\n", ")", ",", "\"Adding a field of length {} to a Instances of length {}\"", ".", "format", "(", "data_len", ",", "len", "(", "self", ")", ")", "\n", "", "self", ".", "batch_extra_fields", "[", "name", "]", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.__setattr__": [[83, 88], ["object.__setattr__", "c10.InstancesList.set"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.__setattr__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["", "def", "__setattr__", "(", "self", ",", "name", ",", "val", ")", ":", "\n", "        ", "if", "name", "in", "[", "\"im_info\"", ",", "\"indices\"", ",", "\"batch_extra_fields\"", ",", "\"image_size\"", "]", ":", "\n", "            ", "super", "(", ")", ".", "__setattr__", "(", "name", ",", "val", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "set", "(", "name", ",", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.__getattr__": [[89, 93], ["AttributeError"], "methods", ["None"], ["", "", "def", "__getattr__", "(", "self", ",", "name", ")", ":", "\n", "        ", "if", "name", "not", "in", "self", ".", "batch_extra_fields", ":", "\n", "            ", "raise", "AttributeError", "(", "\"Cannot find field '{}' in the given Instances!\"", ".", "format", "(", "name", ")", ")", "\n", "", "return", "self", ".", "batch_extra_fields", "[", "name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.__len__": [[94, 96], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten": [[97, 105], ["c10.InstancesList.batch_extra_fields.items", "isinstance", "ret.append", "ret.append"], "methods", ["None"], ["", "def", "flatten", "(", "self", ")", ":", "\n", "        ", "ret", "=", "[", "]", "\n", "for", "_", ",", "v", "in", "self", ".", "batch_extra_fields", ".", "items", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "v", ",", "(", "Boxes", ",", "Keypoints", ")", ")", ":", "\n", "                ", "ret", ".", "append", "(", "v", ".", "tensor", ")", "\n", "", "else", ":", "\n", "                ", "ret", ".", "append", "(", "v", ")", "\n", "", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.to_d2_instances_list": [[106, 145], ["enumerate", "isinstance", "all", "detectron2.structures.Instances", "instances_list.batch_extra_fields.items", "ret.append", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "isinstance", "isinstance", "issubclass", "isinstance", "detectron2.structures.Instances.set", "isinstance", "detectron2.structures.Instances.set", "issubclass", "int", "int", "detectron2.structures.Instances.set", "detectron2.structures.Boxes", "detectron2.structures.Instances.set", "issubclass", "info[].item", "info[].item", "detectron2.structures.Keypoints", "detectron2.structures.Instances.set", "ValueError"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["", "@", "staticmethod", "\n", "def", "to_d2_instances_list", "(", "instances_list", ")", ":", "\n", "        ", "\"\"\"\n        Convert InstancesList to List[Instances]. The input `instances_list` can\n        also be a List[Instances], in this case this method is a non-op.\n        \"\"\"", "\n", "if", "not", "isinstance", "(", "instances_list", ",", "InstancesList", ")", ":", "\n", "            ", "assert", "all", "(", "isinstance", "(", "x", ",", "Instances", ")", "for", "x", "in", "instances_list", ")", "\n", "return", "instances_list", "\n", "\n", "", "ret", "=", "[", "]", "\n", "for", "i", ",", "info", "in", "enumerate", "(", "instances_list", ".", "im_info", ")", ":", "\n", "            ", "instances", "=", "Instances", "(", "torch", ".", "Size", "(", "[", "int", "(", "info", "[", "0", "]", ".", "item", "(", ")", ")", ",", "int", "(", "info", "[", "1", "]", ".", "item", "(", ")", ")", "]", ")", ")", "\n", "\n", "ids", "=", "instances_list", ".", "indices", "==", "i", "\n", "for", "k", ",", "v", "in", "instances_list", ".", "batch_extra_fields", ".", "items", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "v", ",", "torch", ".", "Tensor", ")", ":", "\n", "                    ", "instances", ".", "set", "(", "k", ",", "v", "[", "ids", "]", ")", "\n", "continue", "\n", "", "elif", "isinstance", "(", "v", ",", "Boxes", ")", ":", "\n", "                    ", "instances", ".", "set", "(", "k", ",", "v", "[", "ids", ",", "-", "4", ":", "]", ")", "\n", "continue", "\n", "\n", "", "target_type", ",", "tensor_source", "=", "v", "\n", "assert", "isinstance", "(", "tensor_source", ",", "torch", ".", "Tensor", ")", "\n", "assert", "tensor_source", ".", "shape", "[", "0", "]", "==", "instances_list", ".", "indices", ".", "shape", "[", "0", "]", "\n", "tensor_source", "=", "tensor_source", "[", "ids", "]", "\n", "\n", "if", "issubclass", "(", "target_type", ",", "Boxes", ")", ":", "\n", "                    ", "instances", ".", "set", "(", "k", ",", "Boxes", "(", "tensor_source", "[", ":", ",", "-", "4", ":", "]", ")", ")", "\n", "", "elif", "issubclass", "(", "target_type", ",", "Keypoints", ")", ":", "\n", "                    ", "instances", ".", "set", "(", "k", ",", "Keypoints", "(", "tensor_source", ")", ")", "\n", "", "elif", "issubclass", "(", "target_type", ",", "torch", ".", "Tensor", ")", ":", "\n", "                    ", "instances", ".", "set", "(", "k", ",", "tensor_source", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "\"Can't handle targe type: {}\"", ".", "format", "(", "target_type", ")", ")", "\n", "\n", "", "", "ret", ".", "append", "(", "instances", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.Caffe2Compatible._get_tensor_mode": [[148, 150], ["None"], "methods", ["None"], ["    ", "def", "_get_tensor_mode", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_tensor_mode", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.Caffe2Compatible._set_tensor_mode": [[151, 153], ["None"], "methods", ["None"], ["", "def", "_set_tensor_mode", "(", "self", ",", "v", ")", ":", "\n", "        ", "self", ".", "_tensor_mode", "=", "v", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.Caffe2RPN.forward": [[161, 246], ["c10.Caffe2RPN.rpn_head", "isinstance", "isinstance", "zip", "c10.Caffe2RPN.c2_postprocess", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "iter", "scores.detach.detach.detach", "bbox_deltas.detach.detach.detach", "torch.ops._caffe2.GenerateProposals", "torch.ops._caffe2.GenerateProposals", "torch.ops._caffe2.GenerateProposals", "torch.ops._caffe2.GenerateProposals", "rpn_rois_list.append", "rpn_roi_probs_list.append", "len", "list", "int", "int", "torch.ops._caffe2.CollectRpnProposals", "torch.ops._caffe2.CollectRpnProposals", "torch.ops._caffe2.CollectRpnProposals", "torch.ops._caffe2.CollectRpnProposals", "shared.to_device", "len", "len", "shared.to_device", "math.log2", "math.log2", "len", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "len", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.Caffe2RPN.c2_postprocess", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.iter", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.to_device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.to_device"], ["    ", "def", "forward", "(", "self", ",", "images", ",", "features", ",", "gt_instances", "=", "None", ")", ":", "\n", "        ", "assert", "not", "self", ".", "training", "\n", "\n", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", "\n", "objectness_logits_pred", ",", "anchor_deltas_pred", "=", "self", ".", "rpn_head", "(", "features", ")", "\n", "\n", "assert", "isinstance", "(", "images", ",", "ImageList", ")", "\n", "if", "self", ".", "tensor_mode", ":", "\n", "            ", "im_info", "=", "images", ".", "image_sizes", "\n", "", "else", ":", "\n", "            ", "im_info", "=", "torch", ".", "Tensor", "(", "\n", "[", "[", "im_sz", "[", "0", "]", ",", "im_sz", "[", "1", "]", ",", "torch", ".", "Tensor", "(", "[", "1.0", "]", ")", "]", "for", "im_sz", "in", "images", ".", "image_sizes", "]", "\n", ")", ".", "to", "(", "images", ".", "tensor", ".", "device", ")", "\n", "", "assert", "isinstance", "(", "im_info", ",", "torch", ".", "Tensor", ")", "\n", "\n", "rpn_rois_list", "=", "[", "]", "\n", "rpn_roi_probs_list", "=", "[", "]", "\n", "for", "scores", ",", "bbox_deltas", ",", "cell_anchors_tensor", ",", "feat_stride", "in", "zip", "(", "\n", "objectness_logits_pred", ",", "\n", "anchor_deltas_pred", ",", "\n", "iter", "(", "self", ".", "anchor_generator", ".", "cell_anchors", ")", ",", "\n", "self", ".", "anchor_generator", ".", "strides", ",", "\n", ")", ":", "\n", "            ", "scores", "=", "scores", ".", "detach", "(", ")", "\n", "bbox_deltas", "=", "bbox_deltas", ".", "detach", "(", ")", "\n", "\n", "rpn_rois", ",", "rpn_roi_probs", "=", "torch", ".", "ops", ".", "_caffe2", ".", "GenerateProposals", "(", "\n", "scores", ",", "\n", "bbox_deltas", ",", "\n", "im_info", ",", "\n", "cell_anchors_tensor", ",", "\n", "spatial_scale", "=", "1.0", "/", "feat_stride", ",", "\n", "pre_nms_topN", "=", "self", ".", "pre_nms_topk", "[", "self", ".", "training", "]", ",", "\n", "post_nms_topN", "=", "self", ".", "post_nms_topk", "[", "self", ".", "training", "]", ",", "\n", "nms_thresh", "=", "self", ".", "nms_thresh", ",", "\n", "min_size", "=", "self", ".", "min_box_size", ",", "\n", "# correct_transform_coords=True,  # deprecated argument", "\n", "angle_bound_on", "=", "True", ",", "# Default", "\n", "angle_bound_lo", "=", "-", "180", ",", "\n", "angle_bound_hi", "=", "180", ",", "\n", "clip_angle_thresh", "=", "1.0", ",", "# Default", "\n", "legacy_plus_one", "=", "False", ",", "\n", ")", "\n", "rpn_rois_list", ".", "append", "(", "rpn_rois", ")", "\n", "rpn_roi_probs_list", ".", "append", "(", "rpn_roi_probs", ")", "\n", "\n", "# For FPN in D2, in RPN all proposals from different levels are concated", "\n", "# together, ranked and picked by top post_nms_topk. Then in ROIPooler", "\n", "# it calculates level_assignments and calls the RoIAlign from", "\n", "# the corresponding level.", "\n", "\n", "", "if", "len", "(", "objectness_logits_pred", ")", "==", "1", ":", "\n", "            ", "rpn_rois", "=", "rpn_rois_list", "[", "0", "]", "\n", "rpn_roi_probs", "=", "rpn_roi_probs_list", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "assert", "len", "(", "rpn_rois_list", ")", "==", "len", "(", "rpn_roi_probs_list", ")", "\n", "rpn_post_nms_topN", "=", "self", ".", "post_nms_topk", "[", "self", ".", "training", "]", "\n", "\n", "device", "=", "rpn_rois_list", "[", "0", "]", ".", "device", "\n", "input_list", "=", "[", "to_device", "(", "x", ",", "\"cpu\"", ")", "for", "x", "in", "(", "rpn_rois_list", "+", "rpn_roi_probs_list", ")", "]", "\n", "\n", "# TODO remove this after confirming rpn_max_level/rpn_min_level", "\n", "# is not needed in CollectRpnProposals.", "\n", "feature_strides", "=", "list", "(", "self", ".", "anchor_generator", ".", "strides", ")", "\n", "rpn_min_level", "=", "int", "(", "math", ".", "log2", "(", "feature_strides", "[", "0", "]", ")", ")", "\n", "rpn_max_level", "=", "int", "(", "math", ".", "log2", "(", "feature_strides", "[", "-", "1", "]", ")", ")", "\n", "assert", "(", "rpn_max_level", "-", "rpn_min_level", "+", "1", ")", "==", "len", "(", "\n", "rpn_rois_list", "\n", ")", ",", "\"CollectRpnProposals requires continuous levels\"", "\n", "\n", "rpn_rois", "=", "torch", ".", "ops", ".", "_caffe2", ".", "CollectRpnProposals", "(", "\n", "input_list", ",", "\n", "# NOTE: in current implementation, rpn_max_level and rpn_min_level", "\n", "# are not needed, only the subtraction of two matters and it", "\n", "# can be infer from the number of inputs. Keep them now for", "\n", "# consistency.", "\n", "rpn_max_level", "=", "2", "+", "len", "(", "rpn_rois_list", ")", "-", "1", ",", "\n", "rpn_min_level", "=", "2", ",", "\n", "rpn_post_nms_topN", "=", "rpn_post_nms_topN", ",", "\n", ")", "\n", "rpn_rois", "=", "to_device", "(", "rpn_rois", ",", "device", ")", "\n", "rpn_roi_probs", "=", "[", "]", "\n", "\n", "", "proposals", "=", "self", ".", "c2_postprocess", "(", "im_info", ",", "rpn_rois", ",", "rpn_roi_probs", ",", "self", ".", "tensor_mode", ")", "\n", "return", "proposals", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.Caffe2RPN.c2_postprocess": [[247, 262], ["c10.InstancesList", "c10.InstancesList.to_d2_instances_list", "c10.Caffe2Boxes"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.to_d2_instances_list"], ["", "@", "staticmethod", "\n", "def", "c2_postprocess", "(", "im_info", ",", "rpn_rois", ",", "rpn_roi_probs", ",", "tensor_mode", ")", ":", "\n", "        ", "proposals", "=", "InstancesList", "(", "\n", "im_info", "=", "im_info", ",", "\n", "indices", "=", "rpn_rois", "[", ":", ",", "0", "]", ",", "\n", "extra_fields", "=", "{", "\n", "\"proposal_boxes\"", ":", "Caffe2Boxes", "(", "rpn_rois", ")", ",", "\n", "\"objectness_logits\"", ":", "(", "torch", ".", "Tensor", ",", "rpn_roi_probs", ")", ",", "\n", "}", ",", "\n", ")", "\n", "if", "not", "tensor_mode", ":", "\n", "            ", "proposals", "=", "InstancesList", ".", "to_d2_instances_list", "(", "proposals", ")", "\n", "", "else", ":", "\n", "            ", "proposals", "=", "[", "proposals", "]", "\n", "", "return", "proposals", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.Caffe2ROIPooler.c2_preprocess": [[265, 275], ["all", "all", "detectron2.modeling.poolers.convert_boxes_to_pooler_format", "isinstance", "isinstance", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.poolers.convert_boxes_to_pooler_format"], ["    ", "@", "staticmethod", "\n", "def", "c2_preprocess", "(", "box_lists", ")", ":", "\n", "        ", "assert", "all", "(", "isinstance", "(", "x", ",", "Boxes", ")", "for", "x", "in", "box_lists", ")", "\n", "if", "all", "(", "isinstance", "(", "x", ",", "Caffe2Boxes", ")", "for", "x", "in", "box_lists", ")", ":", "\n", "# input is pure-tensor based", "\n", "            ", "assert", "len", "(", "box_lists", ")", "==", "1", "\n", "pooler_fmt_boxes", "=", "box_lists", "[", "0", "]", ".", "tensor", "\n", "", "else", ":", "\n", "            ", "pooler_fmt_boxes", "=", "poolers", ".", "convert_boxes_to_pooler_format", "(", "box_lists", ")", "\n", "", "return", "pooler_fmt_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.Caffe2ROIPooler.forward": [[276, 343], ["c10.Caffe2ROIPooler.c2_preprocess", "len", "torch.ops._caffe2.DistributeFpnProposals", "torch.ops._caffe2.DistributeFpnProposals", "torch.ops._caffe2.DistributeFpnProposals", "torch.ops._caffe2.DistributeFpnProposals", "zip", "detectron2.layers.cat", "torch.ops._caffe2.BatchPermutation", "torch.ops._caffe2.BatchPermutation", "torch.ops._caffe2.BatchPermutation", "torch.ops._caffe2.BatchPermutation", "isinstance", "c2_roi_align", "shared.to_device", "shared.to_device", "isinstance", "c2_roi_align", "roi_feat_fpn_list.append", "bool", "float", "int", "int", "int", "float", "int", "int", "int"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.Caffe2ROIPooler.c2_preprocess", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.to_device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.to_device"], ["", "def", "forward", "(", "self", ",", "x", ",", "box_lists", ")", ":", "\n", "        ", "assert", "not", "self", ".", "training", "\n", "\n", "pooler_fmt_boxes", "=", "self", ".", "c2_preprocess", "(", "box_lists", ")", "\n", "num_level_assignments", "=", "len", "(", "self", ".", "level_poolers", ")", "\n", "\n", "if", "num_level_assignments", "==", "1", ":", "\n", "            ", "if", "isinstance", "(", "self", ".", "level_poolers", "[", "0", "]", ",", "ROIAlignRotated", ")", ":", "\n", "                ", "c2_roi_align", "=", "torch", ".", "ops", ".", "_caffe2", ".", "RoIAlignRotated", "\n", "aligned", "=", "True", "\n", "", "else", ":", "\n", "                ", "c2_roi_align", "=", "torch", ".", "ops", ".", "_caffe2", ".", "RoIAlign", "\n", "aligned", "=", "self", ".", "level_poolers", "[", "0", "]", ".", "aligned", "\n", "\n", "", "out", "=", "c2_roi_align", "(", "\n", "x", "[", "0", "]", ",", "\n", "pooler_fmt_boxes", ",", "\n", "order", "=", "\"NCHW\"", ",", "\n", "spatial_scale", "=", "float", "(", "self", ".", "level_poolers", "[", "0", "]", ".", "spatial_scale", ")", ",", "\n", "pooled_h", "=", "int", "(", "self", ".", "output_size", "[", "0", "]", ")", ",", "\n", "pooled_w", "=", "int", "(", "self", ".", "output_size", "[", "1", "]", ")", ",", "\n", "sampling_ratio", "=", "int", "(", "self", ".", "level_poolers", "[", "0", "]", ".", "sampling_ratio", ")", ",", "\n", "aligned", "=", "aligned", ",", "\n", ")", "\n", "return", "out", "\n", "\n", "", "device", "=", "pooler_fmt_boxes", ".", "device", "\n", "assert", "(", "\n", "self", ".", "max_level", "-", "self", ".", "min_level", "+", "1", "==", "4", "\n", ")", ",", "\"Currently DistributeFpnProposals only support 4 levels\"", "\n", "fpn_outputs", "=", "torch", ".", "ops", ".", "_caffe2", ".", "DistributeFpnProposals", "(", "\n", "to_device", "(", "pooler_fmt_boxes", ",", "\"cpu\"", ")", ",", "\n", "roi_canonical_scale", "=", "self", ".", "canonical_box_size", ",", "\n", "roi_canonical_level", "=", "self", ".", "canonical_level", ",", "\n", "roi_max_level", "=", "self", ".", "max_level", ",", "\n", "roi_min_level", "=", "self", ".", "min_level", ",", "\n", "legacy_plus_one", "=", "False", ",", "\n", ")", "\n", "fpn_outputs", "=", "[", "to_device", "(", "x", ",", "device", ")", "for", "x", "in", "fpn_outputs", "]", "\n", "\n", "rois_fpn_list", "=", "fpn_outputs", "[", ":", "-", "1", "]", "\n", "rois_idx_restore_int32", "=", "fpn_outputs", "[", "-", "1", "]", "\n", "\n", "roi_feat_fpn_list", "=", "[", "]", "\n", "for", "roi_fpn", ",", "x_level", ",", "pooler", "in", "zip", "(", "rois_fpn_list", ",", "x", ",", "self", ".", "level_poolers", ")", ":", "\n", "            ", "if", "isinstance", "(", "pooler", ",", "ROIAlignRotated", ")", ":", "\n", "                ", "c2_roi_align", "=", "torch", ".", "ops", ".", "_caffe2", ".", "RoIAlignRotated", "\n", "aligned", "=", "True", "\n", "", "else", ":", "\n", "                ", "c2_roi_align", "=", "torch", ".", "ops", ".", "_caffe2", ".", "RoIAlign", "\n", "aligned", "=", "bool", "(", "pooler", ".", "aligned", ")", "\n", "\n", "", "roi_feat_fpn", "=", "c2_roi_align", "(", "\n", "x_level", ",", "\n", "roi_fpn", ",", "\n", "order", "=", "\"NCHW\"", ",", "\n", "spatial_scale", "=", "float", "(", "pooler", ".", "spatial_scale", ")", ",", "\n", "pooled_h", "=", "int", "(", "self", ".", "output_size", "[", "0", "]", ")", ",", "\n", "pooled_w", "=", "int", "(", "self", ".", "output_size", "[", "1", "]", ")", ",", "\n", "sampling_ratio", "=", "int", "(", "pooler", ".", "sampling_ratio", ")", ",", "\n", "aligned", "=", "aligned", ",", "\n", ")", "\n", "roi_feat_fpn_list", ".", "append", "(", "roi_feat_fpn", ")", "\n", "\n", "", "roi_feat_shuffled", "=", "cat", "(", "roi_feat_fpn_list", ",", "dim", "=", "0", ")", "\n", "roi_feat", "=", "torch", ".", "ops", ".", "_caffe2", ".", "BatchPermutation", "(", "roi_feat_shuffled", ",", "rois_idx_restore_int32", ")", "\n", "return", "roi_feat", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.Caffe2FastRCNNOutputsInference.__init__": [[346, 348], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "tensor_mode", ")", ":", "\n", "        ", "self", ".", "tensor_mode", "=", "tensor_mode", "# whether the output is caffe2 tensor mode", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.Caffe2FastRCNNOutputsInference.__call__": [[349, 469], ["torch.softmax", "torch.softmax", "type().cat", "torch.ops._caffe2.BBoxTransform", "torch.ops._caffe2.BBoxTransform", "torch.ops._caffe2.BBoxTransform", "torch.ops._caffe2.BBoxTransform", "shared.to_device", "shared.to_device", "torch.ops._caffe2.BoxWithNMSLimit", "torch.ops._caffe2.BoxWithNMSLimit", "torch.ops._caffe2.BoxWithNMSLimit", "torch.ops._caffe2.BoxWithNMSLimit", "shared.to_device", "shared.to_device", "shared.to_device", "shared.to_device", "shared.to_device", "shared.to_device", "detectron2.layers.cat", "shared.alias", "shared.alias", "shared.alias", "shared.alias", "shared.alias", "shared.alias", "c10.InstancesList", "len", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "detectron2.layers.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "shared.to_device", "shared.to_device", "shared.to_device", "shared.to_device", "shared.to_device", "shared.to_device", "roi_class_nms.to.to.to", "c10.InstancesList.to_d2_instances_list", "shared.alias.int().tolist", "list", "type", "float", "float", "int", "torch.full", "torch.full", "torch.full", "torch.full", "shared.alias.to().split", "torch.full", "torch.full", "torch.full", "torch.full", "enumerate", "c10.Caffe2Boxes", "shared.alias.int", "enumerate", "shared.alias.to", "int", "len", "x.item"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.to_device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.to_device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.to_device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.to_device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.to_device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.to_device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.to_device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.to_device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.alias", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.alias", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.alias", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.alias", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.alias", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.alias", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.to_device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.to_device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.to_device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.to_device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.to_device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.to_device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.to_d2_instances_list", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "__call__", "(", "self", ",", "box_predictor", ",", "predictions", ",", "proposals", ")", ":", "\n", "        ", "\"\"\" equivalent to FastRCNNOutputLayers.inference \"\"\"", "\n", "score_thresh", "=", "box_predictor", ".", "test_score_thresh", "\n", "nms_thresh", "=", "box_predictor", ".", "test_nms_thresh", "\n", "topk_per_image", "=", "box_predictor", ".", "test_topk_per_image", "\n", "is_rotated", "=", "len", "(", "box_predictor", ".", "box2box_transform", ".", "weights", ")", "==", "5", "\n", "\n", "if", "is_rotated", ":", "\n", "            ", "box_dim", "=", "5", "\n", "assert", "box_predictor", ".", "box2box_transform", ".", "weights", "[", "4", "]", "==", "1", ",", "(", "\n", "\"The weights for Rotated BBoxTransform in C2 have only 4 dimensions,\"", "\n", "+", "\" thus enforcing the angle weight to be 1 for now\"", "\n", ")", "\n", "box2box_transform_weights", "=", "box_predictor", ".", "box2box_transform", ".", "weights", "[", ":", "4", "]", "\n", "", "else", ":", "\n", "            ", "box_dim", "=", "4", "\n", "box2box_transform_weights", "=", "box_predictor", ".", "box2box_transform", ".", "weights", "\n", "\n", "", "class_logits", ",", "box_regression", "=", "predictions", "\n", "class_prob", "=", "F", ".", "softmax", "(", "class_logits", ",", "-", "1", ")", "\n", "\n", "assert", "box_regression", ".", "shape", "[", "1", "]", "%", "box_dim", "==", "0", "\n", "cls_agnostic_bbox_reg", "=", "box_regression", ".", "shape", "[", "1", "]", "//", "box_dim", "==", "1", "\n", "\n", "input_tensor_mode", "=", "proposals", "[", "0", "]", ".", "proposal_boxes", ".", "tensor", ".", "shape", "[", "1", "]", "==", "box_dim", "+", "1", "\n", "\n", "rois", "=", "type", "(", "proposals", "[", "0", "]", ".", "proposal_boxes", ")", ".", "cat", "(", "[", "p", ".", "proposal_boxes", "for", "p", "in", "proposals", "]", ")", "\n", "device", ",", "dtype", "=", "rois", ".", "tensor", ".", "device", ",", "rois", ".", "tensor", ".", "dtype", "\n", "if", "input_tensor_mode", ":", "\n", "            ", "im_info", "=", "proposals", "[", "0", "]", ".", "image_size", "\n", "rois", "=", "rois", ".", "tensor", "\n", "", "else", ":", "\n", "            ", "im_info", "=", "torch", ".", "Tensor", "(", "\n", "[", "[", "sz", "[", "0", "]", ",", "sz", "[", "1", "]", ",", "1.0", "]", "for", "sz", "in", "[", "x", ".", "image_size", "for", "x", "in", "proposals", "]", "]", "\n", ")", "\n", "batch_ids", "=", "cat", "(", "\n", "[", "\n", "torch", ".", "full", "(", "(", "b", ",", "1", ")", ",", "i", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "for", "i", ",", "b", "in", "enumerate", "(", "len", "(", "p", ")", "for", "p", "in", "proposals", ")", "\n", "]", ",", "\n", "dim", "=", "0", ",", "\n", ")", "\n", "rois", "=", "torch", ".", "cat", "(", "[", "batch_ids", ",", "rois", ".", "tensor", "]", ",", "dim", "=", "1", ")", "\n", "\n", "", "roi_pred_bbox", ",", "roi_batch_splits", "=", "torch", ".", "ops", ".", "_caffe2", ".", "BBoxTransform", "(", "\n", "to_device", "(", "rois", ",", "\"cpu\"", ")", ",", "\n", "to_device", "(", "box_regression", ",", "\"cpu\"", ")", ",", "\n", "to_device", "(", "im_info", ",", "\"cpu\"", ")", ",", "\n", "weights", "=", "box2box_transform_weights", ",", "\n", "apply_scale", "=", "True", ",", "\n", "rotated", "=", "is_rotated", ",", "\n", "angle_bound_on", "=", "True", ",", "\n", "angle_bound_lo", "=", "-", "180", ",", "\n", "angle_bound_hi", "=", "180", ",", "\n", "clip_angle_thresh", "=", "1.0", ",", "\n", "legacy_plus_one", "=", "False", ",", "\n", ")", "\n", "roi_pred_bbox", "=", "to_device", "(", "roi_pred_bbox", ",", "device", ")", "\n", "roi_batch_splits", "=", "to_device", "(", "roi_batch_splits", ",", "device", ")", "\n", "\n", "nms_outputs", "=", "torch", ".", "ops", ".", "_caffe2", ".", "BoxWithNMSLimit", "(", "\n", "to_device", "(", "class_prob", ",", "\"cpu\"", ")", ",", "\n", "to_device", "(", "roi_pred_bbox", ",", "\"cpu\"", ")", ",", "\n", "to_device", "(", "roi_batch_splits", ",", "\"cpu\"", ")", ",", "\n", "score_thresh", "=", "float", "(", "score_thresh", ")", ",", "\n", "nms", "=", "float", "(", "nms_thresh", ")", ",", "\n", "detections_per_im", "=", "int", "(", "topk_per_image", ")", ",", "\n", "soft_nms_enabled", "=", "False", ",", "\n", "soft_nms_method", "=", "\"linear\"", ",", "\n", "soft_nms_sigma", "=", "0.5", ",", "\n", "soft_nms_min_score_thres", "=", "0.001", ",", "\n", "rotated", "=", "is_rotated", ",", "\n", "cls_agnostic_bbox_reg", "=", "cls_agnostic_bbox_reg", ",", "\n", "input_boxes_include_bg_cls", "=", "False", ",", "\n", "output_classes_include_bg_cls", "=", "False", ",", "\n", "legacy_plus_one", "=", "False", ",", "\n", ")", "\n", "roi_score_nms", "=", "to_device", "(", "nms_outputs", "[", "0", "]", ",", "device", ")", "\n", "roi_bbox_nms", "=", "to_device", "(", "nms_outputs", "[", "1", "]", ",", "device", ")", "\n", "roi_class_nms", "=", "to_device", "(", "nms_outputs", "[", "2", "]", ",", "device", ")", "\n", "roi_batch_splits_nms", "=", "to_device", "(", "nms_outputs", "[", "3", "]", ",", "device", ")", "\n", "roi_keeps_nms", "=", "to_device", "(", "nms_outputs", "[", "4", "]", ",", "device", ")", "\n", "roi_keeps_size_nms", "=", "to_device", "(", "nms_outputs", "[", "5", "]", ",", "device", ")", "\n", "if", "not", "self", ".", "tensor_mode", ":", "\n", "            ", "roi_class_nms", "=", "roi_class_nms", ".", "to", "(", "torch", ".", "int64", ")", "\n", "\n", "", "roi_batch_ids", "=", "cat", "(", "\n", "[", "\n", "torch", ".", "full", "(", "(", "b", ",", "1", ")", ",", "i", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "for", "i", ",", "b", "in", "enumerate", "(", "int", "(", "x", ".", "item", "(", ")", ")", "for", "x", "in", "roi_batch_splits_nms", ")", "\n", "]", ",", "\n", "dim", "=", "0", ",", "\n", ")", "\n", "\n", "roi_class_nms", "=", "alias", "(", "roi_class_nms", ",", "\"class_nms\"", ")", "\n", "roi_score_nms", "=", "alias", "(", "roi_score_nms", ",", "\"score_nms\"", ")", "\n", "roi_bbox_nms", "=", "alias", "(", "roi_bbox_nms", ",", "\"bbox_nms\"", ")", "\n", "roi_batch_splits_nms", "=", "alias", "(", "roi_batch_splits_nms", ",", "\"batch_splits_nms\"", ")", "\n", "roi_keeps_nms", "=", "alias", "(", "roi_keeps_nms", ",", "\"keeps_nms\"", ")", "\n", "roi_keeps_size_nms", "=", "alias", "(", "roi_keeps_size_nms", ",", "\"keeps_size_nms\"", ")", "\n", "\n", "results", "=", "InstancesList", "(", "\n", "im_info", "=", "im_info", ",", "\n", "indices", "=", "roi_batch_ids", "[", ":", ",", "0", "]", ",", "\n", "extra_fields", "=", "{", "\n", "\"pred_boxes\"", ":", "Caffe2Boxes", "(", "roi_bbox_nms", ")", ",", "\n", "\"scores\"", ":", "roi_score_nms", ",", "\n", "\"pred_classes\"", ":", "roi_class_nms", ",", "\n", "}", ",", "\n", ")", "\n", "\n", "if", "not", "self", ".", "tensor_mode", ":", "\n", "            ", "results", "=", "InstancesList", ".", "to_d2_instances_list", "(", "results", ")", "\n", "batch_splits", "=", "roi_batch_splits_nms", ".", "int", "(", ")", ".", "tolist", "(", ")", "\n", "kept_indices", "=", "list", "(", "roi_keeps_nms", ".", "to", "(", "torch", ".", "int64", ")", ".", "split", "(", "batch_splits", ")", ")", "\n", "", "else", ":", "\n", "            ", "results", "=", "[", "results", "]", "\n", "kept_indices", "=", "[", "roi_keeps_nms", "]", "\n", "\n", "", "return", "results", ",", "kept_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.Caffe2MaskRCNNInference.__call__": [[472, 481], ["all", "pred_mask_logits.sigmoid", "shared.alias", "detectron2.modeling.roi_heads.mask_head.mask_rcnn_inference", "isinstance", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.alias", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.mask_head.mask_rcnn_inference"], ["    ", "def", "__call__", "(", "self", ",", "pred_mask_logits", ",", "pred_instances", ")", ":", "\n", "        ", "\"\"\" equivalent to mask_head.mask_rcnn_inference \"\"\"", "\n", "if", "all", "(", "isinstance", "(", "x", ",", "InstancesList", ")", "for", "x", "in", "pred_instances", ")", ":", "\n", "            ", "assert", "len", "(", "pred_instances", ")", "==", "1", "\n", "mask_probs_pred", "=", "pred_mask_logits", ".", "sigmoid", "(", ")", "\n", "mask_probs_pred", "=", "alias", "(", "mask_probs_pred", ",", "\"mask_fcn_probs\"", ")", "\n", "pred_instances", "[", "0", "]", ".", "pred_masks", "=", "mask_probs_pred", "\n", "", "else", ":", "\n", "            ", "mask_rcnn_inference", "(", "pred_mask_logits", ",", "pred_instances", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.Caffe2KeypointRCNNInference.__init__": [[484, 486], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "use_heatmap_max_keypoint", ")", ":", "\n", "        ", "self", ".", "use_heatmap_max_keypoint", "=", "use_heatmap_max_keypoint", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.Caffe2KeypointRCNNInference.__call__": [[487, 504], ["shared.alias", "all", "isinstance", "len", "torch.ops._caffe2.HeatmapMaxKeypoint", "torch.ops._caffe2.HeatmapMaxKeypoint", "torch.ops._caffe2.HeatmapMaxKeypoint", "torch.ops._caffe2.HeatmapMaxKeypoint", "shared.to_device", "shared.alias", "shared.to_device"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.alias", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.to_device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.alias", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.to_device"], ["", "def", "__call__", "(", "self", ",", "pred_keypoint_logits", ",", "pred_instances", ")", ":", "\n", "# just return the keypoint heatmap for now,", "\n", "# there will be option to call HeatmapMaxKeypointOp", "\n", "        ", "output", "=", "alias", "(", "pred_keypoint_logits", ",", "\"kps_score\"", ")", "\n", "if", "all", "(", "isinstance", "(", "x", ",", "InstancesList", ")", "for", "x", "in", "pred_instances", ")", ":", "\n", "            ", "assert", "len", "(", "pred_instances", ")", "==", "1", "\n", "if", "self", ".", "use_heatmap_max_keypoint", ":", "\n", "                ", "device", "=", "output", ".", "device", "\n", "output", "=", "torch", ".", "ops", ".", "_caffe2", ".", "HeatmapMaxKeypoint", "(", "\n", "to_device", "(", "output", ",", "\"cpu\"", ")", ",", "\n", "pred_instances", "[", "0", "]", ".", "pred_boxes", ".", "tensor", ",", "\n", "should_output_softmax", "=", "True", ",", "# worth make it configerable?", "\n", ")", "\n", "output", "=", "to_device", "(", "output", ",", "device", ")", "\n", "output", "=", "alias", "(", "output", ",", "\"keypoints_out\"", ")", "\n", "", "pred_instances", "[", "0", "]", ".", "pred_keypoints", "=", "output", "\n", "", "return", "pred_keypoint_logits", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Tracer.__init__": [[72, 92], ["isinstance", "isinstance", "type", "api.add_export_config"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.add_export_config"], ["def", "__init__", "(", "self", ",", "cfg", ",", "model", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            cfg (CfgNode): a detectron2 config, with extra export-related options\n                added by :func:`add_export_config`.\n            model (nn.Module): a model built by\n                :func:`detectron2.modeling.build_model`. Weights have to be already\n                loaded to this model.\n            inputs: sample inputs that the given model takes for inference.\n                Will be used to trace the model. Random input with no detected objects\n                will not work if the model has data-dependent control flow (e.g., R-CNN).\n        \"\"\"", "\n", "assert", "isinstance", "(", "cfg", ",", "CN", ")", ",", "cfg", "\n", "assert", "isinstance", "(", "model", ",", "torch", ".", "nn", ".", "Module", ")", ",", "type", "(", "model", ")", "\n", "if", "\"EXPORT_CAFFE2\"", "not", "in", "cfg", ":", "\n", "            ", "cfg", "=", "add_export_config", "(", "cfg", ")", "# will just the defaults", "\n", "\n", "", "self", ".", "cfg", "=", "cfg", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "inputs", "=", "inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Tracer._get_traceable": [[93, 99], ["C2MetaArch", "C2MetaArch.get_caffe2_inputs", "copy.deepcopy"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2MetaArch.get_caffe2_inputs"], ["", "def", "_get_traceable", "(", "self", ")", ":", "\n", "# TODO how to make it extensible to support custom models", "\n", "        ", "C2MetaArch", "=", "META_ARCH_CAFFE2_EXPORT_TYPE_MAP", "[", "self", ".", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "]", "\n", "traceable_model", "=", "C2MetaArch", "(", "self", ".", "cfg", ",", "copy", ".", "deepcopy", "(", "self", ".", "model", ")", ")", "\n", "traceable_inputs", "=", "traceable_model", ".", "get_caffe2_inputs", "(", "self", ".", "inputs", ")", "\n", "return", "traceable_model", ",", "traceable_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Tracer.export_caffe2": [[100, 114], ["api.Caffe2Tracer._get_traceable", "export_caffe2_detection_model", "api.Caffe2Model"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Tracer._get_traceable", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_export.export_caffe2_detection_model"], ["", "def", "export_caffe2", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Export the model to Caffe2's protobuf format.\n        The returned object can be saved with ``.save_protobuf()`` method.\n        The result can be loaded and executed using Caffe2 runtime.\n\n        Returns:\n            Caffe2Model\n        \"\"\"", "\n", "from", ".", "caffe2_export", "import", "export_caffe2_detection_model", "\n", "\n", "model", ",", "inputs", "=", "self", ".", "_get_traceable", "(", ")", "\n", "predict_net", ",", "init_net", "=", "export_caffe2_detection_model", "(", "model", ",", "inputs", ")", "\n", "return", "Caffe2Model", "(", "predict_net", ",", "init_net", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Tracer.export_onnx": [[115, 130], ["api.Caffe2Tracer._get_traceable", "export_onnx_model_impl"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Tracer._get_traceable"], ["", "def", "export_onnx", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Export the model to ONNX format.\n        Note that the exported model contains custom ops only available in caffe2, therefore it\n        cannot be directly executed by other runtime. Post-processing or transformation passes\n        may be applied on the model to accommodate different runtimes, but we currently do not\n        provide support for them.\n\n        Returns:\n            onnx.ModelProto: an onnx model.\n        \"\"\"", "\n", "from", ".", "caffe2_export", "import", "export_onnx_model", "as", "export_onnx_model_impl", "\n", "\n", "model", ",", "inputs", "=", "self", ".", "_get_traceable", "(", ")", "\n", "return", "export_onnx_model_impl", "(", "model", ",", "(", "inputs", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Tracer.export_torchscript": [[131, 144], ["api.Caffe2Tracer._get_traceable", "logging.getLogger", "logging.getLogger.info", "torch.no_grad", "torch.jit.trace"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Tracer._get_traceable"], ["", "def", "export_torchscript", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Export the model to a ``torch.jit.TracedModule`` by tracing.\n        The returned object can be saved to a file by ``.save()``.\n\n        Returns:\n            torch.jit.TracedModule: a torch TracedModule\n        \"\"\"", "\n", "model", ",", "inputs", "=", "self", ".", "_get_traceable", "(", ")", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Tracing the model with torch.jit.trace ...\"", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "return", "torch", ".", "jit", ".", "trace", "(", "model", ",", "(", "inputs", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Model.__init__": [[199, 205], ["torch.nn.Module.__init__", "api.Caffe2Model.eval"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "predict_net", ",", "init_net", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "eval", "(", ")", "# always in eval mode", "\n", "self", ".", "_predict_net", "=", "predict_net", "\n", "self", ".", "_init_net", "=", "init_net", "\n", "self", ".", "_predictor", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Model.predict_net": [[208, 215], ["None"], "methods", ["None"], ["@", "property", "\n", "def", "predict_net", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            core.Net: the underlying caffe2 predict net\n        \"\"\"", "\n", "return", "self", ".", "_predict_net", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Model.init_net": [[216, 223], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "init_net", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            core.Net: the underlying caffe2 init net\n        \"\"\"", "\n", "return", "self", ".", "_init_net", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Model.save_protobuf": [[224, 242], ["logging.getLogger", "logging.getLogger.info", "fvcore.common.file_io.PathManager.exists", "fvcore.common.file_io.PathManager.mkdirs", "fvcore.common.file_io.PathManager.open", "f.write", "fvcore.common.file_io.PathManager.open", "f.write", "fvcore.common.file_io.PathManager.open", "f.write", "os.path.join", "api.Caffe2Model._predict_net.SerializeToString", "os.path.join", "str", "os.path.join", "api.Caffe2Model._init_net.SerializeToString"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write"], ["", "def", "save_protobuf", "(", "self", ",", "output_dir", ")", ":", "\n", "        ", "\"\"\"\n        Save the model as caffe2's protobuf format.\n\n        Args:\n            output_dir (str): the output directory to save protobuf files.\n        \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Saving model to {} ...\"", ".", "format", "(", "output_dir", ")", ")", "\n", "if", "not", "PathManager", ".", "exists", "(", "output_dir", ")", ":", "\n", "            ", "PathManager", ".", "mkdirs", "(", "output_dir", ")", "\n", "\n", "", "with", "PathManager", ".", "open", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "\"model.pb\"", ")", ",", "\"wb\"", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "self", ".", "_predict_net", ".", "SerializeToString", "(", ")", ")", "\n", "", "with", "PathManager", ".", "open", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "\"model.pbtxt\"", ")", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "str", "(", "self", ".", "_predict_net", ")", ")", "\n", "", "with", "PathManager", ".", "open", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "\"model_init.pb\"", ")", ",", "\"wb\"", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "self", ".", "_init_net", ".", "SerializeToString", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Model.save_graph": [[243, 264], ["shared.save_graph", "shared.get_pb_arg_vali", "shared.get_pb_arg_vals().decode", "caffe2_modeling.convert_batched_inputs_to_c2_format", "run_and_save_graph", "x.cpu().numpy", "shared.get_pb_arg_vals", "x.cpu"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Model.save_graph", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_vali", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.convert_batched_inputs_to_c2_format", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_export.run_and_save_graph", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_vals"], ["", "", "def", "save_graph", "(", "self", ",", "output_file", ",", "inputs", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Save the graph as SVG format.\n\n        Args:\n            output_file (str): a SVG file\n            inputs: optional inputs given to the model.\n                If given, the inputs will be used to run the graph to record\n                shape of every tensor. The shape information will be\n                saved together with the graph.\n        \"\"\"", "\n", "from", ".", "caffe2_export", "import", "run_and_save_graph", "\n", "\n", "if", "inputs", "is", "None", ":", "\n", "            ", "save_graph", "(", "self", ".", "_predict_net", ",", "output_file", ",", "op_only", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "size_divisibility", "=", "get_pb_arg_vali", "(", "self", ".", "_predict_net", ",", "\"size_divisibility\"", ",", "0", ")", "\n", "device", "=", "get_pb_arg_vals", "(", "self", ".", "_predict_net", ",", "\"device\"", ",", "b\"cpu\"", ")", ".", "decode", "(", "\"ascii\"", ")", "\n", "inputs", "=", "convert_batched_inputs_to_c2_format", "(", "inputs", ",", "size_divisibility", ",", "device", ")", "\n", "inputs", "=", "[", "x", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "for", "x", "in", "inputs", "]", "\n", "run_and_save_graph", "(", "self", ".", "_predict_net", ",", "self", ".", "_init_net", ",", "inputs", ",", "output_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Model.load_protobuf": [[265, 285], ["caffe2.proto.caffe2_pb2.NetDef", "caffe2.proto.caffe2_pb2.NetDef", "api.Caffe2Model", "fvcore.common.file_io.PathManager.open", "caffe2.proto.caffe2_pb2.NetDef.ParseFromString", "fvcore.common.file_io.PathManager.open", "caffe2.proto.caffe2_pb2.NetDef.ParseFromString", "os.path.join", "f.read", "os.path.join", "f.read"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "load_protobuf", "(", "dir", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dir (str): a directory used to save Caffe2Model with\n                :meth:`save_protobuf`.\n                The files \"model.pb\" and \"model_init.pb\" are needed.\n\n        Returns:\n            Caffe2Model: the caffe2 model loaded from this directory.\n        \"\"\"", "\n", "predict_net", "=", "caffe2_pb2", ".", "NetDef", "(", ")", "\n", "with", "PathManager", ".", "open", "(", "os", ".", "path", ".", "join", "(", "dir", ",", "\"model.pb\"", ")", ",", "\"rb\"", ")", "as", "f", ":", "\n", "            ", "predict_net", ".", "ParseFromString", "(", "f", ".", "read", "(", ")", ")", "\n", "\n", "", "init_net", "=", "caffe2_pb2", ".", "NetDef", "(", ")", "\n", "with", "PathManager", ".", "open", "(", "os", ".", "path", ".", "join", "(", "dir", ",", "\"model_init.pb\"", ")", ",", "\"rb\"", ")", "as", "f", ":", "\n", "            ", "init_net", ".", "ParseFromString", "(", "f", ".", "read", "(", ")", ")", "\n", "\n", "", "return", "Caffe2Model", "(", "predict_net", ",", "init_net", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Model.__call__": [[286, 299], ["api.Caffe2Model._predictor", "caffe2_inference.ProtobufDetectionModel"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"\n        An interface that wraps around a caffe2 model and mimics detectron2's models'\n        input/output format. See details about the format at :doc:`/tutorials/models`.\n        This is used to compare the outputs of caffe2 model with its original torch model.\n\n        Due to the extra conversion between torch/caffe2, this method is not meant for\n        benchmark. Because of the conversion, this method also has dependency\n        on detectron2 in order to convert to detectron2's output format.\n        \"\"\"", "\n", "if", "self", ".", "_predictor", "is", "None", ":", "\n", "            ", "self", ".", "_predictor", "=", "ProtobufDetectionModel", "(", "self", ".", "_predict_net", ",", "self", ".", "_init_net", ")", "\n", "", "return", "self", ".", "_predictor", "(", "inputs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.add_export_config": [[25, 41], ["cfg.is_frozen", "cfg.defrost", "detectron2.config.CfgNode", "cfg.freeze"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze"], ["def", "add_export_config", "(", "cfg", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        cfg (CfgNode): a detectron2 config\n\n    Returns:\n        CfgNode: an updated config with new options that will be used\n            by :class:`Caffe2Tracer`.\n    \"\"\"", "\n", "is_frozen", "=", "cfg", ".", "is_frozen", "(", ")", "\n", "cfg", ".", "defrost", "(", ")", "\n", "cfg", ".", "EXPORT_CAFFE2", "=", "CN", "(", ")", "\n", "cfg", ".", "EXPORT_CAFFE2", ".", "USE_HEATMAP_MAX_KEYPOINT", "=", "False", "\n", "if", "is_frozen", ":", "\n", "        ", "cfg", ".", "freeze", "(", ")", "\n", "", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.export_caffe2_model": [[146, 163], ["api.Caffe2Tracer.export_caffe2", "api.Caffe2Tracer"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Tracer.export_caffe2"], ["", "", "", "def", "export_caffe2_model", "(", "cfg", ",", "model", ",", "inputs", ")", ":", "\n", "    ", "\"\"\"\n    Export a detectron2 model to caffe2 format.\n\n    Args:\n        cfg (CfgNode): a detectron2 config, with extra export-related options\n            added by :func:`add_export_config`.\n        model (nn.Module): a model built by\n            :func:`detectron2.modeling.build_model`.\n            It will be modified by this function.\n        inputs: sample inputs that the given model takes for inference.\n            Will be used to trace the model.\n\n    Returns:\n        Caffe2Model\n    \"\"\"", "\n", "return", "Caffe2Tracer", "(", "cfg", ",", "model", ",", "inputs", ")", ".", "export_caffe2", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.export_onnx_model": [[165, 185], ["api.Caffe2Tracer.export_onnx", "api.Caffe2Tracer"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Tracer.export_onnx"], ["", "def", "export_onnx_model", "(", "cfg", ",", "model", ",", "inputs", ")", ":", "\n", "    ", "\"\"\"\n    Export a detectron2 model to ONNX format.\n    Note that the exported model contains custom ops only available in caffe2, therefore it\n    cannot be directly executed by other runtime. Post-processing or transformation passes\n    may be applied on the model to accommodate different runtimes, but we currently do not\n    provide support for them.\n\n    Args:\n        cfg (CfgNode): a detectron2 config, with extra export-related options\n            added by :func:`add_export_config`.\n        model (nn.Module): a model built by\n            :func:`detectron2.modeling.build_model`.\n            It will be modified by this function.\n        inputs: sample inputs that the given model takes for inference.\n            Will be used to trace the model.\n    Returns:\n        onnx.ModelProto: an onnx model.\n    \"\"\"", "\n", "return", "Caffe2Tracer", "(", "cfg", ",", "model", ",", "inputs", ")", ".", "export_onnx", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_inference.ProtobufModel.__init__": [[23, 39], ["logger.info", "super().__init__", "isinstance", "isinstance", "caffe2.python.core.Net", "set", "shared.ScopedWS", "ws.RunNetOnce", "ws.CreateNet", "caffe2_inference.ProtobufModel.net.Proto", "ws.Blobs", "ws.CreateBlob"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["def", "__init__", "(", "self", ",", "predict_net", ",", "init_net", ")", ":", "\n", "        ", "logger", ".", "info", "(", "\"Initializing ProtobufModel ...\"", ")", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "predict_net", ",", "caffe2_pb2", ".", "NetDef", ")", "\n", "assert", "isinstance", "(", "init_net", ",", "caffe2_pb2", ".", "NetDef", ")", "\n", "self", ".", "ws_name", "=", "\"__ws_tmp__\"", "\n", "self", ".", "net", "=", "core", ".", "Net", "(", "predict_net", ")", "\n", "\n", "with", "ScopedWS", "(", "self", ".", "ws_name", ",", "is_reset", "=", "True", ",", "is_cleanup", "=", "False", ")", "as", "ws", ":", "\n", "            ", "ws", ".", "RunNetOnce", "(", "init_net", ")", "\n", "for", "blob", "in", "self", ".", "net", ".", "Proto", "(", ")", ".", "external_input", ":", "\n", "                ", "if", "blob", "not", "in", "ws", ".", "Blobs", "(", ")", ":", "\n", "                    ", "ws", ".", "CreateBlob", "(", "blob", ")", "\n", "", "", "ws", ".", "CreateNet", "(", "self", ".", "net", ")", "\n", "\n", "", "self", ".", "_error_msgs", "=", "set", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_inference.ProtobufModel.forward": [[40, 66], ["all", "shared.ScopedWS", "inputs_dict.items", "collections.OrderedDict", "ws.FeedBlob", "ws.RunNet", "caffe2_inference.ProtobufModel.net.Proto", "ws.FeedBlob", "logger.warning", "caffe2_inference.ProtobufModel.net.Proto", "caffe2_inference.ProtobufModel.net.Proto", "caffe2_inference.ProtobufModel._error_msgs.add", "logger.warning", "ws.FetchBlob", "str", "str", "caffe2_inference.ProtobufModel.net.Proto", "str"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs_dict", ")", ":", "\n", "        ", "assert", "all", "(", "inp", "in", "self", ".", "net", ".", "Proto", "(", ")", ".", "external_input", "for", "inp", "in", "inputs_dict", ")", "\n", "with", "ScopedWS", "(", "self", ".", "ws_name", ",", "is_reset", "=", "False", ",", "is_cleanup", "=", "False", ")", "as", "ws", ":", "\n", "            ", "for", "b", ",", "tensor", "in", "inputs_dict", ".", "items", "(", ")", ":", "\n", "                ", "ws", ".", "FeedBlob", "(", "b", ",", "tensor", ")", "\n", "", "try", ":", "\n", "                ", "ws", ".", "RunNet", "(", "self", ".", "net", ".", "Proto", "(", ")", ".", "name", ")", "\n", "", "except", "RuntimeError", "as", "e", ":", "\n", "                ", "if", "not", "str", "(", "e", ")", "in", "self", ".", "_error_msgs", ":", "\n", "                    ", "self", ".", "_error_msgs", ".", "add", "(", "str", "(", "e", ")", ")", "\n", "logger", ".", "warning", "(", "\"Encountered new RuntimeError: \\n{}\"", ".", "format", "(", "str", "(", "e", ")", ")", ")", "\n", "", "logger", ".", "warning", "(", "\"Catch the error and use partial results.\"", ")", "\n", "\n", "", "outputs_dict", "=", "collections", ".", "OrderedDict", "(", "\n", "[", "(", "b", ",", "ws", ".", "FetchBlob", "(", "b", ")", ")", "for", "b", "in", "self", ".", "net", ".", "Proto", "(", ")", ".", "external_output", "]", "\n", ")", "\n", "# Remove outputs of current run, this is necessary in order to", "\n", "# prevent fetching the result from previous run if the model fails", "\n", "# in the middle.", "\n", "for", "b", "in", "self", ".", "net", ".", "Proto", "(", ")", ".", "external_output", ":", "\n", "# Needs to create uninitialized blob to make the net runable.", "\n", "# This is \"equivalent\" to: ws.RemoveBlob(b) then ws.CreateBlob(b),", "\n", "# but there'no such API.", "\n", "                ", "ws", ".", "FeedBlob", "(", "b", ",", "\"{}, a C++ native class of type nullptr (uninitialized).\"", ".", "format", "(", "b", ")", ")", "\n", "\n", "", "", "return", "outputs_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_inference.ProtobufDetectionModel.__init__": [[74, 93], ["super().__init__", "caffe2_inference.ProtobufModel", "shared.get_pb_arg_vali", "shared.get_pb_arg_vals().decode", "shared.get_pb_arg_vals", "shared.get_pb_arg_vals.get_outputs_converter", "shared.get_pb_arg_vals", "shared.get_pb_arg_vals.decode"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_vali", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_vals", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.Caffe2RetinaNet.get_outputs_converter", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.get_pb_arg_vals"], ["def", "__init__", "(", "self", ",", "predict_net", ",", "init_net", ",", "*", ",", "convert_outputs", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            predict_net, init_net (core.Net): caffe2 nets\n            convert_outptus (callable): a function that converts caffe2\n                outputs to the same format of the original pytorch model.\n                By default, use the one defined in the caffe2 meta_arch.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "protobuf_model", "=", "ProtobufModel", "(", "predict_net", ",", "init_net", ")", "\n", "self", ".", "size_divisibility", "=", "get_pb_arg_vali", "(", "predict_net", ",", "\"size_divisibility\"", ",", "0", ")", "\n", "self", ".", "device", "=", "get_pb_arg_vals", "(", "predict_net", ",", "\"device\"", ",", "b\"cpu\"", ")", ".", "decode", "(", "\"ascii\"", ")", "\n", "\n", "if", "convert_outputs", "is", "None", ":", "\n", "            ", "meta_arch", "=", "get_pb_arg_vals", "(", "predict_net", ",", "\"meta_architecture\"", ",", "b\"GeneralizedRCNN\"", ")", "\n", "meta_arch", "=", "META_ARCH_CAFFE2_EXPORT_TYPE_MAP", "[", "meta_arch", ".", "decode", "(", "\"ascii\"", ")", "]", "\n", "self", ".", "_convert_outputs", "=", "meta_arch", ".", "get_outputs_converter", "(", "predict_net", ",", "init_net", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_convert_outputs", "=", "convert_outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_inference.ProtobufDetectionModel._infer_output_devices": [[94, 111], ["caffe2_inference.ProtobufDetectionModel.protobuf_model.net.Proto", "shared.infer_device_type", "caffe2.python.core.get_ssa", "caffe2_inference.ProtobufDetectionModel._infer_output_devices._get_device_type"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.infer_device_type"], ["", "", "def", "_infer_output_devices", "(", "self", ",", "inputs_dict", ")", ":", "\n", "        ", "def", "_get_device_type", "(", "torch_tensor", ")", ":", "\n", "            ", "assert", "torch_tensor", ".", "device", ".", "type", "in", "[", "\"cpu\"", ",", "\"cuda\"", "]", "\n", "assert", "torch_tensor", ".", "device", ".", "index", "==", "0", "\n", "return", "torch_tensor", ".", "device", ".", "type", "\n", "\n", "", "predict_net", "=", "self", ".", "protobuf_model", ".", "net", ".", "Proto", "(", ")", "\n", "input_device_types", "=", "{", "\n", "(", "name", ",", "0", ")", ":", "_get_device_type", "(", "tensor", ")", "for", "name", ",", "tensor", "in", "inputs_dict", ".", "items", "(", ")", "\n", "}", "\n", "device_type_map", "=", "infer_device_type", "(", "\n", "predict_net", ",", "known_status", "=", "input_device_types", ",", "device_name_style", "=", "\"pytorch\"", "\n", ")", "\n", "ssa", ",", "versions", "=", "core", ".", "get_ssa", "(", "predict_net", ")", "\n", "versioned_outputs", "=", "[", "(", "name", ",", "versions", "[", "name", "]", ")", "for", "name", "in", "predict_net", ".", "external_output", "]", "\n", "output_devices", "=", "[", "device_type_map", "[", "outp", "]", "for", "outp", "in", "versioned_outputs", "]", "\n", "return", "output_devices", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_inference.ProtobufDetectionModel._convert_inputs": [[112, 118], ["caffe2_modeling.convert_batched_inputs_to_c2_format"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_modeling.convert_batched_inputs_to_c2_format"], ["", "def", "_convert_inputs", "(", "self", ",", "batched_inputs", ")", ":", "\n", "# currently all models convert inputs in the same way", "\n", "        ", "data", ",", "im_info", "=", "convert_batched_inputs_to_c2_format", "(", "\n", "batched_inputs", ",", "self", ".", "size_divisibility", ",", "self", ".", "device", "\n", ")", "\n", "return", "{", "\"data\"", ":", "data", ",", "\"im_info\"", ":", "im_info", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_inference.ProtobufDetectionModel.forward": [[119, 137], ["caffe2_inference.ProtobufDetectionModel._convert_inputs", "caffe2_inference.ProtobufDetectionModel.protobuf_model", "any", "caffe2_inference.ProtobufDetectionModel._convert_outputs", "caffe2_inference.ProtobufDetectionModel._infer_output_devices", "caffe2_inference.ProtobufDetectionModel.forward._cast_caffe2_blob_to_torch_tensor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_inference.ProtobufDetectionModel._convert_inputs", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.caffe2_inference.ProtobufDetectionModel._infer_output_devices"], ["", "def", "forward", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "c2_inputs", "=", "self", ".", "_convert_inputs", "(", "batched_inputs", ")", "\n", "c2_results", "=", "self", ".", "protobuf_model", "(", "c2_inputs", ")", "\n", "\n", "if", "any", "(", "t", ".", "device", ".", "type", "!=", "\"cpu\"", "for", "_", ",", "t", "in", "c2_inputs", ".", "items", "(", ")", ")", ":", "\n", "            ", "output_devices", "=", "self", ".", "_infer_output_devices", "(", "c2_inputs", ")", "\n", "", "else", ":", "\n", "            ", "output_devices", "=", "[", "\"cpu\"", "for", "_", "in", "self", ".", "protobuf_model", ".", "net", ".", "Proto", "(", ")", ".", "external_output", "]", "\n", "\n", "", "def", "_cast_caffe2_blob_to_torch_tensor", "(", "blob", ",", "device", ")", ":", "\n", "            ", "return", "torch", ".", "Tensor", "(", "blob", ")", ".", "to", "(", "device", ")", "if", "isinstance", "(", "blob", ",", "np", ".", "ndarray", ")", "else", "None", "\n", "\n", "", "c2_results", "=", "{", "\n", "name", ":", "_cast_caffe2_blob_to_torch_tensor", "(", "c2_results", "[", "name", "]", ",", "device", ")", "\n", "for", "name", ",", "device", "in", "zip", "(", "self", ".", "protobuf_model", ".", "net", ".", "Proto", "(", ")", ".", "external_output", ",", "output_devices", ")", "\n", "}", "\n", "\n", "return", "self", ".", "_convert_outputs", "(", "batched_inputs", ",", "c2_inputs", ",", "c2_results", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultPredictor.__init__": [[186, 202], ["cfg.clone", "detectron2.modeling.build_model", "defaults.DefaultPredictor.model.eval", "len", "detectron2.checkpoint.DetectionCheckpointer", "detectron2.checkpoint.DetectionCheckpointer.load", "detectron2.ResizeShortestEdge", "detectron2.data.MetadataCatalog.get"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["# Anchor angles.", "\n", "# list[list[float]], the angle in degrees, for each input feature map.", "\n", "# ANGLES[i] specifies the list of angles for IN_FEATURES[i].", "\n", "_C", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "ANGLES", "=", "[", "[", "-", "90", ",", "0", ",", "90", "]", "]", "\n", "# Relative offset between the center of the first anchor and the top-left corner of the image", "\n", "# Value has to be in [0, 1). Recommend to use 0.5, which means half stride.", "\n", "# The value is not expected to affect model accuracy.", "\n", "_C", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "OFFSET", "=", "0.0", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# RPN options", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "MODEL", ".", "RPN", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "RPN", ".", "HEAD_NAME", "=", "\"StandardRPNHead\"", "# used by RPN_HEAD_REGISTRY", "\n", "\n", "# Names of the input feature maps to be used by RPN", "\n", "# e.g., [\"p2\", \"p3\", \"p4\", \"p5\", \"p6\"] for FPN", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultPredictor.__call__": [[203, 225], ["torch.no_grad", "defaults.DefaultPredictor.aug.get_transform().apply_image", "torch.as_tensor", "torch.as_tensor.astype().transpose", "defaults.DefaultPredictor.model", "defaults.DefaultPredictor.aug.get_transform", "torch.as_tensor.astype"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.apply_image"], ["_C", ".", "MODEL", ".", "RPN", ".", "IN_FEATURES", "=", "[", "\"res4\"", "]", "\n", "# Remove RPN anchors that go outside the image by BOUNDARY_THRESH pixels", "\n", "# Set to -1 or a large value, e.g. 100000, to disable pruning anchors", "\n", "_C", ".", "MODEL", ".", "RPN", ".", "BOUNDARY_THRESH", "=", "-", "1", "\n", "# IOU overlap ratios [BG_IOU_THRESHOLD, FG_IOU_THRESHOLD]", "\n", "# Minimum overlap required between an anchor and ground-truth box for the", "\n", "# (anchor, gt box) pair to be a positive example (IoU >= FG_IOU_THRESHOLD", "\n", "# ==> positive RPN example: 1)", "\n", "# Maximum overlap allowed between an anchor and ground-truth box for the", "\n", "# (anchor, gt box) pair to be a negative examples (IoU < BG_IOU_THRESHOLD", "\n", "# ==> negative RPN example: 0)", "\n", "# Anchors with overlap in between (BG_IOU_THRESHOLD <= IoU < FG_IOU_THRESHOLD)", "\n", "# are ignored (-1)", "\n", "_C", ".", "MODEL", ".", "RPN", ".", "IOU_THRESHOLDS", "=", "[", "0.3", ",", "0.7", "]", "\n", "_C", ".", "MODEL", ".", "RPN", ".", "IOU_LABELS", "=", "[", "0", ",", "-", "1", ",", "1", "]", "\n", "# Number of regions per image used to train RPN", "\n", "_C", ".", "MODEL", ".", "RPN", ".", "BATCH_SIZE_PER_IMAGE", "=", "256", "\n", "# Target fraction of foreground (positive) examples per RPN minibatch", "\n", "_C", ".", "MODEL", ".", "RPN", ".", "POSITIVE_FRACTION", "=", "0.5", "\n", "# Options are: \"smooth_l1\", \"giou\"", "\n", "_C", ".", "MODEL", ".", "RPN", ".", "BBOX_REG_LOSS_TYPE", "=", "\"smooth_l1\"", "\n", "_C", ".", "MODEL", ".", "RPN", ".", "BBOX_REG_LOSS_WEIGHT", "=", "1.0", "\n", "# Weights on (dx, dy, dw, dh) for normalizing RPN anchor regression targets", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.__init__": [[271, 307], ["logging.getLogger", "defaults.DefaultTrainer.auto_scale_workers", "defaults.DefaultTrainer.build_model", "defaults.DefaultTrainer.build_optimizer", "defaults.DefaultTrainer.build_train_loader", "train_loop.SimpleTrainer.__init__", "defaults.DefaultTrainer.build_lr_scheduler", "detectron2.checkpoint.DetectionCheckpointer", "defaults.DefaultTrainer.register_hooks", "logging.getLogger.isEnabledFor", "detectron2.utils.logger.setup_logger", "detectron2.utils.comm.get_world_size", "detectron2.utils.comm.get_world_size", "torch.nn.parallel.DistributedDataParallel", "defaults.DefaultTrainer.build_hooks", "detectron2.utils.comm.get_local_rank"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.auto_scale_workers", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.apis.train.build_optimizer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.Trainer.build_train_loader", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.build_solver.build_lr_scheduler", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.TrainerBase.register_hooks", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.setup_logger", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.build_hooks", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_local_rank"], ["# Minimum score threshold (assuming scores in a [0, 1] range); a value chosen to", "\n", "# balance obtaining high recall with not having too many low precision", "\n", "# detections that will slow down inference post processing steps (like NMS)", "\n", "# A default threshold of 0.0 increases AP by ~0.2-0.3 but significantly slows down", "\n", "# inference.", "\n", "_C", ".", "MODEL", ".", "ROI_HEADS", ".", "SCORE_THRESH_TEST", "=", "0.05", "\n", "# Overlap threshold used for non-maximum suppression (suppress boxes with", "\n", "# IoU >= this threshold)", "\n", "_C", ".", "MODEL", ".", "ROI_HEADS", ".", "NMS_THRESH_TEST", "=", "0.5", "\n", "# If True, augment proposals with ground-truth boxes before sampling proposals to", "\n", "# train ROI heads.", "\n", "_C", ".", "MODEL", ".", "ROI_HEADS", ".", "PROPOSAL_APPEND_GT", "=", "True", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Box Head", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", "=", "CN", "(", ")", "\n", "# C4 don't use head name option", "\n", "# Options for non-C4 models: FastRCNNConvFCHead,", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NAME", "=", "\"\"", "\n", "# Options are: \"smooth_l1\", \"giou\"", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "BBOX_REG_LOSS_TYPE", "=", "\"smooth_l1\"", "\n", "# The final scaling coefficient on the box regression loss, used to balance the magnitude of its", "\n", "# gradients with other losses in the model. See also `MODEL.ROI_KEYPOINT_HEAD.LOSS_WEIGHT`.", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "BBOX_REG_LOSS_WEIGHT", "=", "1.0", "\n", "# Default weights on (dx, dy, dw, dh) for normalizing bbox regression targets", "\n", "# These are empirically chosen to approximately lead to unit variance targets", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "BBOX_REG_WEIGHTS", "=", "(", "10.0", ",", "10.0", ",", "5.0", ",", "5.0", ")", "\n", "# The transition point from L1 to L2 loss. Set to 0.0 to make the loss simply L1.", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "SMOOTH_L1_BETA", "=", "0.0", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_RESOLUTION", "=", "14", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_SAMPLING_RATIO", "=", "0", "\n", "# Type of pooling operation applied to the incoming feature map for each RoI", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_TYPE", "=", "\"ROIAlignV2\"", "\n", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NUM_FC", "=", "0", "\n", "# Hidden layer dimension for FC layers in the RoI box head", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.resume_or_load": [[308, 325], ["defaults.DefaultTrainer.checkpointer.resume_or_load", "defaults.DefaultTrainer.checkpointer.has_checkpoint", "defaults.DefaultTrainer.get"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "FC_DIM", "=", "1024", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NUM_CONV", "=", "0", "\n", "# Channel dimension for Conv layers in the RoI box head", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "CONV_DIM", "=", "256", "\n", "# Normalization method for the convolution layers.", "\n", "# Options: \"\" (no norm), \"GN\", \"SyncBN\".", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NORM", "=", "\"\"", "\n", "# Whether to use class agnostic for bbox regression", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "CLS_AGNOSTIC_BBOX_REG", "=", "False", "\n", "# If true, RoI heads use bounding boxes predicted by the box head rather than proposal boxes.", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "TRAIN_ON_PRED_BOXES", "=", "False", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Cascaded Box Head", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_CASCADE_HEAD", "=", "CN", "(", ")", "\n", "# The number of cascade stages is implicitly defined by the length of the following two configs.", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_CASCADE_HEAD", ".", "BBOX_REG_WEIGHTS", "=", "(", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.build_hooks": [[328, 374], ["defaults.DefaultTrainer.cfg.clone", "defaults.DefaultTrainer.defrost", "detectron2.utils.comm.is_main_process", "ret.append", "detectron2.utils.comm.is_main_process", "hooks.IterationTimer", "hooks.LRScheduler", "ret.append", "defaults.DefaultTrainer.test", "hooks.EvalHook", "ret.append", "hooks.PreciseBN", "hooks.PeriodicCheckpointer", "hooks.PeriodicWriter", "fvcore.nn.precise_bn.get_bn_modules", "defaults.DefaultTrainer.build_train_loader", "defaults.DefaultTrainer.build_writers"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_packaging.TestCollectEnv.test", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.Trainer.build_train_loader", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.Trainer.build_writers"], ["(", "30.0", ",", "30.0", ",", "15.0", ",", "15.0", ")", ",", "\n", ")", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_CASCADE_HEAD", ".", "IOUS", "=", "(", "0.5", ",", "0.6", ",", "0.7", ")", "\n", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Mask Head", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "MODEL", ".", "ROI_MASK_HEAD", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "NAME", "=", "\"MaskRCNNConvUpsampleHead\"", "\n", "_C", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_RESOLUTION", "=", "14", "\n", "_C", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_SAMPLING_RATIO", "=", "0", "\n", "_C", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "NUM_CONV", "=", "0", "# The number of convs in the mask head", "\n", "_C", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "CONV_DIM", "=", "256", "\n", "# Normalization method for the convolution layers.", "\n", "# Options: \"\" (no norm), \"GN\", \"SyncBN\".", "\n", "_C", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "NORM", "=", "\"\"", "\n", "# Whether to use class agnostic for mask prediction", "\n", "_C", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "CLS_AGNOSTIC_MASK", "=", "False", "\n", "# Type of pooling operation applied to the incoming feature map for each RoI", "\n", "_C", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_TYPE", "=", "\"ROIAlignV2\"", "\n", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Keypoint Head", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "NAME", "=", "\"KRCNNConvDeconvUpsampleHead\"", "\n", "_C", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "POOLER_RESOLUTION", "=", "14", "\n", "_C", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "POOLER_SAMPLING_RATIO", "=", "0", "\n", "_C", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "CONV_DIMS", "=", "tuple", "(", "512", "for", "_", "in", "range", "(", "8", ")", ")", "\n", "_C", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "NUM_KEYPOINTS", "=", "17", "# 17 is the number of keypoints in COCO.", "\n", "\n", "# Images with too few (or no) keypoints are excluded from training.", "\n", "_C", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "MIN_KEYPOINTS_PER_IMAGE", "=", "1", "\n", "# Normalize by the total number of visible keypoints in the minibatch if True.", "\n", "# Otherwise, normalize by the total number of keypoints that could ever exist", "\n", "# in the minibatch.", "\n", "# The keypoint softmax loss is only calculated on visible keypoints.", "\n", "# Since the number of visible keypoints can vary significantly between", "\n", "# minibatches, this has the effect of up-weighting the importance of", "\n", "# minibatches with few visible keypoints. (Imagine the extreme case of", "\n", "# only one visible keypoint versus N: in the case of N, each one", "\n", "# contributes 1/N to the gradient compared to the single keypoint", "\n", "# determining the gradient direction). Instead, we can normalize the", "\n", "# loss by the total number of keypoints, if it were the case that all", "\n", "# keypoints were visible in a full minibatch. (Returning to the example,", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.build_writers": [[375, 401], ["detectron2.utils.events.CommonMetricPrinter", "detectron2.utils.events.JSONWriter", "detectron2.utils.events.TensorboardXWriter", "os.path.join"], "methods", ["None"], ["# this means that the one visible keypoint contributes as much as each", "\n", "# of the N keypoints.)", "\n", "_C", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "NORMALIZE_LOSS_BY_VISIBLE_KEYPOINTS", "=", "True", "\n", "# Multi-task loss weight to use for keypoints", "\n", "# Recommended values:", "\n", "#   - use 1.0 if NORMALIZE_LOSS_BY_VISIBLE_KEYPOINTS is True", "\n", "#   - use 4.0 if NORMALIZE_LOSS_BY_VISIBLE_KEYPOINTS is False", "\n", "_C", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "LOSS_WEIGHT", "=", "1.0", "\n", "# Type of pooling operation applied to the incoming feature map for each RoI", "\n", "_C", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "POOLER_TYPE", "=", "\"ROIAlignV2\"", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Semantic Segmentation Head", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "MODEL", ".", "SEM_SEG_HEAD", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NAME", "=", "\"SemSegFPNHead\"", "\n", "_C", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IN_FEATURES", "=", "[", "\"p2\"", ",", "\"p3\"", ",", "\"p4\"", ",", "\"p5\"", "]", "\n", "# Label in the semantic segmentation ground truth that is ignored, i.e., no loss is calculated for", "\n", "# the correposnding pixel.", "\n", "_C", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IGNORE_VALUE", "=", "255", "\n", "# Number of classes in the semantic segmentation head", "\n", "_C", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NUM_CLASSES", "=", "54", "\n", "# Number of channels in the 3x3 convs inside semantic-FPN heads.", "\n", "_C", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "CONVS_DIM", "=", "128", "\n", "# Outputs from semantic-FPN heads are up-scaled to the COMMON_STRIDE stride.", "\n", "_C", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "COMMON_STRIDE", "=", "4", "\n", "# Normalization method for the convolution layers. Options: \"\" (no norm), \"GN\".", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.train": [[403, 417], ["super().train", "len", "detectron2.utils.comm.is_main_process", "hasattr", "detectron2.evaluation.verify_results"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.testing.verify_results"], ["_C", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "LOSS_WEIGHT", "=", "1.0", "\n", "\n", "_C", ".", "MODEL", ".", "PANOPTIC_FPN", "=", "CN", "(", ")", "\n", "# Scaling of all losses from instance detection / segmentation head.", "\n", "_C", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "INSTANCE_LOSS_WEIGHT", "=", "1.0", "\n", "\n", "# options when combining instance & semantic segmentation outputs", "\n", "_C", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", "=", "CN", "(", "{", "\"ENABLED\"", ":", "True", "}", ")", "\n", "_C", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", ".", "OVERLAP_THRESH", "=", "0.5", "\n", "_C", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", ".", "STUFF_AREA_LIMIT", "=", "4096", "\n", "_C", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", ".", "INSTANCES_CONFIDENCE_THRESH", "=", "0.5", "\n", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# RetinaNet Head", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.build_model": [[418, 431], ["detectron2.modeling.build_model", "logging.getLogger", "logging.getLogger.info"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model"], ["# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "MODEL", ".", "RETINANET", "=", "CN", "(", ")", "\n", "\n", "# This is the number of foreground classes.", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "NUM_CLASSES", "=", "80", "\n", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "IN_FEATURES", "=", "[", "\"p3\"", ",", "\"p4\"", ",", "\"p5\"", ",", "\"p6\"", ",", "\"p7\"", "]", "\n", "\n", "# Convolutions to use in the cls and bbox tower", "\n", "# NOTE: this doesn't include the last conv for logits", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "NUM_CONVS", "=", "4", "\n", "\n", "# IoU overlap ratio [bg, fg] for labeling anchors.", "\n", "# Anchors with < bg are labeled negative (0)", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.build_optimizer": [[432, 442], ["detectron2.solver.build_optimizer"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.apis.train.build_optimizer"], ["# Anchors  with >= bg and < fg are ignored (-1)", "\n", "# Anchors with >= fg are labeled positive (1)", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "IOU_THRESHOLDS", "=", "[", "0.4", ",", "0.5", "]", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "IOU_LABELS", "=", "[", "0", ",", "-", "1", ",", "1", "]", "\n", "\n", "# Prior prob for rare case (i.e. foreground) at the beginning of training.", "\n", "# This is used to set the bias for the logits layer of the classifier subnet.", "\n", "# This improves training stability in the case of heavy class imbalance.", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "PRIOR_PROB", "=", "0.01", "\n", "\n", "# Inference cls score threshold, only anchors with score > INFERENCE_TH are", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.build_lr_scheduler": [[443, 450], ["detectron2.solver.build_lr_scheduler"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.build_solver.build_lr_scheduler"], ["# considered for inference (to improve speed)", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "SCORE_THRESH_TEST", "=", "0.05", "\n", "# Select topk candidates before NMS", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "TOPK_CANDIDATES_TEST", "=", "1000", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "NMS_THRESH_TEST", "=", "0.5", "\n", "\n", "# Weights on (dx, dy, dw, dh) for normalizing Retinanet anchor regression targets", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "BBOX_REG_WEIGHTS", "=", "(", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.build_train_loader": [[451, 461], ["detectron2.data.build_detection_train_loader"], "methods", ["None"], ["\n", "# Loss parameters", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "FOCAL_LOSS_GAMMA", "=", "2.0", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "FOCAL_LOSS_ALPHA", "=", "0.25", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "SMOOTH_L1_LOSS_BETA", "=", "0.1", "\n", "# Options are: \"smooth_l1\", \"giou\"", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "BBOX_REG_LOSS_TYPE", "=", "\"smooth_l1\"", "\n", "\n", "# One of BN, SyncBN, FrozenBN, GN", "\n", "# Only supports GN until unshared norm is implemented", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "NORM", "=", "\"\"", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.build_test_loader": [[462, 472], ["detectron2.data.build_detection_test_loader"], "methods", ["None"], ["\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# ResNe[X]t options (ResNets = {ResNet, ResNeXt}", "\n", "# Note that parts of a resnet may be used for both the backbone and the head", "\n", "# These options apply to both", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "MODEL", ".", "RESNETS", "=", "CN", "(", ")", "\n", "\n", "_C", ".", "MODEL", ".", "RESNETS", ".", "DEPTH", "=", "50", "\n", "_C", ".", "MODEL", ".", "RESNETS", ".", "OUT_FEATURES", "=", "[", "\"res4\"", "]", "# res4 for C4 backbone, res2..5 for FPN backbone", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.build_evaluator": [[473, 487], ["NotImplementedError"], "methods", ["None"], ["\n", "# Number of groups to use; 1 ==> ResNet; > 1 ==> ResNeXt", "\n", "_C", ".", "MODEL", ".", "RESNETS", ".", "NUM_GROUPS", "=", "1", "\n", "\n", "# Options: FrozenBN, GN, \"SyncBN\", \"BN\"", "\n", "_C", ".", "MODEL", ".", "RESNETS", ".", "NORM", "=", "\"FrozenBN\"", "\n", "\n", "# Baseline width of each group.", "\n", "# Scaling this parameters will scale the width of all bottleneck layers.", "\n", "_C", ".", "MODEL", ".", "RESNETS", ".", "WIDTH_PER_GROUP", "=", "64", "\n", "\n", "# Place the stride 2 conv on the 1x1 filter", "\n", "# Use True only for the original MSRA ResNet; use False for C2 and Torch models", "\n", "_C", ".", "MODEL", ".", "RESNETS", ".", "STRIDE_IN_1X1", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.test": [[489, 541], ["logging.getLogger", "isinstance", "collections.OrderedDict", "enumerate", "cls.build_test_loader", "detectron2.evaluation.inference_on_dataset", "detectron2.utils.comm.is_main_process", "len", "len", "len", "len", "len", "isinstance", "logging.getLogger.info", "detectron2.evaluation.print_csv_format", "list", "cls.build_evaluator", "collections.OrderedDict.values", "logging.getLogger.warn"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.Trainer.build_test_loader", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.evaluator.inference_on_dataset", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.testing.print_csv_format", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.Trainer.build_evaluator"], ["_C", ".", "MODEL", ".", "RESNETS", ".", "RES5_DILATION", "=", "1", "\n", "\n", "# Output width of res2. Scaling this parameters will scale the width of all 1x1 convs in ResNet", "\n", "# For R18 and R34, this needs to be set to 64", "\n", "_C", ".", "MODEL", ".", "RESNETS", ".", "RES2_OUT_CHANNELS", "=", "256", "\n", "_C", ".", "MODEL", ".", "RESNETS", ".", "STEM_OUT_CHANNELS", "=", "64", "\n", "\n", "# Apply Deformable Convolution in stages", "\n", "# Specify if apply deform_conv on Res2, Res3, Res4, Res5", "\n", "_C", ".", "MODEL", ".", "RESNETS", ".", "DEFORM_ON_PER_STAGE", "=", "[", "False", ",", "False", ",", "False", ",", "False", "]", "\n", "# Use True to use modulated deform_conv (DeformableV2, https://arxiv.org/abs/1811.11168);", "\n", "# Use False for DeformableV1.", "\n", "_C", ".", "MODEL", ".", "RESNETS", ".", "DEFORM_MODULATED", "=", "False", "\n", "# Number of groups in deformable conv.", "\n", "_C", ".", "MODEL", ".", "RESNETS", ".", "DEFORM_NUM_GROUPS", "=", "1", "\n", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Solver", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "SOLVER", "=", "CN", "(", ")", "\n", "\n", "# See detectron2/solver/build.py for LR scheduler options", "\n", "_C", ".", "SOLVER", ".", "LR_SCHEDULER_NAME", "=", "\"WarmupMultiStepLR\"", "\n", "\n", "_C", ".", "SOLVER", ".", "MAX_ITER", "=", "40000", "\n", "\n", "_C", ".", "SOLVER", ".", "BASE_LR", "=", "0.001", "\n", "\n", "_C", ".", "SOLVER", ".", "MOMENTUM", "=", "0.9", "\n", "\n", "_C", ".", "SOLVER", ".", "NESTEROV", "=", "False", "\n", "\n", "_C", ".", "SOLVER", ".", "WEIGHT_DECAY", "=", "0.0001", "\n", "# The weight decay that's applied to parameters of normalization layers", "\n", "# (typically the affine transformation)", "\n", "_C", ".", "SOLVER", ".", "WEIGHT_DECAY_NORM", "=", "0.0", "\n", "\n", "_C", ".", "SOLVER", ".", "GAMMA", "=", "0.1", "\n", "# The iteration number to decrease learning rate by GAMMA.", "\n", "_C", ".", "SOLVER", ".", "STEPS", "=", "(", "30000", ",", ")", "\n", "\n", "_C", ".", "SOLVER", ".", "WARMUP_FACTOR", "=", "1.0", "/", "1000", "\n", "_C", ".", "SOLVER", ".", "WARMUP_ITERS", "=", "1000", "\n", "_C", ".", "SOLVER", ".", "WARMUP_METHOD", "=", "\"linear\"", "\n", "\n", "# Save a checkpoint after every this number of iterations", "\n", "_C", ".", "SOLVER", ".", "CHECKPOINT_PERIOD", "=", "5000", "\n", "\n", "# Number of images per batch across all machines.", "\n", "# If we have 16 GPUs and IMS_PER_BATCH = 32,", "\n", "# each GPU will see 2 images per batch.", "\n", "# May be adjusted automatically if REFERENCE_WORLD_SIZE is set.", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.auto_scale_workers": [[542, 612], ["cfg.clone.clone.clone", "cfg.clone.clone.is_frozen", "cfg.clone.clone.defrost", "int", "int", "int", "tuple", "int", "int", "logging.getLogger", "logging.getLogger.info", "round", "round", "round", "round", "round", "cfg.clone.clone.freeze", "int", "round"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze"], ["_C", ".", "SOLVER", ".", "IMS_PER_BATCH", "=", "16", "\n", "\n", "# The reference number of workers (GPUs) this config is meant to train with.", "\n", "# It takes no effect when set to 0.", "\n", "# With a non-zero value, it will be used by DefaultTrainer to compute a desired", "\n", "# per-worker batch size, and then scale the other related configs (total batch size,", "\n", "# learning rate, etc) to match the per-worker batch size.", "\n", "# See documentation of `DefaultTrainer.auto_scale_workers` for details:", "\n", "_C", ".", "SOLVER", ".", "REFERENCE_WORLD_SIZE", "=", "0", "\n", "\n", "# Detectron v1 (and previous detection code) used a 2x higher LR and 0 WD for", "\n", "# biases. This is not useful (at least for recent models). You should avoid", "\n", "# changing these and they exist only to reproduce Detectron v1 training if", "\n", "# desired.", "\n", "_C", ".", "SOLVER", ".", "BIAS_LR_FACTOR", "=", "1.0", "\n", "_C", ".", "SOLVER", ".", "WEIGHT_DECAY_BIAS", "=", "_C", ".", "SOLVER", ".", "WEIGHT_DECAY", "\n", "\n", "# Gradient clipping", "\n", "_C", ".", "SOLVER", ".", "CLIP_GRADIENTS", "=", "CN", "(", "{", "\"ENABLED\"", ":", "False", "}", ")", "\n", "# Type of gradient clipping, currently 2 values are supported:", "\n", "# - \"value\": the absolute values of elements of each gradients are clipped", "\n", "# - \"norm\": the norm of the gradient for each parameter is clipped thus", "\n", "#   affecting all elements in the parameter", "\n", "_C", ".", "SOLVER", ".", "CLIP_GRADIENTS", ".", "CLIP_TYPE", "=", "\"value\"", "\n", "# Maximum absolute value used for clipping gradients", "\n", "_C", ".", "SOLVER", ".", "CLIP_GRADIENTS", ".", "CLIP_VALUE", "=", "1.0", "\n", "# Floating point number p for L-p norm to be used with the \"norm\"", "\n", "# gradient clipping type; for L-inf, please specify .inf", "\n", "_C", ".", "SOLVER", ".", "CLIP_GRADIENTS", ".", "NORM_TYPE", "=", "2.0", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Specific test options", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "TEST", "=", "CN", "(", ")", "\n", "# For end-to-end tests to verify the expected accuracy.", "\n", "# Each item is [task, metric, value, tolerance]", "\n", "# e.g.: [['bbox', 'AP', 38.5, 0.2]]", "\n", "_C", ".", "TEST", ".", "EXPECTED_RESULTS", "=", "[", "]", "\n", "# The period (in terms of steps) to evaluate the model during training.", "\n", "# Set to 0 to disable.", "\n", "_C", ".", "TEST", ".", "EVAL_PERIOD", "=", "0", "\n", "# The sigmas used to calculate keypoint OKS. See http://cocodataset.org/#keypoints-eval", "\n", "# When empty, it will use the defaults in COCO.", "\n", "# Otherwise it should be a list[float] with the same length as ROI_KEYPOINT_HEAD.NUM_KEYPOINTS.", "\n", "_C", ".", "TEST", ".", "KEYPOINT_OKS_SIGMAS", "=", "[", "]", "\n", "# Maximum number of detections to return per image during inference (100 is", "\n", "# based on the limit established for the COCO dataset).", "\n", "_C", ".", "TEST", ".", "DETECTIONS_PER_IMAGE", "=", "100", "\n", "\n", "_C", ".", "TEST", ".", "AUG", "=", "CN", "(", "{", "\"ENABLED\"", ":", "False", "}", ")", "\n", "_C", ".", "TEST", ".", "AUG", ".", "MIN_SIZES", "=", "(", "400", ",", "500", ",", "600", ",", "700", ",", "800", ",", "900", ",", "1000", ",", "1100", ",", "1200", ")", "\n", "_C", ".", "TEST", ".", "AUG", ".", "MAX_SIZE", "=", "4000", "\n", "_C", ".", "TEST", ".", "AUG", ".", "FLIP", "=", "True", "\n", "\n", "_C", ".", "TEST", ".", "PRECISE_BN", "=", "CN", "(", "{", "\"ENABLED\"", ":", "False", "}", ")", "\n", "_C", ".", "TEST", ".", "PRECISE_BN", ".", "NUM_ITER", "=", "200", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Misc options", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Directory where output files are written", "\n", "_C", ".", "OUTPUT_DIR", "=", "\"./output\"", "\n", "# Set seed to negative to fully randomize everything.", "\n", "# Set seed to positive to use a fixed seed. Note that a fixed seed increases", "\n", "# reproducibility but does not guarantee fully deterministic behavior.", "\n", "# Disabling all parallelism further increases reproducibility.", "\n", "_C", ".", "SEED", "=", "-", "1", "\n", "# Benchmark different cudnn algorithms.", "\n", "# If input images have very different sizes, this option will have large overhead", "\n", "# for about 10k iterations. It usually hurts total time, but can benefit for certain models.", "\n", "# If input images have the same or similar sizes, benchmark is often helpful.", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.default_argument_parser": [[49, 109], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "hash", "os.getuid"], "function", ["None"], ["# Size of the smallest side of the image during training", "\n", "_C", ".", "INPUT", ".", "MIN_SIZE_TRAIN", "=", "(", "800", ",", ")", "\n", "# Sample size of smallest side by choice or random selection from range give by", "\n", "# INPUT.MIN_SIZE_TRAIN", "\n", "_C", ".", "INPUT", ".", "MIN_SIZE_TRAIN_SAMPLING", "=", "\"choice\"", "\n", "# Maximum size of the side of the image during training", "\n", "_C", ".", "INPUT", ".", "MAX_SIZE_TRAIN", "=", "1333", "\n", "# Size of the smallest side of the image during testing. Set to zero to disable resize in testing.", "\n", "_C", ".", "INPUT", ".", "MIN_SIZE_TEST", "=", "800", "\n", "# Maximum size of the side of the image during testing", "\n", "_C", ".", "INPUT", ".", "MAX_SIZE_TEST", "=", "1333", "\n", "# Mode for flipping images used in data augmentation during training", "\n", "# choose one of [\"horizontal, \"vertical\", \"none\"]", "\n", "_C", ".", "INPUT", ".", "RANDOM_FLIP", "=", "\"horizontal\"", "\n", "\n", "# `True` if cropping is used for data augmentation during training", "\n", "_C", ".", "INPUT", ".", "CROP", "=", "CN", "(", "{", "\"ENABLED\"", ":", "False", "}", ")", "\n", "# Cropping type:", "\n", "# - \"relative\" crop (H * CROP.SIZE[0], W * CROP.SIZE[1]) part of an input of size (H, W)", "\n", "# - \"relative_range\" uniformly sample relative crop size from between [CROP.SIZE[0], [CROP.SIZE[1]].", "\n", "#   and  [1, 1] and use it as in \"relative\" scenario.", "\n", "# - \"absolute\" crop part of an input with absolute size: (CROP.SIZE[0], CROP.SIZE[1]).", "\n", "# - \"absolute_range\", for an input of size (H, W), uniformly sample H_crop in", "\n", "#   [CROP.SIZE[0], min(H, CROP.SIZE[1])] and W_crop in [CROP.SIZE[0], min(W, CROP.SIZE[1])]", "\n", "_C", ".", "INPUT", ".", "CROP", ".", "TYPE", "=", "\"relative_range\"", "\n", "# Size of crop in range (0, 1] if CROP.TYPE is \"relative\" or \"relative_range\" and in number of", "\n", "# pixels if CROP.TYPE is \"absolute\"", "\n", "_C", ".", "INPUT", ".", "CROP", ".", "SIZE", "=", "[", "0.9", ",", "0.9", "]", "\n", "\n", "\n", "# Whether the model needs RGB, YUV, HSV etc.", "\n", "# Should be one of the modes defined here, as we use PIL to read the image:", "\n", "# https://pillow.readthedocs.io/en/stable/handbook/concepts.html#concept-modes", "\n", "# with BGR being the one exception. One can set image format to BGR, we will", "\n", "# internally use RGB for conversion and flip the channels over", "\n", "_C", ".", "INPUT", ".", "FORMAT", "=", "\"BGR\"", "\n", "# The ground truth mask format that the model will use.", "\n", "# Mask R-CNN supports either \"polygon\" or \"bitmask\" as ground truth.", "\n", "_C", ".", "INPUT", ".", "MASK_FORMAT", "=", "\"polygon\"", "# alternative: \"bitmask\"", "\n", "\n", "\n", "# -----------------------------------------------------------------------------", "\n", "# Dataset", "\n", "# -----------------------------------------------------------------------------", "\n", "_C", ".", "DATASETS", "=", "CN", "(", ")", "\n", "# List of the dataset names for training. Must be registered in DatasetCatalog", "\n", "_C", ".", "DATASETS", ".", "TRAIN", "=", "(", ")", "\n", "# List of the pre-computed proposal files for training, which must be consistent", "\n", "# with datasets listed in DATASETS.TRAIN.", "\n", "_C", ".", "DATASETS", ".", "PROPOSAL_FILES_TRAIN", "=", "(", ")", "\n", "# Number of top scoring precomputed proposals to keep for training", "\n", "_C", ".", "DATASETS", ".", "PRECOMPUTED_PROPOSAL_TOPK_TRAIN", "=", "2000", "\n", "# List of the dataset names for testing. Must be registered in DatasetCatalog", "\n", "_C", ".", "DATASETS", ".", "TEST", "=", "(", ")", "\n", "# List of the pre-computed proposal files for test, which must be consistent", "\n", "# with datasets listed in DATASETS.TEST.", "\n", "_C", ".", "DATASETS", ".", "PROPOSAL_FILES_TEST", "=", "(", ")", "\n", "# Number of top scoring precomputed proposals to keep for test", "\n", "_C", ".", "DATASETS", ".", "PRECOMPUTED_PROPOSAL_TOPK_TEST", "=", "1000", "\n", "\n", "# -----------------------------------------------------------------------------", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.default_setup": [[111, 158], ["detectron2.utils.comm.get_rank", "detectron2.utils.logger.setup_logger", "detectron2.utils.logger.setup_logger", "detectron2.utils.logger.setup_logger.info", "detectron2.utils.logger.setup_logger.info", "detectron2.utils.logger.setup_logger.info", "detectron2.utils.logger.setup_logger.info", "detectron2.utils.env.seed_all_rng", "detectron2.utils.comm.is_main_process", "fvcore.common.file_io.PathManager.mkdirs", "hasattr", "detectron2.utils.logger.setup_logger.info", "detectron2.utils.comm.is_main_process", "os.path.join", "detectron2.utils.logger.setup_logger.info", "detectron2.utils.comm.get_world_size", "detectron2.utils.collect_env.collect_env_info", "str", "fvcore.common.file_io.PathManager.open", "f.write", "hasattr", "fvcore.common.file_io.PathManager.open().read", "cfg.dump", "fvcore.common.file_io.PathManager.open"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.setup_logger", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.setup_logger", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.env.seed_all_rng", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect_env.collect_env_info", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.dump"], ["# -----------------------------------------------------------------------------", "\n", "_C", ".", "DATALOADER", "=", "CN", "(", ")", "\n", "# Number of data loading threads", "\n", "_C", ".", "DATALOADER", ".", "NUM_WORKERS", "=", "4", "\n", "# If True, each batch should contain only images for which the aspect ratio", "\n", "# is compatible. This groups portrait images together, and landscape images", "\n", "# are not batched with portrait images.", "\n", "_C", ".", "DATALOADER", ".", "ASPECT_RATIO_GROUPING", "=", "True", "\n", "# Options: TrainingSampler, RepeatFactorTrainingSampler", "\n", "_C", ".", "DATALOADER", ".", "SAMPLER_TRAIN", "=", "\"TrainingSampler\"", "\n", "# Repeat threshold for RepeatFactorTrainingSampler", "\n", "_C", ".", "DATALOADER", ".", "REPEAT_THRESHOLD", "=", "0.0", "\n", "# Tf True, when working on datasets that have instance annotations, the", "\n", "# training dataloader will filter out images without associated annotations", "\n", "_C", ".", "DATALOADER", ".", "FILTER_EMPTY_ANNOTATIONS", "=", "True", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Backbone options", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "MODEL", ".", "BACKBONE", "=", "CN", "(", ")", "\n", "\n", "_C", ".", "MODEL", ".", "BACKBONE", ".", "NAME", "=", "\"build_resnet_backbone\"", "\n", "# Freeze the first several stages so they are not trained.", "\n", "# There are 5 stages in ResNet. The first is a convolution, and the following", "\n", "# stages are each group of residual blocks.", "\n", "_C", ".", "MODEL", ".", "BACKBONE", ".", "FREEZE_AT", "=", "2", "\n", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# FPN options", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "MODEL", ".", "FPN", "=", "CN", "(", ")", "\n", "# Names of the input feature maps to be used by FPN", "\n", "# They must have contiguous power of 2 strides", "\n", "# e.g., [\"res2\", \"res3\", \"res4\", \"res5\"]", "\n", "_C", ".", "MODEL", ".", "FPN", ".", "IN_FEATURES", "=", "[", "]", "\n", "_C", ".", "MODEL", ".", "FPN", ".", "OUT_CHANNELS", "=", "256", "\n", "\n", "# Options: \"\" (no norm), \"GN\"", "\n", "_C", ".", "MODEL", ".", "FPN", ".", "NORM", "=", "\"\"", "\n", "\n", "# Types for fusing the FPN top-down and lateral features. Can be either \"sum\" or \"avg\"", "\n", "_C", ".", "MODEL", ".", "FPN", ".", "FUSE_TYPE", "=", "\"sum\"", "\n", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Proposal generator options", "\n", "# ---------------------------------------------------------------------------- #", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.launch._find_free_port": [[12, 22], ["socket.socket", "socket.socket.bind", "socket.socket.close", "socket.socket.getsockname"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.TensorboardXWriter.close"], ["def", "_find_free_port", "(", ")", ":", "\n", "    ", "import", "socket", "\n", "\n", "sock", "=", "socket", ".", "socket", "(", "socket", ".", "AF_INET", ",", "socket", ".", "SOCK_STREAM", ")", "\n", "# Binding to port 0 will cause the OS to find an available port for us", "\n", "sock", ".", "bind", "(", "(", "\"\"", ",", "0", ")", ")", "\n", "port", "=", "sock", ".", "getsockname", "(", ")", "[", "1", "]", "\n", "sock", ".", "close", "(", ")", "\n", "# NOTE: there is still a chance the port could be taken by other processes.", "\n", "return", "port", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.launch.launch": [[24, 63], ["torch.spawn", "main_func", "launch._find_free_port", "dist_url.startswith", "logging.getLogger", "logging.getLogger.warning"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.launch._find_free_port"], ["", "def", "launch", "(", "main_func", ",", "num_gpus_per_machine", ",", "num_machines", "=", "1", ",", "machine_rank", "=", "0", ",", "dist_url", "=", "None", ",", "args", "=", "(", ")", ")", ":", "\n", "    ", "\"\"\"\n    Launch multi-gpu or distributed training.\n    This function must be called on all machines involved in the training.\n    It will spawn child processes (defined by ``num_gpus_per_machine``) on each machine.\n\n    Args:\n        main_func: a function that will be called by `main_func(*args)`\n        num_gpus_per_machine (int): number of GPUs per machine\n        num_machines (int): the total number of machines\n        machine_rank (int): the rank of this machine\n        dist_url (str): url to connect to for distributed jobs, including protocol\n                       e.g. \"tcp://127.0.0.1:8686\".\n                       Can be set to \"auto\" to automatically select a free port on localhost\n        args (tuple): arguments passed to main_func\n    \"\"\"", "\n", "world_size", "=", "num_machines", "*", "num_gpus_per_machine", "\n", "if", "world_size", ">", "1", ":", "\n", "# https://github.com/pytorch/pytorch/pull/14391", "\n", "# TODO prctl in spawned processes", "\n", "\n", "        ", "if", "dist_url", "==", "\"auto\"", ":", "\n", "            ", "assert", "num_machines", "==", "1", ",", "\"dist_url=auto not supported in multi-machine jobs.\"", "\n", "port", "=", "_find_free_port", "(", ")", "\n", "dist_url", "=", "f\"tcp://127.0.0.1:{port}\"", "\n", "", "if", "num_machines", ">", "1", "and", "dist_url", ".", "startswith", "(", "\"file://\"", ")", ":", "\n", "            ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warning", "(", "\n", "\"file:// is not a reliable init_method in multi-machine jobs. Prefer tcp://\"", "\n", ")", "\n", "\n", "", "mp", ".", "spawn", "(", "\n", "_distributed_worker", ",", "\n", "nprocs", "=", "num_gpus_per_machine", ",", "\n", "args", "=", "(", "main_func", ",", "world_size", ",", "num_gpus_per_machine", ",", "machine_rank", ",", "dist_url", ",", "args", ")", ",", "\n", "daemon", "=", "False", ",", "\n", ")", "\n", "", "else", ":", "\n", "        ", "main_func", "(", "*", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.launch._distributed_worker": [[65, 95], ["torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "detectron2.utils.comm.synchronize", "torch.cuda.set_device", "torch.cuda.set_device", "torch.cuda.set_device", "range", "main_func", "torch.init_process_group", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "list", "torch.new_group", "logging.getLogger", "logging.getLogger.error", "range"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.synchronize"], ["", "", "def", "_distributed_worker", "(", "\n", "local_rank", ",", "main_func", ",", "world_size", ",", "num_gpus_per_machine", ",", "machine_rank", ",", "dist_url", ",", "args", "\n", ")", ":", "\n", "    ", "assert", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"cuda is not available. Please check your installation.\"", "\n", "global_rank", "=", "machine_rank", "*", "num_gpus_per_machine", "+", "local_rank", "\n", "try", ":", "\n", "        ", "dist", ".", "init_process_group", "(", "\n", "backend", "=", "\"NCCL\"", ",", "init_method", "=", "dist_url", ",", "world_size", "=", "world_size", ",", "rank", "=", "global_rank", "\n", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "error", "(", "\"Process group URL: {}\"", ".", "format", "(", "dist_url", ")", ")", "\n", "raise", "e", "\n", "# synchronize is needed here to prevent a possible timeout after calling init_process_group", "\n", "# See: https://github.com/facebookresearch/maskrcnn-benchmark/issues/172", "\n", "", "comm", ".", "synchronize", "(", ")", "\n", "\n", "assert", "num_gpus_per_machine", "<=", "torch", ".", "cuda", ".", "device_count", "(", ")", "\n", "torch", ".", "cuda", ".", "set_device", "(", "local_rank", ")", "\n", "\n", "# Setup the local process group (which contains ranks within the same machine)", "\n", "assert", "comm", ".", "_LOCAL_PROCESS_GROUP", "is", "None", "\n", "num_machines", "=", "world_size", "//", "num_gpus_per_machine", "\n", "for", "i", "in", "range", "(", "num_machines", ")", ":", "\n", "        ", "ranks_on_i", "=", "list", "(", "range", "(", "i", "*", "num_gpus_per_machine", ",", "(", "i", "+", "1", ")", "*", "num_gpus_per_machine", ")", ")", "\n", "pg", "=", "dist", ".", "new_group", "(", "ranks_on_i", ")", "\n", "if", "i", "==", "machine_rank", ":", "\n", "            ", "comm", ".", "_LOCAL_PROCESS_GROUP", "=", "pg", "\n", "\n", "", "", "main_func", "(", "*", "args", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.CallbackHook.__init__": [[45, 53], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "*", ",", "before_train", "=", "None", ",", "after_train", "=", "None", ",", "before_step", "=", "None", ",", "after_step", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Each argument is a function that takes one argument: the trainer.\n        \"\"\"", "\n", "self", ".", "_before_train", "=", "before_train", "\n", "self", ".", "_before_step", "=", "before_step", "\n", "self", ".", "_after_step", "=", "after_step", "\n", "self", ".", "_after_train", "=", "after_train", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.CallbackHook.before_train": [[54, 57], ["hooks.CallbackHook._before_train"], "methods", ["None"], ["", "def", "before_train", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_before_train", ":", "\n", "            ", "self", ".", "_before_train", "(", "self", ".", "trainer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.CallbackHook.after_train": [[58, 65], ["hooks.CallbackHook._after_train"], "methods", ["None"], ["", "", "def", "after_train", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_after_train", ":", "\n", "            ", "self", ".", "_after_train", "(", "self", ".", "trainer", ")", "\n", "# The functions may be closures that hold reference to the trainer", "\n", "# Therefore, delete them to avoid circular reference.", "\n", "", "del", "self", ".", "_before_train", ",", "self", ".", "_after_train", "\n", "del", "self", ".", "_before_step", ",", "self", ".", "_after_step", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.CallbackHook.before_step": [[66, 69], ["hooks.CallbackHook._before_step"], "methods", ["None"], ["", "def", "before_step", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_before_step", ":", "\n", "            ", "self", ".", "_before_step", "(", "self", ".", "trainer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.CallbackHook.after_step": [[70, 73], ["hooks.CallbackHook._after_step"], "methods", ["None"], ["", "", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_after_step", ":", "\n", "            ", "self", ".", "_after_step", "(", "self", ".", "trainer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.IterationTimer.__init__": [[87, 97], ["fvcore.common.timer.Timer", "time.perf_counter", "fvcore.common.timer.Timer"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "warmup_iter", "=", "3", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            warmup_iter (int): the number of iterations at the beginning to exclude\n                from timing.\n        \"\"\"", "\n", "self", ".", "_warmup_iter", "=", "warmup_iter", "\n", "self", ".", "_step_timer", "=", "Timer", "(", ")", "\n", "self", ".", "_start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "self", ".", "_total_timer", "=", "Timer", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.IterationTimer.before_train": [[98, 102], ["time.perf_counter", "hooks.IterationTimer._total_timer.reset", "hooks.IterationTimer._total_timer.pause"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator.DensePoseCOCOEvaluator.reset"], ["", "def", "before_train", "(", "self", ")", ":", "\n", "        ", "self", ".", "_start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "self", ".", "_total_timer", ".", "reset", "(", ")", "\n", "self", ".", "_total_timer", ".", "pause", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.IterationTimer.after_train": [[103, 126], ["logging.getLogger", "hooks.IterationTimer._total_timer.seconds", "logging.getLogger.info", "time.perf_counter", "logging.getLogger.info", "str", "str", "str", "datetime.timedelta", "datetime.timedelta", "datetime.timedelta", "int", "int", "int"], "methods", ["None"], ["", "def", "after_train", "(", "self", ")", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "total_time", "=", "time", ".", "perf_counter", "(", ")", "-", "self", ".", "_start_time", "\n", "total_time_minus_hooks", "=", "self", ".", "_total_timer", ".", "seconds", "(", ")", "\n", "hook_time", "=", "total_time", "-", "total_time_minus_hooks", "\n", "\n", "num_iter", "=", "self", ".", "trainer", ".", "iter", "+", "1", "-", "self", ".", "trainer", ".", "start_iter", "-", "self", ".", "_warmup_iter", "\n", "\n", "if", "num_iter", ">", "0", "and", "total_time_minus_hooks", ">", "0", ":", "\n", "# Speed is meaningful only after warmup", "\n", "# NOTE this format is parsed by grep in some scripts", "\n", "            ", "logger", ".", "info", "(", "\n", "\"Overall training speed: {} iterations in {} ({:.4f} s / it)\"", ".", "format", "(", "\n", "num_iter", ",", "\n", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "total_time_minus_hooks", ")", ")", ")", ",", "\n", "total_time_minus_hooks", "/", "num_iter", ",", "\n", ")", "\n", ")", "\n", "\n", "", "logger", ".", "info", "(", "\n", "\"Total training time: {} ({} on hooks)\"", ".", "format", "(", "\n", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "total_time", ")", ")", ")", ",", "\n", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "hook_time", ")", ")", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.IterationTimer.before_step": [[129, 132], ["hooks.IterationTimer._step_timer.reset", "hooks.IterationTimer._total_timer.resume"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator.DensePoseCOCOEvaluator.reset"], ["", "def", "before_step", "(", "self", ")", ":", "\n", "        ", "self", ".", "_step_timer", ".", "reset", "(", ")", "\n", "self", ".", "_total_timer", ".", "resume", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.IterationTimer.after_step": [[133, 145], ["hooks.IterationTimer._total_timer.pause", "hooks.IterationTimer._step_timer.seconds", "hooks.IterationTimer.trainer.storage.put_scalars", "time.perf_counter", "hooks.IterationTimer._total_timer.reset"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalars", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator.DensePoseCOCOEvaluator.reset"], ["", "def", "after_step", "(", "self", ")", ":", "\n", "# +1 because we're in after_step, the current step is done", "\n", "# but not yet counted", "\n", "        ", "iter_done", "=", "self", ".", "trainer", ".", "iter", "-", "self", ".", "trainer", ".", "start_iter", "+", "1", "\n", "if", "iter_done", ">=", "self", ".", "_warmup_iter", ":", "\n", "            ", "sec", "=", "self", ".", "_step_timer", ".", "seconds", "(", ")", "\n", "self", ".", "trainer", ".", "storage", ".", "put_scalars", "(", "time", "=", "sec", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "self", ".", "_total_timer", ".", "reset", "(", ")", "\n", "\n", "", "self", ".", "_total_timer", ".", "pause", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.PeriodicWriter.__init__": [[155, 165], ["isinstance"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "writers", ",", "period", "=", "20", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            writers (list[EventWriter]): a list of EventWriter objects\n            period (int):\n        \"\"\"", "\n", "self", ".", "_writers", "=", "writers", "\n", "for", "w", "in", "writers", ":", "\n", "            ", "assert", "isinstance", "(", "w", ",", "EventWriter", ")", ",", "w", "\n", "", "self", ".", "_period", "=", "period", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.PeriodicWriter.after_step": [[166, 172], ["writer.write"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write"], ["", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "if", "(", "self", ".", "trainer", ".", "iter", "+", "1", ")", "%", "self", ".", "_period", "==", "0", "or", "(", "\n", "self", ".", "trainer", ".", "iter", "==", "self", ".", "trainer", ".", "max_iter", "-", "1", "\n", ")", ":", "\n", "            ", "for", "writer", "in", "self", ".", "_writers", ":", "\n", "                ", "writer", ".", "write", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.PeriodicWriter.after_train": [[173, 179], ["writer.write", "writer.close"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.TensorboardXWriter.close"], ["", "", "", "def", "after_train", "(", "self", ")", ":", "\n", "        ", "for", "writer", "in", "self", ".", "_writers", ":", "\n", "# If any new data is found (e.g. produced by other after_train),", "\n", "# write them before closing", "\n", "            ", "writer", ".", "write", "(", ")", "\n", "writer", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.PeriodicCheckpointer.before_train": [[192, 194], ["None"], "methods", ["None"], ["def", "before_train", "(", "self", ")", ":", "\n", "        ", "self", ".", "max_iter", "=", "self", ".", "trainer", ".", "max_iter", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.PeriodicCheckpointer.after_step": [[195, 198], ["hooks.PeriodicCheckpointer.step"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.optimizers.LARS.step"], ["", "def", "after_step", "(", "self", ")", ":", "\n", "# No way to use **kwargs", "\n", "        ", "self", ".", "step", "(", "self", ".", "trainer", ".", "iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.LRScheduler.__init__": [[206, 233], ["max", "collections.Counter", "enumerate", "enumerate", "len", "collections.Counter.most_common", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "optimizer", ",", "scheduler", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            optimizer (torch.optim.Optimizer):\n            scheduler (torch.optim._LRScheduler)\n        \"\"\"", "\n", "self", ".", "_optimizer", "=", "optimizer", "\n", "self", ".", "_scheduler", "=", "scheduler", "\n", "\n", "# NOTE: some heuristics on what LR to summarize", "\n", "# summarize the param group with most parameters", "\n", "largest_group", "=", "max", "(", "len", "(", "g", "[", "\"params\"", "]", ")", "for", "g", "in", "optimizer", ".", "param_groups", ")", "\n", "\n", "if", "largest_group", "==", "1", ":", "\n", "# If all groups have one parameter,", "\n", "# then find the most common initial LR, and use it for summary", "\n", "            ", "lr_count", "=", "Counter", "(", "[", "g", "[", "\"lr\"", "]", "for", "g", "in", "optimizer", ".", "param_groups", "]", ")", "\n", "lr", "=", "lr_count", ".", "most_common", "(", ")", "[", "0", "]", "[", "0", "]", "\n", "for", "i", ",", "g", "in", "enumerate", "(", "optimizer", ".", "param_groups", ")", ":", "\n", "                ", "if", "g", "[", "\"lr\"", "]", "==", "lr", ":", "\n", "                    ", "self", ".", "_best_param_group_id", "=", "i", "\n", "break", "\n", "", "", "", "else", ":", "\n", "            ", "for", "i", ",", "g", "in", "enumerate", "(", "optimizer", ".", "param_groups", ")", ":", "\n", "                ", "if", "len", "(", "g", "[", "\"params\"", "]", ")", "==", "largest_group", ":", "\n", "                    ", "self", ".", "_best_param_group_id", "=", "i", "\n", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.LRScheduler.after_step": [[234, 238], ["hooks.LRScheduler.trainer.storage.put_scalar", "hooks.LRScheduler._scheduler.step"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.optimizers.LARS.step"], ["", "", "", "", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "lr", "=", "self", ".", "_optimizer", ".", "param_groups", "[", "self", ".", "_best_param_group_id", "]", "[", "\"lr\"", "]", "\n", "self", ".", "trainer", ".", "storage", ".", "put_scalar", "(", "\"lr\"", ",", "lr", ",", "smoothing_hint", "=", "False", ")", "\n", "self", ".", "_scheduler", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.AutogradProfiler.__init__": [[263, 275], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "enable_predicate", ",", "output_dir", ",", "*", ",", "use_cuda", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            enable_predicate (callable[trainer -> bool]): a function which takes a trainer,\n                and returns whether to enable the profiler.\n                It will be called once every step, and can be used to select which steps to profile.\n            output_dir (str): the output directory to dump tracing files.\n            use_cuda (bool): same as in `torch.autograd.profiler.profile`.\n        \"\"\"", "\n", "self", ".", "_enable_predicate", "=", "enable_predicate", "\n", "self", ".", "_use_cuda", "=", "use_cuda", "\n", "self", ".", "_output_dir", "=", "output_dir", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.AutogradProfiler.before_step": [[276, 282], ["hooks.AutogradProfiler._enable_predicate", "torch.autograd.profiler.profile", "hooks.AutogradProfiler._profiler.__enter__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.ScopedWS.__enter__"], ["", "def", "before_step", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_enable_predicate", "(", "self", ".", "trainer", ")", ":", "\n", "            ", "self", ".", "_profiler", "=", "torch", ".", "autograd", ".", "profiler", ".", "profile", "(", "use_cuda", "=", "self", ".", "_use_cuda", ")", "\n", "self", ".", "_profiler", ".", "__enter__", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_profiler", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.AutogradProfiler.after_step": [[283, 302], ["hooks.AutogradProfiler._profiler.__exit__", "fvcore.common.file_io.PathManager.mkdirs", "os.path.join", "hooks.AutogradProfiler._profiler.export_chrome_trace", "tempfile.TemporaryDirectory", "os.path.join", "hooks.AutogradProfiler._profiler.export_chrome_trace", "fvcore.common.file_io.PathManager.open", "f.write", "open", "f.read"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.shared.ScopedWS.__exit__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write"], ["", "", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_profiler", "is", "None", ":", "\n", "            ", "return", "\n", "", "self", ".", "_profiler", ".", "__exit__", "(", "None", ",", "None", ",", "None", ")", "\n", "PathManager", ".", "mkdirs", "(", "self", ".", "_output_dir", ")", "\n", "out_file", "=", "os", ".", "path", ".", "join", "(", "\n", "self", ".", "_output_dir", ",", "\"profiler-trace-iter{}.json\"", ".", "format", "(", "self", ".", "trainer", ".", "iter", ")", "\n", ")", "\n", "if", "\"://\"", "not", "in", "out_file", ":", "\n", "            ", "self", ".", "_profiler", ".", "export_chrome_trace", "(", "out_file", ")", "\n", "", "else", ":", "\n", "# Support non-posix filesystems", "\n", "            ", "with", "tempfile", ".", "TemporaryDirectory", "(", "prefix", "=", "\"detectron2_profiler\"", ")", "as", "d", ":", "\n", "                ", "tmp_file", "=", "os", ".", "path", ".", "join", "(", "d", ",", "\"tmp.json\"", ")", "\n", "self", ".", "_profiler", ".", "export_chrome_trace", "(", "tmp_file", ")", "\n", "with", "open", "(", "tmp_file", ")", "as", "f", ":", "\n", "                    ", "content", "=", "f", ".", "read", "(", ")", "\n", "", "", "with", "PathManager", ".", "open", "(", "out_file", ",", "\"w\"", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "content", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.EvalHook.__init__": [[311, 326], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "eval_period", ",", "eval_function", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            eval_period (int): the period to run `eval_function`. Set to 0 to\n                not evaluate periodically (but still after the last iteration).\n            eval_function (callable): a function which takes no arguments, and\n                returns a nested dict of evaluation metrics.\n\n        Note:\n            This hook must be enabled in all or none workers.\n            If you would like only certain workers to perform evaluation,\n            give other workers a no-op function (`eval_function=lambda: None`).\n        \"\"\"", "\n", "self", ".", "_period", "=", "eval_period", "\n", "self", ".", "_func", "=", "eval_function", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.EvalHook._do_eval": [[327, 349], ["hooks.EvalHook._func", "detectron2.synchronize", "isinstance", "detectron2.evaluation.testing.flatten_results_dict", "detectron2.evaluation.testing.flatten_results_dict.items", "hooks.EvalHook.trainer.storage.put_scalars", "float", "ValueError"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.synchronize", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.testing.flatten_results_dict", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalars"], ["", "def", "_do_eval", "(", "self", ")", ":", "\n", "        ", "results", "=", "self", ".", "_func", "(", ")", "\n", "\n", "if", "results", ":", "\n", "            ", "assert", "isinstance", "(", "\n", "results", ",", "dict", "\n", ")", ",", "\"Eval function must return a dict. Got {} instead.\"", ".", "format", "(", "results", ")", "\n", "\n", "flattened_results", "=", "flatten_results_dict", "(", "results", ")", "\n", "for", "k", ",", "v", "in", "flattened_results", ".", "items", "(", ")", ":", "\n", "                ", "try", ":", "\n", "                    ", "v", "=", "float", "(", "v", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "                    ", "raise", "ValueError", "(", "\n", "\"[EvalHook] eval_function should return a nested dict of float. \"", "\n", "\"Got '{}: {}' instead.\"", ".", "format", "(", "k", ",", "v", ")", "\n", ")", "from", "e", "\n", "", "", "self", ".", "trainer", ".", "storage", ".", "put_scalars", "(", "**", "flattened_results", ",", "smoothing_hint", "=", "False", ")", "\n", "\n", "# Evaluation may take different time among workers.", "\n", "# A barrier make them start the next iteration together.", "\n", "", "comm", ".", "synchronize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.EvalHook.after_step": [[350, 354], ["hooks.EvalHook._do_eval"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.EvalHook._do_eval"], ["", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "next_iter", "=", "self", ".", "trainer", ".", "iter", "+", "1", "\n", "if", "self", ".", "_period", ">", "0", "and", "next_iter", "%", "self", ".", "_period", "==", "0", ":", "\n", "            ", "self", ".", "_do_eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.EvalHook.after_train": [[355, 362], ["hooks.EvalHook._do_eval"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.EvalHook._do_eval"], ["", "", "def", "after_train", "(", "self", ")", ":", "\n", "# This condition is to prevent the eval from running after a failed training", "\n", "        ", "if", "self", ".", "trainer", ".", "iter", "+", "1", ">=", "self", ".", "trainer", ".", "max_iter", ":", "\n", "            ", "self", ".", "_do_eval", "(", ")", "\n", "# func is likely a closure that holds reference to the trainer", "\n", "# therefore we clean it to avoid circular reference in the end", "\n", "", "del", "self", ".", "_func", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.PreciseBN.__init__": [[374, 402], ["logging.getLogger", "len", "hooks.PreciseBN._logger.info", "fvcore.nn.precise_bn.get_bn_modules"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "period", ",", "model", ",", "data_loader", ",", "num_iter", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            period (int): the period this hook is run, or 0 to not run during training.\n                The hook will always run in the end of training.\n            model (nn.Module): a module whose all BN layers in training mode will be\n                updated by precise BN.\n                Note that user is responsible for ensuring the BN layers to be\n                updated are in training mode when this hook is triggered.\n            data_loader (iterable): it will produce data to be run by `model(data)`.\n            num_iter (int): number of iterations used to compute the precise\n                statistics.\n        \"\"\"", "\n", "self", ".", "_logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "if", "len", "(", "get_bn_modules", "(", "model", ")", ")", "==", "0", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\n", "\"PreciseBN is disabled because model does not contain BN layers in training mode.\"", "\n", ")", "\n", "self", ".", "_disabled", "=", "True", "\n", "return", "\n", "\n", "", "self", ".", "_model", "=", "model", "\n", "self", ".", "_data_loader", "=", "data_loader", "\n", "self", ".", "_num_iter", "=", "num_iter", "\n", "self", ".", "_period", "=", "period", "\n", "self", ".", "_disabled", "=", "False", "\n", "\n", "self", ".", "_data_iter", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.PreciseBN.after_step": [[403, 408], ["hooks.PreciseBN.update_stats"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.PreciseBN.update_stats"], ["", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "next_iter", "=", "self", ".", "trainer", ".", "iter", "+", "1", "\n", "is_final", "=", "next_iter", "==", "self", ".", "trainer", ".", "max_iter", "\n", "if", "is_final", "or", "(", "self", ".", "_period", ">", "0", "and", "next_iter", "%", "self", ".", "_period", "==", "0", ")", ":", "\n", "            ", "self", ".", "update_stats", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.hooks.PreciseBN.update_stats": [[409, 434], ["iter", "itertools.count", "detectron2.utils.events.EventStorage", "hooks.PreciseBN._logger.info", "fvcore.nn.precise_bn.update_bn_stats", "hooks.PreciseBN.update_stats.data_loader"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.iter"], ["", "", "def", "update_stats", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Update the model with precise statistics. Users can manually call this method.\n        \"\"\"", "\n", "if", "self", ".", "_disabled", ":", "\n", "            ", "return", "\n", "\n", "", "if", "self", ".", "_data_iter", "is", "None", ":", "\n", "            ", "self", ".", "_data_iter", "=", "iter", "(", "self", ".", "_data_loader", ")", "\n", "\n", "", "def", "data_loader", "(", ")", ":", "\n", "            ", "for", "num_iter", "in", "itertools", ".", "count", "(", "1", ")", ":", "\n", "                ", "if", "num_iter", "%", "100", "==", "0", ":", "\n", "                    ", "self", ".", "_logger", ".", "info", "(", "\n", "\"Running precise-BN ... {}/{} iterations.\"", ".", "format", "(", "num_iter", ",", "self", ".", "_num_iter", ")", "\n", ")", "\n", "# This way we can reuse the same iterator", "\n", "", "yield", "next", "(", "self", ".", "_data_iter", ")", "\n", "\n", "", "", "with", "EventStorage", "(", ")", ":", "# capture events in a new storage to discard them", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\n", "\"Running precise-BN for {} iterations...  \"", ".", "format", "(", "self", ".", "_num_iter", ")", "\n", "+", "\"Note that this could produce different statistics every time.\"", "\n", ")", "\n", "update_bn_stats", "(", "self", ".", "_model", ",", "data_loader", "(", ")", ",", "self", ".", "_num_iter", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.HookBase.before_train": [[61, 66], ["None"], "methods", ["None"], ["def", "before_train", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Called before the first iteration.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.HookBase.after_train": [[67, 72], ["None"], "methods", ["None"], ["", "def", "after_train", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Called after the last iteration.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.HookBase.before_step": [[73, 78], ["None"], "methods", ["None"], ["", "def", "before_step", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Called before each iteration.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.HookBase.after_step": [[79, 84], ["None"], "methods", ["None"], ["", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Called after each iteration.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.TrainerBase.__init__": [[105, 107], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_hooks", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.TrainerBase.register_hooks": [[108, 125], ["train_loop.TrainerBase._hooks.extend", "isinstance", "weakref.proxy"], "methods", ["None"], ["", "def", "register_hooks", "(", "self", ",", "hooks", ")", ":", "\n", "        ", "\"\"\"\n        Register hooks to the trainer. The hooks are executed in the order\n        they are registered.\n\n        Args:\n            hooks (list[Optional[HookBase]]): list of hooks\n        \"\"\"", "\n", "hooks", "=", "[", "h", "for", "h", "in", "hooks", "if", "h", "is", "not", "None", "]", "\n", "for", "h", "in", "hooks", ":", "\n", "            ", "assert", "isinstance", "(", "h", ",", "HookBase", ")", "\n", "# To avoid circular reference, hooks and trainer cannot own each other.", "\n", "# This normally does not matter, but will cause memory leak if the", "\n", "# involved objects contain __del__:", "\n", "# See http://engineering.hearsaysocial.com/2013/06/16/circular-references-in-python/", "\n", "h", ".", "trainer", "=", "weakref", ".", "proxy", "(", "self", ")", "\n", "", "self", ".", "_hooks", ".", "extend", "(", "hooks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.TrainerBase.train": [[126, 153], ["logging.getLogger", "logging.getLogger.info", "detectron2.utils.events.EventStorage", "train_loop.TrainerBase.before_train", "range", "train_loop.TrainerBase.after_train", "train_loop.TrainerBase.before_step", "train_loop.TrainerBase.run_step", "train_loop.TrainerBase.after_step", "logging.getLogger.exception"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.TrainerBase.before_train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.TrainerBase.after_train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.TrainerBase.before_step", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.SimpleTrainer.run_step", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.TrainerBase.after_step"], ["", "def", "train", "(", "self", ",", "start_iter", ":", "int", ",", "max_iter", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            start_iter, max_iter (int): See docs above\n        \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Starting training from iteration {}\"", ".", "format", "(", "start_iter", ")", ")", "\n", "\n", "self", ".", "iter", "=", "self", ".", "start_iter", "=", "start_iter", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "\n", "with", "EventStorage", "(", "start_iter", ")", "as", "self", ".", "storage", ":", "\n", "            ", "try", ":", "\n", "                ", "self", ".", "before_train", "(", ")", "\n", "for", "self", ".", "iter", "in", "range", "(", "start_iter", ",", "max_iter", ")", ":", "\n", "                    ", "self", ".", "before_step", "(", ")", "\n", "self", ".", "run_step", "(", ")", "\n", "self", ".", "after_step", "(", ")", "\n", "# self.iter == max_iter can be used by `after_train` to", "\n", "# tell whether the training successfully finished or failed", "\n", "# due to exceptions.", "\n", "", "self", ".", "iter", "+=", "1", "\n", "", "except", "Exception", ":", "\n", "                ", "logger", ".", "exception", "(", "\"Exception during training:\"", ")", "\n", "raise", "\n", "", "finally", ":", "\n", "                ", "self", ".", "after_train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.TrainerBase.before_train": [[154, 157], ["h.before_train"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.TrainerBase.before_train"], ["", "", "", "def", "before_train", "(", "self", ")", ":", "\n", "        ", "for", "h", "in", "self", ".", "_hooks", ":", "\n", "            ", "h", ".", "before_train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.TrainerBase.after_train": [[158, 162], ["h.after_train"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.TrainerBase.after_train"], ["", "", "def", "after_train", "(", "self", ")", ":", "\n", "        ", "self", ".", "storage", ".", "iter", "=", "self", ".", "iter", "\n", "for", "h", "in", "self", ".", "_hooks", ":", "\n", "            ", "h", ".", "after_train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.TrainerBase.before_step": [[163, 170], ["h.before_step"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.TrainerBase.before_step"], ["", "", "def", "before_step", "(", "self", ")", ":", "\n", "# Maintain the invariant that storage.iter == trainer.iter", "\n", "# for the entire execution of each step", "\n", "        ", "self", ".", "storage", ".", "iter", "=", "self", ".", "iter", "\n", "\n", "for", "h", "in", "self", ".", "_hooks", ":", "\n", "            ", "h", ".", "before_step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.TrainerBase.after_step": [[171, 174], ["h.after_step"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.TrainerBase.after_step"], ["", "", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "for", "h", "in", "self", ".", "_hooks", ":", "\n", "            ", "h", ".", "after_step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.TrainerBase.run_step": [[175, 177], ["None"], "methods", ["None"], ["", "", "def", "run_step", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.SimpleTrainer.__init__": [[197, 219], ["train_loop.TrainerBase.__init__", "model.train", "iter"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.iter"], ["def", "__init__", "(", "self", ",", "model", ",", "data_loader", ",", "optimizer", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            model: a torch Module. Takes a data from data_loader and returns a\n                dict of losses.\n            data_loader: an iterable. Contains data to be used to call model.\n            optimizer: a torch optimizer.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "\"\"\"\n        We set the model to training mode in the trainer.\n        However it's valid to train a model that's in eval mode.\n        If you want your model (or a submodule of it) to behave\n        like evaluation during training, you can overwrite its train() method.\n        \"\"\"", "\n", "model", ".", "train", "(", ")", "\n", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "data_loader", "=", "data_loader", "\n", "self", ".", "_data_loader_iter", "=", "iter", "(", "data_loader", ")", "\n", "self", ".", "optimizer", "=", "optimizer", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.SimpleTrainer.run_step": [[220, 260], ["time.perf_counter", "next", "train_loop.SimpleTrainer.model", "sum", "train_loop.SimpleTrainer.optimizer.zero_grad", "sum.backward", "train_loop.SimpleTrainer.optimizer.step", "time.perf_counter", "train_loop.SimpleTrainer.values", "train_loop.SimpleTrainer._write_metrics", "train_loop.SimpleTrainer._detect_anomaly", "torch.cuda.stream", "_nullcontext", "torch.cuda.Stream"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.swap_align2nat._SwapAlign2Nat.backward", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.optimizers.LARS.step", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.SimpleTrainer._write_metrics", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.SimpleTrainer._detect_anomaly"], ["", "def", "run_step", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Implement the standard training logic described above.\n        \"\"\"", "\n", "assert", "self", ".", "model", ".", "training", ",", "\"[SimpleTrainer] model was changed to eval mode!\"", "\n", "start", "=", "time", ".", "perf_counter", "(", ")", "\n", "\"\"\"\n        If you want to do something with the data, you can wrap the dataloader.\n        \"\"\"", "\n", "data", "=", "next", "(", "self", ".", "_data_loader_iter", ")", "\n", "data_time", "=", "time", ".", "perf_counter", "(", ")", "-", "start", "\n", "\n", "\"\"\"\n        If you want to do something with the losses, you can wrap the model.\n        \"\"\"", "\n", "loss_dict", "=", "self", ".", "model", "(", "data", ")", "\n", "losses", "=", "sum", "(", "loss_dict", ".", "values", "(", ")", ")", "\n", "\n", "\"\"\"\n        If you need to accumulate gradients or do something similar, you can\n        wrap the optimizer with your custom `zero_grad()` method.\n        \"\"\"", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "losses", ".", "backward", "(", ")", "\n", "\n", "# use a new stream so the ops don't wait for DDP", "\n", "with", "torch", ".", "cuda", ".", "stream", "(", "\n", "torch", ".", "cuda", ".", "Stream", "(", ")", "\n", ")", "if", "losses", ".", "device", ".", "type", "==", "\"cuda\"", "else", "_nullcontext", "(", ")", ":", "\n", "            ", "metrics_dict", "=", "loss_dict", "\n", "metrics_dict", "[", "\"data_time\"", "]", "=", "data_time", "\n", "self", ".", "_write_metrics", "(", "metrics_dict", ")", "\n", "self", ".", "_detect_anomaly", "(", "losses", ",", "loss_dict", ")", "\n", "\n", "", "\"\"\"\n        If you need gradient clipping/scaling or other processing, you can\n        wrap the optimizer with your custom `step()` method. But it is\n        suboptimal as explained in https://arxiv.org/abs/2006.15704 Sec 3.2.4\n        \"\"\"", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.SimpleTrainer._detect_anomaly": [[261, 266], ["torch.isfinite().all", "FloatingPointError", "torch.isfinite"], "methods", ["None"], ["", "def", "_detect_anomaly", "(", "self", ",", "losses", ",", "loss_dict", ")", ":", "\n", "        ", "if", "not", "torch", ".", "isfinite", "(", "losses", ")", ".", "all", "(", ")", ":", "\n", "            ", "raise", "FloatingPointError", "(", "\n", "\"Loss became infinite or NaN at iteration={}!\\nloss_dict = {}\"", ".", "format", "(", "\n", "self", ".", "iter", ",", "loss_dict", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.SimpleTrainer._write_metrics": [[269, 299], ["detectron2.gather", "detectron2.is_main_process", "sum", "train_loop.SimpleTrainer.storage.put_scalar", "isinstance", "v.detach().cpu().item", "float", "metrics_dict.items", "numpy.max", "train_loop.SimpleTrainer.storage.put_scalar", "numpy.mean", "len", "train_loop.SimpleTrainer.storage.put_scalars", "all_metrics_dict[].keys", "v.detach().cpu", "x.pop", "metrics_dict.values", "v.detach"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalars"], ["", "", "def", "_write_metrics", "(", "self", ",", "metrics_dict", ":", "dict", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            metrics_dict (dict): dict of scalar metrics\n        \"\"\"", "\n", "metrics_dict", "=", "{", "\n", "k", ":", "v", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "if", "isinstance", "(", "v", ",", "torch", ".", "Tensor", ")", "else", "float", "(", "v", ")", "\n", "for", "k", ",", "v", "in", "metrics_dict", ".", "items", "(", ")", "\n", "}", "\n", "# gather metrics among all workers for logging", "\n", "# This assumes we do DDP-style training, which is currently the only", "\n", "# supported method in detectron2.", "\n", "all_metrics_dict", "=", "comm", ".", "gather", "(", "metrics_dict", ")", "\n", "\n", "if", "comm", ".", "is_main_process", "(", ")", ":", "\n", "            ", "if", "\"data_time\"", "in", "all_metrics_dict", "[", "0", "]", ":", "\n", "# data_time among workers can have high variance. The actual latency", "\n", "# caused by data_time is the maximum among workers.", "\n", "                ", "data_time", "=", "np", ".", "max", "(", "[", "x", ".", "pop", "(", "\"data_time\"", ")", "for", "x", "in", "all_metrics_dict", "]", ")", "\n", "self", ".", "storage", ".", "put_scalar", "(", "\"data_time\"", ",", "data_time", ")", "\n", "\n", "# average the rest metrics", "\n", "", "metrics_dict", "=", "{", "\n", "k", ":", "np", ".", "mean", "(", "[", "x", "[", "k", "]", "for", "x", "in", "all_metrics_dict", "]", ")", "for", "k", "in", "all_metrics_dict", "[", "0", "]", ".", "keys", "(", ")", "\n", "}", "\n", "total_losses_reduced", "=", "sum", "(", "loss", "for", "loss", "in", "metrics_dict", ".", "values", "(", ")", ")", "\n", "\n", "self", ".", "storage", ".", "put_scalar", "(", "\"total_loss\"", ",", "total_losses_reduced", ")", "\n", "if", "len", "(", "metrics_dict", ")", ">", "1", ":", "\n", "                ", "self", ".", "storage", ".", "put_scalars", "(", "**", "metrics_dict", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountingLoader.__init__": [[30, 32], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "loader", ")", ":", "\n", "        ", "self", ".", "loader", "=", "loader", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountingLoader.__iter__": [[33, 51], ["iter", "detectron2.utils.events.get_event_storage", "next", "len", "detectron2.utils.events.get_event_storage.put_scalar"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.iter", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.get_event_storage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "it", "=", "iter", "(", "self", ".", "loader", ")", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "while", "True", ":", "\n", "            ", "try", ":", "\n", "                ", "batch", "=", "next", "(", "it", ")", "\n", "num_inst_per_dataset", "=", "{", "}", "\n", "for", "data", "in", "batch", ":", "\n", "                    ", "dataset_name", "=", "data", "[", "\"dataset\"", "]", "\n", "if", "dataset_name", "not", "in", "num_inst_per_dataset", ":", "\n", "                        ", "num_inst_per_dataset", "[", "dataset_name", "]", "=", "0", "\n", "", "num_inst", "=", "len", "(", "data", "[", "\"instances\"", "]", ")", "\n", "num_inst_per_dataset", "[", "dataset_name", "]", "+=", "num_inst", "\n", "", "for", "dataset_name", "in", "num_inst_per_dataset", ":", "\n", "                    ", "storage", ".", "put_scalar", "(", "f\"batch/{dataset_name}\"", ",", "num_inst_per_dataset", "[", "dataset_name", "]", ")", "\n", "", "yield", "batch", "\n", "", "except", "StopIteration", ":", "\n", "                ", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.__init__": [[54, 56], ["logging.getLogger"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write": [[57, 64], ["detectron2.utils.events.get_event_storage", "detectron2.utils.events.get_event_storage.histories().items", "trainer.SampleCountMetricPrinter.logger.info", "key.startswith", "detectron2.utils.events.get_event_storage.histories", "batch_stats_strs.append", "buf.avg"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.get_event_storage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.histories"], ["", "def", "write", "(", "self", ")", ":", "\n", "        ", "storage", "=", "get_event_storage", "(", ")", "\n", "batch_stats_strs", "=", "[", "]", "\n", "for", "key", ",", "buf", "in", "storage", ".", "histories", "(", ")", ".", "items", "(", ")", ":", "\n", "            ", "if", "key", ".", "startswith", "(", "\"batch/\"", ")", ":", "\n", "                ", "batch_stats_strs", ".", "append", "(", "f\"{key} {buf.avg(20)}\"", ")", "\n", "", "", "self", ".", "logger", ".", "info", "(", "\", \"", ".", "join", "(", "batch_stats_strs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.Trainer.build_evaluator": [[67, 75], ["detectron2.evaluation.DatasetEvaluators", "os.path.join", "detectron2.evaluation.COCOEvaluator", "evaluators.append", "densepose.DensePoseCOCOEvaluator"], "methods", ["None"], ["    ", "@", "classmethod", "\n", "def", "build_evaluator", "(", "cls", ",", "cfg", ":", "CfgNode", ",", "dataset_name", ",", "output_folder", "=", "None", ")", ":", "\n", "        ", "if", "output_folder", "is", "None", ":", "\n", "            ", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference\"", ")", "\n", "", "evaluators", "=", "[", "COCOEvaluator", "(", "dataset_name", ",", "cfg", ",", "True", ",", "output_folder", ")", "]", "\n", "if", "cfg", ".", "MODEL", ".", "DENSEPOSE_ON", ":", "\n", "            ", "evaluators", ".", "append", "(", "DensePoseCOCOEvaluator", "(", "dataset_name", ",", "True", ",", "output_folder", ")", ")", "\n", "", "return", "DatasetEvaluators", "(", "evaluators", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.Trainer.build_test_loader": [[76, 79], ["densepose.data.build_detection_test_loader", "densepose.data.DatasetMapper"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "build_test_loader", "(", "cls", ",", "cfg", ":", "CfgNode", ",", "dataset_name", ")", ":", "\n", "        ", "return", "build_detection_test_loader", "(", "cfg", ",", "dataset_name", ",", "mapper", "=", "DatasetMapper", "(", "cfg", ",", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.Trainer.build_train_loader": [[80, 94], ["densepose.data.build_detection_train_loader", "cls.build_model", "cls.build_model.to", "detectron2.checkpoint.DetectionCheckpointer().resume_or_load", "densepose.data.build_inference_based_loaders", "densepose.data.build_combined_loader", "trainer.SampleCountingLoader", "densepose.data.has_inference_based_loaders", "densepose.data.DatasetMapper", "detectron2.checkpoint.DetectionCheckpointer"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.resume_or_load"], ["", "@", "classmethod", "\n", "def", "build_train_loader", "(", "cls", ",", "cfg", ":", "CfgNode", ")", ":", "\n", "        ", "data_loader", "=", "build_detection_train_loader", "(", "cfg", ",", "mapper", "=", "DatasetMapper", "(", "cfg", ",", "True", ")", ")", "\n", "if", "not", "has_inference_based_loaders", "(", "cfg", ")", ":", "\n", "            ", "return", "data_loader", "\n", "", "model", "=", "cls", ".", "build_model", "(", "cfg", ")", "\n", "model", ".", "to", "(", "cfg", ".", "BOOTSTRAP_MODEL", ".", "DEVICE", ")", "\n", "DetectionCheckpointer", "(", "model", ")", ".", "resume_or_load", "(", "cfg", ".", "BOOTSTRAP_MODEL", ".", "WEIGHTS", ",", "resume", "=", "False", ")", "\n", "inference_based_loaders", ",", "ratios", "=", "build_inference_based_loaders", "(", "cfg", ",", "model", ")", "\n", "loaders", "=", "[", "data_loader", "]", "+", "inference_based_loaders", "\n", "ratios", "=", "[", "1.0", "]", "+", "ratios", "\n", "combined_data_loader", "=", "build_combined_loader", "(", "cfg", ",", "loaders", ",", "ratios", ")", "\n", "sample_counting_loader", "=", "SampleCountingLoader", "(", "combined_data_loader", ")", "\n", "return", "sample_counting_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.Trainer.build_writers": [[95, 99], ["super().build_writers", "super().build_writers.append", "trainer.SampleCountMetricPrinter"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.Trainer.build_writers"], ["", "def", "build_writers", "(", "self", ")", ":", "\n", "        ", "writers", "=", "super", "(", ")", ".", "build_writers", "(", ")", "\n", "writers", ".", "append", "(", "SampleCountMetricPrinter", "(", ")", ")", "\n", "return", "writers", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.Trainer.test_with_TTA": [[100, 119], ["logging.getLogger", "logging.getLogger.info", "densepose.load_from_cfg", "densepose.DensePoseGeneralizedRCNNWithTTA", "cls.test", "collections.OrderedDict", "densepose.DensePoseDatasetMapperTTA", "cls.build_evaluator", "os.path.join", "collections.OrderedDict.items"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.transform.load_from_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_packaging.TestCollectEnv.test", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.Trainer.build_evaluator"], ["", "@", "classmethod", "\n", "def", "test_with_TTA", "(", "cls", ",", "cfg", ":", "CfgNode", ",", "model", ")", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "\"detectron2.trainer\"", ")", "\n", "# In the end of training, run an evaluation with TTA", "\n", "# Only support some R-CNN models.", "\n", "logger", ".", "info", "(", "\"Running inference with test-time augmentation ...\"", ")", "\n", "transform_data", "=", "load_from_cfg", "(", "cfg", ")", "\n", "model", "=", "DensePoseGeneralizedRCNNWithTTA", "(", "\n", "cfg", ",", "model", ",", "transform_data", ",", "DensePoseDatasetMapperTTA", "(", "cfg", ")", "\n", ")", "\n", "evaluators", "=", "[", "\n", "cls", ".", "build_evaluator", "(", "\n", "cfg", ",", "name", ",", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference_TTA\"", ")", "\n", ")", "\n", "for", "name", "in", "cfg", ".", "DATASETS", ".", "TEST", "\n", "]", "\n", "res", "=", "cls", ".", "test", "(", "cfg", ",", "model", ",", "evaluators", ")", "\n", "res", "=", "OrderedDict", "(", "{", "k", "+", "\"_TTA\"", ":", "v", "for", "k", ",", "v", "in", "res", ".", "items", "(", ")", "}", ")", "\n", "return", "res", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.fast_eval_api.COCOeval_opt.evaluate": [[16, 95], ["time.time", "print", "print", "list", "sorted", "fast_eval_api.COCOeval_opt._prepare", "detectron2._C.COCOevalEvaluateImages", "copy.deepcopy", "time.time", "print", "print", "numpy.unique", "list", "computeIoU", "numpy.unique", "detectron2._C.InstanceAnnotation", "instances_cpp.append", "fast_eval_api.COCOeval_opt.evaluate.convert_instances_to_cpp"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval._prepare", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.computeIoU"], ["def", "evaluate", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Run per image evaluation on given images and store results in self.evalImgs_cpp, a\n        datastructure that isn't readable from Python but is used by a c++ implementation of\n        accumulate().  Unlike the original COCO PythonAPI, we don't populate the datastructure\n        self.evalImgs because this datastructure is a computational bottleneck.\n        :return: None\n        \"\"\"", "\n", "tic", "=", "time", ".", "time", "(", ")", "\n", "\n", "print", "(", "\"Running per image evaluation...\"", ")", "\n", "p", "=", "self", ".", "params", "\n", "# add backward compatibility if useSegm is specified in params", "\n", "if", "p", ".", "useSegm", "is", "not", "None", ":", "\n", "            ", "p", ".", "iouType", "=", "\"segm\"", "if", "p", ".", "useSegm", "==", "1", "else", "\"bbox\"", "\n", "print", "(", "\"useSegm (deprecated) is not None. Running {} evaluation\"", ".", "format", "(", "p", ".", "iouType", ")", ")", "\n", "", "print", "(", "\"Evaluate annotation type *{}*\"", ".", "format", "(", "p", ".", "iouType", ")", ")", "\n", "p", ".", "imgIds", "=", "list", "(", "np", ".", "unique", "(", "p", ".", "imgIds", ")", ")", "\n", "if", "p", ".", "useCats", ":", "\n", "            ", "p", ".", "catIds", "=", "list", "(", "np", ".", "unique", "(", "p", ".", "catIds", ")", ")", "\n", "", "p", ".", "maxDets", "=", "sorted", "(", "p", ".", "maxDets", ")", "\n", "self", ".", "params", "=", "p", "\n", "\n", "self", ".", "_prepare", "(", ")", "\n", "\n", "# loop through images, area range, max detection number", "\n", "catIds", "=", "p", ".", "catIds", "if", "p", ".", "useCats", "else", "[", "-", "1", "]", "\n", "\n", "if", "p", ".", "iouType", "==", "\"segm\"", "or", "p", ".", "iouType", "==", "\"bbox\"", ":", "\n", "            ", "computeIoU", "=", "self", ".", "computeIoU", "\n", "", "elif", "p", ".", "iouType", "==", "\"keypoints\"", ":", "\n", "            ", "computeIoU", "=", "self", ".", "computeOks", "\n", "", "self", ".", "ious", "=", "{", "\n", "(", "imgId", ",", "catId", ")", ":", "computeIoU", "(", "imgId", ",", "catId", ")", "for", "imgId", "in", "p", ".", "imgIds", "for", "catId", "in", "catIds", "\n", "}", "\n", "\n", "maxDet", "=", "p", ".", "maxDets", "[", "-", "1", "]", "\n", "\n", "# <<<< Beginning of code differences with original COCO API", "\n", "def", "convert_instances_to_cpp", "(", "instances", ",", "is_det", "=", "False", ")", ":", "\n", "# Convert annotations for a list of instances in an image to a format that's fast", "\n", "# to access in C++", "\n", "            ", "instances_cpp", "=", "[", "]", "\n", "for", "instance", "in", "instances", ":", "\n", "                ", "instance_cpp", "=", "_C", ".", "InstanceAnnotation", "(", "\n", "int", "(", "instance", "[", "\"id\"", "]", ")", ",", "\n", "instance", "[", "\"score\"", "]", "if", "is_det", "else", "instance", ".", "get", "(", "\"score\"", ",", "0.0", ")", ",", "\n", "instance", "[", "\"area\"", "]", ",", "\n", "bool", "(", "instance", ".", "get", "(", "\"iscrowd\"", ",", "0", ")", ")", ",", "\n", "bool", "(", "instance", ".", "get", "(", "\"ignore\"", ",", "0", ")", ")", ",", "\n", ")", "\n", "instances_cpp", ".", "append", "(", "instance_cpp", ")", "\n", "", "return", "instances_cpp", "\n", "\n", "# Convert GT annotations, detections, and IOUs to a format that's fast to access in C++", "\n", "", "ground_truth_instances", "=", "[", "\n", "[", "convert_instances_to_cpp", "(", "self", ".", "_gts", "[", "imgId", ",", "catId", "]", ")", "for", "catId", "in", "p", ".", "catIds", "]", "\n", "for", "imgId", "in", "p", ".", "imgIds", "\n", "]", "\n", "detected_instances", "=", "[", "\n", "[", "convert_instances_to_cpp", "(", "self", ".", "_dts", "[", "imgId", ",", "catId", "]", ",", "is_det", "=", "True", ")", "for", "catId", "in", "p", ".", "catIds", "]", "\n", "for", "imgId", "in", "p", ".", "imgIds", "\n", "]", "\n", "ious", "=", "[", "[", "self", ".", "ious", "[", "imgId", ",", "catId", "]", "for", "catId", "in", "catIds", "]", "for", "imgId", "in", "p", ".", "imgIds", "]", "\n", "\n", "if", "not", "p", ".", "useCats", ":", "\n", "# For each image, flatten per-category lists into a single list", "\n", "            ", "ground_truth_instances", "=", "[", "[", "[", "o", "for", "c", "in", "i", "for", "o", "in", "c", "]", "]", "for", "i", "in", "ground_truth_instances", "]", "\n", "detected_instances", "=", "[", "[", "[", "o", "for", "c", "in", "i", "for", "o", "in", "c", "]", "]", "for", "i", "in", "detected_instances", "]", "\n", "\n", "# Call C++ implementation of self.evaluateImgs()", "\n", "", "self", ".", "_evalImgs_cpp", "=", "_C", ".", "COCOevalEvaluateImages", "(", "\n", "p", ".", "areaRng", ",", "maxDet", ",", "p", ".", "iouThrs", ",", "ious", ",", "ground_truth_instances", ",", "detected_instances", "\n", ")", "\n", "self", ".", "_evalImgs", "=", "None", "\n", "\n", "self", ".", "_paramsEval", "=", "copy", ".", "deepcopy", "(", "self", ".", "params", ")", "\n", "toc", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "\"COCOeval_opt.evaluate() finished in {:0.2f} seconds.\"", ".", "format", "(", "toc", "-", "tic", ")", ")", "\n", "# >>>> End of code differences with original COCO API", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.fast_eval_api.COCOeval_opt.accumulate": [[97, 120], ["print", "time.time", "detectron2._C.COCOevalAccumulate", "numpy.array().reshape", "numpy.array().reshape", "numpy.array().reshape", "time.time", "print", "hasattr", "print", "numpy.array", "numpy.array", "numpy.array"], "methods", ["None"], ["", "def", "accumulate", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Accumulate per image evaluation results and store the result in self.eval.  Does not\n        support changing parameter settings from those used by self.evaluate()\n        \"\"\"", "\n", "print", "(", "\"Accumulating evaluation results...\"", ")", "\n", "tic", "=", "time", ".", "time", "(", ")", "\n", "if", "not", "hasattr", "(", "self", ",", "\"_evalImgs_cpp\"", ")", ":", "\n", "            ", "print", "(", "\"Please run evaluate() first\"", ")", "\n", "\n", "", "self", ".", "eval", "=", "_C", ".", "COCOevalAccumulate", "(", "self", ".", "_paramsEval", ",", "self", ".", "_evalImgs_cpp", ")", "\n", "\n", "# recall is num_iou_thresholds X num_categories X num_area_ranges X num_max_detections", "\n", "self", ".", "eval", "[", "\"recall\"", "]", "=", "np", ".", "array", "(", "self", ".", "eval", "[", "\"recall\"", "]", ")", ".", "reshape", "(", "\n", "self", ".", "eval", "[", "\"counts\"", "]", "[", ":", "1", "]", "+", "self", ".", "eval", "[", "\"counts\"", "]", "[", "2", ":", "]", "\n", ")", "\n", "\n", "# precision and scores are num_iou_thresholds X num_recall_thresholds X num_categories X", "\n", "# num_area_ranges X num_max_detections", "\n", "self", ".", "eval", "[", "\"precision\"", "]", "=", "np", ".", "array", "(", "self", ".", "eval", "[", "\"precision\"", "]", ")", ".", "reshape", "(", "self", ".", "eval", "[", "\"counts\"", "]", ")", "\n", "self", ".", "eval", "[", "\"scores\"", "]", "=", "np", ".", "array", "(", "self", ".", "eval", "[", "\"scores\"", "]", ")", ".", "reshape", "(", "self", ".", "eval", "[", "\"counts\"", "]", ")", "\n", "toc", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "\"COCOeval_opt.accumulate() finished in {:0.2f} seconds.\"", ".", "format", "(", "toc", "-", "tic", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.sem_seg_evaluation.SemSegEvaluator.__init__": [[24, 58], ["torch.device", "logging.getLogger", "detectron2.data.MetadataCatalog.get", "detectron2.data.DatasetCatalog.get", "c2d.items"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["def", "__init__", "(", "self", ",", "dataset_name", ",", "distributed", ",", "num_classes", ",", "ignore_label", "=", "255", ",", "output_dir", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_name (str): name of the dataset to be evaluated.\n            distributed (True): if True, will collect results from all ranks for evaluation.\n                Otherwise, will evaluate the results in the current process.\n            num_classes (int): number of classes\n            ignore_label (int): value in semantic segmentation ground truth. Predictions for the\n                corresponding pixels should be ignored.\n            output_dir (str): an output directory to dump results.\n        \"\"\"", "\n", "self", ".", "_dataset_name", "=", "dataset_name", "\n", "self", ".", "_distributed", "=", "distributed", "\n", "self", ".", "_output_dir", "=", "output_dir", "\n", "self", ".", "_num_classes", "=", "num_classes", "\n", "self", ".", "_ignore_label", "=", "ignore_label", "\n", "self", ".", "_N", "=", "num_classes", "+", "1", "\n", "\n", "self", ".", "_cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "self", ".", "_logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "self", ".", "input_file_to_gt_file", "=", "{", "\n", "dataset_record", "[", "\"file_name\"", "]", ":", "dataset_record", "[", "\"sem_seg_file_name\"", "]", "\n", "for", "dataset_record", "in", "DatasetCatalog", ".", "get", "(", "dataset_name", ")", "\n", "}", "\n", "\n", "meta", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", "\n", "# Dict that maps contiguous training ids to COCO category ids", "\n", "try", ":", "\n", "            ", "c2d", "=", "meta", ".", "stuff_dataset_id_to_contiguous_id", "\n", "self", ".", "_contiguous_id_to_dataset_id", "=", "{", "v", ":", "k", "for", "k", ",", "v", "in", "c2d", ".", "items", "(", ")", "}", "\n", "", "except", "AttributeError", ":", "\n", "            ", "self", ".", "_contiguous_id_to_dataset_id", "=", "None", "\n", "", "self", ".", "_class_names", "=", "meta", ".", "stuff_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.sem_seg_evaluation.SemSegEvaluator.reset": [[59, 62], ["numpy.zeros"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_conf_matrix", "=", "np", ".", "zeros", "(", "(", "self", ".", "_N", ",", "self", ".", "_N", ")", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "self", ".", "_predictions", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.sem_seg_evaluation.SemSegEvaluator.process": [[63, 86], ["zip", "output[].argmax().to", "numpy.array", "numpy.bincount().reshape", "sem_seg_evaluation.SemSegEvaluator._predictions.extend", "fvcore.common.file_io.PathManager.open", "numpy.array", "sem_seg_evaluation.SemSegEvaluator.encode_json_sem_seg", "output[].argmax", "PIL.open", "numpy.bincount", "numpy.array.reshape", "numpy.array.reshape"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.sem_seg_evaluation.SemSegEvaluator.encode_json_sem_seg"], ["", "def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            inputs: the inputs to a model.\n                It is a list of dicts. Each dict corresponds to an image and\n                contains keys like \"height\", \"width\", \"file_name\".\n            outputs: the outputs of a model. It is either list of semantic segmentation predictions\n                (Tensor [H, W]) or list of dicts with key \"sem_seg\" that contains semantic\n                segmentation prediction in the same format.\n        \"\"\"", "\n", "for", "input", ",", "output", "in", "zip", "(", "inputs", ",", "outputs", ")", ":", "\n", "            ", "output", "=", "output", "[", "\"sem_seg\"", "]", ".", "argmax", "(", "dim", "=", "0", ")", ".", "to", "(", "self", ".", "_cpu_device", ")", "\n", "pred", "=", "np", ".", "array", "(", "output", ",", "dtype", "=", "np", ".", "int", ")", "\n", "with", "PathManager", ".", "open", "(", "self", ".", "input_file_to_gt_file", "[", "input", "[", "\"file_name\"", "]", "]", ",", "\"rb\"", ")", "as", "f", ":", "\n", "                ", "gt", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "f", ")", ",", "dtype", "=", "np", ".", "int", ")", "\n", "\n", "", "gt", "[", "gt", "==", "self", ".", "_ignore_label", "]", "=", "self", ".", "_num_classes", "\n", "\n", "self", ".", "_conf_matrix", "+=", "np", ".", "bincount", "(", "\n", "self", ".", "_N", "*", "pred", ".", "reshape", "(", "-", "1", ")", "+", "gt", ".", "reshape", "(", "-", "1", ")", ",", "minlength", "=", "self", ".", "_N", "**", "2", "\n", ")", ".", "reshape", "(", "self", ".", "_N", ",", "self", ".", "_N", ")", "\n", "\n", "self", ".", "_predictions", ".", "extend", "(", "self", ".", "encode_json_sem_seg", "(", "pred", ",", "input", "[", "\"file_name\"", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.sem_seg_evaluation.SemSegEvaluator.evaluate": [[87, 147], ["numpy.full", "numpy.full", "[].astype", "numpy.sum().astype", "numpy.sum().astype", "numpy.sum", "enumerate", "enumerate", "collections.OrderedDict", "sem_seg_evaluation.SemSegEvaluator._logger.info", "detectron2.utils.comm.synchronize", "detectron2.utils.comm.all_gather", "detectron2.utils.comm.all_gather", "list", "numpy.zeros_like", "fvcore.common.file_io.PathManager.mkdirs", "os.path.join", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "os.path.join", "itertools.chain", "detectron2.utils.comm.is_main_process", "fvcore.common.file_io.PathManager.open", "f.write", "numpy.sum", "numpy.sum", "fvcore.common.file_io.PathManager.open", "torch.save", "json.dumps", "sem_seg_evaluation.SemSegEvaluator._conf_matrix.diagonal"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.synchronize", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save"], ["", "", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Evaluates standard semantic segmentation metrics (http://cocodataset.org/#stuff-eval):\n\n        * Mean intersection-over-union averaged across classes (mIoU)\n        * Frequency Weighted IoU (fwIoU)\n        * Mean pixel accuracy averaged across classes (mACC)\n        * Pixel Accuracy (pACC)\n        \"\"\"", "\n", "if", "self", ".", "_distributed", ":", "\n", "            ", "synchronize", "(", ")", "\n", "conf_matrix_list", "=", "all_gather", "(", "self", ".", "_conf_matrix", ")", "\n", "self", ".", "_predictions", "=", "all_gather", "(", "self", ".", "_predictions", ")", "\n", "self", ".", "_predictions", "=", "list", "(", "itertools", ".", "chain", "(", "*", "self", ".", "_predictions", ")", ")", "\n", "if", "not", "is_main_process", "(", ")", ":", "\n", "                ", "return", "\n", "\n", "", "self", ".", "_conf_matrix", "=", "np", ".", "zeros_like", "(", "self", ".", "_conf_matrix", ")", "\n", "for", "conf_matrix", "in", "conf_matrix_list", ":", "\n", "                ", "self", ".", "_conf_matrix", "+=", "conf_matrix", "\n", "\n", "", "", "if", "self", ".", "_output_dir", ":", "\n", "            ", "PathManager", ".", "mkdirs", "(", "self", ".", "_output_dir", ")", "\n", "file_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_output_dir", ",", "\"sem_seg_predictions.json\"", ")", "\n", "with", "PathManager", ".", "open", "(", "file_path", ",", "\"w\"", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "json", ".", "dumps", "(", "self", ".", "_predictions", ")", ")", "\n", "\n", "", "", "acc", "=", "np", ".", "full", "(", "self", ".", "_num_classes", ",", "np", ".", "nan", ",", "dtype", "=", "np", ".", "float", ")", "\n", "iou", "=", "np", ".", "full", "(", "self", ".", "_num_classes", ",", "np", ".", "nan", ",", "dtype", "=", "np", ".", "float", ")", "\n", "tp", "=", "self", ".", "_conf_matrix", ".", "diagonal", "(", ")", "[", ":", "-", "1", "]", ".", "astype", "(", "np", ".", "float", ")", "\n", "pos_gt", "=", "np", ".", "sum", "(", "self", ".", "_conf_matrix", "[", ":", "-", "1", ",", ":", "-", "1", "]", ",", "axis", "=", "0", ")", ".", "astype", "(", "np", ".", "float", ")", "\n", "class_weights", "=", "pos_gt", "/", "np", ".", "sum", "(", "pos_gt", ")", "\n", "pos_pred", "=", "np", ".", "sum", "(", "self", ".", "_conf_matrix", "[", ":", "-", "1", ",", ":", "-", "1", "]", ",", "axis", "=", "1", ")", ".", "astype", "(", "np", ".", "float", ")", "\n", "acc_valid", "=", "pos_gt", ">", "0", "\n", "acc", "[", "acc_valid", "]", "=", "tp", "[", "acc_valid", "]", "/", "pos_gt", "[", "acc_valid", "]", "\n", "iou_valid", "=", "(", "pos_gt", "+", "pos_pred", ")", ">", "0", "\n", "union", "=", "pos_gt", "+", "pos_pred", "-", "tp", "\n", "iou", "[", "acc_valid", "]", "=", "tp", "[", "acc_valid", "]", "/", "union", "[", "acc_valid", "]", "\n", "macc", "=", "np", ".", "sum", "(", "acc", "[", "acc_valid", "]", ")", "/", "np", ".", "sum", "(", "acc_valid", ")", "\n", "miou", "=", "np", ".", "sum", "(", "iou", "[", "acc_valid", "]", ")", "/", "np", ".", "sum", "(", "iou_valid", ")", "\n", "fiou", "=", "np", ".", "sum", "(", "iou", "[", "acc_valid", "]", "*", "class_weights", "[", "acc_valid", "]", ")", "\n", "pacc", "=", "np", ".", "sum", "(", "tp", ")", "/", "np", ".", "sum", "(", "pos_gt", ")", "\n", "\n", "res", "=", "{", "}", "\n", "res", "[", "\"mIoU\"", "]", "=", "100", "*", "miou", "\n", "res", "[", "\"fwIoU\"", "]", "=", "100", "*", "fiou", "\n", "for", "i", ",", "name", "in", "enumerate", "(", "self", ".", "_class_names", ")", ":", "\n", "            ", "res", "[", "\"IoU-{}\"", ".", "format", "(", "name", ")", "]", "=", "100", "*", "iou", "[", "i", "]", "\n", "", "res", "[", "\"mACC\"", "]", "=", "100", "*", "macc", "\n", "res", "[", "\"pACC\"", "]", "=", "100", "*", "pacc", "\n", "for", "i", ",", "name", "in", "enumerate", "(", "self", ".", "_class_names", ")", ":", "\n", "            ", "res", "[", "\"ACC-{}\"", ".", "format", "(", "name", ")", "]", "=", "100", "*", "acc", "[", "i", "]", "\n", "\n", "", "if", "self", ".", "_output_dir", ":", "\n", "            ", "file_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_output_dir", ",", "\"sem_seg_evaluation.pth\"", ")", "\n", "with", "PathManager", ".", "open", "(", "file_path", ",", "\"wb\"", ")", "as", "f", ":", "\n", "                ", "torch", ".", "save", "(", "res", ",", "f", ")", "\n", "", "", "results", "=", "OrderedDict", "(", "{", "\"sem_seg\"", ":", "res", "}", ")", "\n", "self", ".", "_logger", ".", "info", "(", "results", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.sem_seg_evaluation.SemSegEvaluator.encode_json_sem_seg": [[148, 169], ["numpy.unique", "mask_rle[].decode", "json_list.append", "int", "pycocotools.encode", "numpy.array"], "methods", ["None"], ["", "def", "encode_json_sem_seg", "(", "self", ",", "sem_seg", ",", "input_file_name", ")", ":", "\n", "        ", "\"\"\"\n        Convert semantic segmentation to COCO stuff format with segments encoded as RLEs.\n        See http://cocodataset.org/#format-results\n        \"\"\"", "\n", "json_list", "=", "[", "]", "\n", "for", "label", "in", "np", ".", "unique", "(", "sem_seg", ")", ":", "\n", "            ", "if", "self", ".", "_contiguous_id_to_dataset_id", "is", "not", "None", ":", "\n", "                ", "assert", "(", "\n", "label", "in", "self", ".", "_contiguous_id_to_dataset_id", "\n", ")", ",", "\"Label {} is not in the metadata info for {}\"", ".", "format", "(", "label", ",", "self", ".", "_dataset_name", ")", "\n", "dataset_id", "=", "self", ".", "_contiguous_id_to_dataset_id", "[", "label", "]", "\n", "", "else", ":", "\n", "                ", "dataset_id", "=", "int", "(", "label", ")", "\n", "", "mask", "=", "(", "sem_seg", "==", "label", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "mask_rle", "=", "mask_util", ".", "encode", "(", "np", ".", "array", "(", "mask", "[", ":", ",", ":", ",", "None", "]", ",", "order", "=", "\"F\"", ")", ")", "[", "0", "]", "\n", "mask_rle", "[", "\"counts\"", "]", "=", "mask_rle", "[", "\"counts\"", "]", ".", "decode", "(", "\"utf-8\"", ")", "\n", "json_list", ".", "append", "(", "\n", "{", "\"file_name\"", ":", "input_file_name", ",", "\"category_id\"", ":", "dataset_id", ",", "\"segmentation\"", ":", "mask_rle", "}", "\n", ")", "\n", "", "return", "json_list", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.lvis_evaluation.LVISEvaluator.__init__": [[27, 53], ["lvis_evaluation.LVISEvaluator._tasks_from_config", "torch.device", "logging.getLogger", "detectron2.data.MetadataCatalog.get", "fvcore.common.file_io.PathManager.get_local_path", "LVIS", "len", "lvis_evaluation.LVISEvaluator._lvis_api.get_ann_ids"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.coco_evaluation.COCOEvaluator._tasks_from_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["def", "__init__", "(", "self", ",", "dataset_name", ",", "cfg", ",", "distributed", ",", "output_dir", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_name (str): name of the dataset to be evaluated.\n                It must have the following corresponding metadata:\n                \"json_file\": the path to the LVIS format annotation\n            cfg (CfgNode): config instance\n            distributed (True): if True, will collect results from all ranks for evaluation.\n                Otherwise, will evaluate the results in the current process.\n            output_dir (str): optional, an output directory to dump results.\n        \"\"\"", "\n", "from", "lvis", "import", "LVIS", "\n", "\n", "self", ".", "_tasks", "=", "self", ".", "_tasks_from_config", "(", "cfg", ")", "\n", "self", ".", "_distributed", "=", "distributed", "\n", "self", ".", "_output_dir", "=", "output_dir", "\n", "\n", "self", ".", "_cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "self", ".", "_logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "self", ".", "_metadata", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", "\n", "json_file", "=", "PathManager", ".", "get_local_path", "(", "self", ".", "_metadata", ".", "json_file", ")", "\n", "self", ".", "_lvis_api", "=", "LVIS", "(", "json_file", ")", "\n", "# Test set json files do not contain annotations (evaluation must be", "\n", "# performed using the LVIS evaluation server).", "\n", "self", ".", "_do_evaluation", "=", "len", "(", "self", ".", "_lvis_api", ".", "get_ann_ids", "(", ")", ")", ">", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.lvis_evaluation.LVISEvaluator.reset": [[54, 56], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_predictions", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.lvis_evaluation.LVISEvaluator._tasks_from_config": [[57, 66], ["None"], "methods", ["None"], ["", "def", "_tasks_from_config", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            tuple[str]: tasks that can be evaluated under the given configuration.\n        \"\"\"", "\n", "tasks", "=", "(", "\"bbox\"", ",", ")", "\n", "if", "cfg", ".", "MODEL", ".", "MASK_ON", ":", "\n", "            ", "tasks", "=", "tasks", "+", "(", "\"segm\"", ",", ")", "\n", "", "return", "tasks", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.lvis_evaluation.LVISEvaluator.process": [[67, 85], ["zip", "lvis_evaluation.LVISEvaluator._predictions.append", "output[].to", "coco_evaluation.instances_to_coco_json", "output[].to"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.coco_evaluation.instances_to_coco_json", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            inputs: the inputs to a LVIS model (e.g., GeneralizedRCNN).\n                It is a list of dict. Each dict corresponds to an image and\n                contains keys like \"height\", \"width\", \"file_name\", \"image_id\".\n            outputs: the outputs of a LVIS model. It is a list of dicts with key\n                \"instances\" that contains :class:`Instances`.\n        \"\"\"", "\n", "for", "input", ",", "output", "in", "zip", "(", "inputs", ",", "outputs", ")", ":", "\n", "            ", "prediction", "=", "{", "\"image_id\"", ":", "input", "[", "\"image_id\"", "]", "}", "\n", "\n", "if", "\"instances\"", "in", "output", ":", "\n", "                ", "instances", "=", "output", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "_cpu_device", ")", "\n", "prediction", "[", "\"instances\"", "]", "=", "instances_to_coco_json", "(", "instances", ",", "input", "[", "\"image_id\"", "]", ")", "\n", "", "if", "\"proposals\"", "in", "output", ":", "\n", "                ", "prediction", "[", "\"proposals\"", "]", "=", "output", "[", "\"proposals\"", "]", ".", "to", "(", "self", ".", "_cpu_device", ")", "\n", "", "self", ".", "_predictions", ".", "append", "(", "prediction", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.lvis_evaluation.LVISEvaluator.evaluate": [[86, 114], ["collections.OrderedDict", "copy.deepcopy", "detectron2.synchronize", "detectron2.gather", "list", "len", "lvis_evaluation.LVISEvaluator._logger.warning", "fvcore.common.file_io.PathManager.mkdirs", "os.path.join", "lvis_evaluation.LVISEvaluator._eval_box_proposals", "lvis_evaluation.LVISEvaluator._eval_predictions", "itertools.chain", "detectron2.is_main_process", "fvcore.common.file_io.PathManager.open", "torch.save", "set"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.synchronize", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.coco_evaluation.COCOEvaluator._eval_box_proposals", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator.DensePoseCOCOEvaluator._eval_predictions", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["", "", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_distributed", ":", "\n", "            ", "comm", ".", "synchronize", "(", ")", "\n", "predictions", "=", "comm", ".", "gather", "(", "self", ".", "_predictions", ",", "dst", "=", "0", ")", "\n", "predictions", "=", "list", "(", "itertools", ".", "chain", "(", "*", "predictions", ")", ")", "\n", "\n", "if", "not", "comm", ".", "is_main_process", "(", ")", ":", "\n", "                ", "return", "\n", "", "", "else", ":", "\n", "            ", "predictions", "=", "self", ".", "_predictions", "\n", "\n", "", "if", "len", "(", "predictions", ")", "==", "0", ":", "\n", "            ", "self", ".", "_logger", ".", "warning", "(", "\"[LVISEvaluator] Did not receive valid predictions.\"", ")", "\n", "return", "{", "}", "\n", "\n", "", "if", "self", ".", "_output_dir", ":", "\n", "            ", "PathManager", ".", "mkdirs", "(", "self", ".", "_output_dir", ")", "\n", "file_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_output_dir", ",", "\"instances_predictions.pth\"", ")", "\n", "with", "PathManager", ".", "open", "(", "file_path", ",", "\"wb\"", ")", "as", "f", ":", "\n", "                ", "torch", ".", "save", "(", "predictions", ",", "f", ")", "\n", "\n", "", "", "self", ".", "_results", "=", "OrderedDict", "(", ")", "\n", "if", "\"proposals\"", "in", "predictions", "[", "0", "]", ":", "\n", "            ", "self", ".", "_eval_box_proposals", "(", "predictions", ")", "\n", "", "if", "\"instances\"", "in", "predictions", "[", "0", "]", ":", "\n", "            ", "self", ".", "_eval_predictions", "(", "set", "(", "self", ".", "_tasks", ")", ",", "predictions", ")", "\n", "# Copy so the caller can do whatever with results", "\n", "", "return", "copy", ".", "deepcopy", "(", "self", ".", "_results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.lvis_evaluation.LVISEvaluator._eval_predictions": [[115, 156], ["lvis_evaluation.LVISEvaluator._logger.info", "list", "hasattr", "lvis_evaluation.LVISEvaluator._logger.info", "sorted", "itertools.chain", "os.path.join", "lvis_evaluation.LVISEvaluator._logger.info", "lvis_evaluation.LVISEvaluator._logger.info", "lvis_evaluation._evaluate_predictions_on_lvis", "fvcore.common.file_io.PathManager.open", "f.write", "f.flush", "lvis_evaluation.LVISEvaluator._metadata.thing_dataset_id_to_contiguous_id.items", "json.dumps", "lvis_evaluation.LVISEvaluator._metadata.get"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.lvis_evaluation._evaluate_predictions_on_lvis", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "def", "_eval_predictions", "(", "self", ",", "tasks", ",", "predictions", ")", ":", "\n", "        ", "\"\"\"\n        Evaluate predictions on the given tasks.\n        Fill self._results with the metrics of the tasks.\n\n        Args:\n            predictions (list[dict]): list of outputs from the model\n        \"\"\"", "\n", "self", ".", "_logger", ".", "info", "(", "\"Preparing results in the LVIS format ...\"", ")", "\n", "lvis_results", "=", "list", "(", "itertools", ".", "chain", "(", "*", "[", "x", "[", "\"instances\"", "]", "for", "x", "in", "predictions", "]", ")", ")", "\n", "\n", "# LVIS evaluator can be used to evaluate results for COCO dataset categories.", "\n", "# In this case `_metadata` variable will have a field with COCO-specific category mapping.", "\n", "if", "hasattr", "(", "self", ".", "_metadata", ",", "\"thing_dataset_id_to_contiguous_id\"", ")", ":", "\n", "            ", "reverse_id_mapping", "=", "{", "\n", "v", ":", "k", "for", "k", ",", "v", "in", "self", ".", "_metadata", ".", "thing_dataset_id_to_contiguous_id", ".", "items", "(", ")", "\n", "}", "\n", "for", "result", "in", "lvis_results", ":", "\n", "                ", "result", "[", "\"category_id\"", "]", "=", "reverse_id_mapping", "[", "result", "[", "\"category_id\"", "]", "]", "\n", "", "", "else", ":", "\n", "# unmap the category ids for LVIS (from 0-indexed to 1-indexed)", "\n", "            ", "for", "result", "in", "lvis_results", ":", "\n", "                ", "result", "[", "\"category_id\"", "]", "+=", "1", "\n", "\n", "", "", "if", "self", ".", "_output_dir", ":", "\n", "            ", "file_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_output_dir", ",", "\"lvis_instances_results.json\"", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\"Saving results to {}\"", ".", "format", "(", "file_path", ")", ")", "\n", "with", "PathManager", ".", "open", "(", "file_path", ",", "\"w\"", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "json", ".", "dumps", "(", "lvis_results", ")", ")", "\n", "f", ".", "flush", "(", ")", "\n", "\n", "", "", "if", "not", "self", ".", "_do_evaluation", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\"Annotations are not available for evaluation.\"", ")", "\n", "return", "\n", "\n", "", "self", ".", "_logger", ".", "info", "(", "\"Evaluating predictions ...\"", ")", "\n", "for", "task", "in", "sorted", "(", "tasks", ")", ":", "\n", "            ", "res", "=", "_evaluate_predictions_on_lvis", "(", "\n", "self", ".", "_lvis_api", ",", "lvis_results", ",", "task", ",", "class_names", "=", "self", ".", "_metadata", ".", "get", "(", "\"thing_classes\"", ")", "\n", ")", "\n", "self", ".", "_results", "[", "task", "]", "=", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.lvis_evaluation.LVISEvaluator._eval_box_proposals": [[157, 195], ["lvis_evaluation.LVISEvaluator._logger.info", "lvis_evaluation.LVISEvaluator._logger.info", "lvis_evaluation.LVISEvaluator._logger.info", "areas.items", "ids.append", "boxes.append", "objectness_logits.append", "fvcore.common.file_io.PathManager.open", "pickle.dump", "lvis_evaluation._evaluate_box_proposals", "float", "detectron2.utils.logger.create_small_table", "prediction[].proposal_boxes.tensor.numpy", "prediction[].objectness_logits.numpy", "os.path.join", "stats[].item"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.dump", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.coco_evaluation._evaluate_box_proposals", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.create_small_table"], ["", "", "def", "_eval_box_proposals", "(", "self", ",", "predictions", ")", ":", "\n", "        ", "\"\"\"\n        Evaluate the box proposals in predictions.\n        Fill self._results with the metrics for \"box_proposals\" task.\n        \"\"\"", "\n", "if", "self", ".", "_output_dir", ":", "\n", "# Saving generated box proposals to file.", "\n", "# Predicted box_proposals are in XYXY_ABS mode.", "\n", "            ", "bbox_mode", "=", "BoxMode", ".", "XYXY_ABS", ".", "value", "\n", "ids", ",", "boxes", ",", "objectness_logits", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "prediction", "in", "predictions", ":", "\n", "                ", "ids", ".", "append", "(", "prediction", "[", "\"image_id\"", "]", ")", "\n", "boxes", ".", "append", "(", "prediction", "[", "\"proposals\"", "]", ".", "proposal_boxes", ".", "tensor", ".", "numpy", "(", ")", ")", "\n", "objectness_logits", ".", "append", "(", "prediction", "[", "\"proposals\"", "]", ".", "objectness_logits", ".", "numpy", "(", ")", ")", "\n", "\n", "", "proposal_data", "=", "{", "\n", "\"boxes\"", ":", "boxes", ",", "\n", "\"objectness_logits\"", ":", "objectness_logits", ",", "\n", "\"ids\"", ":", "ids", ",", "\n", "\"bbox_mode\"", ":", "bbox_mode", ",", "\n", "}", "\n", "with", "PathManager", ".", "open", "(", "os", ".", "path", ".", "join", "(", "self", ".", "_output_dir", ",", "\"box_proposals.pkl\"", ")", ",", "\"wb\"", ")", "as", "f", ":", "\n", "                ", "pickle", ".", "dump", "(", "proposal_data", ",", "f", ")", "\n", "\n", "", "", "if", "not", "self", ".", "_do_evaluation", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\"Annotations are not available for evaluation.\"", ")", "\n", "return", "\n", "\n", "", "self", ".", "_logger", ".", "info", "(", "\"Evaluating bbox proposals ...\"", ")", "\n", "res", "=", "{", "}", "\n", "areas", "=", "{", "\"all\"", ":", "\"\"", ",", "\"small\"", ":", "\"s\"", ",", "\"medium\"", ":", "\"m\"", ",", "\"large\"", ":", "\"l\"", "}", "\n", "for", "limit", "in", "[", "100", ",", "1000", "]", ":", "\n", "            ", "for", "area", ",", "suffix", "in", "areas", ".", "items", "(", ")", ":", "\n", "                ", "stats", "=", "_evaluate_box_proposals", "(", "predictions", ",", "self", ".", "_lvis_api", ",", "area", "=", "area", ",", "limit", "=", "limit", ")", "\n", "key", "=", "\"AR{}@{:d}\"", ".", "format", "(", "suffix", ",", "limit", ")", "\n", "res", "[", "key", "]", "=", "float", "(", "stats", "[", "\"ar\"", "]", ".", "item", "(", ")", "*", "100", ")", "\n", "", "", "self", ".", "_logger", ".", "info", "(", "\"Proposal metrics: \\n\"", "+", "create_small_table", "(", "res", ")", ")", "\n", "self", ".", "_results", "[", "\"box_proposals\"", "]", "=", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.lvis_evaluation._evaluate_box_proposals": [[199, 305], ["torch.sort", "torch.zeros_like", "enumerate", "torch.zeros_like.mean", "lvis_api.get_ann_ids", "lvis_api.load_anns", "torch.as_tensor().reshape", "detectron2.structures.Boxes", "torch.as_tensor", "len", "detectron2.structures.pairwise_iou", "torch.zeros", "range", "gt_overlaps.append", "len", "torch.cat", "torch.zeros", "torch.arange", "predictions.objectness_logits.sort", "detectron2.structures.BoxMode.convert", "len", "len", "min", "detectron2.structures.pairwise_iou.max", "max_overlaps.max", "float", "torch.as_tensor", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.pairwise_iou", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "", "def", "_evaluate_box_proposals", "(", "dataset_predictions", ",", "lvis_api", ",", "thresholds", "=", "None", ",", "area", "=", "\"all\"", ",", "limit", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Evaluate detection proposal recall metrics. This function is a much\n    faster alternative to the official LVIS API recall evaluation code. However,\n    it produces slightly different results.\n    \"\"\"", "\n", "# Record max overlap value for each gt box", "\n", "# Return vector of overlap values", "\n", "areas", "=", "{", "\n", "\"all\"", ":", "0", ",", "\n", "\"small\"", ":", "1", ",", "\n", "\"medium\"", ":", "2", ",", "\n", "\"large\"", ":", "3", ",", "\n", "\"96-128\"", ":", "4", ",", "\n", "\"128-256\"", ":", "5", ",", "\n", "\"256-512\"", ":", "6", ",", "\n", "\"512-inf\"", ":", "7", ",", "\n", "}", "\n", "area_ranges", "=", "[", "\n", "[", "0", "**", "2", ",", "1e5", "**", "2", "]", ",", "# all", "\n", "[", "0", "**", "2", ",", "32", "**", "2", "]", ",", "# small", "\n", "[", "32", "**", "2", ",", "96", "**", "2", "]", ",", "# medium", "\n", "[", "96", "**", "2", ",", "1e5", "**", "2", "]", ",", "# large", "\n", "[", "96", "**", "2", ",", "128", "**", "2", "]", ",", "# 96-128", "\n", "[", "128", "**", "2", ",", "256", "**", "2", "]", ",", "# 128-256", "\n", "[", "256", "**", "2", ",", "512", "**", "2", "]", ",", "# 256-512", "\n", "[", "512", "**", "2", ",", "1e5", "**", "2", "]", ",", "\n", "]", "# 512-inf", "\n", "assert", "area", "in", "areas", ",", "\"Unknown area range: {}\"", ".", "format", "(", "area", ")", "\n", "area_range", "=", "area_ranges", "[", "areas", "[", "area", "]", "]", "\n", "gt_overlaps", "=", "[", "]", "\n", "num_pos", "=", "0", "\n", "\n", "for", "prediction_dict", "in", "dataset_predictions", ":", "\n", "        ", "predictions", "=", "prediction_dict", "[", "\"proposals\"", "]", "\n", "\n", "# sort predictions in descending order", "\n", "# TODO maybe remove this and make it explicit in the documentation", "\n", "inds", "=", "predictions", ".", "objectness_logits", ".", "sort", "(", "descending", "=", "True", ")", "[", "1", "]", "\n", "predictions", "=", "predictions", "[", "inds", "]", "\n", "\n", "ann_ids", "=", "lvis_api", ".", "get_ann_ids", "(", "img_ids", "=", "[", "prediction_dict", "[", "\"image_id\"", "]", "]", ")", "\n", "anno", "=", "lvis_api", ".", "load_anns", "(", "ann_ids", ")", "\n", "gt_boxes", "=", "[", "\n", "BoxMode", ".", "convert", "(", "obj", "[", "\"bbox\"", "]", ",", "BoxMode", ".", "XYWH_ABS", ",", "BoxMode", ".", "XYXY_ABS", ")", "for", "obj", "in", "anno", "\n", "]", "\n", "gt_boxes", "=", "torch", ".", "as_tensor", "(", "gt_boxes", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "# guard against no boxes", "\n", "gt_boxes", "=", "Boxes", "(", "gt_boxes", ")", "\n", "gt_areas", "=", "torch", ".", "as_tensor", "(", "[", "obj", "[", "\"area\"", "]", "for", "obj", "in", "anno", "]", ")", "\n", "\n", "if", "len", "(", "gt_boxes", ")", "==", "0", "or", "len", "(", "predictions", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "valid_gt_inds", "=", "(", "gt_areas", ">=", "area_range", "[", "0", "]", ")", "&", "(", "gt_areas", "<=", "area_range", "[", "1", "]", ")", "\n", "gt_boxes", "=", "gt_boxes", "[", "valid_gt_inds", "]", "\n", "\n", "num_pos", "+=", "len", "(", "gt_boxes", ")", "\n", "\n", "if", "len", "(", "gt_boxes", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "if", "limit", "is", "not", "None", "and", "len", "(", "predictions", ")", ">", "limit", ":", "\n", "            ", "predictions", "=", "predictions", "[", ":", "limit", "]", "\n", "\n", "", "overlaps", "=", "pairwise_iou", "(", "predictions", ".", "proposal_boxes", ",", "gt_boxes", ")", "\n", "\n", "_gt_overlaps", "=", "torch", ".", "zeros", "(", "len", "(", "gt_boxes", ")", ")", "\n", "for", "j", "in", "range", "(", "min", "(", "len", "(", "predictions", ")", ",", "len", "(", "gt_boxes", ")", ")", ")", ":", "\n", "# find which proposal box maximally covers each gt box", "\n", "# and get the iou amount of coverage for each gt box", "\n", "            ", "max_overlaps", ",", "argmax_overlaps", "=", "overlaps", ".", "max", "(", "dim", "=", "0", ")", "\n", "\n", "# find which gt box is 'best' covered (i.e. 'best' = most iou)", "\n", "gt_ovr", ",", "gt_ind", "=", "max_overlaps", ".", "max", "(", "dim", "=", "0", ")", "\n", "assert", "gt_ovr", ">=", "0", "\n", "# find the proposal box that covers the best covered gt box", "\n", "box_ind", "=", "argmax_overlaps", "[", "gt_ind", "]", "\n", "# record the iou coverage of this gt box", "\n", "_gt_overlaps", "[", "j", "]", "=", "overlaps", "[", "box_ind", ",", "gt_ind", "]", "\n", "assert", "_gt_overlaps", "[", "j", "]", "==", "gt_ovr", "\n", "# mark the proposal box and the gt box as used", "\n", "overlaps", "[", "box_ind", ",", ":", "]", "=", "-", "1", "\n", "overlaps", "[", ":", ",", "gt_ind", "]", "=", "-", "1", "\n", "\n", "# append recorded iou coverage level", "\n", "", "gt_overlaps", ".", "append", "(", "_gt_overlaps", ")", "\n", "", "gt_overlaps", "=", "(", "\n", "torch", ".", "cat", "(", "gt_overlaps", ",", "dim", "=", "0", ")", "if", "len", "(", "gt_overlaps", ")", "else", "torch", ".", "zeros", "(", "0", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", ")", "\n", "gt_overlaps", ",", "_", "=", "torch", ".", "sort", "(", "gt_overlaps", ")", "\n", "\n", "if", "thresholds", "is", "None", ":", "\n", "        ", "step", "=", "0.05", "\n", "thresholds", "=", "torch", ".", "arange", "(", "0.5", ",", "0.95", "+", "1e-5", ",", "step", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "", "recalls", "=", "torch", ".", "zeros_like", "(", "thresholds", ")", "\n", "# compute recall for each iou threshold", "\n", "for", "i", ",", "t", "in", "enumerate", "(", "thresholds", ")", ":", "\n", "        ", "recalls", "[", "i", "]", "=", "(", "gt_overlaps", ">=", "t", ")", ".", "float", "(", ")", ".", "sum", "(", ")", "/", "float", "(", "num_pos", ")", "\n", "# ar = 2 * np.trapz(recalls, thresholds)", "\n", "", "ar", "=", "recalls", ".", "mean", "(", ")", "\n", "return", "{", "\n", "\"ar\"", ":", "ar", ",", "\n", "\"recalls\"", ":", "recalls", ",", "\n", "\"thresholds\"", ":", "thresholds", ",", "\n", "\"gt_overlaps\"", ":", "gt_overlaps", ",", "\n", "\"num_pos\"", ":", "num_pos", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.lvis_evaluation._evaluate_predictions_on_lvis": [[308, 351], ["logging.getLogger", "LVISResults", "LVISEval", "LVISEval.run", "LVISEval.print_results", "LVISEval.get_results", "logging.getLogger.info", "len", "logging.getLogger.warn", "copy.deepcopy", "float", "float", "c.pop", "detectron2.utils.logger.create_small_table"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.create_small_table"], ["", "def", "_evaluate_predictions_on_lvis", "(", "lvis_gt", ",", "lvis_results", ",", "iou_type", ",", "class_names", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        iou_type (str):\n        kpt_oks_sigmas (list[float]):\n        class_names (None or list[str]): if provided, will use it to predict\n            per-category AP.\n\n    Returns:\n        a dict of {metric name: score}\n    \"\"\"", "\n", "metrics", "=", "{", "\n", "\"bbox\"", ":", "[", "\"AP\"", ",", "\"AP50\"", ",", "\"AP75\"", ",", "\"APs\"", ",", "\"APm\"", ",", "\"APl\"", ",", "\"APr\"", ",", "\"APc\"", ",", "\"APf\"", "]", ",", "\n", "\"segm\"", ":", "[", "\"AP\"", ",", "\"AP50\"", ",", "\"AP75\"", ",", "\"APs\"", ",", "\"APm\"", ",", "\"APl\"", ",", "\"APr\"", ",", "\"APc\"", ",", "\"APf\"", "]", ",", "\n", "}", "[", "iou_type", "]", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "if", "len", "(", "lvis_results", ")", "==", "0", ":", "# TODO: check if needed", "\n", "        ", "logger", ".", "warn", "(", "\"No predictions from the model!\"", ")", "\n", "return", "{", "metric", ":", "float", "(", "\"nan\"", ")", "for", "metric", "in", "metrics", "}", "\n", "\n", "", "if", "iou_type", "==", "\"segm\"", ":", "\n", "        ", "lvis_results", "=", "copy", ".", "deepcopy", "(", "lvis_results", ")", "\n", "# When evaluating mask AP, if the results contain bbox, LVIS API will", "\n", "# use the box area as the area of the instance, instead of the mask area.", "\n", "# This leads to a different definition of small/medium/large.", "\n", "# We remove the bbox field to let mask AP use mask area.", "\n", "for", "c", "in", "lvis_results", ":", "\n", "            ", "c", ".", "pop", "(", "\"bbox\"", ",", "None", ")", "\n", "\n", "", "", "from", "lvis", "import", "LVISEval", ",", "LVISResults", "\n", "\n", "lvis_results", "=", "LVISResults", "(", "lvis_gt", ",", "lvis_results", ")", "\n", "lvis_eval", "=", "LVISEval", "(", "lvis_gt", ",", "lvis_results", ",", "iou_type", ")", "\n", "lvis_eval", ".", "run", "(", ")", "\n", "lvis_eval", ".", "print_results", "(", ")", "\n", "\n", "# Pull the standard metrics from the LVIS results", "\n", "results", "=", "lvis_eval", ".", "get_results", "(", ")", "\n", "results", "=", "{", "metric", ":", "float", "(", "results", "[", "metric", "]", "*", "100", ")", "for", "metric", "in", "metrics", "}", "\n", "logger", ".", "info", "(", "\"Evaluation results for {}: \\n\"", ".", "format", "(", "iou_type", ")", "+", "create_small_table", "(", "results", ")", ")", "\n", "return", "results", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.coco_evaluation.COCOEvaluator.__init__": [[40, 93], ["coco_evaluation.COCOEvaluator._tasks_from_config", "torch.device", "logging.getLogger", "detectron2.data.MetadataCatalog.get", "fvcore.common.file_io.PathManager.get_local_path", "hasattr", "coco_evaluation.COCOEvaluator._logger.info", "os.path.join", "detectron2.data.datasets.coco.convert_to_coco_json", "contextlib.redirect_stdout", "pycocotools.coco.COCO", "io.StringIO"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.coco_evaluation.COCOEvaluator._tasks_from_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["def", "__init__", "(", "self", ",", "dataset_name", ",", "cfg", ",", "distributed", ",", "output_dir", "=", "None", ",", "*", ",", "use_fast_impl", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_name (str): name of the dataset to be evaluated.\n                It must have either the following corresponding metadata:\n\n                    \"json_file\": the path to the COCO format annotation\n\n                Or it must be in detectron2's standard dataset format\n                so it can be converted to COCO format automatically.\n            cfg (CfgNode): config instance\n            distributed (True): if True, will collect results from all ranks and run evaluation\n                in the main process.\n                Otherwise, will only evaluate the results in the current process.\n            output_dir (str): optional, an output directory to dump all\n                results predicted on the dataset. The dump contains two files:\n\n                1. \"instance_predictions.pth\" a file in torch serialization\n                   format that contains all the raw original predictions.\n                2. \"coco_instances_results.json\" a json file in COCO's result\n                   format.\n            use_fast_impl (bool): use a fast but **unofficial** implementation to compute AP.\n                Although the results should be very close to the official implementation in COCO\n                API, it is still recommended to compute results with the official API for use in\n                papers.\n        \"\"\"", "\n", "self", ".", "_tasks", "=", "self", ".", "_tasks_from_config", "(", "cfg", ")", "\n", "self", ".", "_distributed", "=", "distributed", "\n", "self", ".", "_output_dir", "=", "output_dir", "\n", "self", ".", "_use_fast_impl", "=", "use_fast_impl", "\n", "\n", "self", ".", "_cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "self", ".", "_logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "self", ".", "_metadata", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", "\n", "if", "not", "hasattr", "(", "self", ".", "_metadata", ",", "\"json_file\"", ")", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\n", "f\"'{dataset_name}' is not registered by `register_coco_instances`.\"", "\n", "\" Therefore trying to convert it to COCO format ...\"", "\n", ")", "\n", "\n", "cache_path", "=", "os", ".", "path", ".", "join", "(", "output_dir", ",", "f\"{dataset_name}_coco_format.json\"", ")", "\n", "self", ".", "_metadata", ".", "json_file", "=", "cache_path", "\n", "convert_to_coco_json", "(", "dataset_name", ",", "cache_path", ")", "\n", "\n", "", "json_file", "=", "PathManager", ".", "get_local_path", "(", "self", ".", "_metadata", ".", "json_file", ")", "\n", "with", "contextlib", ".", "redirect_stdout", "(", "io", ".", "StringIO", "(", ")", ")", ":", "\n", "            ", "self", ".", "_coco_api", "=", "COCO", "(", "json_file", ")", "\n", "\n", "", "self", ".", "_kpt_oks_sigmas", "=", "cfg", ".", "TEST", ".", "KEYPOINT_OKS_SIGMAS", "\n", "# Test set json files do not contain annotations (evaluation must be", "\n", "# performed using the COCO evaluation server).", "\n", "self", ".", "_do_evaluation", "=", "\"annotations\"", "in", "self", ".", "_coco_api", ".", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.coco_evaluation.COCOEvaluator.reset": [[94, 96], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_predictions", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.coco_evaluation.COCOEvaluator._tasks_from_config": [[97, 108], ["None"], "methods", ["None"], ["", "def", "_tasks_from_config", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            tuple[str]: tasks that can be evaluated under the given configuration.\n        \"\"\"", "\n", "tasks", "=", "(", "\"bbox\"", ",", ")", "\n", "if", "cfg", ".", "MODEL", ".", "MASK_ON", ":", "\n", "            ", "tasks", "=", "tasks", "+", "(", "\"segm\"", ",", ")", "\n", "", "if", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ":", "\n", "            ", "tasks", "=", "tasks", "+", "(", "\"keypoints\"", ",", ")", "\n", "", "return", "tasks", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.coco_evaluation.COCOEvaluator.process": [[109, 127], ["zip", "coco_evaluation.COCOEvaluator._predictions.append", "output[].to", "coco_evaluation.instances_to_coco_json", "output[].to"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.coco_evaluation.instances_to_coco_json", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            inputs: the inputs to a COCO model (e.g., GeneralizedRCNN).\n                It is a list of dict. Each dict corresponds to an image and\n                contains keys like \"height\", \"width\", \"file_name\", \"image_id\".\n            outputs: the outputs of a COCO model. It is a list of dicts with key\n                \"instances\" that contains :class:`Instances`.\n        \"\"\"", "\n", "for", "input", ",", "output", "in", "zip", "(", "inputs", ",", "outputs", ")", ":", "\n", "            ", "prediction", "=", "{", "\"image_id\"", ":", "input", "[", "\"image_id\"", "]", "}", "\n", "\n", "if", "\"instances\"", "in", "output", ":", "\n", "                ", "instances", "=", "output", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "_cpu_device", ")", "\n", "prediction", "[", "\"instances\"", "]", "=", "instances_to_coco_json", "(", "instances", ",", "input", "[", "\"image_id\"", "]", ")", "\n", "", "if", "\"proposals\"", "in", "output", ":", "\n", "                ", "prediction", "[", "\"proposals\"", "]", "=", "output", "[", "\"proposals\"", "]", ".", "to", "(", "self", ".", "_cpu_device", ")", "\n", "", "self", ".", "_predictions", ".", "append", "(", "prediction", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.coco_evaluation.COCOEvaluator.evaluate": [[128, 156], ["collections.OrderedDict", "copy.deepcopy", "detectron2.synchronize", "detectron2.gather", "list", "len", "coco_evaluation.COCOEvaluator._logger.warning", "fvcore.common.file_io.PathManager.mkdirs", "os.path.join", "coco_evaluation.COCOEvaluator._eval_box_proposals", "coco_evaluation.COCOEvaluator._eval_predictions", "itertools.chain", "detectron2.is_main_process", "fvcore.common.file_io.PathManager.open", "torch.save", "set"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.synchronize", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.coco_evaluation.COCOEvaluator._eval_box_proposals", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator.DensePoseCOCOEvaluator._eval_predictions", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["", "", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_distributed", ":", "\n", "            ", "comm", ".", "synchronize", "(", ")", "\n", "predictions", "=", "comm", ".", "gather", "(", "self", ".", "_predictions", ",", "dst", "=", "0", ")", "\n", "predictions", "=", "list", "(", "itertools", ".", "chain", "(", "*", "predictions", ")", ")", "\n", "\n", "if", "not", "comm", ".", "is_main_process", "(", ")", ":", "\n", "                ", "return", "{", "}", "\n", "", "", "else", ":", "\n", "            ", "predictions", "=", "self", ".", "_predictions", "\n", "\n", "", "if", "len", "(", "predictions", ")", "==", "0", ":", "\n", "            ", "self", ".", "_logger", ".", "warning", "(", "\"[COCOEvaluator] Did not receive valid predictions.\"", ")", "\n", "return", "{", "}", "\n", "\n", "", "if", "self", ".", "_output_dir", ":", "\n", "            ", "PathManager", ".", "mkdirs", "(", "self", ".", "_output_dir", ")", "\n", "file_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_output_dir", ",", "\"instances_predictions.pth\"", ")", "\n", "with", "PathManager", ".", "open", "(", "file_path", ",", "\"wb\"", ")", "as", "f", ":", "\n", "                ", "torch", ".", "save", "(", "predictions", ",", "f", ")", "\n", "\n", "", "", "self", ".", "_results", "=", "OrderedDict", "(", ")", "\n", "if", "\"proposals\"", "in", "predictions", "[", "0", "]", ":", "\n", "            ", "self", ".", "_eval_box_proposals", "(", "predictions", ")", "\n", "", "if", "\"instances\"", "in", "predictions", "[", "0", "]", ":", "\n", "            ", "self", ".", "_eval_predictions", "(", "set", "(", "self", ".", "_tasks", ")", ",", "predictions", ")", "\n", "# Copy so the caller can do whatever with results", "\n", "", "return", "copy", ".", "deepcopy", "(", "self", ".", "_results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.coco_evaluation.COCOEvaluator._eval_predictions": [[157, 212], ["coco_evaluation.COCOEvaluator._logger.info", "list", "hasattr", "coco_evaluation.COCOEvaluator._logger.info", "sorted", "itertools.chain", "os.path.join", "coco_evaluation.COCOEvaluator._logger.info", "coco_evaluation.COCOEvaluator._logger.info", "coco_evaluation.COCOEvaluator._derive_coco_results", "fvcore.common.file_io.PathManager.open", "f.write", "f.flush", "coco_evaluation._evaluate_predictions_on_coco", "coco_evaluation.COCOEvaluator._metadata.thing_dataset_id_to_contiguous_id.items", "json.dumps", "len", "coco_evaluation.COCOEvaluator._metadata.get"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.coco_evaluation.COCOEvaluator._derive_coco_results", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator._evaluate_predictions_on_coco", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "def", "_eval_predictions", "(", "self", ",", "tasks", ",", "predictions", ")", ":", "\n", "        ", "\"\"\"\n        Evaluate predictions on the given tasks.\n        Fill self._results with the metrics of the tasks.\n        \"\"\"", "\n", "self", ".", "_logger", ".", "info", "(", "\"Preparing results for COCO format ...\"", ")", "\n", "coco_results", "=", "list", "(", "itertools", ".", "chain", "(", "*", "[", "x", "[", "\"instances\"", "]", "for", "x", "in", "predictions", "]", ")", ")", "\n", "\n", "# unmap the category ids for COCO", "\n", "if", "hasattr", "(", "self", ".", "_metadata", ",", "\"thing_dataset_id_to_contiguous_id\"", ")", ":", "\n", "            ", "reverse_id_mapping", "=", "{", "\n", "v", ":", "k", "for", "k", ",", "v", "in", "self", ".", "_metadata", ".", "thing_dataset_id_to_contiguous_id", ".", "items", "(", ")", "\n", "}", "\n", "for", "result", "in", "coco_results", ":", "\n", "                ", "category_id", "=", "result", "[", "\"category_id\"", "]", "\n", "assert", "(", "\n", "category_id", "in", "reverse_id_mapping", "\n", ")", ",", "\"A prediction has category_id={}, which is not available in the dataset.\"", ".", "format", "(", "\n", "category_id", "\n", ")", "\n", "result", "[", "\"category_id\"", "]", "=", "reverse_id_mapping", "[", "category_id", "]", "\n", "\n", "", "", "if", "self", ".", "_output_dir", ":", "\n", "            ", "file_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_output_dir", ",", "\"coco_instances_results.json\"", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\"Saving results to {}\"", ".", "format", "(", "file_path", ")", ")", "\n", "with", "PathManager", ".", "open", "(", "file_path", ",", "\"w\"", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "json", ".", "dumps", "(", "coco_results", ")", ")", "\n", "f", ".", "flush", "(", ")", "\n", "\n", "", "", "if", "not", "self", ".", "_do_evaluation", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\"Annotations are not available for evaluation.\"", ")", "\n", "return", "\n", "\n", "", "self", ".", "_logger", ".", "info", "(", "\n", "\"Evaluating predictions with {} COCO API...\"", ".", "format", "(", "\n", "\"unofficial\"", "if", "self", ".", "_use_fast_impl", "else", "\"official\"", "\n", ")", "\n", ")", "\n", "for", "task", "in", "sorted", "(", "tasks", ")", ":", "\n", "            ", "coco_eval", "=", "(", "\n", "_evaluate_predictions_on_coco", "(", "\n", "self", ".", "_coco_api", ",", "\n", "coco_results", ",", "\n", "task", ",", "\n", "kpt_oks_sigmas", "=", "self", ".", "_kpt_oks_sigmas", ",", "\n", "use_fast_impl", "=", "self", ".", "_use_fast_impl", ",", "\n", ")", "\n", "if", "len", "(", "coco_results", ")", ">", "0", "\n", "else", "None", "# cocoapi does not handle empty results very well", "\n", ")", "\n", "\n", "res", "=", "self", ".", "_derive_coco_results", "(", "\n", "coco_eval", ",", "task", ",", "class_names", "=", "self", ".", "_metadata", ".", "get", "(", "\"thing_classes\"", ")", "\n", ")", "\n", "self", ".", "_results", "[", "task", "]", "=", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.coco_evaluation.COCOEvaluator._eval_box_proposals": [[213, 251], ["coco_evaluation.COCOEvaluator._logger.info", "coco_evaluation.COCOEvaluator._logger.info", "coco_evaluation.COCOEvaluator._logger.info", "areas.items", "ids.append", "boxes.append", "objectness_logits.append", "fvcore.common.file_io.PathManager.open", "pickle.dump", "coco_evaluation._evaluate_box_proposals", "float", "detectron2.utils.logger.create_small_table", "prediction[].proposal_boxes.tensor.numpy", "prediction[].objectness_logits.numpy", "os.path.join", "stats[].item"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.dump", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.coco_evaluation._evaluate_box_proposals", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.create_small_table"], ["", "", "def", "_eval_box_proposals", "(", "self", ",", "predictions", ")", ":", "\n", "        ", "\"\"\"\n        Evaluate the box proposals in predictions.\n        Fill self._results with the metrics for \"box_proposals\" task.\n        \"\"\"", "\n", "if", "self", ".", "_output_dir", ":", "\n", "# Saving generated box proposals to file.", "\n", "# Predicted box_proposals are in XYXY_ABS mode.", "\n", "            ", "bbox_mode", "=", "BoxMode", ".", "XYXY_ABS", ".", "value", "\n", "ids", ",", "boxes", ",", "objectness_logits", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "prediction", "in", "predictions", ":", "\n", "                ", "ids", ".", "append", "(", "prediction", "[", "\"image_id\"", "]", ")", "\n", "boxes", ".", "append", "(", "prediction", "[", "\"proposals\"", "]", ".", "proposal_boxes", ".", "tensor", ".", "numpy", "(", ")", ")", "\n", "objectness_logits", ".", "append", "(", "prediction", "[", "\"proposals\"", "]", ".", "objectness_logits", ".", "numpy", "(", ")", ")", "\n", "\n", "", "proposal_data", "=", "{", "\n", "\"boxes\"", ":", "boxes", ",", "\n", "\"objectness_logits\"", ":", "objectness_logits", ",", "\n", "\"ids\"", ":", "ids", ",", "\n", "\"bbox_mode\"", ":", "bbox_mode", ",", "\n", "}", "\n", "with", "PathManager", ".", "open", "(", "os", ".", "path", ".", "join", "(", "self", ".", "_output_dir", ",", "\"box_proposals.pkl\"", ")", ",", "\"wb\"", ")", "as", "f", ":", "\n", "                ", "pickle", ".", "dump", "(", "proposal_data", ",", "f", ")", "\n", "\n", "", "", "if", "not", "self", ".", "_do_evaluation", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\"Annotations are not available for evaluation.\"", ")", "\n", "return", "\n", "\n", "", "self", ".", "_logger", ".", "info", "(", "\"Evaluating bbox proposals ...\"", ")", "\n", "res", "=", "{", "}", "\n", "areas", "=", "{", "\"all\"", ":", "\"\"", ",", "\"small\"", ":", "\"s\"", ",", "\"medium\"", ":", "\"m\"", ",", "\"large\"", ":", "\"l\"", "}", "\n", "for", "limit", "in", "[", "100", ",", "1000", "]", ":", "\n", "            ", "for", "area", ",", "suffix", "in", "areas", ".", "items", "(", ")", ":", "\n", "                ", "stats", "=", "_evaluate_box_proposals", "(", "predictions", ",", "self", ".", "_coco_api", ",", "area", "=", "area", ",", "limit", "=", "limit", ")", "\n", "key", "=", "\"AR{}@{:d}\"", ".", "format", "(", "suffix", ",", "limit", ")", "\n", "res", "[", "key", "]", "=", "float", "(", "stats", "[", "\"ar\"", "]", ".", "item", "(", ")", "*", "100", ")", "\n", "", "", "self", ".", "_logger", ".", "info", "(", "\"Proposal metrics: \\n\"", "+", "create_small_table", "(", "res", ")", ")", "\n", "self", ".", "_results", "[", "\"box_proposals\"", "]", "=", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.coco_evaluation.COCOEvaluator._derive_coco_results": [[252, 319], ["coco_evaluation.COCOEvaluator._logger.info", "enumerate", "min", "list", "itertools.zip_longest", "tabulate.tabulate.tabulate", "coco_evaluation.COCOEvaluator._logger.info", "results.update", "coco_evaluation.COCOEvaluator._logger.warn", "float", "numpy.isfinite", "coco_evaluation.COCOEvaluator._logger.info", "len", "results_per_category.append", "itertools.chain", "float", "enumerate", "detectron2.utils.logger.create_small_table", "sum", "len", "numpy.mean", "float", "len", "results.values", "float", "range"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.create_small_table"], ["", "def", "_derive_coco_results", "(", "self", ",", "coco_eval", ",", "iou_type", ",", "class_names", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Derive the desired score numbers from summarized COCOeval.\n\n        Args:\n            coco_eval (None or COCOEval): None represents no predictions from model.\n            iou_type (str):\n            class_names (None or list[str]): if provided, will use it to predict\n                per-category AP.\n\n        Returns:\n            a dict of {metric name: score}\n        \"\"\"", "\n", "\n", "metrics", "=", "{", "\n", "\"bbox\"", ":", "[", "\"AP\"", ",", "\"AP50\"", ",", "\"AP75\"", ",", "\"APs\"", ",", "\"APm\"", ",", "\"APl\"", "]", ",", "\n", "\"segm\"", ":", "[", "\"AP\"", ",", "\"AP50\"", ",", "\"AP75\"", ",", "\"APs\"", ",", "\"APm\"", ",", "\"APl\"", "]", ",", "\n", "\"keypoints\"", ":", "[", "\"AP\"", ",", "\"AP50\"", ",", "\"AP75\"", ",", "\"APm\"", ",", "\"APl\"", "]", ",", "\n", "}", "[", "iou_type", "]", "\n", "\n", "if", "coco_eval", "is", "None", ":", "\n", "            ", "self", ".", "_logger", ".", "warn", "(", "\"No predictions from the model!\"", ")", "\n", "return", "{", "metric", ":", "float", "(", "\"nan\"", ")", "for", "metric", "in", "metrics", "}", "\n", "\n", "# the standard metrics", "\n", "", "results", "=", "{", "\n", "metric", ":", "float", "(", "coco_eval", ".", "stats", "[", "idx", "]", "*", "100", "if", "coco_eval", ".", "stats", "[", "idx", "]", ">=", "0", "else", "\"nan\"", ")", "\n", "for", "idx", ",", "metric", "in", "enumerate", "(", "metrics", ")", "\n", "}", "\n", "self", ".", "_logger", ".", "info", "(", "\n", "\"Evaluation results for {}: \\n\"", ".", "format", "(", "iou_type", ")", "+", "create_small_table", "(", "results", ")", "\n", ")", "\n", "if", "not", "np", ".", "isfinite", "(", "sum", "(", "results", ".", "values", "(", ")", ")", ")", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\"Some metrics cannot be computed and is shown as NaN.\"", ")", "\n", "\n", "", "if", "class_names", "is", "None", "or", "len", "(", "class_names", ")", "<=", "1", ":", "\n", "            ", "return", "results", "\n", "# Compute per-category AP", "\n", "# from https://github.com/facebookresearch/Detectron/blob/a6a835f5b8208c45d0dce217ce9bbda915f44df7/detectron/datasets/json_dataset_evaluator.py#L222-L252 # noqa", "\n", "", "precisions", "=", "coco_eval", ".", "eval", "[", "\"precision\"", "]", "\n", "# precision has dims (iou, recall, cls, area range, max dets)", "\n", "assert", "len", "(", "class_names", ")", "==", "precisions", ".", "shape", "[", "2", "]", "\n", "\n", "results_per_category", "=", "[", "]", "\n", "for", "idx", ",", "name", "in", "enumerate", "(", "class_names", ")", ":", "\n", "# area range index 0: all area ranges", "\n", "# max dets index -1: typically 100 per image", "\n", "            ", "precision", "=", "precisions", "[", ":", ",", ":", ",", "idx", ",", "0", ",", "-", "1", "]", "\n", "precision", "=", "precision", "[", "precision", ">", "-", "1", "]", "\n", "ap", "=", "np", ".", "mean", "(", "precision", ")", "if", "precision", ".", "size", "else", "float", "(", "\"nan\"", ")", "\n", "results_per_category", ".", "append", "(", "(", "\"{}\"", ".", "format", "(", "name", ")", ",", "float", "(", "ap", "*", "100", ")", ")", ")", "\n", "\n", "# tabulate it", "\n", "", "N_COLS", "=", "min", "(", "6", ",", "len", "(", "results_per_category", ")", "*", "2", ")", "\n", "results_flatten", "=", "list", "(", "itertools", ".", "chain", "(", "*", "results_per_category", ")", ")", "\n", "results_2d", "=", "itertools", ".", "zip_longest", "(", "*", "[", "results_flatten", "[", "i", ":", ":", "N_COLS", "]", "for", "i", "in", "range", "(", "N_COLS", ")", "]", ")", "\n", "table", "=", "tabulate", "(", "\n", "results_2d", ",", "\n", "tablefmt", "=", "\"pipe\"", ",", "\n", "floatfmt", "=", "\".3f\"", ",", "\n", "headers", "=", "[", "\"category\"", ",", "\"AP\"", "]", "*", "(", "N_COLS", "//", "2", ")", ",", "\n", "numalign", "=", "\"left\"", ",", "\n", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\"Per-category {} AP: \\n\"", ".", "format", "(", "iou_type", ")", "+", "table", ")", "\n", "\n", "results", ".", "update", "(", "{", "\"AP-\"", "+", "name", ":", "ap", "for", "name", ",", "ap", "in", "results_per_category", "}", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.coco_evaluation.instances_to_coco_json": [[321, 381], ["len", "instances.pred_boxes.tensor.numpy", "detectron2.structures.BoxMode.convert", "boxes.tolist.tolist", "instances.scores.tolist", "instances.pred_classes.tolist", "instances.has", "instances.has", "range", "results.append", "rle[].decode", "keypoints[].flatten().tolist", "pycocotools.encode", "numpy.array", "keypoints[].flatten"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten"], ["", "", "def", "instances_to_coco_json", "(", "instances", ",", "img_id", ")", ":", "\n", "    ", "\"\"\"\n    Dump an \"Instances\" object to a COCO-format json that's used for evaluation.\n\n    Args:\n        instances (Instances):\n        img_id (int): the image id\n\n    Returns:\n        list[dict]: list of json annotations in COCO format.\n    \"\"\"", "\n", "num_instance", "=", "len", "(", "instances", ")", "\n", "if", "num_instance", "==", "0", ":", "\n", "        ", "return", "[", "]", "\n", "\n", "", "boxes", "=", "instances", ".", "pred_boxes", ".", "tensor", ".", "numpy", "(", ")", "\n", "boxes", "=", "BoxMode", ".", "convert", "(", "boxes", ",", "BoxMode", ".", "XYXY_ABS", ",", "BoxMode", ".", "XYWH_ABS", ")", "\n", "boxes", "=", "boxes", ".", "tolist", "(", ")", "\n", "scores", "=", "instances", ".", "scores", ".", "tolist", "(", ")", "\n", "classes", "=", "instances", ".", "pred_classes", ".", "tolist", "(", ")", "\n", "\n", "has_mask", "=", "instances", ".", "has", "(", "\"pred_masks\"", ")", "\n", "if", "has_mask", ":", "\n", "# use RLE to encode the masks, because they are too large and takes memory", "\n", "# since this evaluator stores outputs of the entire dataset", "\n", "        ", "rles", "=", "[", "\n", "mask_util", ".", "encode", "(", "np", ".", "array", "(", "mask", "[", ":", ",", ":", ",", "None", "]", ",", "order", "=", "\"F\"", ",", "dtype", "=", "\"uint8\"", ")", ")", "[", "0", "]", "\n", "for", "mask", "in", "instances", ".", "pred_masks", "\n", "]", "\n", "for", "rle", "in", "rles", ":", "\n", "# \"counts\" is an array encoded by mask_util as a byte-stream. Python3's", "\n", "# json writer which always produces strings cannot serialize a bytestream", "\n", "# unless you decode it. Thankfully, utf-8 works out (which is also what", "\n", "# the pycocotools/_mask.pyx does).", "\n", "            ", "rle", "[", "\"counts\"", "]", "=", "rle", "[", "\"counts\"", "]", ".", "decode", "(", "\"utf-8\"", ")", "\n", "\n", "", "", "has_keypoints", "=", "instances", ".", "has", "(", "\"pred_keypoints\"", ")", "\n", "if", "has_keypoints", ":", "\n", "        ", "keypoints", "=", "instances", ".", "pred_keypoints", "\n", "\n", "", "results", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "num_instance", ")", ":", "\n", "        ", "result", "=", "{", "\n", "\"image_id\"", ":", "img_id", ",", "\n", "\"category_id\"", ":", "classes", "[", "k", "]", ",", "\n", "\"bbox\"", ":", "boxes", "[", "k", "]", ",", "\n", "\"score\"", ":", "scores", "[", "k", "]", ",", "\n", "}", "\n", "if", "has_mask", ":", "\n", "            ", "result", "[", "\"segmentation\"", "]", "=", "rles", "[", "k", "]", "\n", "", "if", "has_keypoints", ":", "\n", "# In COCO annotations,", "\n", "# keypoints coordinates are pixel indices.", "\n", "# However our predictions are floating point coordinates.", "\n", "# Therefore we subtract 0.5 to be consistent with the annotation format.", "\n", "# This is the inverse of data loading logic in `datasets/coco.py`.", "\n", "            ", "keypoints", "[", "k", "]", "[", ":", ",", ":", "2", "]", "-=", "0.5", "\n", "result", "[", "\"keypoints\"", "]", "=", "keypoints", "[", "k", "]", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "\n", "", "results", ".", "append", "(", "result", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.coco_evaluation._evaluate_box_proposals": [[385, 493], ["torch.sort", "torch.zeros_like", "enumerate", "torch.zeros_like.mean", "coco_api.getAnnIds", "coco_api.loadAnns", "torch.as_tensor().reshape", "detectron2.structures.Boxes", "torch.as_tensor", "len", "detectron2.structures.pairwise_iou", "torch.zeros", "range", "gt_overlaps.append", "len", "torch.cat", "torch.zeros", "torch.arange", "predictions.objectness_logits.sort", "detectron2.structures.BoxMode.convert", "len", "len", "min", "detectron2.structures.pairwise_iou.max", "max_overlaps.max", "float", "torch.as_tensor", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.pairwise_iou", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "def", "_evaluate_box_proposals", "(", "dataset_predictions", ",", "coco_api", ",", "thresholds", "=", "None", ",", "area", "=", "\"all\"", ",", "limit", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Evaluate detection proposal recall metrics. This function is a much\n    faster alternative to the official COCO API recall evaluation code. However,\n    it produces slightly different results.\n    \"\"\"", "\n", "# Record max overlap value for each gt box", "\n", "# Return vector of overlap values", "\n", "areas", "=", "{", "\n", "\"all\"", ":", "0", ",", "\n", "\"small\"", ":", "1", ",", "\n", "\"medium\"", ":", "2", ",", "\n", "\"large\"", ":", "3", ",", "\n", "\"96-128\"", ":", "4", ",", "\n", "\"128-256\"", ":", "5", ",", "\n", "\"256-512\"", ":", "6", ",", "\n", "\"512-inf\"", ":", "7", ",", "\n", "}", "\n", "area_ranges", "=", "[", "\n", "[", "0", "**", "2", ",", "1e5", "**", "2", "]", ",", "# all", "\n", "[", "0", "**", "2", ",", "32", "**", "2", "]", ",", "# small", "\n", "[", "32", "**", "2", ",", "96", "**", "2", "]", ",", "# medium", "\n", "[", "96", "**", "2", ",", "1e5", "**", "2", "]", ",", "# large", "\n", "[", "96", "**", "2", ",", "128", "**", "2", "]", ",", "# 96-128", "\n", "[", "128", "**", "2", ",", "256", "**", "2", "]", ",", "# 128-256", "\n", "[", "256", "**", "2", ",", "512", "**", "2", "]", ",", "# 256-512", "\n", "[", "512", "**", "2", ",", "1e5", "**", "2", "]", ",", "\n", "]", "# 512-inf", "\n", "assert", "area", "in", "areas", ",", "\"Unknown area range: {}\"", ".", "format", "(", "area", ")", "\n", "area_range", "=", "area_ranges", "[", "areas", "[", "area", "]", "]", "\n", "gt_overlaps", "=", "[", "]", "\n", "num_pos", "=", "0", "\n", "\n", "for", "prediction_dict", "in", "dataset_predictions", ":", "\n", "        ", "predictions", "=", "prediction_dict", "[", "\"proposals\"", "]", "\n", "\n", "# sort predictions in descending order", "\n", "# TODO maybe remove this and make it explicit in the documentation", "\n", "inds", "=", "predictions", ".", "objectness_logits", ".", "sort", "(", "descending", "=", "True", ")", "[", "1", "]", "\n", "predictions", "=", "predictions", "[", "inds", "]", "\n", "\n", "ann_ids", "=", "coco_api", ".", "getAnnIds", "(", "imgIds", "=", "prediction_dict", "[", "\"image_id\"", "]", ")", "\n", "anno", "=", "coco_api", ".", "loadAnns", "(", "ann_ids", ")", "\n", "gt_boxes", "=", "[", "\n", "BoxMode", ".", "convert", "(", "obj", "[", "\"bbox\"", "]", ",", "BoxMode", ".", "XYWH_ABS", ",", "BoxMode", ".", "XYXY_ABS", ")", "\n", "for", "obj", "in", "anno", "\n", "if", "obj", "[", "\"iscrowd\"", "]", "==", "0", "\n", "]", "\n", "gt_boxes", "=", "torch", ".", "as_tensor", "(", "gt_boxes", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "# guard against no boxes", "\n", "gt_boxes", "=", "Boxes", "(", "gt_boxes", ")", "\n", "gt_areas", "=", "torch", ".", "as_tensor", "(", "[", "obj", "[", "\"area\"", "]", "for", "obj", "in", "anno", "if", "obj", "[", "\"iscrowd\"", "]", "==", "0", "]", ")", "\n", "\n", "if", "len", "(", "gt_boxes", ")", "==", "0", "or", "len", "(", "predictions", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "valid_gt_inds", "=", "(", "gt_areas", ">=", "area_range", "[", "0", "]", ")", "&", "(", "gt_areas", "<=", "area_range", "[", "1", "]", ")", "\n", "gt_boxes", "=", "gt_boxes", "[", "valid_gt_inds", "]", "\n", "\n", "num_pos", "+=", "len", "(", "gt_boxes", ")", "\n", "\n", "if", "len", "(", "gt_boxes", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "if", "limit", "is", "not", "None", "and", "len", "(", "predictions", ")", ">", "limit", ":", "\n", "            ", "predictions", "=", "predictions", "[", ":", "limit", "]", "\n", "\n", "", "overlaps", "=", "pairwise_iou", "(", "predictions", ".", "proposal_boxes", ",", "gt_boxes", ")", "\n", "\n", "_gt_overlaps", "=", "torch", ".", "zeros", "(", "len", "(", "gt_boxes", ")", ")", "\n", "for", "j", "in", "range", "(", "min", "(", "len", "(", "predictions", ")", ",", "len", "(", "gt_boxes", ")", ")", ")", ":", "\n", "# find which proposal box maximally covers each gt box", "\n", "# and get the iou amount of coverage for each gt box", "\n", "            ", "max_overlaps", ",", "argmax_overlaps", "=", "overlaps", ".", "max", "(", "dim", "=", "0", ")", "\n", "\n", "# find which gt box is 'best' covered (i.e. 'best' = most iou)", "\n", "gt_ovr", ",", "gt_ind", "=", "max_overlaps", ".", "max", "(", "dim", "=", "0", ")", "\n", "assert", "gt_ovr", ">=", "0", "\n", "# find the proposal box that covers the best covered gt box", "\n", "box_ind", "=", "argmax_overlaps", "[", "gt_ind", "]", "\n", "# record the iou coverage of this gt box", "\n", "_gt_overlaps", "[", "j", "]", "=", "overlaps", "[", "box_ind", ",", "gt_ind", "]", "\n", "assert", "_gt_overlaps", "[", "j", "]", "==", "gt_ovr", "\n", "# mark the proposal box and the gt box as used", "\n", "overlaps", "[", "box_ind", ",", ":", "]", "=", "-", "1", "\n", "overlaps", "[", ":", ",", "gt_ind", "]", "=", "-", "1", "\n", "\n", "# append recorded iou coverage level", "\n", "", "gt_overlaps", ".", "append", "(", "_gt_overlaps", ")", "\n", "", "gt_overlaps", "=", "(", "\n", "torch", ".", "cat", "(", "gt_overlaps", ",", "dim", "=", "0", ")", "if", "len", "(", "gt_overlaps", ")", "else", "torch", ".", "zeros", "(", "0", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", ")", "\n", "gt_overlaps", ",", "_", "=", "torch", ".", "sort", "(", "gt_overlaps", ")", "\n", "\n", "if", "thresholds", "is", "None", ":", "\n", "        ", "step", "=", "0.05", "\n", "thresholds", "=", "torch", ".", "arange", "(", "0.5", ",", "0.95", "+", "1e-5", ",", "step", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "", "recalls", "=", "torch", ".", "zeros_like", "(", "thresholds", ")", "\n", "# compute recall for each iou threshold", "\n", "for", "i", ",", "t", "in", "enumerate", "(", "thresholds", ")", ":", "\n", "        ", "recalls", "[", "i", "]", "=", "(", "gt_overlaps", ">=", "t", ")", ".", "float", "(", ")", ".", "sum", "(", ")", "/", "float", "(", "num_pos", ")", "\n", "# ar = 2 * np.trapz(recalls, thresholds)", "\n", "", "ar", "=", "recalls", ".", "mean", "(", ")", "\n", "return", "{", "\n", "\"ar\"", ":", "ar", ",", "\n", "\"recalls\"", ":", "recalls", ",", "\n", "\"thresholds\"", ":", "thresholds", ",", "\n", "\"gt_overlaps\"", ":", "gt_overlaps", ",", "\n", "\"num_pos\"", ":", "num_pos", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.coco_evaluation._evaluate_predictions_on_coco": [[496, 539], ["coco_gt.loadRes", "coco_eval.evaluate", "coco_eval.accumulate", "coco_eval.summarize", "len", "copy.deepcopy", "len", "c.pop", "hasattr", "numpy.array", "len", "len", "next", "iter", "coco_gt.anns.values"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.deepcluster_hook.DeepClusterHook.evaluate", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.accumulate", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.summarize", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.iter"], ["", "def", "_evaluate_predictions_on_coco", "(", "\n", "coco_gt", ",", "coco_results", ",", "iou_type", ",", "kpt_oks_sigmas", "=", "None", ",", "use_fast_impl", "=", "True", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Evaluate the coco results using COCOEval API.\n    \"\"\"", "\n", "assert", "len", "(", "coco_results", ")", ">", "0", "\n", "\n", "if", "iou_type", "==", "\"segm\"", ":", "\n", "        ", "coco_results", "=", "copy", ".", "deepcopy", "(", "coco_results", ")", "\n", "# When evaluating mask AP, if the results contain bbox, cocoapi will", "\n", "# use the box area as the area of the instance, instead of the mask area.", "\n", "# This leads to a different definition of small/medium/large.", "\n", "# We remove the bbox field to let mask AP use mask area.", "\n", "for", "c", "in", "coco_results", ":", "\n", "            ", "c", ".", "pop", "(", "\"bbox\"", ",", "None", ")", "\n", "\n", "", "", "coco_dt", "=", "coco_gt", ".", "loadRes", "(", "coco_results", ")", "\n", "coco_eval", "=", "(", "COCOeval_opt", "if", "use_fast_impl", "else", "COCOeval", ")", "(", "coco_gt", ",", "coco_dt", ",", "iou_type", ")", "\n", "\n", "if", "iou_type", "==", "\"keypoints\"", ":", "\n", "# Use the COCO default keypoint OKS sigmas unless overrides are specified", "\n", "        ", "if", "kpt_oks_sigmas", ":", "\n", "            ", "assert", "hasattr", "(", "coco_eval", ".", "params", ",", "\"kpt_oks_sigmas\"", ")", ",", "\"pycocotools is too old!\"", "\n", "coco_eval", ".", "params", ".", "kpt_oks_sigmas", "=", "np", ".", "array", "(", "kpt_oks_sigmas", ")", "\n", "# COCOAPI requires every detection and every gt to have keypoints, so", "\n", "# we just take the first entry from both", "\n", "", "num_keypoints_dt", "=", "len", "(", "coco_results", "[", "0", "]", "[", "\"keypoints\"", "]", ")", "//", "3", "\n", "num_keypoints_gt", "=", "len", "(", "next", "(", "iter", "(", "coco_gt", ".", "anns", ".", "values", "(", ")", ")", ")", "[", "\"keypoints\"", "]", ")", "//", "3", "\n", "num_keypoints_oks", "=", "len", "(", "coco_eval", ".", "params", ".", "kpt_oks_sigmas", ")", "\n", "assert", "num_keypoints_oks", "==", "num_keypoints_dt", "==", "num_keypoints_gt", ",", "(", "\n", "f\"[COCOEvaluator] Prediction contain {num_keypoints_dt} keypoints. \"", "\n", "f\"Ground truth contains {num_keypoints_gt} keypoints. \"", "\n", "f\"The length of cfg.TEST.KEYPOINT_OKS_SIGMAS is {num_keypoints_oks}. \"", "\n", "\"They have to agree with each other. For meaning of OKS, please refer to \"", "\n", "\"http://cocodataset.org/#keypoints-eval.\"", "\n", ")", "\n", "\n", "", "coco_eval", ".", "evaluate", "(", ")", "\n", "coco_eval", ".", "accumulate", "(", ")", "\n", "coco_eval", ".", "summarize", "(", ")", "\n", "\n", "return", "coco_eval", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.panoptic_evaluation.COCOPanopticEvaluator.__init__": [[31, 47], ["detectron2.data.MetadataCatalog.get", "fvcore.common.file_io.PathManager.mkdirs", "os.path.join", "panoptic_evaluation.COCOPanopticEvaluator._metadata.thing_dataset_id_to_contiguous_id.items", "panoptic_evaluation.COCOPanopticEvaluator._metadata.stuff_dataset_id_to_contiguous_id.items"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["def", "__init__", "(", "self", ",", "dataset_name", ",", "output_dir", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_name (str): name of the dataset\n            output_dir (str): output directory to save results for evaluation\n        \"\"\"", "\n", "self", ".", "_metadata", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", "\n", "self", ".", "_thing_contiguous_id_to_dataset_id", "=", "{", "\n", "v", ":", "k", "for", "k", ",", "v", "in", "self", ".", "_metadata", ".", "thing_dataset_id_to_contiguous_id", ".", "items", "(", ")", "\n", "}", "\n", "self", ".", "_stuff_contiguous_id_to_dataset_id", "=", "{", "\n", "v", ":", "k", "for", "k", ",", "v", "in", "self", ".", "_metadata", ".", "stuff_dataset_id_to_contiguous_id", ".", "items", "(", ")", "\n", "}", "\n", "\n", "PathManager", ".", "mkdirs", "(", "output_dir", ")", "\n", "self", ".", "_predictions_json", "=", "os", ".", "path", ".", "join", "(", "output_dir", ",", "\"predictions.json\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.panoptic_evaluation.COCOPanopticEvaluator.reset": [[48, 50], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_predictions", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.panoptic_evaluation.COCOPanopticEvaluator._convert_category_id": [[51, 65], ["segment_info.pop"], "methods", ["None"], ["", "def", "_convert_category_id", "(", "self", ",", "segment_info", ")", ":", "\n", "        ", "isthing", "=", "segment_info", ".", "pop", "(", "\"isthing\"", ",", "None", ")", "\n", "if", "isthing", "is", "None", ":", "\n", "# the model produces panoptic category id directly. No more conversion needed", "\n", "            ", "return", "segment_info", "\n", "", "if", "isthing", "is", "True", ":", "\n", "            ", "segment_info", "[", "\"category_id\"", "]", "=", "self", ".", "_thing_contiguous_id_to_dataset_id", "[", "\n", "segment_info", "[", "\"category_id\"", "]", "\n", "]", "\n", "", "else", ":", "\n", "            ", "segment_info", "[", "\"category_id\"", "]", "=", "self", ".", "_stuff_contiguous_id_to_dataset_id", "[", "\n", "segment_info", "[", "\"category_id\"", "]", "\n", "]", "\n", "", "return", "segment_info", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.panoptic_evaluation.COCOPanopticEvaluator.process": [[66, 109], ["zip", "panoptic_img.cpu().numpy.cpu().numpy.cpu().numpy", "os.path.basename", "numpy.unique", "io.BytesIO", "PIL.Image.fromarray().save", "panoptic_evaluation.COCOPanopticEvaluator._predictions.append", "panoptic_img.cpu().numpy.cpu().numpy.cpu", "segments_info.append", "os.path.splitext", "panoptic_evaluation.COCOPanopticEvaluator._convert_category_id", "panoptic_evaluation.COCOPanopticEvaluator._metadata.thing_dataset_id_to_contiguous_id.values", "PIL.Image.fromarray", "out.getvalue", "int", "bool", "id2rgb", "int"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.panoptic_evaluation.COCOPanopticEvaluator._convert_category_id"], ["", "def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "from", "panopticapi", ".", "utils", "import", "id2rgb", "\n", "\n", "for", "input", ",", "output", "in", "zip", "(", "inputs", ",", "outputs", ")", ":", "\n", "            ", "panoptic_img", ",", "segments_info", "=", "output", "[", "\"panoptic_seg\"", "]", "\n", "panoptic_img", "=", "panoptic_img", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "segments_info", "is", "None", ":", "\n", "# If \"segments_info\" is None, we assume \"panoptic_img\" is a", "\n", "# H*W int32 image storing the panoptic_id in the format of", "\n", "# category_id * label_divisor + instance_id. We reserve -1 for", "\n", "# VOID label, and add 1 to panoptic_img since the official", "\n", "# evaluation script uses 0 for VOID label.", "\n", "                ", "label_divisor", "=", "self", ".", "_metadata", ".", "label_divisor", "\n", "segments_info", "=", "[", "]", "\n", "for", "panoptic_label", "in", "np", ".", "unique", "(", "panoptic_img", ")", ":", "\n", "                    ", "if", "panoptic_label", "==", "-", "1", ":", "\n", "# VOID region.", "\n", "                        ", "continue", "\n", "", "pred_class", "=", "panoptic_label", "//", "label_divisor", "\n", "isthing", "=", "(", "\n", "pred_class", "in", "self", ".", "_metadata", ".", "thing_dataset_id_to_contiguous_id", ".", "values", "(", ")", "\n", ")", "\n", "segments_info", ".", "append", "(", "\n", "{", "\n", "\"id\"", ":", "int", "(", "panoptic_label", ")", "+", "1", ",", "\n", "\"category_id\"", ":", "int", "(", "pred_class", ")", ",", "\n", "\"isthing\"", ":", "bool", "(", "isthing", ")", ",", "\n", "}", "\n", ")", "\n", "# Official evaluation script uses 0 for VOID label.", "\n", "", "panoptic_img", "+=", "1", "\n", "\n", "", "file_name", "=", "os", ".", "path", ".", "basename", "(", "input", "[", "\"file_name\"", "]", ")", "\n", "file_name_png", "=", "os", ".", "path", ".", "splitext", "(", "file_name", ")", "[", "0", "]", "+", "\".png\"", "\n", "with", "io", ".", "BytesIO", "(", ")", "as", "out", ":", "\n", "                ", "Image", ".", "fromarray", "(", "id2rgb", "(", "panoptic_img", ")", ")", ".", "save", "(", "out", ",", "format", "=", "\"PNG\"", ")", "\n", "segments_info", "=", "[", "self", ".", "_convert_category_id", "(", "x", ")", "for", "x", "in", "segments_info", "]", "\n", "self", ".", "_predictions", ".", "append", "(", "\n", "{", "\n", "\"image_id\"", ":", "input", "[", "\"image_id\"", "]", ",", "\n", "\"file_name\"", ":", "file_name_png", ",", "\n", "\"png_string\"", ":", "out", ".", "getvalue", "(", ")", ",", "\n", "\"segments_info\"", ":", "segments_info", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.panoptic_evaluation.COCOPanopticEvaluator.evaluate": [[112, 161], ["detectron2.utils.comm.synchronize", "detectron2.utils.comm.gather", "list", "fvcore.common.file_io.PathManager.get_local_path", "fvcore.common.file_io.PathManager.get_local_path", "collections.OrderedDict", "panoptic_evaluation._print_panoptic_results", "itertools.chain", "detectron2.utils.comm.is_main_process", "tempfile.TemporaryDirectory", "logger.info", "open", "json.load", "fvcore.common.file_io.PathManager.open", "f.write", "contextlib.redirect_stdout", "pq_compute", "open", "f.write", "json.dumps", "io.StringIO", "fvcore.common.file_io.PathManager.get_local_path", "os.path.join", "p.pop"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.synchronize", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.panoptic_evaluation._print_panoptic_results", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write"], ["", "", "", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "comm", ".", "synchronize", "(", ")", "\n", "\n", "self", ".", "_predictions", "=", "comm", ".", "gather", "(", "self", ".", "_predictions", ")", "\n", "self", ".", "_predictions", "=", "list", "(", "itertools", ".", "chain", "(", "*", "self", ".", "_predictions", ")", ")", "\n", "if", "not", "comm", ".", "is_main_process", "(", ")", ":", "\n", "            ", "return", "\n", "\n", "# PanopticApi requires local files", "\n", "", "gt_json", "=", "PathManager", ".", "get_local_path", "(", "self", ".", "_metadata", ".", "panoptic_json", ")", "\n", "gt_folder", "=", "PathManager", ".", "get_local_path", "(", "self", ".", "_metadata", ".", "panoptic_root", ")", "\n", "\n", "with", "tempfile", ".", "TemporaryDirectory", "(", "prefix", "=", "\"panoptic_eval\"", ")", "as", "pred_dir", ":", "\n", "            ", "logger", ".", "info", "(", "\"Writing all panoptic predictions to {} ...\"", ".", "format", "(", "pred_dir", ")", ")", "\n", "for", "p", "in", "self", ".", "_predictions", ":", "\n", "                ", "with", "open", "(", "os", ".", "path", ".", "join", "(", "pred_dir", ",", "p", "[", "\"file_name\"", "]", ")", ",", "\"wb\"", ")", "as", "f", ":", "\n", "                    ", "f", ".", "write", "(", "p", ".", "pop", "(", "\"png_string\"", ")", ")", "\n", "\n", "", "", "with", "open", "(", "gt_json", ",", "\"r\"", ")", "as", "f", ":", "\n", "                ", "json_data", "=", "json", ".", "load", "(", "f", ")", "\n", "", "json_data", "[", "\"annotations\"", "]", "=", "self", ".", "_predictions", "\n", "with", "PathManager", ".", "open", "(", "self", ".", "_predictions_json", ",", "\"w\"", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "json", ".", "dumps", "(", "json_data", ")", ")", "\n", "\n", "", "from", "panopticapi", ".", "evaluation", "import", "pq_compute", "\n", "\n", "with", "contextlib", ".", "redirect_stdout", "(", "io", ".", "StringIO", "(", ")", ")", ":", "\n", "                ", "pq_res", "=", "pq_compute", "(", "\n", "gt_json", ",", "\n", "PathManager", ".", "get_local_path", "(", "self", ".", "_predictions_json", ")", ",", "\n", "gt_folder", "=", "gt_folder", ",", "\n", "pred_folder", "=", "pred_dir", ",", "\n", ")", "\n", "\n", "", "", "res", "=", "{", "}", "\n", "res", "[", "\"PQ\"", "]", "=", "100", "*", "pq_res", "[", "\"All\"", "]", "[", "\"pq\"", "]", "\n", "res", "[", "\"SQ\"", "]", "=", "100", "*", "pq_res", "[", "\"All\"", "]", "[", "\"sq\"", "]", "\n", "res", "[", "\"RQ\"", "]", "=", "100", "*", "pq_res", "[", "\"All\"", "]", "[", "\"rq\"", "]", "\n", "res", "[", "\"PQ_th\"", "]", "=", "100", "*", "pq_res", "[", "\"Things\"", "]", "[", "\"pq\"", "]", "\n", "res", "[", "\"SQ_th\"", "]", "=", "100", "*", "pq_res", "[", "\"Things\"", "]", "[", "\"sq\"", "]", "\n", "res", "[", "\"RQ_th\"", "]", "=", "100", "*", "pq_res", "[", "\"Things\"", "]", "[", "\"rq\"", "]", "\n", "res", "[", "\"PQ_st\"", "]", "=", "100", "*", "pq_res", "[", "\"Stuff\"", "]", "[", "\"pq\"", "]", "\n", "res", "[", "\"SQ_st\"", "]", "=", "100", "*", "pq_res", "[", "\"Stuff\"", "]", "[", "\"sq\"", "]", "\n", "res", "[", "\"RQ_st\"", "]", "=", "100", "*", "pq_res", "[", "\"Stuff\"", "]", "[", "\"rq\"", "]", "\n", "\n", "results", "=", "OrderedDict", "(", "{", "\"panoptic_seg\"", ":", "res", "}", ")", "\n", "_print_panoptic_results", "(", "pq_res", ")", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.panoptic_evaluation._print_panoptic_results": [[163, 173], ["tabulate.tabulate", "logger.info", "data.append"], "function", ["None"], ["", "", "def", "_print_panoptic_results", "(", "pq_res", ")", ":", "\n", "    ", "headers", "=", "[", "\"\"", ",", "\"PQ\"", ",", "\"SQ\"", ",", "\"RQ\"", ",", "\"#categories\"", "]", "\n", "data", "=", "[", "]", "\n", "for", "name", "in", "[", "\"All\"", ",", "\"Things\"", ",", "\"Stuff\"", "]", ":", "\n", "        ", "row", "=", "[", "name", "]", "+", "[", "pq_res", "[", "name", "]", "[", "k", "]", "*", "100", "for", "k", "in", "[", "\"pq\"", ",", "\"sq\"", ",", "\"rq\"", "]", "]", "+", "[", "pq_res", "[", "name", "]", "[", "\"n\"", "]", "]", "\n", "data", ".", "append", "(", "row", ")", "\n", "", "table", "=", "tabulate", "(", "\n", "data", ",", "headers", "=", "headers", ",", "tablefmt", "=", "\"pipe\"", ",", "floatfmt", "=", "\".3f\"", ",", "stralign", "=", "\"center\"", ",", "numalign", "=", "\"center\"", "\n", ")", "\n", "logger", ".", "info", "(", "\"Panoptic Evaluation Results:\\n\"", "+", "table", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.__init__": [[31, 45], ["detectron2.data.MetadataCatalog.get", "os.path.join", "os.path.join", "torch.device", "logging.getLogger"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device"], ["def", "__init__", "(", "self", ",", "dataset_name", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_name (str): name of the dataset, e.g., \"voc_2007_test\"\n        \"\"\"", "\n", "self", ".", "_dataset_name", "=", "dataset_name", "\n", "meta", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", "\n", "self", ".", "_anno_file_template", "=", "os", ".", "path", ".", "join", "(", "meta", ".", "dirname", ",", "\"Annotations\"", ",", "\"{}.xml\"", ")", "\n", "self", ".", "_image_set_path", "=", "os", ".", "path", ".", "join", "(", "meta", ".", "dirname", ",", "\"ImageSets\"", ",", "\"Main\"", ",", "meta", ".", "split", "+", "\".txt\"", ")", "\n", "self", ".", "_class_names", "=", "meta", ".", "thing_classes", "\n", "assert", "meta", ".", "year", "in", "[", "2007", ",", "2012", "]", ",", "meta", ".", "year", "\n", "self", ".", "_is_2007", "=", "meta", ".", "year", "==", "2007", "\n", "self", ".", "_cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "self", ".", "_logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.reset": [[46, 48], ["collections.defaultdict"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_predictions", "=", "defaultdict", "(", "list", ")", "# class name -> list of prediction strings", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.process": [[49, 63], ["zip", "output[].to", "output[].to.pred_boxes.tensor.numpy", "output[].to.scores.tolist", "output[].to.pred_classes.tolist", "zip", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._predictions[].append"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "for", "input", ",", "output", "in", "zip", "(", "inputs", ",", "outputs", ")", ":", "\n", "            ", "image_id", "=", "input", "[", "\"image_id\"", "]", "\n", "instances", "=", "output", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "_cpu_device", ")", "\n", "boxes", "=", "instances", ".", "pred_boxes", ".", "tensor", ".", "numpy", "(", ")", "\n", "scores", "=", "instances", ".", "scores", ".", "tolist", "(", ")", "\n", "classes", "=", "instances", ".", "pred_classes", ".", "tolist", "(", ")", "\n", "for", "box", ",", "score", ",", "cls", "in", "zip", "(", "boxes", ",", "scores", ",", "classes", ")", ":", "\n", "                ", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "=", "box", "\n", "# The inverse of data loading logic in `datasets/pascal_voc.py`", "\n", "xmin", "+=", "1", "\n", "ymin", "+=", "1", "\n", "self", ".", "_predictions", "[", "cls", "]", ".", "append", "(", "\n", "f\"{image_id} {score:.3f} {xmin:.1f} {ymin:.1f} {xmax:.1f} {ymax:.1f}\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.evaluate": [[65, 111], ["detectron2.utils.comm.gather", "collections.defaultdict", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "collections.OrderedDict", "detectron2.utils.comm.is_main_process", "predictions_per_rank.items", "tempfile.TemporaryDirectory", "os.path.join", "collections.defaultdict", "enumerate", "numpy.mean", "numpy.mean", "predictions[].extend", "collections.defaultdict.get", "range", "collections.defaultdict.items", "list", "open", "f.write", "pascal_voc_evaluation.voc_eval", "aps[].append", "mAP.values", "os.path.join.format"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.pascal_voc_evaluation.voc_eval"], ["", "", "", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            dict: has a key \"segm\", whose value is a dict of \"AP\", \"AP50\", and \"AP75\".\n        \"\"\"", "\n", "all_predictions", "=", "comm", ".", "gather", "(", "self", ".", "_predictions", ",", "dst", "=", "0", ")", "\n", "if", "not", "comm", ".", "is_main_process", "(", ")", ":", "\n", "            ", "return", "\n", "", "predictions", "=", "defaultdict", "(", "list", ")", "\n", "for", "predictions_per_rank", "in", "all_predictions", ":", "\n", "            ", "for", "clsid", ",", "lines", "in", "predictions_per_rank", ".", "items", "(", ")", ":", "\n", "                ", "predictions", "[", "clsid", "]", ".", "extend", "(", "lines", ")", "\n", "", "", "del", "all_predictions", "\n", "\n", "self", ".", "_logger", ".", "info", "(", "\n", "\"Evaluating {} using {} metric. \"", "\n", "\"Note that results do not use the official Matlab API.\"", ".", "format", "(", "\n", "self", ".", "_dataset_name", ",", "2007", "if", "self", ".", "_is_2007", "else", "2012", "\n", ")", "\n", ")", "\n", "\n", "with", "tempfile", ".", "TemporaryDirectory", "(", "prefix", "=", "\"pascal_voc_eval_\"", ")", "as", "dirname", ":", "\n", "            ", "res_file_template", "=", "os", ".", "path", ".", "join", "(", "dirname", ",", "\"{}.txt\"", ")", "\n", "\n", "aps", "=", "defaultdict", "(", "list", ")", "# iou -> ap per class", "\n", "for", "cls_id", ",", "cls_name", "in", "enumerate", "(", "self", ".", "_class_names", ")", ":", "\n", "                ", "lines", "=", "predictions", ".", "get", "(", "cls_id", ",", "[", "\"\"", "]", ")", "\n", "\n", "with", "open", "(", "res_file_template", ".", "format", "(", "cls_name", ")", ",", "\"w\"", ")", "as", "f", ":", "\n", "                    ", "f", ".", "write", "(", "\"\\n\"", ".", "join", "(", "lines", ")", ")", "\n", "\n", "", "for", "thresh", "in", "range", "(", "50", ",", "100", ",", "5", ")", ":", "\n", "                    ", "rec", ",", "prec", ",", "ap", "=", "voc_eval", "(", "\n", "res_file_template", ",", "\n", "self", ".", "_anno_file_template", ",", "\n", "self", ".", "_image_set_path", ",", "\n", "cls_name", ",", "\n", "ovthresh", "=", "thresh", "/", "100.0", ",", "\n", "use_07_metric", "=", "self", ".", "_is_2007", ",", "\n", ")", "\n", "aps", "[", "thresh", "]", ".", "append", "(", "ap", "*", "100", ")", "\n", "\n", "", "", "", "ret", "=", "OrderedDict", "(", ")", "\n", "mAP", "=", "{", "iou", ":", "np", ".", "mean", "(", "x", ")", "for", "iou", ",", "x", "in", "aps", ".", "items", "(", ")", "}", "\n", "ret", "[", "\"bbox\"", "]", "=", "{", "\"AP\"", ":", "np", ".", "mean", "(", "list", "(", "mAP", ".", "values", "(", ")", ")", ")", ",", "\"AP50\"", ":", "mAP", "[", "50", "]", ",", "\"AP75\"", ":", "mAP", "[", "75", "]", "}", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.pascal_voc_evaluation.parse_rec": [[126, 148], ["functools.lru_cache", "ET.parse.findall", "fvcore.common.file_io.PathManager.open", "xml.parse", "int", "int", "obj.find", "objects.append", "obj.find", "obj.find", "int", "int", "int", "int", "obj.find", "obj.find", "obj.find.find", "obj.find.find", "obj.find.find", "obj.find.find"], "function", ["None"], ["@", "lru_cache", "(", "maxsize", "=", "None", ")", "\n", "def", "parse_rec", "(", "filename", ")", ":", "\n", "    ", "\"\"\"Parse a PASCAL VOC xml file.\"\"\"", "\n", "with", "PathManager", ".", "open", "(", "filename", ")", "as", "f", ":", "\n", "        ", "tree", "=", "ET", ".", "parse", "(", "f", ")", "\n", "", "objects", "=", "[", "]", "\n", "for", "obj", "in", "tree", ".", "findall", "(", "\"object\"", ")", ":", "\n", "        ", "obj_struct", "=", "{", "}", "\n", "obj_struct", "[", "\"name\"", "]", "=", "obj", ".", "find", "(", "\"name\"", ")", ".", "text", "\n", "obj_struct", "[", "\"pose\"", "]", "=", "obj", ".", "find", "(", "\"pose\"", ")", ".", "text", "\n", "obj_struct", "[", "\"truncated\"", "]", "=", "int", "(", "obj", ".", "find", "(", "\"truncated\"", ")", ".", "text", ")", "\n", "obj_struct", "[", "\"difficult\"", "]", "=", "int", "(", "obj", ".", "find", "(", "\"difficult\"", ")", ".", "text", ")", "\n", "bbox", "=", "obj", ".", "find", "(", "\"bndbox\"", ")", "\n", "obj_struct", "[", "\"bbox\"", "]", "=", "[", "\n", "int", "(", "bbox", ".", "find", "(", "\"xmin\"", ")", ".", "text", ")", ",", "\n", "int", "(", "bbox", ".", "find", "(", "\"ymin\"", ")", ".", "text", ")", ",", "\n", "int", "(", "bbox", ".", "find", "(", "\"xmax\"", ")", ".", "text", ")", ",", "\n", "int", "(", "bbox", ".", "find", "(", "\"ymax\"", ")", ".", "text", ")", ",", "\n", "]", "\n", "objects", ".", "append", "(", "obj_struct", ")", "\n", "\n", "", "return", "objects", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.pascal_voc_evaluation.voc_ap": [[150, 180], ["numpy.arange", "numpy.concatenate", "numpy.concatenate", "range", "numpy.sum", "numpy.maximum", "numpy.where", "numpy.sum", "numpy.max"], "function", ["None"], ["", "def", "voc_ap", "(", "rec", ",", "prec", ",", "use_07_metric", "=", "False", ")", ":", "\n", "    ", "\"\"\"Compute VOC AP given precision and recall. If use_07_metric is true, uses\n    the VOC 07 11-point method (default:False).\n    \"\"\"", "\n", "if", "use_07_metric", ":", "\n", "# 11 point metric", "\n", "        ", "ap", "=", "0.0", "\n", "for", "t", "in", "np", ".", "arange", "(", "0.0", ",", "1.1", ",", "0.1", ")", ":", "\n", "            ", "if", "np", ".", "sum", "(", "rec", ">=", "t", ")", "==", "0", ":", "\n", "                ", "p", "=", "0", "\n", "", "else", ":", "\n", "                ", "p", "=", "np", ".", "max", "(", "prec", "[", "rec", ">=", "t", "]", ")", "\n", "", "ap", "=", "ap", "+", "p", "/", "11.0", "\n", "", "", "else", ":", "\n", "# correct AP calculation", "\n", "# first append sentinel values at the end", "\n", "        ", "mrec", "=", "np", ".", "concatenate", "(", "(", "[", "0.0", "]", ",", "rec", ",", "[", "1.0", "]", ")", ")", "\n", "mpre", "=", "np", ".", "concatenate", "(", "(", "[", "0.0", "]", ",", "prec", ",", "[", "0.0", "]", ")", ")", "\n", "\n", "# compute the precision envelope", "\n", "for", "i", "in", "range", "(", "mpre", ".", "size", "-", "1", ",", "0", ",", "-", "1", ")", ":", "\n", "            ", "mpre", "[", "i", "-", "1", "]", "=", "np", ".", "maximum", "(", "mpre", "[", "i", "-", "1", "]", ",", "mpre", "[", "i", "]", ")", "\n", "\n", "# to calculate area under PR curve, look for points", "\n", "# where X axis (recall) changes value", "\n", "", "i", "=", "np", ".", "where", "(", "mrec", "[", "1", ":", "]", "!=", "mrec", "[", ":", "-", "1", "]", ")", "[", "0", "]", "\n", "\n", "# and sum (\\Delta recall) * prec", "\n", "ap", "=", "np", ".", "sum", "(", "(", "mrec", "[", "i", "+", "1", "]", "-", "mrec", "[", "i", "]", ")", "*", "mpre", "[", "i", "+", "1", "]", ")", "\n", "", "return", "ap", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.pascal_voc_evaluation.voc_eval": [[182, 296], ["detpath.format", "numpy.array", "numpy.array().reshape", "numpy.argsort", "len", "numpy.zeros", "numpy.zeros", "range", "numpy.cumsum", "numpy.cumsum", "pascal_voc_evaluation.voc_ap", "fvcore.common.file_io.PathManager.open", "f.readlines", "x.strip", "pascal_voc_evaluation.parse_rec", "numpy.array", "numpy.array().astype", "open", "f.readlines", "x.strip().split", "BB[].astype", "R[].astype", "float", "numpy.maximum", "annopath.format", "len", "sum", "float", "numpy.array", "numpy.maximum", "numpy.maximum", "numpy.minimum", "numpy.minimum", "numpy.maximum", "numpy.maximum", "numpy.max", "numpy.argmax", "numpy.array", "x.strip", "numpy.finfo", "float"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.pascal_voc_evaluation.voc_ap", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.pascal_voc_evaluation.parse_rec"], ["", "def", "voc_eval", "(", "detpath", ",", "annopath", ",", "imagesetfile", ",", "classname", ",", "ovthresh", "=", "0.5", ",", "use_07_metric", "=", "False", ")", ":", "\n", "    ", "\"\"\"rec, prec, ap = voc_eval(detpath,\n                                annopath,\n                                imagesetfile,\n                                classname,\n                                [ovthresh],\n                                [use_07_metric])\n\n    Top level function that does the PASCAL VOC evaluation.\n\n    detpath: Path to detections\n        detpath.format(classname) should produce the detection results file.\n    annopath: Path to annotations\n        annopath.format(imagename) should be the xml annotations file.\n    imagesetfile: Text file containing the list of images, one image per line.\n    classname: Category name (duh)\n    [ovthresh]: Overlap threshold (default = 0.5)\n    [use_07_metric]: Whether to use VOC07's 11 point AP computation\n        (default False)\n    \"\"\"", "\n", "# assumes detections are in detpath.format(classname)", "\n", "# assumes annotations are in annopath.format(imagename)", "\n", "# assumes imagesetfile is a text file with each line an image name", "\n", "\n", "# first load gt", "\n", "# read list of images", "\n", "with", "PathManager", ".", "open", "(", "imagesetfile", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "", "imagenames", "=", "[", "x", ".", "strip", "(", ")", "for", "x", "in", "lines", "]", "\n", "\n", "# load annots", "\n", "recs", "=", "{", "}", "\n", "for", "imagename", "in", "imagenames", ":", "\n", "        ", "recs", "[", "imagename", "]", "=", "parse_rec", "(", "annopath", ".", "format", "(", "imagename", ")", ")", "\n", "\n", "# extract gt objects for this class", "\n", "", "class_recs", "=", "{", "}", "\n", "npos", "=", "0", "\n", "for", "imagename", "in", "imagenames", ":", "\n", "        ", "R", "=", "[", "obj", "for", "obj", "in", "recs", "[", "imagename", "]", "if", "obj", "[", "\"name\"", "]", "==", "classname", "]", "\n", "bbox", "=", "np", ".", "array", "(", "[", "x", "[", "\"bbox\"", "]", "for", "x", "in", "R", "]", ")", "\n", "difficult", "=", "np", ".", "array", "(", "[", "x", "[", "\"difficult\"", "]", "for", "x", "in", "R", "]", ")", ".", "astype", "(", "np", ".", "bool", ")", "\n", "# difficult = np.array([False for x in R]).astype(np.bool)  # treat all \"difficult\" as GT", "\n", "det", "=", "[", "False", "]", "*", "len", "(", "R", ")", "\n", "npos", "=", "npos", "+", "sum", "(", "~", "difficult", ")", "\n", "class_recs", "[", "imagename", "]", "=", "{", "\"bbox\"", ":", "bbox", ",", "\"difficult\"", ":", "difficult", ",", "\"det\"", ":", "det", "}", "\n", "\n", "# read dets", "\n", "", "detfile", "=", "detpath", ".", "format", "(", "classname", ")", "\n", "with", "open", "(", "detfile", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "\n", "", "splitlines", "=", "[", "x", ".", "strip", "(", ")", ".", "split", "(", "\" \"", ")", "for", "x", "in", "lines", "]", "\n", "image_ids", "=", "[", "x", "[", "0", "]", "for", "x", "in", "splitlines", "]", "\n", "confidence", "=", "np", ".", "array", "(", "[", "float", "(", "x", "[", "1", "]", ")", "for", "x", "in", "splitlines", "]", ")", "\n", "BB", "=", "np", ".", "array", "(", "[", "[", "float", "(", "z", ")", "for", "z", "in", "x", "[", "2", ":", "]", "]", "for", "x", "in", "splitlines", "]", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "\n", "# sort by confidence", "\n", "sorted_ind", "=", "np", ".", "argsort", "(", "-", "confidence", ")", "\n", "BB", "=", "BB", "[", "sorted_ind", ",", ":", "]", "\n", "image_ids", "=", "[", "image_ids", "[", "x", "]", "for", "x", "in", "sorted_ind", "]", "\n", "\n", "# go down dets and mark TPs and FPs", "\n", "nd", "=", "len", "(", "image_ids", ")", "\n", "tp", "=", "np", ".", "zeros", "(", "nd", ")", "\n", "fp", "=", "np", ".", "zeros", "(", "nd", ")", "\n", "for", "d", "in", "range", "(", "nd", ")", ":", "\n", "        ", "R", "=", "class_recs", "[", "image_ids", "[", "d", "]", "]", "\n", "bb", "=", "BB", "[", "d", ",", ":", "]", ".", "astype", "(", "float", ")", "\n", "ovmax", "=", "-", "np", ".", "inf", "\n", "BBGT", "=", "R", "[", "\"bbox\"", "]", ".", "astype", "(", "float", ")", "\n", "\n", "if", "BBGT", ".", "size", ">", "0", ":", "\n", "# compute overlaps", "\n", "# intersection", "\n", "            ", "ixmin", "=", "np", ".", "maximum", "(", "BBGT", "[", ":", ",", "0", "]", ",", "bb", "[", "0", "]", ")", "\n", "iymin", "=", "np", ".", "maximum", "(", "BBGT", "[", ":", ",", "1", "]", ",", "bb", "[", "1", "]", ")", "\n", "ixmax", "=", "np", ".", "minimum", "(", "BBGT", "[", ":", ",", "2", "]", ",", "bb", "[", "2", "]", ")", "\n", "iymax", "=", "np", ".", "minimum", "(", "BBGT", "[", ":", ",", "3", "]", ",", "bb", "[", "3", "]", ")", "\n", "iw", "=", "np", ".", "maximum", "(", "ixmax", "-", "ixmin", "+", "1.0", ",", "0.0", ")", "\n", "ih", "=", "np", ".", "maximum", "(", "iymax", "-", "iymin", "+", "1.0", ",", "0.0", ")", "\n", "inters", "=", "iw", "*", "ih", "\n", "\n", "# union", "\n", "uni", "=", "(", "\n", "(", "bb", "[", "2", "]", "-", "bb", "[", "0", "]", "+", "1.0", ")", "*", "(", "bb", "[", "3", "]", "-", "bb", "[", "1", "]", "+", "1.0", ")", "\n", "+", "(", "BBGT", "[", ":", ",", "2", "]", "-", "BBGT", "[", ":", ",", "0", "]", "+", "1.0", ")", "*", "(", "BBGT", "[", ":", ",", "3", "]", "-", "BBGT", "[", ":", ",", "1", "]", "+", "1.0", ")", "\n", "-", "inters", "\n", ")", "\n", "\n", "overlaps", "=", "inters", "/", "uni", "\n", "ovmax", "=", "np", ".", "max", "(", "overlaps", ")", "\n", "jmax", "=", "np", ".", "argmax", "(", "overlaps", ")", "\n", "\n", "", "if", "ovmax", ">", "ovthresh", ":", "\n", "            ", "if", "not", "R", "[", "\"difficult\"", "]", "[", "jmax", "]", ":", "\n", "                ", "if", "not", "R", "[", "\"det\"", "]", "[", "jmax", "]", ":", "\n", "                    ", "tp", "[", "d", "]", "=", "1.0", "\n", "R", "[", "\"det\"", "]", "[", "jmax", "]", "=", "1", "\n", "", "else", ":", "\n", "                    ", "fp", "[", "d", "]", "=", "1.0", "\n", "", "", "", "else", ":", "\n", "            ", "fp", "[", "d", "]", "=", "1.0", "\n", "\n", "# compute precision recall", "\n", "", "", "fp", "=", "np", ".", "cumsum", "(", "fp", ")", "\n", "tp", "=", "np", ".", "cumsum", "(", "tp", ")", "\n", "rec", "=", "tp", "/", "float", "(", "npos", ")", "\n", "# avoid divide by zero in case the first detection matches a difficult", "\n", "# ground truth", "\n", "prec", "=", "tp", "/", "np", ".", "maximum", "(", "tp", "+", "fp", ",", "np", ".", "finfo", "(", "np", ".", "float64", ")", ".", "eps", ")", "\n", "ap", "=", "voc_ap", "(", "rec", ",", "prec", ",", "use_07_metric", ")", "\n", "\n", "return", "rec", ",", "prec", ",", "ap", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.testing.print_csv_format": [[10, 26], ["isinstance", "logging.getLogger", "results.items", "logging.getLogger.info", "logging.getLogger.info", "logging.getLogger.info", "res.items"], "function", ["None"], ["def", "print_csv_format", "(", "results", ")", ":", "\n", "    ", "\"\"\"\n    Print main metrics in a format similar to Detectron,\n    so that they are easy to copypaste into a spreadsheet.\n\n    Args:\n        results (OrderedDict[dict]): task_name -> {metric -> score}\n    \"\"\"", "\n", "assert", "isinstance", "(", "results", ",", "OrderedDict", ")", ",", "results", "# unordered results cannot be properly printed", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "for", "task", ",", "res", "in", "results", ".", "items", "(", ")", ":", "\n", "# Don't print \"AP-category\" metrics since they are usually not tracked.", "\n", "        ", "important_res", "=", "[", "(", "k", ",", "v", ")", "for", "k", ",", "v", "in", "res", ".", "items", "(", ")", "if", "\"-\"", "not", "in", "k", "]", "\n", "logger", ".", "info", "(", "\"copypaste: Task: {}\"", ".", "format", "(", "task", ")", ")", "\n", "logger", ".", "info", "(", "\"copypaste: \"", "+", "\",\"", ".", "join", "(", "[", "k", "[", "0", "]", "for", "k", "in", "important_res", "]", ")", ")", "\n", "logger", ".", "info", "(", "\"copypaste: \"", "+", "\",\"", ".", "join", "(", "[", "\"{0:.4f}\"", ".", "format", "(", "k", "[", "1", "]", ")", "for", "k", "in", "important_res", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.testing.verify_results": [[28, 59], ["logging.getLogger", "len", "abs", "logging.getLogger.error", "logging.getLogger.error", "logging.getLogger.error", "sys.exit", "logging.getLogger.info", "numpy.isfinite", "str", "pprint.pformat"], "function", ["None"], ["", "", "def", "verify_results", "(", "cfg", ",", "results", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        results (OrderedDict[dict]): task_name -> {metric -> score}\n\n    Returns:\n        bool: whether the verification succeeds or not\n    \"\"\"", "\n", "expected_results", "=", "cfg", ".", "TEST", ".", "EXPECTED_RESULTS", "\n", "if", "not", "len", "(", "expected_results", ")", ":", "\n", "        ", "return", "True", "\n", "\n", "", "ok", "=", "True", "\n", "for", "task", ",", "metric", ",", "expected", ",", "tolerance", "in", "expected_results", ":", "\n", "        ", "actual", "=", "results", "[", "task", "]", "[", "metric", "]", "\n", "if", "not", "np", ".", "isfinite", "(", "actual", ")", ":", "\n", "            ", "ok", "=", "False", "\n", "", "diff", "=", "abs", "(", "actual", "-", "expected", ")", "\n", "if", "diff", ">", "tolerance", ":", "\n", "            ", "ok", "=", "False", "\n", "\n", "", "", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "if", "not", "ok", ":", "\n", "        ", "logger", ".", "error", "(", "\"Result verification failed!\"", ")", "\n", "logger", ".", "error", "(", "\"Expected Results: \"", "+", "str", "(", "expected_results", ")", ")", "\n", "logger", ".", "error", "(", "\"Actual Results: \"", "+", "pprint", ".", "pformat", "(", "results", ")", ")", "\n", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "\"Results verification passed.\"", ")", "\n", "", "return", "ok", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.testing.flatten_results_dict": [[61, 79], ["results.items", "isinstance", "testing.flatten_results_dict", "flatten_results_dict.items"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.testing.flatten_results_dict"], ["", "def", "flatten_results_dict", "(", "results", ")", ":", "\n", "    ", "\"\"\"\n    Expand a hierarchical dict of scalars into a flat dict of scalars.\n    If results[k1][k2][k3] = v, the returned dict will have the entry\n    {\"k1/k2/k3\": v}.\n\n    Args:\n        results (dict):\n    \"\"\"", "\n", "r", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "results", ".", "items", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "v", ",", "Mapping", ")", ":", "\n", "            ", "v", "=", "flatten_results_dict", "(", "v", ")", "\n", "for", "kk", ",", "vv", "in", "v", ".", "items", "(", ")", ":", "\n", "                ", "r", "[", "k", "+", "\"/\"", "+", "kk", "]", "=", "vv", "\n", "", "", "else", ":", "\n", "            ", "r", "[", "k", "]", "=", "v", "\n", "", "", "return", "r", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.evaluator.DatasetEvaluator.reset": [[24, 30], ["None"], "methods", ["None"], ["def", "reset", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Preparation for a new round of evaluation.\n        Should be called before starting a round of evaluation.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.evaluator.DatasetEvaluator.process": [[31, 47], ["None"], "methods", ["None"], ["", "def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "\"\"\"\n        Process the pair of inputs and outputs.\n        If they contain batches, the pairs can be consumed one-by-one using `zip`:\n\n        .. code-block:: python\n\n            for input_, output in zip(inputs, outputs):\n                # do evaluation on single input/output pair\n                ...\n\n        Args:\n            inputs (list): the inputs that's used to call the model.\n            outputs (list): the return value of `model(inputs)`\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.evaluator.DatasetEvaluator.evaluate": [[48, 62], ["None"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Evaluate/summarize the performance, after processing all input/output pairs.\n\n        Returns:\n            dict:\n                A new evaluator class can return a dict of arbitrary format\n                as long as the user can process the results.\n                In our train_net.py, we expect the following format:\n\n                * key: the name of the task (e.g., bbox)\n                * value: a dict of {metric name: score}, e.g.: {\"AP50\": 80}\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.evaluator.DatasetEvaluators.__init__": [[72, 79], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "evaluators", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            evaluators (list): the evaluators to combine.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_evaluators", "=", "evaluators", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.evaluator.DatasetEvaluators.reset": [[80, 83], ["evaluator.reset"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator.DensePoseCOCOEvaluator.reset"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "for", "evaluator", "in", "self", ".", "_evaluators", ":", "\n", "            ", "evaluator", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.evaluator.DatasetEvaluators.process": [[84, 87], ["evaluator.process"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator.DensePoseCOCOEvaluator.process"], ["", "", "def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "for", "evaluator", "in", "self", ".", "_evaluators", ":", "\n", "            ", "evaluator", ".", "process", "(", "inputs", ",", "outputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.evaluator.DatasetEvaluators.evaluate": [[88, 99], ["collections.OrderedDict", "evaluator.evaluate", "detectron2.utils.comm.is_main_process", "evaluator.evaluate.items"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.deepcluster_hook.DeepClusterHook.evaluate", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process"], ["", "", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "results", "=", "OrderedDict", "(", ")", "\n", "for", "evaluator", "in", "self", ".", "_evaluators", ":", "\n", "            ", "result", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "if", "is_main_process", "(", ")", "and", "result", "is", "not", "None", ":", "\n", "                ", "for", "k", ",", "v", "in", "result", ".", "items", "(", ")", ":", "\n", "                    ", "assert", "(", "\n", "k", "not", "in", "results", "\n", ")", ",", "\"Different evaluators produce results with the same key {}\"", ".", "format", "(", "k", ")", "\n", "results", "[", "k", "]", "=", "v", "\n", "", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.evaluator.inference_on_dataset": [[101, 182], ["detectron2.utils.comm.get_world_size", "logging.getLogger", "logging.getLogger.info", "len", "evaluator.DatasetEvaluators.reset", "min", "time.perf_counter", "str", "logging.getLogger.info", "str", "logging.getLogger.info", "evaluator.DatasetEvaluators.evaluate", "evaluator.DatasetEvaluators", "evaluator.inference_context", "torch.no_grad", "enumerate", "time.perf_counter", "datetime.timedelta", "datetime.timedelta", "len", "time.perf_counter", "model", "torch.cuda.is_available", "evaluator.DatasetEvaluators.process", "time.perf_counter", "torch.cuda.synchronize", "time.perf_counter", "datetime.timedelta", "detectron2.utils.logger.log_every_n_seconds", "int", "int", "time.perf_counter", "int", "str"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator.DensePoseCOCOEvaluator.reset", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.deepcluster_hook.DeepClusterHook.evaluate", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.evaluator.inference_context", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator.DensePoseCOCOEvaluator.process", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.synchronize", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.log_every_n_seconds"], ["", "", "def", "inference_on_dataset", "(", "model", ",", "data_loader", ",", "evaluator", ")", ":", "\n", "    ", "\"\"\"\n    Run model on the data_loader and evaluate the metrics with evaluator.\n    Also benchmark the inference speed of `model.forward` accurately.\n    The model will be used in eval mode.\n\n    Args:\n        model (nn.Module): a module which accepts an object from\n            `data_loader` and returns some outputs. It will be temporarily set to `eval` mode.\n\n            If you wish to evaluate a model in `training` mode instead, you can\n            wrap the given model and override its behavior of `.eval()` and `.train()`.\n        data_loader: an iterable object with a length.\n            The elements it generates will be the inputs to the model.\n        evaluator (DatasetEvaluator): the evaluator to run. Use `None` if you only want\n            to benchmark, but don't want to do any evaluation.\n\n    Returns:\n        The return value of `evaluator.evaluate()`\n    \"\"\"", "\n", "num_devices", "=", "get_world_size", "(", ")", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Start inference on {} images\"", ".", "format", "(", "len", "(", "data_loader", ")", ")", ")", "\n", "\n", "total", "=", "len", "(", "data_loader", ")", "# inference data loader must have a fixed length", "\n", "if", "evaluator", "is", "None", ":", "\n", "# create a no-op evaluator", "\n", "        ", "evaluator", "=", "DatasetEvaluators", "(", "[", "]", ")", "\n", "", "evaluator", ".", "reset", "(", ")", "\n", "\n", "num_warmup", "=", "min", "(", "5", ",", "total", "-", "1", ")", "\n", "start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "total_compute_time", "=", "0", "\n", "with", "inference_context", "(", "model", ")", ",", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "idx", ",", "inputs", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "            ", "if", "idx", "==", "num_warmup", ":", "\n", "                ", "start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "total_compute_time", "=", "0", "\n", "\n", "", "start_compute_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "outputs", "=", "model", "(", "inputs", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "                ", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "", "total_compute_time", "+=", "time", ".", "perf_counter", "(", ")", "-", "start_compute_time", "\n", "evaluator", ".", "process", "(", "inputs", ",", "outputs", ")", "\n", "\n", "iters_after_start", "=", "idx", "+", "1", "-", "num_warmup", "*", "int", "(", "idx", ">=", "num_warmup", ")", "\n", "seconds_per_img", "=", "total_compute_time", "/", "iters_after_start", "\n", "if", "idx", ">=", "num_warmup", "*", "2", "or", "seconds_per_img", ">", "5", ":", "\n", "                ", "total_seconds_per_img", "=", "(", "time", ".", "perf_counter", "(", ")", "-", "start_time", ")", "/", "iters_after_start", "\n", "eta", "=", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "total_seconds_per_img", "*", "(", "total", "-", "idx", "-", "1", ")", ")", ")", "\n", "log_every_n_seconds", "(", "\n", "logging", ".", "INFO", ",", "\n", "\"Inference done {}/{}. {:.4f} s / img. ETA={}\"", ".", "format", "(", "\n", "idx", "+", "1", ",", "total", ",", "seconds_per_img", ",", "str", "(", "eta", ")", "\n", ")", ",", "\n", "n", "=", "5", ",", "\n", ")", "\n", "\n", "# Measure the time only for this worker (before the synchronization barrier)", "\n", "", "", "", "total_time", "=", "time", ".", "perf_counter", "(", ")", "-", "start_time", "\n", "total_time_str", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "total_time", ")", ")", "\n", "# NOTE this format is parsed by grep", "\n", "logger", ".", "info", "(", "\n", "\"Total inference time: {} ({:.6f} s / img per device, on {} devices)\"", ".", "format", "(", "\n", "total_time_str", ",", "total_time", "/", "(", "total", "-", "num_warmup", ")", ",", "num_devices", "\n", ")", "\n", ")", "\n", "total_compute_time_str", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "total_compute_time", ")", ")", ")", "\n", "logger", ".", "info", "(", "\n", "\"Total inference pure compute time: {} ({:.6f} s / img per device, on {} devices)\"", ".", "format", "(", "\n", "total_compute_time_str", ",", "total_compute_time", "/", "(", "total", "-", "num_warmup", ")", ",", "num_devices", "\n", ")", "\n", ")", "\n", "\n", "results", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "# An evaluator may return None when not in main process.", "\n", "# Replace it by an empty dict instead to make it easier for downstream code to handle", "\n", "if", "results", "is", "None", ":", "\n", "        ", "results", "=", "{", "}", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.evaluator.inference_context": [[184, 197], ["model.eval", "model.train"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train"], ["", "@", "contextmanager", "\n", "def", "inference_context", "(", "model", ")", ":", "\n", "    ", "\"\"\"\n    A context where the model is temporarily changed to eval mode,\n    and restored to previous mode afterwards.\n\n    Args:\n        model: a torch Module\n    \"\"\"", "\n", "training_mode", "=", "model", ".", "training", "\n", "model", ".", "eval", "(", ")", "\n", "yield", "\n", "model", ".", "train", "(", "training_mode", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.rotated_coco_evaluation.RotatedCOCOeval.is_rotated": [[16, 32], ["type", "type", "numpy.all", "numpy.array", "len", "type", "type"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "is_rotated", "(", "box_list", ")", ":", "\n", "        ", "if", "type", "(", "box_list", ")", "==", "np", ".", "ndarray", ":", "\n", "            ", "return", "box_list", ".", "shape", "[", "1", "]", "==", "5", "\n", "", "elif", "type", "(", "box_list", ")", "==", "list", ":", "\n", "            ", "if", "box_list", "==", "[", "]", ":", "# cannot decide the box_dim", "\n", "                ", "return", "False", "\n", "", "return", "np", ".", "all", "(", "\n", "np", ".", "array", "(", "\n", "[", "\n", "(", "len", "(", "obj", ")", "==", "5", ")", "and", "(", "(", "type", "(", "obj", ")", "==", "list", ")", "or", "(", "type", "(", "obj", ")", "==", "np", ".", "ndarray", ")", ")", "\n", "for", "obj", "in", "box_list", "\n", "]", "\n", ")", "\n", ")", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.rotated_coco_evaluation.RotatedCOCOeval.boxlist_to_tensor": [[33, 56], ["type", "torch.from_numpy", "type", "Exception", "detectron2.structures.BoxMode.convert", "Exception", "torch.zeros", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "@", "staticmethod", "\n", "def", "boxlist_to_tensor", "(", "boxlist", ",", "output_box_dim", ")", ":", "\n", "        ", "if", "type", "(", "boxlist", ")", "==", "np", ".", "ndarray", ":", "\n", "            ", "box_tensor", "=", "torch", ".", "from_numpy", "(", "boxlist", ")", "\n", "", "elif", "type", "(", "boxlist", ")", "==", "list", ":", "\n", "            ", "if", "boxlist", "==", "[", "]", ":", "\n", "                ", "return", "torch", ".", "zeros", "(", "(", "0", ",", "output_box_dim", ")", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "", "else", ":", "\n", "                ", "box_tensor", "=", "torch", ".", "FloatTensor", "(", "boxlist", ")", "\n", "", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\"Unrecognized boxlist type\"", ")", "\n", "\n", "", "input_box_dim", "=", "box_tensor", ".", "shape", "[", "1", "]", "\n", "if", "input_box_dim", "!=", "output_box_dim", ":", "\n", "            ", "if", "input_box_dim", "==", "4", "and", "output_box_dim", "==", "5", ":", "\n", "                ", "box_tensor", "=", "BoxMode", ".", "convert", "(", "box_tensor", ",", "BoxMode", ".", "XYWH_ABS", ",", "BoxMode", ".", "XYWHA_ABS", ")", "\n", "", "else", ":", "\n", "                ", "raise", "Exception", "(", "\n", "\"Unable to convert from {}-dim box to {}-dim box\"", ".", "format", "(", "\n", "input_box_dim", ",", "output_box_dim", "\n", ")", "\n", ")", "\n", "", "", "return", "box_tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.rotated_coco_evaluation.RotatedCOCOeval.compute_iou_dt_gt": [[57, 67], ["rotated_coco_evaluation.RotatedCOCOeval.is_rotated", "rotated_coco_evaluation.RotatedCOCOeval.is_rotated", "all", "detectron2.structures.RotatedBoxes", "detectron2.structures.RotatedBoxes", "detectron2.structures.pairwise_iou_rotated", "pycocotools.cocoeval.maskUtils.iou", "rotated_coco_evaluation.RotatedCOCOeval.boxlist_to_tensor", "rotated_coco_evaluation.RotatedCOCOeval.boxlist_to_tensor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.rotated_coco_evaluation.RotatedCOCOeval.is_rotated", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.rotated_coco_evaluation.RotatedCOCOeval.is_rotated", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.rotated_boxes.pairwise_iou_rotated", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.rotated_coco_evaluation.RotatedCOCOeval.boxlist_to_tensor", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.rotated_coco_evaluation.RotatedCOCOeval.boxlist_to_tensor"], ["", "def", "compute_iou_dt_gt", "(", "self", ",", "dt", ",", "gt", ",", "is_crowd", ")", ":", "\n", "        ", "if", "self", ".", "is_rotated", "(", "dt", ")", "or", "self", ".", "is_rotated", "(", "gt", ")", ":", "\n", "# TODO: take is_crowd into consideration", "\n", "            ", "assert", "all", "(", "c", "==", "0", "for", "c", "in", "is_crowd", ")", "\n", "dt", "=", "RotatedBoxes", "(", "self", ".", "boxlist_to_tensor", "(", "dt", ",", "output_box_dim", "=", "5", ")", ")", "\n", "gt", "=", "RotatedBoxes", "(", "self", ".", "boxlist_to_tensor", "(", "gt", ",", "output_box_dim", "=", "5", ")", ")", "\n", "return", "pairwise_iou_rotated", "(", "dt", ",", "gt", ")", "\n", "", "else", ":", "\n", "# This is the same as the classical COCO evaluation", "\n", "            ", "return", "maskUtils", ".", "iou", "(", "dt", ",", "gt", ",", "is_crowd", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.rotated_coco_evaluation.RotatedCOCOeval.computeIoU": [[68, 95], ["numpy.argsort", "rotated_coco_evaluation.RotatedCOCOeval.compute_iou_dt_gt", "len", "int", "len", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.rotated_coco_evaluation.RotatedCOCOeval.compute_iou_dt_gt"], ["", "", "def", "computeIoU", "(", "self", ",", "imgId", ",", "catId", ")", ":", "\n", "        ", "p", "=", "self", ".", "params", "\n", "if", "p", ".", "useCats", ":", "\n", "            ", "gt", "=", "self", ".", "_gts", "[", "imgId", ",", "catId", "]", "\n", "dt", "=", "self", ".", "_dts", "[", "imgId", ",", "catId", "]", "\n", "", "else", ":", "\n", "            ", "gt", "=", "[", "_", "for", "cId", "in", "p", ".", "catIds", "for", "_", "in", "self", ".", "_gts", "[", "imgId", ",", "cId", "]", "]", "\n", "dt", "=", "[", "_", "for", "cId", "in", "p", ".", "catIds", "for", "_", "in", "self", ".", "_dts", "[", "imgId", ",", "cId", "]", "]", "\n", "", "if", "len", "(", "gt", ")", "==", "0", "and", "len", "(", "dt", ")", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "", "inds", "=", "np", ".", "argsort", "(", "[", "-", "d", "[", "\"score\"", "]", "for", "d", "in", "dt", "]", ",", "kind", "=", "\"mergesort\"", ")", "\n", "dt", "=", "[", "dt", "[", "i", "]", "for", "i", "in", "inds", "]", "\n", "if", "len", "(", "dt", ")", ">", "p", ".", "maxDets", "[", "-", "1", "]", ":", "\n", "            ", "dt", "=", "dt", "[", "0", ":", "p", ".", "maxDets", "[", "-", "1", "]", "]", "\n", "\n", "", "assert", "p", ".", "iouType", "==", "\"bbox\"", ",", "\"unsupported iouType for iou computation\"", "\n", "\n", "g", "=", "[", "g", "[", "\"bbox\"", "]", "for", "g", "in", "gt", "]", "\n", "d", "=", "[", "d", "[", "\"bbox\"", "]", "for", "d", "in", "dt", "]", "\n", "\n", "# compute iou between each dt and gt region", "\n", "iscrowd", "=", "[", "int", "(", "o", "[", "\"iscrowd\"", "]", ")", "for", "o", "in", "gt", "]", "\n", "\n", "# Note: this function is copied from cocoeval.py in cocoapi", "\n", "# and the major difference is here.", "\n", "ious", "=", "self", ".", "compute_iou_dt_gt", "(", "d", ",", "g", ",", "iscrowd", ")", "\n", "return", "ious", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.rotated_coco_evaluation.RotatedCOCOEvaluator.process": [[104, 123], ["zip", "rotated_coco_evaluation.RotatedCOCOEvaluator._predictions.append", "output[].to", "rotated_coco_evaluation.RotatedCOCOEvaluator.instances_to_json", "output[].to"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.rotated_coco_evaluation.RotatedCOCOEvaluator.instances_to_json", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            inputs: the inputs to a COCO model (e.g., GeneralizedRCNN).\n                It is a list of dict. Each dict corresponds to an image and\n                contains keys like \"height\", \"width\", \"file_name\", \"image_id\".\n            outputs: the outputs of a COCO model. It is a list of dicts with key\n                \"instances\" that contains :class:`Instances`.\n        \"\"\"", "\n", "for", "input", ",", "output", "in", "zip", "(", "inputs", ",", "outputs", ")", ":", "\n", "            ", "prediction", "=", "{", "\"image_id\"", ":", "input", "[", "\"image_id\"", "]", "}", "\n", "\n", "if", "\"instances\"", "in", "output", ":", "\n", "                ", "instances", "=", "output", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "_cpu_device", ")", "\n", "\n", "prediction", "[", "\"instances\"", "]", "=", "self", ".", "instances_to_json", "(", "instances", ",", "input", "[", "\"image_id\"", "]", ")", "\n", "", "if", "\"proposals\"", "in", "output", ":", "\n", "                ", "prediction", "[", "\"proposals\"", "]", "=", "output", "[", "\"proposals\"", "]", ".", "to", "(", "self", ".", "_cpu_device", ")", "\n", "", "self", ".", "_predictions", ".", "append", "(", "prediction", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.rotated_coco_evaluation.RotatedCOCOEvaluator.instances_to_json": [[124, 147], ["len", "instances.pred_boxes.tensor.numpy", "detectron2.structures.BoxMode.convert.tolist", "instances.scores.tolist", "instances.pred_classes.tolist", "range", "detectron2.structures.BoxMode.convert", "results.append"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "", "def", "instances_to_json", "(", "self", ",", "instances", ",", "img_id", ")", ":", "\n", "        ", "num_instance", "=", "len", "(", "instances", ")", "\n", "if", "num_instance", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "\n", "", "boxes", "=", "instances", ".", "pred_boxes", ".", "tensor", ".", "numpy", "(", ")", "\n", "if", "boxes", ".", "shape", "[", "1", "]", "==", "4", ":", "\n", "            ", "boxes", "=", "BoxMode", ".", "convert", "(", "boxes", ",", "BoxMode", ".", "XYXY_ABS", ",", "BoxMode", ".", "XYWH_ABS", ")", "\n", "", "boxes", "=", "boxes", ".", "tolist", "(", ")", "\n", "scores", "=", "instances", ".", "scores", ".", "tolist", "(", ")", "\n", "classes", "=", "instances", ".", "pred_classes", ".", "tolist", "(", ")", "\n", "\n", "results", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "num_instance", ")", ":", "\n", "            ", "result", "=", "{", "\n", "\"image_id\"", ":", "img_id", ",", "\n", "\"category_id\"", ":", "classes", "[", "k", "]", ",", "\n", "\"bbox\"", ":", "boxes", "[", "k", "]", ",", "\n", "\"score\"", ":", "scores", "[", "k", "]", ",", "\n", "}", "\n", "\n", "results", ".", "append", "(", "result", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.rotated_coco_evaluation.RotatedCOCOEvaluator._eval_predictions": [[148, 188], ["rotated_coco_evaluation.RotatedCOCOEvaluator._logger.info", "list", "hasattr", "rotated_coco_evaluation.RotatedCOCOEvaluator._logger.info", "sorted", "itertools.chain", "os.path.join", "rotated_coco_evaluation.RotatedCOCOEvaluator._logger.info", "rotated_coco_evaluation.RotatedCOCOEvaluator._logger.info", "rotated_coco_evaluation.RotatedCOCOEvaluator._derive_coco_results", "fvcore.common.file_io.PathManager.open", "f.write", "f.flush", "rotated_coco_evaluation.RotatedCOCOEvaluator._evaluate_predictions_on_coco", "rotated_coco_evaluation.RotatedCOCOEvaluator._metadata.thing_dataset_id_to_contiguous_id.items", "json.dumps", "len", "rotated_coco_evaluation.RotatedCOCOEvaluator._metadata.get"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.coco_evaluation.COCOEvaluator._derive_coco_results", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator._evaluate_predictions_on_coco", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "def", "_eval_predictions", "(", "self", ",", "tasks", ",", "predictions", ")", ":", "\n", "        ", "\"\"\"\n        Evaluate predictions on the given tasks.\n        Fill self._results with the metrics of the tasks.\n        \"\"\"", "\n", "self", ".", "_logger", ".", "info", "(", "\"Preparing results for COCO format ...\"", ")", "\n", "coco_results", "=", "list", "(", "itertools", ".", "chain", "(", "*", "[", "x", "[", "\"instances\"", "]", "for", "x", "in", "predictions", "]", ")", ")", "\n", "\n", "# unmap the category ids for COCO", "\n", "if", "hasattr", "(", "self", ".", "_metadata", ",", "\"thing_dataset_id_to_contiguous_id\"", ")", ":", "\n", "            ", "reverse_id_mapping", "=", "{", "\n", "v", ":", "k", "for", "k", ",", "v", "in", "self", ".", "_metadata", ".", "thing_dataset_id_to_contiguous_id", ".", "items", "(", ")", "\n", "}", "\n", "for", "result", "in", "coco_results", ":", "\n", "                ", "result", "[", "\"category_id\"", "]", "=", "reverse_id_mapping", "[", "result", "[", "\"category_id\"", "]", "]", "\n", "\n", "", "", "if", "self", ".", "_output_dir", ":", "\n", "            ", "file_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_output_dir", ",", "\"coco_instances_results.json\"", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\"Saving results to {}\"", ".", "format", "(", "file_path", ")", ")", "\n", "with", "PathManager", ".", "open", "(", "file_path", ",", "\"w\"", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "json", ".", "dumps", "(", "coco_results", ")", ")", "\n", "f", ".", "flush", "(", ")", "\n", "\n", "", "", "if", "not", "self", ".", "_do_evaluation", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\"Annotations are not available for evaluation.\"", ")", "\n", "return", "\n", "\n", "", "self", ".", "_logger", ".", "info", "(", "\"Evaluating predictions ...\"", ")", "\n", "for", "task", "in", "sorted", "(", "tasks", ")", ":", "\n", "            ", "assert", "task", "==", "\"bbox\"", ",", "\"Task {} is not supported\"", ".", "format", "(", "task", ")", "\n", "coco_eval", "=", "(", "\n", "self", ".", "_evaluate_predictions_on_coco", "(", "self", ".", "_coco_api", ",", "coco_results", ")", "\n", "if", "len", "(", "coco_results", ")", ">", "0", "\n", "else", "None", "# cocoapi does not handle empty results very well", "\n", ")", "\n", "\n", "res", "=", "self", ".", "_derive_coco_results", "(", "\n", "coco_eval", ",", "task", ",", "class_names", "=", "self", ".", "_metadata", ".", "get", "(", "\"thing_classes\"", ")", "\n", ")", "\n", "self", ".", "_results", "[", "task", "]", "=", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.rotated_coco_evaluation.RotatedCOCOEvaluator._evaluate_predictions_on_coco": [[189, 205], ["coco_gt.loadRes", "rotated_coco_evaluation.RotatedCOCOeval", "RotatedCOCOeval.evaluate", "RotatedCOCOeval.accumulate", "RotatedCOCOeval.summarize", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.deepcluster_hook.DeepClusterHook.evaluate", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.accumulate", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.summarize"], ["", "", "def", "_evaluate_predictions_on_coco", "(", "self", ",", "coco_gt", ",", "coco_results", ")", ":", "\n", "        ", "\"\"\"\n        Evaluate the coco results using COCOEval API.\n        \"\"\"", "\n", "assert", "len", "(", "coco_results", ")", ">", "0", "\n", "\n", "coco_dt", "=", "coco_gt", ".", "loadRes", "(", "coco_results", ")", "\n", "\n", "# Only bbox is supported for now", "\n", "coco_eval", "=", "RotatedCOCOeval", "(", "coco_gt", ",", "coco_dt", ",", "iouType", "=", "\"bbox\"", ")", "\n", "\n", "coco_eval", ".", "evaluate", "(", ")", "\n", "coco_eval", ".", "accumulate", "(", ")", "\n", "coco_eval", ".", "summarize", "(", ")", "\n", "\n", "return", "coco_eval", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.cityscapes_evaluation.CityscapesEvaluator.__init__": [[23, 33], ["detectron2.data.MetadataCatalog.get", "torch.device", "logging.getLogger"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device"], ["def", "__init__", "(", "self", ",", "dataset_name", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_name (str): the name of the dataset.\n                It must have the following metadata associated with it:\n                \"thing_classes\", \"gt_dir\".\n        \"\"\"", "\n", "self", ".", "_metadata", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", "\n", "self", ".", "_cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "self", ".", "_logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.cityscapes_evaluation.CityscapesEvaluator.reset": [[34, 44], ["tempfile.TemporaryDirectory", "cityscapes_evaluation.CityscapesEvaluator._logger.info", "detectron2.utils.comm.all_gather", "cityscapes_evaluation.CityscapesEvaluator._working_dir.cleanup"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_working_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", "prefix", "=", "\"cityscapes_eval_\"", ")", "\n", "self", ".", "_temp_dir", "=", "self", ".", "_working_dir", ".", "name", "\n", "# All workers will write to the same results directory", "\n", "# TODO this does not work in distributed training", "\n", "self", ".", "_temp_dir", "=", "comm", ".", "all_gather", "(", "self", ".", "_temp_dir", ")", "[", "0", "]", "\n", "if", "self", ".", "_temp_dir", "!=", "self", ".", "_working_dir", ".", "name", ":", "\n", "            ", "self", ".", "_working_dir", ".", "cleanup", "(", ")", "\n", "", "self", ".", "_logger", ".", "info", "(", "\n", "\"Writing cityscapes results to temporary directory {} ...\"", ".", "format", "(", "self", ".", "_temp_dir", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.cityscapes_evaluation.CityscapesInstanceEvaluator.process": [[57, 87], ["zip", "os.path.join", "os.path.splitext", "output[].to", "len", "os.path.basename", "open", "range", "open", "output[].to.pred_masks[].numpy().astype", "os.path.join", "PIL.Image.fromarray().save", "fout.write", "output[].to.pred_masks[].numpy", "PIL.Image.fromarray", "os.path.basename"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write"], ["def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "from", "cityscapesscripts", ".", "helpers", ".", "labels", "import", "name2label", "\n", "\n", "for", "input", ",", "output", "in", "zip", "(", "inputs", ",", "outputs", ")", ":", "\n", "            ", "file_name", "=", "input", "[", "\"file_name\"", "]", "\n", "basename", "=", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "basename", "(", "file_name", ")", ")", "[", "0", "]", "\n", "pred_txt", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_temp_dir", ",", "basename", "+", "\"_pred.txt\"", ")", "\n", "\n", "if", "\"instances\"", "in", "output", ":", "\n", "                ", "output", "=", "output", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "_cpu_device", ")", "\n", "num_instances", "=", "len", "(", "output", ")", "\n", "with", "open", "(", "pred_txt", ",", "\"w\"", ")", "as", "fout", ":", "\n", "                    ", "for", "i", "in", "range", "(", "num_instances", ")", ":", "\n", "                        ", "pred_class", "=", "output", ".", "pred_classes", "[", "i", "]", "\n", "classes", "=", "self", ".", "_metadata", ".", "thing_classes", "[", "pred_class", "]", "\n", "class_id", "=", "name2label", "[", "classes", "]", ".", "id", "\n", "score", "=", "output", ".", "scores", "[", "i", "]", "\n", "mask", "=", "output", ".", "pred_masks", "[", "i", "]", ".", "numpy", "(", ")", ".", "astype", "(", "\"uint8\"", ")", "\n", "png_filename", "=", "os", ".", "path", ".", "join", "(", "\n", "self", ".", "_temp_dir", ",", "basename", "+", "\"_{}_{}.png\"", ".", "format", "(", "i", ",", "classes", ")", "\n", ")", "\n", "\n", "Image", ".", "fromarray", "(", "mask", "*", "255", ")", ".", "save", "(", "png_filename", ")", "\n", "fout", ".", "write", "(", "\n", "\"{} {} {}\\n\"", ".", "format", "(", "os", ".", "path", ".", "basename", "(", "png_filename", ")", ",", "class_id", ",", "score", ")", "\n", ")", "\n", "", "", "", "else", ":", "\n", "# Cityscapes requires a prediction file for every ground truth image.", "\n", "                ", "with", "open", "(", "pred_txt", ",", "\"w\"", ")", "as", "fout", ":", "\n", "                    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.cityscapes_evaluation.CityscapesInstanceEvaluator.evaluate": [[88, 127], ["detectron2.utils.comm.synchronize", "cityscapes_evaluation.CityscapesInstanceEvaluator._logger.info", "os.path.abspath", "os.path.join", "fvcore.common.file_io.PathManager.get_local_path", "glob.glob", "len", "collections.OrderedDict", "cityscapes_evaluation.CityscapesInstanceEvaluator._working_dir.cleanup", "detectron2.utils.comm.get_rank", "os.path.join", "predictionImgList.append", "cityscapes_eval.evaluateImgLists", "cityscapes_eval.getPrediction"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.synchronize", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank"], ["", "", "", "", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            dict: has a key \"segm\", whose value is a dict of \"AP\" and \"AP50\".\n        \"\"\"", "\n", "comm", ".", "synchronize", "(", ")", "\n", "if", "comm", ".", "get_rank", "(", ")", ">", "0", ":", "\n", "            ", "return", "\n", "", "import", "cityscapesscripts", ".", "evaluation", ".", "evalInstanceLevelSemanticLabeling", "as", "cityscapes_eval", "\n", "\n", "self", ".", "_logger", ".", "info", "(", "\"Evaluating results under {} ...\"", ".", "format", "(", "self", ".", "_temp_dir", ")", ")", "\n", "\n", "# set some global states in cityscapes evaluation API, before evaluating", "\n", "cityscapes_eval", ".", "args", ".", "predictionPath", "=", "os", ".", "path", ".", "abspath", "(", "self", ".", "_temp_dir", ")", "\n", "cityscapes_eval", ".", "args", ".", "predictionWalk", "=", "None", "\n", "cityscapes_eval", ".", "args", ".", "JSONOutput", "=", "False", "\n", "cityscapes_eval", ".", "args", ".", "colorized", "=", "False", "\n", "cityscapes_eval", ".", "args", ".", "gtInstancesFile", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_temp_dir", ",", "\"gtInstances.json\"", ")", "\n", "\n", "# These lines are adopted from", "\n", "# https://github.com/mcordts/cityscapesScripts/blob/master/cityscapesscripts/evaluation/evalInstanceLevelSemanticLabeling.py # noqa", "\n", "gt_dir", "=", "PathManager", ".", "get_local_path", "(", "self", ".", "_metadata", ".", "gt_dir", ")", "\n", "groundTruthImgList", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "gt_dir", ",", "\"*\"", ",", "\"*_gtFine_instanceIds.png\"", ")", ")", "\n", "assert", "len", "(", "\n", "groundTruthImgList", "\n", ")", ",", "\"Cannot find any ground truth images to use for evaluation. Searched for: {}\"", ".", "format", "(", "\n", "cityscapes_eval", ".", "args", ".", "groundTruthSearch", "\n", ")", "\n", "predictionImgList", "=", "[", "]", "\n", "for", "gt", "in", "groundTruthImgList", ":", "\n", "            ", "predictionImgList", ".", "append", "(", "cityscapes_eval", ".", "getPrediction", "(", "gt", ",", "cityscapes_eval", ".", "args", ")", ")", "\n", "", "results", "=", "cityscapes_eval", ".", "evaluateImgLists", "(", "\n", "predictionImgList", ",", "groundTruthImgList", ",", "cityscapes_eval", ".", "args", "\n", ")", "[", "\"averages\"", "]", "\n", "\n", "ret", "=", "OrderedDict", "(", ")", "\n", "ret", "[", "\"segm\"", "]", "=", "{", "\"AP\"", ":", "results", "[", "\"allAp\"", "]", "*", "100", ",", "\"AP50\"", ":", "results", "[", "\"allAp50%\"", "]", "*", "100", "}", "\n", "self", ".", "_working_dir", ".", "cleanup", "(", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.cityscapes_evaluation.CityscapesSemSegEvaluator.process": [[139, 154], ["zip", "os.path.join", "output[].argmax().to().numpy", "trainId2label.items", "PIL.Image.fromarray().save", "os.path.splitext", "numpy.ones", "os.path.basename", "output[].argmax().to", "PIL.Image.fromarray", "output[].argmax"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "from", "cityscapesscripts", ".", "helpers", ".", "labels", "import", "trainId2label", "\n", "\n", "for", "input", ",", "output", "in", "zip", "(", "inputs", ",", "outputs", ")", ":", "\n", "            ", "file_name", "=", "input", "[", "\"file_name\"", "]", "\n", "basename", "=", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "basename", "(", "file_name", ")", ")", "[", "0", "]", "\n", "pred_filename", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_temp_dir", ",", "basename", "+", "\"_pred.png\"", ")", "\n", "\n", "output", "=", "output", "[", "\"sem_seg\"", "]", ".", "argmax", "(", "dim", "=", "0", ")", ".", "to", "(", "self", ".", "_cpu_device", ")", ".", "numpy", "(", ")", "\n", "pred", "=", "255", "*", "np", ".", "ones", "(", "output", ".", "shape", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "for", "train_id", ",", "label", "in", "trainId2label", ".", "items", "(", ")", ":", "\n", "                ", "if", "label", ".", "ignoreInEval", ":", "\n", "                    ", "continue", "\n", "", "pred", "[", "output", "==", "train_id", "]", "=", "label", ".", "id", "\n", "", "Image", ".", "fromarray", "(", "pred", ")", ".", "save", "(", "pred_filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.cityscapes_evaluation.CityscapesSemSegEvaluator.evaluate": [[155, 195], ["detectron2.utils.comm.synchronize", "cityscapes_evaluation.CityscapesSemSegEvaluator._logger.info", "os.path.abspath", "fvcore.common.file_io.PathManager.get_local_path", "glob.glob", "len", "cityscapes_eval.evaluateImgLists", "collections.OrderedDict", "cityscapes_evaluation.CityscapesSemSegEvaluator._working_dir.cleanup", "detectron2.utils.comm.get_rank", "os.path.join", "predictionImgList.append", "cityscapes_eval.getPrediction"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.synchronize", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank"], ["", "", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "comm", ".", "synchronize", "(", ")", "\n", "if", "comm", ".", "get_rank", "(", ")", ">", "0", ":", "\n", "            ", "return", "\n", "# Load the Cityscapes eval script *after* setting the required env var,", "\n", "# since the script reads CITYSCAPES_DATASET into global variables at load time.", "\n", "", "import", "cityscapesscripts", ".", "evaluation", ".", "evalPixelLevelSemanticLabeling", "as", "cityscapes_eval", "\n", "\n", "self", ".", "_logger", ".", "info", "(", "\"Evaluating results under {} ...\"", ".", "format", "(", "self", ".", "_temp_dir", ")", ")", "\n", "\n", "# set some global states in cityscapes evaluation API, before evaluating", "\n", "cityscapes_eval", ".", "args", ".", "predictionPath", "=", "os", ".", "path", ".", "abspath", "(", "self", ".", "_temp_dir", ")", "\n", "cityscapes_eval", ".", "args", ".", "predictionWalk", "=", "None", "\n", "cityscapes_eval", ".", "args", ".", "JSONOutput", "=", "False", "\n", "cityscapes_eval", ".", "args", ".", "colorized", "=", "False", "\n", "\n", "# These lines are adopted from", "\n", "# https://github.com/mcordts/cityscapesScripts/blob/master/cityscapesscripts/evaluation/evalPixelLevelSemanticLabeling.py # noqa", "\n", "gt_dir", "=", "PathManager", ".", "get_local_path", "(", "self", ".", "_metadata", ".", "gt_dir", ")", "\n", "groundTruthImgList", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "gt_dir", ",", "\"*\"", ",", "\"*_gtFine_labelIds.png\"", ")", ")", "\n", "assert", "len", "(", "\n", "groundTruthImgList", "\n", ")", ",", "\"Cannot find any ground truth images to use for evaluation. Searched for: {}\"", ".", "format", "(", "\n", "cityscapes_eval", ".", "args", ".", "groundTruthSearch", "\n", ")", "\n", "predictionImgList", "=", "[", "]", "\n", "for", "gt", "in", "groundTruthImgList", ":", "\n", "            ", "predictionImgList", ".", "append", "(", "cityscapes_eval", ".", "getPrediction", "(", "cityscapes_eval", ".", "args", ",", "gt", ")", ")", "\n", "", "results", "=", "cityscapes_eval", ".", "evaluateImgLists", "(", "\n", "predictionImgList", ",", "groundTruthImgList", ",", "cityscapes_eval", ".", "args", "\n", ")", "\n", "ret", "=", "OrderedDict", "(", ")", "\n", "ret", "[", "\"sem_seg\"", "]", "=", "{", "\n", "\"IoU\"", ":", "100.0", "*", "results", "[", "\"averageScoreClasses\"", "]", ",", "\n", "\"iIoU\"", ":", "100.0", "*", "results", "[", "\"averageScoreInstClasses\"", "]", ",", "\n", "\"IoU_sup\"", ":", "100.0", "*", "results", "[", "\"averageScoreCategories\"", "]", ",", "\n", "\"iIoU_sup\"", ":", "100.0", "*", "results", "[", "\"averageScoreInstCategories\"", "]", ",", "\n", "}", "\n", "self", ".", "_working_dir", ".", "cleanup", "(", ")", "\n", "return", "ret", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.solver.build._create_gradient_clipper": [[19, 37], ["cfg.clone.clone", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_value_", "build.GradientClipType"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone"], ["\n", "meta_arch", "=", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "\n", "model", "=", "META_ARCH_REGISTRY", ".", "get", "(", "meta_arch", ")", "(", "cfg", ")", "\n", "model", ".", "to", "(", "torch", ".", "device", "(", "cfg", ".", "MODEL", ".", "DEVICE", ")", ")", "\n", "return", "model", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.solver.build._generate_optimizer_class_with_gradient_clipping": [[39, 59], ["type", "super().step", "gradient_clipper", "type"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.optimizers.LARS.step"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.solver.build.maybe_add_gradient_clipping": [[61, 91], ["build._create_gradient_clipper", "build._generate_optimizer_class_with_gradient_clipping", "type"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.solver.build._create_gradient_clipper", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.solver.build._generate_optimizer_class_with_gradient_clipping"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.solver.build.build_optimizer": [[93, 138], ["set", "model.modules", "torch.optim.SGD", "build.maybe_add_gradient_clipping", "module.named_parameters", "memo.add", "isinstance"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.solver.build.maybe_add_gradient_clipping"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.solver.build.build_lr_scheduler": [[140, 166], ["lr_scheduler.WarmupMultiStepLR", "lr_scheduler.WarmupCosineLR", "ValueError"], "function", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.solver.lr_scheduler.WarmupMultiStepLR.__init__": [[17, 37], ["super().__init__", "ValueError", "list", "sorted"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "optimizer", ":", "torch", ".", "optim", ".", "Optimizer", ",", "\n", "milestones", ":", "List", "[", "int", "]", ",", "\n", "gamma", ":", "float", "=", "0.1", ",", "\n", "warmup_factor", ":", "float", "=", "0.001", ",", "\n", "warmup_iters", ":", "int", "=", "1000", ",", "\n", "warmup_method", ":", "str", "=", "\"linear\"", ",", "\n", "last_epoch", ":", "int", "=", "-", "1", ",", "\n", ")", ":", "\n", "        ", "if", "not", "list", "(", "milestones", ")", "==", "sorted", "(", "milestones", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Milestones should be a list of\"", "\" increasing integers. Got {}\"", ",", "milestones", "\n", ")", "\n", "", "self", ".", "milestones", "=", "milestones", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "warmup_factor", "=", "warmup_factor", "\n", "self", ".", "warmup_iters", "=", "warmup_iters", "\n", "self", ".", "warmup_method", "=", "warmup_method", "\n", "super", "(", ")", ".", "__init__", "(", "optimizer", ",", "last_epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.solver.lr_scheduler.WarmupMultiStepLR.get_lr": [[38, 45], ["lr_scheduler._get_warmup_factor_at_iter", "bisect.bisect_right"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.solver.lr_scheduler._get_warmup_factor_at_iter"], ["", "def", "get_lr", "(", "self", ")", "->", "List", "[", "float", "]", ":", "\n", "        ", "warmup_factor", "=", "_get_warmup_factor_at_iter", "(", "\n", "self", ".", "warmup_method", ",", "self", ".", "last_epoch", ",", "self", ".", "warmup_iters", ",", "self", ".", "warmup_factor", "\n", ")", "\n", "return", "[", "\n", "base_lr", "*", "warmup_factor", "*", "self", ".", "gamma", "**", "bisect_right", "(", "self", ".", "milestones", ",", "self", ".", "last_epoch", ")", "\n", "for", "base_lr", "in", "self", ".", "base_lrs", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.solver.lr_scheduler.WarmupMultiStepLR._compute_values": [[47, 50], ["lr_scheduler.WarmupMultiStepLR.get_lr"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.lr_scheduler.WarmupPolyLR.get_lr"], ["", "def", "_compute_values", "(", "self", ")", "->", "List", "[", "float", "]", ":", "\n", "# The new interface", "\n", "        ", "return", "self", ".", "get_lr", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.solver.lr_scheduler.WarmupCosineLR.__init__": [[53, 67], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "optimizer", ":", "torch", ".", "optim", ".", "Optimizer", ",", "\n", "max_iters", ":", "int", ",", "\n", "warmup_factor", ":", "float", "=", "0.001", ",", "\n", "warmup_iters", ":", "int", "=", "1000", ",", "\n", "warmup_method", ":", "str", "=", "\"linear\"", ",", "\n", "last_epoch", ":", "int", "=", "-", "1", ",", "\n", ")", ":", "\n", "        ", "self", ".", "max_iters", "=", "max_iters", "\n", "self", ".", "warmup_factor", "=", "warmup_factor", "\n", "self", ".", "warmup_iters", "=", "warmup_iters", "\n", "self", ".", "warmup_method", "=", "warmup_method", "\n", "super", "(", ")", ".", "__init__", "(", "optimizer", ",", "last_epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.solver.lr_scheduler.WarmupCosineLR.get_lr": [[68, 83], ["lr_scheduler._get_warmup_factor_at_iter", "math.cos"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.solver.lr_scheduler._get_warmup_factor_at_iter"], ["", "def", "get_lr", "(", "self", ")", "->", "List", "[", "float", "]", ":", "\n", "        ", "warmup_factor", "=", "_get_warmup_factor_at_iter", "(", "\n", "self", ".", "warmup_method", ",", "self", ".", "last_epoch", ",", "self", ".", "warmup_iters", ",", "self", ".", "warmup_factor", "\n", ")", "\n", "# Different definitions of half-cosine with warmup are possible. For", "\n", "# simplicity we multiply the standard half-cosine schedule by the warmup", "\n", "# factor. An alternative is to start the period of the cosine at warmup_iters", "\n", "# instead of at 0. In the case that warmup_iters << max_iters the two are", "\n", "# very close to each other.", "\n", "return", "[", "\n", "base_lr", "\n", "*", "warmup_factor", "\n", "*", "0.5", "\n", "*", "(", "1.0", "+", "math", ".", "cos", "(", "math", ".", "pi", "*", "self", ".", "last_epoch", "/", "self", ".", "max_iters", ")", ")", "\n", "for", "base_lr", "in", "self", ".", "base_lrs", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.solver.lr_scheduler.WarmupCosineLR._compute_values": [[85, 88], ["lr_scheduler.WarmupCosineLR.get_lr"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.lr_scheduler.WarmupPolyLR.get_lr"], ["", "def", "_compute_values", "(", "self", ")", "->", "List", "[", "float", "]", ":", "\n", "# The new interface", "\n", "        ", "return", "self", ".", "get_lr", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.solver.lr_scheduler._get_warmup_factor_at_iter": [[90, 117], ["ValueError"], "function", ["None"], ["", "", "def", "_get_warmup_factor_at_iter", "(", "\n", "method", ":", "str", ",", "iter", ":", "int", ",", "warmup_iters", ":", "int", ",", "warmup_factor", ":", "float", "\n", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Return the learning rate warmup factor at a specific iteration.\n    See :paper:`ImageNet in 1h` for more details.\n\n    Args:\n        method (str): warmup method; either \"constant\" or \"linear\".\n        iter (int): iteration at which to calculate the warmup factor.\n        warmup_iters (int): the number of warmup iterations.\n        warmup_factor (float): the base warmup factor (the meaning changes according\n            to the method used).\n\n    Returns:\n        float: the effective warmup factor at the given iteration.\n    \"\"\"", "\n", "if", "iter", ">=", "warmup_iters", ":", "\n", "        ", "return", "1.0", "\n", "\n", "", "if", "method", "==", "\"constant\"", ":", "\n", "        ", "return", "warmup_factor", "\n", "", "elif", "method", "==", "\"linear\"", ":", "\n", "        ", "alpha", "=", "iter", "/", "warmup_iters", "\n", "return", "warmup_factor", "*", "(", "1", "-", "alpha", ")", "+", "alpha", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Unknown warmup method: {}\"", ".", "format", "(", "method", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.Panoptic-DeepLab.train_net.Trainer.build_evaluator": [[54, 90], ["detectron2.evaluation.DatasetEvaluators", "detectron2.evaluation.DatasetEvaluators", "os.path.join", "detectron2.data.MetadataCatalog.get", "detectron2.data.MetadataCatalog.get", "evaluator_list.append", "evaluator_list.append", "evaluator_list.append", "cfg.defrost", "cfg.freeze", "evaluator_list.append", "len", "NotImplementedError", "detectron2.evaluation.COCOPanopticEvaluator", "detectron2.evaluation.COCOPanopticEvaluator", "torch.cuda.device_count", "detectron2.get_rank", "detectron2.get_rank", "detectron2.evaluation.CityscapesSemSegEvaluator", "detectron2.evaluation.CityscapesSemSegEvaluator", "detectron2.evaluation.CityscapesInstanceEvaluator", "detectron2.evaluation.CityscapesInstanceEvaluator", "detectron2.evaluation.COCOEvaluator", "detectron2.evaluation.COCOEvaluator", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank"], ["return", "cfg", "\n", "\n", "\n", "", "def", "main", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "setup", "(", "args", ")", "\n", "\n", "if", "args", ".", "eval_only", ":", "\n", "        ", "model", "=", "Trainer", ".", "build_model", "(", "cfg", ")", "\n", "DetectionCheckpointer", "(", "\n", "model", ",", "save_dir", "=", "cfg", ".", "OUTPUT_DIR", ")", ".", "resume_or_load", "(", "\n", "cfg", ".", "MODEL", ".", "WEIGHTS", ",", "resume", "=", "args", ".", "resume", ")", "\n", "res", "=", "Trainer", ".", "test", "(", "cfg", ",", "model", ")", "\n", "return", "res", "\n", "\n", "", "trainer", "=", "Trainer", "(", "cfg", ")", "\n", "trainer", ".", "resume_or_load", "(", "resume", "=", "args", ".", "resume", ")", "\n", "return", "trainer", ".", "train", "(", ")", "\n", "\n", "\n", "", "if", "__name__", "==", "\"__main__\"", ":", "\n", "    ", "args", "=", "default_argument_parser", "(", ")", ".", "parse_args", "(", ")", "\n", "\n", "print", "(", "\"Command Line Args:\"", ",", "args", ")", "\n", "launch", "(", "\n", "main", ",", "\n", "args", ".", "num_gpus", ",", "\n", "num_machines", "=", "args", ".", "num_machines", ",", "\n", "machine_rank", "=", "args", ".", "machine_rank", ",", "\n", "dist_url", "=", "args", ".", "dist_url", ",", "\n", "args", "=", "(", "args", ",", ")", ",", "\n", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.Panoptic-DeepLab.train_net.Trainer.build_train_loader": [[91, 95], ["detectron2.projects.panoptic_deeplab.PanopticDeeplabDatasetMapper", "detectron2.projects.panoptic_deeplab.PanopticDeeplabDatasetMapper", "detectron2.data.build_detection_train_loader", "detectron2.data.build_detection_train_loader", "train_net.build_sem_seg_train_aug"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.build_sem_seg_train_aug"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.Panoptic-DeepLab.train_net.Trainer.build_lr_scheduler": [[96, 103], ["detectron2.projects.deeplab.build_lr_scheduler", "detectron2.projects.deeplab.build_lr_scheduler"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.build_solver.build_lr_scheduler", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.build_solver.build_lr_scheduler"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.Panoptic-DeepLab.train_net.Trainer.build_optimizer": [[104, 155], ["set", "model.modules", "detectron2.solver.build.maybe_add_gradient_clipping", "detectron2.solver.build.maybe_add_gradient_clipping", "module.named_parameters", "torch.optim.SGD", "memo.add", "isinstance", "torch.optim.Adam", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.solver.build.maybe_add_gradient_clipping", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.solver.build.maybe_add_gradient_clipping"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.Panoptic-DeepLab.train_net.build_sem_seg_train_aug": [[34, 44], ["augs.append", "detectron2.ResizeShortestEdge", "augs.append", "detectron2.RandomFlip", "detectron2.RandomCrop"], "function", ["None"], ["\n", "\n", "", "", "class", "Trainer", "(", "DefaultTrainer", ")", ":", "\n", "\n", "    ", "@", "classmethod", "\n", "def", "build_evaluator", "(", "cls", ",", "cfg", ",", "dataset_name", ",", "output_folder", "=", "None", ")", ":", "\n", "        ", "if", "output_folder", "is", "None", ":", "\n", "            ", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference\"", ")", "\n", "", "if", "\"voc\"", "in", "dataset_name", ":", "\n", "            ", "return", "PascalVOCDetectionEvaluator", "(", "dataset_name", ")", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.Panoptic-DeepLab.train_net.setup": [[157, 168], ["detectron2.config.get_cfg", "detectron2.projects.panoptic_deeplab.add_panoptic_deeplab_config", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.engine.default_setup"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.config.add_panoptic_deeplab_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.default_setup"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.Panoptic-DeepLab.train_net.main": [[170, 184], ["train_net.setup", "train_net.Trainer", "Trainer.resume_or_load", "Trainer.train", "Trainer.build_model", "detectron2.checkpoint.DetectionCheckpointer().resume_or_load", "Trainer.test", "detectron2.checkpoint.DetectionCheckpointer"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.setup", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_packaging.TestCollectEnv.test"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.config.add_panoptic_deeplab_config": [[8, 51], ["detectron2.projects.deeplab.add_deeplab_config", "detectron2.config.CfgNode", "detectron2.config.CfgNode"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.config.add_deeplab_config"], ["from", "fvcore", ".", "common", ".", "file_io", "import", "PathManager", "\n", "\n", "\n", "class", "CfgNode", "(", "_CfgNode", ")", ":", "\n", "    ", "\"\"\"\n    The same as `fvcore.common.config.CfgNode`, but different in:\n\n    1. Use unsafe yaml loading by default.\n       Note that this may lead to arbitrary code execution: you must not\n       load a config file from untrusted sources before manually inspecting\n       the content of the file.\n    2. Support config versioning.\n       When attempting to merge an old config, it will convert the old config automatically.\n    \"\"\"", "\n", "\n", "# Note that the default value of allow_unsafe is changed to True", "\n", "def", "merge_from_file", "(", "self", ",", "cfg_filename", ":", "str", ",", "allow_unsafe", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "        ", "assert", "PathManager", ".", "isfile", "(", "cfg_filename", ")", ",", "f\"Config file '{cfg_filename}' does not exist!\"", "\n", "loaded_cfg", "=", "_CfgNode", ".", "load_yaml_with_base", "(", "cfg_filename", ",", "allow_unsafe", "=", "allow_unsafe", ")", "\n", "loaded_cfg", "=", "type", "(", "self", ")", "(", "loaded_cfg", ")", "\n", "\n", "# defaults.py needs to import CfgNode", "\n", "from", ".", "defaults", "import", "_C", "\n", "\n", "latest_ver", "=", "_C", ".", "VERSION", "\n", "assert", "(", "\n", "latest_ver", "==", "self", ".", "VERSION", "\n", ")", ",", "\"CfgNode.merge_from_file is only allowed on a config object of latest version!\"", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "loaded_ver", "=", "loaded_cfg", ".", "get", "(", "\"VERSION\"", ",", "None", ")", "\n", "if", "loaded_ver", "is", "None", ":", "\n", "            ", "from", ".", "compat", "import", "guess_version", "\n", "\n", "loaded_ver", "=", "guess_version", "(", "loaded_cfg", ",", "cfg_filename", ")", "\n", "", "assert", "loaded_ver", "<=", "self", ".", "VERSION", ",", "\"Cannot merge a v{} config into a v{} config.\"", ".", "format", "(", "\n", "loaded_ver", ",", "self", ".", "VERSION", "\n", ")", "\n", "\n", "if", "loaded_ver", "==", "self", ".", "VERSION", ":", "\n", "            ", "self", ".", "merge_from_other_cfg", "(", "loaded_cfg", ")", "\n", "", "else", ":", "\n", "# compat.py needs to import CfgNode", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.panoptic_seg.PanopticDeepLab.__init__": [[42, 55], ["torch.nn.Module.__init__", "detectron2.modeling.build_backbone", "detectron2.modeling.build_sem_seg_head", "panoptic_seg.build_ins_embed_branch", "panoptic_seg.PanopticDeepLab.register_buffer", "panoptic_seg.PanopticDeepLab.register_buffer", "detectron2.data.MetadataCatalog.get", "panoptic_seg.PanopticDeepLab.backbone.output_shape", "panoptic_seg.PanopticDeepLab.backbone.output_shape", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.semantic_seg.build_sem_seg_head", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.panoptic_seg.build_ins_embed_branch", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.backbone.Backbone.output_shape", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.backbone.Backbone.output_shape"], ["def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "self", ".", "sem_seg_head", "=", "build_sem_seg_head", "(", "cfg", ",", "self", ".", "backbone", ".", "output_shape", "(", ")", ")", "\n", "self", ".", "ins_embed_head", "=", "build_ins_embed_branch", "(", "cfg", ",", "self", ".", "backbone", ".", "output_shape", "(", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_mean\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_MEAN", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_std\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_STD", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "meta", "=", "MetadataCatalog", ".", "get", "(", "cfg", ".", "DATASETS", ".", "TRAIN", "[", "0", "]", ")", "\n", "self", ".", "stuff_area", "=", "cfg", ".", "MODEL", ".", "PANOPTIC_DEEPLAB", ".", "STUFF_AREA", "\n", "self", ".", "threshold", "=", "cfg", ".", "MODEL", ".", "PANOPTIC_DEEPLAB", ".", "CENTER_THRESHOLD", "\n", "self", ".", "nms_kernel", "=", "cfg", ".", "MODEL", ".", "PANOPTIC_DEEPLAB", ".", "NMS_KERNEL", "\n", "self", ".", "top_k", "=", "cfg", ".", "MODEL", ".", "PANOPTIC_DEEPLAB", ".", "TOP_K_INSTANCE", "\n", "self", ".", "predict_instances", "=", "cfg", ".", "MODEL", ".", "PANOPTIC_DEEPLAB", ".", "PREDICT_INSTANCES", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.panoptic_seg.PanopticDeepLab.device": [[56, 59], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "pixel_mean", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.panoptic_seg.PanopticDeepLab.forward": [[60, 205], ["detectron2.structures.ImageList.from_tensors", "panoptic_seg.PanopticDeepLab.backbone", "panoptic_seg.PanopticDeepLab.sem_seg_head", "losses.update", "panoptic_seg.PanopticDeepLab.ins_embed_head", "losses.update", "losses.update", "zip", "x[].to", "detectron2.structures.ImageList.from_tensors().tensor.unsqueeze", "input_per_image.get", "input_per_image.get", "detectron2.modeling.postprocessing.sem_seg_postprocess", "detectron2.modeling.postprocessing.sem_seg_postprocess", "detectron2.modeling.postprocessing.sem_seg_postprocess", "post_processing.get_panoptic_segmentation", "processed_results.append", "panoptic_image.squeeze.squeeze.squeeze", "torch.nn.functional.softmax", "x[].to", "detectron2.structures.ImageList.from_tensors", "x[].to", "x[].to", "detectron2.structures.ImageList.from_tensors", "x[].to", "detectron2.structures.ImageList.from_tensors", "x[].to", "detectron2.structures.ImageList.from_tensors", "detectron2.modeling.postprocessing.sem_seg_postprocess.argmax", "panoptic_image.squeeze.squeeze.cpu().numpy", "numpy.unique", "x[].to", "detectron2.structures.ImageList.from_tensors", "panoptic_seg.PanopticDeepLab.meta.thing_dataset_id_to_contiguous_id.values", "len", "detectron2.structures.Instances.cat", "detectron2.structures.ImageList.from_tensors", "panoptic_image.squeeze.squeeze.cpu", "list", "detectron2.structures.Instances", "torch.tensor", "mask.unsqueeze", "torch.mean", "torch.nonzero().float", "torch.tensor", "detectron2.structures.BitMasks().get_bounding_boxes", "instances.append", "panoptic_seg.PanopticDeepLab.meta.thing_dataset_id_to_contiguous_id.values", "torch.mean", "torch.mean", "torch.nonzero", "detectron2.structures.BitMasks", "int", "int", "center_y.item", "center_x.item"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.postprocessing.sem_seg_postprocess", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.postprocessing.sem_seg_postprocess", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.postprocessing.sem_seg_postprocess", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.post_processing.get_panoptic_segmentation", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.PolygonMasks.get_bounding_boxes"], ["", "def", "forward", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            batched_inputs: a list, batched outputs of :class:`DatasetMapper`.\n                Each item in the list contains the inputs for one image.\n                For now, each item in the list is a dict that contains:\n                   * \"image\": Tensor, image in (C, H, W) format.\n                   * \"sem_seg\": semantic segmentation ground truth\n                   * \"center\": center points heatmap ground truth\n                   * \"offset\": pixel offsets to center points ground truth\n                   * Other information that's included in the original dicts, such as:\n                     \"height\", \"width\" (int): the output resolution of the model (may be different\n                     from input resolution), used in inference.\n        Returns:\n            list[dict]:\n                each dict is the results for one image. The dict contains the following keys:\n\n                * \"panoptic_seg\", \"sem_seg\": see documentation\n                    :doc:`/tutorials/models` for the standard output format\n                * \"instances\": available if ``predict_instances is True``. see documentation\n                    :doc:`/tutorials/models` for the standard output format\n        \"\"\"", "\n", "images", "=", "[", "x", "[", "\"image\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "images", "=", "[", "(", "x", "-", "self", ".", "pixel_mean", ")", "/", "self", ".", "pixel_std", "for", "x", "in", "images", "]", "\n", "size_divisibility", "=", "self", ".", "backbone", ".", "size_divisibility", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "size_divisibility", ")", "\n", "\n", "features", "=", "self", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "\n", "losses", "=", "{", "}", "\n", "if", "\"sem_seg\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "targets", "=", "[", "x", "[", "\"sem_seg\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "targets", "=", "ImageList", ".", "from_tensors", "(", "\n", "targets", ",", "size_divisibility", ",", "self", ".", "sem_seg_head", ".", "ignore_value", "\n", ")", ".", "tensor", "\n", "if", "\"sem_seg_weights\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "# The default D2 DatasetMapper may not contain \"sem_seg_weights\"", "\n", "# Avoid error in testing when default DatasetMapper is used.", "\n", "                ", "weights", "=", "[", "x", "[", "\"sem_seg_weights\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "weights", "=", "ImageList", ".", "from_tensors", "(", "weights", ",", "size_divisibility", ")", ".", "tensor", "\n", "", "else", ":", "\n", "                ", "weights", "=", "None", "\n", "", "", "else", ":", "\n", "            ", "targets", "=", "None", "\n", "weights", "=", "None", "\n", "", "sem_seg_results", ",", "sem_seg_losses", "=", "self", ".", "sem_seg_head", "(", "features", ",", "targets", ",", "weights", ")", "\n", "losses", ".", "update", "(", "sem_seg_losses", ")", "\n", "\n", "if", "\"center\"", "in", "batched_inputs", "[", "0", "]", "and", "\"offset\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "center_targets", "=", "[", "x", "[", "\"center\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "center_targets", "=", "ImageList", ".", "from_tensors", "(", "\n", "center_targets", ",", "size_divisibility", "\n", ")", ".", "tensor", ".", "unsqueeze", "(", "1", ")", "\n", "center_weights", "=", "[", "x", "[", "\"center_weights\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "center_weights", "=", "ImageList", ".", "from_tensors", "(", "center_weights", ",", "size_divisibility", ")", ".", "tensor", "\n", "\n", "offset_targets", "=", "[", "x", "[", "\"offset\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "offset_targets", "=", "ImageList", ".", "from_tensors", "(", "offset_targets", ",", "size_divisibility", ")", ".", "tensor", "\n", "offset_weights", "=", "[", "x", "[", "\"offset_weights\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "offset_weights", "=", "ImageList", ".", "from_tensors", "(", "offset_weights", ",", "size_divisibility", ")", ".", "tensor", "\n", "", "else", ":", "\n", "            ", "center_targets", "=", "None", "\n", "center_weights", "=", "None", "\n", "\n", "offset_targets", "=", "None", "\n", "offset_weights", "=", "None", "\n", "\n", "", "center_results", ",", "offset_results", ",", "center_losses", ",", "offset_losses", "=", "self", ".", "ins_embed_head", "(", "\n", "features", ",", "center_targets", ",", "center_weights", ",", "offset_targets", ",", "offset_weights", "\n", ")", "\n", "losses", ".", "update", "(", "center_losses", ")", "\n", "losses", ".", "update", "(", "offset_losses", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "losses", "\n", "\n", "", "processed_results", "=", "[", "]", "\n", "for", "sem_seg_result", ",", "center_result", ",", "offset_result", ",", "input_per_image", ",", "image_size", "in", "zip", "(", "\n", "sem_seg_results", ",", "center_results", ",", "offset_results", ",", "batched_inputs", ",", "images", ".", "image_sizes", "\n", ")", ":", "\n", "            ", "height", "=", "input_per_image", ".", "get", "(", "\"height\"", ")", "\n", "width", "=", "input_per_image", ".", "get", "(", "\"width\"", ")", "\n", "r", "=", "sem_seg_postprocess", "(", "sem_seg_result", ",", "image_size", ",", "height", ",", "width", ")", "\n", "c", "=", "sem_seg_postprocess", "(", "center_result", ",", "image_size", ",", "height", ",", "width", ")", "\n", "o", "=", "sem_seg_postprocess", "(", "offset_result", ",", "image_size", ",", "height", ",", "width", ")", "\n", "# Post-processing to get panoptic segmentation.", "\n", "panoptic_image", ",", "_", "=", "get_panoptic_segmentation", "(", "\n", "r", ".", "argmax", "(", "dim", "=", "0", ",", "keepdim", "=", "True", ")", ",", "\n", "c", ",", "\n", "o", ",", "\n", "thing_ids", "=", "self", ".", "meta", ".", "thing_dataset_id_to_contiguous_id", ".", "values", "(", ")", ",", "\n", "label_divisor", "=", "self", ".", "meta", ".", "label_divisor", ",", "\n", "stuff_area", "=", "self", ".", "stuff_area", ",", "\n", "void_label", "=", "-", "1", ",", "\n", "threshold", "=", "self", ".", "threshold", ",", "\n", "nms_kernel", "=", "self", ".", "nms_kernel", ",", "\n", "top_k", "=", "self", ".", "top_k", ",", "\n", ")", "\n", "# For semantic segmentation evaluation.", "\n", "processed_results", ".", "append", "(", "{", "\"sem_seg\"", ":", "r", "}", ")", "\n", "panoptic_image", "=", "panoptic_image", ".", "squeeze", "(", "0", ")", "\n", "semantic_prob", "=", "F", ".", "softmax", "(", "r", ",", "dim", "=", "0", ")", "\n", "# For panoptic segmentation evaluation.", "\n", "processed_results", "[", "-", "1", "]", "[", "\"panoptic_seg\"", "]", "=", "(", "panoptic_image", ",", "None", ")", "\n", "# For instance segmentation evaluation.", "\n", "if", "self", ".", "predict_instances", ":", "\n", "                ", "instances", "=", "[", "]", "\n", "panoptic_image_cpu", "=", "panoptic_image", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "for", "panoptic_label", "in", "np", ".", "unique", "(", "panoptic_image_cpu", ")", ":", "\n", "                    ", "if", "panoptic_label", "==", "-", "1", ":", "\n", "                        ", "continue", "\n", "", "pred_class", "=", "panoptic_label", "//", "self", ".", "meta", ".", "label_divisor", "\n", "isthing", "=", "pred_class", "in", "list", "(", "\n", "self", ".", "meta", ".", "thing_dataset_id_to_contiguous_id", ".", "values", "(", ")", "\n", ")", "\n", "# Get instance segmentation results.", "\n", "if", "isthing", ":", "\n", "                        ", "instance", "=", "Instances", "(", "(", "height", ",", "width", ")", ")", "\n", "# Evaluation code takes continuous id starting from 0", "\n", "instance", ".", "pred_classes", "=", "torch", ".", "tensor", "(", "\n", "[", "pred_class", "]", ",", "device", "=", "panoptic_image", ".", "device", "\n", ")", "\n", "mask", "=", "panoptic_image", "==", "panoptic_label", "\n", "instance", ".", "pred_masks", "=", "mask", ".", "unsqueeze", "(", "0", ")", "\n", "# Average semantic probability", "\n", "sem_scores", "=", "semantic_prob", "[", "pred_class", ",", "...", "]", "\n", "sem_scores", "=", "torch", ".", "mean", "(", "sem_scores", "[", "mask", "]", ")", "\n", "# Center point probability", "\n", "mask_indices", "=", "torch", ".", "nonzero", "(", "mask", ")", ".", "float", "(", ")", "\n", "center_y", ",", "center_x", "=", "(", "\n", "torch", ".", "mean", "(", "mask_indices", "[", ":", ",", "0", "]", ")", ",", "\n", "torch", ".", "mean", "(", "mask_indices", "[", ":", ",", "1", "]", ")", ",", "\n", ")", "\n", "center_scores", "=", "c", "[", "0", ",", "int", "(", "center_y", ".", "item", "(", ")", ")", ",", "int", "(", "center_x", ".", "item", "(", ")", ")", "]", "\n", "# Confidence score is semantic prob * center prob.", "\n", "instance", ".", "scores", "=", "torch", ".", "tensor", "(", "\n", "[", "sem_scores", "*", "center_scores", "]", ",", "device", "=", "panoptic_image", ".", "device", "\n", ")", "\n", "# Get bounding boxes", "\n", "instance", ".", "pred_boxes", "=", "BitMasks", "(", "instance", ".", "pred_masks", ")", ".", "get_bounding_boxes", "(", ")", "\n", "instances", ".", "append", "(", "instance", ")", "\n", "", "", "if", "len", "(", "instances", ")", ">", "0", ":", "\n", "                    ", "processed_results", "[", "-", "1", "]", "[", "\"instances\"", "]", "=", "Instances", ".", "cat", "(", "instances", ")", "\n", "\n", "", "", "", "return", "processed_results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.panoptic_seg.PanopticDeepLabSemSegHead.__init__": [[213, 288], ["detectron2.projects.deeplab.DeepLabV3PlusHead.__init__", "torch.nn.Sequential", "fvcore.c2_xavier_fill", "fvcore.c2_xavier_fill", "detectron2.layers.Conv2d", "torch.nn.init.normal_", "torch.nn.init.constant_", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "torch.nn.CrossEntropyLoss", "detectron2.projects.deeplab.loss.DeepLabCE", "ValueError", "detectron2.layers.get_norm", "detectron2.layers.get_norm"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "input_shape", ":", "Dict", "[", "str", ",", "ShapeSpec", "]", ",", "\n", "*", ",", "\n", "decoder_channels", ":", "List", "[", "int", "]", ",", "\n", "norm", ":", "Union", "[", "str", ",", "Callable", "]", ",", "\n", "head_channels", ":", "int", ",", "\n", "loss_weight", ":", "float", ",", "\n", "loss_type", ":", "str", ",", "\n", "loss_top_k", ":", "float", ",", "\n", "ignore_value", ":", "int", ",", "\n", "num_classes", ":", "int", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            input_shape (ShapeSpec): shape of the input feature\n            decoder_channels (list[int]): a list of output channels of each\n                decoder stage. It should have the same length as \"in_features\"\n                (each element in \"in_features\" corresponds to one decoder stage).\n            norm (str or callable): normalization for all conv layers.\n            head_channels (int): the output channels of extra convolutions\n                between decoder and predictor.\n            loss_weight (float): loss weight.\n            loss_top_k: (float): setting the top k% hardest pixels for\n                \"hard_pixel_mining\" loss.\n            loss_type, ignore_value, num_classes: the same as the base class.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "input_shape", ",", "\n", "decoder_channels", "=", "decoder_channels", ",", "\n", "norm", "=", "norm", ",", "\n", "ignore_value", "=", "ignore_value", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "assert", "self", ".", "decoder_only", "\n", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "use_bias", "=", "norm", "==", "\"\"", "\n", "# `head` is additional transform before predictor", "\n", "self", ".", "head", "=", "nn", ".", "Sequential", "(", "\n", "Conv2d", "(", "\n", "decoder_channels", "[", "0", "]", ",", "\n", "decoder_channels", "[", "0", "]", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "use_bias", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "decoder_channels", "[", "0", "]", ")", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", ",", "\n", "Conv2d", "(", "\n", "decoder_channels", "[", "0", "]", ",", "\n", "head_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "use_bias", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "head_channels", ")", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", ",", "\n", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "head", "[", "0", "]", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "head", "[", "1", "]", ")", "\n", "self", ".", "predictor", "=", "Conv2d", "(", "head_channels", ",", "num_classes", ",", "kernel_size", "=", "1", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "predictor", ".", "weight", ",", "0", ",", "0.001", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "predictor", ".", "bias", ",", "0", ")", "\n", "\n", "if", "loss_type", "==", "\"cross_entropy\"", ":", "\n", "            ", "self", ".", "loss", "=", "nn", ".", "CrossEntropyLoss", "(", "reduction", "=", "\"mean\"", ",", "ignore_index", "=", "ignore_value", ")", "\n", "", "elif", "loss_type", "==", "\"hard_pixel_mining\"", ":", "\n", "            ", "self", ".", "loss", "=", "DeepLabCE", "(", "ignore_label", "=", "ignore_value", ",", "top_k_percent_pixels", "=", "loss_top_k", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Unexpected loss type: %s\"", "%", "loss_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.panoptic_seg.PanopticDeepLabSemSegHead.from_config": [[289, 295], ["super().from_config"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3PlusHead.from_config"], ["", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "ret", "=", "super", "(", ")", ".", "from_config", "(", "cfg", ",", "input_shape", ")", "\n", "ret", "[", "\"head_channels\"", "]", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "HEAD_CHANNELS", "\n", "ret", "[", "\"loss_top_k\"", "]", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "LOSS_TOP_K", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.panoptic_seg.PanopticDeepLabSemSegHead.forward": [[296, 310], ["panoptic_seg.PanopticDeepLabSemSegHead.layers", "torch.nn.functional.interpolate", "panoptic_seg.PanopticDeepLabSemSegHead.losses"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3PlusHead.layers", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3Head.losses"], ["", "def", "forward", "(", "self", ",", "features", ",", "targets", "=", "None", ",", "weights", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            In training, returns (None, dict of losses)\n            In inference, returns (CxHxW logits, {})\n        \"\"\"", "\n", "y", "=", "self", ".", "layers", "(", "features", ")", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "None", ",", "self", ".", "losses", "(", "y", ",", "targets", ",", "weights", ")", "\n", "", "else", ":", "\n", "            ", "y", "=", "F", ".", "interpolate", "(", "\n", "y", ",", "scale_factor", "=", "self", ".", "common_stride", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "return", "y", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.panoptic_seg.PanopticDeepLabSemSegHead.layers": [[311, 317], ["super().layers", "panoptic_seg.PanopticDeepLabSemSegHead.head", "panoptic_seg.PanopticDeepLabSemSegHead.predictor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3PlusHead.layers"], ["", "", "def", "layers", "(", "self", ",", "features", ")", ":", "\n", "        ", "assert", "self", ".", "decoder_only", "\n", "y", "=", "super", "(", ")", ".", "layers", "(", "features", ")", "\n", "y", "=", "self", ".", "head", "(", "y", ")", "\n", "y", "=", "self", ".", "predictor", "(", "y", ")", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.panoptic_seg.PanopticDeepLabSemSegHead.losses": [[318, 325], ["torch.nn.functional.interpolate", "panoptic_seg.PanopticDeepLabSemSegHead.loss"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.multi_cls_head.MultiClsHead.loss"], ["", "def", "losses", "(", "self", ",", "predictions", ",", "targets", ",", "weights", "=", "None", ")", ":", "\n", "        ", "predictions", "=", "F", ".", "interpolate", "(", "\n", "predictions", ",", "scale_factor", "=", "self", ".", "common_stride", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "loss", "=", "self", ".", "loss", "(", "predictions", ",", "targets", ",", "weights", ")", "\n", "losses", "=", "{", "\"loss_sem_seg\"", ":", "loss", "*", "self", ".", "loss_weight", "}", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.panoptic_seg.PanopticDeepLabInsEmbedHead.__init__": [[341, 431], ["detectron2.projects.deeplab.DeepLabV3PlusHead.__init__", "torch.nn.Sequential", "fvcore.c2_xavier_fill", "fvcore.c2_xavier_fill", "detectron2.layers.Conv2d", "torch.nn.init.normal_", "torch.nn.init.constant_", "torch.nn.Sequential", "fvcore.c2_xavier_fill", "fvcore.c2_xavier_fill", "detectron2.layers.Conv2d", "torch.nn.init.normal_", "torch.nn.init.constant_", "torch.nn.MSELoss", "torch.nn.L1Loss", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "detectron2.layers.get_norm"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "input_shape", ":", "Dict", "[", "str", ",", "ShapeSpec", "]", ",", "\n", "*", ",", "\n", "decoder_channels", ":", "List", "[", "int", "]", ",", "\n", "norm", ":", "Union", "[", "str", ",", "Callable", "]", ",", "\n", "head_channels", ":", "int", ",", "\n", "center_loss_weight", ":", "float", ",", "\n", "offset_loss_weight", ":", "float", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            input_shape (ShapeSpec): shape of the input feature\n            decoder_channels (list[int]): a list of output channels of each\n                decoder stage. It should have the same length as \"in_features\"\n                (each element in \"in_features\" corresponds to one decoder stage).\n            norm (str or callable): normalization for all conv layers.\n            head_channels (int): the output channels of extra convolutions\n                between decoder and predictor.\n            center_loss_weight (float): loss weight for center point prediction.\n            offset_loss_weight (float): loss weight for center offset prediction.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "input_shape", ",", "decoder_channels", "=", "decoder_channels", ",", "norm", "=", "norm", ",", "**", "kwargs", ")", "\n", "assert", "self", ".", "decoder_only", "\n", "\n", "self", ".", "center_loss_weight", "=", "center_loss_weight", "\n", "self", ".", "offset_loss_weight", "=", "offset_loss_weight", "\n", "use_bias", "=", "norm", "==", "\"\"", "\n", "# center prediction", "\n", "# `head` is additional transform before predictor", "\n", "self", ".", "center_head", "=", "nn", ".", "Sequential", "(", "\n", "Conv2d", "(", "\n", "decoder_channels", "[", "0", "]", ",", "\n", "decoder_channels", "[", "0", "]", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "use_bias", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "decoder_channels", "[", "0", "]", ")", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", ",", "\n", "Conv2d", "(", "\n", "decoder_channels", "[", "0", "]", ",", "\n", "head_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "use_bias", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "head_channels", ")", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", ",", "\n", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "center_head", "[", "0", "]", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "center_head", "[", "1", "]", ")", "\n", "self", ".", "center_predictor", "=", "Conv2d", "(", "head_channels", ",", "1", ",", "kernel_size", "=", "1", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "center_predictor", ".", "weight", ",", "0", ",", "0.001", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "center_predictor", ".", "bias", ",", "0", ")", "\n", "\n", "# offset prediction", "\n", "# `head` is additional transform before predictor", "\n", "self", ".", "offset_head", "=", "nn", ".", "Sequential", "(", "\n", "Conv2d", "(", "\n", "decoder_channels", "[", "0", "]", ",", "\n", "decoder_channels", "[", "0", "]", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "use_bias", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "decoder_channels", "[", "0", "]", ")", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", ",", "\n", "Conv2d", "(", "\n", "decoder_channels", "[", "0", "]", ",", "\n", "head_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "use_bias", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "head_channels", ")", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", ",", "\n", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "offset_head", "[", "0", "]", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "offset_head", "[", "1", "]", ")", "\n", "self", ".", "offset_predictor", "=", "Conv2d", "(", "head_channels", ",", "2", ",", "kernel_size", "=", "1", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "offset_predictor", ".", "weight", ",", "0", ",", "0.001", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "offset_predictor", ".", "bias", ",", "0", ")", "\n", "\n", "self", ".", "center_loss", "=", "nn", ".", "MSELoss", "(", "reduction", "=", "\"none\"", ")", "\n", "self", ".", "offset_loss", "=", "nn", ".", "L1Loss", "(", "reduction", "=", "\"none\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.panoptic_seg.PanopticDeepLabInsEmbedHead.from_config": [[432, 457], ["dict", "len"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "if", "cfg", ".", "INPUT", ".", "CROP", ".", "ENABLED", ":", "\n", "            ", "assert", "cfg", ".", "INPUT", ".", "CROP", ".", "TYPE", "==", "\"absolute\"", "\n", "train_size", "=", "cfg", ".", "INPUT", ".", "CROP", ".", "SIZE", "\n", "", "else", ":", "\n", "            ", "train_size", "=", "None", "\n", "", "decoder_channels", "=", "[", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "CONVS_DIM", "]", "*", "(", "\n", "len", "(", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "IN_FEATURES", ")", "-", "1", "\n", ")", "+", "[", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "ASPP_CHANNELS", "]", "\n", "ret", "=", "dict", "(", "\n", "input_shape", "=", "input_shape", ",", "\n", "in_features", "=", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "IN_FEATURES", ",", "\n", "project_channels", "=", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "PROJECT_CHANNELS", ",", "\n", "aspp_dilations", "=", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "ASPP_DILATIONS", ",", "\n", "aspp_dropout", "=", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "ASPP_DROPOUT", ",", "\n", "decoder_channels", "=", "decoder_channels", ",", "\n", "common_stride", "=", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "COMMON_STRIDE", ",", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "NORM", ",", "\n", "train_size", "=", "train_size", ",", "\n", "head_channels", "=", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "HEAD_CHANNELS", ",", "\n", "center_loss_weight", "=", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "CENTER_LOSS_WEIGHT", ",", "\n", "offset_loss_weight", "=", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "OFFSET_LOSS_WEIGHT", ",", "\n", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.panoptic_seg.PanopticDeepLabInsEmbedHead.forward": [[458, 490], ["panoptic_seg.PanopticDeepLabInsEmbedHead.layers", "torch.nn.functional.interpolate", "panoptic_seg.PanopticDeepLabInsEmbedHead.center_losses", "panoptic_seg.PanopticDeepLabInsEmbedHead.offset_losses", "torch.nn.functional.interpolate"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3PlusHead.layers", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.panoptic_seg.PanopticDeepLabInsEmbedHead.center_losses", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.panoptic_seg.PanopticDeepLabInsEmbedHead.offset_losses"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "features", ",", "\n", "center_targets", "=", "None", ",", "\n", "center_weights", "=", "None", ",", "\n", "offset_targets", "=", "None", ",", "\n", "offset_weights", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            In training, returns (None, dict of losses)\n            In inference, returns (CxHxW logits, {})\n        \"\"\"", "\n", "center", ",", "offset", "=", "self", ".", "layers", "(", "features", ")", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "(", "\n", "None", ",", "\n", "None", ",", "\n", "self", ".", "center_losses", "(", "center", ",", "center_targets", ",", "center_weights", ")", ",", "\n", "self", ".", "offset_losses", "(", "offset", ",", "offset_targets", ",", "offset_weights", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "center", "=", "F", ".", "interpolate", "(", "\n", "center", ",", "scale_factor", "=", "self", ".", "common_stride", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "offset", "=", "(", "\n", "F", ".", "interpolate", "(", "\n", "offset", ",", "scale_factor", "=", "self", ".", "common_stride", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "*", "self", ".", "common_stride", "\n", ")", "\n", "return", "center", ",", "offset", ",", "{", "}", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.panoptic_seg.PanopticDeepLabInsEmbedHead.layers": [[491, 501], ["super().layers", "panoptic_seg.PanopticDeepLabInsEmbedHead.center_head", "panoptic_seg.PanopticDeepLabInsEmbedHead.center_predictor", "panoptic_seg.PanopticDeepLabInsEmbedHead.offset_head", "panoptic_seg.PanopticDeepLabInsEmbedHead.offset_predictor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3PlusHead.layers"], ["", "", "def", "layers", "(", "self", ",", "features", ")", ":", "\n", "        ", "assert", "self", ".", "decoder_only", "\n", "y", "=", "super", "(", ")", ".", "layers", "(", "features", ")", "\n", "# center", "\n", "center", "=", "self", ".", "center_head", "(", "y", ")", "\n", "center", "=", "self", ".", "center_predictor", "(", "center", ")", "\n", "# offset", "\n", "offset", "=", "self", ".", "offset_head", "(", "y", ")", "\n", "offset", "=", "self", ".", "offset_predictor", "(", "offset", ")", "\n", "return", "center", ",", "offset", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.panoptic_seg.PanopticDeepLabInsEmbedHead.center_losses": [[502, 513], ["torch.nn.functional.interpolate", "panoptic_seg.PanopticDeepLabInsEmbedHead.center_loss", "weights.sum", "loss.sum", "weights.sum", "loss.sum"], "methods", ["None"], ["", "def", "center_losses", "(", "self", ",", "predictions", ",", "targets", ",", "weights", ")", ":", "\n", "        ", "predictions", "=", "F", ".", "interpolate", "(", "\n", "predictions", ",", "scale_factor", "=", "self", ".", "common_stride", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "loss", "=", "self", ".", "center_loss", "(", "predictions", ",", "targets", ")", "*", "weights", "\n", "if", "weights", ".", "sum", "(", ")", ">", "0", ":", "\n", "            ", "loss", "=", "loss", ".", "sum", "(", ")", "/", "weights", ".", "sum", "(", ")", "\n", "", "else", ":", "\n", "            ", "loss", "=", "loss", ".", "sum", "(", ")", "*", "0", "\n", "", "losses", "=", "{", "\"loss_center\"", ":", "loss", "*", "self", ".", "center_loss_weight", "}", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.panoptic_seg.PanopticDeepLabInsEmbedHead.offset_losses": [[514, 528], ["torch.nn.functional.interpolate", "panoptic_seg.PanopticDeepLabInsEmbedHead.offset_loss", "weights.sum", "loss.sum", "weights.sum", "loss.sum"], "methods", ["None"], ["", "def", "offset_losses", "(", "self", ",", "predictions", ",", "targets", ",", "weights", ")", ":", "\n", "        ", "predictions", "=", "(", "\n", "F", ".", "interpolate", "(", "\n", "predictions", ",", "scale_factor", "=", "self", ".", "common_stride", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "*", "self", ".", "common_stride", "\n", ")", "\n", "loss", "=", "self", ".", "offset_loss", "(", "predictions", ",", "targets", ")", "*", "weights", "\n", "if", "weights", ".", "sum", "(", ")", ">", "0", ":", "\n", "            ", "loss", "=", "loss", ".", "sum", "(", ")", "/", "weights", ".", "sum", "(", ")", "\n", "", "else", ":", "\n", "            ", "loss", "=", "loss", ".", "sum", "(", ")", "*", "0", "\n", "", "losses", "=", "{", "\"loss_offset\"", ":", "loss", "*", "self", ".", "offset_loss_weight", "}", "\n", "return", "losses", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.panoptic_seg.build_ins_embed_branch": [[327, 333], ["INS_EMBED_BRANCHES_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "", "def", "build_ins_embed_branch", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build a instance embedding branch from `cfg.MODEL.INS_EMBED_HEAD.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "NAME", "\n", "return", "INS_EMBED_BRANCHES_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.target_generator.PanopticDeepLabTargetGenerator.__init__": [[12, 51], ["set", "numpy.arange", "numpy.exp"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["def", "__init__", "(", "\n", "self", ",", "\n", "ignore_label", ",", "\n", "thing_ids", ",", "\n", "sigma", "=", "8", ",", "\n", "ignore_stuff_in_offset", "=", "False", ",", "\n", "small_instance_area", "=", "0", ",", "\n", "small_instance_weight", "=", "1", ",", "\n", "ignore_crowd_in_semantic", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            ignore_label: Integer, the ignore label for semantic segmentation.\n            thing_ids: Set, a set of ids from contiguous category ids belonging\n                to thing categories.\n            sigma: the sigma for Gaussian kernel.\n            ignore_stuff_in_offset: Boolean, whether to ignore stuff region when\n                training the offset branch.\n            small_instance_area: Integer, indicates largest area for small instances.\n            small_instance_weight: Integer, indicates semantic loss weights for\n                small instances.\n            ignore_crowd_in_semantic: Boolean, whether to ignore crowd region in\n                semantic segmentation branch, crowd region is ignored in the original\n                TensorFlow implementation.\n        \"\"\"", "\n", "self", ".", "ignore_label", "=", "ignore_label", "\n", "self", ".", "thing_ids", "=", "set", "(", "thing_ids", ")", "\n", "self", ".", "ignore_stuff_in_offset", "=", "ignore_stuff_in_offset", "\n", "self", ".", "small_instance_area", "=", "small_instance_area", "\n", "self", ".", "small_instance_weight", "=", "small_instance_weight", "\n", "self", ".", "ignore_crowd_in_semantic", "=", "ignore_crowd_in_semantic", "\n", "\n", "# Generate the default Gaussian image for each center", "\n", "self", ".", "sigma", "=", "sigma", "\n", "size", "=", "6", "*", "sigma", "+", "3", "\n", "x", "=", "np", ".", "arange", "(", "0", ",", "size", ",", "1", ",", "float", ")", "\n", "y", "=", "x", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "x0", ",", "y0", "=", "3", "*", "sigma", "+", "1", ",", "3", "*", "sigma", "+", "1", "\n", "self", ".", "g", "=", "np", ".", "exp", "(", "-", "(", "(", "x", "-", "x0", ")", "**", "2", "+", "(", "y", "-", "y0", ")", "**", "2", ")", "/", "(", "2", "*", "sigma", "**", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.target_generator.PanopticDeepLabTargetGenerator.__call__": [[52, 155], ["numpy.zeros", "numpy.zeros", "numpy.meshgrid", "numpy.ones_like", "numpy.zeros_like", "numpy.zeros_like", "dict", "numpy.zeros_like", "numpy.arange", "numpy.arange", "numpy.where", "len", "center_pts.append", "numpy.maximum", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "len", "numpy.mean", "numpy.mean", "int", "int", "int", "int", "int", "int", "max", "max", "max", "min", "max", "min", "semantic.astype", "numpy.zeros.astype", "numpy.zeros.astype", "numpy.ones_like.astype", "numpy.zeros_like.astype", "numpy.zeros_like.astype", "round", "round", "numpy.round", "numpy.round", "numpy.round", "numpy.round", "min", "min"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "panoptic", ",", "segments_info", ")", ":", "\n", "        ", "\"\"\"Generates the training target.\n        reference: https://github.com/mcordts/cityscapesScripts/blob/master/cityscapesscripts/preparation/createPanopticImgs.py  # noqa\n        reference: https://github.com/facebookresearch/detectron2/blob/master/datasets/prepare_panoptic_fpn.py#L18  # noqa\n\n        Args:\n            panoptic: numpy.array, panoptic label, we assume it is already\n                converted from rgb image by panopticapi.utils.rgb2id.\n            segments_info (list[dict]): see detectron2 documentation of \"Use Custom Datasets\".\n\n        Returns:\n            A dictionary with fields:\n                - sem_seg: Tensor, semantic label, shape=(H, W).\n                - center: Tensor, center heatmap, shape=(H, W).\n                - center_points: List, center coordinates, with tuple\n                    (y-coord, x-coord).\n                - offset: Tensor, offset, shape=(2, H, W), first dim is\n                    (offset_y, offset_x).\n                - sem_seg_weights: Tensor, loss weight for semantic prediction,\n                    shape=(H, W).\n                - center_weights: Tensor, ignore region of center prediction,\n                    shape=(H, W), used as weights for center regression 0 is\n                    ignore, 1 is has instance. Multiply this mask to loss.\n                - offset_weights: Tensor, ignore region of offset prediction,\n                    shape=(H, W), used as weights for offset regression 0 is\n                    ignore, 1 is has instance. Multiply this mask to loss.\n        \"\"\"", "\n", "height", ",", "width", "=", "panoptic", ".", "shape", "[", "0", "]", ",", "panoptic", ".", "shape", "[", "1", "]", "\n", "semantic", "=", "np", ".", "zeros_like", "(", "panoptic", ",", "dtype", "=", "np", ".", "uint8", ")", "+", "self", ".", "ignore_label", "\n", "center", "=", "np", ".", "zeros", "(", "(", "height", ",", "width", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "center_pts", "=", "[", "]", "\n", "offset", "=", "np", ".", "zeros", "(", "(", "2", ",", "height", ",", "width", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "y_coord", ",", "x_coord", "=", "np", ".", "meshgrid", "(", "\n", "np", ".", "arange", "(", "height", ",", "dtype", "=", "np", ".", "float32", ")", ",", "np", ".", "arange", "(", "width", ",", "dtype", "=", "np", ".", "float32", ")", ",", "indexing", "=", "\"ij\"", "\n", ")", "\n", "# Generate pixel-wise loss weights", "\n", "semantic_weights", "=", "np", ".", "ones_like", "(", "panoptic", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "# 0: ignore, 1: has instance", "\n", "# three conditions for a region to be ignored for instance branches:", "\n", "# (1) It is labeled as `ignore_label`", "\n", "# (2) It is crowd region (iscrowd=1)", "\n", "# (3) (Optional) It is stuff region (for offset branch)", "\n", "center_weights", "=", "np", ".", "zeros_like", "(", "panoptic", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "offset_weights", "=", "np", ".", "zeros_like", "(", "panoptic", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "for", "seg", "in", "segments_info", ":", "\n", "            ", "cat_id", "=", "seg", "[", "\"category_id\"", "]", "\n", "if", "not", "(", "self", ".", "ignore_crowd_in_semantic", "and", "seg", "[", "\"iscrowd\"", "]", ")", ":", "\n", "                ", "semantic", "[", "panoptic", "==", "seg", "[", "\"id\"", "]", "]", "=", "cat_id", "\n", "", "if", "not", "seg", "[", "\"iscrowd\"", "]", ":", "\n", "# Ignored regions are not in `segments_info`.", "\n", "# Handle crowd region.", "\n", "                ", "center_weights", "[", "panoptic", "==", "seg", "[", "\"id\"", "]", "]", "=", "1", "\n", "if", "not", "self", ".", "ignore_stuff_in_offset", "or", "cat_id", "in", "self", ".", "thing_ids", ":", "\n", "                    ", "offset_weights", "[", "panoptic", "==", "seg", "[", "\"id\"", "]", "]", "=", "1", "\n", "", "", "if", "cat_id", "in", "self", ".", "thing_ids", ":", "\n", "# find instance center", "\n", "                ", "mask_index", "=", "np", ".", "where", "(", "panoptic", "==", "seg", "[", "\"id\"", "]", ")", "\n", "if", "len", "(", "mask_index", "[", "0", "]", ")", "==", "0", ":", "\n", "# the instance is completely cropped", "\n", "                    ", "continue", "\n", "\n", "# Find instance area", "\n", "", "ins_area", "=", "len", "(", "mask_index", "[", "0", "]", ")", "\n", "if", "ins_area", "<", "self", ".", "small_instance_area", ":", "\n", "                    ", "semantic_weights", "[", "panoptic", "==", "seg", "[", "\"id\"", "]", "]", "=", "self", ".", "small_instance_weight", "\n", "\n", "", "center_y", ",", "center_x", "=", "np", ".", "mean", "(", "mask_index", "[", "0", "]", ")", ",", "np", ".", "mean", "(", "mask_index", "[", "1", "]", ")", "\n", "center_pts", ".", "append", "(", "[", "center_y", ",", "center_x", "]", ")", "\n", "\n", "# generate center heatmap", "\n", "y", ",", "x", "=", "int", "(", "round", "(", "center_y", ")", ")", ",", "int", "(", "round", "(", "center_x", ")", ")", "\n", "sigma", "=", "self", ".", "sigma", "\n", "# upper left", "\n", "ul", "=", "int", "(", "np", ".", "round", "(", "x", "-", "3", "*", "sigma", "-", "1", ")", ")", ",", "int", "(", "np", ".", "round", "(", "y", "-", "3", "*", "sigma", "-", "1", ")", ")", "\n", "# bottom right", "\n", "br", "=", "int", "(", "np", ".", "round", "(", "x", "+", "3", "*", "sigma", "+", "2", ")", ")", ",", "int", "(", "np", ".", "round", "(", "y", "+", "3", "*", "sigma", "+", "2", ")", ")", "\n", "\n", "# start and end indices in default Gaussian image", "\n", "gaussian_x0", ",", "gaussian_x1", "=", "max", "(", "0", ",", "-", "ul", "[", "0", "]", ")", ",", "min", "(", "br", "[", "0", "]", ",", "width", ")", "-", "ul", "[", "0", "]", "\n", "gaussian_y0", ",", "gaussian_y1", "=", "max", "(", "0", ",", "-", "ul", "[", "1", "]", ")", ",", "min", "(", "br", "[", "1", "]", ",", "height", ")", "-", "ul", "[", "1", "]", "\n", "\n", "# start and end indices in center heatmap image", "\n", "center_x0", ",", "center_x1", "=", "max", "(", "0", ",", "ul", "[", "0", "]", ")", ",", "min", "(", "br", "[", "0", "]", ",", "width", ")", "\n", "center_y0", ",", "center_y1", "=", "max", "(", "0", ",", "ul", "[", "1", "]", ")", ",", "min", "(", "br", "[", "1", "]", ",", "height", ")", "\n", "center", "[", "center_y0", ":", "center_y1", ",", "center_x0", ":", "center_x1", "]", "=", "np", ".", "maximum", "(", "\n", "center", "[", "center_y0", ":", "center_y1", ",", "center_x0", ":", "center_x1", "]", ",", "\n", "self", ".", "g", "[", "gaussian_y0", ":", "gaussian_y1", ",", "gaussian_x0", ":", "gaussian_x1", "]", ",", "\n", ")", "\n", "\n", "# generate offset (2, h, w) -> (y-dir, x-dir)", "\n", "offset", "[", "0", "]", "[", "mask_index", "]", "=", "center_y", "-", "y_coord", "[", "mask_index", "]", "\n", "offset", "[", "1", "]", "[", "mask_index", "]", "=", "center_x", "-", "x_coord", "[", "mask_index", "]", "\n", "\n", "", "", "center_weights", "=", "center_weights", "[", "None", "]", "\n", "offset_weights", "=", "offset_weights", "[", "None", "]", "\n", "return", "dict", "(", "\n", "sem_seg", "=", "torch", ".", "as_tensor", "(", "semantic", ".", "astype", "(", "\"long\"", ")", ")", ",", "\n", "center", "=", "torch", ".", "as_tensor", "(", "center", ".", "astype", "(", "np", ".", "float32", ")", ")", ",", "\n", "center_points", "=", "center_pts", ",", "\n", "offset", "=", "torch", ".", "as_tensor", "(", "offset", ".", "astype", "(", "np", ".", "float32", ")", ")", ",", "\n", "sem_seg_weights", "=", "torch", ".", "as_tensor", "(", "semantic_weights", ".", "astype", "(", "np", ".", "float32", ")", ")", ",", "\n", "center_weights", "=", "torch", ".", "as_tensor", "(", "center_weights", ".", "astype", "(", "np", ".", "float32", ")", ")", ",", "\n", "offset_weights", "=", "torch", ".", "as_tensor", "(", "offset_weights", ".", "astype", "(", "np", ".", "float32", ")", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.post_processing.find_instance_center": [[9, 42], ["torch.threshold", "torch.max_pool2d", "center_heatmap.squeeze.squeeze", "len", "torch.nonzero", "torch.nonzero", "torch.topk", "torch.topk", "torch.nonzero", "torch.nonzero", "center_heatmap.squeeze.size", "torch.flatten", "torch.flatten", "top_k_scores[].clamp_"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten"], ["def", "find_instance_center", "(", "center_heatmap", ",", "threshold", "=", "0.1", ",", "nms_kernel", "=", "3", ",", "top_k", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Find the center points from the center heatmap.\n    Args:\n        center_heatmap: A Tensor of shape [1, H, W] of raw center heatmap output.\n        threshold: A float, threshold applied to center heatmap score.\n        nms_kernel: An integer, NMS max pooling kernel size.\n        top_k: An integer, top k centers to keep.\n    Returns:\n        A Tensor of shape [K, 2] where K is the number of center points. The\n            order of second dim is (y, x).\n    \"\"\"", "\n", "# Thresholding, setting values below threshold to -1.", "\n", "center_heatmap", "=", "F", ".", "threshold", "(", "center_heatmap", ",", "threshold", ",", "-", "1", ")", "\n", "\n", "# NMS", "\n", "nms_padding", "=", "(", "nms_kernel", "-", "1", ")", "//", "2", "\n", "center_heatmap_max_pooled", "=", "F", ".", "max_pool2d", "(", "\n", "center_heatmap", ",", "kernel_size", "=", "nms_kernel", ",", "stride", "=", "1", ",", "padding", "=", "nms_padding", "\n", ")", "\n", "center_heatmap", "[", "center_heatmap", "!=", "center_heatmap_max_pooled", "]", "=", "-", "1", "\n", "\n", "# Squeeze first two dimensions.", "\n", "center_heatmap", "=", "center_heatmap", ".", "squeeze", "(", ")", "\n", "assert", "len", "(", "center_heatmap", ".", "size", "(", ")", ")", "==", "2", ",", "\"Something is wrong with center heatmap dimension.\"", "\n", "\n", "# Find non-zero elements.", "\n", "if", "top_k", "is", "None", ":", "\n", "        ", "return", "torch", ".", "nonzero", "(", "center_heatmap", ">", "0", ")", "\n", "", "else", ":", "\n", "# find top k centers.", "\n", "        ", "top_k_scores", ",", "_", "=", "torch", ".", "topk", "(", "torch", ".", "flatten", "(", "center_heatmap", ")", ",", "top_k", ")", "\n", "return", "torch", ".", "nonzero", "(", "center_heatmap", ">", "top_k_scores", "[", "-", "1", "]", ".", "clamp_", "(", "min", "=", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.post_processing.group_pixels": [[44, 77], ["torch.meshgrid", "torch.meshgrid", "torch.cat", "torch.cat", "center_loc.flatten().T.unsqueeze_.flatten().T.unsqueeze_", "center_points.unsqueeze.unsqueeze", "torch.norm", "torch.norm", "offsets.size", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.argmin().reshape", "torch.argmin().reshape", "y_coord.unsqueeze", "x_coord.unsqueeze", "center_loc.flatten().T.unsqueeze_.flatten", "torch.argmin", "torch.argmin"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten"], ["", "", "def", "group_pixels", "(", "center_points", ",", "offsets", ")", ":", "\n", "    ", "\"\"\"\n    Gives each pixel in the image an instance id.\n    Args:\n        center_points: A Tensor of shape [K, 2] where K is the number of center points.\n            The order of second dim is (y, x).\n        offsets: A Tensor of shape [2, H, W] of raw offset output. The order of\n            second dim is (offset_y, offset_x).\n    Returns:\n        A Tensor of shape [1, H, W] with values in range [1, K], which represents\n            the center this pixel belongs to.\n    \"\"\"", "\n", "height", ",", "width", "=", "offsets", ".", "size", "(", ")", "[", "1", ":", "]", "\n", "\n", "# Generates a coordinate map, where each location is the coordinate of", "\n", "# that location.", "\n", "y_coord", ",", "x_coord", "=", "torch", ".", "meshgrid", "(", "\n", "torch", ".", "arange", "(", "height", ",", "dtype", "=", "offsets", ".", "dtype", ",", "device", "=", "offsets", ".", "device", ")", ",", "\n", "torch", ".", "arange", "(", "width", ",", "dtype", "=", "offsets", ".", "dtype", ",", "device", "=", "offsets", ".", "device", ")", ",", "\n", ")", "\n", "coord", "=", "torch", ".", "cat", "(", "(", "y_coord", ".", "unsqueeze", "(", "0", ")", ",", "x_coord", ".", "unsqueeze", "(", "0", ")", ")", ",", "dim", "=", "0", ")", "\n", "\n", "center_loc", "=", "coord", "+", "offsets", "\n", "center_loc", "=", "center_loc", ".", "flatten", "(", "1", ")", ".", "T", ".", "unsqueeze_", "(", "0", ")", "# [1, H*W, 2]", "\n", "center_points", "=", "center_points", ".", "unsqueeze", "(", "1", ")", "# [K, 1, 2]", "\n", "\n", "# Distance: [K, H*W].", "\n", "distance", "=", "torch", ".", "norm", "(", "center_points", "-", "center_loc", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# Finds center with minimum distance at each location, offset by 1, to", "\n", "# reserve id=0 for stuff.", "\n", "instance_id", "=", "torch", ".", "argmin", "(", "distance", ",", "dim", "=", "0", ")", ".", "reshape", "(", "(", "1", ",", "height", ",", "width", ")", ")", "+", "1", "\n", "return", "instance_id", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.post_processing.get_instance_segmentation": [[79, 109], ["post_processing.find_instance_center", "post_processing.group_pixels", "find_instance_center.size", "find_instance_center.unsqueeze", "torch.zeros_like", "torch.zeros_like", "find_instance_center.unsqueeze"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.post_processing.find_instance_center", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.post_processing.group_pixels"], ["", "def", "get_instance_segmentation", "(", "\n", "sem_seg", ",", "center_heatmap", ",", "offsets", ",", "thing_seg", ",", "thing_ids", ",", "threshold", "=", "0.1", ",", "nms_kernel", "=", "3", ",", "top_k", "=", "None", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Post-processing for instance segmentation, gets class agnostic instance id.\n    Args:\n        sem_seg: A Tensor of shape [1, H, W], predicted semantic label.\n        center_heatmap: A Tensor of shape [1, H, W] of raw center heatmap output.\n        offsets: A Tensor of shape [2, H, W] of raw offset output. The order of\n            second dim is (offset_y, offset_x).\n        thing_seg: A Tensor of shape [1, H, W], predicted foreground mask,\n            if not provided, inference from semantic prediction.\n        thing_ids: A set of ids from contiguous category ids belonging\n            to thing categories.\n        threshold: A float, threshold applied to center heatmap score.\n        nms_kernel: An integer, NMS max pooling kernel size.\n        top_k: An integer, top k centers to keep.\n    Returns:\n        A Tensor of shape [1, H, W] with value 0 represent stuff (not instance)\n            and other positive values represent different instances.\n        A Tensor of shape [1, K, 2] where K is the number of center points.\n            The order of second dim is (y, x).\n    \"\"\"", "\n", "center_points", "=", "find_instance_center", "(", "\n", "center_heatmap", ",", "threshold", "=", "threshold", ",", "nms_kernel", "=", "nms_kernel", ",", "top_k", "=", "top_k", "\n", ")", "\n", "if", "center_points", ".", "size", "(", "0", ")", "==", "0", ":", "\n", "        ", "return", "torch", ".", "zeros_like", "(", "sem_seg", ")", ",", "center_points", ".", "unsqueeze", "(", "0", ")", "\n", "", "ins_seg", "=", "group_pixels", "(", "center_points", ",", "offsets", ")", "\n", "return", "thing_seg", "*", "ins_seg", ",", "center_points", ".", "unsqueeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.post_processing.merge_semantic_and_instance": [[111, 163], ["collections.Counter", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.zeros_like", "torch.zeros_like", "torch.mode", "torch.mode", "torch.nonzero().size", "torch.nonzero().size", "sem_seg[].view", "class_id.item", "stuff_mask.sum().item", "class_id.item", "class_id.item", "torch.nonzero", "torch.nonzero", "stuff_mask.sum"], "function", ["None"], ["", "def", "merge_semantic_and_instance", "(", "\n", "sem_seg", ",", "ins_seg", ",", "semantic_thing_seg", ",", "label_divisor", ",", "thing_ids", ",", "stuff_area", ",", "void_label", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Post-processing for panoptic segmentation, by merging semantic segmentation\n        label and class agnostic instance segmentation label.\n    Args:\n        sem_seg: A Tensor of shape [1, H, W], predicted category id for each pixel.\n        ins_seg: A Tensor of shape [1, H, W], predicted instance id for each pixel.\n        semantic_thing_seg: A Tensor of shape [1, H, W], predicted foreground mask.\n        label_divisor: An integer, used to convert panoptic id =\n            semantic id * label_divisor + instance_id.\n        thing_ids: Set, a set of ids from contiguous category ids belonging\n            to thing categories.\n        stuff_area: An integer, remove stuff whose area is less tan stuff_area.\n        void_label: An integer, indicates the region has no confident prediction.\n    Returns:\n        A Tensor of shape [1, H, W].\n    \"\"\"", "\n", "# In case thing mask does not align with semantic prediction.", "\n", "pan_seg", "=", "torch", ".", "zeros_like", "(", "sem_seg", ")", "+", "void_label", "\n", "is_thing", "=", "(", "ins_seg", ">", "0", ")", "&", "(", "semantic_thing_seg", ">", "0", ")", "\n", "\n", "# Keep track of instance id for each class.", "\n", "class_id_tracker", "=", "Counter", "(", ")", "\n", "\n", "# Paste thing by majority voting.", "\n", "instance_ids", "=", "torch", ".", "unique", "(", "ins_seg", ")", "\n", "for", "ins_id", "in", "instance_ids", ":", "\n", "        ", "if", "ins_id", "==", "0", ":", "\n", "            ", "continue", "\n", "# Make sure only do majority voting within `semantic_thing_seg`.", "\n", "", "thing_mask", "=", "(", "ins_seg", "==", "ins_id", ")", "&", "is_thing", "\n", "if", "torch", ".", "nonzero", "(", "thing_mask", ")", ".", "size", "(", "0", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "", "class_id", ",", "_", "=", "torch", ".", "mode", "(", "sem_seg", "[", "thing_mask", "]", ".", "view", "(", "-", "1", ")", ")", "\n", "class_id_tracker", "[", "class_id", ".", "item", "(", ")", "]", "+=", "1", "\n", "new_ins_id", "=", "class_id_tracker", "[", "class_id", ".", "item", "(", ")", "]", "\n", "pan_seg", "[", "thing_mask", "]", "=", "class_id", "*", "label_divisor", "+", "new_ins_id", "\n", "\n", "# Paste stuff to unoccupied area.", "\n", "", "class_ids", "=", "torch", ".", "unique", "(", "sem_seg", ")", "\n", "for", "class_id", "in", "class_ids", ":", "\n", "        ", "if", "class_id", ".", "item", "(", ")", "in", "thing_ids", ":", "\n", "# thing class", "\n", "            ", "continue", "\n", "# Calculate stuff area.", "\n", "", "stuff_mask", "=", "(", "sem_seg", "==", "class_id", ")", "&", "(", "ins_seg", "==", "0", ")", "\n", "if", "stuff_mask", ".", "sum", "(", ")", ".", "item", "(", ")", ">=", "stuff_area", ":", "\n", "            ", "pan_seg", "[", "stuff_mask", "]", "=", "class_id", "*", "label_divisor", "\n", "\n", "", "", "return", "pan_seg", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.post_processing.get_panoptic_segmentation": [[165, 235], ["post_processing.get_instance_segmentation", "post_processing.merge_semantic_and_instance", "ValueError", "center_heatmap.dim", "ValueError", "offsets.dim", "ValueError", "torch.zeros_like", "torch.zeros_like", "list", "sem_seg.dim", "sem_seg.size", "ValueError", "sem_seg.size", "center_heatmap.dim", "offsets.dim", "foreground_mask.dim", "foreground_mask.size", "sem_seg.size"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.post_processing.get_instance_segmentation", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.post_processing.merge_semantic_and_instance"], ["", "def", "get_panoptic_segmentation", "(", "\n", "sem_seg", ",", "\n", "center_heatmap", ",", "\n", "offsets", ",", "\n", "thing_ids", ",", "\n", "label_divisor", ",", "\n", "stuff_area", ",", "\n", "void_label", ",", "\n", "threshold", "=", "0.1", ",", "\n", "nms_kernel", "=", "7", ",", "\n", "top_k", "=", "200", ",", "\n", "foreground_mask", "=", "None", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Post-processing for panoptic segmentation.\n    Args:\n        sem_seg: A Tensor of shape [1, H, W] of predicted semantic label.\n        center_heatmap: A Tensor of shape [1, H, W] of raw center heatmap output.\n        offsets: A Tensor of shape [2, H, W] of raw offset output. The order of\n            second dim is (offset_y, offset_x).\n        thing_ids: A set of ids from contiguous category ids belonging\n            to thing categories.\n        label_divisor: An integer, used to convert panoptic id =\n            semantic id * label_divisor + instance_id.\n        stuff_area: An integer, remove stuff whose area is less tan stuff_area.\n        void_label: An integer, indicates the region has no confident prediction.\n        threshold: A float, threshold applied to center heatmap score.\n        nms_kernel: An integer, NMS max pooling kernel size.\n        top_k: An integer, top k centers to keep.\n        foreground_mask: Optional, A Tensor of shape [1, H, W] of predicted\n            binary foreground mask. If not provided, it will be generated from\n            sem_seg.\n    Returns:\n        A Tensor of shape [1, H, W], int64.\n    \"\"\"", "\n", "if", "sem_seg", ".", "dim", "(", ")", "!=", "3", "and", "sem_seg", ".", "size", "(", "0", ")", "!=", "1", ":", "\n", "        ", "raise", "ValueError", "(", "\"Semantic prediction with un-supported shape: {}.\"", ".", "format", "(", "sem_seg", ".", "size", "(", ")", ")", ")", "\n", "", "if", "center_heatmap", ".", "dim", "(", ")", "!=", "3", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"Center prediction with un-supported dimension: {}.\"", ".", "format", "(", "center_heatmap", ".", "dim", "(", ")", ")", "\n", ")", "\n", "", "if", "offsets", ".", "dim", "(", ")", "!=", "3", ":", "\n", "        ", "raise", "ValueError", "(", "\"Offset prediction with un-supported dimension: {}.\"", ".", "format", "(", "offsets", ".", "dim", "(", ")", ")", ")", "\n", "", "if", "foreground_mask", "is", "not", "None", ":", "\n", "        ", "if", "foreground_mask", ".", "dim", "(", ")", "!=", "3", "and", "foreground_mask", ".", "size", "(", "0", ")", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Foreground prediction with un-supported shape: {}.\"", ".", "format", "(", "sem_seg", ".", "size", "(", ")", ")", "\n", ")", "\n", "", "thing_seg", "=", "foreground_mask", "\n", "", "else", ":", "\n", "# inference from semantic segmentation", "\n", "        ", "thing_seg", "=", "torch", ".", "zeros_like", "(", "sem_seg", ")", "\n", "for", "thing_class", "in", "list", "(", "thing_ids", ")", ":", "\n", "            ", "thing_seg", "[", "sem_seg", "==", "thing_class", "]", "=", "1", "\n", "\n", "", "", "instance", ",", "center", "=", "get_instance_segmentation", "(", "\n", "sem_seg", ",", "\n", "center_heatmap", ",", "\n", "offsets", ",", "\n", "thing_seg", ",", "\n", "thing_ids", ",", "\n", "threshold", "=", "threshold", ",", "\n", "nms_kernel", "=", "nms_kernel", ",", "\n", "top_k", "=", "top_k", ",", "\n", ")", "\n", "panoptic", "=", "merge_semantic_and_instance", "(", "\n", "sem_seg", ",", "instance", ",", "thing_seg", ",", "label_divisor", ",", "thing_ids", ",", "stuff_area", ",", "void_label", "\n", ")", "\n", "\n", "return", "panoptic", ",", "center", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.dataset_mapper.PanopticDeeplabDatasetMapper.__init__": [[28, 53], ["detectron2.data.transforms.AugmentationList", "logging.getLogger", "logging.getLogger.info", "str"], "methods", ["None"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "*", ",", "\n", "augmentations", ":", "List", "[", "Union", "[", "T", ".", "Augmentation", ",", "T", ".", "Transform", "]", "]", ",", "\n", "image_format", ":", "str", ",", "\n", "panoptic_target_generator", ":", "Callable", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            augmentations: a list of augmentations or deterministic transforms to apply\n            image_format: an image format supported by :func:`detection_utils.read_image`.\n            panoptic_target_generator: a callable that takes \"panoptic_seg\" and\n                \"segments_info\" to generate training targets for the model.\n        \"\"\"", "\n", "# fmt: off", "\n", "self", ".", "augmentations", "=", "T", ".", "AugmentationList", "(", "augmentations", ")", "\n", "self", ".", "image_format", "=", "image_format", "\n", "# fmt: on", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Augmentations used in training: \"", "+", "str", "(", "augmentations", ")", ")", "\n", "\n", "self", ".", "panoptic_target_generator", "=", "panoptic_target_generator", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.dataset_mapper.PanopticDeeplabDatasetMapper.from_config": [[54, 86], ["augs.append", "detectron2.data.MetadataCatalog.get", "target_generator.PanopticDeepLabTargetGenerator", "detectron2.data.transforms.ResizeShortestEdge", "augs.append", "detectron2.data.transforms.RandomFlip", "detectron2.data.transforms.RandomCrop", "list", "detectron2.data.MetadataCatalog.get.thing_dataset_id_to_contiguous_id.values"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "augs", "=", "[", "\n", "T", ".", "ResizeShortestEdge", "(", "\n", "cfg", ".", "INPUT", ".", "MIN_SIZE_TRAIN", ",", "\n", "cfg", ".", "INPUT", ".", "MAX_SIZE_TRAIN", ",", "\n", "cfg", ".", "INPUT", ".", "MIN_SIZE_TRAIN_SAMPLING", ",", "\n", ")", "\n", "]", "\n", "if", "cfg", ".", "INPUT", ".", "CROP", ".", "ENABLED", ":", "\n", "            ", "augs", ".", "append", "(", "T", ".", "RandomCrop", "(", "cfg", ".", "INPUT", ".", "CROP", ".", "TYPE", ",", "cfg", ".", "INPUT", ".", "CROP", ".", "SIZE", ")", ")", "\n", "", "augs", ".", "append", "(", "T", ".", "RandomFlip", "(", ")", ")", "\n", "\n", "# Assume always applies to the training set.", "\n", "dataset_names", "=", "cfg", ".", "DATASETS", ".", "TRAIN", "\n", "meta", "=", "MetadataCatalog", ".", "get", "(", "dataset_names", "[", "0", "]", ")", "\n", "panoptic_target_generator", "=", "PanopticDeepLabTargetGenerator", "(", "\n", "ignore_label", "=", "meta", ".", "ignore_label", ",", "\n", "thing_ids", "=", "list", "(", "meta", ".", "thing_dataset_id_to_contiguous_id", ".", "values", "(", ")", ")", ",", "\n", "sigma", "=", "cfg", ".", "INPUT", ".", "GAUSSIAN_SIGMA", ",", "\n", "ignore_stuff_in_offset", "=", "cfg", ".", "INPUT", ".", "IGNORE_STUFF_IN_OFFSET", ",", "\n", "small_instance_area", "=", "cfg", ".", "INPUT", ".", "SMALL_INSTANCE_AREA", ",", "\n", "small_instance_weight", "=", "cfg", ".", "INPUT", ".", "SMALL_INSTANCE_WEIGHT", ",", "\n", "ignore_crowd_in_semantic", "=", "cfg", ".", "INPUT", ".", "IGNORE_CROWD_IN_SEMANTIC", ",", "\n", ")", "\n", "\n", "ret", "=", "{", "\n", "\"augmentations\"", ":", "augs", ",", "\n", "\"image_format\"", ":", "cfg", ".", "INPUT", ".", "FORMAT", ",", "\n", "\"panoptic_target_generator\"", ":", "panoptic_target_generator", ",", "\n", "}", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.panoptic_deeplab.dataset_mapper.PanopticDeeplabDatasetMapper.__call__": [[87, 117], ["copy.deepcopy", "detectron2.data.detection_utils.read_image", "detectron2.data.detection_utils.check_image_size", "detectron2.data.detection_utils.read_image", "detectron2.data.transforms.AugInput", "dataset_mapper.PanopticDeeplabDatasetMapper.augmentations", "torch.as_tensor", "dataset_mapper.PanopticDeeplabDatasetMapper.panoptic_target_generator", "copy.deepcopy.update", "copy.deepcopy.pop", "numpy.ascontiguousarray", "panopticapi.utils.rgb2id", "detectron2.data.detection_utils.read_image.transpose"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update"], ["", "def", "__call__", "(", "self", ",", "dataset_dict", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_dict (dict): Metadata of one image, in Detectron2 Dataset format.\n\n        Returns:\n            dict: a format that builtin models in detectron2 accept\n        \"\"\"", "\n", "dataset_dict", "=", "copy", ".", "deepcopy", "(", "dataset_dict", ")", "# it will be modified by code below", "\n", "# Load image.", "\n", "image", "=", "utils", ".", "read_image", "(", "dataset_dict", "[", "\"file_name\"", "]", ",", "format", "=", "self", ".", "image_format", ")", "\n", "utils", ".", "check_image_size", "(", "dataset_dict", ",", "image", ")", "\n", "# Panoptic label is encoded in RGB image.", "\n", "pan_seg_gt", "=", "utils", ".", "read_image", "(", "dataset_dict", ".", "pop", "(", "\"pan_seg_file_name\"", ")", ",", "\"RGB\"", ")", "\n", "\n", "# Reuses semantic transform for panoptic labels.", "\n", "aug_input", "=", "T", ".", "AugInput", "(", "image", ",", "sem_seg", "=", "pan_seg_gt", ")", "\n", "_", "=", "self", ".", "augmentations", "(", "aug_input", ")", "\n", "image", ",", "pan_seg_gt", "=", "aug_input", ".", "image", ",", "aug_input", ".", "sem_seg", "\n", "\n", "# Pytorch's dataloader is efficient on torch.Tensor due to shared-memory,", "\n", "# but not efficient on large generic data structures due to the use of pickle & mp.Queue.", "\n", "# Therefore it's important to use torch.Tensor.", "\n", "dataset_dict", "[", "\"image\"", "]", "=", "torch", ".", "as_tensor", "(", "np", ".", "ascontiguousarray", "(", "image", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", ")", "\n", "\n", "# Generates training targets for Panoptic-DeepLab.", "\n", "targets", "=", "self", ".", "panoptic_target_generator", "(", "rgb2id", "(", "pan_seg_gt", ")", ",", "dataset_dict", "[", "\"segments_info\"", "]", ")", "\n", "dataset_dict", ".", "update", "(", "targets", ")", "\n", "\n", "return", "dataset_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.TensorMask.setup.get_extensions": [[11, 59], ["os.path.dirname", "os.path.join", "os.path.join", "glob.glob", "os.path.abspath", "os.path.join", "glob.glob", "glob.glob", "os.environ.get", "os.path.join", "extension", "os.path.join", "os.path.join", "torch.cuda.is_available", "os.getenv", "extra_compile_args[].append"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "return", "content", "\n", "\n", "\n", "", "MAJOR", "=", "0", "\n", "MINOR", "=", "3", "\n", "PATCH", "=", "0", "\n", "SUFFIX", "=", "''", "\n", "if", "PATCH", "!=", "''", ":", "\n", "    ", "SHORT_VERSION", "=", "'{}.{}.{}{}'", ".", "format", "(", "MAJOR", ",", "MINOR", ",", "PATCH", ",", "SUFFIX", ")", "\n", "", "else", ":", "\n", "    ", "SHORT_VERSION", "=", "'{}.{}{}'", ".", "format", "(", "MAJOR", ",", "MINOR", ",", "SUFFIX", ")", "\n", "\n", "", "version_file", "=", "'openselfsup/version.py'", "\n", "\n", "\n", "def", "get_git_hash", "(", ")", ":", "\n", "\n", "    ", "def", "_minimal_ext_cmd", "(", "cmd", ")", ":", "\n", "# construct minimal environment", "\n", "        ", "env", "=", "{", "}", "\n", "for", "k", "in", "[", "'SYSTEMROOT'", ",", "'PATH'", ",", "'HOME'", "]", ":", "\n", "            ", "v", "=", "os", ".", "environ", ".", "get", "(", "k", ")", "\n", "if", "v", "is", "not", "None", ":", "\n", "                ", "env", "[", "k", "]", "=", "v", "\n", "# LANGUAGE is used on win32", "\n", "", "", "env", "[", "'LANGUAGE'", "]", "=", "'C'", "\n", "env", "[", "'LANG'", "]", "=", "'C'", "\n", "env", "[", "'LC_ALL'", "]", "=", "'C'", "\n", "out", "=", "subprocess", ".", "Popen", "(", "\n", "cmd", ",", "stdout", "=", "subprocess", ".", "PIPE", ",", "env", "=", "env", ")", ".", "communicate", "(", ")", "[", "0", "]", "\n", "return", "out", "\n", "\n", "", "try", ":", "\n", "        ", "out", "=", "_minimal_ext_cmd", "(", "[", "'git'", ",", "'rev-parse'", ",", "'HEAD'", "]", ")", "\n", "sha", "=", "out", ".", "strip", "(", ")", ".", "decode", "(", "'ascii'", ")", "\n", "", "except", "OSError", ":", "\n", "        ", "sha", "=", "'unknown'", "\n", "\n", "", "return", "sha", "\n", "\n", "\n", "", "def", "get_hash", "(", ")", ":", "\n", "    ", "if", "os", ".", "path", ".", "exists", "(", "'.git'", ")", ":", "\n", "        ", "sha", "=", "get_git_hash", "(", ")", "[", ":", "7", "]", "\n", "", "elif", "os", ".", "path", ".", "exists", "(", "version_file", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "from", "openselfsup", ".", "version", "import", "__version__", "\n", "sha", "=", "__version__", ".", "split", "(", "'+'", ")", "[", "-", "1", "]", "\n", "", "except", "ImportError", ":", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.TensorMask.train_net.Trainer.build_evaluator": [[22, 27], ["detectron2.evaluation.COCOEvaluator", "os.path.join"], "methods", ["None"], ["class", "Res5ROIHeadsExtraNorm", "(", "Res5ROIHeads", ")", ":", "\n", "    ", "\"\"\"\n    As described in the MOCO paper, there is an extra BN layer\n    following the res5 stage.\n    \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.TensorMask.train_net.setup": [[29, 40], ["detectron2.config.get_cfg", "tensormask.add_tensormask_config", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.engine.default_setup"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.config.add_tensormask_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.default_setup"], ["        ", "seq", ",", "out_channels", "=", "super", "(", ")", ".", "_build_res5_block", "(", "cfg", ")", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "NORM", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", "\n", "seq", ".", "add_module", "(", "\"norm\"", ",", "norm", ")", "\n", "return", "seq", ",", "out_channels", "\n", "\n", "\n", "", "", "class", "Trainer", "(", "DefaultTrainer", ")", ":", "\n", "\n", "    ", "@", "classmethod", "\n", "def", "build_evaluator", "(", "cls", ",", "cfg", ",", "dataset_name", ",", "output_folder", "=", "None", ")", ":", "\n", "        ", "if", "output_folder", "is", "None", ":", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.TensorMask.train_net.main": [[42, 58], ["train_net.setup", "train_net.Trainer", "Trainer.resume_or_load", "Trainer.train", "Trainer.build_model", "detectron2.checkpoint.DetectionCheckpointer().resume_or_load", "Trainer.test", "detectron2.is_main_process", "detectron2.evaluation.verify_results", "detectron2.checkpoint.DetectionCheckpointer"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.setup", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_packaging.TestCollectEnv.test", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.testing.verify_results"], ["", "if", "\"voc\"", "in", "dataset_name", ":", "\n", "            ", "return", "PascalVOCDetectionEvaluator", "(", "dataset_name", ")", "\n", "", "else", ":", "\n", "            ", "return", "COCOEvaluator", "(", "dataset_name", ",", "cfg", ",", "True", ",", "output_folder", ")", "\n", "\n", "\n", "", "", "", "def", "setup", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "default_setup", "(", "cfg", ",", "args", ")", "\n", "return", "cfg", "\n", "\n", "\n", "", "def", "main", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "setup", "(", "args", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.config.add_tensormask_config": [[7, 51], ["detectron2.config.CfgNode"], "function", ["None"], ["from", "fvcore", ".", "common", ".", "config", "import", "CfgNode", "as", "_CfgNode", "\n", "from", "fvcore", ".", "common", ".", "file_io", "import", "PathManager", "\n", "\n", "\n", "class", "CfgNode", "(", "_CfgNode", ")", ":", "\n", "    ", "\"\"\"\n    The same as `fvcore.common.config.CfgNode`, but different in:\n\n    1. Use unsafe yaml loading by default.\n       Note that this may lead to arbitrary code execution: you must not\n       load a config file from untrusted sources before manually inspecting\n       the content of the file.\n    2. Support config versioning.\n       When attempting to merge an old config, it will convert the old config automatically.\n    \"\"\"", "\n", "\n", "# Note that the default value of allow_unsafe is changed to True", "\n", "def", "merge_from_file", "(", "self", ",", "cfg_filename", ":", "str", ",", "allow_unsafe", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "        ", "assert", "PathManager", ".", "isfile", "(", "cfg_filename", ")", ",", "f\"Config file '{cfg_filename}' does not exist!\"", "\n", "loaded_cfg", "=", "_CfgNode", ".", "load_yaml_with_base", "(", "cfg_filename", ",", "allow_unsafe", "=", "allow_unsafe", ")", "\n", "loaded_cfg", "=", "type", "(", "self", ")", "(", "loaded_cfg", ")", "\n", "\n", "# defaults.py needs to import CfgNode", "\n", "from", ".", "defaults", "import", "_C", "\n", "\n", "latest_ver", "=", "_C", ".", "VERSION", "\n", "assert", "(", "\n", "latest_ver", "==", "self", ".", "VERSION", "\n", ")", ",", "\"CfgNode.merge_from_file is only allowed on a config object of latest version!\"", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "loaded_ver", "=", "loaded_cfg", ".", "get", "(", "\"VERSION\"", ",", "None", ")", "\n", "if", "loaded_ver", "is", "None", ":", "\n", "            ", "from", ".", "compat", "import", "guess_version", "\n", "\n", "loaded_ver", "=", "guess_version", "(", "loaded_cfg", ",", "cfg_filename", ")", "\n", "", "assert", "loaded_ver", "<=", "self", ".", "VERSION", ",", "\"Cannot merge a v{} config into a v{} config.\"", ".", "format", "(", "\n", "loaded_ver", ",", "self", ".", "VERSION", "\n", ")", "\n", "\n", "if", "loaded_ver", "==", "self", ".", "VERSION", ":", "\n", "            ", "self", ".", "merge_from_other_cfg", "(", "loaded_cfg", ")", "\n", "", "else", ":", "\n", "# compat.py needs to import CfgNode", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMaskAnchorGenerator.grid_anchors_with_unit_lengths_and_indexes": [[235, 269], ["enumerate", "zip", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "anchors.append", "unit_lengths.append", "torch.full", "torch.full", "torch.full", "torch.full", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "indexes.append", "torch.full", "torch.full", "torch.full", "torch.full", "torch.stack().view", "torch.stack().view", "torch.stack().view", "torch.stack().view", "base_anchors.view", "torch.stack", "torch.stack", "torch.stack", "torch.stack"], "methods", ["None"], ["def", "grid_anchors_with_unit_lengths_and_indexes", "(", "self", ",", "grid_sizes", ")", ":", "\n", "        ", "anchors", "=", "[", "]", "\n", "unit_lengths", "=", "[", "]", "\n", "indexes", "=", "[", "]", "\n", "for", "lvl", ",", "(", "size", ",", "stride", ",", "base_anchors", ")", "in", "enumerate", "(", "\n", "zip", "(", "grid_sizes", ",", "self", ".", "strides", ",", "self", ".", "cell_anchors", ")", "\n", ")", ":", "\n", "            ", "grid_height", ",", "grid_width", "=", "size", "\n", "device", "=", "base_anchors", ".", "device", "\n", "shifts_x", "=", "torch", ".", "arange", "(", "\n", "0", ",", "grid_width", "*", "stride", ",", "step", "=", "stride", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", "\n", ")", "\n", "shifts_y", "=", "torch", ".", "arange", "(", "\n", "0", ",", "grid_height", "*", "stride", ",", "step", "=", "stride", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", "\n", ")", "\n", "shift_y", ",", "shift_x", "=", "torch", ".", "meshgrid", "(", "shifts_y", ",", "shifts_x", ")", "\n", "shifts", "=", "torch", ".", "stack", "(", "(", "shift_x", ",", "shift_y", ",", "shift_x", ",", "shift_y", ")", ",", "dim", "=", "2", ")", "\n", "# Stack anchors in shapes of (HWA, 4)", "\n", "cur_anchor", "=", "(", "shifts", "[", ":", ",", ":", ",", "None", ",", ":", "]", "+", "base_anchors", ".", "view", "(", "1", ",", "1", ",", "-", "1", ",", "4", ")", ")", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "anchors", ".", "append", "(", "cur_anchor", ")", "\n", "unit_lengths", ".", "append", "(", "\n", "torch", ".", "full", "(", "(", "cur_anchor", ".", "shape", "[", "0", "]", ",", ")", ",", "stride", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", ")", "\n", "# create mask indexes using mesh grid", "\n", "shifts_l", "=", "torch", ".", "full", "(", "(", "1", ",", ")", ",", "lvl", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "device", ")", "\n", "shifts_i", "=", "torch", ".", "zeros", "(", "(", "1", ",", ")", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "device", ")", "\n", "shifts_h", "=", "torch", ".", "arange", "(", "0", ",", "grid_height", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "device", ")", "\n", "shifts_w", "=", "torch", ".", "arange", "(", "0", ",", "grid_width", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "device", ")", "\n", "shifts_a", "=", "torch", ".", "arange", "(", "0", ",", "base_anchors", ".", "shape", "[", "0", "]", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "device", ")", "\n", "grids", "=", "torch", ".", "meshgrid", "(", "shifts_l", ",", "shifts_i", ",", "shifts_h", ",", "shifts_w", ",", "shifts_a", ")", "\n", "\n", "indexes", ".", "append", "(", "torch", ".", "stack", "(", "grids", ",", "dim", "=", "5", ")", ".", "view", "(", "-", "1", ",", "5", ")", ")", "\n", "\n", "", "return", "anchors", ",", "unit_lengths", ",", "indexes", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMaskAnchorGenerator.forward": [[270, 298], ["len", "arch.TensorMaskAnchorGenerator.grid_anchors_with_unit_lengths_and_indexes", "detectron2.structures.Boxes", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "range", "range", "range"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMaskAnchorGenerator.grid_anchors_with_unit_lengths_and_indexes"], ["", "def", "forward", "(", "self", ",", "features", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            list[list[Boxes]]: a list of #image elements. Each is a list of #feature level Boxes.\n                The Boxes contains anchors of this image on the specific feature level.\n            list[list[Tensor]]: a list of #image elements. Each is a list of #feature level tensors.\n                The tensor contains strides, or unit lengths for the anchors.\n            list[list[Tensor]]: a list of #image elements. Each is a list of #feature level tensors.\n                The Tensor contains indexes for the anchors, with the last dimension meaning\n                (L, N, H, W, A), where L is level, I is image (not set yet), H is height,\n                W is width, and A is anchor.\n        \"\"\"", "\n", "num_images", "=", "len", "(", "features", "[", "0", "]", ")", "\n", "grid_sizes", "=", "[", "feature_map", ".", "shape", "[", "-", "2", ":", "]", "for", "feature_map", "in", "features", "]", "\n", "anchors_list", ",", "lengths_list", ",", "indexes_list", "=", "self", ".", "grid_anchors_with_unit_lengths_and_indexes", "(", "\n", "grid_sizes", "\n", ")", "\n", "\n", "# Convert anchors from Tensor to Boxes", "\n", "anchors_per_im", "=", "[", "Boxes", "(", "x", ")", "for", "x", "in", "anchors_list", "]", "\n", "\n", "# TODO it can be simplified to not return duplicated information for", "\n", "# each image, just like detectron2's own AnchorGenerator", "\n", "anchors", "=", "[", "copy", ".", "deepcopy", "(", "anchors_per_im", ")", "for", "_", "in", "range", "(", "num_images", ")", "]", "\n", "unit_lengths", "=", "[", "copy", ".", "deepcopy", "(", "lengths_list", ")", "for", "_", "in", "range", "(", "num_images", ")", "]", "\n", "indexes", "=", "[", "copy", ".", "deepcopy", "(", "indexes_list", ")", "for", "_", "in", "range", "(", "num_images", ")", "]", "\n", "\n", "return", "anchors", ",", "unit_lengths", ",", "indexes", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.__init__": [[308, 353], ["torch.nn.Module.__init__", "len", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "detectron2.modeling.backbone.build_backbone", "arch.TensorMask.backbone.output_shape", "arch.TensorMaskAnchorGenerator", "arch.TensorMaskHead", "detectron2.modeling.box_regression.Box2BoxTransform", "arch.TensorMask.register_buffer", "arch.TensorMask.register_buffer", "min", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.backbone.Backbone.output_shape"], ["def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "self", ".", "num_classes", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "NUM_CLASSES", "\n", "self", ".", "in_features", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "IN_FEATURES", "\n", "self", ".", "anchor_sizes", "=", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "SIZES", "\n", "self", ".", "num_levels", "=", "len", "(", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "SIZES", ")", "\n", "# Loss parameters:", "\n", "self", ".", "focal_loss_alpha", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "FOCAL_LOSS_ALPHA", "\n", "self", ".", "focal_loss_gamma", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "FOCAL_LOSS_GAMMA", "\n", "# Inference parameters:", "\n", "self", ".", "score_threshold", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "SCORE_THRESH_TEST", "\n", "self", ".", "topk_candidates", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "TOPK_CANDIDATES_TEST", "\n", "self", ".", "nms_threshold", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "NMS_THRESH_TEST", "\n", "self", ".", "detections_im", "=", "cfg", ".", "TEST", ".", "DETECTIONS_PER_IMAGE", "\n", "# Mask parameters:", "\n", "self", ".", "mask_on", "=", "cfg", ".", "MODEL", ".", "MASK_ON", "\n", "self", ".", "mask_loss_weight", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "MASK_LOSS_WEIGHT", "\n", "self", ".", "mask_pos_weight", "=", "torch", ".", "tensor", "(", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "POSITIVE_WEIGHT", ",", "\n", "dtype", "=", "torch", ".", "float32", ")", "\n", "self", ".", "bipyramid_on", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "BIPYRAMID_ON", "\n", "# fmt: on", "\n", "\n", "# build the backbone", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "\n", "backbone_shape", "=", "self", ".", "backbone", ".", "output_shape", "(", ")", "\n", "feature_shapes", "=", "[", "backbone_shape", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", "\n", "feature_strides", "=", "[", "x", ".", "stride", "for", "x", "in", "feature_shapes", "]", "\n", "# build anchors", "\n", "self", ".", "anchor_generator", "=", "TensorMaskAnchorGenerator", "(", "cfg", ",", "feature_shapes", ")", "\n", "self", ".", "num_anchors", "=", "self", ".", "anchor_generator", ".", "num_cell_anchors", "[", "0", "]", "\n", "anchors_min_level", "=", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "SIZES", "[", "0", "]", "\n", "self", ".", "mask_sizes", "=", "[", "size", "//", "feature_strides", "[", "0", "]", "for", "size", "in", "anchors_min_level", "]", "\n", "self", ".", "min_anchor_size", "=", "min", "(", "anchors_min_level", ")", "-", "feature_strides", "[", "0", "]", "\n", "\n", "# head of the TensorMask", "\n", "self", ".", "head", "=", "TensorMaskHead", "(", "\n", "cfg", ",", "self", ".", "num_levels", ",", "self", ".", "num_anchors", ",", "self", ".", "mask_sizes", ",", "feature_shapes", "\n", ")", "\n", "# box transform", "\n", "self", ".", "box2box_transform", "=", "Box2BoxTransform", "(", "weights", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "BBOX_REG_WEIGHTS", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_mean\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_MEAN", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_std\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_STD", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device": [[354, 357], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "pixel_mean", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.forward": [[358, 415], ["arch.TensorMask.preprocess_image", "arch.TensorMask.backbone", "arch.TensorMask.head", "arch.TensorMask.anchor_generator", "arch.TensorMask.get_ground_truth", "arch.TensorMask.losses", "arch.TensorMask.inference", "zip", "x[].to", "input_im.get", "input_im.get", "arch._postprocess", "processed_results.append"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.preprocess_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.get_ground_truth", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3Head.losses", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.inference", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch._postprocess"], ["", "def", "forward", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            batched_inputs: a list, batched outputs of :class:`DetectionTransform` .\n                Each item in the list contains the inputs for one image.\n            For now, each item in the list is a dict that contains:\n                image: Tensor, image in (C, H, W) format.\n                instances: Instances\n                Other information that's included in the original dicts, such as:\n                    \"height\", \"width\" (int): the output resolution of the model, used in inference.\n                        See :meth:`postprocess` for details.\n         Returns:\n            losses (dict[str: Tensor]): mapping from a named loss to a tensor\n                storing the loss. Used during training only.\n        \"\"\"", "\n", "images", "=", "self", ".", "preprocess_image", "(", "batched_inputs", ")", "\n", "if", "\"instances\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "gt_instances", "=", "[", "x", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "", "else", ":", "\n", "            ", "gt_instances", "=", "None", "\n", "\n", "", "features", "=", "self", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", "\n", "# apply the TensorMask head", "\n", "pred_logits", ",", "pred_deltas", ",", "pred_masks", "=", "self", ".", "head", "(", "features", ")", "\n", "# generate anchors based on features, is it image specific?", "\n", "anchors", ",", "unit_lengths", ",", "indexes", "=", "self", ".", "anchor_generator", "(", "features", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "# get ground truths for class labels and box targets, it will label each anchor", "\n", "            ", "gt_class_info", ",", "gt_delta_info", ",", "gt_mask_info", ",", "num_fg", "=", "self", ".", "get_ground_truth", "(", "\n", "anchors", ",", "unit_lengths", ",", "indexes", ",", "gt_instances", "\n", ")", "\n", "# compute the loss", "\n", "return", "self", ".", "losses", "(", "\n", "gt_class_info", ",", "\n", "gt_delta_info", ",", "\n", "gt_mask_info", ",", "\n", "num_fg", ",", "\n", "pred_logits", ",", "\n", "pred_deltas", ",", "\n", "pred_masks", ",", "\n", ")", "\n", "", "else", ":", "\n", "# do inference to get the output", "\n", "            ", "results", "=", "self", ".", "inference", "(", "pred_logits", ",", "pred_deltas", ",", "pred_masks", ",", "anchors", ",", "indexes", ",", "images", ")", "\n", "processed_results", "=", "[", "]", "\n", "for", "results_im", ",", "input_im", ",", "image_size", "in", "zip", "(", "\n", "results", ",", "batched_inputs", ",", "images", ".", "image_sizes", "\n", ")", ":", "\n", "                ", "height", "=", "input_im", ".", "get", "(", "\"height\"", ",", "image_size", "[", "0", "]", ")", "\n", "width", "=", "input_im", ".", "get", "(", "\"width\"", ",", "image_size", "[", "1", "]", ")", "\n", "# this is to do post-processing with the image size", "\n", "result_box", ",", "result_mask", "=", "results_im", "\n", "r", "=", "_postprocess", "(", "result_box", ",", "result_mask", ",", "height", ",", "width", ")", "\n", "processed_results", ".", "append", "(", "{", "\"instances\"", ":", "r", "}", ")", "\n", "", "return", "processed_results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.losses": [[416, 501], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "arch.permute_all_cls_and_box_to_N_HWA_K_and_concat", "max", "fvcore.nn.sigmoid_focal_loss_star_jit", "range", "pred_deltas.sum", "fvcore.nn.smooth_l1_loss", "range", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.binary_cross_entropy_with_logits", "torch.binary_cross_entropy_with_logits", "cur_pred_masks.view", "[].to"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.permute_all_cls_and_box_to_N_HWA_K_and_concat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "", "def", "losses", "(", "\n", "self", ",", "\n", "gt_class_info", ",", "\n", "gt_delta_info", ",", "\n", "gt_mask_info", ",", "\n", "num_fg", ",", "\n", "pred_logits", ",", "\n", "pred_deltas", ",", "\n", "pred_masks", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            For `gt_class_info`, `gt_delta_info`, `gt_mask_info` and `num_fg` parameters, see\n                :meth:`TensorMask.get_ground_truth`.\n            For `pred_logits`, `pred_deltas` and `pred_masks`, see\n                :meth:`TensorMaskHead.forward`.\n\n        Returns:\n            losses (dict[str: Tensor]): mapping from a named loss to a scalar tensor\n                storing the loss. Used during training only. The potential dict keys are:\n                \"loss_cls\", \"loss_box_reg\" and \"loss_mask\".\n        \"\"\"", "\n", "gt_classes_target", ",", "gt_valid_inds", "=", "gt_class_info", "\n", "gt_deltas", ",", "gt_fg_inds", "=", "gt_delta_info", "\n", "gt_masks", ",", "gt_mask_inds", "=", "gt_mask_info", "\n", "loss_normalizer", "=", "torch", ".", "tensor", "(", "max", "(", "1", ",", "num_fg", ")", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "# classification and regression", "\n", "pred_logits", ",", "pred_deltas", "=", "permute_all_cls_and_box_to_N_HWA_K_and_concat", "(", "\n", "pred_logits", ",", "pred_deltas", ",", "self", ".", "num_classes", "\n", ")", "\n", "loss_cls", "=", "(", "\n", "sigmoid_focal_loss_star_jit", "(", "\n", "pred_logits", "[", "gt_valid_inds", "]", ",", "\n", "gt_classes_target", "[", "gt_valid_inds", "]", ",", "\n", "alpha", "=", "self", ".", "focal_loss_alpha", ",", "\n", "gamma", "=", "self", ".", "focal_loss_gamma", ",", "\n", "reduction", "=", "\"sum\"", ",", "\n", ")", "\n", "/", "loss_normalizer", "\n", ")", "\n", "\n", "if", "num_fg", "==", "0", ":", "\n", "            ", "loss_box_reg", "=", "pred_deltas", ".", "sum", "(", ")", "*", "0", "\n", "", "else", ":", "\n", "            ", "loss_box_reg", "=", "(", "\n", "smooth_l1_loss", "(", "pred_deltas", "[", "gt_fg_inds", "]", ",", "gt_deltas", ",", "beta", "=", "0.0", ",", "reduction", "=", "\"sum\"", ")", "\n", "/", "loss_normalizer", "\n", ")", "\n", "", "losses", "=", "{", "\"loss_cls\"", ":", "loss_cls", ",", "\"loss_box_reg\"", ":", "loss_box_reg", "}", "\n", "\n", "# mask prediction", "\n", "if", "self", ".", "mask_on", ":", "\n", "            ", "loss_mask", "=", "0", "\n", "for", "lvl", "in", "range", "(", "self", ".", "num_levels", ")", ":", "\n", "                ", "cur_level_factor", "=", "2", "**", "lvl", "if", "self", ".", "bipyramid_on", "else", "1", "\n", "for", "anc", "in", "range", "(", "self", ".", "num_anchors", ")", ":", "\n", "                    ", "cur_gt_mask_inds", "=", "gt_mask_inds", "[", "lvl", "]", "[", "anc", "]", "\n", "if", "cur_gt_mask_inds", "is", "None", ":", "\n", "                        ", "loss_mask", "+=", "pred_masks", "[", "lvl", "]", "[", "anc", "]", "[", "0", ",", "0", ",", "0", ",", "0", "]", "*", "0", "\n", "", "else", ":", "\n", "                        ", "cur_mask_size", "=", "self", ".", "mask_sizes", "[", "anc", "]", "*", "cur_level_factor", "\n", "# TODO maybe there are numerical issues when mask sizes are large", "\n", "cur_size_divider", "=", "torch", ".", "tensor", "(", "\n", "self", ".", "mask_loss_weight", "/", "(", "cur_mask_size", "**", "2", ")", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "self", ".", "device", ",", "\n", ")", "\n", "\n", "cur_pred_masks", "=", "pred_masks", "[", "lvl", "]", "[", "anc", "]", "[", "\n", "cur_gt_mask_inds", "[", ":", ",", "0", "]", ",", "# N", "\n", ":", ",", "# V x U", "\n", "cur_gt_mask_inds", "[", ":", ",", "1", "]", ",", "# H", "\n", "cur_gt_mask_inds", "[", ":", ",", "2", "]", ",", "# W", "\n", "]", "\n", "\n", "loss_mask", "+=", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "cur_pred_masks", ".", "view", "(", "-", "1", ",", "cur_mask_size", ",", "cur_mask_size", ")", ",", "# V, U", "\n", "gt_masks", "[", "lvl", "]", "[", "anc", "]", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", ",", "\n", "reduction", "=", "\"sum\"", ",", "\n", "weight", "=", "cur_size_divider", ",", "\n", "pos_weight", "=", "self", ".", "mask_pos_weight", ",", "\n", ")", "\n", "", "", "", "losses", "[", "\"loss_mask\"", "]", "=", "loss_mask", "/", "loss_normalizer", "\n", "", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.get_ground_truth": [[502, 631], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "enumerate", "detectron2.layers.cat", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "detectron2.structures.Boxes.cat", "detectron2.layers.cat", "detectron2.layers.cat", "zip", "torch.full_like", "torch.full_like", "torch.full_like", "torch.full_like", "detectron2.layers.cat.append", "detectron2.layers.cat", "range", "range", "len", "arch._assignment_rule", "len", "arch.TensorMask.box2box_transform.get_deltas", "gt_deltas.append", "range", "range", "range", "detectron2.layers.cat", "detectron2.layers.cat", "torch.any", "torch.any", "torch.any", "torch.any", "range", "torch.any", "torch.any", "torch.any", "torch.any", "[].append", "[].append", "targets_im[].gt_masks.crop_and_resize"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch._assignment_rule", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.box_regression.Box2BoxTransformRotated.get_deltas", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.PolygonMasks.crop_and_resize"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_ground_truth", "(", "self", ",", "anchors", ",", "unit_lengths", ",", "indexes", ",", "targets", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            anchors (list[list[Boxes]]): a list of N=#image elements. Each is a\n                list of #feature level Boxes. The Boxes contains anchors of\n                this image on the specific feature level.\n            unit_lengths (list[list[Tensor]]): a list of N=#image elements. Each is a\n                list of #feature level Tensor. The tensor contains unit lengths for anchors of\n                this image on the specific feature level.\n            indexes (list[list[Tensor]]): a list of N=#image elements. Each is a\n                list of #feature level Tensor. The tensor contains the 5D index of\n                each anchor, the second dimension means (L, N, H, W, A), where L\n                is level, I is image, H is height, W is width, and A is anchor.\n            targets (list[Instances]): a list of N `Instances`s. The i-th\n                `Instances` contains the ground-truth per-instance annotations\n                for the i-th input image.  Specify `targets` during training only.\n\n        Returns:\n            gt_class_info (Tensor, Tensor): A pair of two tensors for classification.\n                The first one is an integer tensor of shape (R, #classes) storing ground-truth\n                labels for each anchor. R is the total number of anchors in the batch.\n                The second one is an integer tensor of shape (R,), to indicate which\n                anchors are valid for loss computation, which anchors are not.\n            gt_delta_info (Tensor, Tensor): A pair of two tensors for boxes.\n                The first one, of shape (F, 4). F=#foreground anchors.\n                The last dimension represents ground-truth box2box transform\n                targets (dx, dy, dw, dh) that map each anchor to its matched ground-truth box.\n                Only foreground anchors have values in this tensor. Could be `None` if F=0.\n                The second one, of shape (R,), is an integer tensor indicating which anchors\n                are foreground ones used for box regression. Could be `None` if F=0.\n            gt_mask_info (list[list[Tensor]], list[list[Tensor]]): A pair of two lists for masks.\n                The first one is a list of P=#feature level elements. Each is a\n                list of A=#anchor tensors. Each tensor contains the ground truth\n                masks of the same size and for the same feature level. Could be `None`.\n                The second one is a list of P=#feature level elements. Each is a\n                list of A=#anchor tensors. Each tensor contains the location of the ground truth\n                masks of the same size and for the same feature level. The second dimension means\n                (N, H, W), where N is image, H is height, and W is width. Could be `None`.\n            num_fg (int): F=#foreground anchors, used later for loss normalization.\n        \"\"\"", "\n", "gt_classes", "=", "[", "]", "\n", "gt_deltas", "=", "[", "]", "\n", "gt_masks", "=", "[", "[", "[", "]", "for", "_", "in", "range", "(", "self", ".", "num_anchors", ")", "]", "for", "_", "in", "range", "(", "self", ".", "num_levels", ")", "]", "\n", "gt_mask_inds", "=", "[", "[", "[", "]", "for", "_", "in", "range", "(", "self", ".", "num_anchors", ")", "]", "for", "_", "in", "range", "(", "self", ".", "num_levels", ")", "]", "\n", "\n", "anchors", "=", "[", "Boxes", ".", "cat", "(", "anchors_i", ")", "for", "anchors_i", "in", "anchors", "]", "\n", "unit_lengths", "=", "[", "cat", "(", "unit_lengths_i", ")", "for", "unit_lengths_i", "in", "unit_lengths", "]", "\n", "indexes", "=", "[", "cat", "(", "indexes_i", ")", "for", "indexes_i", "in", "indexes", "]", "\n", "\n", "num_fg", "=", "0", "\n", "for", "i", ",", "(", "anchors_im", ",", "unit_lengths_im", ",", "indexes_im", ",", "targets_im", ")", "in", "enumerate", "(", "\n", "zip", "(", "anchors", ",", "unit_lengths", ",", "indexes", ",", "targets", ")", "\n", ")", ":", "\n", "# Initialize all", "\n", "            ", "gt_classes_i", "=", "torch", ".", "full_like", "(", "\n", "unit_lengths_im", ",", "self", ".", "num_classes", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "self", ".", "device", "\n", ")", "\n", "# Ground truth classes", "\n", "has_gt", "=", "len", "(", "targets_im", ")", ">", "0", "\n", "if", "has_gt", ":", "\n", "# Compute the pairwise matrix", "\n", "                ", "gt_matched_inds", ",", "anchor_labels", "=", "_assignment_rule", "(", "\n", "targets_im", ".", "gt_boxes", ",", "anchors_im", ",", "unit_lengths_im", ",", "self", ".", "min_anchor_size", "\n", ")", "\n", "# Find the foreground instances", "\n", "fg_inds", "=", "anchor_labels", "==", "1", "\n", "fg_anchors", "=", "anchors_im", "[", "fg_inds", "]", "\n", "num_fg", "+=", "len", "(", "fg_anchors", ")", "\n", "# Find the ground truths for foreground instances", "\n", "gt_fg_matched_inds", "=", "gt_matched_inds", "[", "fg_inds", "]", "\n", "# Assign labels for foreground instances", "\n", "gt_classes_i", "[", "fg_inds", "]", "=", "targets_im", ".", "gt_classes", "[", "gt_fg_matched_inds", "]", "\n", "# Anchors with label -1 are ignored, others are left as negative", "\n", "gt_classes_i", "[", "anchor_labels", "==", "-", "1", "]", "=", "-", "1", "\n", "\n", "# Boxes", "\n", "# Ground truth box regression, only for foregrounds", "\n", "matched_gt_boxes", "=", "targets_im", "[", "gt_fg_matched_inds", "]", ".", "gt_boxes", "\n", "# Compute box regression offsets for foregrounds only", "\n", "gt_deltas_i", "=", "self", ".", "box2box_transform", ".", "get_deltas", "(", "\n", "fg_anchors", ".", "tensor", ",", "matched_gt_boxes", ".", "tensor", "\n", ")", "\n", "gt_deltas", ".", "append", "(", "gt_deltas_i", ")", "\n", "\n", "# Masks", "\n", "if", "self", ".", "mask_on", ":", "\n", "# Compute masks for each level and each anchor", "\n", "                    ", "matched_indexes", "=", "indexes_im", "[", "fg_inds", ",", ":", "]", "\n", "for", "lvl", "in", "range", "(", "self", ".", "num_levels", ")", ":", "\n", "                        ", "ids_lvl", "=", "matched_indexes", "[", ":", ",", "0", "]", "==", "lvl", "\n", "if", "torch", ".", "any", "(", "ids_lvl", ")", ":", "\n", "                            ", "cur_level_factor", "=", "2", "**", "lvl", "if", "self", ".", "bipyramid_on", "else", "1", "\n", "for", "anc", "in", "range", "(", "self", ".", "num_anchors", ")", ":", "\n", "                                ", "ids_lvl_anchor", "=", "ids_lvl", "&", "(", "matched_indexes", "[", ":", ",", "4", "]", "==", "anc", ")", "\n", "if", "torch", ".", "any", "(", "ids_lvl_anchor", ")", ":", "\n", "                                    ", "gt_masks", "[", "lvl", "]", "[", "anc", "]", ".", "append", "(", "\n", "targets_im", "[", "\n", "gt_fg_matched_inds", "[", "ids_lvl_anchor", "]", "\n", "]", ".", "gt_masks", ".", "crop_and_resize", "(", "\n", "fg_anchors", "[", "ids_lvl_anchor", "]", ".", "tensor", ",", "\n", "self", ".", "mask_sizes", "[", "anc", "]", "*", "cur_level_factor", ",", "\n", ")", "\n", ")", "\n", "# Select (N, H, W) dimensions", "\n", "gt_mask_inds_lvl_anc", "=", "matched_indexes", "[", "ids_lvl_anchor", ",", "1", ":", "4", "]", "\n", "# Set the image index to the current image", "\n", "gt_mask_inds_lvl_anc", "[", ":", ",", "0", "]", "=", "i", "\n", "gt_mask_inds", "[", "lvl", "]", "[", "anc", "]", ".", "append", "(", "gt_mask_inds_lvl_anc", ")", "\n", "", "", "", "", "", "", "gt_classes", ".", "append", "(", "gt_classes_i", ")", "\n", "\n", "# Classes and boxes", "\n", "", "gt_classes", "=", "cat", "(", "gt_classes", ")", "\n", "gt_valid_inds", "=", "gt_classes", ">=", "0", "\n", "gt_fg_inds", "=", "gt_valid_inds", "&", "(", "gt_classes", "<", "self", ".", "num_classes", ")", "\n", "gt_classes_target", "=", "torch", ".", "zeros", "(", "\n", "(", "gt_classes", ".", "shape", "[", "0", "]", ",", "self", ".", "num_classes", ")", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "self", ".", "device", "\n", ")", "\n", "gt_classes_target", "[", "gt_fg_inds", ",", "gt_classes", "[", "gt_fg_inds", "]", "]", "=", "1", "\n", "gt_deltas", "=", "cat", "(", "gt_deltas", ")", "if", "gt_deltas", "else", "None", "\n", "\n", "# Masks", "\n", "gt_masks", "=", "[", "[", "cat", "(", "mla", ")", "if", "mla", "else", "None", "for", "mla", "in", "ml", "]", "for", "ml", "in", "gt_masks", "]", "\n", "gt_mask_inds", "=", "[", "[", "cat", "(", "ila", ")", "if", "ila", "else", "None", "for", "ila", "in", "il", "]", "for", "il", "in", "gt_mask_inds", "]", "\n", "return", "(", "\n", "(", "gt_classes_target", ",", "gt_valid_inds", ")", ",", "\n", "(", "gt_deltas", ",", "gt_fg_inds", ")", ",", "\n", "(", "gt_masks", ",", "gt_mask_inds", ")", ",", "\n", "num_fg", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.inference": [[633, 674], ["detectron2.layers.cat", "detectron2.layers.cat", "enumerate", "len", "len", "detectron2.modeling.meta_arch.retinanet.permute_to_N_HWA_K", "detectron2.modeling.meta_arch.retinanet.permute_to_N_HWA_K", "zip", "arch.TensorMask.inference_single_image", "results.append", "detectron2.structures.Boxes.cat", "detectron2.layers.cat", "tuple"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.permute_to_N_HWA_K", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.permute_to_N_HWA_K", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.inference_single_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "def", "inference", "(", "self", ",", "pred_logits", ",", "pred_deltas", ",", "pred_masks", ",", "anchors", ",", "indexes", ",", "images", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            pred_logits, pred_deltas, pred_masks: Same as the output of:\n                meth:`TensorMaskHead.forward`\n            anchors, indexes: Same as the input of meth:`TensorMask.get_ground_truth`\n            images (ImageList): the input images\n\n        Returns:\n            results (List[Instances]): a list of #images elements.\n        \"\"\"", "\n", "assert", "len", "(", "anchors", ")", "==", "len", "(", "images", ")", "\n", "results", "=", "[", "]", "\n", "\n", "pred_logits", "=", "[", "permute_to_N_HWA_K", "(", "x", ",", "self", ".", "num_classes", ")", "for", "x", "in", "pred_logits", "]", "\n", "pred_deltas", "=", "[", "permute_to_N_HWA_K", "(", "x", ",", "4", ")", "for", "x", "in", "pred_deltas", "]", "\n", "\n", "pred_logits", "=", "cat", "(", "pred_logits", ",", "dim", "=", "1", ")", "\n", "pred_deltas", "=", "cat", "(", "pred_deltas", ",", "dim", "=", "1", ")", "\n", "\n", "for", "img_idx", ",", "(", "anchors_im", ",", "indexes_im", ")", "in", "enumerate", "(", "zip", "(", "anchors", ",", "indexes", ")", ")", ":", "\n", "# Get the size of the current image", "\n", "            ", "image_size", "=", "images", ".", "image_sizes", "[", "img_idx", "]", "\n", "\n", "logits_im", "=", "pred_logits", "[", "img_idx", "]", "\n", "deltas_im", "=", "pred_deltas", "[", "img_idx", "]", "\n", "\n", "if", "self", ".", "mask_on", ":", "\n", "                ", "masks_im", "=", "[", "[", "mla", "[", "img_idx", "]", "for", "mla", "in", "ml", "]", "for", "ml", "in", "pred_masks", "]", "\n", "", "else", ":", "\n", "                ", "masks_im", "=", "[", "None", "]", "*", "self", ".", "num_levels", "\n", "", "results_im", "=", "self", ".", "inference_single_image", "(", "\n", "logits_im", ",", "\n", "deltas_im", ",", "\n", "masks_im", ",", "\n", "Boxes", ".", "cat", "(", "anchors_im", ")", ",", "\n", "cat", "(", "indexes_im", ")", ",", "\n", "tuple", "(", "image_size", ")", ",", "\n", ")", "\n", "results", ".", "append", "(", "results_im", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.inference_single_image": [[675, 743], ["pred_logits.flatten().sigmoid_.flatten().sigmoid_.flatten().sigmoid_", "min", "pred_logits[].sort", "arch.TensorMask.box2box_transform.apply_deltas", "detectron2.layers.batched_nms", "detectron2.structures.Instances", "detectron2.structures.Boxes", "torch.where", "torch.where", "torch.where", "torch.where", "result_indexes.tolist", "pred_logits.flatten().sigmoid_.flatten().sigmoid_.flatten", "result_masks.append", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "[].view"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.box_regression.Box2BoxTransformRotated.apply_deltas", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.batched_nms", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten"], ["", "def", "inference_single_image", "(", "\n", "self", ",", "pred_logits", ",", "pred_deltas", ",", "pred_masks", ",", "anchors", ",", "indexes", ",", "image_size", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Single-image inference. Return bounding-box detection results by thresholding\n        on scores and applying non-maximum suppression (NMS).\n\n        Arguments:\n            pred_logits (list[Tensor]): list of #feature levels. Each entry contains\n                tensor of size (AxHxW, K)\n            pred_deltas (list[Tensor]): Same shape as 'pred_logits' except that K becomes 4.\n            pred_masks (list[list[Tensor]]): List of #feature levels, each is a list of #anchors.\n                Each entry contains tensor of size (M_i*M_i, H, W). `None` if mask_on=False.\n            anchors (list[Boxes]): list of #feature levels. Each entry contains\n                a Boxes object, which contains all the anchors for that\n                image in that feature level.\n            image_size (tuple(H, W)): a tuple of the image height and width.\n\n        Returns:\n            Same as `inference`, but for only one image.\n        \"\"\"", "\n", "pred_logits", "=", "pred_logits", ".", "flatten", "(", ")", ".", "sigmoid_", "(", ")", "\n", "# We get top locations across all levels to accelerate the inference speed,", "\n", "# which does not seem to affect the accuracy.", "\n", "# First select values above the threshold", "\n", "logits_top_idxs", "=", "torch", ".", "where", "(", "pred_logits", ">", "self", ".", "score_threshold", ")", "[", "0", "]", "\n", "# Then get the top values", "\n", "num_topk", "=", "min", "(", "self", ".", "topk_candidates", ",", "logits_top_idxs", ".", "shape", "[", "0", "]", ")", "\n", "pred_prob", ",", "topk_idxs", "=", "pred_logits", "[", "logits_top_idxs", "]", ".", "sort", "(", "descending", "=", "True", ")", "\n", "# Keep top k scoring values", "\n", "pred_prob", "=", "pred_prob", "[", ":", "num_topk", "]", "\n", "# Keep top k values", "\n", "top_idxs", "=", "logits_top_idxs", "[", "topk_idxs", "[", ":", "num_topk", "]", "]", "\n", "\n", "# class index", "\n", "cls_idxs", "=", "top_idxs", "%", "self", ".", "num_classes", "\n", "# HWA index", "\n", "top_idxs", "//=", "self", ".", "num_classes", "\n", "# predict boxes", "\n", "pred_boxes", "=", "self", ".", "box2box_transform", ".", "apply_deltas", "(", "\n", "pred_deltas", "[", "top_idxs", "]", ",", "anchors", "[", "top_idxs", "]", ".", "tensor", "\n", ")", "\n", "# apply nms", "\n", "keep", "=", "batched_nms", "(", "pred_boxes", ",", "pred_prob", ",", "cls_idxs", ",", "self", ".", "nms_threshold", ")", "\n", "# pick the top ones", "\n", "keep", "=", "keep", "[", ":", "self", ".", "detections_im", "]", "\n", "\n", "results", "=", "Instances", "(", "image_size", ")", "\n", "results", ".", "pred_boxes", "=", "Boxes", "(", "pred_boxes", "[", "keep", "]", ")", "\n", "results", ".", "scores", "=", "pred_prob", "[", "keep", "]", "\n", "results", ".", "pred_classes", "=", "cls_idxs", "[", "keep", "]", "\n", "\n", "# deal with masks", "\n", "result_masks", ",", "result_anchors", "=", "[", "]", ",", "None", "\n", "if", "self", ".", "mask_on", ":", "\n", "# index and anchors, useful for masks", "\n", "            ", "top_indexes", "=", "indexes", "[", "top_idxs", "]", "\n", "top_anchors", "=", "anchors", "[", "top_idxs", "]", "\n", "result_indexes", "=", "top_indexes", "[", "keep", "]", "\n", "result_anchors", "=", "top_anchors", "[", "keep", "]", "\n", "# Get masks and do sigmoid", "\n", "for", "lvl", ",", "_", ",", "h", ",", "w", ",", "anc", "in", "result_indexes", ".", "tolist", "(", ")", ":", "\n", "                ", "cur_size", "=", "self", ".", "mask_sizes", "[", "anc", "]", "*", "(", "2", "**", "lvl", "if", "self", ".", "bipyramid_on", "else", "1", ")", "\n", "result_masks", ".", "append", "(", "\n", "torch", ".", "sigmoid", "(", "pred_masks", "[", "lvl", "]", "[", "anc", "]", "[", ":", ",", "h", ",", "w", "]", ".", "view", "(", "1", ",", "cur_size", ",", "cur_size", ")", ")", "\n", ")", "\n", "\n", "", "", "return", "results", ",", "(", "result_masks", ",", "result_anchors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.preprocess_image": [[744, 752], ["detectron2.structures.ImageList.from_tensors", "x[].to"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "preprocess_image", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Normalize, pad and batch the input images.\n        \"\"\"", "\n", "images", "=", "[", "x", "[", "\"image\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "images", "=", "[", "(", "x", "-", "self", ".", "pixel_mean", ")", "/", "self", ".", "pixel_std", "for", "x", "in", "images", "]", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "self", ".", "backbone", ".", "size_divisibility", ")", "\n", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMaskHead.__init__": [[755, 856], ["torch.nn.Module.__init__", "range", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.Conv2d", "range", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.Conv2d", "modules_list.extend", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "cls_subnet.append", "cls_subnet.append", "bbox_subnet.append", "bbox_subnet.append", "range", "torch.nn.Sequential", "torch.nn.Sequential", "modules_list.append", "modules.modules", "math.log", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "mask_subnet.append", "mask_subnet.append", "arch.TensorMaskHead.add_module", "modules_list.append", "isinstance", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.Conv2d", "getattr", "range", "torch.nn.Sequential", "torch.nn.Sequential", "modules_list.append", "tensormask.layers.SwapAlign2Nat", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "setattr", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "tensormask.layers.SwapAlign2Nat"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "num_levels", ",", "num_anchors", ",", "mask_sizes", ",", "input_shape", ":", "List", "[", "ShapeSpec", "]", ")", ":", "\n", "        ", "\"\"\"\n        TensorMask head.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "# fmt: off", "\n", "self", ".", "in_features", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "IN_FEATURES", "\n", "in_channels", "=", "input_shape", "[", "0", "]", ".", "channels", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "NUM_CLASSES", "\n", "cls_channels", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "CLS_CHANNELS", "\n", "num_convs", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "NUM_CONVS", "\n", "# box parameters", "\n", "bbox_channels", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "BBOX_CHANNELS", "\n", "# mask parameters", "\n", "self", ".", "mask_on", "=", "cfg", ".", "MODEL", ".", "MASK_ON", "\n", "self", ".", "mask_sizes", "=", "mask_sizes", "\n", "mask_channels", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "MASK_CHANNELS", "\n", "self", ".", "align_on", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "ALIGNED_ON", "\n", "self", ".", "bipyramid_on", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "BIPYRAMID_ON", "\n", "# fmt: on", "\n", "\n", "# class subnet", "\n", "cls_subnet", "=", "[", "]", "\n", "cur_channels", "=", "in_channels", "\n", "for", "_", "in", "range", "(", "num_convs", ")", ":", "\n", "            ", "cls_subnet", ".", "append", "(", "\n", "nn", ".", "Conv2d", "(", "cur_channels", ",", "cls_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", ")", "\n", "cur_channels", "=", "cls_channels", "\n", "cls_subnet", ".", "append", "(", "nn", ".", "ReLU", "(", ")", ")", "\n", "\n", "", "self", ".", "cls_subnet", "=", "nn", ".", "Sequential", "(", "*", "cls_subnet", ")", "\n", "self", ".", "cls_score", "=", "nn", ".", "Conv2d", "(", "\n", "cur_channels", ",", "num_anchors", "*", "num_classes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", "\n", ")", "\n", "modules_list", "=", "[", "self", ".", "cls_subnet", ",", "self", ".", "cls_score", "]", "\n", "\n", "# box subnet", "\n", "bbox_subnet", "=", "[", "]", "\n", "cur_channels", "=", "in_channels", "\n", "for", "_", "in", "range", "(", "num_convs", ")", ":", "\n", "            ", "bbox_subnet", ".", "append", "(", "\n", "nn", ".", "Conv2d", "(", "cur_channels", ",", "bbox_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", ")", "\n", "cur_channels", "=", "bbox_channels", "\n", "bbox_subnet", ".", "append", "(", "nn", ".", "ReLU", "(", ")", ")", "\n", "\n", "", "self", ".", "bbox_subnet", "=", "nn", ".", "Sequential", "(", "*", "bbox_subnet", ")", "\n", "self", ".", "bbox_pred", "=", "nn", ".", "Conv2d", "(", "\n", "cur_channels", ",", "num_anchors", "*", "4", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", "\n", ")", "\n", "modules_list", ".", "extend", "(", "[", "self", ".", "bbox_subnet", ",", "self", ".", "bbox_pred", "]", ")", "\n", "\n", "# mask subnet", "\n", "if", "self", ".", "mask_on", ":", "\n", "            ", "mask_subnet", "=", "[", "]", "\n", "cur_channels", "=", "in_channels", "\n", "for", "_", "in", "range", "(", "num_convs", ")", ":", "\n", "                ", "mask_subnet", ".", "append", "(", "\n", "nn", ".", "Conv2d", "(", "cur_channels", ",", "mask_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", ")", "\n", "cur_channels", "=", "mask_channels", "\n", "mask_subnet", ".", "append", "(", "nn", ".", "ReLU", "(", ")", ")", "\n", "\n", "", "self", ".", "mask_subnet", "=", "nn", ".", "Sequential", "(", "*", "mask_subnet", ")", "\n", "modules_list", ".", "append", "(", "self", ".", "mask_subnet", ")", "\n", "for", "mask_size", "in", "self", ".", "mask_sizes", ":", "\n", "                ", "cur_mask_module", "=", "\"mask_pred_%02d\"", "%", "mask_size", "\n", "self", ".", "add_module", "(", "\n", "cur_mask_module", ",", "\n", "nn", ".", "Conv2d", "(", "\n", "cur_channels", ",", "mask_size", "*", "mask_size", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", "\n", ")", ",", "\n", ")", "\n", "modules_list", ".", "append", "(", "getattr", "(", "self", ",", "cur_mask_module", ")", ")", "\n", "", "if", "self", ".", "align_on", ":", "\n", "                ", "if", "self", ".", "bipyramid_on", ":", "\n", "                    ", "for", "lvl", "in", "range", "(", "num_levels", ")", ":", "\n", "                        ", "cur_mask_module", "=", "\"align2nat_%02d\"", "%", "lvl", "\n", "lambda_val", "=", "2", "**", "lvl", "\n", "setattr", "(", "self", ",", "cur_mask_module", ",", "SwapAlign2Nat", "(", "lambda_val", ")", ")", "\n", "# Also the fusing layer, stay at the same channel size", "\n", "", "mask_fuse", "=", "[", "\n", "nn", ".", "Conv2d", "(", "cur_channels", ",", "cur_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "]", "\n", "self", ".", "mask_fuse", "=", "nn", ".", "Sequential", "(", "*", "mask_fuse", ")", "\n", "modules_list", ".", "append", "(", "self", ".", "mask_fuse", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "align2nat", "=", "SwapAlign2Nat", "(", "1", ")", "\n", "\n", "# Initialization", "\n", "", "", "", "for", "modules", "in", "modules_list", ":", "\n", "            ", "for", "layer", "in", "modules", ".", "modules", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "layer", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                    ", "torch", ".", "nn", ".", "init", ".", "normal_", "(", "layer", ".", "weight", ",", "mean", "=", "0", ",", "std", "=", "0.01", ")", "\n", "torch", ".", "nn", ".", "init", ".", "constant_", "(", "layer", ".", "bias", ",", "0", ")", "\n", "\n", "# Use prior in model initialization to improve stability", "\n", "", "", "", "bias_value", "=", "-", "(", "math", ".", "log", "(", "(", "1", "-", "0.01", ")", "/", "0.01", ")", ")", "\n", "torch", ".", "nn", ".", "init", ".", "constant_", "(", "self", ".", "cls_score", ".", "bias", ",", "bias_value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMaskHead.forward": [[857, 914], ["arch.TensorMaskHead.cls_score", "arch.TensorMaskHead.bbox_pred", "enumerate", "arch.TensorMaskHead.cls_subnet", "arch.TensorMaskHead.bbox_subnet", "arch.TensorMaskHead.mask_subnet", "enumerate", "pred_masks.append", "mask_feats_up.append", "getattr", "getattr.", "cur_masks.append", "torch.interpolate", "torch.interpolate", "arch.TensorMaskHead.mask_fuse", "getattr", "getattr.", "arch.TensorMaskHead.align2nat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "features", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            features (list[Tensor]): FPN feature map tensors in high to low resolution.\n                Each tensor in the list correspond to different feature levels.\n\n        Returns:\n            pred_logits (list[Tensor]): #lvl tensors, each has shape (N, AxK, Hi, Wi).\n                The tensor predicts the classification probability\n                at each spatial position for each of the A anchors and K object\n                classes.\n            pred_deltas (list[Tensor]): #lvl tensors, each has shape (N, Ax4, Hi, Wi).\n                The tensor predicts 4-vector (dx,dy,dw,dh) box\n                regression values for every anchor. These values are the\n                relative offset between the anchor and the ground truth box.\n            pred_masks (list(list[Tensor])): #lvl list of tensors, each is a list of\n                A tensors of shape (N, M_{i,a}, Hi, Wi).\n                The tensor predicts a dense set of M_ixM_i masks at every location.\n        \"\"\"", "\n", "pred_logits", "=", "[", "self", ".", "cls_score", "(", "self", ".", "cls_subnet", "(", "x", ")", ")", "for", "x", "in", "features", "]", "\n", "pred_deltas", "=", "[", "self", ".", "bbox_pred", "(", "self", ".", "bbox_subnet", "(", "x", ")", ")", "for", "x", "in", "features", "]", "\n", "\n", "pred_masks", "=", "None", "\n", "if", "self", ".", "mask_on", ":", "\n", "            ", "mask_feats", "=", "[", "self", ".", "mask_subnet", "(", "x", ")", "for", "x", "in", "features", "]", "\n", "\n", "if", "self", ".", "bipyramid_on", ":", "\n", "                ", "mask_feat_high_res", "=", "mask_feats", "[", "0", "]", "\n", "H", ",", "W", "=", "mask_feat_high_res", ".", "shape", "[", "-", "2", ":", "]", "\n", "mask_feats_up", "=", "[", "]", "\n", "for", "lvl", ",", "mask_feat", "in", "enumerate", "(", "mask_feats", ")", ":", "\n", "                    ", "lambda_val", "=", "2.0", "**", "lvl", "\n", "mask_feat_up", "=", "mask_feat", "\n", "if", "lvl", ">", "0", ":", "\n", "                        ", "mask_feat_up", "=", "F", ".", "interpolate", "(", "\n", "mask_feat", ",", "scale_factor", "=", "lambda_val", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "", "mask_feats_up", ".", "append", "(", "\n", "self", ".", "mask_fuse", "(", "mask_feat_up", "[", ":", ",", ":", ",", ":", "H", ",", ":", "W", "]", "+", "mask_feat_high_res", ")", "\n", ")", "\n", "", "mask_feats", "=", "mask_feats_up", "\n", "\n", "", "pred_masks", "=", "[", "]", "\n", "for", "lvl", ",", "mask_feat", "in", "enumerate", "(", "mask_feats", ")", ":", "\n", "                ", "cur_masks", "=", "[", "]", "\n", "for", "mask_size", "in", "self", ".", "mask_sizes", ":", "\n", "                    ", "cur_mask_module", "=", "getattr", "(", "self", ",", "\"mask_pred_%02d\"", "%", "mask_size", ")", "\n", "cur_mask", "=", "cur_mask_module", "(", "mask_feat", ")", "\n", "if", "self", ".", "align_on", ":", "\n", "                        ", "if", "self", ".", "bipyramid_on", ":", "\n", "                            ", "cur_mask_module", "=", "getattr", "(", "self", ",", "\"align2nat_%02d\"", "%", "lvl", ")", "\n", "cur_mask", "=", "cur_mask_module", "(", "cur_mask", ")", "\n", "", "else", ":", "\n", "                            ", "cur_mask", "=", "self", ".", "align2nat", "(", "cur_mask", ")", "\n", "", "", "cur_masks", ".", "append", "(", "cur_mask", ")", "\n", "", "pred_masks", ".", "append", "(", "cur_masks", ")", "\n", "", "", "return", "pred_logits", ",", "pred_deltas", ",", "pred_masks", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.permute_all_cls_and_box_to_N_HWA_K_and_concat": [[23, 40], ["detectron2.layers.cat().view", "detectron2.layers.cat().view", "detectron2.modeling.meta_arch.retinanet.permute_to_N_HWA_K", "detectron2.modeling.meta_arch.retinanet.permute_to_N_HWA_K", "detectron2.layers.cat", "detectron2.layers.cat"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.permute_to_N_HWA_K", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.meta_arch.retinanet.permute_to_N_HWA_K", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["def", "permute_all_cls_and_box_to_N_HWA_K_and_concat", "(", "pred_logits", ",", "pred_anchor_deltas", ",", "num_classes", "=", "80", ")", ":", "\n", "    ", "\"\"\"\n    Rearrange the tensor layout from the network output, i.e.:\n    list[Tensor]: #lvl tensors of shape (N, A x K, Hi, Wi)\n    to per-image predictions, i.e.:\n    Tensor: of shape (N x sum(Hi x Wi x A), K)\n    \"\"\"", "\n", "# for each feature level, permute the outputs to make them be in the", "\n", "# same format as the labels.", "\n", "pred_logits_flattened", "=", "[", "permute_to_N_HWA_K", "(", "x", ",", "num_classes", ")", "for", "x", "in", "pred_logits", "]", "\n", "pred_anchor_deltas_flattened", "=", "[", "permute_to_N_HWA_K", "(", "x", ",", "4", ")", "for", "x", "in", "pred_anchor_deltas", "]", "\n", "# concatenate on the first dimension (representing the feature levels), to", "\n", "# take into account the way the labels were generated (with all feature maps", "\n", "# being concatenated as well)", "\n", "pred_logits", "=", "cat", "(", "pred_logits_flattened", ",", "dim", "=", "1", ")", ".", "view", "(", "-", "1", ",", "num_classes", ")", "\n", "pred_anchor_deltas", "=", "cat", "(", "pred_anchor_deltas_flattened", ",", "dim", "=", "1", ")", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "return", "pred_logits", ",", "pred_anchor_deltas", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch._assignment_rule": [[42, 133], ["torch.min", "torch.min", "torch.max", "torch.max", "detectron2.layers.cat", "torch.zeros_like", "torch.zeros_like", "torch.all", "torch.all", "assign_matrix.max", "matches.new_full", "torch.max", "torch.max", "torch.sum", "torch.sum", "matches.size", "assign_matrix.sum", "gt_boxes.new_full", "gt_boxes.new_full", "torch.max", "torch.max"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "def", "_assignment_rule", "(", "\n", "gt_boxes", ",", "\n", "anchor_boxes", ",", "\n", "unit_lengths", ",", "\n", "min_anchor_size", ",", "\n", "scale_thresh", "=", "2.0", ",", "\n", "spatial_thresh", "=", "1.0", ",", "\n", "uniqueness_on", "=", "True", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Given two lists of boxes of N ground truth boxes and M anchor boxes,\n    compute the assignment between the two, following the assignment rules in\n    https://arxiv.org/abs/1903.12174.\n    The box order must be (xmin, ymin, xmax, ymax), so please make sure to convert\n    to BoxMode.XYXY_ABS before calling this function.\n\n    Args:\n        gt_boxes, anchor_boxes (Boxes): two Boxes. Contains N & M boxes/anchors, respectively.\n        unit_lengths (Tensor): Contains the unit lengths of M anchor boxes.\n        min_anchor_size (float): Minimum size of the anchor, in pixels\n        scale_thresh (float): The `scale` threshold: the maximum size of the anchor\n                              should not be greater than scale_thresh x max(h, w) of\n                              the ground truth box.\n        spatial_thresh (float): The `spatial` threshold: the l2 distance between the\n                              center of the anchor and the ground truth box should not\n                              be greater than spatial_thresh x u where u is the unit length.\n\n    Returns:\n        matches (Tensor[int64]): a vector of length M, where matches[i] is a matched\n                ground-truth index in [0, N)\n        match_labels (Tensor[int8]): a vector of length M, where pred_labels[i] indicates\n            whether a prediction is a true or false positive or ignored\n    \"\"\"", "\n", "gt_boxes", ",", "anchor_boxes", "=", "gt_boxes", ".", "tensor", ",", "anchor_boxes", ".", "tensor", "\n", "N", "=", "gt_boxes", ".", "shape", "[", "0", "]", "\n", "M", "=", "anchor_boxes", ".", "shape", "[", "0", "]", "\n", "if", "N", "==", "0", "or", "M", "==", "0", ":", "\n", "        ", "return", "(", "\n", "gt_boxes", ".", "new_full", "(", "(", "N", ",", ")", ",", "0", ",", "dtype", "=", "torch", ".", "int64", ")", ",", "\n", "gt_boxes", ".", "new_full", "(", "(", "N", ",", ")", ",", "-", "1", ",", "dtype", "=", "torch", ".", "int8", ")", ",", "\n", ")", "\n", "\n", "# Containment rule", "\n", "", "lt", "=", "torch", ".", "min", "(", "gt_boxes", "[", ":", ",", "None", ",", ":", "2", "]", ",", "anchor_boxes", "[", ":", ",", ":", "2", "]", ")", "# [N,M,2]", "\n", "rb", "=", "torch", ".", "max", "(", "gt_boxes", "[", ":", ",", "None", ",", "2", ":", "]", ",", "anchor_boxes", "[", ":", ",", "2", ":", "]", ")", "# [N,M,2]", "\n", "union", "=", "cat", "(", "[", "lt", ",", "rb", "]", ",", "dim", "=", "2", ")", "# [N,M,4]", "\n", "\n", "dummy_gt_boxes", "=", "torch", ".", "zeros_like", "(", "gt_boxes", ")", "\n", "anchor", "=", "dummy_gt_boxes", "[", ":", ",", "None", ",", ":", "]", "+", "anchor_boxes", "[", ":", ",", ":", "]", "# [N,M,4]", "\n", "\n", "contain_matrix", "=", "torch", ".", "all", "(", "union", "==", "anchor", ",", "dim", "=", "2", ")", "# [N,M]", "\n", "\n", "# Centrality rule, scale", "\n", "gt_size_lower", "=", "torch", ".", "max", "(", "gt_boxes", "[", ":", ",", "2", ":", "]", "-", "gt_boxes", "[", ":", ",", ":", "2", "]", ",", "dim", "=", "1", ")", "[", "0", "]", "# [N]", "\n", "gt_size_upper", "=", "gt_size_lower", "*", "scale_thresh", "# [N]", "\n", "# Fall back for small objects", "\n", "gt_size_upper", "[", "gt_size_upper", "<", "min_anchor_size", "]", "=", "min_anchor_size", "\n", "# Due to sampling of locations, the anchor sizes are deducted with sampling strides", "\n", "anchor_size", "=", "(", "\n", "torch", ".", "max", "(", "anchor_boxes", "[", ":", ",", "2", ":", "]", "-", "anchor_boxes", "[", ":", ",", ":", "2", "]", ",", "dim", "=", "1", ")", "[", "0", "]", "-", "unit_lengths", "\n", ")", "# [M]", "\n", "\n", "size_diff_upper", "=", "gt_size_upper", "[", ":", ",", "None", "]", "-", "anchor_size", "# [N,M]", "\n", "scale_matrix", "=", "size_diff_upper", ">=", "0", "# [N,M]", "\n", "\n", "# Centrality rule, spatial", "\n", "gt_center", "=", "(", "gt_boxes", "[", ":", ",", "2", ":", "]", "+", "gt_boxes", "[", ":", ",", ":", "2", "]", ")", "/", "2", "# [N,2]", "\n", "anchor_center", "=", "(", "anchor_boxes", "[", ":", ",", "2", ":", "]", "+", "anchor_boxes", "[", ":", ",", ":", "2", "]", ")", "/", "2", "# [M,2]", "\n", "offset_center", "=", "gt_center", "[", ":", ",", "None", ",", ":", "]", "-", "anchor_center", "[", ":", ",", ":", "]", "# [N,M,2]", "\n", "offset_center", "/=", "unit_lengths", "[", ":", ",", "None", "]", "# [N,M,2]", "\n", "spatial_square", "=", "spatial_thresh", "*", "spatial_thresh", "\n", "spatial_matrix", "=", "torch", ".", "sum", "(", "offset_center", "*", "offset_center", ",", "dim", "=", "2", ")", "<=", "spatial_square", "\n", "\n", "assign_matrix", "=", "(", "contain_matrix", "&", "scale_matrix", "&", "spatial_matrix", ")", ".", "int", "(", ")", "\n", "\n", "# assign_matrix is N (gt) x M (predicted)", "\n", "# Max over gt elements (dim 0) to find best gt candidate for each prediction", "\n", "matched_vals", ",", "matches", "=", "assign_matrix", ".", "max", "(", "dim", "=", "0", ")", "\n", "match_labels", "=", "matches", ".", "new_full", "(", "matches", ".", "size", "(", ")", ",", "1", ",", "dtype", "=", "torch", ".", "int8", ")", "\n", "\n", "match_labels", "[", "matched_vals", "==", "0", "]", "=", "0", "\n", "match_labels", "[", "matched_vals", "==", "1", "]", "=", "1", "\n", "\n", "# find all the elements that match to ground truths multiple times", "\n", "not_unique_idxs", "=", "assign_matrix", ".", "sum", "(", "dim", "=", "0", ")", ">", "1", "\n", "if", "uniqueness_on", ":", "\n", "        ", "match_labels", "[", "not_unique_idxs", "]", "=", "0", "\n", "", "else", ":", "\n", "        ", "match_labels", "[", "not_unique_idxs", "]", "=", "-", "1", "\n", "\n", "", "return", "matches", ",", "match_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch._paste_mask_lists_in_image": [[136, 180], ["torch.tensor", "torch.tensor", "torch.unique", "torch.unique", "torch.unique.tolist", "detectron2.layers.cat", "detectron2.layers.cat", "torch.empty_like", "torch.empty_like", "len", "torch.empty", "torch.empty", "detectron2.layers.cat.append", "detectron2.layers.cat", "detectron2.layers.cat.append", "torch.where", "torch.where", "detectron2.layers.paste_masks_in_image"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.mask_ops.paste_masks_in_image"], ["", "def", "_paste_mask_lists_in_image", "(", "masks", ",", "boxes", ",", "image_shape", ",", "threshold", "=", "0.5", ")", ":", "\n", "    ", "\"\"\"\n    Paste a list of masks that are of various resolutions (e.g., 28 x 28) into an image.\n    The location, height, and width for pasting each mask is determined by their\n    corresponding bounding boxes in boxes.\n\n    Args:\n        masks (list(Tensor)): A list of Tensor of shape (1, Hmask_i, Wmask_i).\n                            Values are in [0, 1]. The list length, Bimg, is the\n                            number of detected object instances in the image.\n        boxes (Boxes): A Boxes of length Bimg. boxes.tensor[i] and masks[i] correspond\n                            to the same object instance.\n        image_shape (tuple): height, width\n        threshold (float): A threshold in [0, 1] for converting the (soft) masks to\n            binary masks.\n\n    Returns:\n        img_masks (Tensor): A tensor of shape (Bimg, Himage, Wimage), where Bimg is the\n        number of detected object instances and Himage, Wimage are the image width\n        and height. img_masks[i] is a binary mask for object instance i.\n    \"\"\"", "\n", "if", "len", "(", "masks", ")", "==", "0", ":", "\n", "        ", "return", "torch", ".", "empty", "(", "(", "0", ",", "1", ")", "+", "image_shape", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "\n", "# Loop over masks groups. Each group has the same mask prediction size.", "\n", "", "img_masks", "=", "[", "]", "\n", "ind_masks", "=", "[", "]", "\n", "mask_sizes", "=", "torch", ".", "tensor", "(", "[", "m", ".", "shape", "[", "-", "1", "]", "for", "m", "in", "masks", "]", ")", "\n", "unique_sizes", "=", "torch", ".", "unique", "(", "mask_sizes", ")", "\n", "for", "msize", "in", "unique_sizes", ".", "tolist", "(", ")", ":", "\n", "        ", "cur_ind", "=", "torch", ".", "where", "(", "mask_sizes", "==", "msize", ")", "[", "0", "]", "\n", "ind_masks", ".", "append", "(", "cur_ind", ")", "\n", "\n", "cur_masks", "=", "cat", "(", "[", "masks", "[", "i", "]", "for", "i", "in", "cur_ind", "]", ")", "\n", "cur_boxes", "=", "boxes", "[", "cur_ind", "]", "\n", "img_masks", ".", "append", "(", "paste_masks_in_image", "(", "cur_masks", ",", "cur_boxes", ",", "image_shape", ",", "threshold", ")", ")", "\n", "\n", "", "img_masks", "=", "cat", "(", "img_masks", ")", "\n", "ind_masks", "=", "cat", "(", "ind_masks", ")", "\n", "\n", "img_masks_out", "=", "torch", ".", "empty_like", "(", "img_masks", ")", "\n", "img_masks_out", "[", "ind_masks", ",", ":", ",", ":", "]", "=", "img_masks", "\n", "\n", "return", "img_masks_out", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch._postprocess": [[182, 227], ["detectron2.structures.Instances", "output_boxes.clip", "output_boxes.nonempty", "arch._paste_mask_lists_in_image", "detectron2.structures.Instances.get_fields", "zip", "output_boxes.nonempty.tolist"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.nonempty", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch._paste_mask_lists_in_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.get_fields"], ["", "def", "_postprocess", "(", "results", ",", "result_mask_info", ",", "output_height", ",", "output_width", ",", "mask_threshold", "=", "0.5", ")", ":", "\n", "    ", "\"\"\"\n    Post-process the output boxes for TensorMask.\n    The input images are often resized when entering an object detector.\n    As a result, we often need the outputs of the detector in a different\n    resolution from its inputs.\n\n    This function will postprocess the raw outputs of TensorMask\n    to produce outputs according to the desired output resolution.\n\n    Args:\n        results (Instances): the raw outputs from the detector.\n            `results.image_size` contains the input image resolution the detector sees.\n            This object might be modified in-place. Note that it does not contain the field\n            `pred_masks`, which is provided by another input `result_masks`.\n        result_mask_info (list[Tensor], Boxes): a pair of two items for mask related results.\n                The first item is a list of #detection tensors, each is the predicted masks.\n                The second item is the anchors corresponding to the predicted masks.\n        output_height, output_width: the desired output resolution.\n\n    Returns:\n        Instances: the postprocessed output from the model, based on the output resolution\n    \"\"\"", "\n", "scale_x", ",", "scale_y", "=", "(", "output_width", "/", "results", ".", "image_size", "[", "1", "]", ",", "output_height", "/", "results", ".", "image_size", "[", "0", "]", ")", "\n", "results", "=", "Instances", "(", "(", "output_height", ",", "output_width", ")", ",", "**", "results", ".", "get_fields", "(", ")", ")", "\n", "\n", "output_boxes", "=", "results", ".", "pred_boxes", "\n", "output_boxes", ".", "tensor", "[", ":", ",", "0", ":", ":", "2", "]", "*=", "scale_x", "\n", "output_boxes", ".", "tensor", "[", ":", ",", "1", ":", ":", "2", "]", "*=", "scale_y", "\n", "output_boxes", ".", "clip", "(", "results", ".", "image_size", ")", "\n", "\n", "inds_nonempty", "=", "output_boxes", ".", "nonempty", "(", ")", "\n", "results", "=", "results", "[", "inds_nonempty", "]", "\n", "result_masks", ",", "result_anchors", "=", "result_mask_info", "\n", "if", "result_masks", ":", "\n", "        ", "result_anchors", ".", "tensor", "[", ":", ",", "0", ":", ":", "2", "]", "*=", "scale_x", "\n", "result_anchors", ".", "tensor", "[", ":", ",", "1", ":", ":", "2", "]", "*=", "scale_y", "\n", "result_masks", "=", "[", "x", "for", "(", "i", ",", "x", ")", "in", "zip", "(", "inds_nonempty", ".", "tolist", "(", ")", ",", "result_masks", ")", "if", "i", "]", "\n", "results", ".", "pred_masks", "=", "_paste_mask_lists_in_image", "(", "\n", "result_masks", ",", "\n", "result_anchors", "[", "inds_nonempty", "]", ",", "\n", "results", ".", "image_size", ",", "\n", "threshold", "=", "mask_threshold", ",", "\n", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_swap_align2nat.SwapAlign2NatTest.test_swap_align2nat_gradcheck_cuda": [[12, 20], ["unittest.skipIf", "torch.device", "tensormask.layers.swap_align2nat.SwapAlign2Nat().to", "torch.rand", "test_swap_align2nat.SwapAlign2NatTest.assertTrue", "torch.autograd.gradcheck", "torch.cuda.is_available", "tensormask.layers.swap_align2nat.SwapAlign2Nat"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["    ", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_swap_align2nat_gradcheck_cuda", "(", "self", ")", ":", "\n", "        ", "dtype", "=", "torch", ".", "float64", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda\"", ")", "\n", "m", "=", "SwapAlign2Nat", "(", "2", ")", ".", "to", "(", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "x", "=", "torch", ".", "rand", "(", "2", ",", "4", ",", "10", ",", "10", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ",", "requires_grad", "=", "True", ")", "\n", "\n", "self", ".", "assertTrue", "(", "gradcheck", "(", "m", ",", "x", ")", ",", "\"gradcheck failed for SwapAlign2Nat CUDA\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_swap_align2nat.SwapAlign2NatTest._swap_align2nat": [[21, 29], ["tensormask.layers.swap_align2nat.SwapAlign2Nat", "torch.from_numpy", "tensormask.layers.swap_align2nat.SwapAlign2Nat.forward().cpu().numpy", "tensor[].astype", "tensormask.layers.swap_align2nat.SwapAlign2Nat.forward().cpu", "tensormask.layers.swap_align2nat.SwapAlign2Nat.forward", "torch.from_numpy.cuda"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.forward", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda"], ["", "def", "_swap_align2nat", "(", "self", ",", "tensor", ",", "lambda_val", ")", ":", "\n", "        ", "\"\"\"\n        The basic setup for testing Swap_Align\n        \"\"\"", "\n", "op", "=", "SwapAlign2Nat", "(", "lambda_val", ",", "pad_val", "=", "0.0", ")", "\n", "input", "=", "torch", ".", "from_numpy", "(", "tensor", "[", "None", ",", ":", ",", ":", ",", ":", "]", ".", "astype", "(", "\"float32\"", ")", ")", "\n", "output", "=", "op", ".", "forward", "(", "input", ".", "cuda", "(", ")", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "return", "output", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_image_resize_transform.TestImageResizeTransform.test_image_resize_1": [[10, 17], ["densepose.data.transform.ImageResizeTransform", "densepose.data.transform.ImageResizeTransform.", "test_image_resize_transform.TestImageResizeTransform.assertEqual", "test_image_resize_transform.TestImageResizeTransform.assertAlmostEqual", "torch.ones", "torch.ones", "densepose.data.transform.ImageResizeTransform.size", "IMAGES_GT.size", "torch.abs().max().item", "torch.abs().max", "torch.abs"], "methods", ["None"], ["    ", "def", "test_image_resize_1", "(", "self", ")", ":", "\n", "        ", "images_batch", "=", "torch", ".", "ones", "(", "(", "3", ",", "100", ",", "100", ",", "3", ")", ",", "dtype", "=", "torch", ".", "uint8", ")", "*", "100", "\n", "transform", "=", "ImageResizeTransform", "(", ")", "\n", "images_transformed", "=", "transform", "(", "images_batch", ")", "\n", "IMAGES_GT", "=", "torch", ".", "ones", "(", "(", "3", ",", "3", ",", "800", ",", "800", ")", ",", "dtype", "=", "torch", ".", "float", ")", "*", "100", "\n", "self", ".", "assertEqual", "(", "images_transformed", ".", "size", "(", ")", ",", "IMAGES_GT", ".", "size", "(", ")", ")", "\n", "self", ".", "assertAlmostEqual", "(", "torch", ".", "abs", "(", "IMAGES_GT", "-", "images_transformed", ")", ".", "max", "(", ")", ".", "item", "(", ")", ",", "0.0", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_combine_data_loader.TestCombinedDataLoader.test_combine_loaders_1": [[31, 47], ["test_combine_data_loader._grouper", "test_combine_data_loader._grouper", "random.seed", "densepose.data.CombinedDataLoader", "enumerate", "test_combine_data_loader.TestCombinedDataLoader.assertEqual", "test_combine_data_loader.TestCombinedDataLoader.assertEqual", "len", "range", "range"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_combine_data_loader._grouper", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_combine_data_loader._grouper"], ["    ", "def", "test_combine_loaders_1", "(", "self", ")", ":", "\n", "        ", "loader1", "=", "_grouper", "(", "[", "f\"1_{i}\"", "for", "i", "in", "range", "(", "10", ")", "]", ",", "2", ")", "\n", "loader2", "=", "_grouper", "(", "[", "f\"2_{i}\"", "for", "i", "in", "range", "(", "11", ")", "]", ",", "3", ")", "\n", "batch_size", "=", "4", "\n", "ratios", "=", "(", "0.1", ",", "0.9", ")", "\n", "random", ".", "seed", "(", "43", ")", "\n", "combined", "=", "CombinedDataLoader", "(", "(", "loader1", ",", "loader2", ")", ",", "batch_size", ",", "ratios", ")", "\n", "BATCHES_GT", "=", "[", "\n", "[", "\"1_0\"", ",", "\"1_1\"", ",", "\"2_0\"", ",", "\"2_1\"", "]", ",", "\n", "[", "\"2_2\"", ",", "\"2_3\"", ",", "\"2_4\"", ",", "\"2_5\"", "]", ",", "\n", "[", "\"1_2\"", ",", "\"1_3\"", ",", "\"2_6\"", ",", "\"2_7\"", "]", ",", "\n", "[", "\"2_8\"", ",", "\"2_9\"", ",", "\"2_10\"", ",", "None", "]", ",", "\n", "]", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "combined", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "len", "(", "batch", ")", ",", "batch_size", ")", "\n", "self", ".", "assertEqual", "(", "batch", ",", "BATCHES_GT", "[", "i", "]", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_combine_data_loader._grouper": [[10, 28], ["iter", "range", "values.append", "tuple", "next", "values.extend", "tuple", "len"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.iter"], ["def", "_grouper", "(", "iterable", ":", "Iterable", "[", "Any", "]", ",", "n", ":", "int", ",", "fillvalue", "=", "None", ")", "->", "Iterator", "[", "Tuple", "[", "Any", "]", "]", ":", "\n", "    ", "\"\"\"\n    Group elements of an iterable by chunks of size `n`, e.g.\n    grouper(range(9), 4) ->\n        (0, 1, 2, 3), (4, 5, 6, 7), (8, None, None, None)\n    \"\"\"", "\n", "it", "=", "iter", "(", "iterable", ")", "\n", "while", "True", ":", "\n", "        ", "values", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "n", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "value", "=", "next", "(", "it", ")", "\n", "", "except", "StopIteration", ":", "\n", "                ", "values", ".", "extend", "(", "[", "fillvalue", "]", "*", "(", "n", "-", "len", "(", "values", ")", ")", ")", "\n", "yield", "tuple", "(", "values", ")", "\n", "return", "\n", "", "values", ".", "append", "(", "value", ")", "\n", "", "yield", "tuple", "(", "values", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common._get_base_config_dir": [[20, 25], ["os.path.join", "os.path.dirname", "os.path.realpath"], "function", ["None"], ["def", "_get_base_config_dir", "(", ")", ":", "\n", "    ", "\"\"\"\n    Return the base directory for configurations\n    \"\"\"", "\n", "return", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "realpath", "(", "__file__", ")", ")", ",", "\"..\"", ",", "_BASE_CONFIG_DIR", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common._get_evolution_config_dir": [[27, 32], ["os.path.join", "common._get_base_config_dir"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common._get_base_config_dir"], ["", "def", "_get_evolution_config_dir", "(", ")", ":", "\n", "    ", "\"\"\"\n    Return the base directory for evolution configurations\n    \"\"\"", "\n", "return", "os", ".", "path", ".", "join", "(", "_get_base_config_dir", "(", ")", ",", "_EVOLUTION_CONFIG_SUB_DIR", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common._get_hrnet_config_dir": [[34, 39], ["os.path.join", "common._get_base_config_dir"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common._get_base_config_dir"], ["", "def", "_get_hrnet_config_dir", "(", ")", ":", "\n", "    ", "\"\"\"\n    Return the base directory for HRNet configurations\n    \"\"\"", "\n", "return", "os", ".", "path", ".", "join", "(", "_get_base_config_dir", "(", ")", ",", "_HRNET_CONFIG_SUB_DIR", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common._get_quick_schedules_config_dir": [[41, 46], ["os.path.join", "common._get_base_config_dir"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common._get_base_config_dir"], ["", "def", "_get_quick_schedules_config_dir", "(", ")", ":", "\n", "    ", "\"\"\"\n    Return the base directory for quick schedules configurations\n    \"\"\"", "\n", "return", "os", ".", "path", ".", "join", "(", "_get_base_config_dir", "(", ")", ",", "_QUICK_SCHEDULES_CONFIG_SUB_DIR", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common._collect_config_files": [[48, 66], ["common._get_base_config_dir", "os.listdir", "os.path.join", "os.path.splitext", "entry.startswith", "os.path.relpath", "results.append", "os.path.isfile"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common._get_base_config_dir"], ["", "def", "_collect_config_files", "(", "config_dir", ")", ":", "\n", "    ", "\"\"\"\n    Collect all configuration files (i.e. densepose_*.yaml) directly in the specified directory\n    \"\"\"", "\n", "start", "=", "_get_base_config_dir", "(", ")", "\n", "results", "=", "[", "]", "\n", "for", "entry", "in", "os", ".", "listdir", "(", "config_dir", ")", ":", "\n", "        ", "path", "=", "os", ".", "path", ".", "join", "(", "config_dir", ",", "entry", ")", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "path", ")", ":", "\n", "            ", "continue", "\n", "", "_", ",", "ext", "=", "os", ".", "path", ".", "splitext", "(", "entry", ")", "\n", "if", "ext", "!=", "_CONFIG_FILE_EXT", ":", "\n", "            ", "continue", "\n", "", "if", "entry", ".", "startswith", "(", "_BASE_CONFIG_FILE_PREFIX", ")", ":", "\n", "            ", "continue", "\n", "", "config_file", "=", "os", ".", "path", ".", "relpath", "(", "path", ",", "start", ")", "\n", "results", ".", "append", "(", "config_file", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common.get_config_files": [[68, 73], ["common._collect_config_files", "common._get_base_config_dir"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common._collect_config_files", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common._get_base_config_dir"], ["", "def", "get_config_files", "(", ")", ":", "\n", "    ", "\"\"\"\n    Get all the configuration files (relative to the base configuration directory)\n    \"\"\"", "\n", "return", "_collect_config_files", "(", "_get_base_config_dir", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common.get_evolution_config_files": [[75, 80], ["common._collect_config_files", "common._get_evolution_config_dir"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common._collect_config_files", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common._get_evolution_config_dir"], ["", "def", "get_evolution_config_files", "(", ")", ":", "\n", "    ", "\"\"\"\n    Get all the evolution configuration files (relative to the base configuration directory)\n    \"\"\"", "\n", "return", "_collect_config_files", "(", "_get_evolution_config_dir", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common.get_hrnet_config_files": [[82, 87], ["common._collect_config_files", "common._get_hrnet_config_dir"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common._collect_config_files", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common._get_hrnet_config_dir"], ["", "def", "get_hrnet_config_files", "(", ")", ":", "\n", "    ", "\"\"\"\n    Get all the HRNet configuration files (relative to the base configuration directory)\n    \"\"\"", "\n", "return", "_collect_config_files", "(", "_get_hrnet_config_dir", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common.get_quick_schedules_config_files": [[89, 94], ["common._collect_config_files", "common._get_quick_schedules_config_dir"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common._collect_config_files", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common._get_quick_schedules_config_dir"], ["", "def", "get_quick_schedules_config_files", "(", ")", ":", "\n", "    ", "\"\"\"\n    Get all the quick schedules configuration files (relative to the base configuration directory)\n    \"\"\"", "\n", "return", "_collect_config_files", "(", "_get_quick_schedules_config_dir", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common._get_model_config": [[96, 108], ["detectron2.config.get_cfg", "densepose.add_densepose_config", "os.path.join", "detectron2.config.get_cfg.merge_from_file", "common._get_base_config_dir", "torch.cuda.is_available"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.config.add_densepose_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common._get_base_config_dir"], ["", "def", "_get_model_config", "(", "config_file", ")", ":", "\n", "    ", "\"\"\"\n    Load and return the configuration from the specified file (relative to the base configuration\n    directory)\n    \"\"\"", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "add_densepose_config", "(", "cfg", ")", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "_get_base_config_dir", "(", ")", ",", "config_file", ")", "\n", "cfg", ".", "merge_from_file", "(", "path", ")", "\n", "if", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "cfg", ".", "MODEL_DEVICE", "=", "\"cpu\"", "\n", "", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common.get_model": [[110, 116], ["common._get_model_config", "detectron2.modeling.build_model"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common._get_model_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model"], ["", "def", "get_model", "(", "config_file", ")", ":", "\n", "    ", "\"\"\"\n    Get the model from the specified file (relative to the base configuration directory)\n    \"\"\"", "\n", "cfg", "=", "_get_model_config", "(", "config_file", ")", "\n", "return", "build_model", "(", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common.setup": [[118, 125], ["common._get_model_config", "_get_model_config.freeze", "detectron2.engine.default_setup"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common._get_model_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.default_setup"], ["", "def", "setup", "(", "config_file", ")", ":", "\n", "    ", "\"\"\"\n    Setup the configuration from the specified file (relative to the base configuration directory)\n    \"\"\"", "\n", "cfg", "=", "_get_model_config", "(", "config_file", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "default_setup", "(", "cfg", ",", "{", "}", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_frame_selector.TestFrameSelector.test_frame_selector_random_k_1": [[10, 19], ["random.seed", "densepose.data.video.RandomKFramesSelector", "list", "densepose.data.video.RandomKFramesSelector.", "test_frame_selector.TestFrameSelector.assertEqual", "range"], "methods", ["None"], ["    ", "def", "test_frame_selector_random_k_1", "(", "self", ")", ":", "\n", "        ", "_SEED", "=", "43", "\n", "_K", "=", "4", "\n", "random", ".", "seed", "(", "_SEED", ")", "\n", "selector", "=", "RandomKFramesSelector", "(", "_K", ")", "\n", "frame_tss", "=", "list", "(", "range", "(", "0", ",", "20", ",", "2", ")", ")", "\n", "_SELECTED_GT", "=", "[", "0", ",", "8", ",", "4", ",", "6", "]", "\n", "selected", "=", "selector", "(", "frame_tss", ")", "\n", "self", ".", "assertEqual", "(", "_SELECTED_GT", ",", "selected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_frame_selector.TestFrameSelector.test_frame_selector_random_k_2": [[20, 29], ["random.seed", "densepose.data.video.RandomKFramesSelector", "list", "densepose.data.video.RandomKFramesSelector.", "test_frame_selector.TestFrameSelector.assertEqual", "range"], "methods", ["None"], ["", "def", "test_frame_selector_random_k_2", "(", "self", ")", ":", "\n", "        ", "_SEED", "=", "43", "\n", "_K", "=", "10", "\n", "random", ".", "seed", "(", "_SEED", ")", "\n", "selector", "=", "RandomKFramesSelector", "(", "_K", ")", "\n", "frame_tss", "=", "list", "(", "range", "(", "0", ",", "6", ",", "2", ")", ")", "\n", "_SELECTED_GT", "=", "[", "0", ",", "2", ",", "4", "]", "\n", "selected", "=", "selector", "(", "frame_tss", ")", "\n", "self", ".", "assertEqual", "(", "_SELECTED_GT", ",", "selected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_frame_selector.TestFrameSelector.test_frame_selector_first_k_1": [[30, 37], ["densepose.data.video.FirstKFramesSelector", "list", "densepose.data.video.FirstKFramesSelector.", "test_frame_selector.TestFrameSelector.assertEqual", "range"], "methods", ["None"], ["", "def", "test_frame_selector_first_k_1", "(", "self", ")", ":", "\n", "        ", "_K", "=", "4", "\n", "selector", "=", "FirstKFramesSelector", "(", "_K", ")", "\n", "frame_tss", "=", "list", "(", "range", "(", "0", ",", "20", ",", "2", ")", ")", "\n", "_SELECTED_GT", "=", "frame_tss", "[", ":", "_K", "]", "\n", "selected", "=", "selector", "(", "frame_tss", ")", "\n", "self", ".", "assertEqual", "(", "_SELECTED_GT", ",", "selected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_frame_selector.TestFrameSelector.test_frame_selector_first_k_2": [[38, 45], ["densepose.data.video.FirstKFramesSelector", "list", "densepose.data.video.FirstKFramesSelector.", "test_frame_selector.TestFrameSelector.assertEqual", "range"], "methods", ["None"], ["", "def", "test_frame_selector_first_k_2", "(", "self", ")", ":", "\n", "        ", "_K", "=", "10", "\n", "selector", "=", "FirstKFramesSelector", "(", "_K", ")", "\n", "frame_tss", "=", "list", "(", "range", "(", "0", ",", "6", ",", "2", ")", ")", "\n", "_SELECTED_GT", "=", "frame_tss", "[", ":", "_K", "]", "\n", "selected", "=", "selector", "(", "frame_tss", ")", "\n", "self", ".", "assertEqual", "(", "_SELECTED_GT", ",", "selected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_frame_selector.TestFrameSelector.test_frame_selector_last_k_1": [[46, 53], ["densepose.data.video.LastKFramesSelector", "list", "densepose.data.video.LastKFramesSelector.", "test_frame_selector.TestFrameSelector.assertEqual", "range"], "methods", ["None"], ["", "def", "test_frame_selector_last_k_1", "(", "self", ")", ":", "\n", "        ", "_K", "=", "4", "\n", "selector", "=", "LastKFramesSelector", "(", "_K", ")", "\n", "frame_tss", "=", "list", "(", "range", "(", "0", ",", "20", ",", "2", ")", ")", "\n", "_SELECTED_GT", "=", "frame_tss", "[", "-", "_K", ":", "]", "\n", "selected", "=", "selector", "(", "frame_tss", ")", "\n", "self", ".", "assertEqual", "(", "_SELECTED_GT", ",", "selected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_frame_selector.TestFrameSelector.test_frame_selector_last_k_2": [[54, 61], ["densepose.data.video.LastKFramesSelector", "list", "densepose.data.video.LastKFramesSelector.", "test_frame_selector.TestFrameSelector.assertEqual", "range"], "methods", ["None"], ["", "def", "test_frame_selector_last_k_2", "(", "self", ")", ":", "\n", "        ", "_K", "=", "10", "\n", "selector", "=", "LastKFramesSelector", "(", "_K", ")", "\n", "frame_tss", "=", "list", "(", "range", "(", "0", ",", "6", ",", "2", ")", ")", "\n", "_SELECTED_GT", "=", "frame_tss", "[", "-", "_K", ":", "]", "\n", "selected", "=", "selector", "(", "frame_tss", ")", "\n", "self", ".", "assertEqual", "(", "_SELECTED_GT", ",", "selected", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_e2e.ModelE2ETest.setUp": [[30, 32], ["common.get_model"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common.get_model"], ["def", "setUp", "(", "self", ")", ":", "\n", "        ", "self", ".", "model", "=", "get_model", "(", "self", ".", "CONFIG_PATH", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_e2e.ModelE2ETest._test_eval": [[33, 37], ["test_model_e2e.ModelE2ETest.model.eval", "test_model_e2e.ModelE2ETest.model", "test_model_e2e.make_model_inputs", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_e2e.make_model_inputs"], ["", "def", "_test_eval", "(", "self", ",", "sizes", ")", ":", "\n", "        ", "inputs", "=", "[", "make_model_inputs", "(", "torch", ".", "rand", "(", "3", ",", "size", "[", "0", "]", ",", "size", "[", "1", "]", ")", ")", "for", "size", "in", "sizes", "]", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "self", ".", "model", "(", "inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_e2e.DensePoseRCNNE2ETest.test_empty_data": [[42, 44], ["test_model_e2e.DensePoseRCNNE2ETest._test_eval"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_e2e.ModelE2ETest._test_eval"], ["def", "test_empty_data", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_eval", "(", "[", "(", "200", ",", "250", ")", ",", "(", "200", ",", "249", ")", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_e2e.make_model_inputs": [[12, 17], ["None"], "function", ["None"], ["def", "make_model_inputs", "(", "image", ",", "instances", "=", "None", ")", ":", "\n", "    ", "if", "instances", "is", "None", ":", "\n", "        ", "return", "{", "\"image\"", ":", "image", "}", "\n", "\n", "", "return", "{", "\"image\"", ":", "image", ",", "\"instances\"", ":", "instances", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_e2e.make_empty_instances": [[19, 25], ["detectron2.structures.Instances", "detectron2.structures.Boxes", "torch.tensor().to", "detectron2.structures.BitMasks", "torch.rand", "torch.rand", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["", "def", "make_empty_instances", "(", "h", ",", "w", ")", ":", "\n", "    ", "instances", "=", "Instances", "(", "(", "h", ",", "w", ")", ")", "\n", "instances", ".", "gt_boxes", "=", "Boxes", "(", "torch", ".", "rand", "(", "0", ",", "4", ")", ")", "\n", "instances", ".", "gt_classes", "=", "torch", ".", "tensor", "(", "[", "]", ")", ".", "to", "(", "dtype", "=", "torch", ".", "int64", ")", "\n", "instances", ".", "gt_masks", "=", "BitMasks", "(", "torch", ".", "rand", "(", "0", ",", "h", ",", "w", ")", ")", "\n", "return", "instances", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_setup.TestSetup._test_setup": [[15, 17], ["common.setup"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.setup"], ["    ", "def", "_test_setup", "(", "self", ",", "config_file", ")", ":", "\n", "        ", "setup", "(", "config_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_setup.TestSetup.test_setup_configs": [[18, 22], ["common.get_config_files", "test_setup.TestSetup._test_setup"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common.get_config_files", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_setup.TestSetup._test_setup"], ["", "def", "test_setup_configs", "(", "self", ")", ":", "\n", "        ", "config_files", "=", "get_config_files", "(", ")", "\n", "for", "config_file", "in", "config_files", ":", "\n", "            ", "self", ".", "_test_setup", "(", "config_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_setup.TestSetup.test_setup_evolution_configs": [[23, 27], ["common.get_evolution_config_files", "test_setup.TestSetup._test_setup"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common.get_evolution_config_files", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_setup.TestSetup._test_setup"], ["", "", "def", "test_setup_evolution_configs", "(", "self", ")", ":", "\n", "        ", "config_files", "=", "get_evolution_config_files", "(", ")", "\n", "for", "config_file", "in", "config_files", ":", "\n", "            ", "self", ".", "_test_setup", "(", "config_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_setup.TestSetup.test_setup_hrnet_configs": [[28, 32], ["common.get_hrnet_config_files", "test_setup.TestSetup._test_setup"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common.get_hrnet_config_files", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_setup.TestSetup._test_setup"], ["", "", "def", "test_setup_hrnet_configs", "(", "self", ")", ":", "\n", "        ", "config_files", "=", "get_hrnet_config_files", "(", ")", "\n", "for", "config_file", "in", "config_files", ":", "\n", "            ", "self", ".", "_test_setup", "(", "config_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_setup.TestSetup.test_setup_quick_schedules_configs": [[33, 37], ["common.get_quick_schedules_config_files", "test_setup.TestSetup._test_setup"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.common.get_quick_schedules_config_files", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_setup.TestSetup._test_setup"], ["", "", "def", "test_setup_quick_schedules_configs", "(", "self", ")", ":", "\n", "        ", "config_files", "=", "get_quick_schedules_config_files", "(", ")", "\n", "for", "config_file", "in", "config_files", ":", "\n", "            ", "self", ".", "_test_setup", "(", "config_file", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_structures.TestStructures.test_normalized_coords_transform": [[9, 26], ["densepose.data.structures.normalized_coords_transform", "test_structures.TestStructures.assertEqual", "test_structures.TestStructures.assertEqual", "test_structures.TestStructures.assertEqual", "test_structures.TestStructures.assertEqual", "densepose.data.structures.normalized_coords_transform.", "densepose.data.structures.normalized_coords_transform.", "densepose.data.structures.normalized_coords_transform.", "densepose.data.structures.normalized_coords_transform."], "methods", ["None"], ["    ", "def", "test_normalized_coords_transform", "(", "self", ")", ":", "\n", "        ", "bbox", "=", "(", "32", ",", "24", ",", "288", ",", "216", ")", "\n", "x0", ",", "y0", ",", "w", ",", "h", "=", "bbox", "\n", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "=", "x0", ",", "y0", ",", "x0", "+", "w", ",", "y0", "+", "h", "\n", "f", "=", "normalized_coords_transform", "(", "*", "bbox", ")", "\n", "# Top-left", "\n", "expected_p", ",", "actual_p", "=", "(", "-", "1", ",", "-", "1", ")", ",", "f", "(", "(", "xmin", ",", "ymin", ")", ")", "\n", "self", ".", "assertEqual", "(", "expected_p", ",", "actual_p", ")", "\n", "# Top-right", "\n", "expected_p", ",", "actual_p", "=", "(", "1", ",", "-", "1", ")", ",", "f", "(", "(", "xmax", ",", "ymin", ")", ")", "\n", "self", ".", "assertEqual", "(", "expected_p", ",", "actual_p", ")", "\n", "# Bottom-left", "\n", "expected_p", ",", "actual_p", "=", "(", "-", "1", ",", "1", ")", ",", "f", "(", "(", "xmin", ",", "ymax", ")", ")", "\n", "self", ".", "assertEqual", "(", "expected_p", ",", "actual_p", ")", "\n", "# Bottom-right", "\n", "expected_p", ",", "actual_p", "=", "(", "1", ",", "1", ")", ",", "f", "(", "(", "xmax", ",", "ymax", ")", ")", "\n", "self", ".", "assertEqual", "(", "expected_p", ",", "actual_p", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_video_keyframe_dataset.TestVideoKeyframeDataset.test_read_keyframes_all": [[56, 66], ["test_video_keyframe_dataset.TestVideoKeyframeDataset.assertTrue", "test_video_keyframe_dataset.temp_video", "densepose.data.video.VideoKeyframeDataset", "test_video_keyframe_dataset.TestVideoKeyframeDataset.assertEqual", "test_video_keyframe_dataset.TestVideoKeyframeDataset.assertEqual", "test_video_keyframe_dataset.TestVideoKeyframeDataset.assertEqual", "len", "torch.Size"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_video_keyframe_dataset.temp_video"], ["    ", "def", "test_read_keyframes_all", "(", "self", ")", ":", "\n", "        ", "with", "temp_video", "(", "60", ",", "300", ",", "300", ",", "5", ",", "video_codec", "=", "\"mpeg4\"", ")", "as", "(", "fname", ",", "data", ")", ":", "\n", "            ", "video_list", "=", "[", "fname", "]", "\n", "dataset", "=", "VideoKeyframeDataset", "(", "video_list", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "dataset", ")", ",", "1", ")", "\n", "data1", "=", "dataset", "[", "0", "]", "\n", "self", ".", "assertEqual", "(", "data1", ".", "shape", ",", "torch", ".", "Size", "(", "(", "5", ",", "300", ",", "300", ",", "3", ")", ")", ")", "\n", "self", ".", "assertEqual", "(", "data1", ".", "dtype", ",", "torch", ".", "uint8", ")", "\n", "return", "\n", "", "self", ".", "assertTrue", "(", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_video_keyframe_dataset.TestVideoKeyframeDataset.test_read_keyframes_with_selector": [[67, 79], ["test_video_keyframe_dataset.TestVideoKeyframeDataset.assertTrue", "test_video_keyframe_dataset.temp_video", "random.seed", "densepose.data.video.RandomKFramesSelector", "densepose.data.video.VideoKeyframeDataset", "test_video_keyframe_dataset.TestVideoKeyframeDataset.assertEqual", "test_video_keyframe_dataset.TestVideoKeyframeDataset.assertEqual", "test_video_keyframe_dataset.TestVideoKeyframeDataset.assertEqual", "len", "torch.Size"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_video_keyframe_dataset.temp_video"], ["", "def", "test_read_keyframes_with_selector", "(", "self", ")", ":", "\n", "        ", "with", "temp_video", "(", "60", ",", "300", ",", "300", ",", "5", ",", "video_codec", "=", "\"mpeg4\"", ")", "as", "(", "fname", ",", "data", ")", ":", "\n", "            ", "video_list", "=", "[", "fname", "]", "\n", "random", ".", "seed", "(", "0", ")", "\n", "frame_selector", "=", "RandomKFramesSelector", "(", "3", ")", "\n", "dataset", "=", "VideoKeyframeDataset", "(", "video_list", ",", "frame_selector", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "dataset", ")", ",", "1", ")", "\n", "data1", "=", "dataset", "[", "0", "]", "\n", "self", ".", "assertEqual", "(", "data1", ".", "shape", ",", "torch", ".", "Size", "(", "(", "3", ",", "300", ",", "300", ",", "3", ")", ")", ")", "\n", "self", ".", "assertEqual", "(", "data1", ".", "dtype", ",", "torch", ".", "uint8", ")", "\n", "return", "\n", "", "self", ".", "assertTrue", "(", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_video_keyframe_dataset.TestVideoKeyframeDataset.test_read_keyframes_with_selector_with_transform": [[80, 93], ["test_video_keyframe_dataset.TestVideoKeyframeDataset.assertTrue", "test_video_keyframe_dataset.temp_video", "random.seed", "densepose.data.video.RandomKFramesSelector", "densepose.data.transform.ImageResizeTransform", "densepose.data.video.VideoKeyframeDataset", "test_video_keyframe_dataset.TestVideoKeyframeDataset.assertEqual", "test_video_keyframe_dataset.TestVideoKeyframeDataset.assertEqual", "test_video_keyframe_dataset.TestVideoKeyframeDataset.assertEqual", "len", "torch.Size"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_video_keyframe_dataset.temp_video"], ["", "def", "test_read_keyframes_with_selector_with_transform", "(", "self", ")", ":", "\n", "        ", "with", "temp_video", "(", "60", ",", "300", ",", "300", ",", "5", ",", "video_codec", "=", "\"mpeg4\"", ")", "as", "(", "fname", ",", "data", ")", ":", "\n", "            ", "video_list", "=", "[", "fname", "]", "\n", "random", ".", "seed", "(", "0", ")", "\n", "frame_selector", "=", "RandomKFramesSelector", "(", "1", ")", "\n", "transform", "=", "ImageResizeTransform", "(", ")", "\n", "dataset", "=", "VideoKeyframeDataset", "(", "video_list", ",", "frame_selector", ",", "transform", ")", "\n", "data1", "=", "dataset", "[", "0", "]", "\n", "self", ".", "assertEqual", "(", "len", "(", "dataset", ")", ",", "1", ")", "\n", "self", ".", "assertEqual", "(", "data1", ".", "shape", ",", "torch", ".", "Size", "(", "(", "1", ",", "3", ",", "800", ",", "800", ")", ")", ")", "\n", "self", ".", "assertEqual", "(", "data1", ".", "dtype", ",", "torch", ".", "float32", ")", "\n", "return", "\n", "", "self", ".", "assertTrue", "(", "False", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_video_keyframe_dataset._create_video_frames": [[21, 30], ["torch.meshgrid", "range", "torch.stack", "torch.linspace", "torch.linspace", "data.append", "float", "torch.exp", "d.unsqueeze().repeat().byte", "float", "d.unsqueeze().repeat", "d.unsqueeze"], "function", ["None"], ["", "def", "_create_video_frames", "(", "num_frames", ",", "height", ",", "width", ")", ":", "\n", "    ", "y", ",", "x", "=", "torch", ".", "meshgrid", "(", "torch", ".", "linspace", "(", "-", "2", ",", "2", ",", "height", ")", ",", "torch", ".", "linspace", "(", "-", "2", ",", "2", ",", "width", ")", ")", "\n", "data", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_frames", ")", ":", "\n", "        ", "xc", "=", "float", "(", "i", ")", "/", "num_frames", "\n", "yc", "=", "1", "-", "float", "(", "i", ")", "/", "(", "2", "*", "num_frames", ")", "\n", "d", "=", "torch", ".", "exp", "(", "-", "(", "(", "x", "-", "xc", ")", "**", "2", "+", "(", "y", "-", "yc", ")", "**", "2", ")", "/", "2", ")", "*", "255", "\n", "data", ".", "append", "(", "d", ".", "unsqueeze", "(", "2", ")", ".", "repeat", "(", "1", ",", "1", ",", "3", ")", ".", "byte", "(", ")", ")", "\n", "", "return", "torch", ".", "stack", "(", "data", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_video_keyframe_dataset.temp_video": [[33, 52], ["test_video_keyframe_dataset._create_video_frames", "os.unlink", "tempfile.NamedTemporaryFile", "f.close", "torchvision.write_video", "ValueError", "ValueError"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_video_keyframe_dataset._create_video_frames", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.TensorboardXWriter.close"], ["", "@", "contextlib", ".", "contextmanager", "\n", "def", "temp_video", "(", "num_frames", ",", "height", ",", "width", ",", "fps", ",", "lossless", "=", "False", ",", "video_codec", "=", "None", ",", "options", "=", "None", ")", ":", "\n", "    ", "if", "lossless", ":", "\n", "        ", "if", "video_codec", "is", "not", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"video_codec can't be specified together with lossless\"", ")", "\n", "", "if", "options", "is", "not", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"options can't be specified together with lossless\"", ")", "\n", "", "video_codec", "=", "\"libx264rgb\"", "\n", "options", "=", "{", "\"crf\"", ":", "\"0\"", "}", "\n", "", "if", "video_codec", "is", "None", ":", "\n", "        ", "video_codec", "=", "\"libx264\"", "\n", "", "if", "options", "is", "None", ":", "\n", "        ", "options", "=", "{", "}", "\n", "", "data", "=", "_create_video_frames", "(", "num_frames", ",", "height", ",", "width", ")", "\n", "with", "tempfile", ".", "NamedTemporaryFile", "(", "suffix", "=", "\".mp4\"", ")", "as", "f", ":", "\n", "        ", "f", ".", "close", "(", ")", "\n", "io", ".", "write_video", "(", "f", ".", "name", ",", "data", ",", "fps", "=", "fps", ",", "video_codec", "=", "video_codec", ",", "options", "=", "options", ")", "\n", "yield", "f", ".", "name", ",", "data", "\n", "", "os", ".", "unlink", "(", "f", ".", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_packaging.TestProjects.test_import": [[8, 16], ["None"], "methods", ["None"], ["    ", "def", "test_import", "(", "self", ")", ":", "\n", "        ", "from", "detectron2", ".", "projects", "import", "point_rend", "\n", "\n", "_", "=", "point_rend", ".", "add_pointrend_config", "\n", "\n", "import", "detectron2", ".", "projects", ".", "deeplab", "as", "deeplab", "\n", "\n", "_", "=", "deeplab", ".", "add_deeplab_config", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_packaging.TestCollectEnv.test": [[23, 25], ["detectron2.utils.collect_env.collect_env_info"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect_env.collect_env_info"], ["    ", "def", "test", "(", "self", ")", ":", "\n", "        ", "_", "=", "collect_env_info", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_zoo.TestModelZoo.test_get_returns_model": [[12, 16], ["detectron2.model_zoo.get", "test_model_zoo.TestModelZoo.assertIsInstance", "test_model_zoo.TestModelZoo.assertIsInstance"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["    ", "def", "test_get_returns_model", "(", "self", ")", ":", "\n", "        ", "model", "=", "model_zoo", ".", "get", "(", "\"Misc/scratch_mask_rcnn_R_50_FPN_3x_gn.yaml\"", ",", "trained", "=", "False", ")", "\n", "self", ".", "assertIsInstance", "(", "model", ",", "GeneralizedRCNN", ")", "\n", "self", ".", "assertIsInstance", "(", "model", ".", "backbone", ",", "FPN", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_zoo.TestModelZoo.test_get_invalid_model": [[17, 19], ["test_model_zoo.TestModelZoo.assertRaises"], "methods", ["None"], ["", "def", "test_get_invalid_model", "(", "self", ")", ":", "\n", "        ", "self", ".", "assertRaises", "(", "RuntimeError", ",", "model_zoo", ".", "get", ",", "\"Invalid/config.yaml\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_zoo.TestModelZoo.test_get_url": [[20, 25], ["detectron2.model_zoo.get_checkpoint_url", "test_model_zoo.TestModelZoo.assertEqual"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get_checkpoint_url"], ["", "def", "test_get_url", "(", "self", ")", ":", "\n", "        ", "url", "=", "model_zoo", ".", "get_checkpoint_url", "(", "\"Misc/scratch_mask_rcnn_R_50_FPN_3x_gn.yaml\"", ")", "\n", "self", ".", "assertEqual", "(", "\n", "url", ",", "\n", "\"https://dl.fbaipublicfiles.com/detectron2/Misc/scratch_mask_rcnn_R_50_FPN_3x_gn/138602908/model_final_01ca85.pkl\"", ",", "# noqa", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_analysis.RetinaNetTest.setUp": [[26, 28], ["test_model_analysis.get_model_zoo"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_analysis.get_model_zoo"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "self", ".", "model", "=", "get_model_zoo", "(", "\"COCO-Detection/retinanet_R_50_FPN_1x.yaml\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_analysis.RetinaNetTest.test_flop": [[29, 34], ["detectron2.utils.analysis.flop_count_operators", "test_model_analysis.RetinaNetTest.assertTrue", "int", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.analysis.flop_count_operators"], ["", "def", "test_flop", "(", "self", ")", ":", "\n", "# RetinaNet supports flop-counting with random inputs", "\n", "        ", "inputs", "=", "[", "{", "\"image\"", ":", "torch", ".", "rand", "(", "3", ",", "800", ",", "800", ")", "}", "]", "\n", "res", "=", "flop_count_operators", "(", "self", ".", "model", ",", "inputs", ")", "\n", "self", ".", "assertTrue", "(", "int", "(", "res", "[", "\"conv\"", "]", ")", ",", "146", ")", "# 146B flops", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_analysis.RetinaNetTest.test_param_count": [[35, 39], ["detectron2.utils.analysis.parameter_count", "test_model_analysis.RetinaNetTest.assertTrue", "test_model_analysis.RetinaNetTest.assertTrue"], "methods", ["None"], ["", "def", "test_param_count", "(", "self", ")", ":", "\n", "        ", "res", "=", "parameter_count", "(", "self", ".", "model", ")", "\n", "self", ".", "assertTrue", "(", "res", "[", "\"\"", "]", ",", "37915572", ")", "\n", "self", ".", "assertTrue", "(", "res", "[", "\"backbone\"", "]", ",", "31452352", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_analysis.FasterRCNNTest.setUp": [[42, 44], ["test_model_analysis.get_model_zoo"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_analysis.get_model_zoo"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "self", ".", "model", "=", "get_model_zoo", "(", "\"COCO-Detection/faster_rcnn_R_50_FPN_1x.yaml\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_analysis.FasterRCNNTest.test_flop": [[45, 54], ["detectron2.utils.analysis.flop_count_operators", "test_model_analysis.FasterRCNNTest.assertTrue", "int", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.analysis.flop_count_operators"], ["", "def", "test_flop", "(", "self", ")", ":", "\n", "# Faster R-CNN supports flop-counting with random inputs", "\n", "        ", "inputs", "=", "[", "{", "\"image\"", ":", "torch", ".", "rand", "(", "3", ",", "800", ",", "800", ")", "}", "]", "\n", "res", "=", "flop_count_operators", "(", "self", ".", "model", ",", "inputs", ")", "\n", "\n", "# This only checks flops for backbone & proposal generator", "\n", "# Flops for box head is not conv, and depends on #proposals, which is", "\n", "# almost 0 for random inputs.", "\n", "self", ".", "assertTrue", "(", "int", "(", "res", "[", "\"conv\"", "]", ")", ",", "117", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_analysis.FasterRCNNTest.test_param_count": [[55, 59], ["detectron2.utils.analysis.parameter_count", "test_model_analysis.FasterRCNNTest.assertTrue", "test_model_analysis.FasterRCNNTest.assertTrue"], "methods", ["None"], ["", "def", "test_param_count", "(", "self", ")", ":", "\n", "        ", "res", "=", "parameter_count", "(", "self", ".", "model", ")", "\n", "self", ".", "assertTrue", "(", "res", "[", "\"\"", "]", ",", "41699936", ")", "\n", "self", ".", "assertTrue", "(", "res", "[", "\"backbone\"", "]", ",", "26799296", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_model_analysis.get_model_zoo": [[13, 23], ["detectron2.get_config_file", "detectron2.config.get_cfg", "detectron2.config.get_cfg.merge_from_file", "detectron2.modeling.build_model", "torch.cuda.is_available"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get_config_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model"], ["def", "get_model_zoo", "(", "config_path", ")", ":", "\n", "    ", "\"\"\"\n    Like model_zoo.get, but do not load any weights (even pretrained)\n    \"\"\"", "\n", "cfg_file", "=", "model_zoo", ".", "get_config_file", "(", "config_path", ")", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "cfg_file", ")", "\n", "if", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "cfg", ".", "MODEL", ".", "DEVICE", "=", "\"cpu\"", "\n", "", "return", "build_model", "(", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_config.TestConfigVersioning.test_upgrade_downgrade_consistency": [[27, 35], ["detectron2.config.get_cfg", "detectron2.config.downgrade_config", "detectron2.config.upgrade_config", "test_config.TestConfigVersioning.assertTrue"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat.downgrade_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.compat.upgrade_config"], ["    ", "def", "test_upgrade_downgrade_consistency", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "# check that custom is preserved", "\n", "cfg", ".", "USER_CUSTOM", "=", "1", "\n", "\n", "down", "=", "downgrade_config", "(", "cfg", ",", "to_version", "=", "0", ")", "\n", "up", "=", "upgrade_config", "(", "down", ")", "\n", "self", ".", "assertTrue", "(", "up", "==", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_config.TestConfigVersioning._merge_cfg_str": [[36, 45], ["tempfile.NamedTemporaryFile", "tempfile.NamedTemporaryFile.write", "tempfile.NamedTemporaryFile.close", "cfg.merge_from_file", "os.remove"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.TensorboardXWriter.close", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.instances.Instances.remove"], ["", "def", "_merge_cfg_str", "(", "self", ",", "cfg", ",", "merge_str", ")", ":", "\n", "        ", "f", "=", "tempfile", ".", "NamedTemporaryFile", "(", "mode", "=", "\"w\"", ",", "suffix", "=", "\".yaml\"", ",", "delete", "=", "False", ")", "\n", "try", ":", "\n", "            ", "f", ".", "write", "(", "merge_str", ")", "\n", "f", ".", "close", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "f", ".", "name", ")", "\n", "", "finally", ":", "\n", "            ", "os", ".", "remove", "(", "f", ".", "name", ")", "\n", "", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_config.TestConfigVersioning.test_auto_upgrade": [[46, 55], ["detectron2.config.get_cfg", "test_config.TestConfigVersioning._merge_cfg_str", "test_config.TestConfigVersioning.assertEqual", "test_config.TestConfigVersioning.assertEqual"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_config.TestConfigVersioning._merge_cfg_str"], ["", "def", "test_auto_upgrade", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "latest_ver", "=", "cfg", ".", "VERSION", "\n", "cfg", ".", "USER_CUSTOM", "=", "1", "\n", "\n", "self", ".", "_merge_cfg_str", "(", "cfg", ",", "_V0_CFG", ")", "\n", "\n", "self", ".", "assertEqual", "(", "cfg", ".", "MODEL", ".", "RPN", ".", "HEAD_NAME", ",", "\"TEST\"", ")", "\n", "self", ".", "assertEqual", "(", "cfg", ".", "VERSION", ",", "latest_ver", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_config.TestConfigVersioning.test_guess_v1": [[56, 61], ["detectron2.config.get_cfg", "test_config.TestConfigVersioning._merge_cfg_str", "test_config.TestConfigVersioning.assertEqual"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_config.TestConfigVersioning._merge_cfg_str"], ["", "def", "test_guess_v1", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "latest_ver", "=", "cfg", ".", "VERSION", "\n", "self", ".", "_merge_cfg_str", "(", "cfg", ",", "_V1_CFG", ")", "\n", "self", ".", "assertEqual", "(", "cfg", ".", "VERSION", ",", "latest_ver", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_config._TestClassA.__init__": [[64, 73], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "@", "configurable", "\n", "def", "__init__", "(", "self", ",", "arg1", ",", "arg2", ",", "arg3", "=", "3", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "arg1", "=", "arg1", "\n", "self", ".", "arg2", "=", "arg2", "\n", "self", ".", "arg3", "=", "arg3", "\n", "assert", "arg1", "==", "1", "\n", "assert", "arg2", "==", "2", "\n", "assert", "arg3", "==", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_config._TestClassA.from_config": [[74, 78], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "args", "=", "{", "\"arg1\"", ":", "cfg", ".", "ARG1", ",", "\"arg2\"", ":", "cfg", ".", "ARG2", "}", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_config._TestClassB.__init__": [[81, 88], ["test_config._TestClassA.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "@", "configurable", "\n", "def", "__init__", "(", "self", ",", "input_shape", ",", "arg1", ",", "arg2", ",", "arg3", "=", "3", ")", ":", "\n", "        ", "\"\"\"\n        Doc of _TestClassB\n        \"\"\"", "\n", "assert", "input_shape", "==", "\"shape\"", "\n", "super", "(", ")", ".", "__init__", "(", "arg1", ",", "arg2", ",", "arg3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_config._TestClassB.from_config": [[89, 94], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "# test extra positional arg in from_config", "\n", "        ", "args", "=", "{", "\"arg1\"", ":", "cfg", ".", "ARG1", ",", "\"arg2\"", ":", "cfg", ".", "ARG2", "}", "\n", "args", "[", "\"input_shape\"", "]", "=", "input_shape", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_config._LegacySubClass.__init__": [[98, 103], ["test_config._TestClassB.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ",", "arg4", "=", "4", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "cfg", ",", "input_shape", ")", "\n", "assert", "self", ".", "arg1", "==", "1", "\n", "assert", "self", ".", "arg2", "==", "2", "\n", "assert", "self", ".", "arg3", "==", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_config._NewSubClassNewInit.__init__": [[107, 113], ["test_config._TestClassB.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "@", "configurable", "\n", "def", "__init__", "(", "self", ",", "input_shape", ",", "arg4", "=", "4", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "input_shape", ",", "**", "kwargs", ")", "\n", "assert", "self", ".", "arg1", "==", "1", "\n", "assert", "self", ".", "arg2", "==", "2", "\n", "assert", "self", ".", "arg3", "==", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_config._LegacySubClassNotCfg.__init__": [[117, 122], ["test_config._TestClassB.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "config", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "config", ",", "input_shape", ")", "\n", "assert", "self", ".", "arg1", "==", "1", "\n", "assert", "self", ".", "arg2", "==", "2", "\n", "assert", "self", ".", "arg3", "==", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_config._TestClassC.from_config": [[125, 131], ["args.update"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update"], ["    ", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ",", "**", "kwargs", ")", ":", "# test extra kwarg overwrite", "\n", "        ", "args", "=", "{", "\"arg1\"", ":", "cfg", ".", "ARG1", ",", "\"arg2\"", ":", "cfg", ".", "ARG2", "}", "\n", "args", "[", "\"input_shape\"", "]", "=", "input_shape", "\n", "args", ".", "update", "(", "kwargs", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_config._TestClassD.__init__": [[134, 138], ["test_config._TestClassA.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "@", "configurable", "\n", "def", "__init__", "(", "self", ",", "input_shape", ":", "ShapeSpec", ",", "arg1", ":", "int", ",", "arg2", ",", "arg3", "=", "3", ")", ":", "\n", "        ", "assert", "input_shape", "==", "\"shape\"", "\n", "super", "(", ")", ".", "__init__", "(", "arg1", ",", "arg2", ",", "arg3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_config.TestConfigurable.testInitWithArgs": [[144, 149], ["test_config._TestClassA", "test_config._TestClassB", "test_config._TestClassC", "test_config._TestClassD"], "methods", ["None"], ["    ", "def", "testInitWithArgs", "(", "self", ")", ":", "\n", "        ", "_", "=", "_TestClassA", "(", "arg1", "=", "1", ",", "arg2", "=", "2", ",", "arg3", "=", "3", ")", "\n", "_", "=", "_TestClassB", "(", "\"shape\"", ",", "arg1", "=", "1", ",", "arg2", "=", "2", ")", "\n", "_", "=", "_TestClassC", "(", "\"shape\"", ",", "arg1", "=", "1", ",", "arg2", "=", "2", ")", "\n", "_", "=", "_TestClassD", "(", "\"shape\"", ",", "arg1", "=", "1", ",", "arg2", "=", "2", ",", "arg3", "=", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_config.TestConfigurable.testPatchedAttr": [[150, 153], ["test_config.TestConfigurable.assertTrue", "test_config.TestConfigurable.assertEqual"], "methods", ["None"], ["", "def", "testPatchedAttr", "(", "self", ")", ":", "\n", "        ", "self", ".", "assertTrue", "(", "\"Doc\"", "in", "_TestClassB", ".", "__init__", ".", "__doc__", ")", "\n", "self", ".", "assertEqual", "(", "_TestClassD", ".", "__init__", ".", "__annotations__", "[", "\"arg1\"", "]", ",", "int", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_config.TestConfigurable.testInitWithCfg": [[154, 178], ["detectron2.config.get_cfg", "test_config._TestClassA", "test_config._TestClassB", "test_config._TestClassC", "test_config._TestClassD", "test_config._LegacySubClass", "test_config._NewSubClassNewInit", "test_config._LegacySubClassNotCfg", "test_config._TestClassA", "test_config._TestClassB", "test_config._TestClassC", "test_config._TestClassD", "test_config._LegacySubClass", "test_config._NewSubClassNewInit", "test_config._LegacySubClassNotCfg", "test_config.TestConfigurable.assertRaises", "test_config._TestClassD"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg"], ["", "def", "testInitWithCfg", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "ARG1", "=", "1", "\n", "cfg", ".", "ARG2", "=", "2", "\n", "cfg", ".", "ARG3", "=", "3", "\n", "_", "=", "_TestClassA", "(", "cfg", ")", "\n", "_", "=", "_TestClassB", "(", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "_", "=", "_TestClassC", "(", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "_", "=", "_TestClassD", "(", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "_", "=", "_LegacySubClass", "(", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "_", "=", "_NewSubClassNewInit", "(", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "_", "=", "_LegacySubClassNotCfg", "(", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "with", "self", ".", "assertRaises", "(", "TypeError", ")", ":", "\n", "# disallow forwarding positional args to __init__ since it's prone to errors", "\n", "            ", "_", "=", "_TestClassD", "(", "cfg", ",", "\"shape\"", ")", "\n", "\n", "# call with kwargs instead", "\n", "", "_", "=", "_TestClassA", "(", "cfg", "=", "cfg", ")", "\n", "_", "=", "_TestClassB", "(", "cfg", "=", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "_", "=", "_TestClassC", "(", "cfg", "=", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "_", "=", "_TestClassD", "(", "cfg", "=", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "_", "=", "_LegacySubClass", "(", "cfg", "=", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "_", "=", "_NewSubClassNewInit", "(", "cfg", "=", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "_", "=", "_LegacySubClassNotCfg", "(", "config", "=", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_config.TestConfigurable.testInitWithCfgOverwrite": [[179, 197], ["detectron2.config.get_cfg", "test_config._TestClassA", "test_config._TestClassB", "test_config._TestClassC", "test_config._TestClassD", "test_config._TestClassA", "test_config._TestClassB", "test_config._TestClassC", "test_config._TestClassD", "test_config.TestConfigurable.assertRaises", "test_config._TestClassA"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg"], ["", "def", "testInitWithCfgOverwrite", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "ARG1", "=", "1", "\n", "cfg", ".", "ARG2", "=", "999", "# wrong config", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "_", "=", "_TestClassA", "(", "cfg", ",", "arg3", "=", "3", ")", "\n", "\n", "# overwrite arg2 with correct config later:", "\n", "", "_", "=", "_TestClassA", "(", "cfg", ",", "arg2", "=", "2", ",", "arg3", "=", "3", ")", "\n", "_", "=", "_TestClassB", "(", "cfg", ",", "input_shape", "=", "\"shape\"", ",", "arg2", "=", "2", ",", "arg3", "=", "3", ")", "\n", "_", "=", "_TestClassC", "(", "cfg", ",", "input_shape", "=", "\"shape\"", ",", "arg2", "=", "2", ",", "arg3", "=", "3", ")", "\n", "_", "=", "_TestClassD", "(", "cfg", ",", "input_shape", "=", "\"shape\"", ",", "arg2", "=", "2", ",", "arg3", "=", "3", ")", "\n", "\n", "# call with kwargs cfg=cfg instead", "\n", "_", "=", "_TestClassA", "(", "cfg", "=", "cfg", ",", "arg2", "=", "2", ",", "arg3", "=", "3", ")", "\n", "_", "=", "_TestClassB", "(", "cfg", "=", "cfg", ",", "input_shape", "=", "\"shape\"", ",", "arg2", "=", "2", ",", "arg3", "=", "3", ")", "\n", "_", "=", "_TestClassC", "(", "cfg", "=", "cfg", ",", "input_shape", "=", "\"shape\"", ",", "arg2", "=", "2", ",", "arg3", "=", "3", ")", "\n", "_", "=", "_TestClassD", "(", "cfg", "=", "cfg", ",", "input_shape", "=", "\"shape\"", ",", "arg2", "=", "2", ",", "arg3", "=", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_config.TestConfigurable.testInitWithCfgWrongArgs": [[198, 208], ["detectron2.config.get_cfg", "test_config.TestConfigurable.assertRaises", "test_config._TestClassB", "test_config.TestConfigurable.assertRaises", "test_config._TestClassC", "test_config.TestConfigurable.assertRaises", "test_config._TestClassD"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg"], ["", "def", "testInitWithCfgWrongArgs", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "ARG1", "=", "1", "\n", "cfg", ".", "ARG2", "=", "2", "\n", "with", "self", ".", "assertRaises", "(", "TypeError", ")", ":", "\n", "            ", "_", "=", "_TestClassB", "(", "cfg", ",", "\"shape\"", ",", "not_exist", "=", "1", ")", "\n", "", "with", "self", ".", "assertRaises", "(", "TypeError", ")", ":", "\n", "            ", "_", "=", "_TestClassC", "(", "cfg", ",", "\"shape\"", ",", "not_exist", "=", "1", ")", "\n", "", "with", "self", ".", "assertRaises", "(", "TypeError", ")", ":", "\n", "            ", "_", "=", "_TestClassD", "(", "cfg", ",", "\"shape\"", ",", "not_exist", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_config.TestConfigurable.testBadClass": [[209, 241], ["test_config.TestConfigurable.assertRaises", "_BadClass1", "test_config.TestConfigurable.assertRaises", "_BadClass2", "test_config.TestConfigurable.assertRaises", "_BadClass3", "detectron2.config.get_cfg"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg"], ["", "", "def", "testBadClass", "(", "self", ")", ":", "\n", "        ", "class", "_BadClass1", ":", "\n", "            ", "@", "configurable", "\n", "def", "__init__", "(", "self", ",", "a", "=", "1", ",", "b", "=", "2", ")", ":", "\n", "                ", "pass", "\n", "\n", "", "", "class", "_BadClass2", ":", "\n", "            ", "@", "configurable", "\n", "def", "__init__", "(", "self", ",", "a", "=", "1", ",", "b", "=", "2", ")", ":", "\n", "                ", "pass", "\n", "\n", "", "def", "from_config", "(", "self", ",", "cfg", ")", ":", "# noqa", "\n", "                ", "pass", "\n", "\n", "", "", "class", "_BadClass3", ":", "\n", "            ", "@", "configurable", "\n", "def", "__init__", "(", "self", ",", "a", "=", "1", ",", "b", "=", "2", ")", ":", "\n", "                ", "pass", "\n", "\n", "# bad name: must be cfg", "\n", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "config", ")", ":", "# noqa", "\n", "                ", "pass", "\n", "\n", "", "", "with", "self", ".", "assertRaises", "(", "AttributeError", ")", ":", "\n", "            ", "_", "=", "_BadClass1", "(", "a", "=", "1", ")", "\n", "\n", "", "with", "self", ".", "assertRaises", "(", "TypeError", ")", ":", "\n", "            ", "_", "=", "_BadClass2", "(", "a", "=", "1", ")", "\n", "\n", "", "with", "self", ".", "assertRaises", "(", "TypeError", ")", ":", "\n", "            ", "_", "=", "_BadClass3", "(", "get_cfg", "(", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_export_torchscript.TestTorchscript.test_dump_IR_tracing": [[16, 38], ["detectron2.config.get_cfg", "Mod", "detectron2.modeling.build_backbone", "Mod.eval", "torch.no_grad", "torch.jit.trace", "tempfile.TemporaryDirectory", "detectron2.export.torchscript.dump_torchscript_IR", "tuple", "os.path.join", "test_export_torchscript.TestTorchscript.assertTrue", "test_export_torchscript.TestTorchscript.m().values", "torch.rand", "test_export_torchscript.TestTorchscript.m", "os.stat"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.torchscript.dump_torchscript_IR"], ["    ", "def", "test_dump_IR_tracing", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DEPTH", "=", "18", "\n", "cfg", ".", "MODEL", ".", "RESNETS", ".", "RES2_OUT_CHANNELS", "=", "64", "\n", "\n", "class", "Mod", "(", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "                ", "return", "tuple", "(", "self", ".", "m", "(", "x", ")", ".", "values", "(", ")", ")", "\n", "\n", "", "", "model", "=", "Mod", "(", ")", "\n", "model", ".", "m", "=", "build_backbone", "(", "cfg", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "ts_model", "=", "torch", ".", "jit", ".", "trace", "(", "model", ",", "(", "torch", ".", "rand", "(", "2", ",", "3", ",", "224", ",", "224", ")", ",", ")", ")", "\n", "\n", "", "with", "tempfile", ".", "TemporaryDirectory", "(", "prefix", "=", "\"detectron2_test\"", ")", "as", "d", ":", "\n", "            ", "dump_torchscript_IR", "(", "ts_model", ",", "d", ")", "\n", "# check that the files are created", "\n", "for", "name", "in", "[", "\"model_ts_code\"", ",", "\"model_ts_IR\"", ",", "\"model_ts_IR_inlined\"", ",", "\"model\"", "]", ":", "\n", "                ", "fname", "=", "os", ".", "path", ".", "join", "(", "d", ",", "name", "+", "\".txt\"", ")", "\n", "self", ".", "assertTrue", "(", "os", ".", "stat", "(", "fname", ")", ".", "st_size", ">", "0", ",", "fname", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_export_caffe2.TestCaffe2Export.setUp": [[23, 25], ["detectron2.utils.logger.setup_logger"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.setup_logger"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "setup_logger", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_export_caffe2.TestCaffe2Export._test_model": [[26, 45], ["detectron2.config.get_cfg", "add_export_config.merge_from_file", "add_export_config", "detectron2.modeling.build_model", "detectron2.checkpoint.DetectionCheckpointer().load", "export_caffe2_model", "detectron2.model_zoo.get_config_file", "detectron2.model_zoo.get_checkpoint_url", "copy.deepcopy", "tempfile.TemporaryDirectory", "Caffe2Model.load_protobuf.save_protobuf", "Caffe2Model.load_protobuf.save_graph", "Caffe2Model.load_protobuf", "test_export_caffe2.TestCaffe2Export._get_test_image", "detectron2.checkpoint.DetectionCheckpointer", "os.path.join", "Caffe2Model.load_protobuf.", "copy.deepcopy"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.add_export_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.export_caffe2_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get_config_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get_checkpoint_url", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Model.save_protobuf", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Model.save_graph", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.api.Caffe2Model.load_protobuf", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_export_caffe2.TestCaffe2Export._get_test_image"], ["", "def", "_test_model", "(", "self", ",", "config_path", ",", "device", "=", "\"cpu\"", ")", ":", "\n", "# requires extra dependencies", "\n", "        ", "from", "detectron2", ".", "export", "import", "Caffe2Model", ",", "add_export_config", ",", "export_caffe2_model", "\n", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "model_zoo", ".", "get_config_file", "(", "config_path", ")", ")", "\n", "cfg", "=", "add_export_config", "(", "cfg", ")", "\n", "cfg", ".", "MODEL", ".", "DEVICE", "=", "device", "\n", "\n", "inputs", "=", "[", "{", "\"image\"", ":", "self", ".", "_get_test_image", "(", ")", "}", "]", "\n", "model", "=", "build_model", "(", "cfg", ")", "\n", "DetectionCheckpointer", "(", "model", ")", ".", "load", "(", "model_zoo", ".", "get_checkpoint_url", "(", "config_path", ")", ")", "\n", "c2_model", "=", "export_caffe2_model", "(", "cfg", ",", "model", ",", "copy", ".", "deepcopy", "(", "inputs", ")", ")", "\n", "\n", "with", "tempfile", ".", "TemporaryDirectory", "(", "prefix", "=", "\"detectron2_unittest\"", ")", "as", "d", ":", "\n", "            ", "c2_model", ".", "save_protobuf", "(", "d", ")", "\n", "c2_model", ".", "save_graph", "(", "os", ".", "path", ".", "join", "(", "d", ",", "\"test.svg\"", ")", ",", "inputs", "=", "copy", ".", "deepcopy", "(", "inputs", ")", ")", "\n", "c2_model", "=", "Caffe2Model", ".", "load_protobuf", "(", "d", ")", "\n", "", "c2_model", "(", "inputs", ")", "[", "0", "]", "[", "\"instances\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_export_caffe2.TestCaffe2Export._get_test_image": [[46, 58], ["cv2.imdecode", "torch.from_numpy", "fvcore.common.file_io.PathManager.exists", "fvcore.common.file_io.PathManager.open", "f.read", "numpy.frombuffer", "cv2.imdecode.transpose", "test_export_caffe2.TestCaffe2Export.skipTest", "detectron2.data.DatasetCatalog.get"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "def", "_get_test_image", "(", "self", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "file_name", "=", "DatasetCatalog", ".", "get", "(", "\"coco_2017_train\"", ")", "[", "0", "]", "[", "\"file_name\"", "]", "\n", "assert", "PathManager", ".", "exists", "(", "file_name", ")", "\n", "", "except", "Exception", ":", "\n", "            ", "self", ".", "skipTest", "(", "\"COCO dataset not available.\"", ")", "\n", "\n", "", "with", "PathManager", ".", "open", "(", "file_name", ",", "\"rb\"", ")", "as", "f", ":", "\n", "            ", "buf", "=", "f", ".", "read", "(", ")", "\n", "", "img", "=", "cv2", ".", "imdecode", "(", "np", ".", "frombuffer", "(", "buf", ",", "dtype", "=", "np", ".", "uint8", ")", ",", "cv2", ".", "IMREAD_COLOR", ")", "\n", "assert", "img", "is", "not", "None", ",", "file_name", "\n", "return", "torch", ".", "from_numpy", "(", "img", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_export_caffe2.TestCaffe2Export.testMaskRCNN": [[59, 61], ["test_export_caffe2.TestCaffe2Export._test_model"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_export_caffe2.TestCaffe2Export._test_model"], ["", "def", "testMaskRCNN", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_model", "(", "\"COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x.yaml\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_export_caffe2.TestCaffe2Export.testMaskRCNNGPU": [[62, 65], ["unittest.skipIf", "test_export_caffe2.TestCaffe2Export._test_model", "torch.cuda.is_available"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_export_caffe2.TestCaffe2Export._test_model"], ["", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "testMaskRCNNGPU", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_model", "(", "\"COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x.yaml\"", ",", "device", "=", "\"cuda\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_export_caffe2.TestCaffe2Export.testRetinaNet": [[66, 68], ["test_export_caffe2.TestCaffe2Export._test_model"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_export_caffe2.TestCaffe2Export._test_model"], ["", "def", "testRetinaNet", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_model", "(", "\"COCO-Detection/retinanet_R_50_FPN_3x.yaml\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_export_caffe2.TestCaffe2Export.testPanopticFPN": [[69, 71], ["test_export_caffe2.TestCaffe2Export._test_model"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_export_caffe2.TestCaffe2Export._test_model"], ["", "def", "testPanopticFPN", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_model", "(", "\"COCO-PanopticSegmentation/panoptic_fpn_R_50_3x.yaml\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_checkpoint.TestCheckpointer.setUp": [[12, 14], ["detectron2.utils.logger.setup_logger"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.setup_logger"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "setup_logger", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_checkpoint.TestCheckpointer.create_complex_model": [[15, 31], ["torch.nn.Module", "torch.nn.Module", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Module", "torch.nn.Linear", "collections.OrderedDict", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand"], "methods", ["None"], ["", "def", "create_complex_model", "(", "self", ")", ":", "\n", "        ", "m", "=", "nn", ".", "Module", "(", ")", "\n", "m", ".", "block1", "=", "nn", ".", "Module", "(", ")", "\n", "m", ".", "block1", ".", "layer1", "=", "nn", ".", "Linear", "(", "2", ",", "3", ")", "\n", "m", ".", "layer2", "=", "nn", ".", "Linear", "(", "3", ",", "2", ")", "\n", "m", ".", "res", "=", "nn", ".", "Module", "(", ")", "\n", "m", ".", "res", ".", "layer2", "=", "nn", ".", "Linear", "(", "3", ",", "2", ")", "\n", "\n", "state_dict", "=", "OrderedDict", "(", ")", "\n", "state_dict", "[", "\"layer1.weight\"", "]", "=", "torch", ".", "rand", "(", "3", ",", "2", ")", "\n", "state_dict", "[", "\"layer1.bias\"", "]", "=", "torch", ".", "rand", "(", "3", ")", "\n", "state_dict", "[", "\"layer2.weight\"", "]", "=", "torch", ".", "rand", "(", "2", ",", "3", ")", "\n", "state_dict", "[", "\"layer2.bias\"", "]", "=", "torch", ".", "rand", "(", "2", ")", "\n", "state_dict", "[", "\"res.layer2.weight\"", "]", "=", "torch", ".", "rand", "(", "2", ",", "3", ")", "\n", "state_dict", "[", "\"res.layer2.bias\"", "]", "=", "torch", ".", "rand", "(", "2", ")", "\n", "return", "m", ",", "state_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_checkpoint.TestCheckpointer.test_complex_model_loaded": [[32, 45], ["test_checkpoint.TestCheckpointer.create_complex_model", "torch.nn.DataParallel.state_dict", "detectron2.checkpoint.c2_model_loading.align_and_update_state_dicts", "zip", "torch.nn.DataParallel", "nn.DataParallel.state_dict.values", "state_dict.values", "test_checkpoint.TestCheckpointer.assertFalse", "test_checkpoint.TestCheckpointer.assertTrue", "loaded.equal", "id", "id"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_checkpoint.TestCheckpointer.create_complex_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.checkpoint.c2_model_loading.align_and_update_state_dicts"], ["", "def", "test_complex_model_loaded", "(", "self", ")", ":", "\n", "        ", "for", "add_data_parallel", "in", "[", "False", ",", "True", "]", ":", "\n", "            ", "model", ",", "state_dict", "=", "self", ".", "create_complex_model", "(", ")", "\n", "if", "add_data_parallel", ":", "\n", "                ", "model", "=", "nn", ".", "DataParallel", "(", "model", ")", "\n", "", "model_sd", "=", "model", ".", "state_dict", "(", ")", "\n", "\n", "align_and_update_state_dicts", "(", "model_sd", ",", "state_dict", ")", "\n", "for", "loaded", ",", "stored", "in", "zip", "(", "model_sd", ".", "values", "(", ")", ",", "state_dict", ".", "values", "(", ")", ")", ":", "\n", "# different tensor references", "\n", "                ", "self", ".", "assertFalse", "(", "id", "(", "loaded", ")", "==", "id", "(", "stored", ")", ")", "\n", "# same content", "\n", "self", ".", "assertTrue", "(", "loaded", ".", "equal", "(", "stored", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_engine.SimpleModel.__init__": [[17, 21], ["torch.nn.Module.__init__", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "sleep_sec", "=", "0", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "mod", "=", "nn", ".", "Linear", "(", "10", ",", "20", ")", "\n", "self", ".", "sleep_sec", "=", "sleep_sec", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_engine.SimpleModel.forward": [[22, 26], ["time.sleep", "x.sum", "sum", "x.mean", "test_engine.SimpleModel.parameters"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "sleep_sec", ">", "0", ":", "\n", "            ", "time", ".", "sleep", "(", "self", ".", "sleep_sec", ")", "\n", "", "return", "{", "\"loss\"", ":", "x", ".", "sum", "(", ")", "+", "sum", "(", "[", "x", ".", "mean", "(", ")", "for", "x", "in", "self", ".", "parameters", "(", ")", "]", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_engine.TestTrainer._data_loader": [[29, 33], ["torch.device", "torch.rand().to", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["    ", "def", "_data_loader", "(", "self", ",", "device", ")", ":", "\n", "        ", "device", "=", "torch", ".", "device", "(", "device", ")", "\n", "while", "True", ":", "\n", "            ", "yield", "torch", ".", "rand", "(", "3", ",", "3", ")", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_engine.TestTrainer.test_simple_trainer": [[34, 40], ["SimpleModel().to", "detectron2.engine.SimpleTrainer", "detectron2.engine.SimpleTrainer.train", "test_engine.TestTrainer._data_loader", "torch.optim.SGD", "test_engine.SimpleModel", "SimpleModel().to.parameters"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_engine.TestTrainer._data_loader"], ["", "", "def", "test_simple_trainer", "(", "self", ",", "device", "=", "\"cpu\"", ")", ":", "\n", "        ", "model", "=", "SimpleModel", "(", ")", ".", "to", "(", "device", "=", "device", ")", "\n", "trainer", "=", "SimpleTrainer", "(", "\n", "model", ",", "self", ".", "_data_loader", "(", "device", ")", ",", "torch", ".", "optim", ".", "SGD", "(", "model", ".", "parameters", "(", ")", ",", "0.1", ")", "\n", ")", "\n", "trainer", ".", "train", "(", "0", ",", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_engine.TestTrainer.test_simple_trainer_cuda": [[41, 44], ["unittest.skipIf", "test_engine.TestTrainer.test_simple_trainer", "torch.cuda.is_available"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_engine.TestTrainer.test_simple_trainer"], ["", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_simple_trainer_cuda", "(", "self", ")", ":", "\n", "        ", "self", ".", "test_simple_trainer", "(", "device", "=", "\"cuda\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_engine.TestTrainer.test_writer_hooks": [[45, 76], ["test_engine.SimpleModel", "detectron2.engine.SimpleTrainer", "test_engine.TestTrainer._data_loader", "torch.optim.SGD", "tempfile.TemporaryDirectory", "os.path.join", "unittest.mock.MagicMock", "detectron2.engine.SimpleTrainer.register_hooks", "detectron2.engine.SimpleTrainer.train", "test_engine.TestTrainer.assertEqual", "zip", "test_engine.TestTrainer.assertIn", "SimpleModel.parameters", "detectron2.utils.events.CommonMetricPrinter", "detectron2.utils.events.JSONWriter", "open", "test_engine.TestTrainer.assertEqual", "test_engine.TestTrainer.assertIn", "str", "len", "test_engine.TestTrainer.assertIn", "detectron2.engine.hooks.EvalHook", "detectron2.engine.hooks.PeriodicWriter", "json.loads", "line.strip"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_engine.TestTrainer._data_loader", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.TrainerBase.register_hooks", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train"], ["", "def", "test_writer_hooks", "(", "self", ")", ":", "\n", "        ", "model", "=", "SimpleModel", "(", "sleep_sec", "=", "0.1", ")", "\n", "trainer", "=", "SimpleTrainer", "(", "\n", "model", ",", "self", ".", "_data_loader", "(", "\"cpu\"", ")", ",", "torch", ".", "optim", ".", "SGD", "(", "model", ".", "parameters", "(", ")", ",", "0.1", ")", "\n", ")", "\n", "\n", "max_iter", "=", "50", "\n", "\n", "with", "tempfile", ".", "TemporaryDirectory", "(", "prefix", "=", "\"detectron2_test\"", ")", "as", "d", ":", "\n", "            ", "json_file", "=", "os", ".", "path", ".", "join", "(", "d", ",", "\"metrics.json\"", ")", "\n", "writers", "=", "[", "CommonMetricPrinter", "(", "max_iter", ")", ",", "JSONWriter", "(", "json_file", ")", "]", "\n", "logger_info", "=", "writers", "[", "0", "]", ".", "logger", ".", "info", "=", "MagicMock", "(", ")", "\n", "\n", "trainer", ".", "register_hooks", "(", "\n", "[", "hooks", ".", "EvalHook", "(", "0", ",", "lambda", ":", "{", "\"metric\"", ":", "100", "}", ")", ",", "hooks", ".", "PeriodicWriter", "(", "writers", ")", "]", "\n", ")", "\n", "trainer", ".", "train", "(", "0", ",", "max_iter", ")", "\n", "\n", "with", "open", "(", "json_file", ",", "\"r\"", ")", "as", "f", ":", "\n", "                ", "data", "=", "[", "json", ".", "loads", "(", "line", ".", "strip", "(", ")", ")", "for", "line", "in", "f", "]", "\n", "self", ".", "assertEqual", "(", "[", "x", "[", "\"iteration\"", "]", "for", "x", "in", "data", "]", ",", "[", "19", ",", "39", ",", "49", ",", "50", "]", ")", "\n", "# the eval metric is in the last line with iter 50", "\n", "self", ".", "assertIn", "(", "\"metric\"", ",", "data", "[", "-", "1", "]", ",", "\"Eval metric must be in last line of JSON!\"", ")", "\n", "\n", "# test logged messages from CommonMetricPrinter", "\n", "", "all_logs", "=", "[", "str", "(", "x", ")", "for", "x", "in", "logger_info", ".", "call_args_list", "]", "\n", "self", ".", "assertEqual", "(", "len", "(", "all_logs", ")", ",", "3", ")", "\n", "for", "log", ",", "iter", "in", "zip", "(", "all_logs", ",", "[", "19", ",", "39", ",", "49", "]", ")", ":", "\n", "                ", "self", ".", "assertIn", "(", "f\"iter: {iter}\"", ",", "log", ")", "\n", "\n", "", "self", ".", "assertIn", "(", "\"eta: 0:00:00\"", ",", "all_logs", "[", "-", "1", "]", ",", "\"Last ETA must be 0!\"", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_events.TestEventWriter.testScalar": [[11, 26], ["tempfile.TemporaryDirectory", "detectron2.utils.events.EventStorage", "os.path.join", "detectron2.utils.events.JSONWriter", "range", "detectron2.utils.events.JSONWriter.close", "storage.put_scalar", "storage.step", "open", "test_events.TestEventWriter.assertTrue", "detectron2.utils.events.JSONWriter.write", "json.loads", "int"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.TensorboardXWriter.close", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.optimizers.LARS.step", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write"], ["    ", "def", "testScalar", "(", "self", ")", ":", "\n", "        ", "with", "tempfile", ".", "TemporaryDirectory", "(", "\n", "prefix", "=", "\"detectron2_tests\"", "\n", ")", "as", "dir", ",", "EventStorage", "(", ")", "as", "storage", ":", "\n", "            ", "json_file", "=", "os", ".", "path", ".", "join", "(", "dir", ",", "\"test.json\"", ")", "\n", "writer", "=", "JSONWriter", "(", "json_file", ")", "\n", "for", "k", "in", "range", "(", "60", ")", ":", "\n", "                ", "storage", ".", "put_scalar", "(", "\"key\"", ",", "k", ",", "smoothing_hint", "=", "False", ")", "\n", "if", "(", "k", "+", "1", ")", "%", "20", "==", "0", ":", "\n", "                    ", "writer", ".", "write", "(", ")", "\n", "", "storage", ".", "step", "(", ")", "\n", "", "writer", ".", "close", "(", ")", "\n", "with", "open", "(", "json_file", ")", "as", "f", ":", "\n", "                ", "data", "=", "[", "json", ".", "loads", "(", "l", ")", "for", "l", "in", "f", "]", "\n", "self", ".", "assertTrue", "(", "[", "int", "(", "k", "[", "\"key\"", "]", ")", "for", "k", "in", "data", "]", "==", "[", "19", ",", "39", ",", "59", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_events.TestEventWriter.testScalarMismatchedPeriod": [[27, 47], ["tempfile.TemporaryDirectory", "detectron2.utils.events.EventStorage", "os.path.join", "detectron2.utils.events.JSONWriter", "range", "detectron2.utils.events.JSONWriter.close", "storage.put_scalar", "storage.step", "open", "test_events.TestEventWriter.assertTrue", "test_events.TestEventWriter.assertTrue", "test_events.TestEventWriter.assertTrue", "storage.put_scalar", "detectron2.utils.events.JSONWriter.write", "json.loads", "int", "int", "int", "k.get", "k.get"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.TensorboardXWriter.close", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.optimizers.LARS.step", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "", "", "def", "testScalarMismatchedPeriod", "(", "self", ")", ":", "\n", "        ", "with", "tempfile", ".", "TemporaryDirectory", "(", "\n", "prefix", "=", "\"detectron2_tests\"", "\n", ")", "as", "dir", ",", "EventStorage", "(", ")", "as", "storage", ":", "\n", "            ", "json_file", "=", "os", ".", "path", ".", "join", "(", "dir", ",", "\"test.json\"", ")", "\n", "\n", "writer", "=", "JSONWriter", "(", "json_file", ")", "\n", "for", "k", "in", "range", "(", "60", ")", ":", "\n", "                ", "if", "k", "%", "17", "==", "0", ":", "# write in a differnt period", "\n", "                    ", "storage", ".", "put_scalar", "(", "\"key2\"", ",", "k", ",", "smoothing_hint", "=", "False", ")", "\n", "", "storage", ".", "put_scalar", "(", "\"key\"", ",", "k", ",", "smoothing_hint", "=", "False", ")", "\n", "if", "(", "k", "+", "1", ")", "%", "20", "==", "0", ":", "\n", "                    ", "writer", ".", "write", "(", ")", "\n", "", "storage", ".", "step", "(", ")", "\n", "", "writer", ".", "close", "(", ")", "\n", "with", "open", "(", "json_file", ")", "as", "f", ":", "\n", "                ", "data", "=", "[", "json", ".", "loads", "(", "l", ")", "for", "l", "in", "f", "]", "\n", "self", ".", "assertTrue", "(", "[", "int", "(", "k", ".", "get", "(", "\"key2\"", ",", "0", ")", ")", "for", "k", "in", "data", "]", "==", "[", "17", ",", "0", ",", "34", ",", "0", ",", "51", ",", "0", "]", ")", "\n", "self", ".", "assertTrue", "(", "[", "int", "(", "k", ".", "get", "(", "\"key\"", ",", "0", ")", ")", "for", "k", "in", "data", "]", "==", "[", "0", ",", "19", ",", "0", ",", "39", ",", "0", ",", "59", "]", ")", "\n", "self", ".", "assertTrue", "(", "[", "int", "(", "k", "[", "\"iteration\"", "]", ")", "for", "k", "in", "data", "]", "==", "[", "17", ",", "19", ",", "34", ",", "39", ",", "51", ",", "59", "]", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_visualizer.TestVisualizer._random_data": [[17, 34], ["numpy.concatenate", "numpy.zeros_like", "numpy.random.rand", "numpy.random.rand", "str", "numpy.random.rand().flatten", "test_visualizer.TestVisualizer._random_data._rand_poly"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten"], ["    ", "def", "_random_data", "(", "self", ")", ":", "\n", "        ", "H", ",", "W", "=", "100", ",", "100", "\n", "N", "=", "10", "\n", "img", "=", "np", ".", "random", ".", "rand", "(", "H", ",", "W", ",", "3", ")", "*", "255", "\n", "boxxy", "=", "np", ".", "random", ".", "rand", "(", "N", ",", "2", ")", "*", "(", "H", "//", "2", ")", "\n", "boxes", "=", "np", ".", "concatenate", "(", "(", "boxxy", ",", "boxxy", "+", "H", "//", "2", ")", ",", "axis", "=", "1", ")", "\n", "\n", "def", "_rand_poly", "(", ")", ":", "\n", "            ", "return", "np", ".", "random", ".", "rand", "(", "3", ",", "2", ")", ".", "flatten", "(", ")", "*", "H", "\n", "\n", "", "polygons", "=", "[", "[", "_rand_poly", "(", ")", "for", "_", "in", "range", "(", "np", ".", "random", ".", "randint", "(", "1", ",", "5", ")", ")", "]", "for", "_", "in", "range", "(", "N", ")", "]", "\n", "\n", "mask", "=", "np", ".", "zeros_like", "(", "img", "[", ":", ",", ":", ",", "0", "]", ",", "dtype", "=", "np", ".", "bool", ")", "\n", "mask", "[", ":", "40", ",", "10", ":", "20", "]", "=", "1", "\n", "\n", "labels", "=", "[", "str", "(", "i", ")", "for", "i", "in", "range", "(", "N", ")", "]", "\n", "return", "img", ",", "boxes", ",", "labels", ",", "polygons", ",", "[", "mask", "]", "*", "N", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_visualizer.TestVisualizer.metadata": [[35, 38], ["detectron2.data.MetadataCatalog.get"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "@", "property", "\n", "def", "metadata", "(", "self", ")", ":", "\n", "        ", "return", "MetadataCatalog", ".", "get", "(", "\"coco_2017_train\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_visualizer.TestVisualizer.test_draw_dataset_dict": [[39, 65], ["detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.draw_dataset_dict", "numpy.random.rand"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_dataset_dict"], ["", "def", "test_draw_dataset_dict", "(", "self", ")", ":", "\n", "        ", "img", "=", "np", ".", "random", ".", "rand", "(", "512", ",", "512", ",", "3", ")", "*", "255", "\n", "dic", "=", "{", "\n", "\"annotations\"", ":", "[", "\n", "{", "\n", "\"bbox\"", ":", "[", "\n", "368.9946492271106", ",", "\n", "330.891438763377", ",", "\n", "13.148537455410235", ",", "\n", "13.644708680142685", ",", "\n", "]", ",", "\n", "\"bbox_mode\"", ":", "BoxMode", ".", "XYWH_ABS", ",", "\n", "\"category_id\"", ":", "0", ",", "\n", "\"iscrowd\"", ":", "1", ",", "\n", "\"segmentation\"", ":", "{", "\n", "\"counts\"", ":", "\"_jh52m?2N2N2N2O100O10O001N1O2MceP2\"", ",", "\n", "\"size\"", ":", "[", "512", ",", "512", "]", ",", "\n", "}", ",", "\n", "}", "\n", "]", ",", "\n", "\"height\"", ":", "512", ",", "\n", "\"image_id\"", ":", "1", ",", "\n", "\"width\"", ":", "512", ",", "\n", "}", "\n", "v", "=", "Visualizer", "(", "img", ",", "self", ".", "metadata", ")", "\n", "v", ".", "draw_dataset_dict", "(", "dic", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_visualizer.TestVisualizer.test_overlay_instances": [[66, 82], ["test_visualizer.TestVisualizer._random_data", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.overlay_instances().get_image", "test_visualizer.TestVisualizer.assertEqual", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.overlay_instances().get_image", "test_visualizer.TestVisualizer.assertEqual", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.overlay_instances().get_image", "test_visualizer.TestVisualizer.assertEqual", "detectron2.utils.visualizer.Visualizer.overlay_instances", "detectron2.utils.visualizer.Visualizer.overlay_instances", "detectron2.utils.visualizer.Visualizer.overlay_instances"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_visualizer.TestVisualizer._random_data", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.get_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.get_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.get_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.overlay_instances"], ["", "def", "test_overlay_instances", "(", "self", ")", ":", "\n", "        ", "img", ",", "boxes", ",", "labels", ",", "polygons", ",", "masks", "=", "self", ".", "_random_data", "(", ")", "\n", "\n", "v", "=", "Visualizer", "(", "img", ",", "self", ".", "metadata", ")", "\n", "output", "=", "v", ".", "overlay_instances", "(", "masks", "=", "polygons", ",", "boxes", "=", "boxes", ",", "labels", "=", "labels", ")", ".", "get_image", "(", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "shape", ",", "img", ".", "shape", ")", "\n", "\n", "# Test 2x scaling", "\n", "v", "=", "Visualizer", "(", "img", ",", "self", ".", "metadata", ",", "scale", "=", "2.0", ")", "\n", "output", "=", "v", ".", "overlay_instances", "(", "masks", "=", "polygons", ",", "boxes", "=", "boxes", ",", "labels", "=", "labels", ")", ".", "get_image", "(", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "0", "]", "*", "2", ")", "\n", "\n", "# Test overlay masks", "\n", "v", "=", "Visualizer", "(", "img", ",", "self", ".", "metadata", ")", "\n", "output", "=", "v", ".", "overlay_instances", "(", "masks", "=", "masks", ",", "boxes", "=", "boxes", ",", "labels", "=", "labels", ")", ".", "get_image", "(", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "shape", ",", "img", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_visualizer.TestVisualizer.test_overlay_instances_no_boxes": [[83, 87], ["test_visualizer.TestVisualizer._random_data", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.overlay_instances().get_image", "detectron2.utils.visualizer.Visualizer.overlay_instances"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_visualizer.TestVisualizer._random_data", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.get_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.overlay_instances"], ["", "def", "test_overlay_instances_no_boxes", "(", "self", ")", ":", "\n", "        ", "img", ",", "boxes", ",", "labels", ",", "polygons", ",", "_", "=", "self", ".", "_random_data", "(", ")", "\n", "v", "=", "Visualizer", "(", "img", ",", "self", ".", "metadata", ")", "\n", "v", ".", "overlay_instances", "(", "masks", "=", "polygons", ",", "boxes", "=", "None", ",", "labels", "=", "labels", ")", ".", "get_image", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_visualizer.TestVisualizer.test_draw_instance_predictions": [[88, 99], ["test_visualizer.TestVisualizer._random_data", "len", "detectron2.structures.Instances", "torch.randint", "torch.rand", "torch.from_numpy", "torch.from_numpy", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.draw_instance_predictions", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_visualizer.TestVisualizer._random_data", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.video_visualizer.VideoVisualizer.draw_instance_predictions"], ["", "def", "test_draw_instance_predictions", "(", "self", ")", ":", "\n", "        ", "img", ",", "boxes", ",", "_", ",", "_", ",", "masks", "=", "self", ".", "_random_data", "(", ")", "\n", "num_inst", "=", "len", "(", "boxes", ")", "\n", "inst", "=", "Instances", "(", "(", "img", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "1", "]", ")", ")", "\n", "inst", ".", "pred_classes", "=", "torch", ".", "randint", "(", "0", ",", "80", ",", "size", "=", "(", "num_inst", ",", ")", ")", "\n", "inst", ".", "scores", "=", "torch", ".", "rand", "(", "num_inst", ")", "\n", "inst", ".", "pred_boxes", "=", "torch", ".", "from_numpy", "(", "boxes", ")", "\n", "inst", ".", "pred_masks", "=", "torch", ".", "from_numpy", "(", "np", ".", "asarray", "(", "masks", ")", ")", "\n", "\n", "v", "=", "Visualizer", "(", "img", ",", "self", ".", "metadata", ")", "\n", "v", ".", "draw_instance_predictions", "(", "inst", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_visualizer.TestVisualizer.test_BWmode_nomask": [[100, 110], ["test_visualizer.TestVisualizer._random_data", "len", "detectron2.structures.Instances", "torch.randint", "torch.rand", "torch.from_numpy", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.draw_instance_predictions"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_visualizer.TestVisualizer._random_data", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.video_visualizer.VideoVisualizer.draw_instance_predictions"], ["", "def", "test_BWmode_nomask", "(", "self", ")", ":", "\n", "        ", "img", ",", "boxes", ",", "_", ",", "_", ",", "masks", "=", "self", ".", "_random_data", "(", ")", "\n", "num_inst", "=", "len", "(", "boxes", ")", "\n", "inst", "=", "Instances", "(", "(", "img", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "1", "]", ")", ")", "\n", "inst", ".", "pred_classes", "=", "torch", ".", "randint", "(", "0", ",", "80", ",", "size", "=", "(", "num_inst", ",", ")", ")", "\n", "inst", ".", "scores", "=", "torch", ".", "rand", "(", "num_inst", ")", "\n", "inst", ".", "pred_boxes", "=", "torch", ".", "from_numpy", "(", "boxes", ")", "\n", "\n", "v", "=", "Visualizer", "(", "img", ",", "self", ".", "metadata", ",", "instance_mode", "=", "ColorMode", ".", "IMAGE_BW", ")", "\n", "v", ".", "draw_instance_predictions", "(", "inst", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_visualizer.TestVisualizer.test_draw_empty_mask_predictions": [[111, 122], ["test_visualizer.TestVisualizer._random_data", "len", "detectron2.structures.Instances", "torch.randint", "torch.rand", "torch.from_numpy", "torch.from_numpy", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.draw_instance_predictions", "numpy.zeros_like", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_visualizer.TestVisualizer._random_data", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.video_visualizer.VideoVisualizer.draw_instance_predictions"], ["", "def", "test_draw_empty_mask_predictions", "(", "self", ")", ":", "\n", "        ", "img", ",", "boxes", ",", "_", ",", "_", ",", "masks", "=", "self", ".", "_random_data", "(", ")", "\n", "num_inst", "=", "len", "(", "boxes", ")", "\n", "inst", "=", "Instances", "(", "(", "img", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "1", "]", ")", ")", "\n", "inst", ".", "pred_classes", "=", "torch", ".", "randint", "(", "0", ",", "80", ",", "size", "=", "(", "num_inst", ",", ")", ")", "\n", "inst", ".", "scores", "=", "torch", ".", "rand", "(", "num_inst", ")", "\n", "inst", ".", "pred_boxes", "=", "torch", ".", "from_numpy", "(", "boxes", ")", "\n", "inst", ".", "pred_masks", "=", "torch", ".", "from_numpy", "(", "np", ".", "zeros_like", "(", "np", ".", "asarray", "(", "masks", ")", ")", ")", "\n", "\n", "v", "=", "Visualizer", "(", "img", ",", "self", ".", "metadata", ")", "\n", "v", ".", "draw_instance_predictions", "(", "inst", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_visualizer.TestVisualizer.test_correct_output_shape": [[123, 128], ["detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.output.get_image", "test_visualizer.TestVisualizer.assertEqual", "numpy.random.rand"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.get_image"], ["", "def", "test_correct_output_shape", "(", "self", ")", ":", "\n", "        ", "img", "=", "np", ".", "random", ".", "rand", "(", "928", ",", "928", ",", "3", ")", "*", "255", "\n", "v", "=", "Visualizer", "(", "img", ",", "self", ".", "metadata", ")", "\n", "out", "=", "v", ".", "output", ".", "get_image", "(", ")", "\n", "self", ".", "assertEqual", "(", "out", ".", "shape", ",", "img", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_visualizer.TestVisualizer.test_overlay_rotated_instances": [[129, 145], ["torch.zeros", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "detectron2.structures.RotatedBoxes", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.overlay_instances().get_image", "test_visualizer.TestVisualizer.assertEqual", "numpy.random.rand", "max", "max", "str", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "range", "detectron2.utils.visualizer.Visualizer.overlay_instances"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.get_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.overlay_instances"], ["", "def", "test_overlay_rotated_instances", "(", "self", ")", ":", "\n", "        ", "H", ",", "W", "=", "100", ",", "150", "\n", "img", "=", "np", ".", "random", ".", "rand", "(", "H", ",", "W", ",", "3", ")", "*", "255", "\n", "num_boxes", "=", "50", "\n", "boxes_5d", "=", "torch", ".", "zeros", "(", "num_boxes", ",", "5", ")", "\n", "boxes_5d", "[", ":", ",", "0", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "0.1", "*", "W", ",", "1.1", "*", "W", ")", "\n", "boxes_5d", "[", ":", ",", "1", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "0.1", "*", "H", ",", "1.1", "*", "H", ")", "\n", "boxes_5d", "[", ":", ",", "2", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "0", ",", "max", "(", "W", ",", "H", ")", ")", "\n", "boxes_5d", "[", ":", ",", "3", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "0", ",", "max", "(", "W", ",", "H", ")", ")", "\n", "boxes_5d", "[", ":", ",", "4", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "1800", ",", "1800", ")", "\n", "rotated_boxes", "=", "RotatedBoxes", "(", "boxes_5d", ")", "\n", "labels", "=", "[", "str", "(", "i", ")", "for", "i", "in", "range", "(", "num_boxes", ")", "]", "\n", "\n", "v", "=", "Visualizer", "(", "img", ",", "self", ".", "metadata", ")", "\n", "output", "=", "v", ".", "overlay_instances", "(", "boxes", "=", "rotated_boxes", ",", "labels", "=", "labels", ")", ".", "get_image", "(", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "shape", ",", "img", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_visualizer.TestVisualizer.test_draw_no_metadata": [[146, 157], ["test_visualizer.TestVisualizer._random_data", "len", "detectron2.structures.Instances", "torch.randint", "torch.rand", "torch.from_numpy", "torch.from_numpy", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.draw_instance_predictions", "numpy.asarray", "detectron2.data.MetadataCatalog.get"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_visualizer.TestVisualizer._random_data", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.video_visualizer.VideoVisualizer.draw_instance_predictions", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "def", "test_draw_no_metadata", "(", "self", ")", ":", "\n", "        ", "img", ",", "boxes", ",", "_", ",", "_", ",", "masks", "=", "self", ".", "_random_data", "(", ")", "\n", "num_inst", "=", "len", "(", "boxes", ")", "\n", "inst", "=", "Instances", "(", "(", "img", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "1", "]", ")", ")", "\n", "inst", ".", "pred_classes", "=", "torch", ".", "randint", "(", "0", ",", "80", ",", "size", "=", "(", "num_inst", ",", ")", ")", "\n", "inst", ".", "scores", "=", "torch", ".", "rand", "(", "num_inst", ")", "\n", "inst", ".", "pred_boxes", "=", "torch", ".", "from_numpy", "(", "boxes", ")", "\n", "inst", ".", "pred_masks", "=", "torch", ".", "from_numpy", "(", "np", ".", "asarray", "(", "masks", ")", ")", "\n", "\n", "v", "=", "Visualizer", "(", "img", ",", "MetadataCatalog", ".", "get", "(", "\"asdfasdf\"", ")", ")", "\n", "v", ".", "draw_instance_predictions", "(", "inst", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_visualizer.TestVisualizer.test_draw_binary_mask": [[158, 178], ["test_visualizer.TestVisualizer._random_data", "numpy.zeros_like().astype", "cv2.rectangle", "numpy.zeros_like", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.draw_binary_mask", "test_visualizer.TestVisualizer.assertTrue", "o.get_image().astype.get_image().astype.get_image().astype", "tempfile.TemporaryDirectory", "os.path.join", "o.get_image().astype.get_image().astype.save", "o[].sum", "cv2.imread", "o.get_image().astype.get_image().astype.get_image"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_visualizer.TestVisualizer._random_data", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_binary_mask", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.get_image"], ["", "def", "test_draw_binary_mask", "(", "self", ")", ":", "\n", "        ", "img", ",", "boxes", ",", "_", ",", "_", ",", "masks", "=", "self", ".", "_random_data", "(", ")", "\n", "img", "[", ":", ",", ":", ",", "0", "]", "=", "0", "# remove red color", "\n", "mask", "=", "masks", "[", "0", "]", "\n", "mask_with_hole", "=", "np", ".", "zeros_like", "(", "mask", ")", ".", "astype", "(", "\"uint8\"", ")", "\n", "mask_with_hole", "=", "cv2", ".", "rectangle", "(", "mask_with_hole", ",", "(", "10", ",", "10", ")", ",", "(", "50", ",", "50", ")", ",", "1", ",", "5", ")", "\n", "\n", "for", "m", "in", "[", "mask", ",", "mask_with_hole", "]", ":", "\n", "            ", "for", "save", "in", "[", "True", ",", "False", "]", ":", "\n", "                ", "v", "=", "Visualizer", "(", "img", ")", "\n", "o", "=", "v", ".", "draw_binary_mask", "(", "m", ",", "color", "=", "\"red\"", ",", "text", "=", "\"test\"", ")", "\n", "if", "save", ":", "\n", "                    ", "with", "tempfile", ".", "TemporaryDirectory", "(", "prefix", "=", "\"detectron2_viz\"", ")", "as", "d", ":", "\n", "                        ", "path", "=", "os", ".", "path", ".", "join", "(", "d", ",", "\"output.png\"", ")", "\n", "o", ".", "save", "(", "path", ")", "\n", "o", "=", "cv2", ".", "imread", "(", "path", ")", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", "\n", "", "", "else", ":", "\n", "                    ", "o", "=", "o", ".", "get_image", "(", ")", ".", "astype", "(", "\"float32\"", ")", "\n", "# red color is drawn on the image", "\n", "", "self", ".", "assertTrue", "(", "o", "[", ":", ",", ":", ",", "0", "]", ".", "sum", "(", ")", ">", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_visualizer.TestVisualizer.test_border_mask_with_holes": [[179, 199], ["numpy.zeros", "detectron2.utils.visualizer.Visualizer", "numpy.zeros", "cv2.rectangle", "detectron2.utils.visualizer.Visualizer.draw_binary_mask", "test_visualizer.TestVisualizer.assertEqual", "test_visualizer.TestVisualizer.assertEqual", "test_visualizer.TestVisualizer.assertIn", "test_visualizer.TestVisualizer.assertIn", "detectron2.utils.visualizer.Visualizer.draw_binary_mask.get_image", "tuple", "tuple", "len", "len", "x.tolist", "x.tolist"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_binary_mask", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.get_image"], ["", "", "", "def", "test_border_mask_with_holes", "(", "self", ")", ":", "\n", "        ", "H", ",", "W", "=", "200", ",", "200", "\n", "img", "=", "np", ".", "zeros", "(", "(", "H", ",", "W", ",", "3", ")", ")", "\n", "img", "[", ":", ",", ":", ",", "0", "]", "=", "255.0", "\n", "v", "=", "Visualizer", "(", "img", ",", "scale", "=", "3", ")", "\n", "\n", "mask", "=", "np", ".", "zeros", "(", "(", "H", ",", "W", ")", ")", "\n", "mask", "[", ":", ",", "100", ":", "150", "]", "=", "1", "\n", "# create a hole, to trigger imshow", "\n", "mask", "=", "cv2", ".", "rectangle", "(", "mask", ",", "(", "110", ",", "110", ")", ",", "(", "130", ",", "130", ")", ",", "0", ",", "thickness", "=", "-", "1", ")", "\n", "output", "=", "v", ".", "draw_binary_mask", "(", "mask", ",", "color", "=", "\"blue\"", ")", "\n", "output", "=", "output", ".", "get_image", "(", ")", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", "\n", "\n", "first_row", "=", "{", "tuple", "(", "x", ".", "tolist", "(", ")", ")", "for", "x", "in", "output", "[", "0", "]", "}", "\n", "last_row", "=", "{", "tuple", "(", "x", ".", "tolist", "(", ")", ")", "for", "x", "in", "output", "[", "-", "1", "]", "}", "\n", "# Check quantization / off-by-1 error: the first and last row must have two colors", "\n", "self", ".", "assertEqual", "(", "len", "(", "last_row", ")", ",", "2", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "first_row", ")", ",", "2", ")", "\n", "self", ".", "assertIn", "(", "(", "0", ",", "0", ",", "255", ")", ",", "last_row", ")", "\n", "self", ".", "assertIn", "(", "(", "0", ",", "0", ",", "255", ")", ",", "first_row", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_visualizer.TestVisualizer.test_border_polygons": [[200, 220], ["numpy.zeros", "detectron2.utils.visualizer.Visualizer", "numpy.zeros", "detectron2.utils.visualizer.Visualizer.draw_binary_mask", "test_visualizer.TestVisualizer.assertGreaterEqual", "test_visualizer.TestVisualizer.assertGreaterEqual", "test_visualizer.TestVisualizer.assertIn", "test_visualizer.TestVisualizer.assertIn", "detectron2.utils.visualizer.Visualizer.draw_binary_mask.get_image", "tuple", "tuple", "len", "len", "x.tolist", "x.tolist"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.Visualizer.draw_binary_mask", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.get_image"], ["", "def", "test_border_polygons", "(", "self", ")", ":", "\n", "        ", "H", ",", "W", "=", "200", ",", "200", "\n", "img", "=", "np", ".", "zeros", "(", "(", "H", ",", "W", ",", "3", ")", ")", "\n", "img", "[", ":", ",", ":", ",", "0", "]", "=", "255.0", "\n", "v", "=", "Visualizer", "(", "img", ",", "scale", "=", "3", ")", "\n", "mask", "=", "np", ".", "zeros", "(", "(", "H", ",", "W", ")", ")", "\n", "mask", "[", ":", ",", "100", ":", "150", "]", "=", "1", "\n", "\n", "output", "=", "v", ".", "draw_binary_mask", "(", "mask", ",", "color", "=", "\"blue\"", ")", "\n", "output", "=", "output", ".", "get_image", "(", ")", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", "\n", "\n", "first_row", "=", "{", "tuple", "(", "x", ".", "tolist", "(", ")", ")", "for", "x", "in", "output", "[", "0", "]", "}", "\n", "last_row", "=", "{", "tuple", "(", "x", ".", "tolist", "(", ")", ")", "for", "x", "in", "output", "[", "-", "1", "]", "}", "\n", "# Check quantization / off-by-1 error:", "\n", "# the first and last row must have >=2 colors, because the polygon", "\n", "# touches both rows", "\n", "self", ".", "assertGreaterEqual", "(", "len", "(", "last_row", ")", ",", "2", ")", "\n", "self", ".", "assertGreaterEqual", "(", "len", "(", "first_row", ")", ",", "2", ")", "\n", "self", ".", "assertIn", "(", "(", "0", ",", "0", ",", "255", ")", ",", "last_row", ")", "\n", "self", ".", "assertIn", "(", "(", "0", ",", "0", ",", "255", ")", ",", "first_row", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DeepLab.train_net.Trainer.build_evaluator": [[50, 84], ["detectron2.evaluation.DatasetEvaluators", "detectron2.evaluation.DatasetEvaluators", "os.path.join", "detectron2.data.MetadataCatalog.get", "detectron2.data.MetadataCatalog.get", "detectron2.evaluation.SemSegEvaluator", "detectron2.evaluation.SemSegEvaluator", "detectron2.evaluation.CityscapesSemSegEvaluator", "detectron2.evaluation.CityscapesSemSegEvaluator", "len", "NotImplementedError", "len", "torch.cuda.device_count", "detectron2.get_rank", "detectron2.get_rank"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank"], ["cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "default_setup", "(", "cfg", ",", "args", ")", "\n", "return", "cfg", "\n", "\n", "\n", "", "def", "main", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "setup", "(", "args", ")", "\n", "\n", "if", "args", ".", "eval_only", ":", "\n", "        ", "model", "=", "Trainer", ".", "build_model", "(", "cfg", ")", "\n", "DetectionCheckpointer", "(", "\n", "model", ",", "save_dir", "=", "cfg", ".", "OUTPUT_DIR", ")", ".", "resume_or_load", "(", "\n", "cfg", ".", "MODEL", ".", "WEIGHTS", ",", "resume", "=", "args", ".", "resume", ")", "\n", "res", "=", "Trainer", ".", "test", "(", "cfg", ",", "model", ")", "\n", "return", "res", "\n", "\n", "", "trainer", "=", "Trainer", "(", "cfg", ")", "\n", "trainer", ".", "resume_or_load", "(", "resume", "=", "args", ".", "resume", ")", "\n", "return", "trainer", ".", "train", "(", ")", "\n", "\n", "\n", "", "if", "__name__", "==", "\"__main__\"", ":", "\n", "    ", "args", "=", "default_argument_parser", "(", ")", ".", "parse_args", "(", ")", "\n", "\n", "print", "(", "\"Command Line Args:\"", ",", "args", ")", "\n", "launch", "(", "\n", "main", ",", "\n", "args", ".", "num_gpus", ",", "\n", "num_machines", "=", "args", ".", "num_machines", ",", "\n", "machine_rank", "=", "args", ".", "machine_rank", ",", "\n", "dist_url", "=", "args", ".", "dist_url", ",", "\n", "args", "=", "(", "args", ",", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DeepLab.train_net.Trainer.build_train_loader": [[85, 92], ["detectron2.data.build_detection_train_loader", "detectron2.data.build_detection_train_loader", "detectron2.data.DatasetMapper", "detectron2.data.DatasetMapper", "train_net.build_sem_seg_train_aug"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.build_sem_seg_train_aug"], ["", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DeepLab.train_net.Trainer.build_lr_scheduler": [[93, 100], ["detectron2.projects.deeplab.build_lr_scheduler", "detectron2.projects.deeplab.build_lr_scheduler"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.build_solver.build_lr_scheduler", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.build_solver.build_lr_scheduler"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DeepLab.train_net.build_sem_seg_train_aug": [[23, 40], ["augs.append", "detectron2.ResizeShortestEdge", "augs.append", "detectron2.RandomFlip", "detectron2.RandomCrop_CategoryAreaConstraint"], "function", ["None"], ["    ", "\"\"\"\n    As described in the MOCO paper, there is an extra BN layer\n    following the res5 stage.\n    \"\"\"", "\n", "\n", "def", "_build_res5_block", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "seq", ",", "out_channels", "=", "super", "(", ")", ".", "_build_res5_block", "(", "cfg", ")", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "NORM", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", "\n", "seq", ".", "add_module", "(", "\"norm\"", ",", "norm", ")", "\n", "return", "seq", ",", "out_channels", "\n", "\n", "\n", "", "", "class", "Trainer", "(", "DefaultTrainer", ")", ":", "\n", "\n", "    ", "@", "classmethod", "\n", "def", "build_evaluator", "(", "cls", ",", "cfg", ",", "dataset_name", ",", "output_folder", "=", "None", ")", ":", "\n", "        ", "if", "output_folder", "is", "None", ":", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DeepLab.train_net.setup": [[102, 113], ["detectron2.config.get_cfg", "detectron2.projects.deeplab.add_deeplab_config", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.engine.default_setup"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.config.add_deeplab_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.default_setup"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DeepLab.train_net.main": [[115, 129], ["train_net.setup", "train_net.Trainer", "Trainer.resume_or_load", "Trainer.train", "Trainer.build_model", "detectron2.checkpoint.DetectionCheckpointer().resume_or_load", "Trainer.test", "detectron2.checkpoint.DetectionCheckpointer"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.setup", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_packaging.TestCollectEnv.test"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.config.add_deeplab_config": [[5, 28], ["None"], "function", ["None"], ["import", "inspect", "\n", "import", "logging", "\n", "from", "fvcore", ".", "common", ".", "config", "import", "CfgNode", "as", "_CfgNode", "\n", "from", "fvcore", ".", "common", ".", "file_io", "import", "PathManager", "\n", "\n", "\n", "class", "CfgNode", "(", "_CfgNode", ")", ":", "\n", "    ", "\"\"\"\n    The same as `fvcore.common.config.CfgNode`, but different in:\n\n    1. Use unsafe yaml loading by default.\n       Note that this may lead to arbitrary code execution: you must not\n       load a config file from untrusted sources before manually inspecting\n       the content of the file.\n    2. Support config versioning.\n       When attempting to merge an old config, it will convert the old config automatically.\n    \"\"\"", "\n", "\n", "# Note that the default value of allow_unsafe is changed to True", "\n", "def", "merge_from_file", "(", "self", ",", "cfg_filename", ":", "str", ",", "allow_unsafe", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "        ", "assert", "PathManager", ".", "isfile", "(", "cfg_filename", ")", ",", "f\"Config file '{cfg_filename}' does not exist!\"", "\n", "loaded_cfg", "=", "_CfgNode", ".", "load_yaml_with_base", "(", "cfg_filename", ",", "allow_unsafe", "=", "allow_unsafe", ")", "\n", "loaded_cfg", "=", "type", "(", "self", ")", "(", "loaded_cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.loss.DeepLabCE.__init__": [[20, 26], ["torch.Module.__init__", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "ignore_label", "=", "-", "1", ",", "top_k_percent_pixels", "=", "1.0", ",", "weight", "=", "None", ")", ":", "\n", "        ", "super", "(", "DeepLabCE", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "top_k_percent_pixels", "=", "top_k_percent_pixels", "\n", "self", ".", "ignore_label", "=", "ignore_label", "\n", "self", ".", "criterion", "=", "nn", ".", "CrossEntropyLoss", "(", "\n", "weight", "=", "weight", ",", "ignore_index", "=", "ignore_label", ",", "reduction", "=", "\"none\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.loss.DeepLabCE.forward": [[28, 41], ["int", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "pixel_losses.contiguous().view.contiguous().view.mean", "loss.DeepLabCE.criterion().contiguous().view", "pixel_losses.contiguous().view.contiguous().view.contiguous().view", "pixel_losses.contiguous().view.contiguous().view.mean", "loss.DeepLabCE.criterion", "pixel_losses.contiguous().view.contiguous().view.numel", "loss.DeepLabCE.criterion().contiguous", "pixel_losses.contiguous().view.contiguous().view.contiguous", "loss.DeepLabCE.criterion"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "logits", ",", "labels", ",", "weights", "=", "None", ")", ":", "\n", "        ", "if", "weights", "is", "None", ":", "\n", "            ", "pixel_losses", "=", "self", ".", "criterion", "(", "logits", ",", "labels", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "", "else", ":", "\n", "# Apply per-pixel loss weights.", "\n", "            ", "pixel_losses", "=", "self", ".", "criterion", "(", "logits", ",", "labels", ")", "*", "weights", "\n", "pixel_losses", "=", "pixel_losses", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "", "if", "self", ".", "top_k_percent_pixels", "==", "1.0", ":", "\n", "            ", "return", "pixel_losses", ".", "mean", "(", ")", "\n", "\n", "", "top_k_pixels", "=", "int", "(", "self", ".", "top_k_percent_pixels", "*", "pixel_losses", ".", "numel", "(", ")", ")", "\n", "pixel_losses", ",", "_", "=", "torch", ".", "topk", "(", "pixel_losses", ",", "top_k_pixels", ")", "\n", "return", "pixel_losses", ".", "mean", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.resnet.DeepLabStem.__init__": [[19, 57], ["detectron2.layers.CNNBlockBase.__init__", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "fvcore.c2_msra_fill", "fvcore.c2_msra_fill", "fvcore.c2_msra_fill", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "detectron2.layers.get_norm"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm"], ["from", ".", "build", "import", "BACKBONE_REGISTRY", "\n", "\n", "__all__", "=", "[", "\n", "\"ResNetBlockBase\"", ",", "\n", "\"BasicBlock\"", ",", "\n", "\"BottleneckBlock\"", ",", "\n", "\"DeformBottleneckBlock\"", ",", "\n", "\"BasicStem\"", ",", "\n", "\"ResNet\"", ",", "\n", "\"make_stage\"", ",", "\n", "\"build_resnet_backbone\"", ",", "\n", "]", "\n", "\n", "\n", "class", "BasicBlock", "(", "CNNBlockBase", ")", ":", "\n", "    ", "\"\"\"\n    The basic residual block for ResNet-18 and ResNet-34 defined in :paper:`ResNet`,\n    with two 3x3 conv layers and a projection shortcut if needed.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "*", ",", "stride", "=", "1", ",", "norm", "=", "\"BN\"", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            in_channels (int): Number of input channels.\n            out_channels (int): Number of output channels.\n            stride (int): Stride for the first conv.\n            norm (str or callable): normalization for all conv layers.\n                See :func:`layers.get_norm` for supported format.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "stride", ")", "\n", "\n", "if", "in_channels", "!=", "out_channels", ":", "\n", "            ", "self", ".", "shortcut", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.resnet.DeepLabStem.forward": [[58, 67], ["resnet.DeepLabStem.conv1", "torch.relu_", "resnet.DeepLabStem.conv2", "torch.relu_", "resnet.DeepLabStem.conv3", "torch.relu_", "torch.max_pool2d"], "methods", ["None"], [")", "\n", "", "else", ":", "\n", "            ", "self", ".", "shortcut", "=", "None", "\n", "\n", "", "self", ".", "conv1", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.resnet.build_resnet_deeplab_backbone": [[69, 158], ["detectron2.modeling.BACKBONE_REGISTRY.register", "max", "enumerate", "detectron2.modeling.backbone.resnet.ResNet().freeze", "detectron2.modeling.backbone.resnet.BasicStem", "range", "detectron2.modeling.backbone.resnet.ResNet.make_stage", "stages.append", "resnet.DeepLabStem", "ValueError", "stage_kargs.pop", "detectron2.modeling.backbone.resnet.ResNet"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.base.BaseConverter.register", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.make_stage"], ["norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "\n", "self", ".", "conv2", "=", "Conv2d", "(", "\n", "out_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "\n", "for", "layer", "in", "[", "self", ".", "conv1", ",", "self", ".", "conv2", ",", "self", ".", "shortcut", "]", ":", "\n", "            ", "if", "layer", "is", "not", "None", ":", "# shortcut can be None", "\n", "                ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "\n", "", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "\n", "if", "self", ".", "shortcut", "is", "not", "None", ":", "\n", "            ", "shortcut", "=", "self", ".", "shortcut", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "shortcut", "=", "x", "\n", "\n", "", "out", "+=", "shortcut", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "return", "out", "\n", "\n", "\n", "", "", "class", "BottleneckBlock", "(", "CNNBlockBase", ")", ":", "\n", "    ", "\"\"\"\n    The standard bottleneck residual block used by ResNet-50, 101 and 152\n    defined in :paper:`ResNet`.  It contains 3 conv layers with kernels\n    1x1, 3x3, 1x1, and a projection shortcut if needed.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "*", ",", "\n", "bottleneck_channels", ",", "\n", "stride", "=", "1", ",", "\n", "num_groups", "=", "1", ",", "\n", "norm", "=", "\"BN\"", ",", "\n", "stride_in_1x1", "=", "False", ",", "\n", "dilation", "=", "1", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            bottleneck_channels (int): number of output channels for the 3x3\n                \"bottleneck\" conv layers.\n            num_groups (int): number of groups for the 3x3 conv layer.\n            norm (str or callable): normalization for all conv layers.\n                See :func:`layers.get_norm` for supported format.\n            stride_in_1x1 (bool): when stride>1, whether to put stride in the\n                first 1x1 convolution or the bottleneck 3x3 convolution.\n            dilation (int): the dilation rate of the 3x3 conv layer.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "stride", ")", "\n", "\n", "if", "in_channels", "!=", "out_channels", ":", "\n", "            ", "self", ".", "shortcut", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "shortcut", "=", "None", "\n", "\n", "# The original MSRA ResNet models have stride in the first 1x1 conv", "\n", "# The subsequent fb.torch.resnet and Caffe2 ResNe[X]t implementations have", "\n", "# stride in the 3x3 conv", "\n", "", "stride_1x1", ",", "stride_3x3", "=", "(", "stride", ",", "1", ")", "if", "stride_in_1x1", "else", "(", "1", ",", "stride", ")", "\n", "\n", "self", ".", "conv1", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "bottleneck_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride_1x1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "bottleneck_channels", ")", ",", "\n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.build_solver.build_lr_scheduler": [[10, 29], ["lr_scheduler.WarmupPolyLR", "detectron2.solver.build_lr_scheduler"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.build_solver.build_lr_scheduler"], ["def", "build_lr_scheduler", "(", "\n", "cfg", ":", "CfgNode", ",", "optimizer", ":", "torch", ".", "optim", ".", "Optimizer", "\n", ")", "->", "torch", ".", "optim", ".", "lr_scheduler", ".", "_LRScheduler", ":", "\n", "    ", "\"\"\"\n    Build a LR scheduler from config.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "SOLVER", ".", "LR_SCHEDULER_NAME", "\n", "if", "name", "==", "\"WarmupPolyLR\"", ":", "\n", "        ", "return", "WarmupPolyLR", "(", "\n", "optimizer", ",", "\n", "cfg", ".", "SOLVER", ".", "MAX_ITER", ",", "\n", "warmup_factor", "=", "cfg", ".", "SOLVER", ".", "WARMUP_FACTOR", ",", "\n", "warmup_iters", "=", "cfg", ".", "SOLVER", ".", "WARMUP_ITERS", ",", "\n", "warmup_method", "=", "cfg", ".", "SOLVER", ".", "WARMUP_METHOD", ",", "\n", "power", "=", "cfg", ".", "SOLVER", ".", "POLY_LR_POWER", ",", "\n", "constant_ending", "=", "cfg", ".", "SOLVER", ".", "POLY_LR_CONSTANT_ENDING", ",", "\n", ")", "\n", "", "else", ":", "\n", "        ", "return", "build_d2_lr_scheduler", "(", "cfg", ",", "optimizer", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.lr_scheduler.WarmupPolyLR.__init__": [[25, 43], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["last_epoch", ":", "int", "=", "-", "1", ",", "\n", ")", ":", "\n", "        ", "if", "not", "list", "(", "milestones", ")", "==", "sorted", "(", "milestones", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Milestones should be a list of\"", "\" increasing integers. Got {}\"", ",", "milestones", "\n", ")", "\n", "", "self", ".", "milestones", "=", "milestones", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "warmup_factor", "=", "warmup_factor", "\n", "self", ".", "warmup_iters", "=", "warmup_iters", "\n", "self", ".", "warmup_method", "=", "warmup_method", "\n", "super", "(", ")", ".", "__init__", "(", "optimizer", ",", "last_epoch", ")", "\n", "\n", "", "def", "get_lr", "(", "self", ")", "->", "List", "[", "float", "]", ":", "\n", "        ", "warmup_factor", "=", "_get_warmup_factor_at_iter", "(", "\n", "self", ".", "warmup_method", ",", "self", ".", "last_epoch", ",", "self", ".", "warmup_iters", ",", "self", ".", "warmup_factor", "\n", ")", "\n", "return", "[", "\n", "base_lr", "*", "warmup_factor", "*", "self", ".", "gamma", "**", "bisect_right", "(", "self", ".", "milestones", ",", "self", ".", "last_epoch", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.lr_scheduler.WarmupPolyLR.get_lr": [[44, 58], ["detectron2.solver.lr_scheduler._get_warmup_factor_at_iter", "math.pow", "math.pow"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.solver.lr_scheduler._get_warmup_factor_at_iter"], ["for", "base_lr", "in", "self", ".", "base_lrs", "\n", "]", "\n", "\n", "", "def", "_compute_values", "(", "self", ")", "->", "List", "[", "float", "]", ":", "\n", "# The new interface", "\n", "        ", "return", "self", ".", "get_lr", "(", ")", "\n", "\n", "\n", "", "", "class", "WarmupCosineLR", "(", "torch", ".", "optim", ".", "lr_scheduler", ".", "_LRScheduler", ")", ":", "\n", "    ", "def", "__init__", "(", "\n", "self", ",", "\n", "optimizer", ":", "torch", ".", "optim", ".", "Optimizer", ",", "\n", "max_iters", ":", "int", ",", "\n", "warmup_factor", ":", "float", "=", "0.001", ",", "\n", "warmup_iters", ":", "int", "=", "1000", ",", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.lr_scheduler.WarmupPolyLR._compute_values": [[60, 63], ["lr_scheduler.WarmupPolyLR.get_lr"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.lr_scheduler.WarmupPolyLR.get_lr"], ["last_epoch", ":", "int", "=", "-", "1", ",", "\n", ")", ":", "\n", "        ", "self", ".", "max_iters", "=", "max_iters", "\n", "self", ".", "warmup_factor", "=", "warmup_factor", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3PlusHead.__init__": [[21, 171], ["torch.nn.Module.__init__", "torch.nn.ModuleDict", "enumerate", "len", "len", "len", "len", "len", "len", "torch.nn.ModuleDict", "detectron2.layers.Conv2d", "torch.nn.init.normal_", "torch.nn.init.constant_", "len", "len", "detectron2.layers.ASPP", "detectron2.layers.Conv2d", "torch.nn.Sequential", "fvcore.c2_xavier_fill", "fvcore.c2_xavier_fill", "fvcore.c2_xavier_fill", "torch.nn.CrossEntropyLoss", "len", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "loss.DeepLabCE", "ValueError", "ValueError", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "detectron2.layers.get_norm"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm"], ["SEM_SEG_HEADS_REGISTRY", ".", "__doc__", "=", "\"\"\"\nRegistry for semantic segmentation heads, which make semantic segmentation predictions\nfrom feature maps.\n\"\"\"", "\n", "\n", "\n", "@", "META_ARCH_REGISTRY", ".", "register", "(", ")", "\n", "class", "SemanticSegmentor", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "\"\"\"\n    Main class for semantic segmentation architectures.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "self", ".", "sem_seg_head", "=", "build_sem_seg_head", "(", "cfg", ",", "self", ".", "backbone", ".", "output_shape", "(", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_mean\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_MEAN", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_std\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_STD", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "\n", "", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "pixel_mean", ".", "device", "\n", "\n", "", "def", "forward", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            batched_inputs: a list, batched outputs of :class:`DatasetMapper`.\n                Each item in the list contains the inputs for one image.\n\n                For now, each item in the list is a dict that contains:\n\n                   * \"image\": Tensor, image in (C, H, W) format.\n                   * \"sem_seg\": semantic segmentation ground truth\n                   * Other information that's included in the original dicts, such as:\n                     \"height\", \"width\" (int): the output resolution of the model (may be different\n                     from input resolution), used in inference.\n\n\n        Returns:\n            list[dict]:\n              Each dict is the output for one input image.\n              The dict contains one key \"sem_seg\" whose value is a\n              Tensor that represents the\n              per-pixel segmentation prediced by the head.\n              The prediction has shape KxHxW that represents the logits of\n              each class for each pixel.\n        \"\"\"", "\n", "images", "=", "[", "x", "[", "\"image\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "images", "=", "[", "(", "x", "-", "self", ".", "pixel_mean", ")", "/", "self", ".", "pixel_std", "for", "x", "in", "images", "]", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "self", ".", "backbone", ".", "size_divisibility", ")", "\n", "\n", "features", "=", "self", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "\n", "if", "\"sem_seg\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "targets", "=", "[", "x", "[", "\"sem_seg\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "targets", "=", "ImageList", ".", "from_tensors", "(", "\n", "targets", ",", "self", ".", "backbone", ".", "size_divisibility", ",", "self", ".", "sem_seg_head", ".", "ignore_value", "\n", ")", ".", "tensor", "\n", "", "else", ":", "\n", "            ", "targets", "=", "None", "\n", "", "results", ",", "losses", "=", "self", ".", "sem_seg_head", "(", "features", ",", "targets", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "losses", "\n", "\n", "", "processed_results", "=", "[", "]", "\n", "for", "result", ",", "input_per_image", ",", "image_size", "in", "zip", "(", "results", ",", "batched_inputs", ",", "images", ".", "image_sizes", ")", ":", "\n", "            ", "height", "=", "input_per_image", ".", "get", "(", "\"height\"", ")", "\n", "width", "=", "input_per_image", ".", "get", "(", "\"width\"", ")", "\n", "r", "=", "sem_seg_postprocess", "(", "result", ",", "image_size", ",", "height", ",", "width", ")", "\n", "processed_results", ".", "append", "(", "{", "\"sem_seg\"", ":", "r", "}", ")", "\n", "", "return", "processed_results", "\n", "\n", "\n", "", "", "def", "build_sem_seg_head", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build a semantic segmentation head from `cfg.MODEL.SEM_SEG_HEAD.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NAME", "\n", "return", "SEM_SEG_HEADS_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "\n", "\n", "", "@", "SEM_SEG_HEADS_REGISTRY", ".", "register", "(", ")", "\n", "class", "SemSegFPNHead", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "\"\"\"\n    A semantic segmentation head described in :paper:`PanopticFPN`.\n    It takes FPN features as input and merges information from all\n    levels of the FPN into single output.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "Dict", "[", "str", ",", "ShapeSpec", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "self", ".", "in_features", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IN_FEATURES", "\n", "feature_strides", "=", "{", "k", ":", "v", ".", "stride", "for", "k", ",", "v", "in", "input_shape", ".", "items", "(", ")", "}", "\n", "feature_channels", "=", "{", "k", ":", "v", ".", "channels", "for", "k", ",", "v", "in", "input_shape", ".", "items", "(", ")", "}", "\n", "self", ".", "ignore_value", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IGNORE_VALUE", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NUM_CLASSES", "\n", "conv_dims", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "CONVS_DIM", "\n", "self", ".", "common_stride", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "COMMON_STRIDE", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NORM", "\n", "self", ".", "loss_weight", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "LOSS_WEIGHT", "\n", "# fmt: on", "\n", "\n", "self", ".", "scale_heads", "=", "[", "]", "\n", "for", "in_feature", "in", "self", ".", "in_features", ":", "\n", "            ", "head_ops", "=", "[", "]", "\n", "head_length", "=", "max", "(", "\n", "1", ",", "int", "(", "np", ".", "log2", "(", "feature_strides", "[", "in_feature", "]", ")", "-", "np", ".", "log2", "(", "self", ".", "common_stride", ")", ")", "\n", ")", "\n", "for", "k", "in", "range", "(", "head_length", ")", ":", "\n", "                ", "norm_module", "=", "nn", ".", "GroupNorm", "(", "32", ",", "conv_dims", ")", "if", "norm", "==", "\"GN\"", "else", "None", "\n", "conv", "=", "Conv2d", "(", "\n", "feature_channels", "[", "in_feature", "]", "if", "k", "==", "0", "else", "conv_dims", ",", "\n", "conv_dims", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "not", "norm", ",", "\n", "norm", "=", "norm_module", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", "\n", "weight_init", ".", "c2_msra_fill", "(", "conv", ")", "\n", "head_ops", ".", "append", "(", "conv", ")", "\n", "if", "feature_strides", "[", "in_feature", "]", "!=", "self", ".", "common_stride", ":", "\n", "                    ", "head_ops", ".", "append", "(", "\n", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", "\n", ")", "\n", "", "", "self", ".", "scale_heads", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "head_ops", ")", ")", "\n", "self", ".", "add_module", "(", "in_feature", ",", "self", ".", "scale_heads", "[", "-", "1", "]", ")", "\n", "", "self", ".", "predictor", "=", "Conv2d", "(", "conv_dims", ",", "num_classes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "weight_init", ".", "c2_msra_fill", "(", "self", ".", "predictor", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "features", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            In training, returns (None, dict of losses)\n            In inference, returns (CxHxW logits, {})\n        \"\"\"", "\n", "x", "=", "self", ".", "layers", "(", "features", ")", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "None", ",", "self", ".", "losses", "(", "x", ",", "targets", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "F", ".", "interpolate", "(", "\n", "x", ",", "scale_factor", "=", "self", ".", "common_stride", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "return", "x", ",", "{", "}", "\n", "\n", "", "", "def", "layers", "(", "self", ",", "features", ")", ":", "\n", "        ", "for", "i", ",", "f", "in", "enumerate", "(", "self", ".", "in_features", ")", ":", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3PlusHead.from_config": [[172, 198], ["dict", "len"], "methods", ["None"], ["            ", "if", "i", "==", "0", ":", "\n", "                ", "x", "=", "self", ".", "scale_heads", "[", "i", "]", "(", "features", "[", "f", "]", ")", "\n", "", "else", ":", "\n", "                ", "x", "=", "x", "+", "self", ".", "scale_heads", "[", "i", "]", "(", "features", "[", "f", "]", ")", "\n", "", "", "x", "=", "self", ".", "predictor", "(", "x", ")", "\n", "return", "x", "\n", "\n", "", "def", "losses", "(", "self", ",", "predictions", ",", "targets", ")", ":", "\n", "        ", "predictions", "=", "F", ".", "interpolate", "(", "\n", "predictions", ",", "scale_factor", "=", "self", ".", "common_stride", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "\n", "predictions", ",", "targets", ",", "reduction", "=", "\"mean\"", ",", "ignore_index", "=", "self", ".", "ignore_value", "\n", ")", "\n", "losses", "=", "{", "\"loss_sem_seg\"", ":", "loss", "*", "self", ".", "loss_weight", "}", "\n", "return", "losses", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3PlusHead.forward": [[199, 216], ["semantic_seg.DeepLabV3PlusHead.layers", "torch.nn.functional.interpolate", "semantic_seg.DeepLabV3PlusHead.losses"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3PlusHead.layers", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3Head.losses"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3PlusHead.layers": [[217, 233], ["semantic_seg.DeepLabV3PlusHead.predictor", "torch.nn.functional.interpolate", "torch.cat", "proj_x.size"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3PlusHead.losses": [[234, 241], ["torch.nn.functional.interpolate", "semantic_seg.DeepLabV3PlusHead.loss"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.multi_cls_head.MultiClsHead.loss"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3Head.__init__": [[249, 302], ["torch.nn.Module.__init__", "detectron2.layers.ASPP", "detectron2.layers.Conv2d", "torch.nn.init.normal_", "torch.nn.init.constant_", "len", "len", "torch.nn.CrossEntropyLoss", "ValueError", "loss.DeepLabCE", "ValueError"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3Head.forward": [[303, 319], ["semantic_seg.DeepLabV3Head.aspp", "semantic_seg.DeepLabV3Head.predictor", "torch.nn.functional.interpolate", "semantic_seg.DeepLabV3Head.losses"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3Head.losses"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3Head.losses": [[320, 327], ["torch.nn.functional.interpolate", "semantic_seg.DeepLabV3Head.loss"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.multi_cls_head.MultiClsHead.loss"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.query_db.Action.add_arguments": [[40, 47], ["parser.add_argument"], "methods", ["None"], ["    ", "@", "classmethod", "\n", "def", "add_arguments", "(", "cls", ":", "type", ",", "parser", ":", "argparse", ".", "ArgumentParser", ")", ":", "\n", "        ", "parser", ".", "add_argument", "(", "\n", "\"-v\"", ",", "\n", "\"--verbosity\"", ",", "\n", "action", "=", "\"count\"", ",", "\n", "help", "=", "\"Verbose mode. Multiple -v options increase the verbosity.\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.query_db.EntrywiseAction.add_arguments": [[60, 75], ["query_db.Action.add_arguments", "parser.add_argument", "parser.add_argument", "parser.add_argument"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.add_arguments"], ["    ", "@", "classmethod", "\n", "def", "add_arguments", "(", "cls", ":", "type", ",", "parser", ":", "argparse", ".", "ArgumentParser", ")", ":", "\n", "        ", "super", "(", "EntrywiseAction", ",", "cls", ")", ".", "add_arguments", "(", "parser", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"dataset\"", ",", "metavar", "=", "\"<dataset>\"", ",", "help", "=", "\"Dataset name (e.g. densepose_coco_2014_train)\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"selector\"", ",", "\n", "metavar", "=", "\"<selector>\"", ",", "\n", "help", "=", "\"Dataset entry selector in the form field1[:type]=value1[,\"", "\n", "\"field2[:type]=value_min-value_max...] which selects all \"", "\n", "\"entries from the dataset that satisfy the constraints\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--max-entries\"", ",", "metavar", "=", "\"N\"", ",", "help", "=", "\"Maximum number of entries to process\"", ",", "type", "=", "int", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.query_db.EntrywiseAction.execute": [[77, 90], ["query_db.setup_dataset", "densepose.utils.dbhelper.EntrySelector.from_string", "cls.create_context", "zip", "range", "densepose.utils.dbhelper.EntrySelector.from_string.", "densepose.utils.dbhelper.EntrySelector.from_string.", "cls.execute_on_entry", "cls.execute_on_entry"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.query_db.setup_dataset", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.dbhelper.EntrySelector.from_string", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.create_context", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.query_db.ShowAction.execute_on_entry", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.query_db.ShowAction.execute_on_entry"], ["", "@", "classmethod", "\n", "def", "execute", "(", "cls", ":", "type", ",", "args", ":", "argparse", ".", "Namespace", ")", ":", "\n", "        ", "dataset", "=", "setup_dataset", "(", "args", ".", "dataset", ")", "\n", "entry_selector", "=", "EntrySelector", ".", "from_string", "(", "args", ".", "selector", ")", "\n", "context", "=", "cls", ".", "create_context", "(", "args", ")", "\n", "if", "args", ".", "max_entries", "is", "not", "None", ":", "\n", "            ", "for", "_", ",", "entry", "in", "zip", "(", "range", "(", "args", ".", "max_entries", ")", ",", "dataset", ")", ":", "\n", "                ", "if", "entry_selector", "(", "entry", ")", ":", "\n", "                    ", "cls", ".", "execute_on_entry", "(", "entry", ",", "context", ")", "\n", "", "", "", "else", ":", "\n", "            ", "for", "entry", "in", "dataset", ":", "\n", "                ", "if", "entry_selector", "(", "entry", ")", ":", "\n", "                    ", "cls", ".", "execute_on_entry", "(", "entry", ",", "context", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.query_db.EntrywiseAction.create_context": [[91, 95], ["None"], "methods", ["None"], ["", "", "", "", "@", "classmethod", "\n", "def", "create_context", "(", "cls", ":", "type", ",", "args", ":", "argparse", ".", "Namespace", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "context", "=", "{", "}", "\n", "return", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.query_db.PrintAction.add_parser": [[105, 110], ["subparsers.add_parser", "cls.add_arguments", "subparsers.add_parser.set_defaults"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.add_parser", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.add_arguments"], ["@", "classmethod", "\n", "def", "add_parser", "(", "cls", ":", "type", ",", "subparsers", ":", "argparse", ".", "_SubParsersAction", ")", ":", "\n", "        ", "parser", "=", "subparsers", ".", "add_parser", "(", "cls", ".", "COMMAND", ",", "help", "=", "\"Output selected entries to stdout. \"", ")", "\n", "cls", ".", "add_arguments", "(", "parser", ")", "\n", "parser", ".", "set_defaults", "(", "func", "=", "cls", ".", "execute", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.query_db.PrintAction.add_arguments": [[111, 114], ["query_db.EntrywiseAction.add_arguments"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.add_arguments"], ["", "@", "classmethod", "\n", "def", "add_arguments", "(", "cls", ":", "type", ",", "parser", ":", "argparse", ".", "ArgumentParser", ")", ":", "\n", "        ", "super", "(", "PrintAction", ",", "cls", ")", ".", "add_arguments", "(", "parser", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.query_db.PrintAction.execute_on_entry": [[115, 121], ["pprint.PrettyPrinter", "pprint.PrettyPrinter.pprint"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "execute_on_entry", "(", "cls", ":", "type", ",", "entry", ":", "Dict", "[", "str", ",", "Any", "]", ",", "context", ":", "Dict", "[", "str", ",", "Any", "]", ")", ":", "\n", "        ", "import", "pprint", "\n", "\n", "printer", "=", "pprint", ".", "PrettyPrinter", "(", "indent", "=", "2", ",", "width", "=", "200", ",", "compact", "=", "True", ")", "\n", "printer", ".", "pprint", "(", "entry", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.query_db.ShowAction.add_parser": [[139, 144], ["subparsers.add_parser", "cls.add_arguments", "subparsers.add_parser.set_defaults"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.add_parser", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.add_arguments"], ["@", "classmethod", "\n", "def", "add_parser", "(", "cls", ":", "type", ",", "subparsers", ":", "argparse", ".", "_SubParsersAction", ")", ":", "\n", "        ", "parser", "=", "subparsers", ".", "add_parser", "(", "cls", ".", "COMMAND", ",", "help", "=", "\"Visualize selected entries\"", ")", "\n", "cls", ".", "add_arguments", "(", "parser", ")", "\n", "parser", ".", "set_defaults", "(", "func", "=", "cls", ".", "execute", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.query_db.ShowAction.add_arguments": [[145, 159], ["query_db.EntrywiseAction.add_arguments", "parser.add_argument", "parser.add_argument", "sorted", "cls.VISUALIZERS.keys"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.add_arguments"], ["", "@", "classmethod", "\n", "def", "add_arguments", "(", "cls", ":", "type", ",", "parser", ":", "argparse", ".", "ArgumentParser", ")", ":", "\n", "        ", "super", "(", "ShowAction", ",", "cls", ")", ".", "add_arguments", "(", "parser", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"visualizations\"", ",", "\n", "metavar", "=", "\"<visualizations>\"", ",", "\n", "help", "=", "\"Comma separated list of visualizations, possible values: \"", "\n", "\"[{}]\"", ".", "format", "(", "\",\"", ".", "join", "(", "sorted", "(", "cls", ".", "VISUALIZERS", ".", "keys", "(", ")", ")", ")", ")", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--output\"", ",", "\n", "metavar", "=", "\"<image_file>\"", ",", "\n", "default", "=", "\"output.png\"", ",", "\n", "help", "=", "\"File name to save output to\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.query_db.ShowAction.execute_on_entry": [[161, 177], ["fvcore.common.file_io.PathManager.get_local_path", "cv2.imread", "np.tile", "cls._extract_data_for_visualizers_from_entry", "visualizer.visualize", "cls._get_out_fname", "cv2.imwrite", "logger.info"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.query_db.ShowAction._extract_data_for_visualizers_from_entry", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_data_points.DensePoseDataPointsVisualizer.visualize", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction._get_out_fname"], ["", "@", "classmethod", "\n", "def", "execute_on_entry", "(", "cls", ":", "type", ",", "entry", ":", "Dict", "[", "str", ",", "Any", "]", ",", "context", ":", "Dict", "[", "str", ",", "Any", "]", ")", ":", "\n", "        ", "import", "cv2", "\n", "import", "numpy", "as", "np", "\n", "\n", "image_fpath", "=", "PathManager", ".", "get_local_path", "(", "entry", "[", "\"file_name\"", "]", ")", "\n", "image", "=", "cv2", ".", "imread", "(", "image_fpath", ",", "cv2", ".", "IMREAD_GRAYSCALE", ")", "\n", "image", "=", "np", ".", "tile", "(", "image", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", ",", "[", "1", ",", "1", ",", "3", "]", ")", "\n", "datas", "=", "cls", ".", "_extract_data_for_visualizers_from_entry", "(", "context", "[", "\"vis_specs\"", "]", ",", "entry", ")", "\n", "visualizer", "=", "context", "[", "\"visualizer\"", "]", "\n", "image_vis", "=", "visualizer", ".", "visualize", "(", "image", ",", "datas", ")", "\n", "entry_idx", "=", "context", "[", "\"entry_idx\"", "]", "+", "1", "\n", "out_fname", "=", "cls", ".", "_get_out_fname", "(", "entry_idx", ",", "context", "[", "\"out_fname\"", "]", ")", "\n", "cv2", ".", "imwrite", "(", "out_fname", ",", "image_vis", ")", "\n", "logger", ".", "info", "(", "f\"Output saved to {out_fname}\"", ")", "\n", "context", "[", "\"entry_idx\"", "]", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.query_db.ShowAction._get_out_fname": [[178, 182], ["os.path.splitext"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "_get_out_fname", "(", "cls", ":", "type", ",", "entry_idx", ":", "int", ",", "fname_base", ":", "str", ")", ":", "\n", "        ", "base", ",", "ext", "=", "os", ".", "path", ".", "splitext", "(", "fname_base", ")", "\n", "return", "base", "+", "\".{0:04d}\"", ".", "format", "(", "entry_idx", ")", "+", "ext", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.query_db.ShowAction.create_context": [[183, 197], ["args.visualizations.split", "visualizers.append", "densepose.vis.base.CompoundVisualizer"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "create_context", "(", "cls", ":", "type", ",", "args", ":", "argparse", ".", "Namespace", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "vis_specs", "=", "args", ".", "visualizations", ".", "split", "(", "\",\"", ")", "\n", "visualizers", "=", "[", "]", "\n", "for", "vis_spec", "in", "vis_specs", ":", "\n", "            ", "vis", "=", "cls", ".", "VISUALIZERS", "[", "vis_spec", "]", "\n", "visualizers", ".", "append", "(", "vis", ")", "\n", "", "context", "=", "{", "\n", "\"vis_specs\"", ":", "vis_specs", ",", "\n", "\"visualizer\"", ":", "CompoundVisualizer", "(", "visualizers", ")", ",", "\n", "\"out_fname\"", ":", "args", ".", "output", ",", "\n", "\"entry_idx\"", ":", "0", ",", "\n", "}", "\n", "return", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.query_db.ShowAction._extract_data_for_visualizers_from_entry": [[198, 216], ["densepose.data.structures.DensePoseDataRelative.validate_annotation", "torch.as_tensor", "bbox_list.append", "densepose.data.structures.DensePoseDataRelative", "dp_list.append", "datas.append"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "_extract_data_for_visualizers_from_entry", "(", "\n", "cls", ":", "type", ",", "vis_specs", ":", "List", "[", "str", "]", ",", "entry", ":", "Dict", "[", "str", ",", "Any", "]", "\n", ")", ":", "\n", "        ", "dp_list", "=", "[", "]", "\n", "bbox_list", "=", "[", "]", "\n", "for", "annotation", "in", "entry", "[", "\"annotations\"", "]", ":", "\n", "            ", "is_valid", ",", "_", "=", "DensePoseDataRelative", ".", "validate_annotation", "(", "annotation", ")", "\n", "if", "not", "is_valid", ":", "\n", "                ", "continue", "\n", "", "bbox", "=", "torch", ".", "as_tensor", "(", "annotation", "[", "\"bbox\"", "]", ")", "\n", "bbox_list", ".", "append", "(", "bbox", ")", "\n", "dp_data", "=", "DensePoseDataRelative", "(", "annotation", ")", "\n", "dp_list", ".", "append", "(", "dp_data", ")", "\n", "", "datas", "=", "[", "]", "\n", "for", "vis_spec", "in", "vis_specs", ":", "\n", "            ", "datas", ".", "append", "(", "bbox_list", "if", "\"bbox\"", "==", "vis_spec", "else", "(", "bbox_list", ",", "dp_list", ")", ")", "\n", "", "return", "datas", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.query_db.register_action": [[50, 57], ["None"], "function", ["None"], ["", "", "def", "register_action", "(", "cls", ":", "type", ")", ":", "\n", "    ", "\"\"\"\n    Decorator for action classes to automate action registration\n    \"\"\"", "\n", "global", "_ACTION_REGISTRY", "\n", "_ACTION_REGISTRY", "[", "cls", ".", "COMMAND", "]", "=", "cls", "\n", "return", "cls", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.query_db.setup_dataset": [[218, 225], ["logger.info", "timeit.default_timer", "detectron2.data.catalog.DatasetCatalog.get", "timeit.default_timer", "logger.info"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "", "def", "setup_dataset", "(", "dataset_name", ")", ":", "\n", "    ", "logger", ".", "info", "(", "\"Loading dataset {}\"", ".", "format", "(", "dataset_name", ")", ")", "\n", "start", "=", "timer", "(", ")", "\n", "dataset", "=", "DatasetCatalog", ".", "get", "(", "dataset_name", ")", "\n", "stop", "=", "timer", "(", ")", "\n", "logger", ".", "info", "(", "\"Loaded dataset {} in {:.3f}s\"", ".", "format", "(", "dataset_name", ",", "stop", "-", "start", ")", ")", "\n", "return", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.query_db.create_argument_parser": [[227, 237], ["argparse.ArgumentParser", "argparse.ArgumentParser.set_defaults", "argparse.ArgumentParser.add_subparsers", "_ACTION_REGISTRY.items", "action.add_parser", "argparse.HelpFormatter", "argparse.ArgumentParser.print_help"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.add_parser"], ["", "def", "create_argument_parser", "(", ")", "->", "argparse", ".", "ArgumentParser", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "DOC", ",", "\n", "formatter_class", "=", "lambda", "prog", ":", "argparse", ".", "HelpFormatter", "(", "prog", ",", "max_help_position", "=", "120", ")", ",", "\n", ")", "\n", "parser", ".", "set_defaults", "(", "func", "=", "lambda", "_", ":", "parser", ".", "print_help", "(", "sys", ".", "stdout", ")", ")", "\n", "subparsers", "=", "parser", ".", "add_subparsers", "(", "title", "=", "\"Actions\"", ")", "\n", "for", "_", ",", "action", "in", "_ACTION_REGISTRY", ".", "items", "(", ")", ":", "\n", "        ", "action", ".", "add_parser", "(", "subparsers", ")", "\n", "", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.query_db.main": [[239, 247], ["query_db.create_argument_parser", "create_argument_parser.parse_args", "detectron2.utils.logger.setup_logger", "detectron2.utils.logger.setup_logger.setLevel", "parser.parse_args.func", "hasattr", "densepose.utils.logger.verbosity_to_level"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.create_argument_parser", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.setup_logger", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.verbosity_to_level"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "create_argument_parser", "(", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "verbosity", "=", "args", ".", "verbosity", "if", "hasattr", "(", "args", ",", "\"verbosity\"", ")", "else", "None", "\n", "global", "logger", "\n", "logger", "=", "setup_logger", "(", "name", "=", "LOGGER_NAME", ")", "\n", "logger", ".", "setLevel", "(", "verbosity_to_level", "(", "verbosity", ")", ")", "\n", "args", ".", "func", "(", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.Action.add_arguments": [[42, 49], ["parser.add_argument"], "methods", ["None"], ["    ", "@", "classmethod", "\n", "def", "add_arguments", "(", "cls", ":", "type", ",", "parser", ":", "argparse", ".", "ArgumentParser", ")", ":", "\n", "        ", "parser", ".", "add_argument", "(", "\n", "\"-v\"", ",", "\n", "\"--verbosity\"", ",", "\n", "action", "=", "\"count\"", ",", "\n", "help", "=", "\"Verbose mode. Multiple -v options increase the verbosity.\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.InferenceAction.add_arguments": [[62, 73], ["apply_net.Action.add_arguments", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.add_arguments"], ["    ", "@", "classmethod", "\n", "def", "add_arguments", "(", "cls", ":", "type", ",", "parser", ":", "argparse", ".", "ArgumentParser", ")", ":", "\n", "        ", "super", "(", "InferenceAction", ",", "cls", ")", ".", "add_arguments", "(", "parser", ")", "\n", "parser", ".", "add_argument", "(", "\"cfg\"", ",", "metavar", "=", "\"<config>\"", ",", "help", "=", "\"Config file\"", ")", "\n", "parser", ".", "add_argument", "(", "\"model\"", ",", "metavar", "=", "\"<model>\"", ",", "help", "=", "\"Model file\"", ")", "\n", "parser", ".", "add_argument", "(", "\"input\"", ",", "metavar", "=", "\"<input>\"", ",", "help", "=", "\"Input data\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--opts\"", ",", "\n", "help", "=", "\"Modify config options using the command-line 'KEY VALUE' pairs\"", ",", "\n", "default", "=", "[", "]", ",", "\n", "nargs", "=", "argparse", ".", "REMAINDER", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.InferenceAction.execute": [[75, 94], ["logger.info", "cls.setup_config", "logger.info", "detectron2.engine.defaults.DefaultPredictor", "logger.info", "cls._get_input_file_list", "cls.create_context", "cls.postexecute", "len", "logger.warning", "detectron2.data.detection_utils.read_image", "torch.no_grad", "cls.execute_on_outputs", "detectron2.engine.defaults.DefaultPredictor."], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.setup_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.InferenceAction._get_input_file_list", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.create_context", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.postexecute", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.execute_on_outputs"], ["", "@", "classmethod", "\n", "def", "execute", "(", "cls", ":", "type", ",", "args", ":", "argparse", ".", "Namespace", ")", ":", "\n", "        ", "logger", ".", "info", "(", "f\"Loading config from {args.cfg}\"", ")", "\n", "opts", "=", "[", "]", "\n", "cfg", "=", "cls", ".", "setup_config", "(", "args", ".", "cfg", ",", "args", ".", "model", ",", "args", ",", "opts", ")", "\n", "logger", ".", "info", "(", "f\"Loading model from {args.model}\"", ")", "\n", "predictor", "=", "DefaultPredictor", "(", "cfg", ")", "\n", "logger", ".", "info", "(", "f\"Loading data from {args.input}\"", ")", "\n", "file_list", "=", "cls", ".", "_get_input_file_list", "(", "args", ".", "input", ")", "\n", "if", "len", "(", "file_list", ")", "==", "0", ":", "\n", "            ", "logger", ".", "warning", "(", "f\"No input images for {args.input}\"", ")", "\n", "return", "\n", "", "context", "=", "cls", ".", "create_context", "(", "args", ")", "\n", "for", "file_name", "in", "file_list", ":", "\n", "            ", "img", "=", "read_image", "(", "file_name", ",", "format", "=", "\"BGR\"", ")", "# predictor expects BGR image.", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "outputs", "=", "predictor", "(", "img", ")", "[", "\"instances\"", "]", "\n", "cls", ".", "execute_on_outputs", "(", "context", ",", "{", "\"file_name\"", ":", "file_name", ",", "\"image\"", ":", "img", "}", ",", "outputs", ")", "\n", "", "", "cls", ".", "postexecute", "(", "context", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.InferenceAction.setup_config": [[95, 109], ["detectron2.config.get_cfg", "densepose.add_densepose_config", "densepose.add_hrnet_config", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.config.get_cfg.merge_from_list"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.config.add_densepose_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.config.add_hrnet_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze"], ["", "@", "classmethod", "\n", "def", "setup_config", "(", "\n", "cls", ":", "type", ",", "config_fpath", ":", "str", ",", "model_fpath", ":", "str", ",", "args", ":", "argparse", ".", "Namespace", ",", "opts", ":", "List", "[", "str", "]", "\n", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "add_densepose_config", "(", "cfg", ")", "\n", "add_hrnet_config", "(", "cfg", ")", "\n", "cfg", ".", "merge_from_file", "(", "config_fpath", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "if", "opts", ":", "\n", "            ", "cfg", ".", "merge_from_list", "(", "opts", ")", "\n", "", "cfg", ".", "MODEL", ".", "WEIGHTS", "=", "model_fpath", "\n", "cfg", ".", "freeze", "(", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.InferenceAction._get_input_file_list": [[110, 123], ["os.path.isdir", "os.path.isfile", "os.path.join", "glob.glob", "os.listdir", "os.path.isfile", "os.path.join"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "_get_input_file_list", "(", "cls", ":", "type", ",", "input_spec", ":", "str", ")", ":", "\n", "        ", "if", "os", ".", "path", ".", "isdir", "(", "input_spec", ")", ":", "\n", "            ", "file_list", "=", "[", "\n", "os", ".", "path", ".", "join", "(", "input_spec", ",", "fname", ")", "\n", "for", "fname", "in", "os", ".", "listdir", "(", "input_spec", ")", "\n", "if", "os", ".", "path", ".", "isfile", "(", "os", ".", "path", ".", "join", "(", "input_spec", ",", "fname", ")", ")", "\n", "]", "\n", "", "elif", "os", ".", "path", ".", "isfile", "(", "input_spec", ")", ":", "\n", "            ", "file_list", "=", "[", "input_spec", "]", "\n", "", "else", ":", "\n", "            ", "file_list", "=", "glob", ".", "glob", "(", "input_spec", ")", "\n", "", "return", "file_list", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.DumpAction.add_parser": [[133, 138], ["subparsers.add_parser", "cls.add_arguments", "subparsers.add_parser.set_defaults"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.add_parser", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.add_arguments"], ["@", "classmethod", "\n", "def", "add_parser", "(", "cls", ":", "type", ",", "subparsers", ":", "argparse", ".", "_SubParsersAction", ")", ":", "\n", "        ", "parser", "=", "subparsers", ".", "add_parser", "(", "cls", ".", "COMMAND", ",", "help", "=", "\"Dump model outputs to a file.\"", ")", "\n", "cls", ".", "add_arguments", "(", "parser", ")", "\n", "parser", ".", "set_defaults", "(", "func", "=", "cls", ".", "execute", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.DumpAction.add_arguments": [[139, 147], ["apply_net.InferenceAction.add_arguments", "parser.add_argument"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.add_arguments"], ["", "@", "classmethod", "\n", "def", "add_arguments", "(", "cls", ":", "type", ",", "parser", ":", "argparse", ".", "ArgumentParser", ")", ":", "\n", "        ", "super", "(", "DumpAction", ",", "cls", ")", ".", "add_arguments", "(", "parser", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--output\"", ",", "\n", "metavar", "=", "\"<dump_file>\"", ",", "\n", "default", "=", "\"results.pkl\"", ",", "\n", "help", "=", "\"File name to save dump to\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.DumpAction.execute_on_outputs": [[149, 166], ["logger.info", "outputs.has", "outputs.has", "context[].append", "outputs.get().cpu", "outputs.get().tensor.cpu", "outputs.has", "detectron2.structures.boxes.BoxMode.convert", "outputs.get().to_result", "outputs.get", "outputs.get", "outputs.get"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "@", "classmethod", "\n", "def", "execute_on_outputs", "(", "\n", "cls", ":", "type", ",", "context", ":", "Dict", "[", "str", ",", "Any", "]", ",", "entry", ":", "Dict", "[", "str", ",", "Any", "]", ",", "outputs", ":", "Instances", "\n", ")", ":", "\n", "        ", "image_fpath", "=", "entry", "[", "\"file_name\"", "]", "\n", "logger", ".", "info", "(", "f\"Processing {image_fpath}\"", ")", "\n", "result", "=", "{", "\"file_name\"", ":", "image_fpath", "}", "\n", "if", "outputs", ".", "has", "(", "\"scores\"", ")", ":", "\n", "            ", "result", "[", "\"scores\"", "]", "=", "outputs", ".", "get", "(", "\"scores\"", ")", ".", "cpu", "(", ")", "\n", "", "if", "outputs", ".", "has", "(", "\"pred_boxes\"", ")", ":", "\n", "            ", "result", "[", "\"pred_boxes_XYXY\"", "]", "=", "outputs", ".", "get", "(", "\"pred_boxes\"", ")", ".", "tensor", ".", "cpu", "(", ")", "\n", "if", "outputs", ".", "has", "(", "\"pred_densepose\"", ")", ":", "\n", "                ", "boxes_XYWH", "=", "BoxMode", ".", "convert", "(", "\n", "result", "[", "\"pred_boxes_XYXY\"", "]", ",", "BoxMode", ".", "XYXY_ABS", ",", "BoxMode", ".", "XYWH_ABS", "\n", ")", "\n", "result", "[", "\"pred_densepose\"", "]", "=", "outputs", ".", "get", "(", "\"pred_densepose\"", ")", ".", "to_result", "(", "boxes_XYWH", ")", "\n", "", "", "context", "[", "\"results\"", "]", ".", "append", "(", "result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.DumpAction.create_context": [[167, 171], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "create_context", "(", "cls", ":", "type", ",", "args", ":", "argparse", ".", "Namespace", ")", ":", "\n", "        ", "context", "=", "{", "\"results\"", ":", "[", "]", ",", "\"out_fname\"", ":", "args", ".", "output", "}", "\n", "return", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.DumpAction.postexecute": [[172, 181], ["os.path.dirname", "os.makedirs", "open", "pickle.dump", "logger.info", "len", "os.path.exists"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.dump"], ["", "@", "classmethod", "\n", "def", "postexecute", "(", "cls", ":", "type", ",", "context", ":", "Dict", "[", "str", ",", "Any", "]", ")", ":", "\n", "        ", "out_fname", "=", "context", "[", "\"out_fname\"", "]", "\n", "out_dir", "=", "os", ".", "path", ".", "dirname", "(", "out_fname", ")", "\n", "if", "len", "(", "out_dir", ")", ">", "0", "and", "not", "os", ".", "path", ".", "exists", "(", "out_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "out_dir", ")", "\n", "", "with", "open", "(", "out_fname", ",", "\"wb\"", ")", "as", "hFile", ":", "\n", "            ", "pickle", ".", "dump", "(", "context", "[", "\"results\"", "]", ",", "hFile", ")", "\n", "logger", ".", "info", "(", "f\"Output saved to {out_fname}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.add_parser": [[198, 203], ["subparsers.add_parser", "cls.add_arguments", "subparsers.add_parser.set_defaults"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.add_parser", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.add_arguments"], ["@", "classmethod", "\n", "def", "add_parser", "(", "cls", ":", "type", ",", "subparsers", ":", "argparse", ".", "_SubParsersAction", ")", ":", "\n", "        ", "parser", "=", "subparsers", ".", "add_parser", "(", "cls", ".", "COMMAND", ",", "help", "=", "\"Visualize selected entries\"", ")", "\n", "cls", ".", "add_arguments", "(", "parser", ")", "\n", "parser", ".", "set_defaults", "(", "func", "=", "cls", ".", "execute", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.add_arguments": [[204, 228], ["apply_net.InferenceAction.add_arguments", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "sorted", "cls.VISUALIZERS.keys"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.add_arguments"], ["", "@", "classmethod", "\n", "def", "add_arguments", "(", "cls", ":", "type", ",", "parser", ":", "argparse", ".", "ArgumentParser", ")", ":", "\n", "        ", "super", "(", "ShowAction", ",", "cls", ")", ".", "add_arguments", "(", "parser", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"visualizations\"", ",", "\n", "metavar", "=", "\"<visualizations>\"", ",", "\n", "help", "=", "\"Comma separated list of visualizations, possible values: \"", "\n", "\"[{}]\"", ".", "format", "(", "\",\"", ".", "join", "(", "sorted", "(", "cls", ".", "VISUALIZERS", ".", "keys", "(", ")", ")", ")", ")", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--min_score\"", ",", "\n", "metavar", "=", "\"<score>\"", ",", "\n", "default", "=", "0.8", ",", "\n", "type", "=", "float", ",", "\n", "help", "=", "\"Minimum detection score to visualize\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--nms_thresh\"", ",", "metavar", "=", "\"<threshold>\"", ",", "default", "=", "None", ",", "type", "=", "float", ",", "help", "=", "\"NMS threshold\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--output\"", ",", "\n", "metavar", "=", "\"<image_file>\"", ",", "\n", "default", "=", "\"outputres.png\"", ",", "\n", "help", "=", "\"File name to save output to\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.setup_config": [[230, 241], ["opts.append", "opts.append", "apply_net.InferenceAction.setup_config", "str", "opts.append", "opts.append", "str"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.setup_config"], ["", "@", "classmethod", "\n", "def", "setup_config", "(", "\n", "cls", ":", "type", ",", "config_fpath", ":", "str", ",", "model_fpath", ":", "str", ",", "args", ":", "argparse", ".", "Namespace", ",", "opts", ":", "List", "[", "str", "]", "\n", ")", ":", "\n", "        ", "opts", ".", "append", "(", "\"MODEL.ROI_HEADS.SCORE_THRESH_TEST\"", ")", "\n", "opts", ".", "append", "(", "str", "(", "args", ".", "min_score", ")", ")", "\n", "if", "args", ".", "nms_thresh", "is", "not", "None", ":", "\n", "            ", "opts", ".", "append", "(", "\"MODEL.ROI_HEADS.NMS_THRESH_TEST\"", ")", "\n", "opts", ".", "append", "(", "str", "(", "args", ".", "nms_thresh", ")", ")", "\n", "", "cfg", "=", "super", "(", "ShowAction", ",", "cls", ")", ".", "setup_config", "(", "config_fpath", ",", "model_fpath", ",", "args", ",", "opts", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.execute_on_outputs": [[242, 265], ["logger.info", "cv2.cvtColor", "np.tile", "extractor", "visualizer.visualize", "cls._get_out_fname", "os.path.dirname", "cv2.imwrite", "logger.info", "os.makedirs", "len", "os.path.exists"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_data_points.DensePoseDataPointsVisualizer.visualize", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction._get_out_fname"], ["", "@", "classmethod", "\n", "def", "execute_on_outputs", "(", "\n", "cls", ":", "type", ",", "context", ":", "Dict", "[", "str", ",", "Any", "]", ",", "entry", ":", "Dict", "[", "str", ",", "Any", "]", ",", "outputs", ":", "Instances", "\n", ")", ":", "\n", "        ", "import", "cv2", "\n", "import", "numpy", "as", "np", "\n", "\n", "visualizer", "=", "context", "[", "\"visualizer\"", "]", "\n", "extractor", "=", "context", "[", "\"extractor\"", "]", "\n", "image_fpath", "=", "entry", "[", "\"file_name\"", "]", "\n", "logger", ".", "info", "(", "f\"Processing {image_fpath}\"", ")", "\n", "image", "=", "cv2", ".", "cvtColor", "(", "entry", "[", "\"image\"", "]", ",", "cv2", ".", "COLOR_BGR2GRAY", ")", "\n", "image", "=", "np", ".", "tile", "(", "image", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", ",", "[", "1", ",", "1", ",", "3", "]", ")", "\n", "data", "=", "extractor", "(", "outputs", ")", "\n", "image_vis", "=", "visualizer", ".", "visualize", "(", "image", ",", "data", ")", "\n", "entry_idx", "=", "context", "[", "\"entry_idx\"", "]", "+", "1", "\n", "out_fname", "=", "cls", ".", "_get_out_fname", "(", "entry_idx", ",", "context", "[", "\"out_fname\"", "]", ")", "\n", "out_dir", "=", "os", ".", "path", ".", "dirname", "(", "out_fname", ")", "\n", "if", "len", "(", "out_dir", ")", ">", "0", "and", "not", "os", ".", "path", ".", "exists", "(", "out_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "out_dir", ")", "\n", "", "cv2", ".", "imwrite", "(", "out_fname", ",", "image_vis", ")", "\n", "logger", ".", "info", "(", "f\"Output saved to {out_fname}\"", ")", "\n", "context", "[", "\"entry_idx\"", "]", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.postexecute": [[266, 269], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "postexecute", "(", "cls", ":", "type", ",", "context", ":", "Dict", "[", "str", ",", "Any", "]", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction._get_out_fname": [[270, 274], ["os.path.splitext"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "_get_out_fname", "(", "cls", ":", "type", ",", "entry_idx", ":", "int", ",", "fname_base", ":", "str", ")", ":", "\n", "        ", "base", ",", "ext", "=", "os", ".", "path", ".", "splitext", "(", "fname_base", ")", "\n", "return", "base", "+", "\".{0:04d}\"", ".", "format", "(", "entry_idx", ")", "+", "ext", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.create_context": [[275, 294], ["args.visualizations.split", "densepose.vis.base.CompoundVisualizer", "densepose.vis.extractor.CompoundExtractor", "visualizers.append", "densepose.vis.extractor.create_extractor", "extractors.append"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.extractor.create_extractor"], ["", "@", "classmethod", "\n", "def", "create_context", "(", "cls", ":", "type", ",", "args", ":", "argparse", ".", "Namespace", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "vis_specs", "=", "args", ".", "visualizations", ".", "split", "(", "\",\"", ")", "\n", "visualizers", "=", "[", "]", "\n", "extractors", "=", "[", "]", "\n", "for", "vis_spec", "in", "vis_specs", ":", "\n", "            ", "vis", "=", "cls", ".", "VISUALIZERS", "[", "vis_spec", "]", "(", ")", "\n", "visualizers", ".", "append", "(", "vis", ")", "\n", "extractor", "=", "create_extractor", "(", "vis", ")", "\n", "extractors", ".", "append", "(", "extractor", ")", "\n", "", "visualizer", "=", "CompoundVisualizer", "(", "visualizers", ")", "\n", "extractor", "=", "CompoundExtractor", "(", "extractors", ")", "\n", "context", "=", "{", "\n", "\"extractor\"", ":", "extractor", ",", "\n", "\"visualizer\"", ":", "visualizer", ",", "\n", "\"out_fname\"", ":", "args", ".", "output", ",", "\n", "\"entry_idx\"", ":", "0", ",", "\n", "}", "\n", "return", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.register_action": [[52, 59], ["None"], "function", ["None"], ["", "", "def", "register_action", "(", "cls", ":", "type", ")", ":", "\n", "    ", "\"\"\"\n    Decorator for action classes to automate action registration\n    \"\"\"", "\n", "global", "_ACTION_REGISTRY", "\n", "_ACTION_REGISTRY", "[", "cls", ".", "COMMAND", "]", "=", "cls", "\n", "return", "cls", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.create_argument_parser": [[296, 306], ["argparse.ArgumentParser", "argparse.ArgumentParser.set_defaults", "argparse.ArgumentParser.add_subparsers", "_ACTION_REGISTRY.items", "action.add_parser", "argparse.HelpFormatter", "argparse.ArgumentParser.print_help"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.ShowAction.add_parser"], ["", "", "def", "create_argument_parser", "(", ")", "->", "argparse", ".", "ArgumentParser", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "DOC", ",", "\n", "formatter_class", "=", "lambda", "prog", ":", "argparse", ".", "HelpFormatter", "(", "prog", ",", "max_help_position", "=", "120", ")", ",", "\n", ")", "\n", "parser", ".", "set_defaults", "(", "func", "=", "lambda", "_", ":", "parser", ".", "print_help", "(", "sys", ".", "stdout", ")", ")", "\n", "subparsers", "=", "parser", ".", "add_subparsers", "(", "title", "=", "\"Actions\"", ")", "\n", "for", "_", ",", "action", "in", "_ACTION_REGISTRY", ".", "items", "(", ")", ":", "\n", "        ", "action", ".", "add_parser", "(", "subparsers", ")", "\n", "", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.main": [[308, 316], ["apply_net.create_argument_parser", "create_argument_parser.parse_args", "detectron2.utils.logger.setup_logger", "detectron2.utils.logger.setup_logger.setLevel", "parser.parse_args.func", "hasattr", "densepose.utils.logger.verbosity_to_level"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.apply_net.create_argument_parser", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.setup_logger", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.verbosity_to_level"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "create_argument_parser", "(", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "verbosity", "=", "args", ".", "verbosity", "if", "hasattr", "(", "args", ",", "\"verbosity\"", ")", "else", "None", "\n", "global", "logger", "\n", "logger", "=", "setup_logger", "(", "name", "=", "LOGGER_NAME", ")", "\n", "logger", ".", "setLevel", "(", "verbosity_to_level", "(", "verbosity", ")", ")", "\n", "args", ".", "func", "(", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.train_net.setup": [[25, 35], ["detectron2.config.get_cfg", "densepose.add_densepose_config", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.engine.default_setup", "detectron2.utils.logger.setup_logger", "detectron2.get_rank"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.config.add_densepose_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.default_setup", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.setup_logger", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank"], ["\n", "\n", "def", "_build_res5_block", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "seq", ",", "out_channels", "=", "super", "(", ")", ".", "_build_res5_block", "(", "cfg", ")", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "NORM", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", "\n", "seq", ".", "add_module", "(", "\"norm\"", ",", "norm", ")", "\n", "return", "seq", ",", "out_channels", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.DensePose.train_net.main": [[37, 62], ["train_net.setup", "fvcore.common.file_io.PathManager.set_strict_kwargs_checking", "densepose.engine.Trainer", "densepose.engine.Trainer.resume_or_load", "densepose.engine.Trainer.train", "densepose.engine.Trainer.build_model", "densepose.modeling.densepose_checkpoint.DensePoseCheckpointer().resume_or_load", "densepose.engine.Trainer.test", "detectron2.is_main_process", "densepose.engine.Trainer.register_hooks", "Trainer.test.update", "detectron2.evaluation.verify_results", "densepose.modeling.densepose_checkpoint.DensePoseCheckpointer", "densepose.engine.Trainer.test_with_TTA", "detectron2.engine.hooks.EvalHook", "densepose.engine.Trainer.test_with_TTA"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.setup", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_packaging.TestCollectEnv.test", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.train_loop.TrainerBase.register_hooks", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.testing.verify_results", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.Trainer.test_with_TTA", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.trainer.Trainer.test_with_TTA"], ["\n", "    ", "@", "classmethod", "\n", "def", "build_evaluator", "(", "cls", ",", "cfg", ",", "dataset_name", ",", "output_folder", "=", "None", ")", ":", "\n", "        ", "if", "output_folder", "is", "None", ":", "\n", "            ", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference\"", ")", "\n", "", "if", "\"voc\"", "in", "dataset_name", ":", "\n", "            ", "return", "PascalVOCDetectionEvaluator", "(", "dataset_name", ")", "\n", "", "else", ":", "\n", "            ", "return", "COCOEvaluator", "(", "dataset_name", ",", "cfg", ",", "True", ",", "output_folder", ")", "\n", "\n", "\n", "", "", "", "def", "setup", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "default_setup", "(", "cfg", ",", "args", ")", "\n", "return", "cfg", "\n", "\n", "\n", "", "def", "main", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "setup", "(", "args", ")", "\n", "\n", "if", "args", ".", "eval_only", ":", "\n", "        ", "model", "=", "Trainer", ".", "build_model", "(", "cfg", ")", "\n", "DetectionCheckpointer", "(", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.config.add_dataset_category_config": [[7, 16], ["detectron2.config.CfgNode", "detectron2.config.CfgNode"], "function", ["None"], ["from", "fvcore", ".", "common", ".", "config", "import", "CfgNode", "as", "_CfgNode", "\n", "from", "fvcore", ".", "common", ".", "file_io", "import", "PathManager", "\n", "\n", "\n", "class", "CfgNode", "(", "_CfgNode", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.config.add_bootstrap_config": [[18, 26], ["detectron2.config.CfgNode"], "function", ["None"], ["\n", "\n", "# Note that the default value of allow_unsafe is changed to True", "\n", "def", "merge_from_file", "(", "self", ",", "cfg_filename", ":", "str", ",", "allow_unsafe", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "        ", "assert", "PathManager", ".", "isfile", "(", "cfg_filename", ")", ",", "f\"Config file '{cfg_filename}' does not exist!\"", "\n", "loaded_cfg", "=", "_CfgNode", ".", "load_yaml_with_base", "(", "cfg_filename", ",", "allow_unsafe", "=", "allow_unsafe", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.config.get_bootstrap_dataset_config": [[28, 51], ["detectron2.config.CfgNode", "detectron2.config.CfgNode", "detectron2.config.CfgNode", "detectron2.config.CfgNode", "detectron2.config.CfgNode"], "function", ["None"], ["\n", "# defaults.py needs to import CfgNode", "\n", "from", ".", "defaults", "import", "_C", "\n", "\n", "latest_ver", "=", "_C", ".", "VERSION", "\n", "assert", "(", "\n", "latest_ver", "==", "self", ".", "VERSION", "\n", ")", ",", "\"CfgNode.merge_from_file is only allowed on a config object of latest version!\"", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "loaded_ver", "=", "loaded_cfg", ".", "get", "(", "\"VERSION\"", ",", "None", ")", "\n", "if", "loaded_ver", "is", "None", ":", "\n", "            ", "from", ".", "compat", "import", "guess_version", "\n", "\n", "loaded_ver", "=", "guess_version", "(", "loaded_cfg", ",", "cfg_filename", ")", "\n", "", "assert", "loaded_ver", "<=", "self", ".", "VERSION", ",", "\"Cannot merge a v{} config into a v{} config.\"", ".", "format", "(", "\n", "loaded_ver", ",", "self", ".", "VERSION", "\n", ")", "\n", "\n", "if", "loaded_ver", "==", "self", ".", "VERSION", ":", "\n", "            ", "self", ".", "merge_from_other_cfg", "(", "loaded_cfg", ")", "\n", "", "else", ":", "\n", "# compat.py needs to import CfgNode", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.config.load_bootstrap_config": [[53, 68], ["get_bootstrap_dataset_config().clone", "get_bootstrap_dataset_config().clone.merge_from_other_cfg", "bootstrap_datasets_cfgnodes.append", "detectron2.config.CfgNode", "config.get_bootstrap_dataset_config"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.config.get_bootstrap_dataset_config"], ["\n", "logger", ".", "warning", "(", "\n", "\"Loading an old v{} config file '{}' by automatically upgrading to v{}. \"", "\n", "\"See docs/CHANGELOG.md for instructions to update your files.\"", ".", "format", "(", "\n", "loaded_ver", ",", "cfg_filename", ",", "self", ".", "VERSION", "\n", ")", "\n", ")", "\n", "# To convert, first obtain a full config at an old version", "\n", "old_self", "=", "downgrade_config", "(", "self", ",", "to_version", "=", "loaded_ver", ")", "\n", "old_self", ".", "merge_from_other_cfg", "(", "loaded_cfg", ")", "\n", "new_config", "=", "upgrade_config", "(", "old_self", ")", "\n", "self", ".", "clear", "(", ")", "\n", "self", ".", "update", "(", "new_config", ")", "\n", "\n", "", "", "def", "dump", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.config.add_densepose_head_config": [[70, 143], ["detectron2.config.CfgNode", "detectron2.config.CfgNode", "detectron2.config.CfgNode", "detectron2.config.CfgNode"], "function", ["None"], ["\n", "# to make it show up in docs", "\n", "return", "super", "(", ")", ".", "dump", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "\n", "", "", "global_cfg", "=", "CfgNode", "(", ")", "\n", "\n", "\n", "def", "get_cfg", "(", ")", "->", "CfgNode", ":", "\n", "    ", "\"\"\"\n    Get a copy of the default config.\n\n    Returns:\n        a detectron2 CfgNode instance.\n    \"\"\"", "\n", "from", ".", "defaults", "import", "_C", "\n", "\n", "return", "_C", ".", "clone", "(", ")", "\n", "\n", "\n", "", "def", "set_global_cfg", "(", "cfg", ":", "CfgNode", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Let the global config point to the given cfg.\n\n    Assume that the given \"cfg\" has the key \"KEY\", after calling\n    `set_global_cfg(cfg)`, the key can be accessed by:\n    ::\n        from detectron2.config import global_cfg\n        print(global_cfg.KEY)\n\n    By using a hacky global config, you can access these configs anywhere,\n    without having to pass the config object or the values deep into the code.\n    This is a hacky feature introduced for quick prototyping / research exploration.\n    \"\"\"", "\n", "global", "global_cfg", "\n", "global_cfg", ".", "clear", "(", ")", "\n", "global_cfg", ".", "update", "(", "cfg", ")", "\n", "\n", "\n", "", "def", "configurable", "(", "init_func", ")", ":", "\n", "    ", "\"\"\"\n    Decorate a class's __init__ method so that it can be called with a CfgNode\n    object using the class's from_config classmethod.\n\n    Examples:\n    ::\n        class A:\n            @configurable\n            def __init__(self, a, b=2, c=3):\n                pass\n\n            @classmethod\n            def from_config(cls, cfg):\n                # Returns kwargs to be passed to __init__\n                return {\"a\": cfg.A, \"b\": cfg.B}\n\n        a1 = A(a=1, b=2)  # regular construction\n        a2 = A(cfg)       # construct with a cfg\n        a3 = A(cfg, b=3, c=4)  # construct with extra overwrite\n    \"\"\"", "\n", "assert", "init_func", ".", "__name__", "==", "\"__init__\"", ",", "\"@configurable should only be used for __init__!\"", "\n", "if", "init_func", ".", "__module__", ".", "startswith", "(", "\"detectron2.\"", ")", ":", "\n", "        ", "assert", "(", "\n", "init_func", ".", "__doc__", "is", "not", "None", "and", "\"experimental\"", "in", "init_func", ".", "__doc__", "\n", ")", ",", "f\"configurable {init_func} should be marked experimental\"", "\n", "\n", "", "@", "functools", ".", "wraps", "(", "init_func", ")", "\n", "def", "wrapped", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "from_config_func", "=", "type", "(", "self", ")", ".", "from_config", "\n", "", "except", "AttributeError", "as", "e", ":", "\n", "            ", "raise", "AttributeError", "(", "\n", "\"Class with @configurable must have a 'from_config' classmethod.\"", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.config.add_hrnet_config": [[145, 178], ["detectron2.config.CfgNode", "detectron2.config.CfgNode", "detectron2.config.CfgNode", "detectron2.config.CfgNode", "detectron2.config.CfgNode"], "function", ["None"], ["", "if", "not", "inspect", ".", "ismethod", "(", "from_config_func", ")", ":", "\n", "            ", "raise", "TypeError", "(", "\"Class with @configurable must have a 'from_config' classmethod.\"", ")", "\n", "\n", "", "if", "_called_with_cfg", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "            ", "explicit_args", "=", "_get_args_from_config", "(", "from_config_func", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "init_func", "(", "self", ",", "**", "explicit_args", ")", "\n", "", "else", ":", "\n", "            ", "init_func", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "", "return", "wrapped", "\n", "\n", "\n", "", "def", "_get_args_from_config", "(", "from_config_func", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Use `from_config` to obtain explicit arguments.\n\n    Returns:\n        dict: arguments to be used for cls.__init__\n    \"\"\"", "\n", "signature", "=", "inspect", ".", "signature", "(", "from_config_func", ")", "\n", "if", "list", "(", "signature", ".", "parameters", ".", "keys", "(", ")", ")", "[", "0", "]", "!=", "\"cfg\"", ":", "\n", "        ", "raise", "TypeError", "(", "\n", "f\"{from_config_func.__self__}.from_config must take 'cfg' as the first argument!\"", "\n", ")", "\n", "", "support_var_arg", "=", "any", "(", "\n", "param", ".", "kind", "in", "[", "param", ".", "VAR_POSITIONAL", ",", "param", ".", "VAR_KEYWORD", "]", "\n", "for", "param", "in", "signature", ".", "parameters", ".", "values", "(", ")", "\n", ")", "\n", "if", "support_var_arg", ":", "# forward all arguments to from_config, if from_config accepts them", "\n", "        ", "ret", "=", "from_config_func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "# forward supported arguments to from_config", "\n", "        ", "supported_arg_names", "=", "set", "(", "signature", ".", "parameters", ".", "keys", "(", ")", ")", "\n", "extra_kwargs", "=", "{", "}", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.config.add_densepose_config": [[180, 185], ["config.add_densepose_head_config", "config.add_hrnet_config", "config.add_bootstrap_config", "config.add_dataset_category_config"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.config.add_densepose_head_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.config.add_hrnet_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.config.add_bootstrap_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.config.add_dataset_category_config"], ["            ", "if", "name", "not", "in", "supported_arg_names", ":", "\n", "                ", "extra_kwargs", "[", "name", "]", "=", "kwargs", ".", "pop", "(", "name", ")", "\n", "", "", "ret", "=", "from_config_func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "# forward the other arguments to __init__", "\n", "ret", ".", "update", "(", "extra_kwargs", ")", "\n", "", "return", "ret", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator.DensePoseCOCOEvaluator.__init__": [[29, 41], ["torch.device", "logging.getLogger", "detectron2.data.MetadataCatalog.get", "fvcore.common.file_io.PathManager.get_local_path", "contextlib.redirect_stdout", "pycocotools.coco.COCO", "io.StringIO"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["pass", "\n", "\n", "", "def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator.DensePoseCOCOEvaluator.reset": [[42, 44], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator.DensePoseCOCOEvaluator.process": [[45, 61], ["zip", "output[].to", "evaluator.prediction_to_json", "evaluator.DensePoseCOCOEvaluator._predictions.extend", "output[].to.has"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator.prediction_to_json", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has"], ["\n", "pass", "\n", "\n", "", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Evaluate/summarize the performance, after processing all input/output pairs.\n\n        Returns:\n            dict:\n                A new evaluator class can return a dict of arbitrary format\n                as long as the user can process the results.\n                In our train_net.py, we expect the following format:\n\n                * key: the name of the task (e.g., bbox)\n                * value: a dict of {metric name: score}, e.g.: {\"AP50\": 80}\n        \"\"\"", "\n", "pass", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator.DensePoseCOCOEvaluator.evaluate": [[62, 73], ["copy.deepcopy", "detectron2.utils.comm.synchronize", "detectron2.utils.comm.all_gather", "list", "evaluator.DensePoseCOCOEvaluator._eval_predictions", "itertools.chain", "detectron2.utils.comm.is_main_process"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.synchronize", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator.DensePoseCOCOEvaluator._eval_predictions", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process"], ["\n", "\n", "", "", "class", "DatasetEvaluators", "(", "DatasetEvaluator", ")", ":", "\n", "    ", "\"\"\"\n    Wrapper class to combine multiple :class:`DatasetEvaluator` instances.\n\n    This class dispatches every evaluation call to\n    all of its :class:`DatasetEvaluator`.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "evaluators", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator.DensePoseCOCOEvaluator._eval_predictions": [[74, 96], ["evaluator.DensePoseCOCOEvaluator._logger.info", "evaluator.DensePoseCOCOEvaluator._logger.info", "collections.OrderedDict", "evaluator._evaluate_predictions_on_coco", "fvcore.common.file_io.PathManager.mkdirs", "os.path.join", "fvcore.common.file_io.PathManager.open", "torch.save"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator._evaluate_predictions_on_coco", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save"], ["\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_evaluators", "=", "evaluators", "\n", "\n", "", "def", "reset", "(", "self", ")", ":", "\n", "        ", "for", "evaluator", "in", "self", ".", "_evaluators", ":", "\n", "            ", "evaluator", ".", "reset", "(", ")", "\n", "\n", "", "", "def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "for", "evaluator", "in", "self", ".", "_evaluators", ":", "\n", "            ", "evaluator", ".", "process", "(", "inputs", ",", "outputs", ")", "\n", "\n", "", "", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "results", "=", "OrderedDict", "(", ")", "\n", "for", "evaluator", "in", "self", ".", "_evaluators", ":", "\n", "            ", "result", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "if", "is_main_process", "(", ")", "and", "result", "is", "not", "None", ":", "\n", "                ", "for", "k", ",", "v", "in", "result", ".", "items", "(", ")", ":", "\n", "                    ", "assert", "(", "\n", "k", "not", "in", "results", "\n", ")", ",", "\"Different evaluators produce results with the same key {}\"", ".", "format", "(", "k", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator.prediction_to_json": [[98, 137], ["instances.scores.tolist", "converters.ToMaskConverter.convert", "detectron2.structures.BoxMode.convert", "range", "instances.pred_boxes.tensor.clone", "len", "structures.compress_quantized_densepose_chart_result", "pycocotools.encode", "segmentation_encoded[].decode", "results.append", "structures.quantize_densepose_chart_result", "numpy.require", "raw_boxes_xywh[].tolist", "converters.ToChartResultConverter.convert", "segmentation.numpy"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.chart_result.compress_quantized_densepose_chart_result", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.chart_result.quantize_densepose_chart_result", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "", "", "return", "results", "\n", "\n", "\n", "", "", "def", "inference_on_dataset", "(", "model", ",", "data_loader", ",", "evaluator", ")", ":", "\n", "    ", "\"\"\"\n    Run model on the data_loader and evaluate the metrics with evaluator.\n    Also benchmark the inference speed of `model.forward` accurately.\n    The model will be used in eval mode.\n\n    Args:\n        model (nn.Module): a module which accepts an object from\n            `data_loader` and returns some outputs. It will be temporarily set to `eval` mode.\n\n            If you wish to evaluate a model in `training` mode instead, you can\n            wrap the given model and override its behavior of `.eval()` and `.train()`.\n        data_loader: an iterable object with a length.\n            The elements it generates will be the inputs to the model.\n        evaluator (DatasetEvaluator): the evaluator to run. Use `None` if you only want\n            to benchmark, but don't want to do any evaluation.\n\n    Returns:\n        The return value of `evaluator.evaluate()`\n    \"\"\"", "\n", "num_devices", "=", "get_world_size", "(", ")", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Start inference on {} images\"", ".", "format", "(", "len", "(", "data_loader", ")", ")", ")", "\n", "\n", "total", "=", "len", "(", "data_loader", ")", "# inference data loader must have a fixed length", "\n", "if", "evaluator", "is", "None", ":", "\n", "# create a no-op evaluator", "\n", "        ", "evaluator", "=", "DatasetEvaluators", "(", "[", "]", ")", "\n", "", "evaluator", ".", "reset", "(", ")", "\n", "\n", "num_warmup", "=", "min", "(", "5", ",", "total", "-", "1", ")", "\n", "start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "total_compute_time", "=", "0", "\n", "with", "inference_context", "(", "model", ")", ",", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "idx", ",", "inputs", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "            ", "if", "idx", "==", "num_warmup", ":", "\n", "                ", "start_time", "=", "time", ".", "perf_counter", "(", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator._evaluate_predictions_on_coco": [[139, 167], ["logging.getLogger", "evaluator._get_segmentation_metrics", "evaluator._get_densepose_metrics", "coco_gt.loadRes", "evaluator._evaluate_predictions_on_coco_segm", "logging.getLogger.info", "evaluator._evaluate_predictions_on_coco_gps", "logging.getLogger.info", "evaluator._evaluate_predictions_on_coco_gpsm", "logging.getLogger.info", "len", "logging.getLogger.warn", "detectron2.utils.logger.create_small_table", "detectron2.utils.logger.create_small_table", "detectron2.utils.logger.create_small_table"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator._get_segmentation_metrics", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator._get_densepose_metrics", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator._evaluate_predictions_on_coco_segm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator._evaluate_predictions_on_coco_gps", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator._evaluate_predictions_on_coco_gpsm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.create_small_table", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.create_small_table", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.create_small_table"], ["\n", "", "start_compute_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "outputs", "=", "model", "(", "inputs", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "                ", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "", "total_compute_time", "+=", "time", ".", "perf_counter", "(", ")", "-", "start_compute_time", "\n", "evaluator", ".", "process", "(", "inputs", ",", "outputs", ")", "\n", "\n", "iters_after_start", "=", "idx", "+", "1", "-", "num_warmup", "*", "int", "(", "idx", ">=", "num_warmup", ")", "\n", "seconds_per_img", "=", "total_compute_time", "/", "iters_after_start", "\n", "if", "idx", ">=", "num_warmup", "*", "2", "or", "seconds_per_img", ">", "5", ":", "\n", "                ", "total_seconds_per_img", "=", "(", "time", ".", "perf_counter", "(", ")", "-", "start_time", ")", "/", "iters_after_start", "\n", "eta", "=", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "total_seconds_per_img", "*", "(", "total", "-", "idx", "-", "1", ")", ")", ")", "\n", "log_every_n_seconds", "(", "\n", "logging", ".", "INFO", ",", "\n", "\"Inference done {}/{}. {:.4f} s / img. ETA={}\"", ".", "format", "(", "\n", "idx", "+", "1", ",", "total", ",", "seconds_per_img", ",", "str", "(", "eta", ")", "\n", ")", ",", "\n", "n", "=", "5", ",", "\n", ")", "\n", "\n", "# Measure the time only for this worker (before the synchronization barrier)", "\n", "", "", "", "total_time", "=", "time", ".", "perf_counter", "(", ")", "-", "start_time", "\n", "total_time_str", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "total_time", ")", ")", "\n", "# NOTE this format is parsed by grep", "\n", "logger", ".", "info", "(", "\n", "\"Total inference time: {} ({:.6f} s / img per device, on {} devices)\"", ".", "format", "(", "\n", "total_time_str", ",", "total_time", "/", "(", "total", "-", "num_warmup", ")", ",", "num_devices", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator._get_densepose_metrics": [[169, 179], ["metrics.extend"], "function", ["None"], ["total_compute_time_str", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "total_compute_time", ")", ")", ")", "\n", "logger", ".", "info", "(", "\n", "\"Total inference pure compute time: {} ({:.6f} s / img per device, on {} devices)\"", ".", "format", "(", "\n", "total_compute_time_str", ",", "total_compute_time", "/", "(", "total", "-", "num_warmup", ")", ",", "num_devices", "\n", ")", "\n", ")", "\n", "\n", "results", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "# An evaluator may return None when not in main process.", "\n", "# Replace it by an empty dict instead to make it easier for downstream code to handle", "\n", "if", "results", "is", "None", ":", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator._get_segmentation_metrics": [[181, 195], ["None"], "function", ["None"], ["", "return", "results", "\n", "\n", "\n", "", "@", "contextmanager", "\n", "def", "inference_context", "(", "model", ")", ":", "\n", "    ", "\"\"\"\n    A context where the model is temporarily changed to eval mode,\n    and restored to previous mode afterwards.\n\n    Args:\n        model: a torch Module\n    \"\"\"", "\n", "training_mode", "=", "model", ".", "training", "\n", "model", ".", "eval", "(", ")", "\n", "yield", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator._evaluate_predictions_on_coco_gps": [[198, 208], ["densepose_coco_evaluation.DensePoseCocoEval", "numpy.linspace", "densepose_coco_evaluation.DensePoseCocoEval.evaluate", "densepose_coco_evaluation.DensePoseCocoEval.accumulate", "densepose_coco_evaluation.DensePoseCocoEval.summarize", "float", "int", "enumerate", "numpy.round"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.deepcluster_hook.DeepClusterHook.evaluate", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.accumulate", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.summarize"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator._evaluate_predictions_on_coco_gpsm": [[210, 220], ["densepose_coco_evaluation.DensePoseCocoEval", "numpy.linspace", "densepose_coco_evaluation.DensePoseCocoEval.evaluate", "densepose_coco_evaluation.DensePoseCocoEval.accumulate", "densepose_coco_evaluation.DensePoseCocoEval.summarize", "float", "int", "enumerate", "numpy.round"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.deepcluster_hook.DeepClusterHook.evaluate", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.accumulate", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.summarize"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.evaluator._evaluate_predictions_on_coco_segm": [[222, 232], ["densepose_coco_evaluation.DensePoseCocoEval", "numpy.linspace", "densepose_coco_evaluation.DensePoseCocoEval.evaluate", "densepose_coco_evaluation.DensePoseCocoEval.accumulate", "densepose_coco_evaluation.DensePoseCocoEval.summarize", "float", "int", "enumerate", "numpy.round"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.deepcluster_hook.DeepClusterHook.evaluate", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.accumulate", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.summarize"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.__init__": [[103, 135], ["collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "densepose_coco_evaluation.Params", "sorted", "sorted", "cocoGt.getImgIds", "cocoGt.getCatIds"], "methods", ["None"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "cocoGt", "=", "None", ",", "\n", "cocoDt", "=", "None", ",", "\n", "iouType", ":", "str", "=", "\"densepose\"", ",", "\n", "dpEvalMode", ":", "DensePoseEvalMode", "=", "DensePoseEvalMode", ".", "GPS", ",", "\n", "dpDataMode", ":", "DensePoseDataMode", "=", "DensePoseDataMode", ".", "IUV_DT", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize CocoEval using coco APIs for gt and dt\n        :param cocoGt: coco object with ground truth annotations\n        :param cocoDt: coco object with detection results\n        :return: None\n        \"\"\"", "\n", "self", ".", "cocoGt", "=", "cocoGt", "# ground truth COCO API", "\n", "self", ".", "cocoDt", "=", "cocoDt", "# detections COCO API", "\n", "self", ".", "_dpEvalMode", "=", "dpEvalMode", "\n", "self", ".", "_dpDataMode", "=", "dpDataMode", "\n", "self", ".", "params", "=", "{", "}", "# evaluation parameters", "\n", "self", ".", "evalImgs", "=", "defaultdict", "(", "list", ")", "# per-image per-category eval results [KxAxI]", "\n", "self", ".", "eval", "=", "{", "}", "# accumulated evaluation results", "\n", "self", ".", "_gts", "=", "defaultdict", "(", "list", ")", "# gt for evaluation", "\n", "self", ".", "_dts", "=", "defaultdict", "(", "list", ")", "# dt for evaluation", "\n", "self", ".", "params", "=", "Params", "(", "iouType", "=", "iouType", ")", "# parameters", "\n", "self", ".", "_paramsEval", "=", "{", "}", "# parameters for evaluation", "\n", "self", ".", "stats", "=", "[", "]", "# result summarization", "\n", "self", ".", "ious", "=", "{", "}", "# ious between all gts and dts", "\n", "if", "cocoGt", "is", "not", "None", ":", "\n", "            ", "self", ".", "params", ".", "imgIds", "=", "sorted", "(", "cocoGt", ".", "getImgIds", "(", ")", ")", "\n", "self", ".", "params", ".", "catIds", "=", "sorted", "(", "cocoGt", ".", "getCatIds", "(", ")", ")", "\n", "", "self", ".", "ignoreThrBB", "=", "0.7", "\n", "self", ".", "ignoreThrUV", "=", "0.9", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval._loadGEval": [[136, 168], ["fvcore.common.file_io.PathManager.get_local_path", "fvcore.common.file_io.PathManager.get_local_path", "fvcore.common.file_io.PathManager.get_local_path", "scipy.io.loadmat", "scipy.io.loadmat", "densepose_coco_evaluation.DensePoseCocoEval.PDIST_transform[].squeeze", "numpy.array().squeeze", "numpy.arange", "numpy.array", "numpy.array", "numpy.array", "numpy.arange", "densepose_coco_evaluation.DensePoseCocoEval.Part_UVs.append", "densepose_coco_evaluation.DensePoseCocoEval.Part_ClosestVertInds.append", "open", "pickle.load", "SMPL_subdiv[].squeeze", "numpy.array", "SMPL_subdiv[].squeeze", "SMPL_subdiv[].squeeze"], "methods", ["None"], ["", "def", "_loadGEval", "(", "self", ")", ":", "\n", "        ", "smpl_subdiv_fpath", "=", "PathManager", ".", "get_local_path", "(", "\n", "\"https://dl.fbaipublicfiles.com/densepose/data/SMPL_subdiv.mat\"", "\n", ")", "\n", "pdist_transform_fpath", "=", "PathManager", ".", "get_local_path", "(", "\n", "\"https://dl.fbaipublicfiles.com/densepose/data/SMPL_SUBDIV_TRANSFORM.mat\"", "\n", ")", "\n", "pdist_matrix_fpath", "=", "PathManager", ".", "get_local_path", "(", "\n", "\"https://dl.fbaipublicfiles.com/densepose/data/Pdist_matrix.pkl\"", ",", "timeout_sec", "=", "120", "\n", ")", "\n", "SMPL_subdiv", "=", "loadmat", "(", "smpl_subdiv_fpath", ")", "\n", "self", ".", "PDIST_transform", "=", "loadmat", "(", "pdist_transform_fpath", ")", "\n", "self", ".", "PDIST_transform", "=", "self", ".", "PDIST_transform", "[", "\"index\"", "]", ".", "squeeze", "(", ")", "\n", "UV", "=", "np", ".", "array", "(", "[", "SMPL_subdiv", "[", "\"U_subdiv\"", "]", ",", "SMPL_subdiv", "[", "\"V_subdiv\"", "]", "]", ")", ".", "squeeze", "(", ")", "\n", "ClosestVertInds", "=", "np", ".", "arange", "(", "UV", ".", "shape", "[", "1", "]", ")", "+", "1", "\n", "self", ".", "Part_UVs", "=", "[", "]", "\n", "self", ".", "Part_ClosestVertInds", "=", "[", "]", "\n", "for", "i", "in", "np", ".", "arange", "(", "24", ")", ":", "\n", "            ", "self", ".", "Part_UVs", ".", "append", "(", "UV", "[", ":", ",", "SMPL_subdiv", "[", "\"Part_ID_subdiv\"", "]", ".", "squeeze", "(", ")", "==", "(", "i", "+", "1", ")", "]", ")", "\n", "self", ".", "Part_ClosestVertInds", ".", "append", "(", "\n", "ClosestVertInds", "[", "SMPL_subdiv", "[", "\"Part_ID_subdiv\"", "]", ".", "squeeze", "(", ")", "==", "(", "i", "+", "1", ")", "]", "\n", ")", "\n", "\n", "", "with", "open", "(", "pdist_matrix_fpath", ",", "\"rb\"", ")", "as", "hFile", ":", "\n", "            ", "arrays", "=", "pickle", ".", "load", "(", "hFile", ",", "encoding", "=", "\"latin1\"", ")", "\n", "", "self", ".", "Pdist_matrix", "=", "arrays", "[", "\"Pdist_matrix\"", "]", "\n", "self", ".", "Part_ids", "=", "np", ".", "array", "(", "SMPL_subdiv", "[", "\"Part_ID_subdiv\"", "]", ".", "squeeze", "(", ")", ")", "\n", "# Mean geodesic distances for parts.", "\n", "self", ".", "Mean_Distances", "=", "np", ".", "array", "(", "[", "0", ",", "0.351", ",", "0.107", ",", "0.126", ",", "0.237", ",", "0.173", ",", "0.142", ",", "0.128", ",", "0.150", "]", ")", "\n", "# Coarse Part labels.", "\n", "self", ".", "CoarseParts", "=", "np", ".", "array", "(", "\n", "[", "0", ",", "1", ",", "1", ",", "2", ",", "2", ",", "3", ",", "3", ",", "4", ",", "4", ",", "4", ",", "4", ",", "5", ",", "5", ",", "5", ",", "5", ",", "6", ",", "6", ",", "6", ",", "6", ",", "7", ",", "7", ",", "7", ",", "7", ",", "8", ",", "8", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval._prepare": [[170, 287], ["densepose_coco_evaluation.DensePoseCocoEval.cocoGt.loadImgs", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "pycocotools.mask.frPyObjects", "pycocotools.mask.merge", "pycocotools.mask.decode", "numpy.array().astype", "min", "min", "numpy.require", "densepose_coco_evaluation.DensePoseCocoEval._extract_mask", "numpy.require", "pycocotools.mask.encode", "pycocotools.mask.encode", "densepose_coco_evaluation.DensePoseCocoEval.cocoGt.loadAnns", "densepose_coco_evaluation.DensePoseCocoEval.cocoDt.loadAnns", "densepose_coco_evaluation.DensePoseCocoEval.cocoGt.loadAnns", "densepose_coco_evaluation.DensePoseCocoEval.cocoDt.loadAnns", "densepose_coco_evaluation.DensePoseCocoEval._loadGEval", "densepose_coco_evaluation.DensePoseCocoEval._prepare._toMask"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval._extract_mask", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval._loadGEval"], ["", "def", "_prepare", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Prepare ._gts and ._dts for evaluation based on params\n        :return: None\n        \"\"\"", "\n", "\n", "def", "_toMask", "(", "anns", ",", "coco", ")", ":", "\n", "# modify ann['segmentation'] by reference", "\n", "            ", "for", "ann", "in", "anns", ":", "\n", "# safeguard for invalid segmentation annotation;", "\n", "# annotations containing empty lists exist in the posetrack", "\n", "# dataset. This is not a correct segmentation annotation", "\n", "# in terms of COCO format; we need to deal with it somehow", "\n", "                ", "segm", "=", "ann", "[", "\"segmentation\"", "]", "\n", "if", "type", "(", "segm", ")", "==", "list", "and", "len", "(", "segm", ")", "==", "0", ":", "\n", "                    ", "ann", "[", "\"segmentation\"", "]", "=", "None", "\n", "continue", "\n", "", "rle", "=", "coco", ".", "annToRLE", "(", "ann", ")", "\n", "ann", "[", "\"segmentation\"", "]", "=", "rle", "\n", "\n", "", "", "def", "_getIgnoreRegion", "(", "iid", ",", "coco", ")", ":", "\n", "            ", "img", "=", "coco", ".", "imgs", "[", "iid", "]", "\n", "\n", "if", "\"ignore_regions_x\"", "not", "in", "img", ".", "keys", "(", ")", ":", "\n", "                ", "return", "None", "\n", "\n", "", "if", "len", "(", "img", "[", "\"ignore_regions_x\"", "]", ")", "==", "0", ":", "\n", "                ", "return", "None", "\n", "\n", "", "rgns_merged", "=", "[", "\n", "[", "v", "for", "xy", "in", "zip", "(", "region_x", ",", "region_y", ")", "for", "v", "in", "xy", "]", "\n", "for", "region_x", ",", "region_y", "in", "zip", "(", "img", "[", "\"ignore_regions_x\"", "]", ",", "img", "[", "\"ignore_regions_y\"", "]", ")", "\n", "]", "\n", "rles", "=", "maskUtils", ".", "frPyObjects", "(", "rgns_merged", ",", "img", "[", "\"height\"", "]", ",", "img", "[", "\"width\"", "]", ")", "\n", "rle", "=", "maskUtils", ".", "merge", "(", "rles", ")", "\n", "return", "maskUtils", ".", "decode", "(", "rle", ")", "\n", "\n", "", "def", "_checkIgnore", "(", "dt", ",", "iregion", ")", ":", "\n", "            ", "if", "iregion", "is", "None", ":", "\n", "                ", "return", "True", "\n", "\n", "", "bb", "=", "np", ".", "array", "(", "dt", "[", "\"bbox\"", "]", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "bb", "[", "0", "]", ",", "bb", "[", "1", "]", ",", "bb", "[", "0", "]", "+", "bb", "[", "2", "]", ",", "bb", "[", "1", "]", "+", "bb", "[", "3", "]", "\n", "x2", "=", "min", "(", "[", "x2", ",", "iregion", ".", "shape", "[", "1", "]", "]", ")", "\n", "y2", "=", "min", "(", "[", "y2", ",", "iregion", ".", "shape", "[", "0", "]", "]", ")", "\n", "\n", "if", "bb", "[", "2", "]", "*", "bb", "[", "3", "]", "==", "0", ":", "\n", "                ", "return", "False", "\n", "\n", "", "crop_iregion", "=", "iregion", "[", "y1", ":", "y2", ",", "x1", ":", "x2", "]", "\n", "\n", "if", "crop_iregion", ".", "sum", "(", ")", "==", "0", ":", "\n", "                ", "return", "True", "\n", "\n", "", "if", "\"densepose\"", "not", "in", "dt", ".", "keys", "(", ")", ":", "# filtering boxes", "\n", "                ", "return", "crop_iregion", ".", "sum", "(", ")", "/", "bb", "[", "2", "]", "/", "bb", "[", "3", "]", "<", "self", ".", "ignoreThrBB", "\n", "\n", "# filtering UVs", "\n", "", "ignoremask", "=", "np", ".", "require", "(", "crop_iregion", ",", "requirements", "=", "[", "\"F\"", "]", ")", "\n", "mask", "=", "self", ".", "_extract_mask", "(", "dt", ")", "\n", "uvmask", "=", "np", ".", "require", "(", "np", ".", "asarray", "(", "mask", ">", "0", ")", ",", "dtype", "=", "np", ".", "uint8", ",", "requirements", "=", "[", "\"F\"", "]", ")", "\n", "uvmask_", "=", "maskUtils", ".", "encode", "(", "uvmask", ")", "\n", "ignoremask_", "=", "maskUtils", ".", "encode", "(", "ignoremask", ")", "\n", "uviou", "=", "maskUtils", ".", "iou", "(", "[", "uvmask_", "]", ",", "[", "ignoremask_", "]", ",", "[", "1", "]", ")", "[", "0", "]", "\n", "return", "uviou", "<", "self", ".", "ignoreThrUV", "\n", "\n", "", "p", "=", "self", ".", "params", "\n", "\n", "if", "p", ".", "useCats", ":", "\n", "            ", "gts", "=", "self", ".", "cocoGt", ".", "loadAnns", "(", "self", ".", "cocoGt", ".", "getAnnIds", "(", "imgIds", "=", "p", ".", "imgIds", ",", "catIds", "=", "p", ".", "catIds", ")", ")", "\n", "dts", "=", "self", ".", "cocoDt", ".", "loadAnns", "(", "self", ".", "cocoDt", ".", "getAnnIds", "(", "imgIds", "=", "p", ".", "imgIds", ",", "catIds", "=", "p", ".", "catIds", ")", ")", "\n", "", "else", ":", "\n", "            ", "gts", "=", "self", ".", "cocoGt", ".", "loadAnns", "(", "self", ".", "cocoGt", ".", "getAnnIds", "(", "imgIds", "=", "p", ".", "imgIds", ")", ")", "\n", "dts", "=", "self", ".", "cocoDt", ".", "loadAnns", "(", "self", ".", "cocoDt", ".", "getAnnIds", "(", "imgIds", "=", "p", ".", "imgIds", ")", ")", "\n", "\n", "", "imns", "=", "self", ".", "cocoGt", ".", "loadImgs", "(", "p", ".", "imgIds", ")", "\n", "self", ".", "size_mapping", "=", "{", "}", "\n", "for", "im", "in", "imns", ":", "\n", "            ", "self", ".", "size_mapping", "[", "im", "[", "\"id\"", "]", "]", "=", "[", "im", "[", "\"height\"", "]", ",", "im", "[", "\"width\"", "]", "]", "\n", "\n", "# if iouType == 'uv', add point gt annotations", "\n", "", "if", "p", ".", "iouType", "==", "\"densepose\"", ":", "\n", "            ", "self", ".", "_loadGEval", "(", ")", "\n", "\n", "# convert ground truth to mask if iouType == 'segm'", "\n", "", "if", "p", ".", "iouType", "==", "\"segm\"", ":", "\n", "            ", "_toMask", "(", "gts", ",", "self", ".", "cocoGt", ")", "\n", "_toMask", "(", "dts", ",", "self", ".", "cocoDt", ")", "\n", "\n", "# set ignore flag", "\n", "", "for", "gt", "in", "gts", ":", "\n", "            ", "gt", "[", "\"ignore\"", "]", "=", "gt", "[", "\"ignore\"", "]", "if", "\"ignore\"", "in", "gt", "else", "0", "\n", "gt", "[", "\"ignore\"", "]", "=", "\"iscrowd\"", "in", "gt", "and", "gt", "[", "\"iscrowd\"", "]", "\n", "if", "p", ".", "iouType", "==", "\"keypoints\"", ":", "\n", "                ", "gt", "[", "\"ignore\"", "]", "=", "(", "gt", "[", "\"num_keypoints\"", "]", "==", "0", ")", "or", "gt", "[", "\"ignore\"", "]", "\n", "", "if", "p", ".", "iouType", "==", "\"densepose\"", ":", "\n", "                ", "gt", "[", "\"ignore\"", "]", "=", "(", "\"dp_x\"", "in", "gt", ")", "==", "0", "\n", "", "if", "p", ".", "iouType", "==", "\"segm\"", ":", "\n", "                ", "gt", "[", "\"ignore\"", "]", "=", "gt", "[", "\"segmentation\"", "]", "is", "None", "\n", "\n", "", "", "self", ".", "_gts", "=", "defaultdict", "(", "list", ")", "# gt for evaluation", "\n", "self", ".", "_dts", "=", "defaultdict", "(", "list", ")", "# dt for evaluation", "\n", "self", ".", "_igrgns", "=", "defaultdict", "(", "list", ")", "\n", "\n", "for", "gt", "in", "gts", ":", "\n", "            ", "iid", "=", "gt", "[", "\"image_id\"", "]", "\n", "if", "iid", "not", "in", "self", ".", "_igrgns", ".", "keys", "(", ")", ":", "\n", "                ", "self", ".", "_igrgns", "[", "iid", "]", "=", "_getIgnoreRegion", "(", "iid", ",", "self", ".", "cocoGt", ")", "\n", "", "if", "_checkIgnore", "(", "gt", ",", "self", ".", "_igrgns", "[", "iid", "]", ")", ":", "\n", "                ", "self", ".", "_gts", "[", "iid", ",", "gt", "[", "\"category_id\"", "]", "]", ".", "append", "(", "gt", ")", "\n", "", "", "for", "dt", "in", "dts", ":", "\n", "            ", "iid", "=", "dt", "[", "\"image_id\"", "]", "\n", "if", "(", "iid", "not", "in", "self", ".", "_igrgns", ")", "or", "_checkIgnore", "(", "dt", ",", "self", ".", "_igrgns", "[", "iid", "]", ")", ":", "\n", "                ", "self", ".", "_dts", "[", "iid", ",", "dt", "[", "\"category_id\"", "]", "]", ".", "append", "(", "dt", ")", "\n", "\n", "", "", "self", ".", "evalImgs", "=", "defaultdict", "(", "list", ")", "# per-image per-category evaluation results", "\n", "self", ".", "eval", "=", "{", "}", "# accumulated evaluation results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.evaluate": [[288, 338], ["time.time", "logger.info", "list", "sorted", "densepose_coco_evaluation.DensePoseCocoEval._prepare", "copy.deepcopy", "time.time", "logger.info", "logger.info", "numpy.unique", "list", "densepose_coco_evaluation.DensePoseCocoEval.computeIoU"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval._prepare", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.computeIoU"], ["", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Run per image evaluation on given images and store results (a list of dict) in self.evalImgs\n        :return: None\n        \"\"\"", "\n", "tic", "=", "time", ".", "time", "(", ")", "\n", "logger", ".", "info", "(", "\"Running per image DensePose evaluation... {}\"", ".", "format", "(", "self", ".", "params", ".", "iouType", ")", ")", "\n", "p", "=", "self", ".", "params", "\n", "# add backward compatibility if useSegm is specified in params", "\n", "if", "p", ".", "useSegm", "is", "not", "None", ":", "\n", "            ", "p", ".", "iouType", "=", "\"segm\"", "if", "p", ".", "useSegm", "==", "1", "else", "\"bbox\"", "\n", "logger", ".", "info", "(", "\"useSegm (deprecated) is not None. Running DensePose evaluation\"", ")", "\n", "", "p", ".", "imgIds", "=", "list", "(", "np", ".", "unique", "(", "p", ".", "imgIds", ")", ")", "\n", "if", "p", ".", "useCats", ":", "\n", "            ", "p", ".", "catIds", "=", "list", "(", "np", ".", "unique", "(", "p", ".", "catIds", ")", ")", "\n", "", "p", ".", "maxDets", "=", "sorted", "(", "p", ".", "maxDets", ")", "\n", "self", ".", "params", "=", "p", "\n", "\n", "self", ".", "_prepare", "(", ")", "\n", "# loop through images, area range, max detection number", "\n", "catIds", "=", "p", ".", "catIds", "if", "p", ".", "useCats", "else", "[", "-", "1", "]", "\n", "\n", "if", "p", ".", "iouType", "in", "[", "\"segm\"", ",", "\"bbox\"", "]", ":", "\n", "            ", "computeIoU", "=", "self", ".", "computeIoU", "\n", "", "elif", "p", ".", "iouType", "==", "\"keypoints\"", ":", "\n", "            ", "computeIoU", "=", "self", ".", "computeOks", "\n", "", "elif", "p", ".", "iouType", "==", "\"densepose\"", ":", "\n", "            ", "computeIoU", "=", "self", ".", "computeOgps", "\n", "if", "self", ".", "_dpEvalMode", "==", "DensePoseEvalMode", ".", "GPSM", ":", "\n", "                ", "self", ".", "real_ious", "=", "{", "\n", "(", "imgId", ",", "catId", ")", ":", "self", ".", "computeDPIoU", "(", "imgId", ",", "catId", ")", "\n", "for", "imgId", "in", "p", ".", "imgIds", "\n", "for", "catId", "in", "catIds", "\n", "}", "\n", "\n", "", "", "self", ".", "ious", "=", "{", "\n", "(", "imgId", ",", "catId", ")", ":", "computeIoU", "(", "imgId", ",", "catId", ")", "for", "imgId", "in", "p", ".", "imgIds", "for", "catId", "in", "catIds", "\n", "}", "\n", "\n", "evaluateImg", "=", "self", ".", "evaluateImg", "\n", "maxDet", "=", "p", ".", "maxDets", "[", "-", "1", "]", "\n", "self", ".", "evalImgs", "=", "[", "\n", "evaluateImg", "(", "imgId", ",", "catId", ",", "areaRng", ",", "maxDet", ")", "\n", "for", "catId", "in", "catIds", "\n", "for", "areaRng", "in", "p", ".", "areaRng", "\n", "for", "imgId", "in", "p", ".", "imgIds", "\n", "]", "\n", "self", ".", "_paramsEval", "=", "copy", ".", "deepcopy", "(", "self", ".", "params", ")", "\n", "toc", "=", "time", ".", "time", "(", ")", "\n", "logger", ".", "info", "(", "\"DensePose evaluation DONE (t={:0.2f}s).\"", ".", "format", "(", "toc", "-", "tic", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.getDensePoseMask": [[339, 347], ["numpy.zeros", "min", "range", "len", "pycocotools.mask.decode"], "methods", ["None"], ["", "def", "getDensePoseMask", "(", "self", ",", "polys", ")", ":", "\n", "        ", "maskGen", "=", "np", ".", "zeros", "(", "[", "256", ",", "256", "]", ")", "\n", "stop", "=", "min", "(", "len", "(", "polys", ")", "+", "1", ",", "15", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "stop", ")", ":", "\n", "            ", "if", "polys", "[", "i", "-", "1", "]", ":", "\n", "                ", "currentMask", "=", "maskUtils", ".", "decode", "(", "polys", "[", "i", "-", "1", "]", ")", "\n", "maskGen", "[", "currentMask", ">", "0", "]", "=", "i", "\n", "", "", "return", "maskGen", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval._generate_rlemask_on_image": [[348, 364], ["numpy.array", "numpy.zeros", "numpy.require", "max", "min", "max", "min", "int", "int", "numpy.asarray", "pycocotools.mask.encode", "int", "int", "int", "int", "numpy.array", "int", "int"], "methods", ["None"], ["", "def", "_generate_rlemask_on_image", "(", "self", ",", "mask", ",", "imgId", ",", "data", ")", ":", "\n", "        ", "bbox_xywh", "=", "np", ".", "array", "(", "data", "[", "\"bbox\"", "]", ")", "\n", "x", ",", "y", ",", "w", ",", "h", "=", "bbox_xywh", "\n", "im_h", ",", "im_w", "=", "self", ".", "size_mapping", "[", "imgId", "]", "\n", "im_mask", "=", "np", ".", "zeros", "(", "(", "im_h", ",", "im_w", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "x0", "=", "max", "(", "int", "(", "x", ")", ",", "0", ")", "\n", "x1", "=", "min", "(", "int", "(", "x", "+", "w", ")", ",", "im_w", ",", "int", "(", "x", ")", "+", "mask", ".", "shape", "[", "1", "]", ")", "\n", "y0", "=", "max", "(", "int", "(", "y", ")", ",", "0", ")", "\n", "y1", "=", "min", "(", "int", "(", "y", "+", "h", ")", ",", "im_h", ",", "int", "(", "y", ")", "+", "mask", ".", "shape", "[", "0", "]", ")", "\n", "y", "=", "int", "(", "y", ")", "\n", "x", "=", "int", "(", "x", ")", "\n", "im_mask", "[", "y0", ":", "y1", ",", "x0", ":", "x1", "]", "=", "mask", "[", "y0", "-", "y", ":", "y1", "-", "y", ",", "x0", "-", "x", ":", "x1", "-", "x", "]", "\n", "", "im_mask", "=", "np", ".", "require", "(", "np", ".", "asarray", "(", "im_mask", ">", "0", ")", ",", "dtype", "=", "np", ".", "uint8", ",", "requirements", "=", "[", "\"F\"", "]", ")", "\n", "rle_mask", "=", "maskUtils", ".", "encode", "(", "np", ".", "array", "(", "im_mask", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", ",", "order", "=", "\"F\"", ")", ")", "[", "0", "]", "\n", "return", "rle_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.computeDPIoU": [[365, 423], ["numpy.argsort", "pycocotools.mask.iou", "len", "gtmasks.append", "densepose_coco_evaluation.DensePoseCocoEval._extract_mask", "numpy.require", "densepose_coco_evaluation.DensePoseCocoEval._generate_rlemask_on_image", "dtmasks.append", "int", "len", "len", "numpy.minimum", "scipy.ndimage.zoom", "numpy.array", "densepose_coco_evaluation.DensePoseCocoEval._generate_rlemask_on_image", "numpy.asarray", "densepose_coco_evaluation.DensePoseCocoEval.getDensePoseMask", "float", "float", "densepose_coco_evaluation.DensePoseCocoEval._generate_rlemask_on_image", "max", "max", "isinstance", "pycocotools.mask.frPyObjects", "pycocotools.mask.merge", "isinstance", "isinstance", "densepose_coco_evaluation.DensePoseCocoEval._generate_rlemask_on_image", "pycocotools.mask.frPyObjects"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval._extract_mask", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval._generate_rlemask_on_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval._generate_rlemask_on_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.getDensePoseMask", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval._generate_rlemask_on_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval._generate_rlemask_on_image"], ["", "def", "computeDPIoU", "(", "self", ",", "imgId", ",", "catId", ")", ":", "\n", "        ", "p", "=", "self", ".", "params", "\n", "if", "p", ".", "useCats", ":", "\n", "            ", "gt", "=", "self", ".", "_gts", "[", "imgId", ",", "catId", "]", "\n", "dt", "=", "self", ".", "_dts", "[", "imgId", ",", "catId", "]", "\n", "", "else", ":", "\n", "            ", "gt", "=", "[", "_", "for", "cId", "in", "p", ".", "catIds", "for", "_", "in", "self", ".", "_gts", "[", "imgId", ",", "cId", "]", "]", "\n", "dt", "=", "[", "_", "for", "cId", "in", "p", ".", "catIds", "for", "_", "in", "self", ".", "_dts", "[", "imgId", ",", "cId", "]", "]", "\n", "", "if", "len", "(", "gt", ")", "==", "0", "and", "len", "(", "dt", ")", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "", "inds", "=", "np", ".", "argsort", "(", "[", "-", "d", "[", "\"score\"", "]", "for", "d", "in", "dt", "]", ",", "kind", "=", "\"mergesort\"", ")", "\n", "dt", "=", "[", "dt", "[", "i", "]", "for", "i", "in", "inds", "]", "\n", "if", "len", "(", "dt", ")", ">", "p", ".", "maxDets", "[", "-", "1", "]", ":", "\n", "            ", "dt", "=", "dt", "[", "0", ":", "p", ".", "maxDets", "[", "-", "1", "]", "]", "\n", "\n", "", "gtmasks", "=", "[", "]", "\n", "for", "g", "in", "gt", ":", "\n", "            ", "if", "DensePoseDataRelative", ".", "S_KEY", "in", "g", ":", "\n", "# convert DensePose mask to a binary mask", "\n", "                ", "mask", "=", "np", ".", "minimum", "(", "self", ".", "getDensePoseMask", "(", "g", "[", "DensePoseDataRelative", ".", "S_KEY", "]", ")", ",", "1.0", ")", "\n", "_", ",", "_", ",", "w", ",", "h", "=", "g", "[", "\"bbox\"", "]", "\n", "scale_x", "=", "float", "(", "max", "(", "w", ",", "1", ")", ")", "/", "mask", ".", "shape", "[", "1", "]", "\n", "scale_y", "=", "float", "(", "max", "(", "h", ",", "1", ")", ")", "/", "mask", ".", "shape", "[", "0", "]", "\n", "mask", "=", "spzoom", "(", "mask", ",", "(", "scale_y", ",", "scale_x", ")", ",", "order", "=", "1", ",", "prefilter", "=", "False", ")", "\n", "mask", "=", "np", ".", "array", "(", "mask", ">", "0.5", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "rle_mask", "=", "self", ".", "_generate_rlemask_on_image", "(", "mask", ",", "imgId", ",", "g", ")", "\n", "", "elif", "\"segmentation\"", "in", "g", ":", "\n", "                ", "segmentation", "=", "g", "[", "\"segmentation\"", "]", "\n", "if", "isinstance", "(", "segmentation", ",", "list", ")", "and", "segmentation", ":", "\n", "# polygons", "\n", "                    ", "im_h", ",", "im_w", "=", "self", ".", "size_mapping", "[", "imgId", "]", "\n", "rles", "=", "maskUtils", ".", "frPyObjects", "(", "segmentation", ",", "im_h", ",", "im_w", ")", "\n", "rle_mask", "=", "maskUtils", ".", "merge", "(", "rles", ")", "\n", "", "elif", "isinstance", "(", "segmentation", ",", "dict", ")", ":", "\n", "                    ", "if", "isinstance", "(", "segmentation", "[", "\"counts\"", "]", ",", "list", ")", ":", "\n", "# uncompressed RLE", "\n", "                        ", "im_h", ",", "im_w", "=", "self", ".", "size_mapping", "[", "imgId", "]", "\n", "rle_mask", "=", "maskUtils", ".", "frPyObjects", "(", "segmentation", ",", "im_h", ",", "im_w", ")", "\n", "", "else", ":", "\n", "# compressed RLE", "\n", "                        ", "rle_mask", "=", "segmentation", "\n", "", "", "else", ":", "\n", "                    ", "rle_mask", "=", "self", ".", "_generate_rlemask_on_image", "(", "None", ",", "imgId", ",", "g", ")", "\n", "", "", "else", ":", "\n", "                ", "rle_mask", "=", "self", ".", "_generate_rlemask_on_image", "(", "None", ",", "imgId", ",", "g", ")", "\n", "", "gtmasks", ".", "append", "(", "rle_mask", ")", "\n", "\n", "", "dtmasks", "=", "[", "]", "\n", "for", "d", "in", "dt", ":", "\n", "            ", "mask", "=", "self", ".", "_extract_mask", "(", "d", ")", "\n", "mask", "=", "np", ".", "require", "(", "np", ".", "asarray", "(", "mask", ">", "0", ")", ",", "dtype", "=", "np", ".", "uint8", ",", "requirements", "=", "[", "\"F\"", "]", ")", "\n", "rle_mask", "=", "self", ".", "_generate_rlemask_on_image", "(", "mask", ",", "imgId", ",", "d", ")", "\n", "dtmasks", ".", "append", "(", "rle_mask", ")", "\n", "\n", "# compute iou between each dt and gt region", "\n", "", "iscrowd", "=", "[", "int", "(", "o", "[", "\"iscrowd\"", "]", ")", "for", "o", "in", "gt", "]", "\n", "iousDP", "=", "maskUtils", ".", "iou", "(", "dtmasks", ",", "gtmasks", ",", "iscrowd", ")", "\n", "return", "iousDP", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.computeIoU": [[424, 452], ["numpy.argsort", "pycocotools.mask.iou", "len", "int", "len", "len", "Exception"], "methods", ["None"], ["", "def", "computeIoU", "(", "self", ",", "imgId", ",", "catId", ")", ":", "\n", "        ", "p", "=", "self", ".", "params", "\n", "if", "p", ".", "useCats", ":", "\n", "            ", "gt", "=", "self", ".", "_gts", "[", "imgId", ",", "catId", "]", "\n", "dt", "=", "self", ".", "_dts", "[", "imgId", ",", "catId", "]", "\n", "", "else", ":", "\n", "            ", "gt", "=", "[", "_", "for", "cId", "in", "p", ".", "catIds", "for", "_", "in", "self", ".", "_gts", "[", "imgId", ",", "cId", "]", "]", "\n", "dt", "=", "[", "_", "for", "cId", "in", "p", ".", "catIds", "for", "_", "in", "self", ".", "_dts", "[", "imgId", ",", "cId", "]", "]", "\n", "", "if", "len", "(", "gt", ")", "==", "0", "and", "len", "(", "dt", ")", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "", "inds", "=", "np", ".", "argsort", "(", "[", "-", "d", "[", "\"score\"", "]", "for", "d", "in", "dt", "]", ",", "kind", "=", "\"mergesort\"", ")", "\n", "dt", "=", "[", "dt", "[", "i", "]", "for", "i", "in", "inds", "]", "\n", "if", "len", "(", "dt", ")", ">", "p", ".", "maxDets", "[", "-", "1", "]", ":", "\n", "            ", "dt", "=", "dt", "[", "0", ":", "p", ".", "maxDets", "[", "-", "1", "]", "]", "\n", "\n", "", "if", "p", ".", "iouType", "==", "\"segm\"", ":", "\n", "            ", "g", "=", "[", "g", "[", "\"segmentation\"", "]", "for", "g", "in", "gt", "if", "g", "[", "\"segmentation\"", "]", "is", "not", "None", "]", "\n", "d", "=", "[", "d", "[", "\"segmentation\"", "]", "for", "d", "in", "dt", "if", "d", "[", "\"segmentation\"", "]", "is", "not", "None", "]", "\n", "", "elif", "p", ".", "iouType", "==", "\"bbox\"", ":", "\n", "            ", "g", "=", "[", "g", "[", "\"bbox\"", "]", "for", "g", "in", "gt", "]", "\n", "d", "=", "[", "d", "[", "\"bbox\"", "]", "for", "d", "in", "dt", "]", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\"unknown iouType for iou computation\"", ")", "\n", "\n", "# compute iou between each dt and gt region", "\n", "", "iscrowd", "=", "[", "int", "(", "o", "[", "\"iscrowd\"", "]", ")", "for", "o", "in", "gt", "]", "\n", "ious", "=", "maskUtils", ".", "iou", "(", "d", ",", "g", ",", "iscrowd", ")", "\n", "return", "ious", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.computeOks": [[453, 523], ["numpy.argsort", "numpy.zeros", "len", "enumerate", "len", "numpy.array", "numpy.array", "numpy.count_nonzero", "enumerate", "len", "len", "len", "len", "numpy.array", "numpy.zeros", "numpy.sum", "numpy.max", "numpy.max", "numpy.max", "numpy.max", "numpy.exp", "numpy.spacing"], "methods", ["None"], ["", "def", "computeOks", "(", "self", ",", "imgId", ",", "catId", ")", ":", "\n", "        ", "p", "=", "self", ".", "params", "\n", "# dimension here should be Nxm", "\n", "gts", "=", "self", ".", "_gts", "[", "imgId", ",", "catId", "]", "\n", "dts", "=", "self", ".", "_dts", "[", "imgId", ",", "catId", "]", "\n", "inds", "=", "np", ".", "argsort", "(", "[", "-", "d", "[", "\"score\"", "]", "for", "d", "in", "dts", "]", ",", "kind", "=", "\"mergesort\"", ")", "\n", "dts", "=", "[", "dts", "[", "i", "]", "for", "i", "in", "inds", "]", "\n", "if", "len", "(", "dts", ")", ">", "p", ".", "maxDets", "[", "-", "1", "]", ":", "\n", "            ", "dts", "=", "dts", "[", "0", ":", "p", ".", "maxDets", "[", "-", "1", "]", "]", "\n", "# if len(gts) == 0 and len(dts) == 0:", "\n", "", "if", "len", "(", "gts", ")", "==", "0", "or", "len", "(", "dts", ")", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "", "ious", "=", "np", ".", "zeros", "(", "(", "len", "(", "dts", ")", ",", "len", "(", "gts", ")", ")", ")", "\n", "sigmas", "=", "(", "\n", "np", ".", "array", "(", "\n", "[", "\n", "0.26", ",", "\n", "0.25", ",", "\n", "0.25", ",", "\n", "0.35", ",", "\n", "0.35", ",", "\n", "0.79", ",", "\n", "0.79", ",", "\n", "0.72", ",", "\n", "0.72", ",", "\n", "0.62", ",", "\n", "0.62", ",", "\n", "1.07", ",", "\n", "1.07", ",", "\n", "0.87", ",", "\n", "0.87", ",", "\n", "0.89", ",", "\n", "0.89", ",", "\n", "]", "\n", ")", "\n", "/", "10.0", "\n", ")", "\n", "vars", "=", "(", "sigmas", "*", "2", ")", "**", "2", "\n", "k", "=", "len", "(", "sigmas", ")", "\n", "# compute oks between each detection and ground truth object", "\n", "for", "j", ",", "gt", "in", "enumerate", "(", "gts", ")", ":", "\n", "# create bounds for ignore regions(double the gt bbox)", "\n", "            ", "g", "=", "np", ".", "array", "(", "gt", "[", "\"keypoints\"", "]", ")", "\n", "xg", "=", "g", "[", "0", ":", ":", "3", "]", "\n", "yg", "=", "g", "[", "1", ":", ":", "3", "]", "\n", "vg", "=", "g", "[", "2", ":", ":", "3", "]", "\n", "k1", "=", "np", ".", "count_nonzero", "(", "vg", ">", "0", ")", "\n", "bb", "=", "gt", "[", "\"bbox\"", "]", "\n", "x0", "=", "bb", "[", "0", "]", "-", "bb", "[", "2", "]", "\n", "x1", "=", "bb", "[", "0", "]", "+", "bb", "[", "2", "]", "*", "2", "\n", "y0", "=", "bb", "[", "1", "]", "-", "bb", "[", "3", "]", "\n", "y1", "=", "bb", "[", "1", "]", "+", "bb", "[", "3", "]", "*", "2", "\n", "for", "i", ",", "dt", "in", "enumerate", "(", "dts", ")", ":", "\n", "                ", "d", "=", "np", ".", "array", "(", "dt", "[", "\"keypoints\"", "]", ")", "\n", "xd", "=", "d", "[", "0", ":", ":", "3", "]", "\n", "yd", "=", "d", "[", "1", ":", ":", "3", "]", "\n", "if", "k1", ">", "0", ":", "\n", "# measure the per-keypoint distance if keypoints visible", "\n", "                    ", "dx", "=", "xd", "-", "xg", "\n", "dy", "=", "yd", "-", "yg", "\n", "", "else", ":", "\n", "# measure minimum distance to keypoints in (x0,y0) & (x1,y1)", "\n", "                    ", "z", "=", "np", ".", "zeros", "(", "k", ")", "\n", "dx", "=", "np", ".", "max", "(", "(", "z", ",", "x0", "-", "xd", ")", ",", "axis", "=", "0", ")", "+", "np", ".", "max", "(", "(", "z", ",", "xd", "-", "x1", ")", ",", "axis", "=", "0", ")", "\n", "dy", "=", "np", ".", "max", "(", "(", "z", ",", "y0", "-", "yd", ")", ",", "axis", "=", "0", ")", "+", "np", ".", "max", "(", "(", "z", ",", "yd", "-", "y1", ")", ",", "axis", "=", "0", ")", "\n", "", "e", "=", "(", "dx", "**", "2", "+", "dy", "**", "2", ")", "/", "vars", "/", "(", "gt", "[", "\"area\"", "]", "+", "np", ".", "spacing", "(", "1", ")", ")", "/", "2", "\n", "if", "k1", ">", "0", ":", "\n", "                    ", "e", "=", "e", "[", "vg", ">", "0", "]", "\n", "", "ious", "[", "i", ",", "j", "]", "=", "np", ".", "sum", "(", "np", ".", "exp", "(", "-", "e", ")", ")", "/", "e", ".", "shape", "[", "0", "]", "\n", "", "", "return", "ious", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval._extract_mask": [[524, 530], ["structures.decompress_compressed_densepose_chart_result", "structures.decompress_compressed_densepose_chart_result.labels_uv_uint8[].numpy"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.chart_result.decompress_compressed_densepose_chart_result"], ["", "def", "_extract_mask", "(", "self", ",", "dt", ":", "Dict", "[", "str", ",", "Any", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "densepose_results_quantized_compressed", "=", "dt", "[", "\"densepose\"", "]", "\n", "densepose_results_quantized", "=", "decompress_compressed_densepose_chart_result", "(", "\n", "densepose_results_quantized_compressed", "\n", ")", "\n", "return", "densepose_results_quantized", ".", "labels_uv_uint8", "[", "0", "]", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval._extract_iuv": [[531, 566], ["numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "ValueError"], "methods", ["None"], ["", "def", "_extract_iuv", "(", "\n", "self", ",", "densepose_data", ":", "np", ".", "ndarray", ",", "py", ":", "np", ".", "ndarray", ",", "px", ":", "np", ".", "ndarray", ",", "gt", ":", "Dict", "[", "str", ",", "Any", "]", "\n", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Extract arrays of I, U and V values at given points as numpy arrays\n        given the data mode stored in self._dpDataMode\n        \"\"\"", "\n", "if", "self", ".", "_dpDataMode", "==", "DensePoseDataMode", ".", "IUV_DT", ":", "\n", "# estimated labels and UV (default)", "\n", "            ", "ipoints", "=", "densepose_data", "[", "0", ",", "py", ",", "px", "]", "\n", "upoints", "=", "densepose_data", "[", "1", ",", "py", ",", "px", "]", "/", "255.0", "# convert from uint8 by /255.", "\n", "vpoints", "=", "densepose_data", "[", "2", ",", "py", ",", "px", "]", "/", "255.0", "\n", "", "elif", "self", ".", "_dpDataMode", "==", "DensePoseDataMode", ".", "IUV_GT", ":", "\n", "# ground truth", "\n", "            ", "ipoints", "=", "np", ".", "array", "(", "gt", "[", "\"dp_I\"", "]", ")", "\n", "upoints", "=", "np", ".", "array", "(", "gt", "[", "\"dp_U\"", "]", ")", "\n", "vpoints", "=", "np", ".", "array", "(", "gt", "[", "\"dp_V\"", "]", ")", "\n", "", "elif", "self", ".", "_dpDataMode", "==", "DensePoseDataMode", ".", "I_GT_UV_0", ":", "\n", "# ground truth labels, UV = 0", "\n", "            ", "ipoints", "=", "np", ".", "array", "(", "gt", "[", "\"dp_I\"", "]", ")", "\n", "upoints", "=", "upoints", "*", "0.0", "\n", "vpoints", "=", "vpoints", "*", "0.0", "\n", "", "elif", "self", ".", "_dpDataMode", "==", "DensePoseDataMode", ".", "I_GT_UV_DT", ":", "\n", "# ground truth labels, estimated UV", "\n", "            ", "ipoints", "=", "np", ".", "array", "(", "gt", "[", "\"dp_I\"", "]", ")", "\n", "upoints", "=", "densepose_data", "[", "1", ",", "py", ",", "px", "]", "/", "255.0", "# convert from uint8 by /255.", "\n", "vpoints", "=", "densepose_data", "[", "2", ",", "py", ",", "px", "]", "/", "255.0", "\n", "", "elif", "self", ".", "_dpDataMode", "==", "DensePoseDataMode", ".", "I_DT_UV_0", ":", "\n", "# estimated labels, UV = 0", "\n", "            ", "ipoints", "=", "densepose_data", "[", "0", ",", "py", ",", "px", "]", "\n", "upoints", "=", "upoints", "*", "0.0", "\n", "vpoints", "=", "vpoints", "*", "0.0", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Unknown data mode: {self._dpDataMode}\"", ")", "\n", "", "return", "ipoints", ",", "upoints", ",", "vpoints", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.computeOgps": [[567, 640], ["numpy.argsort", "numpy.zeros", "enumerate", "pycocotools.mask.iou", "len", "int", "len", "len", "len", "len", "enumerate", "int", "int", "numpy.zeros", "len", "len", "numpy.array", "numpy.array", "numpy.max", "structures.decompress_compressed_densepose_chart_result", "densepose_coco_evaluation.DensePoseCocoEval._extract_iuv", "densepose_coco_evaluation.DensePoseCocoEval.findAllClosestVerts", "densepose_coco_evaluation.DensePoseCocoEval.getDistances", "numpy.exp", "structures.decompress_compressed_densepose_chart_result.labels_uv_uint8.numpy", "len", "numpy.sum", "len", "cVertsGT[].astype"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.chart_result.decompress_compressed_densepose_chart_result", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval._extract_iuv", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.findAllClosestVerts", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.getDistances"], ["", "def", "computeOgps", "(", "self", ",", "imgId", ",", "catId", ")", ":", "\n", "        ", "p", "=", "self", ".", "params", "\n", "# dimension here should be Nxm", "\n", "g", "=", "self", ".", "_gts", "[", "imgId", ",", "catId", "]", "\n", "d", "=", "self", ".", "_dts", "[", "imgId", ",", "catId", "]", "\n", "inds", "=", "np", ".", "argsort", "(", "[", "-", "d_", "[", "\"score\"", "]", "for", "d_", "in", "d", "]", ",", "kind", "=", "\"mergesort\"", ")", "\n", "d", "=", "[", "d", "[", "i", "]", "for", "i", "in", "inds", "]", "\n", "if", "len", "(", "d", ")", ">", "p", ".", "maxDets", "[", "-", "1", "]", ":", "\n", "            ", "d", "=", "d", "[", "0", ":", "p", ".", "maxDets", "[", "-", "1", "]", "]", "\n", "# if len(gts) == 0 and len(dts) == 0:", "\n", "", "if", "len", "(", "g", ")", "==", "0", "or", "len", "(", "d", ")", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "", "ious", "=", "np", ".", "zeros", "(", "(", "len", "(", "d", ")", ",", "len", "(", "g", ")", ")", ")", "\n", "# compute opgs between each detection and ground truth object", "\n", "# sigma = self.sigma #0.255 # dist = 0.3m corresponds to ogps = 0.5", "\n", "# 1 # dist = 0.3m corresponds to ogps = 0.96", "\n", "# 1.45 # dist = 1.7m (person height) corresponds to ogps = 0.5)", "\n", "for", "j", ",", "gt", "in", "enumerate", "(", "g", ")", ":", "\n", "            ", "if", "not", "gt", "[", "\"ignore\"", "]", ":", "\n", "                ", "g_", "=", "gt", "[", "\"bbox\"", "]", "\n", "for", "i", ",", "dt", "in", "enumerate", "(", "d", ")", ":", "\n", "#", "\n", "                    ", "dy", "=", "int", "(", "dt", "[", "\"bbox\"", "]", "[", "3", "]", ")", "\n", "dx", "=", "int", "(", "dt", "[", "\"bbox\"", "]", "[", "2", "]", ")", "\n", "dp_x", "=", "np", ".", "array", "(", "gt", "[", "\"dp_x\"", "]", ")", "*", "g_", "[", "2", "]", "/", "255.0", "\n", "dp_y", "=", "np", ".", "array", "(", "gt", "[", "\"dp_y\"", "]", ")", "*", "g_", "[", "3", "]", "/", "255.0", "\n", "py", "=", "(", "dp_y", "+", "g_", "[", "1", "]", "-", "dt", "[", "\"bbox\"", "]", "[", "1", "]", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "px", "=", "(", "dp_x", "+", "g_", "[", "0", "]", "-", "dt", "[", "\"bbox\"", "]", "[", "0", "]", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "#", "\n", "pts", "=", "np", ".", "zeros", "(", "len", "(", "px", ")", ")", "\n", "pts", "[", "px", ">=", "dx", "]", "=", "-", "1", "\n", "pts", "[", "py", ">=", "dy", "]", "=", "-", "1", "\n", "pts", "[", "px", "<", "0", "]", "=", "-", "1", "\n", "pts", "[", "py", "<", "0", "]", "=", "-", "1", "\n", "if", "len", "(", "pts", ")", "<", "1", ":", "\n", "                        ", "ogps", "=", "0.0", "\n", "", "elif", "np", ".", "max", "(", "pts", ")", "==", "-", "1", ":", "\n", "                        ", "ogps", "=", "0.0", "\n", "", "else", ":", "\n", "                        ", "px", "[", "pts", "==", "-", "1", "]", "=", "0", "\n", "py", "[", "pts", "==", "-", "1", "]", "=", "0", "\n", "densepose_results_quantized_compressed", "=", "dt", "[", "\"densepose\"", "]", "\n", "densepose_results_quantized", "=", "decompress_compressed_densepose_chart_result", "(", "\n", "densepose_results_quantized_compressed", "\n", ")", "\n", "ipoints", ",", "upoints", ",", "vpoints", "=", "self", ".", "_extract_iuv", "(", "\n", "densepose_results_quantized", ".", "labels_uv_uint8", ".", "numpy", "(", ")", ",", "py", ",", "px", ",", "gt", "\n", ")", "\n", "ipoints", "[", "pts", "==", "-", "1", "]", "=", "0", "\n", "# Find closest vertices in subsampled mesh.", "\n", "cVerts", ",", "cVertsGT", "=", "self", ".", "findAllClosestVerts", "(", "gt", ",", "upoints", ",", "vpoints", ",", "ipoints", ")", "\n", "# Get pairwise geodesic distances between gt and estimated mesh points.", "\n", "dist", "=", "self", ".", "getDistances", "(", "cVertsGT", ",", "cVerts", ")", "\n", "# Compute the Ogps measure.", "\n", "# Find the mean geodesic normalization distance for", "\n", "# each GT point, based on which part it is on.", "\n", "Current_Mean_Distances", "=", "self", ".", "Mean_Distances", "[", "\n", "self", ".", "CoarseParts", "[", "self", ".", "Part_ids", "[", "cVertsGT", "[", "cVertsGT", ">", "0", "]", ".", "astype", "(", "int", ")", "-", "1", "]", "]", "\n", "]", "\n", "# Compute gps", "\n", "ogps_values", "=", "np", ".", "exp", "(", "-", "(", "dist", "**", "2", ")", "/", "(", "2", "*", "(", "Current_Mean_Distances", "**", "2", ")", ")", ")", "\n", "#", "\n", "if", "len", "(", "dist", ")", ">", "0", ":", "\n", "                            ", "ogps", "=", "np", ".", "sum", "(", "ogps_values", ")", "/", "len", "(", "dist", ")", "\n", "", "", "ious", "[", "i", ",", "j", "]", "=", "ogps", "\n", "\n", "", "", "", "gbb", "=", "[", "gt", "[", "\"bbox\"", "]", "for", "gt", "in", "g", "]", "\n", "dbb", "=", "[", "dt", "[", "\"bbox\"", "]", "for", "dt", "in", "d", "]", "\n", "\n", "# compute iou between each dt and gt region", "\n", "iscrowd", "=", "[", "int", "(", "o", "[", "\"iscrowd\"", "]", ")", "for", "o", "in", "g", "]", "\n", "ious_bb", "=", "maskUtils", ".", "iou", "(", "dbb", ",", "gbb", ",", "iscrowd", ")", "\n", "return", "ious", ",", "ious_bb", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.evaluateImg": [[641, 784], ["numpy.argsort", "numpy.argsort", "len", "len", "len", "numpy.zeros", "numpy.zeros", "numpy.array", "numpy.zeros", "numpy.array().reshape", "numpy.logical_or", "int", "numpy.all", "numpy.logical_or", "len", "enumerate", "numpy.logical_and", "len", "len", "enumerate", "enumerate", "numpy.array", "len", "numpy.repeat", "len", "len", "len", "min", "enumerate", "len", "len", "enumerate", "numpy.sqrt"], "methods", ["None"], ["", "def", "evaluateImg", "(", "self", ",", "imgId", ",", "catId", ",", "aRng", ",", "maxDet", ")", ":", "\n", "        ", "\"\"\"\n        perform evaluation for single category and image\n        :return: dict (single image results)\n        \"\"\"", "\n", "\n", "p", "=", "self", ".", "params", "\n", "if", "p", ".", "useCats", ":", "\n", "            ", "gt", "=", "self", ".", "_gts", "[", "imgId", ",", "catId", "]", "\n", "dt", "=", "self", ".", "_dts", "[", "imgId", ",", "catId", "]", "\n", "", "else", ":", "\n", "            ", "gt", "=", "[", "_", "for", "cId", "in", "p", ".", "catIds", "for", "_", "in", "self", ".", "_gts", "[", "imgId", ",", "cId", "]", "]", "\n", "dt", "=", "[", "_", "for", "cId", "in", "p", ".", "catIds", "for", "_", "in", "self", ".", "_dts", "[", "imgId", ",", "cId", "]", "]", "\n", "", "if", "len", "(", "gt", ")", "==", "0", "and", "len", "(", "dt", ")", "==", "0", ":", "\n", "            ", "return", "None", "\n", "\n", "", "for", "g", "in", "gt", ":", "\n", "# g['_ignore'] = g['ignore']", "\n", "            ", "if", "g", "[", "\"ignore\"", "]", "or", "(", "g", "[", "\"area\"", "]", "<", "aRng", "[", "0", "]", "or", "g", "[", "\"area\"", "]", ">", "aRng", "[", "1", "]", ")", ":", "\n", "                ", "g", "[", "\"_ignore\"", "]", "=", "True", "\n", "", "else", ":", "\n", "                ", "g", "[", "\"_ignore\"", "]", "=", "False", "\n", "\n", "# sort dt highest score first, sort gt ignore last", "\n", "", "", "gtind", "=", "np", ".", "argsort", "(", "[", "g", "[", "\"_ignore\"", "]", "for", "g", "in", "gt", "]", ",", "kind", "=", "\"mergesort\"", ")", "\n", "gt", "=", "[", "gt", "[", "i", "]", "for", "i", "in", "gtind", "]", "\n", "dtind", "=", "np", ".", "argsort", "(", "[", "-", "d", "[", "\"score\"", "]", "for", "d", "in", "dt", "]", ",", "kind", "=", "\"mergesort\"", ")", "\n", "dt", "=", "[", "dt", "[", "i", "]", "for", "i", "in", "dtind", "[", "0", ":", "maxDet", "]", "]", "\n", "iscrowd", "=", "[", "int", "(", "o", "[", "\"iscrowd\"", "]", ")", "for", "o", "in", "gt", "]", "\n", "# load computed ious", "\n", "if", "p", ".", "iouType", "==", "\"densepose\"", ":", "\n", "# print('Checking the length', len(self.ious[imgId, catId]))", "\n", "# if len(self.ious[imgId, catId]) == 0:", "\n", "#    print(self.ious[imgId, catId])", "\n", "            ", "ious", "=", "(", "\n", "self", ".", "ious", "[", "imgId", ",", "catId", "]", "[", "0", "]", "[", ":", ",", "gtind", "]", "\n", "if", "len", "(", "self", ".", "ious", "[", "imgId", ",", "catId", "]", ")", ">", "0", "\n", "else", "self", ".", "ious", "[", "imgId", ",", "catId", "]", "\n", ")", "\n", "ioubs", "=", "(", "\n", "self", ".", "ious", "[", "imgId", ",", "catId", "]", "[", "1", "]", "[", ":", ",", "gtind", "]", "\n", "if", "len", "(", "self", ".", "ious", "[", "imgId", ",", "catId", "]", ")", ">", "0", "\n", "else", "self", ".", "ious", "[", "imgId", ",", "catId", "]", "\n", ")", "\n", "if", "self", ".", "_dpEvalMode", "==", "DensePoseEvalMode", ".", "GPSM", ":", "\n", "                ", "iousM", "=", "(", "\n", "self", ".", "real_ious", "[", "imgId", ",", "catId", "]", "[", ":", ",", "gtind", "]", "\n", "if", "len", "(", "self", ".", "real_ious", "[", "imgId", ",", "catId", "]", ")", ">", "0", "\n", "else", "self", ".", "real_ious", "[", "imgId", ",", "catId", "]", "\n", ")", "\n", "", "", "else", ":", "\n", "            ", "ious", "=", "(", "\n", "self", ".", "ious", "[", "imgId", ",", "catId", "]", "[", ":", ",", "gtind", "]", "\n", "if", "len", "(", "self", ".", "ious", "[", "imgId", ",", "catId", "]", ")", ">", "0", "\n", "else", "self", ".", "ious", "[", "imgId", ",", "catId", "]", "\n", ")", "\n", "\n", "", "T", "=", "len", "(", "p", ".", "iouThrs", ")", "\n", "G", "=", "len", "(", "gt", ")", "\n", "D", "=", "len", "(", "dt", ")", "\n", "gtm", "=", "np", ".", "zeros", "(", "(", "T", ",", "G", ")", ")", "\n", "dtm", "=", "np", ".", "zeros", "(", "(", "T", ",", "D", ")", ")", "\n", "gtIg", "=", "np", ".", "array", "(", "[", "g", "[", "\"_ignore\"", "]", "for", "g", "in", "gt", "]", ")", "\n", "dtIg", "=", "np", ".", "zeros", "(", "(", "T", ",", "D", ")", ")", "\n", "if", "np", ".", "all", "(", "gtIg", ")", "and", "p", ".", "iouType", "==", "\"densepose\"", ":", "\n", "            ", "dtIg", "=", "np", ".", "logical_or", "(", "dtIg", ",", "True", ")", "\n", "\n", "", "if", "len", "(", "ious", ")", ">", "0", ":", "# and not p.iouType == 'densepose':", "\n", "            ", "for", "tind", ",", "t", "in", "enumerate", "(", "p", ".", "iouThrs", ")", ":", "\n", "                ", "for", "dind", ",", "d", "in", "enumerate", "(", "dt", ")", ":", "\n", "# information about best match so far (m=-1 -> unmatched)", "\n", "                    ", "iou", "=", "min", "(", "[", "t", ",", "1", "-", "1e-10", "]", ")", "\n", "m", "=", "-", "1", "\n", "for", "gind", ",", "_g", "in", "enumerate", "(", "gt", ")", ":", "\n", "# if this gt already matched, and not a crowd, continue", "\n", "                        ", "if", "gtm", "[", "tind", ",", "gind", "]", ">", "0", "and", "not", "iscrowd", "[", "gind", "]", ":", "\n", "                            ", "continue", "\n", "# if dt matched to reg gt, and on ignore gt, stop", "\n", "", "if", "m", ">", "-", "1", "and", "gtIg", "[", "m", "]", "==", "0", "and", "gtIg", "[", "gind", "]", "==", "1", ":", "\n", "                            ", "break", "\n", "", "if", "p", ".", "iouType", "==", "\"densepose\"", ":", "\n", "                            ", "if", "self", ".", "_dpEvalMode", "==", "DensePoseEvalMode", ".", "GPSM", ":", "\n", "                                ", "new_iou", "=", "np", ".", "sqrt", "(", "iousM", "[", "dind", ",", "gind", "]", "*", "ious", "[", "dind", ",", "gind", "]", ")", "\n", "", "elif", "self", ".", "_dpEvalMode", "==", "DensePoseEvalMode", ".", "IOU", ":", "\n", "                                ", "new_iou", "=", "iousM", "[", "dind", ",", "gind", "]", "\n", "", "elif", "self", ".", "_dpEvalMode", "==", "DensePoseEvalMode", ".", "GPS", ":", "\n", "                                ", "new_iou", "=", "ious", "[", "dind", ",", "gind", "]", "\n", "", "", "else", ":", "\n", "                            ", "new_iou", "=", "ious", "[", "dind", ",", "gind", "]", "\n", "", "if", "new_iou", "<", "iou", ":", "\n", "                            ", "continue", "\n", "", "if", "new_iou", "==", "0.0", ":", "\n", "                            ", "continue", "\n", "# if match successful and best so far, store appropriately", "\n", "", "iou", "=", "new_iou", "\n", "m", "=", "gind", "\n", "# if match made store id of match for both dt and gt", "\n", "", "if", "m", "==", "-", "1", ":", "\n", "                        ", "continue", "\n", "", "dtIg", "[", "tind", ",", "dind", "]", "=", "gtIg", "[", "m", "]", "\n", "dtm", "[", "tind", ",", "dind", "]", "=", "gt", "[", "m", "]", "[", "\"id\"", "]", "\n", "gtm", "[", "tind", ",", "m", "]", "=", "d", "[", "\"id\"", "]", "\n", "\n", "", "", "", "if", "p", ".", "iouType", "==", "\"densepose\"", ":", "\n", "            ", "if", "not", "len", "(", "ioubs", ")", "==", "0", ":", "\n", "                ", "for", "dind", ",", "d", "in", "enumerate", "(", "dt", ")", ":", "\n", "# information about best match so far (m=-1 -> unmatched)", "\n", "                    ", "if", "dtm", "[", "tind", ",", "dind", "]", "==", "0", ":", "\n", "                        ", "ioub", "=", "0.8", "\n", "m", "=", "-", "1", "\n", "for", "gind", ",", "_g", "in", "enumerate", "(", "gt", ")", ":", "\n", "# if this gt already matched, and not a crowd, continue", "\n", "                            ", "if", "gtm", "[", "tind", ",", "gind", "]", ">", "0", "and", "not", "iscrowd", "[", "gind", "]", ":", "\n", "                                ", "continue", "\n", "# continue to next gt unless better match made", "\n", "", "if", "ioubs", "[", "dind", ",", "gind", "]", "<", "ioub", ":", "\n", "                                ", "continue", "\n", "# if match successful and best so far, store appropriately", "\n", "", "ioub", "=", "ioubs", "[", "dind", ",", "gind", "]", "\n", "m", "=", "gind", "\n", "# if match made store id of match for both dt and gt", "\n", "", "if", "m", ">", "-", "1", ":", "\n", "                            ", "dtIg", "[", ":", ",", "dind", "]", "=", "gtIg", "[", "m", "]", "\n", "if", "gtIg", "[", "m", "]", ":", "\n", "                                ", "dtm", "[", "tind", ",", "dind", "]", "=", "gt", "[", "m", "]", "[", "\"id\"", "]", "\n", "gtm", "[", "tind", ",", "m", "]", "=", "d", "[", "\"id\"", "]", "\n", "# set unmatched detections outside of area range to ignore", "\n", "", "", "", "", "", "", "a", "=", "np", ".", "array", "(", "[", "d", "[", "\"area\"", "]", "<", "aRng", "[", "0", "]", "or", "d", "[", "\"area\"", "]", ">", "aRng", "[", "1", "]", "for", "d", "in", "dt", "]", ")", ".", "reshape", "(", "(", "1", ",", "len", "(", "dt", ")", ")", ")", "\n", "dtIg", "=", "np", ".", "logical_or", "(", "dtIg", ",", "np", ".", "logical_and", "(", "dtm", "==", "0", ",", "np", ".", "repeat", "(", "a", ",", "T", ",", "0", ")", ")", ")", "\n", "# store results for given image and category", "\n", "# print('Done with the function', len(self.ious[imgId, catId]))", "\n", "return", "{", "\n", "\"image_id\"", ":", "imgId", ",", "\n", "\"category_id\"", ":", "catId", ",", "\n", "\"aRng\"", ":", "aRng", ",", "\n", "\"maxDet\"", ":", "maxDet", ",", "\n", "\"dtIds\"", ":", "[", "d", "[", "\"id\"", "]", "for", "d", "in", "dt", "]", ",", "\n", "\"gtIds\"", ":", "[", "g", "[", "\"id\"", "]", "for", "g", "in", "gt", "]", ",", "\n", "\"dtMatches\"", ":", "dtm", ",", "\n", "\"gtMatches\"", ":", "gtm", ",", "\n", "\"dtScores\"", ":", "[", "d", "[", "\"score\"", "]", "for", "d", "in", "dt", "]", ",", "\n", "\"gtIgnore\"", ":", "gtIg", ",", "\n", "\"dtIgnore\"", ":", "dtIg", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.accumulate": [[786, 890], ["logger.info", "time.time", "len", "len", "len", "len", "logger.info", "set", "set", "set", "set", "len", "len", "enumerate", "logger.info", "time.time", "logger.info", "logger.info", "len", "numpy.ones", "numpy.ones", "map", "enumerate", "datetime.datetime.now().strftime", "enumerate", "enumerate", "enumerate", "enumerate", "enumerate", "numpy.max", "numpy.min", "map", "numpy.concatenate", "numpy.argsort", "numpy.concatenate", "numpy.count_nonzero", "numpy.logical_and", "numpy.logical_and", "numpy.cumsum().astype", "numpy.cumsum().astype", "enumerate", "datetime.datetime.now", "len", "numpy.concatenate", "numpy.concatenate", "numpy.logical_not", "numpy.logical_not", "numpy.logical_not", "zip", "numpy.array", "numpy.array", "len", "numpy.zeros", "pr.tolist.tolist.tolist", "q.tolist.tolist.tolist", "range", "numpy.searchsorted", "numpy.array", "tuple", "numpy.cumsum", "numpy.cumsum", "enumerate", "numpy.spacing"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["", "def", "accumulate", "(", "self", ",", "p", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Accumulate per image evaluation results and store the result in self.eval\n        :param p: input params for evaluation\n        :return: None\n        \"\"\"", "\n", "logger", ".", "info", "(", "\"Accumulating evaluation results...\"", ")", "\n", "tic", "=", "time", ".", "time", "(", ")", "\n", "if", "not", "self", ".", "evalImgs", ":", "\n", "            ", "logger", ".", "info", "(", "\"Please run evaluate() first\"", ")", "\n", "# allows input customized parameters", "\n", "", "if", "p", "is", "None", ":", "\n", "            ", "p", "=", "self", ".", "params", "\n", "", "p", ".", "catIds", "=", "p", ".", "catIds", "if", "p", ".", "useCats", "==", "1", "else", "[", "-", "1", "]", "\n", "T", "=", "len", "(", "p", ".", "iouThrs", ")", "\n", "R", "=", "len", "(", "p", ".", "recThrs", ")", "\n", "K", "=", "len", "(", "p", ".", "catIds", ")", "if", "p", ".", "useCats", "else", "1", "\n", "A", "=", "len", "(", "p", ".", "areaRng", ")", "\n", "M", "=", "len", "(", "p", ".", "maxDets", ")", "\n", "precision", "=", "-", "(", "np", ".", "ones", "(", "(", "T", ",", "R", ",", "K", ",", "A", ",", "M", ")", ")", ")", "# -1 for the precision of absent categories", "\n", "recall", "=", "-", "(", "np", ".", "ones", "(", "(", "T", ",", "K", ",", "A", ",", "M", ")", ")", ")", "\n", "\n", "# create dictionary for future indexing", "\n", "logger", ".", "info", "(", "\"Categories: {}\"", ".", "format", "(", "p", ".", "catIds", ")", ")", "\n", "_pe", "=", "self", ".", "_paramsEval", "\n", "catIds", "=", "_pe", ".", "catIds", "if", "_pe", ".", "useCats", "else", "[", "-", "1", "]", "\n", "setK", "=", "set", "(", "catIds", ")", "\n", "setA", "=", "set", "(", "map", "(", "tuple", ",", "_pe", ".", "areaRng", ")", ")", "\n", "setM", "=", "set", "(", "_pe", ".", "maxDets", ")", "\n", "setI", "=", "set", "(", "_pe", ".", "imgIds", ")", "\n", "# get inds to evaluate", "\n", "k_list", "=", "[", "n", "for", "n", ",", "k", "in", "enumerate", "(", "p", ".", "catIds", ")", "if", "k", "in", "setK", "]", "\n", "m_list", "=", "[", "m", "for", "n", ",", "m", "in", "enumerate", "(", "p", ".", "maxDets", ")", "if", "m", "in", "setM", "]", "\n", "a_list", "=", "[", "n", "for", "n", ",", "a", "in", "enumerate", "(", "map", "(", "lambda", "x", ":", "tuple", "(", "x", ")", ",", "p", ".", "areaRng", ")", ")", "if", "a", "in", "setA", "]", "\n", "i_list", "=", "[", "n", "for", "n", ",", "i", "in", "enumerate", "(", "p", ".", "imgIds", ")", "if", "i", "in", "setI", "]", "\n", "I0", "=", "len", "(", "_pe", ".", "imgIds", ")", "\n", "A0", "=", "len", "(", "_pe", ".", "areaRng", ")", "\n", "# retrieve E at each category, area range, and max number of detections", "\n", "for", "k", ",", "k0", "in", "enumerate", "(", "k_list", ")", ":", "\n", "            ", "Nk", "=", "k0", "*", "A0", "*", "I0", "\n", "for", "a", ",", "a0", "in", "enumerate", "(", "a_list", ")", ":", "\n", "                ", "Na", "=", "a0", "*", "I0", "\n", "for", "m", ",", "maxDet", "in", "enumerate", "(", "m_list", ")", ":", "\n", "                    ", "E", "=", "[", "self", ".", "evalImgs", "[", "Nk", "+", "Na", "+", "i", "]", "for", "i", "in", "i_list", "]", "\n", "E", "=", "[", "e", "for", "e", "in", "E", "if", "e", "is", "not", "None", "]", "\n", "if", "len", "(", "E", ")", "==", "0", ":", "\n", "                        ", "continue", "\n", "", "dtScores", "=", "np", ".", "concatenate", "(", "[", "e", "[", "\"dtScores\"", "]", "[", "0", ":", "maxDet", "]", "for", "e", "in", "E", "]", ")", "\n", "\n", "# different sorting method generates slightly different results.", "\n", "# mergesort is used to be consistent as Matlab implementation.", "\n", "inds", "=", "np", ".", "argsort", "(", "-", "dtScores", ",", "kind", "=", "\"mergesort\"", ")", "\n", "\n", "dtm", "=", "np", ".", "concatenate", "(", "[", "e", "[", "\"dtMatches\"", "]", "[", ":", ",", "0", ":", "maxDet", "]", "for", "e", "in", "E", "]", ",", "axis", "=", "1", ")", "[", ":", ",", "inds", "]", "\n", "dtIg", "=", "np", ".", "concatenate", "(", "[", "e", "[", "\"dtIgnore\"", "]", "[", ":", ",", "0", ":", "maxDet", "]", "for", "e", "in", "E", "]", ",", "axis", "=", "1", ")", "[", ":", ",", "inds", "]", "\n", "gtIg", "=", "np", ".", "concatenate", "(", "[", "e", "[", "\"gtIgnore\"", "]", "for", "e", "in", "E", "]", ")", "\n", "npig", "=", "np", ".", "count_nonzero", "(", "gtIg", "==", "0", ")", "\n", "if", "npig", "==", "0", ":", "\n", "                        ", "continue", "\n", "", "tps", "=", "np", ".", "logical_and", "(", "dtm", ",", "np", ".", "logical_not", "(", "dtIg", ")", ")", "\n", "fps", "=", "np", ".", "logical_and", "(", "np", ".", "logical_not", "(", "dtm", ")", ",", "np", ".", "logical_not", "(", "dtIg", ")", ")", "\n", "tp_sum", "=", "np", ".", "cumsum", "(", "tps", ",", "axis", "=", "1", ")", ".", "astype", "(", "dtype", "=", "np", ".", "float", ")", "\n", "fp_sum", "=", "np", ".", "cumsum", "(", "fps", ",", "axis", "=", "1", ")", ".", "astype", "(", "dtype", "=", "np", ".", "float", ")", "\n", "for", "t", ",", "(", "tp", ",", "fp", ")", "in", "enumerate", "(", "zip", "(", "tp_sum", ",", "fp_sum", ")", ")", ":", "\n", "                        ", "tp", "=", "np", ".", "array", "(", "tp", ")", "\n", "fp", "=", "np", ".", "array", "(", "fp", ")", "\n", "nd", "=", "len", "(", "tp", ")", "\n", "rc", "=", "tp", "/", "npig", "\n", "pr", "=", "tp", "/", "(", "fp", "+", "tp", "+", "np", ".", "spacing", "(", "1", ")", ")", "\n", "q", "=", "np", ".", "zeros", "(", "(", "R", ",", ")", ")", "\n", "\n", "if", "nd", ":", "\n", "                            ", "recall", "[", "t", ",", "k", ",", "a", ",", "m", "]", "=", "rc", "[", "-", "1", "]", "\n", "", "else", ":", "\n", "                            ", "recall", "[", "t", ",", "k", ",", "a", ",", "m", "]", "=", "0", "\n", "\n", "# numpy is slow without cython optimization for accessing elements", "\n", "# use python array gets significant speed improvement", "\n", "", "pr", "=", "pr", ".", "tolist", "(", ")", "\n", "q", "=", "q", ".", "tolist", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "nd", "-", "1", ",", "0", ",", "-", "1", ")", ":", "\n", "                            ", "if", "pr", "[", "i", "]", ">", "pr", "[", "i", "-", "1", "]", ":", "\n", "                                ", "pr", "[", "i", "-", "1", "]", "=", "pr", "[", "i", "]", "\n", "\n", "", "", "inds", "=", "np", ".", "searchsorted", "(", "rc", ",", "p", ".", "recThrs", ",", "side", "=", "\"left\"", ")", "\n", "try", ":", "\n", "                            ", "for", "ri", ",", "pi", "in", "enumerate", "(", "inds", ")", ":", "\n", "                                ", "q", "[", "ri", "]", "=", "pr", "[", "pi", "]", "\n", "", "", "except", "Exception", ":", "\n", "                            ", "pass", "\n", "", "precision", "[", "t", ",", ":", ",", "k", ",", "a", ",", "m", "]", "=", "np", ".", "array", "(", "q", ")", "\n", "", "", "", "", "logger", ".", "info", "(", "\n", "\"Final: max precision {}, min precision {}\"", ".", "format", "(", "np", ".", "max", "(", "precision", ")", ",", "np", ".", "min", "(", "precision", ")", ")", "\n", ")", "\n", "self", ".", "eval", "=", "{", "\n", "\"params\"", ":", "p", ",", "\n", "\"counts\"", ":", "[", "T", ",", "R", ",", "K", ",", "A", ",", "M", "]", ",", "\n", "\"date\"", ":", "datetime", ".", "datetime", ".", "now", "(", ")", ".", "strftime", "(", "\"%Y-%m-%d %H:%M:%S\"", ")", ",", "\n", "\"precision\"", ":", "precision", ",", "\n", "\"recall\"", ":", "recall", ",", "\n", "}", "\n", "toc", "=", "time", ".", "time", "(", ")", "\n", "logger", ".", "info", "(", "\"DONE (t={:0.2f}s).\"", ".", "format", "(", "toc", "-", "tic", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.summarize": [[891, 1021], ["densepose_coco_evaluation.DensePoseCocoEval.summarize"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.summarize"], ["", "def", "summarize", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Compute and display summary metrics for evaluation results.\n        Note this function can *only* be applied on the default parameter setting\n        \"\"\"", "\n", "\n", "def", "_summarize", "(", "ap", "=", "1", ",", "iouThr", "=", "None", ",", "areaRng", "=", "\"all\"", ",", "maxDets", "=", "100", ")", ":", "\n", "            ", "p", "=", "self", ".", "params", "\n", "iStr", "=", "\" {:<18} {} @[ {}={:<9} | area={:>6s} | maxDets={:>3d} ] = {:0.3f}\"", "\n", "titleStr", "=", "\"Average Precision\"", "if", "ap", "==", "1", "else", "\"Average Recall\"", "\n", "typeStr", "=", "\"(AP)\"", "if", "ap", "==", "1", "else", "\"(AR)\"", "\n", "measure", "=", "\"IoU\"", "\n", "if", "self", ".", "params", ".", "iouType", "==", "\"keypoints\"", ":", "\n", "                ", "measure", "=", "\"OKS\"", "\n", "", "elif", "self", ".", "params", ".", "iouType", "==", "\"densepose\"", ":", "\n", "                ", "measure", "=", "\"OGPS\"", "\n", "", "iouStr", "=", "(", "\n", "\"{:0.2f}:{:0.2f}\"", ".", "format", "(", "p", ".", "iouThrs", "[", "0", "]", ",", "p", ".", "iouThrs", "[", "-", "1", "]", ")", "\n", "if", "iouThr", "is", "None", "\n", "else", "\"{:0.2f}\"", ".", "format", "(", "iouThr", ")", "\n", ")", "\n", "\n", "aind", "=", "[", "i", "for", "i", ",", "aRng", "in", "enumerate", "(", "p", ".", "areaRngLbl", ")", "if", "aRng", "==", "areaRng", "]", "\n", "mind", "=", "[", "i", "for", "i", ",", "mDet", "in", "enumerate", "(", "p", ".", "maxDets", ")", "if", "mDet", "==", "maxDets", "]", "\n", "if", "ap", "==", "1", ":", "\n", "# dimension of precision: [TxRxKxAxM]", "\n", "                ", "s", "=", "self", ".", "eval", "[", "\"precision\"", "]", "\n", "# IoU", "\n", "if", "iouThr", "is", "not", "None", ":", "\n", "                    ", "t", "=", "np", ".", "where", "(", "np", ".", "abs", "(", "iouThr", "-", "p", ".", "iouThrs", ")", "<", "0.001", ")", "[", "0", "]", "\n", "s", "=", "s", "[", "t", "]", "\n", "", "s", "=", "s", "[", ":", ",", ":", ",", ":", ",", "aind", ",", "mind", "]", "\n", "", "else", ":", "\n", "# dimension of recall: [TxKxAxM]", "\n", "                ", "s", "=", "self", ".", "eval", "[", "\"recall\"", "]", "\n", "if", "iouThr", "is", "not", "None", ":", "\n", "                    ", "t", "=", "np", ".", "where", "(", "np", ".", "abs", "(", "iouThr", "-", "p", ".", "iouThrs", ")", "<", "0.001", ")", "[", "0", "]", "\n", "s", "=", "s", "[", "t", "]", "\n", "", "s", "=", "s", "[", ":", ",", ":", ",", "aind", ",", "mind", "]", "\n", "", "if", "len", "(", "s", "[", "s", ">", "-", "1", "]", ")", "==", "0", ":", "\n", "                ", "mean_s", "=", "-", "1", "\n", "", "else", ":", "\n", "                ", "mean_s", "=", "np", ".", "mean", "(", "s", "[", "s", ">", "-", "1", "]", ")", "\n", "", "logger", ".", "info", "(", "iStr", ".", "format", "(", "titleStr", ",", "typeStr", ",", "measure", ",", "iouStr", ",", "areaRng", ",", "maxDets", ",", "mean_s", ")", ")", "\n", "return", "mean_s", "\n", "\n", "", "def", "_summarizeDets", "(", ")", ":", "\n", "            ", "stats", "=", "np", ".", "zeros", "(", "(", "12", ",", ")", ")", "\n", "stats", "[", "0", "]", "=", "_summarize", "(", "1", ")", "\n", "stats", "[", "1", "]", "=", "_summarize", "(", "1", ",", "iouThr", "=", "0.5", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "2", "]", "=", "_summarize", "(", "1", ",", "iouThr", "=", "0.75", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "3", "]", "=", "_summarize", "(", "1", ",", "areaRng", "=", "\"small\"", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "4", "]", "=", "_summarize", "(", "1", ",", "areaRng", "=", "\"medium\"", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "5", "]", "=", "_summarize", "(", "1", ",", "areaRng", "=", "\"large\"", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "6", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ")", "\n", "stats", "[", "7", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "1", "]", ")", "\n", "stats", "[", "8", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "9", "]", "=", "_summarize", "(", "0", ",", "areaRng", "=", "\"small\"", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "10", "]", "=", "_summarize", "(", "0", ",", "areaRng", "=", "\"medium\"", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "11", "]", "=", "_summarize", "(", "0", ",", "areaRng", "=", "\"large\"", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "return", "stats", "\n", "\n", "", "def", "_summarizeKps", "(", ")", ":", "\n", "            ", "stats", "=", "np", ".", "zeros", "(", "(", "10", ",", ")", ")", "\n", "stats", "[", "0", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "20", ")", "\n", "stats", "[", "1", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "20", ",", "iouThr", "=", "0.5", ")", "\n", "stats", "[", "2", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "20", ",", "iouThr", "=", "0.75", ")", "\n", "stats", "[", "3", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "20", ",", "areaRng", "=", "\"medium\"", ")", "\n", "stats", "[", "4", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "20", ",", "areaRng", "=", "\"large\"", ")", "\n", "stats", "[", "5", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "20", ")", "\n", "stats", "[", "6", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "20", ",", "iouThr", "=", "0.5", ")", "\n", "stats", "[", "7", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "20", ",", "iouThr", "=", "0.75", ")", "\n", "stats", "[", "8", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "20", ",", "areaRng", "=", "\"medium\"", ")", "\n", "stats", "[", "9", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "20", ",", "areaRng", "=", "\"large\"", ")", "\n", "return", "stats", "\n", "\n", "", "def", "_summarizeUvs", "(", ")", ":", "\n", "            ", "stats", "=", "[", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ")", "]", "\n", "min_threshold", "=", "self", ".", "params", ".", "iouThrs", ".", "min", "(", ")", "\n", "if", "min_threshold", "<=", "0.201", ":", "\n", "                ", "stats", "+=", "[", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.2", ")", "]", "\n", "", "if", "min_threshold", "<=", "0.301", ":", "\n", "                ", "stats", "+=", "[", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.3", ")", "]", "\n", "", "if", "min_threshold", "<=", "0.401", ":", "\n", "                ", "stats", "+=", "[", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.4", ")", "]", "\n", "", "stats", "+=", "[", "\n", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.5", ")", ",", "\n", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.75", ")", ",", "\n", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "areaRng", "=", "\"medium\"", ")", ",", "\n", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "areaRng", "=", "\"large\"", ")", ",", "\n", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ")", ",", "\n", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.5", ")", ",", "\n", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.75", ")", ",", "\n", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "areaRng", "=", "\"medium\"", ")", ",", "\n", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "areaRng", "=", "\"large\"", ")", ",", "\n", "]", "\n", "return", "np", ".", "array", "(", "stats", ")", "\n", "\n", "", "def", "_summarizeUvsOld", "(", ")", ":", "\n", "            ", "stats", "=", "np", ".", "zeros", "(", "(", "18", ",", ")", ")", "\n", "stats", "[", "0", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ")", "\n", "stats", "[", "1", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.5", ")", "\n", "stats", "[", "2", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.55", ")", "\n", "stats", "[", "3", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.60", ")", "\n", "stats", "[", "4", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.65", ")", "\n", "stats", "[", "5", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.70", ")", "\n", "stats", "[", "6", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.75", ")", "\n", "stats", "[", "7", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.80", ")", "\n", "stats", "[", "8", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.85", ")", "\n", "stats", "[", "9", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.90", ")", "\n", "stats", "[", "10", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.95", ")", "\n", "stats", "[", "11", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "areaRng", "=", "\"medium\"", ")", "\n", "stats", "[", "12", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "areaRng", "=", "\"large\"", ")", "\n", "stats", "[", "13", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ")", "\n", "stats", "[", "14", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.5", ")", "\n", "stats", "[", "15", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.75", ")", "\n", "stats", "[", "16", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "areaRng", "=", "\"medium\"", ")", "\n", "stats", "[", "17", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "areaRng", "=", "\"large\"", ")", "\n", "return", "stats", "\n", "\n", "", "if", "not", "self", ".", "eval", ":", "\n", "            ", "raise", "Exception", "(", "\"Please run accumulate() first\"", ")", "\n", "", "iouType", "=", "self", ".", "params", ".", "iouType", "\n", "if", "iouType", "in", "[", "\"segm\"", ",", "\"bbox\"", "]", ":", "\n", "            ", "summarize", "=", "_summarizeDets", "\n", "", "elif", "iouType", "in", "[", "\"keypoints\"", "]", ":", "\n", "            ", "summarize", "=", "_summarizeKps", "\n", "", "elif", "iouType", "in", "[", "\"densepose\"", "]", ":", "\n", "            ", "summarize", "=", "_summarizeUvs", "\n", "", "self", ".", "stats", "=", "summarize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.__str__": [[1022, 1024], ["densepose_coco_evaluation.DensePoseCocoEval.summarize"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.summarize"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "self", ".", "summarize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.findAllClosestVerts": [[1026, 1058], ["numpy.array", "numpy.array", "numpy.array", "numpy.arange", "numpy.arange", "numpy.ones", "numpy.ones", "sum", "numpy.array", "scipy.cdist().squeeze", "sum", "numpy.array", "scipy.cdist().squeeze", "scipy.cdist", "numpy.argmin", "scipy.cdist", "numpy.argmin", "Current_Part_UVs.transpose", "numpy.array.transpose", "Current_Part_UVs.transpose", "numpy.array.transpose"], "methods", ["None"], ["", "def", "findAllClosestVerts", "(", "self", ",", "gt", ",", "U_points", ",", "V_points", ",", "Index_points", ")", ":", "\n", "#", "\n", "        ", "I_gt", "=", "np", ".", "array", "(", "gt", "[", "\"dp_I\"", "]", ")", "\n", "U_gt", "=", "np", ".", "array", "(", "gt", "[", "\"dp_U\"", "]", ")", "\n", "V_gt", "=", "np", ".", "array", "(", "gt", "[", "\"dp_V\"", "]", ")", "\n", "#", "\n", "# print(I_gt)", "\n", "#", "\n", "ClosestVerts", "=", "np", ".", "ones", "(", "Index_points", ".", "shape", ")", "*", "-", "1", "\n", "for", "i", "in", "np", ".", "arange", "(", "24", ")", ":", "\n", "#", "\n", "            ", "if", "sum", "(", "Index_points", "==", "(", "i", "+", "1", ")", ")", ">", "0", ":", "\n", "                ", "UVs", "=", "np", ".", "array", "(", "\n", "[", "U_points", "[", "Index_points", "==", "(", "i", "+", "1", ")", "]", ",", "V_points", "[", "Index_points", "==", "(", "i", "+", "1", ")", "]", "]", "\n", ")", "\n", "Current_Part_UVs", "=", "self", ".", "Part_UVs", "[", "i", "]", "\n", "Current_Part_ClosestVertInds", "=", "self", ".", "Part_ClosestVertInds", "[", "i", "]", "\n", "D", "=", "ssd", ".", "cdist", "(", "Current_Part_UVs", ".", "transpose", "(", ")", ",", "UVs", ".", "transpose", "(", ")", ")", ".", "squeeze", "(", ")", "\n", "ClosestVerts", "[", "Index_points", "==", "(", "i", "+", "1", ")", "]", "=", "Current_Part_ClosestVertInds", "[", "\n", "np", ".", "argmin", "(", "D", ",", "axis", "=", "0", ")", "\n", "]", "\n", "#", "\n", "", "", "ClosestVertsGT", "=", "np", ".", "ones", "(", "Index_points", ".", "shape", ")", "*", "-", "1", "\n", "for", "i", "in", "np", ".", "arange", "(", "24", ")", ":", "\n", "            ", "if", "sum", "(", "I_gt", "==", "(", "i", "+", "1", ")", ")", ">", "0", ":", "\n", "                ", "UVs", "=", "np", ".", "array", "(", "[", "U_gt", "[", "I_gt", "==", "(", "i", "+", "1", ")", "]", ",", "V_gt", "[", "I_gt", "==", "(", "i", "+", "1", ")", "]", "]", ")", "\n", "Current_Part_UVs", "=", "self", ".", "Part_UVs", "[", "i", "]", "\n", "Current_Part_ClosestVertInds", "=", "self", ".", "Part_ClosestVertInds", "[", "i", "]", "\n", "D", "=", "ssd", ".", "cdist", "(", "Current_Part_UVs", ".", "transpose", "(", ")", ",", "UVs", ".", "transpose", "(", ")", ")", ".", "squeeze", "(", ")", "\n", "ClosestVertsGT", "[", "I_gt", "==", "(", "i", "+", "1", ")", "]", "=", "Current_Part_ClosestVertInds", "[", "np", ".", "argmin", "(", "D", ",", "axis", "=", "0", ")", "]", "\n", "#", "\n", "", "", "return", "ClosestVerts", ",", "ClosestVertsGT", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.DensePoseCocoEval.getDistances": [[1059, 1097], ["range", "numpy.atleast_1d", "len", "numpy.array().squeeze", "cVerts.astype", "cVertsGT.astype", "dists.append", "numpy.array", "dists.append", "dists.append", "dists.append", "int", "int"], "methods", ["None"], ["", "def", "getDistances", "(", "self", ",", "cVertsGT", ",", "cVerts", ")", ":", "\n", "\n", "        ", "ClosestVertsTransformed", "=", "self", ".", "PDIST_transform", "[", "cVerts", ".", "astype", "(", "int", ")", "-", "1", "]", "\n", "ClosestVertsGTTransformed", "=", "self", ".", "PDIST_transform", "[", "cVertsGT", ".", "astype", "(", "int", ")", "-", "1", "]", "\n", "#", "\n", "ClosestVertsTransformed", "[", "cVerts", "<", "0", "]", "=", "0", "\n", "ClosestVertsGTTransformed", "[", "cVertsGT", "<", "0", "]", "=", "0", "\n", "#", "\n", "cVertsGT", "=", "ClosestVertsGTTransformed", "\n", "cVerts", "=", "ClosestVertsTransformed", "\n", "#", "\n", "n", "=", "27554", "\n", "dists", "=", "[", "]", "\n", "for", "d", "in", "range", "(", "len", "(", "cVertsGT", ")", ")", ":", "\n", "            ", "if", "cVertsGT", "[", "d", "]", ">", "0", ":", "\n", "                ", "if", "cVerts", "[", "d", "]", ">", "0", ":", "\n", "                    ", "i", "=", "cVertsGT", "[", "d", "]", "-", "1", "\n", "j", "=", "cVerts", "[", "d", "]", "-", "1", "\n", "if", "j", "==", "i", ":", "\n", "                        ", "dists", ".", "append", "(", "0", ")", "\n", "", "elif", "j", ">", "i", ":", "\n", "                        ", "ccc", "=", "i", "\n", "i", "=", "j", "\n", "j", "=", "ccc", "\n", "i", "=", "n", "-", "i", "-", "1", "\n", "j", "=", "n", "-", "j", "-", "1", "\n", "k", "=", "(", "n", "*", "(", "n", "-", "1", ")", "/", "2", ")", "-", "(", "n", "-", "i", ")", "*", "(", "(", "n", "-", "i", ")", "-", "1", ")", "/", "2", "+", "j", "-", "i", "-", "1", "\n", "k", "=", "(", "n", "*", "n", "-", "n", ")", "/", "2", "-", "k", "-", "1", "\n", "dists", ".", "append", "(", "self", ".", "Pdist_matrix", "[", "int", "(", "k", ")", "]", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "                        ", "i", "=", "n", "-", "i", "-", "1", "\n", "j", "=", "n", "-", "j", "-", "1", "\n", "k", "=", "(", "n", "*", "(", "n", "-", "1", ")", "/", "2", ")", "-", "(", "n", "-", "i", ")", "*", "(", "(", "n", "-", "i", ")", "-", "1", ")", "/", "2", "+", "j", "-", "i", "-", "1", "\n", "k", "=", "(", "n", "*", "n", "-", "n", ")", "/", "2", "-", "k", "-", "1", "\n", "dists", ".", "append", "(", "self", ".", "Pdist_matrix", "[", "int", "(", "k", ")", "]", "[", "0", "]", ")", "\n", "", "", "else", ":", "\n", "                    ", "dists", ".", "append", "(", "np", ".", "inf", ")", "\n", "", "", "", "return", "np", ".", "atleast_1d", "(", "np", ".", "array", "(", "dists", ")", ".", "squeeze", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.Params.setDetParams": [[1104, 1119], ["numpy.linspace", "numpy.linspace", "int", "int", "numpy.round", "numpy.round"], "methods", ["None"], ["def", "setDetParams", "(", "self", ")", ":", "\n", "        ", "self", ".", "imgIds", "=", "[", "]", "\n", "self", ".", "catIds", "=", "[", "]", "\n", "# np.arange causes trouble.  the data point on arange is slightly larger than the true value", "\n", "self", ".", "iouThrs", "=", "np", ".", "linspace", "(", "0.5", ",", "0.95", ",", "int", "(", "np", ".", "round", "(", "(", "0.95", "-", "0.5", ")", "/", "0.05", ")", ")", "+", "1", ",", "endpoint", "=", "True", ")", "\n", "self", ".", "recThrs", "=", "np", ".", "linspace", "(", "0.0", ",", "1.00", ",", "int", "(", "np", ".", "round", "(", "(", "1.00", "-", "0.0", ")", "/", "0.01", ")", ")", "+", "1", ",", "endpoint", "=", "True", ")", "\n", "self", ".", "maxDets", "=", "[", "1", ",", "10", ",", "100", "]", "\n", "self", ".", "areaRng", "=", "[", "\n", "[", "0", "**", "2", ",", "1e5", "**", "2", "]", ",", "\n", "[", "0", "**", "2", ",", "32", "**", "2", "]", ",", "\n", "[", "32", "**", "2", ",", "96", "**", "2", "]", ",", "\n", "[", "96", "**", "2", ",", "1e5", "**", "2", "]", ",", "\n", "]", "\n", "self", ".", "areaRngLbl", "=", "[", "\"all\"", ",", "\"small\"", ",", "\"medium\"", ",", "\"large\"", "]", "\n", "self", ".", "useCats", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.Params.setKpParams": [[1120, 1130], ["numpy.linspace", "numpy.linspace", "numpy.round", "numpy.round"], "methods", ["None"], ["", "def", "setKpParams", "(", "self", ")", ":", "\n", "        ", "self", ".", "imgIds", "=", "[", "]", "\n", "self", ".", "catIds", "=", "[", "]", "\n", "# np.arange causes trouble.  the data point on arange is slightly larger than the true value", "\n", "self", ".", "iouThrs", "=", "np", ".", "linspace", "(", "0.5", ",", "0.95", ",", "np", ".", "round", "(", "(", "0.95", "-", "0.5", ")", "/", "0.05", ")", "+", "1", ",", "endpoint", "=", "True", ")", "\n", "self", ".", "recThrs", "=", "np", ".", "linspace", "(", "0.0", ",", "1.00", ",", "np", ".", "round", "(", "(", "1.00", "-", "0.0", ")", "/", "0.01", ")", "+", "1", ",", "endpoint", "=", "True", ")", "\n", "self", ".", "maxDets", "=", "[", "20", "]", "\n", "self", ".", "areaRng", "=", "[", "[", "0", "**", "2", ",", "1e5", "**", "2", "]", ",", "[", "32", "**", "2", ",", "96", "**", "2", "]", ",", "[", "96", "**", "2", ",", "1e5", "**", "2", "]", "]", "\n", "self", ".", "areaRngLbl", "=", "[", "\"all\"", ",", "\"medium\"", ",", "\"large\"", "]", "\n", "self", ".", "useCats", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.Params.setUvParams": [[1131, 1140], ["numpy.linspace", "numpy.linspace", "int", "int", "numpy.round", "numpy.round"], "methods", ["None"], ["", "def", "setUvParams", "(", "self", ")", ":", "\n", "        ", "self", ".", "imgIds", "=", "[", "]", "\n", "self", ".", "catIds", "=", "[", "]", "\n", "self", ".", "iouThrs", "=", "np", ".", "linspace", "(", "0.5", ",", "0.95", ",", "int", "(", "np", ".", "round", "(", "(", "0.95", "-", "0.5", ")", "/", "0.05", ")", ")", "+", "1", ",", "endpoint", "=", "True", ")", "\n", "self", ".", "recThrs", "=", "np", ".", "linspace", "(", "0.0", ",", "1.00", ",", "int", "(", "np", ".", "round", "(", "(", "1.00", "-", "0.0", ")", "/", "0.01", ")", ")", "+", "1", ",", "endpoint", "=", "True", ")", "\n", "self", ".", "maxDets", "=", "[", "20", "]", "\n", "self", ".", "areaRng", "=", "[", "[", "0", "**", "2", ",", "1e5", "**", "2", "]", ",", "[", "32", "**", "2", ",", "96", "**", "2", "]", ",", "[", "96", "**", "2", ",", "1e5", "**", "2", "]", "]", "\n", "self", ".", "areaRngLbl", "=", "[", "\"all\"", ",", "\"medium\"", ",", "\"large\"", "]", "\n", "self", ".", "useCats", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.Params.__init__": [[1141, 1153], ["densepose_coco_evaluation.Params.setDetParams", "densepose_coco_evaluation.Params.setKpParams", "densepose_coco_evaluation.Params.setUvParams", "Exception"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.Params.setDetParams", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.Params.setKpParams", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.densepose.densepose_coco_evaluation.Params.setUvParams"], ["", "def", "__init__", "(", "self", ",", "iouType", "=", "\"segm\"", ")", ":", "\n", "        ", "if", "iouType", "==", "\"segm\"", "or", "iouType", "==", "\"bbox\"", ":", "\n", "            ", "self", ".", "setDetParams", "(", ")", "\n", "", "elif", "iouType", "==", "\"keypoints\"", ":", "\n", "            ", "self", ".", "setKpParams", "(", ")", "\n", "", "elif", "iouType", "==", "\"densepose\"", ":", "\n", "            ", "self", ".", "setUvParams", "(", ")", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\"iouType not supported\"", ")", "\n", "", "self", ".", "iouType", "=", "iouType", "\n", "# useSegm is deprecated", "\n", "self", ".", "useSegm", "=", "None", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.predictors.chart_confidence.DensePoseChartConfidencePredictorMixin.__init__": [[32, 46], ["super().__init__", "confidence.DensePoseConfidenceModelConfig.from_cfg", "chart_confidence.DensePoseChartConfidencePredictorMixin._initialize_confidence_estimation_layers", "utils.initialize_module_params"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.confidence.DensePoseConfidenceModelConfig.from_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.predictors.chart_confidence.DensePoseChartConfidencePredictorMixin._initialize_confidence_estimation_layers", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.utils.initialize_module_params"], ["def", "__init__", "(", "self", ",", "cfg", ":", "CfgNode", ",", "input_channels", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Initialize confidence predictor using configuration options.\n\n        Args:\n            cfg (CfgNode): configuration options\n            input_channels (int): number of input channels\n        \"\"\"", "\n", "# we rely on base predictor to call nn.Module.__init__", "\n", "super", "(", ")", ".", "__init__", "(", "cfg", ",", "input_channels", ")", "\n", "self", ".", "confidence_model_cfg", "=", "DensePoseConfidenceModelConfig", ".", "from_cfg", "(", "cfg", ")", "\n", "self", ".", "_initialize_confidence_estimation_layers", "(", "cfg", ",", "input_channels", ")", "\n", "self", ".", "_registry", "=", "{", "}", "\n", "initialize_module_params", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.predictors.chart_confidence.DensePoseChartConfidencePredictorMixin._initialize_confidence_estimation_layers": [[47, 86], ["detectron2.layers.ConvTranspose2d", "detectron2.layers.ConvTranspose2d", "detectron2.layers.ConvTranspose2d", "detectron2.layers.ConvTranspose2d", "detectron2.layers.ConvTranspose2d", "detectron2.layers.ConvTranspose2d", "ValueError", "int", "int", "int", "int", "int", "int"], "methods", ["None"], ["", "def", "_initialize_confidence_estimation_layers", "(", "self", ",", "cfg", ":", "CfgNode", ",", "dim_in", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Initialize confidence estimation layers based on configuration options\n\n        Args:\n            cfg (CfgNode): configuration options\n            dim_in (int): number of input channels\n        \"\"\"", "\n", "dim_out_patches", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "NUM_PATCHES", "+", "1", "\n", "kernel_size", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "DECONV_KERNEL", "\n", "if", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "enabled", ":", "\n", "            ", "if", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "type", "==", "DensePoseUVConfidenceType", ".", "IID_ISO", ":", "\n", "                ", "self", ".", "sigma_2_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "", "elif", "(", "\n", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "type", "\n", "==", "DensePoseUVConfidenceType", ".", "INDEP_ANISO", "\n", ")", ":", "\n", "                ", "self", ".", "sigma_2_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "self", ".", "kappa_u_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "self", ".", "kappa_v_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "f\"Unknown confidence model type: \"", "\n", "f\"{self.confidence_model_cfg.confidence_model_type}\"", "\n", ")", "\n", "", "", "if", "self", ".", "confidence_model_cfg", ".", "segm_confidence", ".", "enabled", ":", "\n", "            ", "self", ".", "fine_segm_confidence_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "1", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "self", ".", "coarse_segm_confidence_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "1", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.predictors.chart_confidence.DensePoseChartConfidencePredictorMixin.forward": [[88, 142], ["super().forward", "chart_confidence.DensePoseChartConfidencePredictorMixin._create_output_instance", "chart_confidence.DensePoseChartConfidencePredictorMixin.interp2d", "torch.nn.functional.softplus", "torch.repeat_interleave", "torch.nn.functional.softplus", "torch.repeat_interleave", "chart_confidence.DensePoseChartConfidencePredictorMixin.sigma_2_lowres", "chart_confidence.DensePoseChartConfidencePredictorMixin.interp2d", "chart_confidence.DensePoseChartConfidencePredictorMixin.interp2d", "chart_confidence.DensePoseChartConfidencePredictorMixin.interp2d", "ValueError", "chart_confidence.DensePoseChartConfidencePredictorMixin.interp2d", "chart_confidence.DensePoseChartConfidencePredictorMixin.interp2d", "chart_confidence.DensePoseChartConfidencePredictorMixin.sigma_2_lowres", "chart_confidence.DensePoseChartConfidencePredictorMixin.kappa_u_lowres", "chart_confidence.DensePoseChartConfidencePredictorMixin.kappa_v_lowres", "chart_confidence.DensePoseChartConfidencePredictorMixin.fine_segm_confidence_lowres", "chart_confidence.DensePoseChartConfidencePredictorMixin.coarse_segm_confidence_lowres"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.forward", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.predictors.chart_confidence.DensePoseChartConfidencePredictorMixin._create_output_instance", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.predictors.chart.DensePoseChartPredictor.interp2d", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.predictors.chart.DensePoseChartPredictor.interp2d", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.predictors.chart.DensePoseChartPredictor.interp2d", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.predictors.chart.DensePoseChartPredictor.interp2d", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.predictors.chart.DensePoseChartPredictor.interp2d", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.predictors.chart.DensePoseChartPredictor.interp2d"], ["", "", "def", "forward", "(", "self", ",", "head_outputs", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Perform forward operation on head outputs used as inputs for the predictor.\n        Calls forward method from the base predictor and uses its outputs to compute\n        confidences.\n\n        Args:\n            head_outputs (Tensor): head outputs used as predictor inputs\n        Return:\n            An instance of outputs with confidences,\n            see `decorate_predictor_output_class_with_confidences`\n        \"\"\"", "\n", "# assuming base class returns SIUV estimates in its first result", "\n", "base_predictor_outputs", "=", "super", "(", ")", ".", "forward", "(", "head_outputs", ")", "\n", "\n", "# create output instance by extending base predictor outputs:", "\n", "output", "=", "self", ".", "_create_output_instance", "(", "base_predictor_outputs", ")", "\n", "\n", "if", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "enabled", ":", "\n", "            ", "if", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "type", "==", "DensePoseUVConfidenceType", ".", "IID_ISO", ":", "\n", "# assuming base class defines interp2d method for bilinear interpolation", "\n", "                ", "output", ".", "sigma_2", "=", "self", ".", "interp2d", "(", "self", ".", "sigma_2_lowres", "(", "head_outputs", ")", ")", "\n", "", "elif", "(", "\n", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "type", "\n", "==", "DensePoseUVConfidenceType", ".", "INDEP_ANISO", "\n", ")", ":", "\n", "# assuming base class defines interp2d method for bilinear interpolation", "\n", "                ", "output", ".", "sigma_2", "=", "self", ".", "interp2d", "(", "self", ".", "sigma_2_lowres", "(", "head_outputs", ")", ")", "\n", "output", ".", "kappa_u", "=", "self", ".", "interp2d", "(", "self", ".", "kappa_u_lowres", "(", "head_outputs", ")", ")", "\n", "output", ".", "kappa_v", "=", "self", ".", "interp2d", "(", "self", ".", "kappa_v_lowres", "(", "head_outputs", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "f\"Unknown confidence model type: \"", "\n", "f\"{self.confidence_model_cfg.confidence_model_type}\"", "\n", ")", "\n", "", "", "if", "self", ".", "confidence_model_cfg", ".", "segm_confidence", ".", "enabled", ":", "\n", "# base predictor outputs are assumed to have `fine_segm` and `coarse_segm` attributes", "\n", "# base predictor is assumed to define `interp2d` method for bilinear interpolation", "\n", "            ", "output", ".", "fine_segm_confidence", "=", "(", "\n", "F", ".", "softplus", "(", "self", ".", "interp2d", "(", "self", ".", "fine_segm_confidence_lowres", "(", "head_outputs", ")", ")", ")", "\n", "+", "self", ".", "confidence_model_cfg", ".", "segm_confidence", ".", "epsilon", "\n", ")", "\n", "output", ".", "fine_segm", "=", "base_predictor_outputs", ".", "fine_segm", "*", "torch", ".", "repeat_interleave", "(", "\n", "output", ".", "fine_segm_confidence", ",", "base_predictor_outputs", ".", "fine_segm", ".", "shape", "[", "1", "]", ",", "dim", "=", "1", "\n", ")", "\n", "output", ".", "coarse_segm_confidence", "=", "(", "\n", "F", ".", "softplus", "(", "self", ".", "interp2d", "(", "self", ".", "coarse_segm_confidence_lowres", "(", "head_outputs", ")", ")", ")", "\n", "+", "self", ".", "confidence_model_cfg", ".", "segm_confidence", ".", "epsilon", "\n", ")", "\n", "output", ".", "coarse_segm", "=", "base_predictor_outputs", ".", "coarse_segm", "*", "torch", ".", "repeat_interleave", "(", "\n", "output", ".", "coarse_segm_confidence", ",", "base_predictor_outputs", ".", "coarse_segm", ".", "shape", "[", "1", "]", ",", "dim", "=", "1", "\n", ")", "\n", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.predictors.chart_confidence.DensePoseChartConfidencePredictorMixin._create_output_instance": [[143, 169], ["structures.decorate_predictor_output_class_with_confidences", "structures.decorate_predictor_output_class_with_confidences.", "type"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.chart_confidence.decorate_predictor_output_class_with_confidences"], ["", "def", "_create_output_instance", "(", "self", ",", "base_predictor_outputs", ":", "Any", ")", ":", "\n", "        ", "\"\"\"\n        Create an instance of predictor outputs by copying the outputs from the\n        base predictor and initializing confidence\n\n        Args:\n            base_predictor_outputs: an instance of base predictor outputs\n                (the outputs type is assumed to be a dataclass)\n        Return:\n           An instance of outputs with confidences\n        \"\"\"", "\n", "PredictorOutput", "=", "decorate_predictor_output_class_with_confidences", "(", "\n", "type", "(", "base_predictor_outputs", ")", "\n", ")", "\n", "# base_predictor_outputs is assumed to be a dataclass", "\n", "# reassign all the fields from base_predictor_outputs (no deep copy!), add new fields", "\n", "output", "=", "PredictorOutput", "(", "\n", "**", "base_predictor_outputs", ".", "__dict__", ",", "\n", "coarse_segm_confidence", "=", "None", ",", "\n", "fine_segm_confidence", "=", "None", ",", "\n", "sigma_1", "=", "None", ",", "\n", "sigma_2", "=", "None", ",", "\n", "kappa_u", "=", "None", ",", "\n", "kappa_v", "=", "None", ",", "\n", ")", "\n", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.predictors.chart.DensePoseChartPredictor.__init__": [[34, 65], ["torch.nn.Module.__init__", "detectron2.layers.ConvTranspose2d", "detectron2.layers.ConvTranspose2d", "detectron2.layers.ConvTranspose2d", "detectron2.layers.ConvTranspose2d", "utils.initialize_module_params", "int", "int", "int", "int"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.utils.initialize_module_params"], ["def", "__init__", "(", "self", ",", "cfg", ":", "CfgNode", ",", "input_channels", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Initialize predictor using configuration options\n\n        Args:\n            cfg (CfgNode): configuration options\n            input_channels (int): input tensor size along the channel dimension\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "dim_in", "=", "input_channels", "\n", "n_segm_chan", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "NUM_COARSE_SEGM_CHANNELS", "\n", "dim_out_patches", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "NUM_PATCHES", "+", "1", "\n", "kernel_size", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "DECONV_KERNEL", "\n", "# coarse segmentation", "\n", "self", ".", "ann_index_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "n_segm_chan", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "# fine segmentation", "\n", "self", ".", "index_uv_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "# U", "\n", "self", ".", "u_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "# V", "\n", "self", ".", "v_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "self", ".", "scale_factor", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "UP_SCALE", "\n", "initialize_module_params", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.predictors.chart.DensePoseChartPredictor.interp2d": [[66, 78], ["detectron2.layers.interpolate"], "methods", ["None"], ["", "def", "interp2d", "(", "self", ",", "tensor_nchw", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Bilinear interpolation method to be used for upscaling\n\n        Args:\n            tensor_nchw (tensor): tensor of shape (N, C, H, W)\n        Return:\n            tensor of shape (N, C, Hout, Wout), where Hout and Wout are computed\n                by applying the scale factor to H and W\n        \"\"\"", "\n", "return", "interpolate", "(", "\n", "tensor_nchw", ",", "scale_factor", "=", "self", ".", "scale_factor", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.predictors.chart.DensePoseChartPredictor.forward": [[80, 94], ["structures.DensePoseChartPredictorOutput", "chart.DensePoseChartPredictor.interp2d", "chart.DensePoseChartPredictor.interp2d", "chart.DensePoseChartPredictor.interp2d", "chart.DensePoseChartPredictor.interp2d", "chart.DensePoseChartPredictor.ann_index_lowres", "chart.DensePoseChartPredictor.index_uv_lowres", "chart.DensePoseChartPredictor.u_lowres", "chart.DensePoseChartPredictor.v_lowres"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.predictors.chart.DensePoseChartPredictor.interp2d", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.predictors.chart.DensePoseChartPredictor.interp2d", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.predictors.chart.DensePoseChartPredictor.interp2d", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.predictors.chart.DensePoseChartPredictor.interp2d"], ["", "def", "forward", "(", "self", ",", "head_outputs", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Perform forward step on DensePose head outputs\n\n        Args:\n            head_outputs (tensor): DensePose head outputs, tensor of shape [N, D, H, W]\n        Return:\n           An instance of DensePoseChartPredictorOutput\n        \"\"\"", "\n", "return", "DensePoseChartPredictorOutput", "(", "\n", "coarse_segm", "=", "self", ".", "interp2d", "(", "self", ".", "ann_index_lowres", "(", "head_outputs", ")", ")", ",", "\n", "fine_segm", "=", "self", ".", "interp2d", "(", "self", ".", "index_uv_lowres", "(", "head_outputs", ")", ")", ",", "\n", "u", "=", "self", ".", "interp2d", "(", "self", ".", "u_lowres", "(", "head_outputs", ")", ")", ",", "\n", "v", "=", "self", ".", "interp2d", "(", "self", ".", "v_lowres", "(", "head_outputs", ")", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart_with_confidences.DensePoseChartWithConfidenceLoss.__init__": [[22, 32], ["chart.DensePoseChartLoss.__init__", "DensePoseConfidenceModelConfig.from_cfg", "chart_with_confidences.IIDIsotropicGaussianUVLoss", "chart_with_confidences.IndepAnisotropicGaussianUVLoss"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.modeling.confidence.DensePoseConfidenceModelConfig.from_cfg"], ["def", "__init__", "(", "self", ",", "cfg", ":", "CfgNode", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "cfg", ")", "\n", "self", ".", "confidence_model_cfg", "=", "DensePoseConfidenceModelConfig", ".", "from_cfg", "(", "cfg", ")", "\n", "if", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "type", "==", "DensePoseUVConfidenceType", ".", "IID_ISO", ":", "\n", "            ", "self", ".", "uv_loss_with_confidences", "=", "IIDIsotropicGaussianUVLoss", "(", "\n", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "epsilon", "\n", ")", "\n", "", "elif", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "type", "==", "DensePoseUVConfidenceType", ".", "INDEP_ANISO", ":", "\n", "            ", "self", ".", "uv_loss_with_confidences", "=", "IndepAnisotropicGaussianUVLoss", "(", "\n", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "epsilon", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart_with_confidences.DensePoseChartWithConfidenceLoss.produce_fake_densepose_losses_uv": [[34, 71], ["super().produce_fake_densepose_losses_uv", "densepose_predictor_outputs.u.sum", "densepose_predictor_outputs.v.sum", "densepose_predictor_outputs.sigma_2.sum", "densepose_predictor_outputs.kappa_v.sum", "densepose_predictor_outputs.sigma_2.sum", "densepose_predictor_outputs.kappa_u.sum"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.produce_fake_densepose_losses_uv"], ["", "", "def", "produce_fake_densepose_losses_uv", "(", "self", ",", "densepose_predictor_outputs", ":", "Any", ")", "->", "LossDict", ":", "\n", "        ", "\"\"\"\n        Overrides fake losses for fine segmentation and U/V coordinates to\n        include computation graphs for additional confidence parameters.\n        These are used when no suitable ground truth data was found in a batch.\n        The loss has a value 0 and is primarily used to construct the computation graph,\n        so that `DistributedDataParallel` has similar graphs on all GPUs and can\n        perform reduction properly.\n\n        Args:\n            densepose_predictor_outputs: DensePose predictor outputs, an object\n                of a dataclass that is assumed to have the following attributes:\n             * fine_segm - fine segmentation estimates, tensor of shape [N, C, S, S]\n             * u - U coordinate estimates per fine labels, tensor of shape [N, C, S, S]\n             * v - V coordinate estimates per fine labels, tensor of shape [N, C, S, S]\n        Return:\n            dict: str -> tensor: dict of losses with the following entries:\n             * `loss_densepose_U`: has value 0\n             * `loss_densepose_V`: has value 0\n             * `loss_densepose_I`: has value 0\n        \"\"\"", "\n", "conf_type", "=", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "type", "\n", "if", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "enabled", ":", "\n", "            ", "loss_uv", "=", "(", "\n", "densepose_predictor_outputs", ".", "u", ".", "sum", "(", ")", "+", "densepose_predictor_outputs", ".", "v", ".", "sum", "(", ")", "\n", ")", "*", "0", "\n", "if", "conf_type", "==", "DensePoseUVConfidenceType", ".", "IID_ISO", ":", "\n", "                ", "loss_uv", "+=", "densepose_predictor_outputs", ".", "sigma_2", ".", "sum", "(", ")", "*", "0", "\n", "", "elif", "conf_type", "==", "DensePoseUVConfidenceType", ".", "INDEP_ANISO", ":", "\n", "                ", "loss_uv", "+=", "(", "\n", "densepose_predictor_outputs", ".", "sigma_2", ".", "sum", "(", ")", "\n", "+", "densepose_predictor_outputs", ".", "kappa_u", ".", "sum", "(", ")", "\n", "+", "densepose_predictor_outputs", ".", "kappa_v", ".", "sum", "(", ")", "\n", ")", "*", "0", "\n", "", "return", "{", "\"loss_densepose_UV\"", ":", "loss_uv", "}", "\n", "", "else", ":", "\n", "            ", "return", "super", "(", ")", ".", "produce_fake_densepose_losses_uv", "(", "densepose_predictor_outputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart_with_confidences.DensePoseChartWithConfidenceLoss.produce_densepose_losses_uv": [[72, 123], ["super().produce_densepose_losses_uv", "interpolator.extract_at_points", "interpolator.extract_at_points", "interpolator.extract_at_points", "chart_with_confidences.DensePoseChartWithConfidenceLoss.uv_loss_with_confidences", "interpolator.extract_at_points", "interpolator.extract_at_points", "chart_with_confidences.DensePoseChartWithConfidenceLoss.uv_loss_with_confidences"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.produce_densepose_losses_uv", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils.BilinearInterpolationHelper.extract_at_points", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils.BilinearInterpolationHelper.extract_at_points", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils.BilinearInterpolationHelper.extract_at_points", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils.BilinearInterpolationHelper.extract_at_points", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils.BilinearInterpolationHelper.extract_at_points"], ["", "", "def", "produce_densepose_losses_uv", "(", "\n", "self", ",", "\n", "proposals_with_gt", ":", "List", "[", "Instances", "]", ",", "\n", "densepose_predictor_outputs", ":", "Any", ",", "\n", "tensors_helper", ":", "SingleTensorsHelper", ",", "\n", "interpolator", ":", "BilinearInterpolationHelper", ",", "\n", "j_valid_fg", ":", "torch", ".", "Tensor", ",", "\n", ")", "->", "LossDict", ":", "\n", "        ", "conf_type", "=", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "type", "\n", "if", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "enabled", ":", "\n", "            ", "u_gt", "=", "tensors_helper", ".", "u_gt", "[", "j_valid_fg", "]", "\n", "u_est", "=", "interpolator", ".", "extract_at_points", "(", "\n", "densepose_predictor_outputs", ".", "u", "[", "tensors_helper", ".", "index_with_dp", "]", "\n", ")", "[", "j_valid_fg", "]", "\n", "\n", "v_gt", "=", "tensors_helper", ".", "v_gt", "[", "j_valid_fg", "]", "\n", "v_est", "=", "interpolator", ".", "extract_at_points", "(", "\n", "densepose_predictor_outputs", ".", "v", "[", "tensors_helper", ".", "index_with_dp", "]", "\n", ")", "[", "j_valid_fg", "]", "\n", "sigma_2_est", "=", "interpolator", ".", "extract_at_points", "(", "\n", "densepose_predictor_outputs", ".", "sigma_2", "[", "tensors_helper", ".", "index_with_dp", "]", "\n", ")", "[", "j_valid_fg", "]", "\n", "if", "conf_type", "==", "DensePoseUVConfidenceType", ".", "IID_ISO", ":", "\n", "                ", "return", "{", "\n", "\"loss_densepose_UV\"", ":", "(", "\n", "self", ".", "uv_loss_with_confidences", "(", "u_est", ",", "v_est", ",", "sigma_2_est", ",", "u_gt", ",", "v_gt", ")", "\n", "*", "self", ".", "w_points", "\n", ")", "\n", "}", "\n", "", "elif", "conf_type", "in", "[", "DensePoseUVConfidenceType", ".", "INDEP_ANISO", "]", ":", "\n", "                ", "kappa_u_est", "=", "interpolator", ".", "extract_at_points", "(", "\n", "densepose_predictor_outputs", ".", "kappa_u", "[", "tensors_helper", ".", "index_with_dp", "]", "\n", ")", "[", "j_valid_fg", "]", "\n", "kappa_v_est", "=", "interpolator", ".", "extract_at_points", "(", "\n", "densepose_predictor_outputs", ".", "kappa_v", "[", "tensors_helper", ".", "index_with_dp", "]", "\n", ")", "[", "j_valid_fg", "]", "\n", "return", "{", "\n", "\"loss_densepose_UV\"", ":", "(", "\n", "self", ".", "uv_loss_with_confidences", "(", "\n", "u_est", ",", "v_est", ",", "sigma_2_est", ",", "kappa_u_est", ",", "kappa_v_est", ",", "u_gt", ",", "v_gt", "\n", ")", "\n", "*", "self", ".", "w_points", "\n", ")", "\n", "}", "\n", "", "", "else", ":", "\n", "            ", "return", "super", "(", ")", ".", "produce_densepose_losses_uv", "(", "\n", "proposals_with_gt", ",", "\n", "densepose_predictor_outputs", ",", "\n", "tensors_helper", ",", "\n", "interpolator", ",", "\n", "j_valid_fg", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart_with_confidences.IIDIsotropicGaussianUVLoss.__init__": [[139, 143], ["torch.nn.Module.__init__", "math.log"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "sigma_lower_bound", ":", "float", ")", ":", "\n", "        ", "super", "(", "IIDIsotropicGaussianUVLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "sigma_lower_bound", "=", "sigma_lower_bound", "\n", "self", ".", "log2pi", "=", "math", ".", "log", "(", "2", "*", "math", ".", "pi", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart_with_confidences.IIDIsotropicGaussianUVLoss.forward": [[144, 161], ["loss.sum", "torch.nn.functional.softplus", "torch.log"], "methods", ["None"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "u", ":", "torch", ".", "Tensor", ",", "\n", "v", ":", "torch", ".", "Tensor", ",", "\n", "sigma_u", ":", "torch", ".", "Tensor", ",", "\n", "target_u", ":", "torch", ".", "Tensor", ",", "\n", "target_v", ":", "torch", ".", "Tensor", ",", "\n", ")", ":", "\n", "# compute $\\sigma_i^2$", "\n", "# use sigma_lower_bound to avoid degenerate solution for variance", "\n", "# (sigma -> 0)", "\n", "        ", "sigma2", "=", "F", ".", "softplus", "(", "sigma_u", ")", "+", "self", ".", "sigma_lower_bound", "\n", "# compute \\|delta_i\\|^2", "\n", "delta_t_delta", "=", "(", "u", "-", "target_u", ")", "**", "2", "+", "(", "v", "-", "target_v", ")", "**", "2", "\n", "# the total loss from the formula above:", "\n", "loss", "=", "0.5", "*", "(", "self", ".", "log2pi", "+", "2", "*", "torch", ".", "log", "(", "sigma2", ")", "+", "delta_t_delta", "/", "sigma2", ")", "\n", "return", "loss", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart_with_confidences.IndepAnisotropicGaussianUVLoss.__init__": [[179, 183], ["torch.nn.Module.__init__", "math.log"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "sigma_lower_bound", ":", "float", ")", ":", "\n", "        ", "super", "(", "IndepAnisotropicGaussianUVLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "sigma_lower_bound", "=", "sigma_lower_bound", "\n", "self", ".", "log2pi", "=", "math", ".", "log", "(", "2", "*", "math", ".", "pi", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart_with_confidences.IndepAnisotropicGaussianUVLoss.forward": [[184, 213], ["loss.sum", "torch.nn.functional.softplus", "torch.log"], "methods", ["None"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "u", ":", "torch", ".", "Tensor", ",", "\n", "v", ":", "torch", ".", "Tensor", ",", "\n", "sigma_u", ":", "torch", ".", "Tensor", ",", "\n", "kappa_u_est", ":", "torch", ".", "Tensor", ",", "\n", "kappa_v_est", ":", "torch", ".", "Tensor", ",", "\n", "target_u", ":", "torch", ".", "Tensor", ",", "\n", "target_v", ":", "torch", ".", "Tensor", ",", "\n", ")", ":", "\n", "# compute $\\sigma_i^2$", "\n", "        ", "sigma2", "=", "F", ".", "softplus", "(", "sigma_u", ")", "+", "self", ".", "sigma_lower_bound", "\n", "# compute \\|r_i\\|^2", "\n", "r_sqnorm2", "=", "kappa_u_est", "**", "2", "+", "kappa_v_est", "**", "2", "\n", "delta_u", "=", "u", "-", "target_u", "\n", "delta_v", "=", "v", "-", "target_v", "\n", "# compute \\|delta_i\\|^2", "\n", "delta_sqnorm", "=", "delta_u", "**", "2", "+", "delta_v", "**", "2", "\n", "delta_u_r_u", "=", "delta_u", "*", "kappa_u_est", "\n", "delta_v_r_v", "=", "delta_v", "*", "kappa_v_est", "\n", "# compute the scalar product <delta_i, r_i>", "\n", "delta_r", "=", "delta_u_r_u", "+", "delta_v_r_v", "\n", "# compute squared scalar product <delta_i, r_i>^2", "\n", "delta_r_sqnorm", "=", "delta_r", "**", "2", "\n", "denom2", "=", "sigma2", "*", "(", "sigma2", "+", "r_sqnorm2", ")", "\n", "loss", "=", "0.5", "*", "(", "\n", "self", ".", "log2pi", "+", "torch", ".", "log", "(", "denom2", ")", "+", "delta_sqnorm", "/", "sigma2", "-", "delta_r_sqnorm", "/", "denom2", "\n", ")", "\n", "return", "loss", ".", "sum", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.__init__": [[102, 117], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.__call__": [[118, 151], ["chart.DensePoseChartLoss.produce_densepose_losses", "chart.DensePoseChartLoss.produce_densepose_losses", "chart.DensePoseChartLoss.produce_mask_losses"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.produce_densepose_losses", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.produce_densepose_losses", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.produce_mask_losses"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.produce_fake_mask_losses": [[152, 168], ["densepose_predictor_outputs.coarse_segm.sum"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.produce_mask_losses": [[169, 205], ["len", "chart.DensePoseChartLoss.produce_fake_mask_losses", "torch.no_grad", "chart.extract_data_for_mask_loss_from_matches", "chart.DensePoseChartLoss.produce_fake_mask_losses", "torch.nn.functional.cross_entropy", "extract_data_for_mask_loss_from_matches.masks_gt.long"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.produce_fake_mask_losses", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.extract_data_for_mask_loss_from_matches", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.produce_fake_mask_losses"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.produce_fake_densepose_losses": [[207, 231], ["chart.DensePoseChartLoss.produce_fake_densepose_losses_uv", "chart.DensePoseChartLoss.produce_fake_densepose_losses_segm"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.produce_fake_densepose_losses_uv", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.produce_fake_densepose_losses_segm"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.produce_fake_densepose_losses_uv": [[232, 253], ["densepose_predictor_outputs.u.sum", "densepose_predictor_outputs.v.sum"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.produce_fake_densepose_losses_segm": [[255, 277], ["densepose_predictor_outputs.fine_segm.sum", "densepose_predictor_outputs.coarse_segm.sum"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.produce_densepose_losses": [[278, 340], ["densepose_predictor_outputs.u.size", "utils.SingleTensorsHelper", "len", "utils.BilinearInterpolationHelper.from_matches", "chart.DensePoseChartLoss.produce_densepose_losses_uv", "chart.DensePoseChartLoss.produce_densepose_losses_segm", "len", "chart.DensePoseChartLoss.produce_fake_densepose_losses", "chart.DensePoseChartLoss.produce_fake_densepose_losses"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils.BilinearInterpolationHelper.from_matches", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.produce_densepose_losses_uv", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.produce_densepose_losses_segm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.produce_fake_densepose_losses", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.produce_fake_densepose_losses"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.produce_densepose_losses_uv": [[341, 376], ["interpolator.extract_at_points", "interpolator.extract_at_points", "torch.nn.functional.smooth_l1_loss", "torch.nn.functional.smooth_l1_loss"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils.BilinearInterpolationHelper.extract_at_points", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils.BilinearInterpolationHelper.extract_at_points"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.DensePoseChartLoss.produce_densepose_losses_segm": [[378, 442], ["interpolator.extract_at_points", "torch.nn.functional.cross_entropy", "torch.no_grad", "utils.resample_data().squeeze", "torch.nn.functional.cross_entropy", "slice", "fine_segm_gt.long", "utils.resample_data().squeeze.long", "utils.resample_data", "tensors_helper.coarse_segm_gt.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils.BilinearInterpolationHelper.extract_at_points", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils.resample_data"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.chart.extract_data_for_mask_loss_from_matches": [[27, 73], ["chart.DataForMaskLoss", "sum", "proposals_targets_per_image.proposal_boxes.tensor.size", "proposals_targets_per_image.gt_masks.crop_and_resize().to", "masks_gt.append", "torch.cat", "inst.proposal_boxes.tensor.size", "proposals_targets_per_image.gt_masks.crop_and_resize"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.masks.PolygonMasks.crop_and_resize"], ["\n", "\n", "def", "__init__", "(", "self", ",", "cfg", ":", "CfgNode", ",", "input_channels", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Initialize predictor using configuration options\n\n        Args:\n            cfg (CfgNode): configuration options\n            input_channels (int): input tensor size along the channel dimension\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "dim_in", "=", "input_channels", "\n", "n_segm_chan", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "NUM_COARSE_SEGM_CHANNELS", "\n", "dim_out_patches", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "NUM_PATCHES", "+", "1", "\n", "kernel_size", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "DECONV_KERNEL", "\n", "# coarse segmentation", "\n", "self", ".", "ann_index_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "n_segm_chan", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "# fine segmentation", "\n", "self", ".", "index_uv_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "# U", "\n", "self", ".", "u_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "# V", "\n", "self", ".", "v_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "self", ".", "scale_factor", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "UP_SCALE", "\n", "initialize_module_params", "(", "self", ")", "\n", "\n", "", "def", "interp2d", "(", "self", ",", "tensor_nchw", ":", "torch", ".", "Tensor", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils.SingleTensorsHelper.__init__": [[97, 117], ["locals().items", "torch.no_grad", "utils._extract_single_tensors_from_matches", "locals", "setattr"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils._extract_single_tensors_from_matches"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils.BilinearInterpolationHelper.__init__": [[143, 159], ["locals().items", "locals", "setattr"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils.BilinearInterpolationHelper.from_matches": [[160, 193], ["tensors_helper.bbox_xywh_gt[].unbind", "tensors_helper.bbox_xywh_est[].unbind", "utils._linear_interpolation_utilities", "utils._linear_interpolation_utilities", "utils.BilinearInterpolationHelper"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils._linear_interpolation_utilities", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils._linear_interpolation_utilities"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils.BilinearInterpolationHelper.extract_at_points": [[195, 228], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils._linear_interpolation_utilities": [[12, 56], ["torch.min.floor().long().clamp", "torch.min", "v_hi.float", "v_grid.floor().long().clamp.float", "torch.min.floor().long", "torch.min.floor"], "function", ["None"], ["", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils.resample_data": [[230, 271], ["bbox_xywh_src.size", "bbox_xywh_src.unbind", "bbox_xywh_dst.unbind", "grid_w[].expand", "grid_h[].expand", "[].expand", "[].expand", "x0dst_norm[].expand", "y0dst_norm[].expand", "torch.stack", "torch.nn.functional.grid_sample", "bbox_xywh_dst.size", "bbox_xywh_src.size", "bbox_xywh_dst.size", "torch.arange", "torch.arange"], "function", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils._extract_single_tensors_from_matches_one_image": [[273, 330], ["proposals_targets.proposal_boxes.clone", "proposals_targets.gt_boxes.clone", "len", "len", "hasattr", "zip", "range", "i_gt_all.append", "x_norm_all.append", "y_norm_all.append", "u_gt_all.append", "v_gt_all.append", "s_gt_all.append", "bbox_xywh_gt_all.append", "bbox_xywh_est_all.append", "torch.full_like", "i_bbox_all.append", "i_with_dp.append", "len", "dp_gt.segm.unsqueeze", "box_xywh_gt.view", "box_xywh_est.view", "len"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils._extract_single_tensors_from_matches": [[333, 409], ["enumerate", "proposals_targets_per_image.proposal_boxes.tensor.size", "utils._extract_single_tensors_from_matches_one_image", "i_gt_all.extend", "x_norm_all.extend", "y_norm_all.extend", "u_gt_all.extend", "v_gt_all.extend", "s_gt_all.extend", "bbox_xywh_gt_all.extend", "bbox_xywh_est_all.extend", "i_bbox_all.extend", "i_with_dp_all.extend", "i_img.extend", "torch.cat().long", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat().long", "len", "len", "len", "torch.cat", "torch.cat"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.losses.utils._extract_single_tensors_from_matches_one_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.base.BaseConverter.register": [[14, 35], ["cls._do_register", "cls._do_register"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.base.BaseConverter._do_register", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.base.BaseConverter._do_register"], ["@", "classmethod", "\n", "def", "register", "(", "cls", ",", "from_type", ":", "Type", ",", "converter", ":", "Any", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Registers a converter for the specified type.\n        Can be used as a decorator (if converter is None), or called as a method.\n\n        Args:\n            from_type (type): type to register the converter for;\n                all instances of this type will use the same converter\n            converter (callable): converter to be registered for the given\n                type; if None, this method is assumed to be a decorator for the converter\n        \"\"\"", "\n", "\n", "if", "converter", "is", "not", "None", ":", "\n", "            ", "cls", ".", "_do_register", "(", "from_type", ",", "converter", ")", "\n", "\n", "", "def", "wrapper", "(", "converter", ":", "Any", ")", "->", "Any", ":", "\n", "            ", "cls", ".", "_do_register", "(", "from_type", ",", "converter", ")", "\n", "return", "converter", "\n", "\n", "", "return", "wrapper", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.base.BaseConverter._do_register": [[36, 39], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "_do_register", "(", "cls", ",", "from_type", ":", "Type", ",", "converter", ":", "Any", ")", ":", "\n", "        ", "cls", ".", "registry", "[", "from_type", "]", "=", "converter", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.base.BaseConverter._lookup_converter": [[40, 61], ["cls._lookup_converter", "cls._do_register"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.base.BaseConverter._lookup_converter", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.base.BaseConverter._do_register"], ["", "@", "classmethod", "\n", "def", "_lookup_converter", "(", "cls", ",", "from_type", ":", "Type", ")", "->", "Any", ":", "\n", "        ", "\"\"\"\n        Perform recursive lookup for the given type\n        to find registered converter. If a converter was found for some base\n        class, it gets registered for this class to save on further lookups.\n\n        Args:\n            from_type: type for which to find a converter\n        Return:\n            callable or None - registered converter or None\n                if no suitable entry was found in the registry\n        \"\"\"", "\n", "if", "from_type", "in", "cls", ".", "registry", ":", "\n", "            ", "return", "cls", ".", "registry", "[", "from_type", "]", "\n", "", "for", "base", "in", "from_type", ".", "__bases__", ":", "\n", "            ", "converter", "=", "cls", ".", "_lookup_converter", "(", "base", ")", "\n", "if", "converter", "is", "not", "None", ":", "\n", "                ", "cls", ".", "_do_register", "(", "from_type", ",", "converter", ")", "\n", "return", "converter", "\n", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.base.BaseConverter.convert": [[62, 84], ["type", "cls._lookup_converter", "cls._lookup_converter.", "KeyError"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.base.BaseConverter._lookup_converter"], ["", "@", "classmethod", "\n", "def", "convert", "(", "cls", ",", "instance", ":", "Any", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Convert an instance to the destination type using some registered\n        converter. Does recursive lookup for base classes, so there's no need\n        for explicit registration for derived classes.\n\n        Args:\n            instance: source instance to convert to the destination type\n        Return:\n            An instance of the destination type obtained from the source instance\n            Raises KeyError, if no suitable converter found\n        \"\"\"", "\n", "instance_type", "=", "type", "(", "instance", ")", "\n", "converter", "=", "cls", ".", "_lookup_converter", "(", "instance_type", ")", "\n", "if", "converter", "is", "None", ":", "\n", "            ", "if", "cls", ".", "dst_type", "is", "None", ":", "\n", "                ", "output_type_str", "=", "\"itself\"", "\n", "", "else", ":", "\n", "                ", "output_type_str", "=", "cls", ".", "dst_type", "\n", "", "raise", "KeyError", "(", "f\"Could not find converter from {instance_type} to {output_type_str}\"", ")", "\n", "", "return", "converter", "(", "instance", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.hflip.HFlipConverter.convert": [[17, 32], ["super().convert"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["@", "classmethod", "\n", "def", "convert", "(", "cls", ",", "predictor_outputs", ":", "Any", ",", "transform_data", ":", "Any", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Performs an horizontal flip on DensePose predictor outputs.\n        Does recursive lookup for base classes, so there's no need\n        for explicit registration for derived classes.\n\n        Args:\n            predictor_outputs: DensePose predictor output to be converted to BitMasks\n            transform_data: Anything useful for the flip\n        Return:\n            An instance of the same type as predictor_outputs\n        \"\"\"", "\n", "return", "super", "(", "HFlipConverter", ",", "cls", ")", ".", "convert", "(", "\n", "predictor_outputs", ",", "transform_data", ",", "*", "args", ",", "**", "kwargs", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.chart_output_hflip.densepose_chart_predictor_output_hflip": [[9, 38], ["len", "type", "dataclasses.fields", "chart_output_hflip._flip_iuv_semantics_tensor", "chart_output_hflip._flip_segm_semantics_tensor", "dataclasses.fields", "type.", "getattr", "isinstance", "getattr", "setattr", "torch.flip"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.chart_output_hflip._flip_iuv_semantics_tensor", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.chart_output_hflip._flip_segm_semantics_tensor"], ["def", "densepose_chart_predictor_output_hflip", "(", "\n", "densepose_predictor_output", ":", "DensePoseChartPredictorOutput", ",", "\n", "transform_data", ":", "DensePoseTransformData", ",", "\n", ")", "->", "DensePoseChartPredictorOutput", ":", "\n", "    ", "\"\"\"\n    Change  to take into account a Horizontal flip.\n    \"\"\"", "\n", "if", "len", "(", "densepose_predictor_output", ")", ">", "0", ":", "\n", "\n", "        ", "PredictorOutput", "=", "type", "(", "densepose_predictor_output", ")", "\n", "output_dict", "=", "{", "}", "\n", "\n", "for", "field", "in", "fields", "(", "densepose_predictor_output", ")", ":", "\n", "            ", "field_value", "=", "getattr", "(", "densepose_predictor_output", ",", "field", ".", "name", ")", "\n", "# flip tensors", "\n", "if", "isinstance", "(", "field_value", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "setattr", "(", "densepose_predictor_output", ",", "field", ".", "name", ",", "torch", ".", "flip", "(", "field_value", ",", "[", "3", "]", ")", ")", "\n", "\n", "", "", "densepose_predictor_output", "=", "_flip_iuv_semantics_tensor", "(", "\n", "densepose_predictor_output", ",", "transform_data", "\n", ")", "\n", "densepose_predictor_output", "=", "_flip_segm_semantics_tensor", "(", "\n", "densepose_predictor_output", ",", "transform_data", "\n", ")", "\n", "\n", "for", "field", "in", "fields", "(", "densepose_predictor_output", ")", ":", "\n", "            ", "output_dict", "[", "field", ".", "name", "]", "=", "getattr", "(", "densepose_predictor_output", ",", "field", ".", "name", ")", "\n", "\n", "", "return", "PredictorOutput", "(", "**", "output_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.chart_output_hflip._flip_iuv_semantics_tensor": [[40, 61], ["[].expand", "densepose_predictor_output.u[].clamp", "densepose_predictor_output.v[].clamp", "torch.arange"], "function", ["None"], ["", "", "def", "_flip_iuv_semantics_tensor", "(", "\n", "densepose_predictor_output", ":", "DensePoseChartPredictorOutput", ",", "\n", "dp_transform_data", ":", "DensePoseTransformData", ",", "\n", ")", "->", "None", ":", "\n", "    ", "point_label_symmetries", "=", "dp_transform_data", ".", "point_label_symmetries", "\n", "uv_symmetries", "=", "dp_transform_data", ".", "uv_symmetries", "\n", "\n", "N", ",", "C", ",", "H", ",", "W", "=", "densepose_predictor_output", ".", "u", ".", "shape", "\n", "u_loc", "=", "(", "densepose_predictor_output", ".", "u", "[", ":", ",", "1", ":", ",", ":", ",", ":", "]", ".", "clamp", "(", "0", ",", "1", ")", "*", "255", ")", ".", "long", "(", ")", "\n", "v_loc", "=", "(", "densepose_predictor_output", ".", "v", "[", ":", ",", "1", ":", ",", ":", ",", ":", "]", ".", "clamp", "(", "0", ",", "1", ")", "*", "255", ")", ".", "long", "(", ")", "\n", "Iindex", "=", "torch", ".", "arange", "(", "C", "-", "1", ",", "device", "=", "densepose_predictor_output", ".", "u", ".", "device", ")", "[", "\n", "None", ",", ":", ",", "None", ",", "None", "\n", "]", ".", "expand", "(", "N", ",", "C", "-", "1", ",", "H", ",", "W", ")", "\n", "densepose_predictor_output", ".", "u", "[", ":", ",", "1", ":", ",", ":", ",", ":", "]", "=", "uv_symmetries", "[", "\"U_transforms\"", "]", "[", "Iindex", ",", "v_loc", ",", "u_loc", "]", "\n", "densepose_predictor_output", ".", "v", "[", ":", ",", "1", ":", ",", ":", ",", ":", "]", "=", "uv_symmetries", "[", "\"V_transforms\"", "]", "[", "Iindex", ",", "v_loc", ",", "u_loc", "]", "\n", "\n", "for", "el", "in", "[", "\"fine_segm\"", ",", "\"u\"", ",", "\"v\"", "]", ":", "\n", "        ", "densepose_predictor_output", ".", "__dict__", "[", "el", "]", "=", "densepose_predictor_output", ".", "__dict__", "[", "el", "]", "[", "\n", ":", ",", "point_label_symmetries", ",", ":", ",", ":", "\n", "]", "\n", "", "return", "densepose_predictor_output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.chart_output_hflip._flip_segm_semantics_tensor": [[63, 71], ["None"], "function", ["None"], ["", "def", "_flip_segm_semantics_tensor", "(", "\n", "densepose_predictor_output", ":", "DensePoseChartPredictorOutput", ",", "dp_transform_data", "\n", ")", ":", "\n", "    ", "if", "densepose_predictor_output", ".", "coarse_segm", ".", "shape", "[", "1", "]", ">", "2", ":", "\n", "        ", "densepose_predictor_output", ".", "coarse_segm", "=", "densepose_predictor_output", ".", "coarse_segm", "[", "\n", ":", ",", "dp_transform_data", ".", "mask_label_symmetries", ",", ":", ",", ":", "\n", "]", "\n", "", "return", "densepose_predictor_output", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.to_chart_result.ToChartResultConverter.convert": [[20, 36], ["super().convert"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["@", "classmethod", "\n", "def", "convert", "(", "cls", ",", "predictor_outputs", ":", "Any", ",", "boxes", ":", "Boxes", ",", "*", "args", ",", "**", "kwargs", ")", "->", "DensePoseChartResult", ":", "\n", "        ", "\"\"\"\n        Convert DensePose predictor outputs to DensePoseResult using some registered\n        converter. Does recursive lookup for base classes, so there's no need\n        for explicit registration for derived classes.\n\n        Args:\n            densepose_predictor_outputs: DensePose predictor output to be\n                converted to BitMasks\n            boxes (Boxes): bounding boxes that correspond to the DensePose\n                predictor outputs\n        Return:\n            An instance of DensePoseResult. If no suitable converter was found, raises KeyError\n        \"\"\"", "\n", "return", "super", "(", "ToChartResultConverter", ",", "cls", ")", ".", "convert", "(", "predictor_outputs", ",", "boxes", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.to_mask.ToMaskConverter.convert": [[22, 47], ["super().convert"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["@", "classmethod", "\n", "def", "convert", "(", "\n", "cls", ",", "\n", "densepose_predictor_outputs", ":", "Any", ",", "\n", "boxes", ":", "Boxes", ",", "\n", "image_size_hw", ":", "ImageSizeType", ",", "\n", "*", "args", ",", "\n", "**", "kwargs", "\n", ")", "->", "BitMasks", ":", "\n", "        ", "\"\"\"\n        Convert DensePose predictor outputs to BitMasks using some registered\n        converter. Does recursive lookup for base classes, so there's no need\n        for explicit registration for derived classes.\n\n        Args:\n            densepose_predictor_outputs: DensePose predictor output to be\n                converted to BitMasks\n            boxes (Boxes): bounding boxes that correspond to the DensePose\n                predictor outputs\n            image_size_hw (tuple [int, int]): image height and width\n        Return:\n            An instance of `BitMasks`. If no suitable converter was found, raises KeyError\n        \"\"\"", "\n", "return", "super", "(", "ToMaskConverter", ",", "cls", ")", ".", "convert", "(", "\n", "densepose_predictor_outputs", ",", "boxes", ",", "image_size_hw", ",", "*", "args", ",", "**", "kwargs", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.segm_to_mask.resample_fine_and_coarse_segm_to_bbox": [[12, 42], ["max", "max", "torch.nn.functional.interpolate().argmax", "int", "int", "torch.nn.functional.interpolate().argmax", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate"], "function", ["None"], ["def", "resample_fine_and_coarse_segm_to_bbox", "(", "\n", "predictor_output", ":", "Any", ",", "box_xywh_abs", ":", "Tuple", "[", "int", ",", "int", ",", "int", ",", "int", "]", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Resample fine and coarse segmentation outputs from a predictor to the given\n    bounding box and derive labels for each pixel of the bounding box\n\n    Args:\n        predictor_output: DensePose predictor output that contains segmentation\n            results to be resampled\n        box_xywh_abs (tuple of 4 int): bounding box given by its upper-left\n            corner coordinates, width (W) and height (H)\n    Return:\n        Labels for each pixel of the bounding box, a uint8 tensor of size [1, H, W]\n    \"\"\"", "\n", "x", ",", "y", ",", "w", ",", "h", "=", "box_xywh_abs", "\n", "w", "=", "max", "(", "int", "(", "w", ")", ",", "1", ")", "\n", "h", "=", "max", "(", "int", "(", "h", ")", ",", "1", ")", "\n", "# coarse segmentation", "\n", "coarse_segm_bbox", "=", "F", ".", "interpolate", "(", "\n", "predictor_output", ".", "coarse_segm", ",", "(", "h", ",", "w", ")", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", ".", "argmax", "(", "dim", "=", "1", ")", "\n", "# combined coarse and fine segmentation", "\n", "labels", "=", "(", "\n", "F", ".", "interpolate", "(", "\n", "predictor_output", ".", "fine_segm", ",", "(", "h", ",", "w", ")", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", ".", "argmax", "(", "dim", "=", "1", ")", "\n", "*", "(", "coarse_segm_bbox", ">", "0", ")", ".", "long", "(", ")", "\n", ")", "\n", "return", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.segm_to_mask.predictor_output_with_fine_and_coarse_segm_to_mask": [[44, 76], ["boxes.tensor.clone", "detectron2.structures.BoxMode.convert", "len", "torch.zeros", "enumerate", "detectron2.structures.BitMasks", "segm_to_mask.resample_fine_and_coarse_segm_to_bbox", "box_xywh.long().tolist", "box_xywh.long"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.segm_to_mask.resample_fine_and_coarse_segm_to_bbox"], ["", "def", "predictor_output_with_fine_and_coarse_segm_to_mask", "(", "\n", "predictor_output", ":", "Any", ",", "boxes", ":", "Boxes", ",", "image_size_hw", ":", "ImageSizeType", "\n", ")", "->", "BitMasks", ":", "\n", "    ", "\"\"\"\n    Convert predictor output with coarse and fine segmentation to a mask.\n    Assumes that predictor output has the following attributes:\n     - coarse_segm (tensor of size [N, D, H, W]): coarse segmentation\n         unnormalized scores for N instances; D is the number of coarse\n         segmentation labels, H and W is the resolution of the estimate\n     - fine_segm (tensor of size [N, C, H, W]): fine segmentation\n         unnormalized scores for N instances; C is the number of fine\n         segmentation labels, H and W is the resolution of the estimate\n\n    Args:\n        predictor_output: DensePose predictor output to be converted to mask\n        boxes (Boxes): bounding boxes that correspond to the DensePose\n            predictor outputs\n        image_size_hw (tuple [int, int]): image height Himg and width Wimg\n    Return:\n        BitMasks that contain a bool tensor of size [N, Himg, Wimg] with\n        a mask of the size of the image for each instance\n    \"\"\"", "\n", "H", ",", "W", "=", "image_size_hw", "\n", "boxes_xyxy_abs", "=", "boxes", ".", "tensor", ".", "clone", "(", ")", "\n", "boxes_xywh_abs", "=", "BoxMode", ".", "convert", "(", "boxes_xyxy_abs", ",", "BoxMode", ".", "XYXY_ABS", ",", "BoxMode", ".", "XYWH_ABS", ")", "\n", "N", "=", "len", "(", "boxes_xywh_abs", ")", "\n", "masks", "=", "torch", ".", "zeros", "(", "(", "N", ",", "H", ",", "W", ")", ",", "dtype", "=", "torch", ".", "bool", ",", "device", "=", "boxes", ".", "tensor", ".", "device", ")", "\n", "for", "i", ",", "box_xywh", "in", "enumerate", "(", "boxes_xywh_abs", ")", ":", "\n", "        ", "labels_i", "=", "resample_fine_and_coarse_segm_to_bbox", "(", "predictor_output", "[", "i", "]", ",", "box_xywh", ")", "\n", "x", ",", "y", ",", "w", ",", "h", "=", "box_xywh", ".", "long", "(", ")", ".", "tolist", "(", ")", "\n", "masks", "[", "i", ",", "y", ":", "y", "+", "h", ",", "x", ":", "x", "+", "w", "]", "=", "labels_i", ">", "0", "\n", "", "return", "BitMasks", "(", "masks", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.chart_output_to_chart_result.resample_uv_to_bbox": [[13, 40], ["max", "max", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.zeros", "range", "int", "int", "F.interpolate.size"], "function", ["None"], ["def", "resample_uv_to_bbox", "(", "\n", "predictor_output", ":", "DensePoseChartPredictorOutput", ",", "\n", "labels", ":", "torch", ".", "Tensor", ",", "\n", "box_xywh_abs", ":", "Tuple", "[", "int", ",", "int", ",", "int", ",", "int", "]", ",", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Resamples U and V coordinate estimates for the given bounding box\n\n    Args:\n        predictor_output (DensePoseChartPredictorOutput): DensePose predictor\n            output to be resampled\n        labels (tensor [H, W] of uint8): labels obtained by resampling segmentation\n            outputs for the given bounding box\n        box_xywh_abs (tuple of 4 int): bounding box that corresponds to predictor outputs\n    Return:\n       Resampled U and V coordinates - a tensor [2, H, W] of float\n    \"\"\"", "\n", "x", ",", "y", ",", "w", ",", "h", "=", "box_xywh_abs", "\n", "w", "=", "max", "(", "int", "(", "w", ")", ",", "1", ")", "\n", "h", "=", "max", "(", "int", "(", "h", ")", ",", "1", ")", "\n", "u_bbox", "=", "F", ".", "interpolate", "(", "predictor_output", ".", "u", ",", "(", "h", ",", "w", ")", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", "\n", "v_bbox", "=", "F", ".", "interpolate", "(", "predictor_output", ".", "v", ",", "(", "h", ",", "w", ")", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", "\n", "uv", "=", "torch", ".", "zeros", "(", "[", "2", ",", "h", ",", "w", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "predictor_output", ".", "u", ".", "device", ")", "\n", "for", "part_id", "in", "range", "(", "1", ",", "u_bbox", ".", "size", "(", "1", ")", ")", ":", "\n", "        ", "uv", "[", "0", "]", "[", "labels", "==", "part_id", "]", "=", "u_bbox", "[", "0", ",", "part_id", "]", "[", "labels", "==", "part_id", "]", "\n", "uv", "[", "1", "]", "[", "labels", "==", "part_id", "]", "=", "v_bbox", "[", "0", ",", "part_id", "]", "[", "labels", "==", "part_id", "]", "\n", "", "return", "uv", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.chart_output_to_chart_result.densepose_chart_predictor_output_to_result": [[42, 68], ["boxes.tensor.clone", "detectron2.structures.BoxMode.convert", "tuple", "resample_fine_and_coarse_segm_to_bbox().squeeze", "chart_output_to_chart_result.resample_uv_to_bbox", "structures.DensePoseChartResult", "boxes_xywh_abs[].long().tolist", "len", "len", "len", "len", "resample_fine_and_coarse_segm_to_bbox", "boxes_xywh_abs[].long"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.chart_output_to_chart_result.resample_uv_to_bbox", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.segm_to_mask.resample_fine_and_coarse_segm_to_bbox"], ["", "def", "densepose_chart_predictor_output_to_result", "(", "\n", "predictor_output", ":", "DensePoseChartPredictorOutput", ",", "boxes", ":", "Boxes", "\n", ")", "->", "DensePoseChartResult", ":", "\n", "    ", "\"\"\"\n    Convert densepose chart predictor outputs to results\n\n    Args:\n        predictor_output (DensePoseChartPredictorOutput): DensePose predictor\n            output to be converted to results, must contain only 1 output\n        boxes (Boxes): bounding box that corresponds to the predictor output,\n            must contain only 1 bounding box\n    Return:\n       DensePose chart-based result (DensePoseChartResult)\n    \"\"\"", "\n", "assert", "len", "(", "predictor_output", ")", "==", "1", "and", "len", "(", "boxes", ")", "==", "1", ",", "(", "\n", "f\"Predictor output to result conversion can operate only single outputs\"", "\n", "f\", got {len(predictor_output)} predictor outputs and {len(boxes)} boxes\"", "\n", ")", "\n", "\n", "boxes_xyxy_abs", "=", "boxes", ".", "tensor", ".", "clone", "(", ")", "\n", "boxes_xywh_abs", "=", "BoxMode", ".", "convert", "(", "boxes_xyxy_abs", ",", "BoxMode", ".", "XYXY_ABS", ",", "BoxMode", ".", "XYWH_ABS", ")", "\n", "box_xywh", "=", "tuple", "(", "boxes_xywh_abs", "[", "0", "]", ".", "long", "(", ")", ".", "tolist", "(", ")", ")", "\n", "\n", "labels", "=", "resample_fine_and_coarse_segm_to_bbox", "(", "predictor_output", ",", "box_xywh", ")", ".", "squeeze", "(", "0", ")", "\n", "uv", "=", "resample_uv_to_bbox", "(", "predictor_output", ",", "labels", ",", "box_xywh", ")", "\n", "return", "DensePoseChartResult", "(", "labels", "=", "labels", ",", "uv", "=", "uv", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.base.MatrixVisualizer.__init__": [[16, 31], ["None"], "methods", ["None"], ["        ", "\"\"\"\n        Registers a converter for the specified type.\n        Can be used as a decorator (if converter is None), or called as a method.\n\n        Args:\n            from_type (type): type to register the converter for;\n                all instances of this type will use the same converter\n            converter (callable): converter to be registered for the given\n                type; if None, this method is assumed to be a decorator for the converter\n        \"\"\"", "\n", "\n", "if", "converter", "is", "not", "None", ":", "\n", "            ", "cls", ".", "_do_register", "(", "from_type", ",", "converter", ")", "\n", "\n", "", "def", "wrapper", "(", "converter", ":", "Any", ")", "->", "Any", ":", "\n", "            ", "cls", ".", "_do_register", "(", "from_type", ",", "converter", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.base.MatrixVisualizer.visualize": [[32, 58], ["base.MatrixVisualizer._check_image", "base.MatrixVisualizer._check_mask_matrix", "base.MatrixVisualizer._resize", "numpy.tile", "numpy.any", "matrix_scaled.clip().astype", "cv2.applyColorMap", "image_target_bgr.astype", "int", "matrix.astype", "logging.getLogger", "logging.getLogger.warning", "matrix_scaled.clip"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.base.MatrixVisualizer._check_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.base.MatrixVisualizer._check_mask_matrix", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.base.MatrixVisualizer._resize", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clip"], ["return", "converter", "\n", "\n", "", "return", "wrapper", "\n", "\n", "", "@", "classmethod", "\n", "def", "_do_register", "(", "cls", ",", "from_type", ":", "Type", ",", "converter", ":", "Any", ")", ":", "\n", "        ", "cls", ".", "registry", "[", "from_type", "]", "=", "converter", "\n", "\n", "", "@", "classmethod", "\n", "def", "_lookup_converter", "(", "cls", ",", "from_type", ":", "Type", ")", "->", "Any", ":", "\n", "        ", "\"\"\"\n        Perform recursive lookup for the given type\n        to find registered converter. If a converter was found for some base\n        class, it gets registered for this class to save on further lookups.\n\n        Args:\n            from_type: type for which to find a converter\n        Return:\n            callable or None - registered converter or None\n                if no suitable entry was found in the registry\n        \"\"\"", "\n", "if", "from_type", "in", "cls", ".", "registry", ":", "\n", "            ", "return", "cls", ".", "registry", "[", "from_type", "]", "\n", "", "for", "base", "in", "from_type", ".", "__bases__", ":", "\n", "            ", "converter", "=", "cls", ".", "_lookup_converter", "(", "base", ")", "\n", "if", "converter", "is", "not", "None", ":", "\n", "                ", "cls", ".", "_do_register", "(", "from_type", ",", "converter", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.base.MatrixVisualizer._resize": [[59, 65], ["cv2.resize", "cv2.resize"], "methods", ["None"], ["return", "converter", "\n", "", "", "return", "None", "\n", "\n", "", "@", "classmethod", "\n", "def", "convert", "(", "cls", ",", "instance", ":", "Any", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.base.MatrixVisualizer._check_image": [[66, 70], ["len"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.base.MatrixVisualizer._check_mask_matrix": [[71, 75], ["len", "len"], "methods", ["None"], ["\n", "instance_type", "=", "type", "(", "instance", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.base.RectangleVisualizer.__init__": [[81, 84], ["None"], "methods", ["None"], ["                ", "output_type_str", "=", "cls", ".", "dst_type", "\n", "", "raise", "KeyError", "(", "f\"Could not find converter from {instance_type} to {output_type_str}\"", ")", "\n", "", "return", "converter", "(", "instance", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.base.RectangleVisualizer.visualize": [[85, 91], ["cv2.rectangle", "int", "int", "int", "int"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.base.PointsVisualizer.__init__": [[97, 100], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.base.PointsVisualizer.visualize": [[101, 108], ["enumerate", "cv2.circle"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.base.TextVisualizer.__init__": [[115, 138], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.base.TextVisualizer.visualize": [[139, 166], ["base.TextVisualizer.get_text_size_wh", "tuple", "cv2.putText", "map", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.base.TextVisualizer.get_text_size_wh"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.base.TextVisualizer.get_text_size_wh": [[167, 172], ["cv2.getTextSize"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.base.CompoundVisualizer.__init__": [[175, 177], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.base.CompoundVisualizer.visualize": [[178, 188], ["enumerate", "len", "len", "len", "len", "visualizer.visualize"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_data_points.DensePoseDataPointsVisualizer.visualize"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.base.CompoundVisualizer.__str__": [[189, 192], ["str"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.extractor.BoundingBoxExtractor.__call__": [[57, 60], ["extractor.extract_boxes_xywh_from_instances"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.extractor.extract_boxes_xywh_from_instances"], ["def", "__call__", "(", "self", ",", "instances", ":", "Instances", ")", ":", "\n", "        ", "boxes_xywh", "=", "extract_boxes_xywh_from_instances", "(", "instances", ")", "\n", "return", "boxes_xywh", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.extractor.ScoredBoundingBoxExtractor.__call__": [[67, 76], ["extractor.extract_scores_from_instances", "extractor.extract_boxes_xywh_from_instances"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.extractor.extract_scores_from_instances", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.extractor.extract_boxes_xywh_from_instances"], ["def", "__call__", "(", "self", ",", "instances", ":", "Instances", ",", "select", "=", "None", ")", ":", "\n", "        ", "scores", "=", "extract_scores_from_instances", "(", "instances", ")", "\n", "boxes_xywh", "=", "extract_boxes_xywh_from_instances", "(", "instances", ")", "\n", "if", "(", "scores", "is", "None", ")", "or", "(", "boxes_xywh", "is", "None", ")", ":", "\n", "            ", "return", "(", "boxes_xywh", ",", "scores", ")", "\n", "", "if", "select", "is", "not", "None", ":", "\n", "            ", "scores", "=", "scores", "[", "select", "]", "\n", "boxes_xywh", "=", "boxes_xywh", "[", "select", "]", "\n", "", "return", "(", "boxes_xywh", ",", "scores", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.extractor.DensePoseResultExtractor.__call__": [[83, 96], ["instances.has", "instances.has", "extractor.extract_boxes_xywh_from_instances", "densepose.converters.ToChartResultConverter", "densepose.converters.ToChartResultConverter.convert", "range", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.extractor.extract_boxes_xywh_from_instances", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["def", "__call__", "(", "self", ",", "instances", ":", "Instances", ",", "select", "=", "None", ")", ":", "\n", "        ", "if", "instances", ".", "has", "(", "\"pred_densepose\"", ")", "and", "instances", ".", "has", "(", "\"pred_boxes\"", ")", ":", "\n", "            ", "dpout", "=", "instances", ".", "pred_densepose", "\n", "boxes_xyxy", "=", "instances", ".", "pred_boxes", "\n", "boxes_xywh", "=", "extract_boxes_xywh_from_instances", "(", "instances", ")", "\n", "if", "select", "is", "not", "None", ":", "\n", "                ", "dpout", "=", "dpout", "[", "select", "]", "\n", "boxes_xyxy", "=", "boxes_xyxy", "[", "select", "]", "\n", "", "converter", "=", "ToChartResultConverter", "(", ")", "\n", "results", "=", "[", "converter", ".", "convert", "(", "dpout", "[", "i", "]", ",", "boxes_xyxy", "[", "[", "i", "]", "]", ")", "for", "i", "in", "range", "(", "len", "(", "dpout", ")", ")", "]", "\n", "return", "results", ",", "boxes_xywh", "\n", "", "else", ":", "\n", "            ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.extractor.CompoundExtractor.__init__": [[103, 105], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "extractors", ")", ":", "\n", "        ", "self", ".", "extractors", "=", "extractors", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.extractor.CompoundExtractor.__call__": [[106, 112], ["extractor", "datas.append"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "instances", ":", "Instances", ",", "select", "=", "None", ")", ":", "\n", "        ", "datas", "=", "[", "]", "\n", "for", "extractor", "in", "self", ".", "extractors", ":", "\n", "            ", "data", "=", "extractor", "(", "instances", ",", "select", ")", "\n", "datas", ".", "append", "(", "data", ")", "\n", "", "return", "datas", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.extractor.NmsFilteredExtractor.__init__": [[119, 122], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "extractor", ",", "iou_threshold", ")", ":", "\n", "        ", "self", ".", "extractor", "=", "extractor", "\n", "self", ".", "iou_threshold", "=", "iou_threshold", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.extractor.NmsFilteredExtractor.__call__": [[123, 138], ["extractor.extract_scores_from_instances", "extractor.extract_boxes_xywh_from_instances", "detectron2.layers.nms.batched_nms().squeeze", "torch.zeros", "extractor.NmsFilteredExtractor.extractor", "len", "detectron2.layers.nms.batched_nms", "torch.zeros", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.extractor.extract_scores_from_instances", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.extractor.extract_boxes_xywh_from_instances", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.batched_nms"], ["", "def", "__call__", "(", "self", ",", "instances", ":", "Instances", ",", "select", "=", "None", ")", ":", "\n", "        ", "scores", "=", "extract_scores_from_instances", "(", "instances", ")", "\n", "boxes_xywh", "=", "extract_boxes_xywh_from_instances", "(", "instances", ")", "\n", "if", "boxes_xywh", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "select_local_idx", "=", "batched_nms", "(", "\n", "boxes_xywh", ",", "\n", "scores", ",", "\n", "torch", ".", "zeros", "(", "len", "(", "scores", ")", ",", "dtype", "=", "torch", ".", "int32", ")", ",", "\n", "iou_threshold", "=", "self", ".", "iou_threshold", ",", "\n", ")", ".", "squeeze", "(", ")", "\n", "select_local", "=", "torch", ".", "zeros", "(", "len", "(", "boxes_xywh", ")", ",", "dtype", "=", "torch", ".", "bool", ",", "device", "=", "boxes_xywh", ".", "device", ")", "\n", "select_local", "[", "select_local_idx", "]", "=", "True", "\n", "select", "=", "select_local", "if", "select", "is", "None", "else", "(", "select", "&", "select_local", ")", "\n", "return", "self", ".", "extractor", "(", "instances", ",", "select", "=", "select", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.extractor.ScoreThresholdedExtractor.__init__": [[145, 148], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "extractor", ",", "min_score", ")", ":", "\n", "        ", "self", ".", "extractor", "=", "extractor", "\n", "self", ".", "min_score", "=", "min_score", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.extractor.ScoreThresholdedExtractor.__call__": [[149, 157], ["extractor.extract_scores_from_instances", "extractor.ScoreThresholdedExtractor.extractor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.extractor.extract_scores_from_instances"], ["", "def", "__call__", "(", "self", ",", "instances", ":", "Instances", ",", "select", "=", "None", ")", ":", "\n", "        ", "scores", "=", "extract_scores_from_instances", "(", "instances", ")", "\n", "if", "scores", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "select_local", "=", "scores", ">", "self", ".", "min_score", "\n", "select", "=", "select_local", "if", "select", "is", "None", "else", "(", "select", "&", "select_local", ")", "\n", "data", "=", "self", ".", "extractor", "(", "instances", ",", "select", "=", "select", ")", "\n", "return", "data", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.extractor.extract_scores_from_instances": [[18, 22], ["instances.has"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has"], ["def", "extract_scores_from_instances", "(", "instances", ":", "Instances", ",", "select", "=", "None", ")", ":", "\n", "    ", "if", "instances", ".", "has", "(", "\"scores\"", ")", ":", "\n", "        ", "return", "instances", ".", "scores", "if", "select", "is", "None", "else", "instances", ".", "scores", "[", "select", "]", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.extractor.extract_boxes_xywh_from_instances": [[24, 31], ["instances.has", "instances.pred_boxes.tensor.clone"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone"], ["", "def", "extract_boxes_xywh_from_instances", "(", "instances", ":", "Instances", ",", "select", "=", "None", ")", ":", "\n", "    ", "if", "instances", ".", "has", "(", "\"pred_boxes\"", ")", ":", "\n", "        ", "boxes_xywh", "=", "instances", ".", "pred_boxes", ".", "tensor", ".", "clone", "(", ")", "\n", "boxes_xywh", "[", ":", ",", "2", "]", "-=", "boxes_xywh", "[", ":", ",", "0", "]", "\n", "boxes_xywh", "[", ":", ",", "3", "]", "-=", "boxes_xywh", "[", ":", ",", "1", "]", "\n", "return", "boxes_xywh", "if", "select", "is", "None", "else", "boxes_xywh", "[", "select", "]", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.extractor.create_extractor": [[33, 50], ["isinstance", "extractor.CompoundExtractor", "isinstance", "extractor.create_extractor", "extractor.DensePoseResultExtractor", "isinstance", "extractor.CompoundExtractor", "isinstance", "logging.getLogger", "logging.getLogger.error"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.extractor.create_extractor"], ["", "def", "create_extractor", "(", "visualizer", ":", "object", ")", ":", "\n", "    ", "\"\"\"\n    Create an extractor for the provided visualizer\n    \"\"\"", "\n", "if", "isinstance", "(", "visualizer", ",", "CompoundVisualizer", ")", ":", "\n", "        ", "extractors", "=", "[", "create_extractor", "(", "v", ")", "for", "v", "in", "visualizer", ".", "visualizers", "]", "\n", "return", "CompoundExtractor", "(", "extractors", ")", "\n", "", "elif", "isinstance", "(", "visualizer", ",", "DensePoseResultsVisualizer", ")", ":", "\n", "        ", "return", "DensePoseResultExtractor", "(", ")", "\n", "", "elif", "isinstance", "(", "visualizer", ",", "ScoredBoundingBoxVisualizer", ")", ":", "\n", "        ", "return", "CompoundExtractor", "(", "[", "extract_boxes_xywh_from_instances", ",", "extract_scores_from_instances", "]", ")", "\n", "", "elif", "isinstance", "(", "visualizer", ",", "BoundingBoxVisualizer", ")", ":", "\n", "        ", "return", "extract_boxes_xywh_from_instances", "\n", "", "else", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "error", "(", "f\"Could not create extractor for {visualizer}\"", ")", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_outputs.DensePoseOutputsVisualizer.__init__": [[11, 21], ["base.MatrixVisualizer"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "inplace", "=", "True", ",", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", ",", "alpha", "=", "0.7", ",", "to_visualize", "=", "None", ")", ":", "\n", "        ", "assert", "to_visualize", "in", "\"IUV\"", ",", "\"can only visualize IUV\"", "\n", "self", ".", "to_visualize", "=", "to_visualize", "\n", "\n", "if", "self", ".", "to_visualize", "==", "\"I\"", ":", "\n", "            ", "val_scale", "=", "255.0", "/", "DensePoseDataRelative", ".", "N_PART_LABELS", "\n", "", "else", ":", "\n", "            ", "val_scale", "=", "1.0", "\n", "", "self", ".", "mask_visualizer", "=", "MatrixVisualizer", "(", "\n", "inplace", "=", "inplace", ",", "cmap", "=", "cmap", ",", "val_scale", "=", "val_scale", ",", "alpha", "=", "alpha", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_outputs.DensePoseOutputsVisualizer.visualize": [[23, 80], ["isinstance", "S.size", "range", "type", "I.size", "S.size", "I.size", "U.size", "S.size", "U.size", "V.size", "S.size", "V.size", "len", "len", "S[].argmax", "In.cpu().numpy().astype", "numpy.zeros", "densepose_outputs.DensePoseOutputsVisualizer.mask_visualizer.visualize", "I[].argmax", "In.cpu().numpy", "[].cpu().numpy().astype", "numpy.zeros", "range", "In.cpu", "[].cpu().numpy", "[].clip", "[].cpu"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_data_points.DensePoseDataPointsVisualizer.visualize", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clip"], ["", "def", "visualize", "(", "\n", "self", ",", "image_bgr", ":", "Image", ",", "dp_output_with_bboxes", ":", "Optional", "[", "Tuple", "[", "DensePoseOutput", ",", "Boxes", "]", "]", "\n", ")", "->", "Image", ":", "\n", "        ", "if", "dp_output_with_bboxes", "is", "None", ":", "\n", "            ", "return", "image_bgr", "\n", "", "densepose_output", ",", "bboxes_xywh", "=", "dp_output_with_bboxes", "\n", "\n", "assert", "isinstance", "(", "\n", "densepose_output", ",", "DensePoseOutput", "\n", ")", ",", "\"DensePoseOutput expected, {} encountered\"", ".", "format", "(", "type", "(", "densepose_output", ")", ")", "\n", "\n", "S", "=", "densepose_output", ".", "S", "\n", "I", "=", "densepose_output", ".", "I", "# noqa", "\n", "U", "=", "densepose_output", ".", "U", "\n", "V", "=", "densepose_output", ".", "V", "\n", "N", "=", "S", ".", "size", "(", "0", ")", "\n", "assert", "N", "==", "I", ".", "size", "(", "\n", "0", "\n", ")", ",", "\"densepose outputs S {} and I {}\"", "\" should have equal first dim size\"", ".", "format", "(", "\n", "S", ".", "size", "(", ")", ",", "I", ".", "size", "(", ")", "\n", ")", "\n", "assert", "N", "==", "U", ".", "size", "(", "\n", "0", "\n", ")", ",", "\"densepose outputs S {} and U {}\"", "\" should have equal first dim size\"", ".", "format", "(", "\n", "S", ".", "size", "(", ")", ",", "U", ".", "size", "(", ")", "\n", ")", "\n", "assert", "N", "==", "V", ".", "size", "(", "\n", "0", "\n", ")", ",", "\"densepose outputs S {} and V {}\"", "\" should have equal first dim size\"", ".", "format", "(", "\n", "S", ".", "size", "(", ")", ",", "V", ".", "size", "(", ")", "\n", ")", "\n", "assert", "N", "==", "len", "(", "\n", "bboxes_xywh", "\n", ")", ",", "\"number of bounding boxes {}\"", "\" should be equal to first dim size of outputs {}\"", ".", "format", "(", "\n", "len", "(", "bboxes_xywh", ")", ",", "N", "\n", ")", "\n", "for", "n", "in", "range", "(", "N", ")", ":", "\n", "            ", "Sn", "=", "S", "[", "n", "]", ".", "argmax", "(", "dim", "=", "0", ")", "\n", "In", "=", "I", "[", "n", "]", ".", "argmax", "(", "dim", "=", "0", ")", "*", "(", "Sn", ">", "0", ")", ".", "long", "(", ")", "\n", "segmentation", "=", "In", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "mask", "=", "np", ".", "zeros", "(", "segmentation", ".", "shape", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "mask", "[", "segmentation", ">", "0", "]", "=", "1", "\n", "bbox_xywh", "=", "bboxes_xywh", "[", "n", "]", "\n", "\n", "if", "self", ".", "to_visualize", "==", "\"I\"", ":", "\n", "                ", "vis", "=", "segmentation", "\n", "", "elif", "self", ".", "to_visualize", "in", "\"UV\"", ":", "\n", "                ", "U_or_Vn", "=", "{", "\"U\"", ":", "U", ",", "\"V\"", ":", "V", "}", "[", "self", ".", "to_visualize", "]", "[", "n", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "vis", "=", "np", ".", "zeros", "(", "segmentation", ".", "shape", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "partId", "in", "range", "(", "U_or_Vn", ".", "shape", "[", "0", "]", ")", ":", "\n", "                    ", "vis", "[", "segmentation", "==", "partId", "]", "=", "(", "\n", "U_or_Vn", "[", "partId", "]", "[", "segmentation", "==", "partId", "]", ".", "clip", "(", "0", ",", "1", ")", "*", "255", "\n", ")", "\n", "\n", "", "", "image_bgr", "=", "self", ".", "mask_visualizer", ".", "visualize", "(", "image_bgr", ",", "mask", ",", "vis", ",", "bbox_xywh", ")", "\n", "\n", "", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_outputs.DensePoseOutputsUVisualizer.__init__": [[83, 85], ["densepose_outputs.DensePoseOutputsVisualizer.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplace", "=", "True", ",", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", ",", "alpha", "=", "0.7", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "inplace", "=", "inplace", ",", "cmap", "=", "cmap", ",", "alpha", "=", "alpha", ",", "to_visualize", "=", "\"U\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_outputs.DensePoseOutputsVVisualizer.__init__": [[88, 90], ["densepose_outputs.DensePoseOutputsVisualizer.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplace", "=", "True", ",", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", ",", "alpha", "=", "0.7", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "inplace", "=", "inplace", ",", "cmap", "=", "cmap", ",", "alpha", "=", "alpha", ",", "to_visualize", "=", "\"V\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_outputs.DensePoseOutputsFineSegmentationVisualizer.__init__": [[93, 95], ["densepose_outputs.DensePoseOutputsVisualizer.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplace", "=", "True", ",", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", ",", "alpha", "=", "0.7", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "inplace", "=", "inplace", ",", "cmap", "=", "cmap", ",", "alpha", "=", "alpha", ",", "to_visualize", "=", "\"I\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.bounding_box.BoundingBoxVisualizer.__init__": [[6, 8], ["base.RectangleVisualizer"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "rectangle_visualizer", "=", "RectangleVisualizer", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.bounding_box.BoundingBoxVisualizer.visualize": [[9, 13], ["bounding_box.BoundingBoxVisualizer.rectangle_visualizer.visualize"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_data_points.DensePoseDataPointsVisualizer.visualize"], ["", "def", "visualize", "(", "self", ",", "image_bgr", ",", "boxes_xywh", ")", ":", "\n", "        ", "for", "bbox_xywh", "in", "boxes_xywh", ":", "\n", "            ", "image_bgr", "=", "self", ".", "rectangle_visualizer", ".", "visualize", "(", "image_bgr", ",", "bbox_xywh", ")", "\n", "", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.bounding_box.ScoredBoundingBoxVisualizer.__init__": [[16, 23], ["base.RectangleVisualizer", "base.TextVisualizer"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "bbox_visualizer_params", "=", "None", ",", "score_visualizer_params", "=", "None", ")", ":", "\n", "        ", "if", "bbox_visualizer_params", "is", "None", ":", "\n", "            ", "bbox_visualizer_params", "=", "{", "}", "\n", "", "if", "score_visualizer_params", "is", "None", ":", "\n", "            ", "score_visualizer_params", "=", "{", "}", "\n", "", "self", ".", "visualizer_bbox", "=", "RectangleVisualizer", "(", "**", "bbox_visualizer_params", ")", "\n", "self", ".", "visualizer_score", "=", "TextVisualizer", "(", "**", "score_visualizer_params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.bounding_box.ScoredBoundingBoxVisualizer.visualize": [[24, 38], ["enumerate", "len", "len", "len", "len", "bounding_box.ScoredBoundingBoxVisualizer.visualizer_bbox.visualize", "bounding_box.ScoredBoundingBoxVisualizer.visualizer_score.visualize"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_data_points.DensePoseDataPointsVisualizer.visualize", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_data_points.DensePoseDataPointsVisualizer.visualize"], ["", "def", "visualize", "(", "self", ",", "image_bgr", ",", "scored_bboxes", ")", ":", "\n", "        ", "boxes_xywh", ",", "box_scores", "=", "scored_bboxes", "\n", "assert", "len", "(", "boxes_xywh", ")", "==", "len", "(", "\n", "box_scores", "\n", ")", ",", "\"Number of bounding boxes {} should be equal to the number of scores {}\"", ".", "format", "(", "\n", "len", "(", "boxes_xywh", ")", ",", "len", "(", "box_scores", ")", "\n", ")", "\n", "for", "i", ",", "box_xywh", "in", "enumerate", "(", "boxes_xywh", ")", ":", "\n", "            ", "score_i", "=", "box_scores", "[", "i", "]", "\n", "image_bgr", "=", "self", ".", "visualizer_bbox", ".", "visualize", "(", "image_bgr", ",", "box_xywh", ")", "\n", "score_txt", "=", "\"{0:6.4f}\"", ".", "format", "(", "score_i", ")", "\n", "topleft_xy", "=", "box_xywh", "[", "0", "]", ",", "box_xywh", "[", "1", "]", "\n", "image_bgr", "=", "self", ".", "visualizer_score", ".", "visualize", "(", "image_bgr", ",", "score_txt", ",", "topleft_xy", ")", "\n", "", "return", "image_bgr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsVisualizer.visualize": [[14, 27], ["boxes_xywh.cpu().numpy.cpu().numpy.cpu().numpy", "densepose_results.DensePoseResultsVisualizer.create_visualization_context", "enumerate", "densepose_results.DensePoseResultsVisualizer.context_to_image_bgr", "torch.cat().type", "densepose_results.DensePoseResultsVisualizer.visualize_iuv_arr", "boxes_xywh.cpu().numpy.cpu().numpy.cpu", "torch.cat().type.cpu().numpy", "torch.cat", "torch.cat().type.cpu"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsCustomContourVisualizer.create_visualization_context", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsCustomContourVisualizer.context_to_image_bgr", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsCustomContourVisualizer.visualize_iuv_arr", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["    ", "def", "visualize", "(", "\n", "self", ",", "image_bgr", ":", "Image", ",", "results_and_boxes_xywh", ":", "Optional", "[", "Tuple", "[", "DensePoseChartResult", ",", "Boxes", "]", "]", "\n", ")", "->", "Image", ":", "\n", "        ", "if", "results_and_boxes_xywh", "is", "None", ":", "\n", "            ", "return", "image_bgr", "\n", "", "densepose_result", ",", "boxes_xywh", "=", "results_and_boxes_xywh", "\n", "boxes_xywh", "=", "boxes_xywh", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "context", "=", "self", ".", "create_visualization_context", "(", "image_bgr", ")", "\n", "for", "i", ",", "result", "in", "enumerate", "(", "densepose_result", ")", ":", "\n", "            ", "iuv_array", "=", "torch", ".", "cat", "(", "(", "result", ".", "labels", "[", "None", "]", ",", "result", ".", "uv", "*", "255.0", ")", ")", ".", "type", "(", "torch", ".", "uint8", ")", "\n", "self", ".", "visualize_iuv_arr", "(", "context", ",", "iuv_array", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "boxes_xywh", "[", "i", "]", ")", "\n", "", "image_bgr", "=", "self", ".", "context_to_image_bgr", "(", "context", ")", "\n", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseMaskedColormapResultsVisualizer.__init__": [[30, 44], ["base.MatrixVisualizer"], "methods", ["None"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "data_extractor", ",", "\n", "segm_extractor", ",", "\n", "inplace", "=", "True", ",", "\n", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", ",", "\n", "alpha", "=", "0.7", ",", "\n", "val_scale", "=", "1.0", ",", "\n", ")", ":", "\n", "        ", "self", ".", "mask_visualizer", "=", "MatrixVisualizer", "(", "\n", "inplace", "=", "inplace", ",", "cmap", "=", "cmap", ",", "val_scale", "=", "val_scale", ",", "alpha", "=", "alpha", "\n", ")", "\n", "self", ".", "data_extractor", "=", "data_extractor", "\n", "self", ".", "segm_extractor", "=", "segm_extractor", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseMaskedColormapResultsVisualizer.create_visualization_context": [[45, 47], ["None"], "methods", ["None"], ["", "def", "create_visualization_context", "(", "self", ",", "image_bgr", ":", "Image", ")", ":", "\n", "        ", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseMaskedColormapResultsVisualizer.context_to_image_bgr": [[48, 50], ["None"], "methods", ["None"], ["", "def", "context_to_image_bgr", "(", "self", ",", "context", ")", ":", "\n", "        ", "return", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseMaskedColormapResultsVisualizer.get_image_bgr_from_context": [[51, 53], ["None"], "methods", ["None"], ["", "def", "get_image_bgr_from_context", "(", "self", ",", "context", ")", ":", "\n", "        ", "return", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseMaskedColormapResultsVisualizer.visualize_iuv_arr": [[54, 62], ["densepose_results.DensePoseMaskedColormapResultsVisualizer.get_image_bgr_from_context", "densepose_results.DensePoseMaskedColormapResultsVisualizer.data_extractor", "densepose_results.DensePoseMaskedColormapResultsVisualizer.segm_extractor", "numpy.zeros", "densepose_results.DensePoseMaskedColormapResultsVisualizer.mask_visualizer.visualize"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsCustomContourVisualizer.get_image_bgr_from_context", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_data_points.DensePoseDataPointsVisualizer.visualize"], ["", "def", "visualize_iuv_arr", "(", "self", ",", "context", ",", "iuv_arr", ":", "np", ".", "array", ",", "bbox_xywh", ")", ":", "\n", "        ", "image_bgr", "=", "self", ".", "get_image_bgr_from_context", "(", "context", ")", "\n", "matrix", "=", "self", ".", "data_extractor", "(", "iuv_arr", ")", "\n", "segm", "=", "self", ".", "segm_extractor", "(", "iuv_arr", ")", "\n", "mask", "=", "np", ".", "zeros", "(", "matrix", ".", "shape", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "mask", "[", "segm", ">", "0", "]", "=", "1", "\n", "image_bgr", "=", "self", ".", "mask_visualizer", ".", "visualize", "(", "image_bgr", ",", "mask", ",", "matrix", ",", "bbox_xywh", ")", "\n", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsMplContourVisualizer.__init__": [[77, 80], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "levels", "=", "10", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "levels", "=", "levels", "\n", "self", ".", "plot_args", "=", "kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsMplContourVisualizer.create_visualization_context": [[81, 99], ["plt.figure", "plt.axes", "plt.axis", "FigureCanvas", "plt.imshow", "float", "float"], "methods", ["None"], ["", "def", "create_visualization_context", "(", "self", ",", "image_bgr", ":", "Image", ")", ":", "\n", "        ", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "from", "matplotlib", ".", "backends", ".", "backend_agg", "import", "FigureCanvasAgg", "as", "FigureCanvas", "\n", "\n", "context", "=", "{", "}", "\n", "context", "[", "\"image_bgr\"", "]", "=", "image_bgr", "\n", "dpi", "=", "100", "\n", "height_inches", "=", "float", "(", "image_bgr", ".", "shape", "[", "0", "]", ")", "/", "dpi", "\n", "width_inches", "=", "float", "(", "image_bgr", ".", "shape", "[", "1", "]", ")", "/", "dpi", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "width_inches", ",", "height_inches", ")", ",", "dpi", "=", "dpi", ")", "\n", "plt", ".", "axes", "(", "[", "0", ",", "0", ",", "1", ",", "1", "]", ")", "\n", "plt", ".", "axis", "(", "\"off\"", ")", "\n", "context", "[", "\"fig\"", "]", "=", "fig", "\n", "canvas", "=", "FigureCanvas", "(", "fig", ")", "\n", "context", "[", "\"canvas\"", "]", "=", "canvas", "\n", "extent", "=", "(", "0", ",", "image_bgr", ".", "shape", "[", "1", "]", ",", "image_bgr", ".", "shape", "[", "0", "]", ",", "0", ")", "\n", "plt", ".", "imshow", "(", "image_bgr", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", ",", "extent", "=", "extent", ")", "\n", "return", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsMplContourVisualizer.context_to_image_bgr": [[100, 109], ["map", "canvas.draw", "numpy.fromstring", "numpy.fromstring.reshape", "image_rgb[].copy", "canvas.tostring_rgb", "fig.get_size_inches", "fig.get_dpi"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.draw"], ["", "def", "context_to_image_bgr", "(", "self", ",", "context", ")", ":", "\n", "        ", "fig", "=", "context", "[", "\"fig\"", "]", "\n", "w", ",", "h", "=", "map", "(", "int", ",", "fig", ".", "get_size_inches", "(", ")", "*", "fig", ".", "get_dpi", "(", ")", ")", "\n", "canvas", "=", "context", "[", "\"canvas\"", "]", "\n", "canvas", ".", "draw", "(", ")", "\n", "image_1d", "=", "np", ".", "fromstring", "(", "canvas", ".", "tostring_rgb", "(", ")", ",", "dtype", "=", "\"uint8\"", ")", "\n", "image_rgb", "=", "image_1d", ".", "reshape", "(", "h", ",", "w", ",", "3", ")", "\n", "image_bgr", "=", "image_rgb", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", ".", "copy", "(", ")", "\n", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsMplContourVisualizer.visualize_iuv_arr": [[110, 123], ["plt.contour", "plt.contour", "_extract_u_from_iuvarr().astype", "_extract_v_from_iuvarr().astype", "densepose_results._extract_u_from_iuvarr", "densepose_results._extract_v_from_iuvarr"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results._extract_u_from_iuvarr", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results._extract_v_from_iuvarr"], ["", "def", "visualize_iuv_arr", "(", "self", ",", "context", ",", "iuv_arr", ":", "np", ".", "ndarray", ",", "bbox_xywh", ":", "Boxes", ")", "->", "Image", ":", "\n", "        ", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "\n", "u", "=", "_extract_u_from_iuvarr", "(", "iuv_arr", ")", ".", "astype", "(", "float", ")", "/", "255.0", "\n", "v", "=", "_extract_v_from_iuvarr", "(", "iuv_arr", ")", ".", "astype", "(", "float", ")", "/", "255.0", "\n", "extent", "=", "(", "\n", "bbox_xywh", "[", "0", "]", ",", "\n", "bbox_xywh", "[", "0", "]", "+", "bbox_xywh", "[", "2", "]", ",", "\n", "bbox_xywh", "[", "1", "]", ",", "\n", "bbox_xywh", "[", "1", "]", "+", "bbox_xywh", "[", "3", "]", ",", "\n", ")", "\n", "plt", ".", "contour", "(", "u", ",", "self", ".", "levels", ",", "extent", "=", "extent", ",", "**", "self", ".", "plot_args", ")", "\n", "plt", ".", "contour", "(", "v", ",", "self", ".", "levels", ",", "extent", "=", "extent", ",", "**", "self", ".", "plot_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsCustomContourVisualizer.__init__": [[130, 145], ["isinstance", "cv2.applyColorMap", "numpy.linspace", "len", "int", "img_color_bgr.ravel"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "levels", "=", "10", ",", "**", "kwargs", ")", ":", "\n", "# TODO: colormap is hardcoded", "\n", "        ", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", "\n", "if", "isinstance", "(", "levels", ",", "int", ")", ":", "\n", "            ", "self", ".", "levels", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "levels", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "levels", "=", "levels", "\n", "", "if", "\"linewidths\"", "in", "kwargs", ":", "\n", "            ", "self", ".", "linewidths", "=", "kwargs", "[", "\"linewidths\"", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "linewidths", "=", "[", "1", "]", "*", "len", "(", "self", ".", "levels", ")", "\n", "", "self", ".", "plot_args", "=", "kwargs", "\n", "img_colors_bgr", "=", "cv2", ".", "applyColorMap", "(", "(", "self", ".", "levels", "*", "255", ")", ".", "astype", "(", "np", ".", "uint8", ")", ",", "cmap", ")", "\n", "self", ".", "level_colors_bgr", "=", "[", "\n", "[", "int", "(", "v", ")", "for", "v", "in", "img_color_bgr", ".", "ravel", "(", ")", "]", "for", "img_color_bgr", "in", "img_colors_bgr", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsCustomContourVisualizer.create_visualization_context": [[147, 149], ["None"], "methods", ["None"], ["", "def", "create_visualization_context", "(", "self", ",", "image_bgr", ":", "Image", ")", ":", "\n", "        ", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsCustomContourVisualizer.context_to_image_bgr": [[150, 152], ["None"], "methods", ["None"], ["", "def", "context_to_image_bgr", "(", "self", ",", "context", ")", ":", "\n", "        ", "return", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsCustomContourVisualizer.get_image_bgr_from_context": [[153, 155], ["None"], "methods", ["None"], ["", "def", "get_image_bgr_from_context", "(", "self", ",", "context", ")", ":", "\n", "        ", "return", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsCustomContourVisualizer.visualize_iuv_arr": [[156, 163], ["densepose_results.DensePoseResultsCustomContourVisualizer.get_image_bgr_from_context", "densepose_results._extract_i_from_iuvarr", "densepose_results.DensePoseResultsCustomContourVisualizer._contours", "densepose_results.DensePoseResultsCustomContourVisualizer._contours", "_extract_u_from_iuvarr().astype", "_extract_v_from_iuvarr().astype", "densepose_results._extract_u_from_iuvarr", "densepose_results._extract_v_from_iuvarr"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsCustomContourVisualizer.get_image_bgr_from_context", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results._extract_i_from_iuvarr", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsCustomContourVisualizer._contours", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsCustomContourVisualizer._contours", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results._extract_u_from_iuvarr", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results._extract_v_from_iuvarr"], ["", "def", "visualize_iuv_arr", "(", "self", ",", "context", ",", "iuv_arr", ":", "np", ".", "ndarray", ",", "bbox_xywh", ":", "Boxes", ")", "->", "Image", ":", "\n", "        ", "image_bgr", "=", "self", ".", "get_image_bgr_from_context", "(", "context", ")", "\n", "segm", "=", "_extract_i_from_iuvarr", "(", "iuv_arr", ")", "\n", "u", "=", "_extract_u_from_iuvarr", "(", "iuv_arr", ")", ".", "astype", "(", "float", ")", "/", "255.0", "\n", "v", "=", "_extract_v_from_iuvarr", "(", "iuv_arr", ")", ".", "astype", "(", "float", ")", "/", "255.0", "\n", "self", ".", "_contours", "(", "image_bgr", ",", "u", ",", "segm", ",", "bbox_xywh", ")", "\n", "self", ".", "_contours", "(", "image_bgr", ",", "v", ",", "segm", ",", "bbox_xywh", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsCustomContourVisualizer._contours": [[164, 209], ["range", "numpy.amin", "numpy.amax", "numpy.nonzero", "numpy.amin", "numpy.amin", "enumerate", "numpy.any", "numpy.amax", "numpy.amax", "numpy.nditer", "numpy.nditer.iternext", "densepose_results.DensePoseResultsCustomContourVisualizer._draw_line"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsCustomContourVisualizer._draw_line"], ["", "def", "_contours", "(", "self", ",", "image_bgr", ",", "arr", ",", "segm", ",", "bbox_xywh", ")", ":", "\n", "        ", "for", "part_idx", "in", "range", "(", "1", ",", "DensePoseDataRelative", ".", "N_PART_LABELS", "+", "1", ")", ":", "\n", "            ", "mask", "=", "segm", "==", "part_idx", "\n", "if", "not", "np", ".", "any", "(", "mask", ")", ":", "\n", "                ", "continue", "\n", "", "arr_min", "=", "np", ".", "amin", "(", "arr", "[", "mask", "]", ")", "\n", "arr_max", "=", "np", ".", "amax", "(", "arr", "[", "mask", "]", ")", "\n", "I", ",", "J", "=", "np", ".", "nonzero", "(", "mask", ")", "\n", "i0", "=", "np", ".", "amin", "(", "I", ")", "\n", "i1", "=", "np", ".", "amax", "(", "I", ")", "+", "1", "\n", "j0", "=", "np", ".", "amin", "(", "J", ")", "\n", "j1", "=", "np", ".", "amax", "(", "J", ")", "+", "1", "\n", "if", "(", "j1", "==", "j0", "+", "1", ")", "or", "(", "i1", "==", "i0", "+", "1", ")", ":", "\n", "                ", "continue", "\n", "", "Nw", "=", "arr", ".", "shape", "[", "1", "]", "-", "1", "\n", "Nh", "=", "arr", ".", "shape", "[", "0", "]", "-", "1", "\n", "for", "level_idx", ",", "level", "in", "enumerate", "(", "self", ".", "levels", ")", ":", "\n", "                ", "if", "(", "level", "<", "arr_min", ")", "or", "(", "level", ">", "arr_max", ")", ":", "\n", "                    ", "continue", "\n", "", "vp", "=", "arr", "[", "i0", ":", "i1", ",", "j0", ":", "j1", "]", ">=", "level", "\n", "bin_codes", "=", "vp", "[", ":", "-", "1", ",", ":", "-", "1", "]", "+", "vp", "[", "1", ":", ",", ":", "-", "1", "]", "*", "2", "+", "vp", "[", "1", ":", ",", "1", ":", "]", "*", "4", "+", "vp", "[", ":", "-", "1", ",", "1", ":", "]", "*", "8", "\n", "mp", "=", "mask", "[", "i0", ":", "i1", ",", "j0", ":", "j1", "]", "\n", "bin_mask_codes", "=", "mp", "[", ":", "-", "1", ",", ":", "-", "1", "]", "+", "mp", "[", "1", ":", ",", ":", "-", "1", "]", "*", "2", "+", "mp", "[", "1", ":", ",", "1", ":", "]", "*", "4", "+", "mp", "[", ":", "-", "1", ",", "1", ":", "]", "*", "8", "\n", "it", "=", "np", ".", "nditer", "(", "bin_codes", ",", "flags", "=", "[", "\"multi_index\"", "]", ")", "\n", "color_bgr", "=", "self", ".", "level_colors_bgr", "[", "level_idx", "]", "\n", "linewidth", "=", "self", ".", "linewidths", "[", "level_idx", "]", "\n", "while", "not", "it", ".", "finished", ":", "\n", "                    ", "if", "(", "it", "[", "0", "]", "!=", "0", ")", "and", "(", "it", "[", "0", "]", "!=", "15", ")", ":", "\n", "                        ", "i", ",", "j", "=", "it", ".", "multi_index", "\n", "if", "bin_mask_codes", "[", "i", ",", "j", "]", "!=", "0", ":", "\n", "                            ", "self", ".", "_draw_line", "(", "\n", "image_bgr", ",", "\n", "arr", ",", "\n", "mask", ",", "\n", "level", ",", "\n", "color_bgr", ",", "\n", "linewidth", ",", "\n", "it", "[", "0", "]", ",", "\n", "it", ".", "multi_index", ",", "\n", "bbox_xywh", ",", "\n", "Nw", ",", "\n", "Nh", ",", "\n", "(", "i0", ",", "j0", ")", ",", "\n", ")", "\n", "", "", "it", ".", "iternext", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsCustomContourVisualizer._draw_line": [[210, 235], ["densepose_results.DensePoseResultsCustomContourVisualizer._bin_code_2_lines", "cv2.line", "int", "int", "int", "int"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsCustomContourVisualizer._bin_code_2_lines"], ["", "", "", "", "def", "_draw_line", "(", "\n", "self", ",", "\n", "image_bgr", ",", "\n", "arr", ",", "\n", "mask", ",", "\n", "v", ",", "\n", "color_bgr", ",", "\n", "linewidth", ",", "\n", "bin_code", ",", "\n", "multi_idx", ",", "\n", "bbox_xywh", ",", "\n", "Nw", ",", "\n", "Nh", ",", "\n", "offset", ",", "\n", ")", ":", "\n", "        ", "lines", "=", "self", ".", "_bin_code_2_lines", "(", "arr", ",", "v", ",", "bin_code", ",", "multi_idx", ",", "Nw", ",", "Nh", ",", "offset", ")", "\n", "x0", ",", "y0", ",", "w", ",", "h", "=", "bbox_xywh", "\n", "x1", "=", "x0", "+", "w", "\n", "y1", "=", "y0", "+", "h", "\n", "for", "line", "in", "lines", ":", "\n", "            ", "x0r", ",", "y0r", "=", "line", "[", "0", "]", "\n", "x1r", ",", "y1r", "=", "line", "[", "1", "]", "\n", "pt0", "=", "(", "int", "(", "x0", "+", "x0r", "*", "(", "x1", "-", "x0", ")", ")", ",", "int", "(", "y0", "+", "y0r", "*", "(", "y1", "-", "y0", ")", ")", ")", "\n", "pt1", "=", "(", "int", "(", "x0", "+", "x1r", "*", "(", "x1", "-", "x0", ")", ")", ",", "int", "(", "y0", "+", "y1r", "*", "(", "y1", "-", "y0", ")", ")", ")", "\n", "cv2", ".", "line", "(", "image_bgr", ",", "pt0", ",", "pt1", ",", "color_bgr", ",", "linewidth", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsCustomContourVisualizer._bin_code_2_lines": [[236, 303], ["float", "float"], "methods", ["None"], ["", "", "def", "_bin_code_2_lines", "(", "self", ",", "arr", ",", "v", ",", "bin_code", ",", "multi_idx", ",", "Nw", ",", "Nh", ",", "offset", ")", ":", "\n", "        ", "i0", ",", "j0", "=", "offset", "\n", "i", ",", "j", "=", "multi_idx", "\n", "i", "+=", "i0", "\n", "j", "+=", "j0", "\n", "v0", ",", "v1", ",", "v2", ",", "v3", "=", "arr", "[", "i", ",", "j", "]", ",", "arr", "[", "i", "+", "1", ",", "j", "]", ",", "arr", "[", "i", "+", "1", ",", "j", "+", "1", "]", ",", "arr", "[", "i", ",", "j", "+", "1", "]", "\n", "x0i", "=", "float", "(", "j", ")", "/", "Nw", "\n", "y0j", "=", "float", "(", "i", ")", "/", "Nh", "\n", "He", "=", "1.0", "/", "Nh", "\n", "We", "=", "1.0", "/", "Nw", "\n", "if", "(", "bin_code", "==", "1", ")", "or", "(", "bin_code", "==", "14", ")", ":", "\n", "            ", "a", "=", "(", "v", "-", "v0", ")", "/", "(", "v1", "-", "v0", ")", "\n", "b", "=", "(", "v", "-", "v0", ")", "/", "(", "v3", "-", "v0", ")", "\n", "pt1", "=", "(", "x0i", ",", "y0j", "+", "a", "*", "He", ")", "\n", "pt2", "=", "(", "x0i", "+", "b", "*", "We", ",", "y0j", ")", "\n", "return", "[", "(", "pt1", ",", "pt2", ")", "]", "\n", "", "elif", "(", "bin_code", "==", "2", ")", "or", "(", "bin_code", "==", "13", ")", ":", "\n", "            ", "a", "=", "(", "v", "-", "v0", ")", "/", "(", "v1", "-", "v0", ")", "\n", "b", "=", "(", "v", "-", "v1", ")", "/", "(", "v2", "-", "v1", ")", "\n", "pt1", "=", "(", "x0i", ",", "y0j", "+", "a", "*", "He", ")", "\n", "pt2", "=", "(", "x0i", "+", "b", "*", "We", ",", "y0j", "+", "He", ")", "\n", "return", "[", "(", "pt1", ",", "pt2", ")", "]", "\n", "", "elif", "(", "bin_code", "==", "3", ")", "or", "(", "bin_code", "==", "12", ")", ":", "\n", "            ", "a", "=", "(", "v", "-", "v0", ")", "/", "(", "v3", "-", "v0", ")", "\n", "b", "=", "(", "v", "-", "v1", ")", "/", "(", "v2", "-", "v1", ")", "\n", "pt1", "=", "(", "x0i", "+", "a", "*", "We", ",", "y0j", ")", "\n", "pt2", "=", "(", "x0i", "+", "b", "*", "We", ",", "y0j", "+", "He", ")", "\n", "return", "[", "(", "pt1", ",", "pt2", ")", "]", "\n", "", "elif", "(", "bin_code", "==", "4", ")", "or", "(", "bin_code", "==", "11", ")", ":", "\n", "            ", "a", "=", "(", "v", "-", "v1", ")", "/", "(", "v2", "-", "v1", ")", "\n", "b", "=", "(", "v", "-", "v3", ")", "/", "(", "v2", "-", "v3", ")", "\n", "pt1", "=", "(", "x0i", "+", "a", "*", "We", ",", "y0j", "+", "He", ")", "\n", "pt2", "=", "(", "x0i", "+", "We", ",", "y0j", "+", "b", "*", "He", ")", "\n", "return", "[", "(", "pt1", ",", "pt2", ")", "]", "\n", "", "elif", "(", "bin_code", "==", "6", ")", "or", "(", "bin_code", "==", "9", ")", ":", "\n", "            ", "a", "=", "(", "v", "-", "v0", ")", "/", "(", "v1", "-", "v0", ")", "\n", "b", "=", "(", "v", "-", "v3", ")", "/", "(", "v2", "-", "v3", ")", "\n", "pt1", "=", "(", "x0i", ",", "y0j", "+", "a", "*", "He", ")", "\n", "pt2", "=", "(", "x0i", "+", "We", ",", "y0j", "+", "b", "*", "He", ")", "\n", "return", "[", "(", "pt1", ",", "pt2", ")", "]", "\n", "", "elif", "(", "bin_code", "==", "7", ")", "or", "(", "bin_code", "==", "8", ")", ":", "\n", "            ", "a", "=", "(", "v", "-", "v0", ")", "/", "(", "v3", "-", "v0", ")", "\n", "b", "=", "(", "v", "-", "v3", ")", "/", "(", "v2", "-", "v3", ")", "\n", "pt1", "=", "(", "x0i", "+", "a", "*", "We", ",", "y0j", ")", "\n", "pt2", "=", "(", "x0i", "+", "We", ",", "y0j", "+", "b", "*", "He", ")", "\n", "return", "[", "(", "pt1", ",", "pt2", ")", "]", "\n", "", "elif", "bin_code", "==", "5", ":", "\n", "            ", "a1", "=", "(", "v", "-", "v0", ")", "/", "(", "v1", "-", "v0", ")", "\n", "b1", "=", "(", "v", "-", "v1", ")", "/", "(", "v2", "-", "v1", ")", "\n", "pt11", "=", "(", "x0i", ",", "y0j", "+", "a1", "*", "He", ")", "\n", "pt12", "=", "(", "x0i", "+", "b1", "*", "We", ",", "y0j", "+", "He", ")", "\n", "a2", "=", "(", "v", "-", "v0", ")", "/", "(", "v3", "-", "v0", ")", "\n", "b2", "=", "(", "v", "-", "v3", ")", "/", "(", "v2", "-", "v3", ")", "\n", "pt21", "=", "(", "x0i", "+", "a2", "*", "We", ",", "y0j", ")", "\n", "pt22", "=", "(", "x0i", "+", "We", ",", "y0j", "+", "b2", "*", "He", ")", "\n", "return", "[", "(", "pt11", ",", "pt12", ")", ",", "(", "pt21", ",", "pt22", ")", "]", "\n", "", "elif", "bin_code", "==", "10", ":", "\n", "            ", "a1", "=", "(", "v", "-", "v0", ")", "/", "(", "v3", "-", "v0", ")", "\n", "b1", "=", "(", "v", "-", "v0", ")", "/", "(", "v1", "-", "v0", ")", "\n", "pt11", "=", "(", "x0i", "+", "a1", "*", "We", ",", "y0j", ")", "\n", "pt12", "=", "(", "x0i", ",", "y0j", "+", "b1", "*", "He", ")", "\n", "a2", "=", "(", "v", "-", "v1", ")", "/", "(", "v2", "-", "v1", ")", "\n", "b2", "=", "(", "v", "-", "v3", ")", "/", "(", "v2", "-", "v3", ")", "\n", "pt21", "=", "(", "x0i", "+", "a2", "*", "We", ",", "y0j", "+", "He", ")", "\n", "pt22", "=", "(", "x0i", "+", "We", ",", "y0j", "+", "b2", "*", "He", ")", "\n", "return", "[", "(", "pt11", ",", "pt12", ")", ",", "(", "pt21", ",", "pt22", ")", "]", "\n", "", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsFineSegmentationVisualizer.__init__": [[317, 325], ["densepose_results.DensePoseMaskedColormapResultsVisualizer.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplace", "=", "True", ",", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", ",", "alpha", "=", "0.7", ")", ":", "\n", "        ", "super", "(", "DensePoseResultsFineSegmentationVisualizer", ",", "self", ")", ".", "__init__", "(", "\n", "_extract_i_from_iuvarr", ",", "\n", "_extract_i_from_iuvarr", ",", "\n", "inplace", ",", "\n", "cmap", ",", "\n", "alpha", ",", "\n", "val_scale", "=", "255.0", "/", "DensePoseDataRelative", ".", "N_PART_LABELS", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsUVisualizer.__init__": [[329, 332], ["densepose_results.DensePoseMaskedColormapResultsVisualizer.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplace", "=", "True", ",", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", ",", "alpha", "=", "0.7", ")", ":", "\n", "        ", "super", "(", "DensePoseResultsUVisualizer", ",", "self", ")", ".", "__init__", "(", "\n", "_extract_u_from_iuvarr", ",", "_extract_i_from_iuvarr", ",", "inplace", ",", "cmap", ",", "alpha", ",", "val_scale", "=", "1.0", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results.DensePoseResultsVVisualizer.__init__": [[336, 339], ["densepose_results.DensePoseMaskedColormapResultsVisualizer.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplace", "=", "True", ",", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", ",", "alpha", "=", "0.7", ")", ":", "\n", "        ", "super", "(", "DensePoseResultsVVisualizer", ",", "self", ")", ".", "__init__", "(", "\n", "_extract_v_from_iuvarr", ",", "_extract_i_from_iuvarr", ",", "inplace", ",", "cmap", ",", "alpha", ",", "val_scale", "=", "1.0", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results._extract_i_from_iuvarr": [[64, 66], ["None"], "function", ["None"], ["", "", "def", "_extract_i_from_iuvarr", "(", "iuv_arr", ")", ":", "\n", "    ", "return", "iuv_arr", "[", "0", ",", ":", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results._extract_u_from_iuvarr": [[68, 70], ["None"], "function", ["None"], ["", "def", "_extract_u_from_iuvarr", "(", "iuv_arr", ")", ":", "\n", "    ", "return", "iuv_arr", "[", "1", ",", ":", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_results._extract_v_from_iuvarr": [[72, 74], ["None"], "function", ["None"], ["", "def", "_extract_v_from_iuvarr", "(", "iuv_arr", ")", ":", "\n", "    ", "return", "iuv_arr", "[", "2", ",", ":", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_data_points.DensePoseDataCoarseSegmentationVisualizer.__init__": [[15, 21], ["base.MatrixVisualizer"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "inplace", "=", "True", ",", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", ",", "alpha", "=", "0.7", ")", ":", "\n", "        ", "self", ".", "mask_visualizer", "=", "MatrixVisualizer", "(", "\n", "inplace", "=", "inplace", ",", "\n", "cmap", "=", "cmap", ",", "\n", "val_scale", "=", "255.0", "/", "DensePoseDataRelative", ".", "N_BODY_PARTS", ",", "\n", "alpha", "=", "alpha", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_data_points.DensePoseDataCoarseSegmentationVisualizer.visualize": [[23, 36], ["zip", "densepose_data.segm.numpy", "numpy.zeros", "densepose_data_points.DensePoseDataCoarseSegmentationVisualizer.mask_visualizer.visualize", "bbox_xywh.numpy"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_data_points.DensePoseDataPointsVisualizer.visualize"], ["", "def", "visualize", "(", "\n", "self", ",", "\n", "image_bgr", ":", "Image", ",", "\n", "bbox_densepose_datas", ":", "Optional", "[", "Tuple", "[", "Iterable", "[", "Boxes", "]", ",", "Iterable", "[", "DensePoseDataRelative", "]", "]", "]", ",", "\n", ")", "->", "Image", ":", "\n", "        ", "if", "bbox_densepose_datas", "is", "None", ":", "\n", "            ", "return", "image_bgr", "\n", "", "for", "bbox_xywh", ",", "densepose_data", "in", "zip", "(", "*", "bbox_densepose_datas", ")", ":", "\n", "            ", "matrix", "=", "densepose_data", ".", "segm", ".", "numpy", "(", ")", "\n", "mask", "=", "np", ".", "zeros", "(", "matrix", ".", "shape", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "mask", "[", "matrix", ">", "0", "]", "=", "1", "\n", "image_bgr", "=", "self", ".", "mask_visualizer", ".", "visualize", "(", "image_bgr", ",", "mask", ",", "matrix", ",", "bbox_xywh", ".", "numpy", "(", ")", ")", "\n", "", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_data_points.DensePoseDataPointsVisualizer.__init__": [[39, 43], ["base.PointsVisualizer"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "densepose_data_to_value_fn", "=", "None", ",", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", ")", ":", "\n", "        ", "self", ".", "points_visualizer", "=", "PointsVisualizer", "(", ")", "\n", "self", ".", "densepose_data_to_value_fn", "=", "densepose_data_to_value_fn", "\n", "self", ".", "cmap", "=", "cmap", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_data_points.DensePoseDataPointsVisualizer.visualize": [[44, 66], ["zip", "bbox_xywh.numpy", "zip", "densepose_data_points.DensePoseDataPointsVisualizer.points_visualizer.visualize", "densepose_data_points.DensePoseDataPointsVisualizer.densepose_data_to_value_fn", "cv2.applyColorMap", "densepose_data_points.DensePoseDataPointsVisualizer.points_visualizer.visualize", "densepose_data.x.numpy", "densepose_data.y.numpy", "int", "img_color_bgr.ravel"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_data_points.DensePoseDataPointsVisualizer.visualize", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_data_points.DensePoseDataPointsVisualizer.visualize"], ["", "def", "visualize", "(", "\n", "self", ",", "\n", "image_bgr", ":", "Image", ",", "\n", "bbox_densepose_datas", ":", "Optional", "[", "Tuple", "[", "Iterable", "[", "Boxes", "]", ",", "Iterable", "[", "DensePoseDataRelative", "]", "]", "]", ",", "\n", ")", "->", "Image", ":", "\n", "        ", "if", "bbox_densepose_datas", "is", "None", ":", "\n", "            ", "return", "image_bgr", "\n", "", "for", "bbox_xywh", ",", "densepose_data", "in", "zip", "(", "*", "bbox_densepose_datas", ")", ":", "\n", "            ", "x0", ",", "y0", ",", "w", ",", "h", "=", "bbox_xywh", ".", "numpy", "(", ")", "\n", "x", "=", "densepose_data", ".", "x", ".", "numpy", "(", ")", "*", "w", "/", "255.0", "+", "x0", "\n", "y", "=", "densepose_data", ".", "y", ".", "numpy", "(", ")", "*", "h", "/", "255.0", "+", "y0", "\n", "pts_xy", "=", "zip", "(", "x", ",", "y", ")", "\n", "if", "self", ".", "densepose_data_to_value_fn", "is", "None", ":", "\n", "                ", "image_bgr", "=", "self", ".", "points_visualizer", ".", "visualize", "(", "image_bgr", ",", "pts_xy", ")", "\n", "", "else", ":", "\n", "                ", "v", "=", "self", ".", "densepose_data_to_value_fn", "(", "densepose_data", ")", "\n", "img_colors_bgr", "=", "cv2", ".", "applyColorMap", "(", "v", ",", "self", ".", "cmap", ")", "\n", "colors_bgr", "=", "[", "\n", "[", "int", "(", "v", ")", "for", "v", "in", "img_color_bgr", ".", "ravel", "(", ")", "]", "for", "img_color_bgr", "in", "img_colors_bgr", "\n", "]", "\n", "image_bgr", "=", "self", ".", "points_visualizer", ".", "visualize", "(", "image_bgr", ",", "pts_xy", ",", "colors_bgr", ")", "\n", "", "", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_data_points.DensePoseDataPointsUVisualizer.__init__": [[88, 91], ["densepose_data_points.DensePoseDataPointsVisualizer.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "DensePoseDataPointsUVisualizer", ",", "self", ")", ".", "__init__", "(", "\n", "densepose_data_to_value_fn", "=", "_densepose_data_u_for_cmap", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_data_points.DensePoseDataPointsVVisualizer.__init__": [[95, 98], ["densepose_data_points.DensePoseDataPointsVisualizer.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "DensePoseDataPointsVVisualizer", ",", "self", ")", ".", "__init__", "(", "\n", "densepose_data_to_value_fn", "=", "_densepose_data_v_for_cmap", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_data_points.DensePoseDataPointsIVisualizer.__init__": [[102, 105], ["densepose_data_points.DensePoseDataPointsVisualizer.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "DensePoseDataPointsIVisualizer", ",", "self", ")", ".", "__init__", "(", "\n", "densepose_data_to_value_fn", "=", "_densepose_data_i_for_cmap", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_data_points._densepose_data_u_for_cmap": [[68, 71], ["u.astype", "numpy.clip", "densepose_data.u.numpy"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clip"], ["", "", "def", "_densepose_data_u_for_cmap", "(", "densepose_data", ")", ":", "\n", "    ", "u", "=", "np", ".", "clip", "(", "densepose_data", ".", "u", ".", "numpy", "(", ")", ",", "0", ",", "1", ")", "*", "255.0", "\n", "return", "u", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_data_points._densepose_data_v_for_cmap": [[73, 76], ["v.astype", "numpy.clip", "densepose_data.v.numpy"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clip"], ["", "def", "_densepose_data_v_for_cmap", "(", "densepose_data", ")", ":", "\n", "    ", "v", "=", "np", ".", "clip", "(", "densepose_data", ".", "v", ".", "numpy", "(", ")", ",", "0", ",", "1", ")", "*", "255.0", "\n", "return", "v", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.vis.densepose_data_points._densepose_data_i_for_cmap": [[78, 85], ["i.astype", "numpy.clip", "densepose_data.i.numpy"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clip"], ["", "def", "_densepose_data_i_for_cmap", "(", "densepose_data", ")", ":", "\n", "    ", "i", "=", "(", "\n", "np", ".", "clip", "(", "densepose_data", ".", "i", ".", "numpy", "(", ")", ",", "0.0", ",", "DensePoseDataRelative", ".", "N_PART_LABELS", ")", "\n", "*", "255.0", "\n", "/", "DensePoseDataRelative", ".", "N_PART_LABELS", "\n", ")", "\n", "return", "i", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.TridentNet.train_net.Trainer.build_evaluator": [[21, 26], ["detectron2.evaluation.COCOEvaluator", "os.path.join"], "methods", ["None"], ["@", "ROI_HEADS_REGISTRY", ".", "register", "(", ")", "\n", "class", "Res5ROIHeadsExtraNorm", "(", "Res5ROIHeads", ")", ":", "\n", "    ", "\"\"\"\n    As described in the MOCO paper, there is an extra BN layer\n    following the res5 stage.\n    \"\"\"", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.TridentNet.train_net.setup": [[28, 39], ["detectron2.config.get_cfg", "tridentnet.add_tridentnet_config", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.engine.default_setup"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tridentnet.config.add_tridentnet_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.default_setup"], ["def", "_build_res5_block", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "seq", ",", "out_channels", "=", "super", "(", ")", ".", "_build_res5_block", "(", "cfg", ")", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "NORM", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", "\n", "seq", ".", "add_module", "(", "\"norm\"", ",", "norm", ")", "\n", "return", "seq", ",", "out_channels", "\n", "\n", "\n", "", "", "class", "Trainer", "(", "DefaultTrainer", ")", ":", "\n", "\n", "    ", "@", "classmethod", "\n", "def", "build_evaluator", "(", "cls", ",", "cfg", ",", "dataset_name", ",", "output_folder", "=", "None", ")", ":", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.TridentNet.train_net.main": [[41, 55], ["train_net.setup", "train_net.Trainer", "Trainer.resume_or_load", "Trainer.train", "Trainer.build_model", "detectron2.checkpoint.DetectionCheckpointer().resume_or_load", "Trainer.test", "detectron2.checkpoint.DetectionCheckpointer"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.setup", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_packaging.TestCollectEnv.test"], ["            ", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference\"", ")", "\n", "", "if", "\"voc\"", "in", "dataset_name", ":", "\n", "            ", "return", "PascalVOCDetectionEvaluator", "(", "dataset_name", ")", "\n", "", "else", ":", "\n", "            ", "return", "COCOEvaluator", "(", "dataset_name", ",", "cfg", ",", "True", ",", "output_folder", ")", "\n", "\n", "\n", "", "", "", "def", "setup", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "default_setup", "(", "cfg", ",", "args", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tridentnet.config.add_tridentnet_config": [[7, 27], ["detectron2.config.CfgNode"], "function", ["None"], ["from", "fvcore", ".", "common", ".", "config", "import", "CfgNode", "as", "_CfgNode", "\n", "from", "fvcore", ".", "common", ".", "file_io", "import", "PathManager", "\n", "\n", "\n", "class", "CfgNode", "(", "_CfgNode", ")", ":", "\n", "    ", "\"\"\"\n    The same as `fvcore.common.config.CfgNode`, but different in:\n\n    1. Use unsafe yaml loading by default.\n       Note that this may lead to arbitrary code execution: you must not\n       load a config file from untrusted sources before manually inspecting\n       the content of the file.\n    2. Support config versioning.\n       When attempting to merge an old config, it will convert the old config automatically.\n    \"\"\"", "\n", "\n", "# Note that the default value of allow_unsafe is changed to True", "\n", "def", "merge_from_file", "(", "self", ",", "cfg_filename", ":", "str", ",", "allow_unsafe", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "        ", "assert", "PathManager", ".", "isfile", "(", "cfg_filename", ")", ",", "f\"Config file '{cfg_filename}' does not exist!\"", "\n", "loaded_cfg", "=", "_CfgNode", ".", "load_yaml_with_base", "(", "cfg_filename", ",", "allow_unsafe", "=", "allow_unsafe", ")", "\n", "loaded_cfg", "=", "type", "(", "self", ")", "(", "loaded_cfg", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tridentnet.trident_rpn.TridentRPN.__init__": [[15, 20], ["detectron2.modeling.proposal_generator.rpn.RPN.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", "TridentRPN", ",", "self", ")", ".", "__init__", "(", "cfg", ",", "input_shape", ")", "\n", "\n", "self", ".", "num_branch", "=", "cfg", ".", "MODEL", ".", "TRIDENT", ".", "NUM_BRANCH", "\n", "self", ".", "trident_fast", "=", "cfg", ".", "MODEL", ".", "TRIDENT", ".", "TEST_BRANCH_IDX", "!=", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tridentnet.trident_rpn.TridentRPN.forward": [[21, 33], ["detectron2.structures.ImageList", "super().forward", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.forward", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "def", "forward", "(", "self", ",", "images", ",", "features", ",", "gt_instances", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        See :class:`RPN.forward`.\n        \"\"\"", "\n", "num_branch", "=", "self", ".", "num_branch", "if", "self", ".", "training", "or", "not", "self", ".", "trident_fast", "else", "1", "\n", "# Duplicate images and gt_instances for all branches in TridentNet.", "\n", "all_images", "=", "ImageList", "(", "\n", "torch", ".", "cat", "(", "[", "images", ".", "tensor", "]", "*", "num_branch", ")", ",", "images", ".", "image_sizes", "*", "num_branch", "\n", ")", "\n", "all_gt_instances", "=", "gt_instances", "*", "num_branch", "if", "gt_instances", "is", "not", "None", "else", "None", "\n", "\n", "return", "super", "(", "TridentRPN", ",", "self", ")", ".", "forward", "(", "all_images", ",", "features", ",", "all_gt_instances", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tridentnet.trident_conv.TridentConv.__init__": [[11, 57], ["torch.nn.Module.__init__", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "isinstance", "isinstance", "torch.nn.Parameter", "torch.nn.init.kaiming_uniform_", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "len", "torch.Tensor", "torch.nn.Parameter", "torch.nn.init.constant_", "torch.Tensor", "len", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", ",", "\n", "stride", "=", "1", ",", "\n", "paddings", "=", "0", ",", "\n", "dilations", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "num_branch", "=", "1", ",", "\n", "test_branch_idx", "=", "-", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "None", ",", "\n", "activation", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", "TridentConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "kernel_size", "=", "_pair", "(", "kernel_size", ")", "\n", "self", ".", "num_branch", "=", "num_branch", "\n", "self", ".", "stride", "=", "_pair", "(", "stride", ")", "\n", "self", ".", "groups", "=", "groups", "\n", "self", ".", "with_bias", "=", "bias", "\n", "if", "isinstance", "(", "paddings", ",", "int", ")", ":", "\n", "            ", "paddings", "=", "[", "paddings", "]", "*", "self", ".", "num_branch", "\n", "", "if", "isinstance", "(", "dilations", ",", "int", ")", ":", "\n", "            ", "dilations", "=", "[", "dilations", "]", "*", "self", ".", "num_branch", "\n", "", "self", ".", "paddings", "=", "[", "_pair", "(", "padding", ")", "for", "padding", "in", "paddings", "]", "\n", "self", ".", "dilations", "=", "[", "_pair", "(", "dilation", ")", "for", "dilation", "in", "dilations", "]", "\n", "self", ".", "test_branch_idx", "=", "test_branch_idx", "\n", "self", ".", "norm", "=", "norm", "\n", "self", ".", "activation", "=", "activation", "\n", "\n", "assert", "len", "(", "{", "self", ".", "num_branch", ",", "len", "(", "self", ".", "paddings", ")", ",", "len", "(", "self", ".", "dilations", ")", "}", ")", "==", "1", "\n", "\n", "self", ".", "weight", "=", "nn", ".", "Parameter", "(", "\n", "torch", ".", "Tensor", "(", "out_channels", ",", "in_channels", "//", "groups", ",", "*", "self", ".", "kernel_size", ")", "\n", ")", "\n", "if", "bias", ":", "\n", "            ", "self", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "out_channels", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "bias", "=", "None", "\n", "\n", "", "nn", ".", "init", ".", "kaiming_uniform_", "(", "self", ".", "weight", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "if", "self", ".", "bias", "is", "not", "None", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "self", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tridentnet.trident_conv.TridentConv.forward": [[58, 95], ["len", "inputs[].numel", "detectron2.layers.wrappers._NewEmptyTensorOp.apply", "torch.nn.functional.conv2d", "torch.nn.functional.conv2d", "trident_conv.TridentConv.norm", "trident_conv.TridentConv.activation", "zip", "zip"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.norm"], ["", "", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "num_branch", "=", "self", ".", "num_branch", "if", "self", ".", "training", "or", "self", ".", "test_branch_idx", "==", "-", "1", "else", "1", "\n", "assert", "len", "(", "inputs", ")", "==", "num_branch", "\n", "\n", "if", "inputs", "[", "0", "]", ".", "numel", "(", ")", "==", "0", ":", "\n", "            ", "output_shape", "=", "[", "\n", "(", "i", "+", "2", "*", "p", "-", "(", "di", "*", "(", "k", "-", "1", ")", "+", "1", ")", ")", "//", "s", "+", "1", "\n", "for", "i", ",", "p", ",", "di", ",", "k", ",", "s", "in", "zip", "(", "\n", "inputs", "[", "0", "]", ".", "shape", "[", "-", "2", ":", "]", ",", "self", ".", "padding", ",", "self", ".", "dilation", ",", "self", ".", "kernel_size", ",", "self", ".", "stride", "\n", ")", "\n", "]", "\n", "output_shape", "=", "[", "input", "[", "0", "]", ".", "shape", "[", "0", "]", ",", "self", ".", "weight", ".", "shape", "[", "0", "]", "]", "+", "output_shape", "\n", "return", "[", "_NewEmptyTensorOp", ".", "apply", "(", "input", ",", "output_shape", ")", "for", "input", "in", "inputs", "]", "\n", "\n", "", "if", "self", ".", "training", "or", "self", ".", "test_branch_idx", "==", "-", "1", ":", "\n", "            ", "outputs", "=", "[", "\n", "F", ".", "conv2d", "(", "input", ",", "self", ".", "weight", ",", "self", ".", "bias", ",", "self", ".", "stride", ",", "padding", ",", "dilation", ",", "self", ".", "groups", ")", "\n", "for", "input", ",", "dilation", ",", "padding", "in", "zip", "(", "inputs", ",", "self", ".", "dilations", ",", "self", ".", "paddings", ")", "\n", "]", "\n", "", "else", ":", "\n", "            ", "outputs", "=", "[", "\n", "F", ".", "conv2d", "(", "\n", "inputs", "[", "0", "]", ",", "\n", "self", ".", "weight", ",", "\n", "self", ".", "bias", ",", "\n", "self", ".", "stride", ",", "\n", "self", ".", "paddings", "[", "self", ".", "test_branch_idx", "]", ",", "\n", "self", ".", "dilations", "[", "self", ".", "test_branch_idx", "]", ",", "\n", "self", ".", "groups", ",", "\n", ")", "\n", "]", "\n", "\n", "", "if", "self", ".", "norm", "is", "not", "None", ":", "\n", "            ", "outputs", "=", "[", "self", ".", "norm", "(", "x", ")", "for", "x", "in", "outputs", "]", "\n", "", "if", "self", ".", "activation", "is", "not", "None", ":", "\n", "            ", "outputs", "=", "[", "self", ".", "activation", "(", "x", ")", "for", "x", "in", "outputs", "]", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tridentnet.trident_conv.TridentConv.extra_repr": [[96, 108], ["str", "str", "str", "str", "str", "str", "str", "str", "str", "str"], "methods", ["None"], ["", "def", "extra_repr", "(", "self", ")", ":", "\n", "        ", "tmpstr", "=", "\"in_channels=\"", "+", "str", "(", "self", ".", "in_channels", ")", "\n", "tmpstr", "+=", "\", out_channels=\"", "+", "str", "(", "self", ".", "out_channels", ")", "\n", "tmpstr", "+=", "\", kernel_size=\"", "+", "str", "(", "self", ".", "kernel_size", ")", "\n", "tmpstr", "+=", "\", num_branch=\"", "+", "str", "(", "self", ".", "num_branch", ")", "\n", "tmpstr", "+=", "\", test_branch_idx=\"", "+", "str", "(", "self", ".", "test_branch_idx", ")", "\n", "tmpstr", "+=", "\", stride=\"", "+", "str", "(", "self", ".", "stride", ")", "\n", "tmpstr", "+=", "\", paddings=\"", "+", "str", "(", "self", ".", "paddings", ")", "\n", "tmpstr", "+=", "\", dilations=\"", "+", "str", "(", "self", ".", "dilations", ")", "\n", "tmpstr", "+=", "\", groups=\"", "+", "str", "(", "self", ".", "groups", ")", "\n", "tmpstr", "+=", "\", bias=\"", "+", "str", "(", "self", ".", "with_bias", ")", "\n", "return", "tmpstr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tridentnet.trident_backbone.TridentBottleneckBlock.__init__": [[16, 94], ["detectron2.modeling.ResNetBlockBase.__init__", "detectron2.layers.Conv2d", "trident_conv.TridentConv", "detectron2.layers.Conv2d", "len", "detectron2.layers.Conv2d", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "fvcore.c2_msra_fill", "detectron2.layers.get_norm"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.get_norm"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "*", ",", "\n", "bottleneck_channels", ",", "\n", "stride", "=", "1", ",", "\n", "num_groups", "=", "1", ",", "\n", "norm", "=", "\"BN\"", ",", "\n", "stride_in_1x1", "=", "False", ",", "\n", "num_branch", "=", "3", ",", "\n", "dilations", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "concat_output", "=", "False", ",", "\n", "test_branch_idx", "=", "-", "1", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            num_branch (int): the number of branches in TridentNet.\n            dilations (tuple): the dilations of multiple branches in TridentNet.\n            concat_output (bool): if concatenate outputs of multiple branches in TridentNet.\n                Use 'True' for the last trident block.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "stride", ")", "\n", "\n", "assert", "num_branch", "==", "len", "(", "dilations", ")", "\n", "\n", "self", ".", "num_branch", "=", "num_branch", "\n", "self", ".", "concat_output", "=", "concat_output", "\n", "self", ".", "test_branch_idx", "=", "test_branch_idx", "\n", "\n", "if", "in_channels", "!=", "out_channels", ":", "\n", "            ", "self", ".", "shortcut", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "shortcut", "=", "None", "\n", "\n", "", "stride_1x1", ",", "stride_3x3", "=", "(", "stride", ",", "1", ")", "if", "stride_in_1x1", "else", "(", "1", ",", "stride", ")", "\n", "\n", "self", ".", "conv1", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "bottleneck_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride_1x1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "bottleneck_channels", ")", ",", "\n", ")", "\n", "\n", "self", ".", "conv2", "=", "TridentConv", "(", "\n", "bottleneck_channels", ",", "\n", "bottleneck_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride_3x3", ",", "\n", "paddings", "=", "dilations", ",", "\n", "bias", "=", "False", ",", "\n", "groups", "=", "num_groups", ",", "\n", "dilations", "=", "dilations", ",", "\n", "num_branch", "=", "num_branch", ",", "\n", "test_branch_idx", "=", "test_branch_idx", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "bottleneck_channels", ")", ",", "\n", ")", "\n", "\n", "self", ".", "conv3", "=", "Conv2d", "(", "\n", "bottleneck_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "\n", "for", "layer", "in", "[", "self", ".", "conv1", ",", "self", ".", "conv2", ",", "self", ".", "conv3", ",", "self", ".", "shortcut", "]", ":", "\n", "            ", "if", "layer", "is", "not", "None", ":", "# shortcut can be None", "\n", "                ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tridentnet.trident_backbone.TridentBottleneckBlock.forward": [[95, 117], ["trident_backbone.TridentBottleneckBlock.conv2", "isinstance", "trident_backbone.TridentBottleneckBlock.conv1", "torch.relu_", "torch.relu_", "torch.relu_", "torch.relu_", "trident_backbone.TridentBottleneckBlock.conv3", "torch.relu_", "torch.relu_", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "trident_backbone.TridentBottleneckBlock.shortcut", "zip"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "num_branch", "=", "self", ".", "num_branch", "if", "self", ".", "training", "or", "self", ".", "test_branch_idx", "==", "-", "1", "else", "1", "\n", "if", "not", "isinstance", "(", "x", ",", "list", ")", ":", "\n", "            ", "x", "=", "[", "x", "]", "*", "num_branch", "\n", "", "out", "=", "[", "self", ".", "conv1", "(", "b", ")", "for", "b", "in", "x", "]", "\n", "out", "=", "[", "F", ".", "relu_", "(", "b", ")", "for", "b", "in", "out", "]", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "[", "F", ".", "relu_", "(", "b", ")", "for", "b", "in", "out", "]", "\n", "\n", "out", "=", "[", "self", ".", "conv3", "(", "b", ")", "for", "b", "in", "out", "]", "\n", "\n", "if", "self", ".", "shortcut", "is", "not", "None", ":", "\n", "            ", "shortcut", "=", "[", "self", ".", "shortcut", "(", "b", ")", "for", "b", "in", "x", "]", "\n", "", "else", ":", "\n", "            ", "shortcut", "=", "x", "\n", "\n", "", "out", "=", "[", "out_b", "+", "shortcut_b", "for", "out_b", ",", "shortcut_b", "in", "zip", "(", "out", ",", "shortcut", ")", "]", "\n", "out", "=", "[", "F", ".", "relu_", "(", "b", ")", "for", "b", "in", "out", "]", "\n", "if", "self", ".", "concat_output", ":", "\n", "            ", "out", "=", "torch", ".", "cat", "(", "out", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tridentnet.trident_backbone.make_trident_stage": [[119, 129], ["range", "blocks.append", "blocks.append", "block_class", "block_class"], "function", ["None"], ["", "", "def", "make_trident_stage", "(", "block_class", ",", "num_blocks", ",", "first_stride", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Create a resnet stage by creating many blocks for TridentNet.\n    \"\"\"", "\n", "blocks", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_blocks", "-", "1", ")", ":", "\n", "        ", "blocks", ".", "append", "(", "block_class", "(", "stride", "=", "first_stride", "if", "i", "==", "0", "else", "1", ",", "**", "kwargs", ")", ")", "\n", "kwargs", "[", "\"in_channels\"", "]", "=", "kwargs", "[", "\"out_channels\"", "]", "\n", "", "blocks", ".", "append", "(", "block_class", "(", "stride", "=", "1", ",", "concat_output", "=", "True", ",", "**", "kwargs", ")", ")", "\n", "return", "blocks", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tridentnet.trident_backbone.build_trident_resnet_backbone": [[131, 224], ["detectron2.modeling.BACKBONE_REGISTRY.register", "detectron2.modeling.backbone.resnet.BasicStem", "max", "enumerate", "detectron2.modeling.ResNet", "FrozenBatchNorm2d.convert_frozen_batchnorm.parameters", "detectron2.layers.FrozenBatchNorm2d.convert_frozen_batchnorm", "range", "stages.append", "stage_kargs.pop", "trident_backbone.make_trident_stage", "detectron2.modeling.make_stage", "block.freeze"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.converters.base.BaseConverter.register", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.batch_norm.FrozenBatchNorm2d.convert_frozen_batchnorm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tridentnet.trident_backbone.make_trident_stage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbone.resnet.make_stage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze"], ["", "@", "BACKBONE_REGISTRY", ".", "register", "(", ")", "\n", "def", "build_trident_resnet_backbone", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Create a ResNet instance from config for TridentNet.\n\n    Returns:\n        ResNet: a :class:`ResNet` instance.\n    \"\"\"", "\n", "# need registration of new blocks/stems?", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "NORM", "\n", "stem", "=", "BasicStem", "(", "\n", "in_channels", "=", "input_shape", ".", "channels", ",", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "STEM_OUT_CHANNELS", ",", "\n", "norm", "=", "norm", ",", "\n", ")", "\n", "freeze_at", "=", "cfg", ".", "MODEL", ".", "BACKBONE", ".", "FREEZE_AT", "\n", "\n", "if", "freeze_at", ">=", "1", ":", "\n", "        ", "for", "p", "in", "stem", ".", "parameters", "(", ")", ":", "\n", "            ", "p", ".", "requires_grad", "=", "False", "\n", "", "stem", "=", "FrozenBatchNorm2d", ".", "convert_frozen_batchnorm", "(", "stem", ")", "\n", "\n", "# fmt: off", "\n", "", "out_features", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "OUT_FEATURES", "\n", "depth", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DEPTH", "\n", "num_groups", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "NUM_GROUPS", "\n", "width_per_group", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "WIDTH_PER_GROUP", "\n", "bottleneck_channels", "=", "num_groups", "*", "width_per_group", "\n", "in_channels", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "STEM_OUT_CHANNELS", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "RES2_OUT_CHANNELS", "\n", "stride_in_1x1", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "STRIDE_IN_1X1", "\n", "res5_dilation", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "RES5_DILATION", "\n", "deform_on_per_stage", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DEFORM_ON_PER_STAGE", "\n", "deform_modulated", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DEFORM_MODULATED", "\n", "deform_num_groups", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DEFORM_NUM_GROUPS", "\n", "num_branch", "=", "cfg", ".", "MODEL", ".", "TRIDENT", ".", "NUM_BRANCH", "\n", "branch_dilations", "=", "cfg", ".", "MODEL", ".", "TRIDENT", ".", "BRANCH_DILATIONS", "\n", "trident_stage", "=", "cfg", ".", "MODEL", ".", "TRIDENT", ".", "TRIDENT_STAGE", "\n", "test_branch_idx", "=", "cfg", ".", "MODEL", ".", "TRIDENT", ".", "TEST_BRANCH_IDX", "\n", "# fmt: on", "\n", "assert", "res5_dilation", "in", "{", "1", ",", "2", "}", ",", "\"res5_dilation cannot be {}.\"", ".", "format", "(", "res5_dilation", ")", "\n", "\n", "num_blocks_per_stage", "=", "{", "50", ":", "[", "3", ",", "4", ",", "6", ",", "3", "]", ",", "101", ":", "[", "3", ",", "4", ",", "23", ",", "3", "]", ",", "152", ":", "[", "3", ",", "8", ",", "36", ",", "3", "]", "}", "[", "depth", "]", "\n", "\n", "stages", "=", "[", "]", "\n", "\n", "res_stage_idx", "=", "{", "\"res2\"", ":", "2", ",", "\"res3\"", ":", "3", ",", "\"res4\"", ":", "4", ",", "\"res5\"", ":", "5", "}", "\n", "out_stage_idx", "=", "[", "res_stage_idx", "[", "f", "]", "for", "f", "in", "out_features", "]", "\n", "trident_stage_idx", "=", "res_stage_idx", "[", "trident_stage", "]", "\n", "max_stage_idx", "=", "max", "(", "out_stage_idx", ")", "\n", "for", "idx", ",", "stage_idx", "in", "enumerate", "(", "range", "(", "2", ",", "max_stage_idx", "+", "1", ")", ")", ":", "\n", "        ", "dilation", "=", "res5_dilation", "if", "stage_idx", "==", "5", "else", "1", "\n", "first_stride", "=", "1", "if", "idx", "==", "0", "or", "(", "stage_idx", "==", "5", "and", "dilation", "==", "2", ")", "else", "2", "\n", "stage_kargs", "=", "{", "\n", "\"num_blocks\"", ":", "num_blocks_per_stage", "[", "idx", "]", ",", "\n", "\"first_stride\"", ":", "first_stride", ",", "\n", "\"in_channels\"", ":", "in_channels", ",", "\n", "\"bottleneck_channels\"", ":", "bottleneck_channels", ",", "\n", "\"out_channels\"", ":", "out_channels", ",", "\n", "\"num_groups\"", ":", "num_groups", ",", "\n", "\"norm\"", ":", "norm", ",", "\n", "\"stride_in_1x1\"", ":", "stride_in_1x1", ",", "\n", "\"dilation\"", ":", "dilation", ",", "\n", "}", "\n", "if", "stage_idx", "==", "trident_stage_idx", ":", "\n", "            ", "assert", "not", "deform_on_per_stage", "[", "\n", "idx", "\n", "]", ",", "\"Not support deformable conv in Trident blocks yet.\"", "\n", "stage_kargs", "[", "\"block_class\"", "]", "=", "TridentBottleneckBlock", "\n", "stage_kargs", "[", "\"num_branch\"", "]", "=", "num_branch", "\n", "stage_kargs", "[", "\"dilations\"", "]", "=", "branch_dilations", "\n", "stage_kargs", "[", "\"test_branch_idx\"", "]", "=", "test_branch_idx", "\n", "stage_kargs", ".", "pop", "(", "\"dilation\"", ")", "\n", "", "elif", "deform_on_per_stage", "[", "idx", "]", ":", "\n", "            ", "stage_kargs", "[", "\"block_class\"", "]", "=", "DeformBottleneckBlock", "\n", "stage_kargs", "[", "\"deform_modulated\"", "]", "=", "deform_modulated", "\n", "stage_kargs", "[", "\"deform_num_groups\"", "]", "=", "deform_num_groups", "\n", "", "else", ":", "\n", "            ", "stage_kargs", "[", "\"block_class\"", "]", "=", "BottleneckBlock", "\n", "", "blocks", "=", "(", "\n", "make_trident_stage", "(", "**", "stage_kargs", ")", "\n", "if", "stage_idx", "==", "trident_stage_idx", "\n", "else", "make_stage", "(", "**", "stage_kargs", ")", "\n", ")", "\n", "in_channels", "=", "out_channels", "\n", "out_channels", "*=", "2", "\n", "bottleneck_channels", "*=", "2", "\n", "\n", "if", "freeze_at", ">=", "stage_idx", ":", "\n", "            ", "for", "block", "in", "blocks", ":", "\n", "                ", "block", ".", "freeze", "(", ")", "\n", "", "", "stages", ".", "append", "(", "blocks", ")", "\n", "", "return", "ResNet", "(", "stem", ",", "stages", ",", "out_features", "=", "out_features", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tridentnet.trident_rcnn.TridentRes5ROIHeads.__init__": [[54, 59], ["detectron2.modeling.roi_heads.roi_heads.Res5ROIHeads.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "cfg", ",", "input_shape", ")", "\n", "\n", "self", ".", "num_branch", "=", "cfg", ".", "MODEL", ".", "TRIDENT", ".", "NUM_BRANCH", "\n", "self", ".", "trident_fast", "=", "cfg", ".", "MODEL", ".", "TRIDENT", ".", "TEST_BRANCH_IDX", "!=", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tridentnet.trident_rcnn.TridentRes5ROIHeads.forward": [[60, 80], ["super().forward", "trident_rcnn.merge_branch_instances"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.forward", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tridentnet.trident_rcnn.merge_branch_instances"], ["", "def", "forward", "(", "self", ",", "images", ",", "features", ",", "proposals", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        See :class:`Res5ROIHeads.forward`.\n        \"\"\"", "\n", "num_branch", "=", "self", ".", "num_branch", "if", "self", ".", "training", "or", "not", "self", ".", "trident_fast", "else", "1", "\n", "all_targets", "=", "targets", "*", "num_branch", "if", "targets", "is", "not", "None", "else", "None", "\n", "pred_instances", ",", "losses", "=", "super", "(", ")", ".", "forward", "(", "images", ",", "features", ",", "proposals", ",", "all_targets", ")", "\n", "del", "images", ",", "all_targets", ",", "targets", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "pred_instances", ",", "losses", "\n", "", "else", ":", "\n", "            ", "pred_instances", "=", "merge_branch_instances", "(", "\n", "pred_instances", ",", "\n", "num_branch", ",", "\n", "self", ".", "box_predictor", ".", "test_nms_thresh", ",", "\n", "self", ".", "box_predictor", ".", "test_topk_per_image", ",", "\n", ")", "\n", "\n", "return", "pred_instances", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tridentnet.trident_rcnn.TridentStandardROIHeads.__init__": [[89, 94], ["detectron2.modeling.StandardROIHeads.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", "TridentStandardROIHeads", ",", "self", ")", ".", "__init__", "(", "cfg", ",", "input_shape", ")", "\n", "\n", "self", ".", "num_branch", "=", "cfg", ".", "MODEL", ".", "TRIDENT", ".", "NUM_BRANCH", "\n", "self", ".", "trident_fast", "=", "cfg", ".", "MODEL", ".", "TRIDENT", ".", "TEST_BRANCH_IDX", "!=", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tridentnet.trident_rcnn.TridentStandardROIHeads.forward": [[95, 117], ["super().forward", "trident_rcnn.merge_branch_instances"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.forward", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tridentnet.trident_rcnn.merge_branch_instances"], ["", "def", "forward", "(", "self", ",", "images", ",", "features", ",", "proposals", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        See :class:`Res5ROIHeads.forward`.\n        \"\"\"", "\n", "# Use 1 branch if using trident_fast during inference.", "\n", "num_branch", "=", "self", ".", "num_branch", "if", "self", ".", "training", "or", "not", "self", ".", "trident_fast", "else", "1", "\n", "# Duplicate targets for all branches in TridentNet.", "\n", "all_targets", "=", "targets", "*", "num_branch", "if", "targets", "is", "not", "None", "else", "None", "\n", "pred_instances", ",", "losses", "=", "super", "(", ")", ".", "forward", "(", "images", ",", "features", ",", "proposals", ",", "all_targets", ")", "\n", "del", "images", ",", "all_targets", ",", "targets", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "pred_instances", ",", "losses", "\n", "", "else", ":", "\n", "            ", "pred_instances", "=", "merge_branch_instances", "(", "\n", "pred_instances", ",", "\n", "num_branch", ",", "\n", "self", ".", "box_predictor", ".", "test_nms_thresh", ",", "\n", "self", ".", "box_predictor", ".", "test_topk_per_image", ",", "\n", ")", "\n", "\n", "return", "pred_instances", ",", "{", "}", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tridentnet.trident_rcnn.merge_branch_instances": [[8, 45], ["range", "len", "detectron2.structures.Instances.cat", "detectron2.layers.batched_nms", "results.append", "range"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.nms.batched_nms"], ["def", "merge_branch_instances", "(", "instances", ",", "num_branch", ",", "nms_thresh", ",", "topk_per_image", ")", ":", "\n", "    ", "\"\"\"\n    Merge detection results from different branches of TridentNet.\n    Return detection results by applying non-maximum suppression (NMS) on bounding boxes\n    and keep the unsuppressed boxes and other instances (e.g mask) if any.\n\n    Args:\n        instances (list[Instances]): A list of N * num_branch instances that store detection\n            results. Contain N images and each image has num_branch instances.\n        num_branch (int): Number of branches used for merging detection results for each image.\n        nms_thresh (float):  The threshold to use for box non-maximum suppression. Value in [0, 1].\n        topk_per_image (int): The number of top scoring detections to return. Set < 0 to return\n            all detections.\n\n    Returns:\n        results: (list[Instances]): A list of N instances, one for each image in the batch,\n            that stores the topk most confidence detections after merging results from multiple\n            branches.\n    \"\"\"", "\n", "if", "num_branch", "==", "1", ":", "\n", "        ", "return", "instances", "\n", "\n", "", "batch_size", "=", "len", "(", "instances", ")", "//", "num_branch", "\n", "results", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "        ", "instance", "=", "Instances", ".", "cat", "(", "[", "instances", "[", "i", "+", "batch_size", "*", "j", "]", "for", "j", "in", "range", "(", "num_branch", ")", "]", ")", "\n", "\n", "# Apply per-class NMS", "\n", "keep", "=", "batched_nms", "(", "\n", "instance", ".", "pred_boxes", ".", "tensor", ",", "instance", ".", "scores", ",", "instance", ".", "pred_classes", ",", "nms_thresh", "\n", ")", "\n", "keep", "=", "keep", "[", ":", "topk_per_image", "]", "\n", "result", "=", "instance", "[", "keep", "]", "\n", "\n", "results", ".", "append", "(", "result", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.Trainer.build_evaluator": [[60, 103], ["detectron2.evaluation.DatasetEvaluators", "detectron2.evaluation.DatasetEvaluators", "os.path.join", "detectron2.data.MetadataCatalog.get", "detectron2.data.MetadataCatalog.get", "detectron2.evaluation.LVISEvaluator", "detectron2.evaluation.LVISEvaluator", "detectron2.evaluation.COCOEvaluator", "detectron2.evaluation.COCOEvaluator", "detectron2.evaluation.SemSegEvaluator", "detectron2.evaluation.SemSegEvaluator", "detectron2.evaluation.CityscapesInstanceEvaluator", "detectron2.evaluation.CityscapesInstanceEvaluator", "detectron2.evaluation.CityscapesSemSegEvaluator", "detectron2.evaluation.CityscapesSemSegEvaluator", "len", "NotImplementedError", "len", "torch.cuda.device_count", "detectron2.get_rank", "detectron2.get_rank", "torch.cuda.device_count", "detectron2.get_rank", "detectron2.get_rank"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank"], ["if", "args", ".", "eval_only", ":", "\n", "        ", "model", "=", "Trainer", ".", "build_model", "(", "cfg", ")", "\n", "DetectionCheckpointer", "(", "\n", "model", ",", "save_dir", "=", "cfg", ".", "OUTPUT_DIR", ")", ".", "resume_or_load", "(", "\n", "cfg", ".", "MODEL", ".", "WEIGHTS", ",", "resume", "=", "args", ".", "resume", ")", "\n", "res", "=", "Trainer", ".", "test", "(", "cfg", ",", "model", ")", "\n", "return", "res", "\n", "\n", "", "trainer", "=", "Trainer", "(", "cfg", ")", "\n", "trainer", ".", "resume_or_load", "(", "resume", "=", "args", ".", "resume", ")", "\n", "return", "trainer", ".", "train", "(", ")", "\n", "\n", "\n", "", "if", "__name__", "==", "\"__main__\"", ":", "\n", "    ", "args", "=", "default_argument_parser", "(", ")", ".", "parse_args", "(", ")", "\n", "\n", "print", "(", "\"Command Line Args:\"", ",", "args", ")", "\n", "launch", "(", "\n", "main", ",", "\n", "args", ".", "num_gpus", ",", "\n", "num_machines", "=", "args", ".", "num_machines", ",", "\n", "machine_rank", "=", "args", ".", "machine_rank", ",", "\n", "dist_url", "=", "args", ".", "dist_url", ",", "\n", "args", "=", "(", "args", ",", ")", ",", "\n", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.Trainer.build_train_loader": [[104, 111], ["detectron2.data.build_detection_train_loader", "detectron2.data.build_detection_train_loader", "detectron2.data.DatasetMapper", "detectron2.data.DatasetMapper", "train_net.build_sem_seg_train_aug"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.build_sem_seg_train_aug"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.build_sem_seg_train_aug": [[31, 50], ["augs.append", "detectron2.ResizeShortestEdge", "augs.append", "augs.append", "detectron2.RandomFlip", "detectron2.RandomCrop_CategoryAreaConstraint", "detectron2.projects.point_rend.ColorAugSSDTransform"], "function", ["None"], ["norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", "\n", "seq", ".", "add_module", "(", "\"norm\"", ",", "norm", ")", "\n", "return", "seq", ",", "out_channels", "\n", "\n", "\n", "", "", "class", "Trainer", "(", "DefaultTrainer", ")", ":", "\n", "\n", "    ", "@", "classmethod", "\n", "def", "build_evaluator", "(", "cls", ",", "cfg", ",", "dataset_name", ",", "output_folder", "=", "None", ")", ":", "\n", "        ", "if", "output_folder", "is", "None", ":", "\n", "            ", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference\"", ")", "\n", "", "if", "\"voc\"", "in", "dataset_name", ":", "\n", "            ", "return", "PascalVOCDetectionEvaluator", "(", "dataset_name", ")", "\n", "", "else", ":", "\n", "            ", "return", "COCOEvaluator", "(", "dataset_name", ",", "cfg", ",", "True", ",", "output_folder", ")", "\n", "\n", "\n", "", "", "", "def", "setup", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.setup": [[113, 124], ["detectron2.config.get_cfg", "detectron2.projects.point_rend.add_pointrend_config", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.engine.default_setup"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.get_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.config.add_pointrend_config", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.default_setup"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.main": [[126, 142], ["train_net.setup", "train_net.Trainer", "Trainer.resume_or_load", "Trainer.train", "Trainer.build_model", "detectron2.checkpoint.DetectionCheckpointer().resume_or_load", "Trainer.test", "detectron2.is_main_process", "detectron2.evaluation.verify_results", "detectron2.checkpoint.DetectionCheckpointer"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.PointRend.train_net.setup", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tests.test_packaging.TestCollectEnv.test", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.is_main_process", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.evaluation.testing.verify_results"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.config.add_pointrend_config": [[7, 49], ["detectron2.config.CfgNode"], "function", ["None"], ["from", "fvcore", ".", "common", ".", "config", "import", "CfgNode", "as", "_CfgNode", "\n", "from", "fvcore", ".", "common", ".", "file_io", "import", "PathManager", "\n", "\n", "\n", "class", "CfgNode", "(", "_CfgNode", ")", ":", "\n", "    ", "\"\"\"\n    The same as `fvcore.common.config.CfgNode`, but different in:\n\n    1. Use unsafe yaml loading by default.\n       Note that this may lead to arbitrary code execution: you must not\n       load a config file from untrusted sources before manually inspecting\n       the content of the file.\n    2. Support config versioning.\n       When attempting to merge an old config, it will convert the old config automatically.\n    \"\"\"", "\n", "\n", "# Note that the default value of allow_unsafe is changed to True", "\n", "def", "merge_from_file", "(", "self", ",", "cfg_filename", ":", "str", ",", "allow_unsafe", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "        ", "assert", "PathManager", ".", "isfile", "(", "cfg_filename", ")", ",", "f\"Config file '{cfg_filename}' does not exist!\"", "\n", "loaded_cfg", "=", "_CfgNode", ".", "load_yaml_with_base", "(", "cfg_filename", ",", "allow_unsafe", "=", "allow_unsafe", ")", "\n", "loaded_cfg", "=", "type", "(", "self", ")", "(", "loaded_cfg", ")", "\n", "\n", "# defaults.py needs to import CfgNode", "\n", "from", ".", "defaults", "import", "_C", "\n", "\n", "latest_ver", "=", "_C", ".", "VERSION", "\n", "assert", "(", "\n", "latest_ver", "==", "self", ".", "VERSION", "\n", ")", ",", "\"CfgNode.merge_from_file is only allowed on a config object of latest version!\"", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "loaded_ver", "=", "loaded_cfg", ".", "get", "(", "\"VERSION\"", ",", "None", ")", "\n", "if", "loaded_ver", "is", "None", ":", "\n", "            ", "from", ".", "compat", "import", "guess_version", "\n", "\n", "loaded_ver", "=", "guess_version", "(", "loaded_cfg", ",", "cfg_filename", ")", "\n", "", "assert", "loaded_ver", "<=", "self", ".", "VERSION", ",", "\"Cannot merge a v{} config into a v{} config.\"", ".", "format", "(", "\n", "loaded_ver", ",", "self", ".", "VERSION", "\n", ")", "\n", "\n", "if", "loaded_ver", "==", "self", ".", "VERSION", ":", "\n", "            ", "self", ".", "merge_from_other_cfg", "(", "loaded_cfg", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.roi_heads.PointRendROIHeads.__init__": [[60, 64], ["detectron2.modeling.StandardROIHeads.__init__", "roi_heads.PointRendROIHeads._init_mask_head"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.roi_heads.PointRendROIHeads._init_mask_head"], ["\n", "assert", "isinstance", "(", "proposals", ",", "(", "list", ",", "tuple", ")", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.roi_heads.PointRendROIHeads._init_mask_head": [[65, 85], ["numpy.sum", "detectron2.modeling.roi_heads.mask_head.build_mask_head", "roi_heads.PointRendROIHeads._init_point_head", "detectron2.layers.ShapeSpec", "input_shape.items"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.mask_head.build_mask_head", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.semantic_seg.PointRendSemSegHead._init_point_head"], ["assert", "isinstance", "(", "proposals", "[", "0", "]", ",", "Instances", ")", "\n", "assert", "proposals", "[", "0", "]", ".", "has", "(", "\"gt_classes\"", ")", "\n", "fg_proposals", "=", "[", "]", "\n", "fg_selection_masks", "=", "[", "]", "\n", "for", "proposals_per_image", "in", "proposals", ":", "\n", "        ", "gt_classes", "=", "proposals_per_image", ".", "gt_classes", "\n", "fg_selection_mask", "=", "(", "gt_classes", "!=", "-", "1", ")", "&", "(", "gt_classes", "!=", "bg_label", ")", "\n", "fg_idxs", "=", "fg_selection_mask", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "fg_proposals", ".", "append", "(", "proposals_per_image", "[", "fg_idxs", "]", ")", "\n", "fg_selection_masks", ".", "append", "(", "fg_selection_mask", ")", "\n", "", "return", "fg_proposals", ",", "fg_selection_masks", "\n", "\n", "\n", "", "def", "select_proposals_with_visible_keypoints", "(", "proposals", ":", "List", "[", "Instances", "]", ")", "->", "List", "[", "Instances", "]", ":", "\n", "    "]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.roi_heads.PointRendROIHeads._init_point_head": [[86, 104], ["numpy.sum", "point_head.build_point_head", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_head.build_point_head"], ["\n", "ret", "=", "[", "]", "\n", "all_num_fg", "=", "[", "]", "\n", "for", "proposals_per_image", "in", "proposals", ":", "\n", "# If empty/unannotated image (hard negatives), skip filtering for train", "\n", "        ", "if", "len", "(", "proposals_per_image", ")", "==", "0", ":", "\n", "            ", "ret", ".", "append", "(", "proposals_per_image", ")", "\n", "continue", "\n", "", "gt_keypoints", "=", "proposals_per_image", ".", "gt_keypoints", ".", "tensor", "\n", "# #fg x K x 3", "\n", "vis_mask", "=", "gt_keypoints", "[", ":", ",", ":", ",", "2", "]", ">=", "1", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.roi_heads.PointRendROIHeads._forward_mask": [[106, 138], ["detectron2.modeling.roi_heads.roi_heads.select_foreground_proposals", "roi_heads.PointRendROIHeads._forward_mask_coarse", "losses.update", "roi_heads.PointRendROIHeads._forward_mask_coarse", "roi_heads.PointRendROIHeads._forward_mask_point", "detectron2.modeling.roi_heads.mask_head.mask_rcnn_inference", "detectron2.modeling.roi_heads.mask_head.mask_rcnn_loss", "roi_heads.PointRendROIHeads._forward_mask_point"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.roi_heads.select_foreground_proposals", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.roi_heads.PointRendROIHeads._forward_mask_coarse", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.roi_heads.PointRendROIHeads._forward_mask_coarse", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.roi_heads.PointRendROIHeads._forward_mask_point", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.mask_head.mask_rcnn_inference", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.roi_heads.mask_head.mask_rcnn_loss", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.roi_heads.PointRendROIHeads._forward_mask_point"], ["proposal_boxes", "=", "proposals_per_image", ".", "proposal_boxes", ".", "tensor", ".", "unsqueeze", "(", "dim", "=", "1", ")", "# #fg x 1 x 4", "\n", "kp_in_box", "=", "(", "\n", "(", "xs", ">=", "proposal_boxes", "[", ":", ",", ":", ",", "0", "]", ")", "\n", "&", "(", "xs", "<=", "proposal_boxes", "[", ":", ",", ":", ",", "2", "]", ")", "\n", "&", "(", "ys", ">=", "proposal_boxes", "[", ":", ",", ":", ",", "1", "]", ")", "\n", "&", "(", "ys", "<=", "proposal_boxes", "[", ":", ",", ":", ",", "3", "]", ")", "\n", ")", "\n", "selection", "=", "(", "kp_in_box", "&", "vis_mask", ")", ".", "any", "(", "dim", "=", "1", ")", "\n", "selection_idxs", "=", "nonzero_tuple", "(", "selection", ")", "[", "0", "]", "\n", "all_num_fg", ".", "append", "(", "selection_idxs", ".", "numel", "(", ")", ")", "\n", "ret", ".", "append", "(", "proposals_per_image", "[", "selection_idxs", "]", ")", "\n", "\n", "", "storage", "=", "get_event_storage", "(", ")", "\n", "storage", ".", "put_scalar", "(", "\"keypoint_head/num_fg_samples\"", ",", "np", ".", "mean", "(", "all_num_fg", ")", ")", "\n", "return", "ret", "\n", "\n", "\n", "", "class", "ROIHeads", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "    ", "\"\"\"\n    ROIHeads perform all per-region computation in an R-CNN.\n\n    It typically contains logic to\n\n    1. (in training only) match proposals with ground truth and sample them\n    2. crop the regions and extract per-region features using proposals\n    3. make per-region predictions with different heads\n\n    It can have many variants, implemented as subclasses of this class.\n    This base class contains the logic to match/sample proposals.\n    But it is not necessary to inherit this class if the sampling logic is not needed.\n    \"\"\"", "\n", "\n", "@", "configurable", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.roi_heads.PointRendROIHeads._forward_mask_coarse": [[139, 154], ["point_features.generate_regular_grid_point_coords", "point_features.point_sample_fine_grained_features", "roi_heads.PointRendROIHeads.mask_coarse_head", "numpy.sum", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.generate_regular_grid_point_coords", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.point_sample_fine_grained_features"], ["def", "__init__", "(", "\n", "self", ",", "\n", "*", ",", "\n", "num_classes", ",", "\n", "batch_size_per_image", ",", "\n", "positive_fraction", ",", "\n", "proposal_matcher", ",", "\n", "proposal_append_gt", "=", "True", "\n", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.roi_heads.PointRendROIHeads._forward_mask_point": [[155, 228], ["detectron2.layers.cat", "point_features.point_sample_fine_grained_features", "point_features.point_sample", "roi_heads.PointRendROIHeads.mask_point_head", "detectron2.layers.cat", "mask_coarse_logits.clone", "range", "torch.no_grad", "point_features.get_uncertain_point_coords_with_randomness", "point_head.roi_mask_point_loss", "len", "detectron2.layers.interpolate", "roi_heads.calculate_uncertainty", "point_features.get_uncertain_point_coords_on_grid", "point_features.point_sample_fine_grained_features", "point_features.point_sample", "roi_heads.PointRendROIHeads.mask_point_head", "point_indices.unsqueeze().expand.unsqueeze().expand.unsqueeze().expand", "mask_logits.reshape().scatter_().view.reshape().scatter_().view.reshape().scatter_().view", "roi_heads.calculate_uncertainty", "point_indices.unsqueeze().expand.unsqueeze().expand.unsqueeze", "mask_logits.reshape().scatter_().view.reshape().scatter_().view.reshape().scatter_", "mask_logits.reshape().scatter_().view.reshape().scatter_().view.reshape"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.point_sample_fine_grained_features", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.point_sample", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.get_uncertain_point_coords_with_randomness", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_head.roi_mask_point_loss", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.semantic_seg.calculate_uncertainty", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.get_uncertain_point_coords_on_grid", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.point_sample_fine_grained_features", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.point_sample", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.semantic_seg.calculate_uncertainty"], ["\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "batch_size_per_image", "=", "batch_size_per_image", "\n", "self", ".", "positive_fraction", "=", "positive_fraction", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "proposal_matcher", "=", "proposal_matcher", "\n", "self", ".", "proposal_append_gt", "=", "proposal_append_gt", "\n", "\n", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "return", "{", "\n", "\"batch_size_per_image\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "BATCH_SIZE_PER_IMAGE", ",", "\n", "\"positive_fraction\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "POSITIVE_FRACTION", ",", "\n", "\"num_classes\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NUM_CLASSES", ",", "\n", "\"proposal_append_gt\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "PROPOSAL_APPEND_GT", ",", "\n", "# Matcher to assign box proposals to gt boxes", "\n", "\"proposal_matcher\"", ":", "Matcher", "(", "\n", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IOU_THRESHOLDS", ",", "\n", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IOU_LABELS", ",", "\n", "allow_low_quality_matches", "=", "False", ",", "\n", ")", ",", "\n", "}", "\n", "\n", "", "def", "_sample_proposals", "(", "\n", "self", ",", "matched_idxs", ":", "torch", ".", "Tensor", ",", "matched_labels", ":", "torch", ".", "Tensor", ",", "gt_classes", ":", "torch", ".", "Tensor", "\n", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Based on the matching between N proposals and M groundtruth,\n        sample the proposals and set their classification labels.\n\n        Args:\n            matched_idxs (Tensor): a vector of length N, each is the best-matched\n                gt index in [0, M) for each proposal.\n            matched_labels (Tensor): a vector of length N, the matcher's label\n                (one of cfg.MODEL.ROI_HEADS.IOU_LABELS) for each proposal.\n            gt_classes (Tensor): a vector of length M.\n\n        Returns:\n            Tensor: a vector of indices of sampled proposals. Each is in [0, N).\n            Tensor: a vector of the same length, the classification label for\n                each sampled proposal. Each sample is labeled as either a category in\n                [0, num_classes) or the background (num_classes).\n        \"\"\"", "\n", "has_gt", "=", "gt_classes", ".", "numel", "(", ")", ">", "0", "\n", "# Get the corresponding GT for each proposal", "\n", "if", "has_gt", ":", "\n", "            ", "gt_classes", "=", "gt_classes", "[", "matched_idxs", "]", "\n", "# Label unmatched proposals (0 label from matcher) as background (label=num_classes)", "\n", "gt_classes", "[", "matched_labels", "==", "0", "]", "=", "self", ".", "num_classes", "\n", "# Label ignore proposals (-1 label)", "\n", "gt_classes", "[", "matched_labels", "==", "-", "1", "]", "=", "-", "1", "\n", "", "else", ":", "\n", "            ", "gt_classes", "=", "torch", ".", "zeros_like", "(", "matched_idxs", ")", "+", "self", ".", "num_classes", "\n", "\n", "", "sampled_fg_idxs", ",", "sampled_bg_idxs", "=", "subsample_labels", "(", "\n", "gt_classes", ",", "self", ".", "batch_size_per_image", ",", "self", ".", "positive_fraction", ",", "self", ".", "num_classes", "\n", ")", "\n", "\n", "sampled_idxs", "=", "torch", ".", "cat", "(", "[", "sampled_fg_idxs", ",", "sampled_bg_idxs", "]", ",", "dim", "=", "0", ")", "\n", "return", "sampled_idxs", ",", "gt_classes", "[", "sampled_idxs", "]", "\n", "\n", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "label_and_sample_proposals", "(", "\n", "self", ",", "proposals", ":", "List", "[", "Instances", "]", ",", "targets", ":", "List", "[", "Instances", "]", "\n", ")", "->", "List", "[", "Instances", "]", ":", "\n", "        "]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.roi_heads.calculate_uncertainty": [[25, 48], ["logits.clone", "logits[].unsqueeze", "torch.abs", "torch.arange"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone"], ["ROI_HEADS_REGISTRY", "=", "Registry", "(", "\"ROI_HEADS\"", ")", "\n", "ROI_HEADS_REGISTRY", ".", "__doc__", "=", "\"\"\"\nRegistry for ROI heads in a generalized R-CNN model.\nROIHeads take feature maps and region proposals, and\nperform per-region computation.\n\nThe registered object will be called with `obj(cfg, input_shape)`.\nThe call is expected to return an :class:`ROIHeads`.\n\"\"\"", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "\n", "def", "build_roi_heads", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build ROIHeads defined by `cfg.MODEL.ROI_HEADS.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NAME", "\n", "return", "ROI_HEADS_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "\n", "\n", "", "def", "select_foreground_proposals", "(", "\n", "proposals", ":", "List", "[", "Instances", "]", ",", "bg_label", ":", "int", "\n", ")", "->", "Tuple", "[", "List", "[", "Instances", "]", ",", "List", "[", "torch", ".", "Tensor", "]", "]", ":", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.point_sample": [[19, 43], ["torch.nn.functional.grid_sample", "point_coords.unsqueeze.dim", "point_coords.unsqueeze.unsqueeze", "output.squeeze.squeeze"], "function", ["None"], ["def", "point_sample", "(", "input", ",", "point_coords", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    A wrapper around :function:`torch.nn.functional.grid_sample` to support 3D point_coords tensors.\n    Unlike :function:`torch.nn.functional.grid_sample` it assumes `point_coords` to lie inside\n    [0, 1] x [0, 1] square.\n\n    Args:\n        input (Tensor): A tensor of shape (N, C, H, W) that contains features map on a H x W grid.\n        point_coords (Tensor): A tensor of shape (N, P, 2) or (N, Hgrid, Wgrid, 2) that contains\n        [0, 1] x [0, 1] normalized point coordinates.\n\n    Returns:\n        output (Tensor): A tensor of shape (N, C, P) or (N, C, Hgrid, Wgrid) that contains\n            features for points in `point_coords`. The features are obtained via bilinear\n            interplation from `input` the same way as :function:`torch.nn.functional.grid_sample`.\n    \"\"\"", "\n", "add_dim", "=", "False", "\n", "if", "point_coords", ".", "dim", "(", ")", "==", "3", ":", "\n", "        ", "add_dim", "=", "True", "\n", "point_coords", "=", "point_coords", ".", "unsqueeze", "(", "2", ")", "\n", "", "output", "=", "F", ".", "grid_sample", "(", "input", ",", "2.0", "*", "point_coords", "-", "1.0", ",", "**", "kwargs", ")", "\n", "if", "add_dim", ":", "\n", "        ", "output", "=", "output", ".", "squeeze", "(", "3", ")", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.generate_regular_grid_point_coords": [[45, 61], ["torch.tensor", "torch.nn.functional.affine_grid", "F.affine_grid.view().expand", "torch.Size", "F.affine_grid.view"], "function", ["None"], ["", "def", "generate_regular_grid_point_coords", "(", "R", ",", "side_size", ",", "device", ")", ":", "\n", "    ", "\"\"\"\n    Generate regular square grid of points in [0, 1] x [0, 1] coordinate space.\n\n    Args:\n        R (int): The number of grids to sample, one for each region.\n        side_size (int): The side size of the regular grid.\n        device (torch.device): Desired device of returned tensor.\n\n    Returns:\n        (Tensor): A tensor of shape (R, side_size^2, 2) that contains coordinates\n            for the regular grids.\n    \"\"\"", "\n", "aff", "=", "torch", ".", "tensor", "(", "[", "[", "[", "0.5", ",", "0", ",", "0.5", "]", ",", "[", "0", ",", "0.5", ",", "0.5", "]", "]", "]", ",", "device", "=", "device", ")", "\n", "r", "=", "F", ".", "affine_grid", "(", "aff", ",", "torch", ".", "Size", "(", "(", "1", ",", "1", ",", "side_size", ",", "side_size", ")", ")", ",", "align_corners", "=", "False", ")", "\n", "return", "r", ".", "view", "(", "1", ",", "-", "1", ",", "2", ")", ".", "expand", "(", "R", ",", "-", "1", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.get_uncertain_point_coords_with_randomness": [[63, 117], ["int", "torch.rand", "point_features.point_sample", "uncertainty_func", "int", "[].view", "torch.topk", "torch.arange", "detectron2.layers.cat", "detectron2.layers.cat.view", "torch.rand", "idx.view"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.point_sample", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "def", "get_uncertain_point_coords_with_randomness", "(", "\n", "coarse_logits", ",", "uncertainty_func", ",", "num_points", ",", "oversample_ratio", ",", "importance_sample_ratio", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Sample points in [0, 1] x [0, 1] coordinate space based on their uncertainty. The unceratinties\n        are calculated for each point using 'uncertainty_func' function that takes point's logit\n        prediction as input.\n    See PointRend paper for details.\n\n    Args:\n        coarse_logits (Tensor): A tensor of shape (N, C, Hmask, Wmask) or (N, 1, Hmask, Wmask) for\n            class-specific or class-agnostic prediction.\n        uncertainty_func: A function that takes a Tensor of shape (N, C, P) or (N, 1, P) that\n            contains logit predictions for P points and returns their uncertainties as a Tensor of\n            shape (N, 1, P).\n        num_points (int): The number of points P to sample.\n        oversample_ratio (int): Oversampling parameter.\n        importance_sample_ratio (float): Ratio of points that are sampled via importnace sampling.\n\n    Returns:\n        point_coords (Tensor): A tensor of shape (N, P, 2) that contains the coordinates of P\n            sampled points.\n    \"\"\"", "\n", "assert", "oversample_ratio", ">=", "1", "\n", "assert", "importance_sample_ratio", "<=", "1", "and", "importance_sample_ratio", ">=", "0", "\n", "num_boxes", "=", "coarse_logits", ".", "shape", "[", "0", "]", "\n", "num_sampled", "=", "int", "(", "num_points", "*", "oversample_ratio", ")", "\n", "point_coords", "=", "torch", ".", "rand", "(", "num_boxes", ",", "num_sampled", ",", "2", ",", "device", "=", "coarse_logits", ".", "device", ")", "\n", "point_logits", "=", "point_sample", "(", "coarse_logits", ",", "point_coords", ",", "align_corners", "=", "False", ")", "\n", "# It is crucial to calculate uncertainty based on the sampled prediction value for the points.", "\n", "# Calculating uncertainties of the coarse predictions first and sampling them for points leads", "\n", "# to incorrect results.", "\n", "# To illustrate this: assume uncertainty_func(logits)=-abs(logits), a sampled point between", "\n", "# two coarse predictions with -1 and 1 logits has 0 logits, and therefore 0 uncertainty value.", "\n", "# However, if we calculate uncertainties for the coarse predictions first,", "\n", "# both will have -1 uncertainty, and the sampled point will get -1 uncertainty.", "\n", "point_uncertainties", "=", "uncertainty_func", "(", "point_logits", ")", "\n", "num_uncertain_points", "=", "int", "(", "importance_sample_ratio", "*", "num_points", ")", "\n", "num_random_points", "=", "num_points", "-", "num_uncertain_points", "\n", "idx", "=", "torch", ".", "topk", "(", "point_uncertainties", "[", ":", ",", "0", ",", ":", "]", ",", "k", "=", "num_uncertain_points", ",", "dim", "=", "1", ")", "[", "1", "]", "\n", "shift", "=", "num_sampled", "*", "torch", ".", "arange", "(", "num_boxes", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "coarse_logits", ".", "device", ")", "\n", "idx", "+=", "shift", "[", ":", ",", "None", "]", "\n", "point_coords", "=", "point_coords", ".", "view", "(", "-", "1", ",", "2", ")", "[", "idx", ".", "view", "(", "-", "1", ")", ",", ":", "]", ".", "view", "(", "\n", "num_boxes", ",", "num_uncertain_points", ",", "2", "\n", ")", "\n", "if", "num_random_points", ">", "0", ":", "\n", "        ", "point_coords", "=", "cat", "(", "\n", "[", "\n", "point_coords", ",", "\n", "torch", ".", "rand", "(", "num_boxes", ",", "num_random_points", ",", "2", ",", "device", "=", "coarse_logits", ".", "device", ")", ",", "\n", "]", ",", "\n", "dim", "=", "1", ",", "\n", ")", "\n", "", "return", "point_coords", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.get_uncertain_point_coords_on_grid": [[119, 144], ["min", "torch.zeros", "float", "float", "torch.topk", "uncertainty_map.view"], "function", ["None"], ["", "def", "get_uncertain_point_coords_on_grid", "(", "uncertainty_map", ",", "num_points", ")", ":", "\n", "    ", "\"\"\"\n    Find `num_points` most uncertain points from `uncertainty_map` grid.\n\n    Args:\n        uncertainty_map (Tensor): A tensor of shape (N, 1, H, W) that contains uncertainty\n            values for a set of points on a regular H x W grid.\n        num_points (int): The number of points P to select.\n\n    Returns:\n        point_indices (Tensor): A tensor of shape (N, P) that contains indices from\n            [0, H x W) of the most uncertain points.\n        point_coords (Tensor): A tensor of shape (N, P, 2) that contains [0, 1] x [0, 1] normalized\n            coordinates of the most uncertain points from the H x W grid.\n    \"\"\"", "\n", "R", ",", "_", ",", "H", ",", "W", "=", "uncertainty_map", ".", "shape", "\n", "h_step", "=", "1.0", "/", "float", "(", "H", ")", "\n", "w_step", "=", "1.0", "/", "float", "(", "W", ")", "\n", "\n", "num_points", "=", "min", "(", "H", "*", "W", ",", "num_points", ")", "\n", "point_indices", "=", "torch", ".", "topk", "(", "uncertainty_map", ".", "view", "(", "R", ",", "H", "*", "W", ")", ",", "k", "=", "num_points", ",", "dim", "=", "1", ")", "[", "1", "]", "\n", "point_coords", "=", "torch", ".", "zeros", "(", "R", ",", "num_points", ",", "2", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "uncertainty_map", ".", "device", ")", "\n", "point_coords", "[", ":", ",", ":", ",", "0", "]", "=", "w_step", "/", "2.0", "+", "(", "point_indices", "%", "W", ")", ".", "to", "(", "torch", ".", "float", ")", "*", "w_step", "\n", "point_coords", "[", ":", ",", ":", ",", "1", "]", "=", "h_step", "/", "2.0", "+", "(", "point_indices", "//", "W", ")", ".", "to", "(", "torch", ".", "float", ")", "*", "h_step", "\n", "return", "point_indices", ",", "point_coords", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.point_sample_fine_grained_features": [[146, 190], ["detectron2.structures.Boxes.cat", "point_features.get_point_coords_wrt_image", "torch.split", "enumerate", "len", "enumerate", "point_features.append", "detectron2.layers.cat", "point_features_per_image.append", "detectron2.layers.cat", "torch.tensor", "point_sample().squeeze().transpose", "point_sample().squeeze", "point_features.point_sample", "feature_map[].unsqueeze", "point_coords_scaled.unsqueeze"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.get_point_coords_wrt_image", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.point_sample"], ["", "def", "point_sample_fine_grained_features", "(", "features_list", ",", "feature_scales", ",", "boxes", ",", "point_coords", ")", ":", "\n", "    ", "\"\"\"\n    Get features from feature maps in `features_list` that correspond to specific point coordinates\n        inside each bounding box from `boxes`.\n\n    Args:\n        features_list (list[Tensor]): A list of feature map tensors to get features from.\n        feature_scales (list[float]): A list of scales for tensors in `features_list`.\n        boxes (list[Boxes]): A list of I Boxes  objects that contain R_1 + ... + R_I = R boxes all\n            together.\n        point_coords (Tensor): A tensor of shape (R, P, 2) that contains\n            [0, 1] x [0, 1] box-normalized coordinates of the P sampled points.\n\n    Returns:\n        point_features (Tensor): A tensor of shape (R, C, P) that contains features sampled\n            from all features maps in feature_list for P sampled points for all R boxes in `boxes`.\n        point_coords_wrt_image (Tensor): A tensor of shape (R, P, 2) that contains image-level\n            coordinates of P points.\n    \"\"\"", "\n", "cat_boxes", "=", "Boxes", ".", "cat", "(", "boxes", ")", "\n", "num_boxes", "=", "[", "len", "(", "b", ")", "for", "b", "in", "boxes", "]", "\n", "\n", "point_coords_wrt_image", "=", "get_point_coords_wrt_image", "(", "cat_boxes", ".", "tensor", ",", "point_coords", ")", "\n", "split_point_coords_wrt_image", "=", "torch", ".", "split", "(", "point_coords_wrt_image", ",", "num_boxes", ")", "\n", "\n", "point_features", "=", "[", "]", "\n", "for", "idx_img", ",", "point_coords_wrt_image_per_image", "in", "enumerate", "(", "split_point_coords_wrt_image", ")", ":", "\n", "        ", "point_features_per_image", "=", "[", "]", "\n", "for", "idx_feature", ",", "feature_map", "in", "enumerate", "(", "features_list", ")", ":", "\n", "            ", "h", ",", "w", "=", "feature_map", ".", "shape", "[", "-", "2", ":", "]", "\n", "scale", "=", "torch", ".", "tensor", "(", "[", "w", ",", "h", "]", ",", "device", "=", "feature_map", ".", "device", ")", "/", "feature_scales", "[", "idx_feature", "]", "\n", "point_coords_scaled", "=", "point_coords_wrt_image_per_image", "/", "scale", "\n", "point_features_per_image", ".", "append", "(", "\n", "point_sample", "(", "\n", "feature_map", "[", "idx_img", "]", ".", "unsqueeze", "(", "0", ")", ",", "\n", "point_coords_scaled", ".", "unsqueeze", "(", "0", ")", ",", "\n", "align_corners", "=", "False", ",", "\n", ")", "\n", ".", "squeeze", "(", "0", ")", "\n", ".", "transpose", "(", "1", ",", "0", ")", "\n", ")", "\n", "", "point_features", ".", "append", "(", "cat", "(", "point_features_per_image", ",", "dim", "=", "1", ")", ")", "\n", "\n", "", "return", "cat", "(", "point_features", ",", "dim", "=", "0", ")", ",", "point_coords_wrt_image", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.get_point_coords_wrt_image": [[192, 217], ["torch.no_grad", "point_coords.clone"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone"], ["", "def", "get_point_coords_wrt_image", "(", "boxes_coords", ",", "point_coords", ")", ":", "\n", "    ", "\"\"\"\n    Convert box-normalized [0, 1] x [0, 1] point cooordinates to image-level coordinates.\n\n    Args:\n        boxes_coords (Tensor): A tensor of shape (R, 4) that contains bounding boxes.\n            coordinates.\n        point_coords (Tensor): A tensor of shape (R, P, 2) that contains\n            [0, 1] x [0, 1] box-normalized coordinates of the P sampled points.\n\n    Returns:\n        point_coords_wrt_image (Tensor): A tensor of shape (R, P, 2) that contains\n            image-normalized coordinates of P sampled points.\n    \"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "point_coords_wrt_image", "=", "point_coords", ".", "clone", "(", ")", "\n", "point_coords_wrt_image", "[", ":", ",", ":", ",", "0", "]", "=", "point_coords_wrt_image", "[", ":", ",", ":", ",", "0", "]", "*", "(", "\n", "boxes_coords", "[", ":", ",", "None", ",", "2", "]", "-", "boxes_coords", "[", ":", ",", "None", ",", "0", "]", "\n", ")", "\n", "point_coords_wrt_image", "[", ":", ",", ":", ",", "1", "]", "=", "point_coords_wrt_image", "[", ":", ",", ":", ",", "1", "]", "*", "(", "\n", "boxes_coords", "[", ":", ",", "None", ",", "3", "]", "-", "boxes_coords", "[", ":", ",", "None", ",", "1", "]", "\n", ")", "\n", "point_coords_wrt_image", "[", ":", ",", ":", ",", "0", "]", "+=", "boxes_coords", "[", ":", ",", "None", ",", "0", "]", "\n", "point_coords_wrt_image", "[", ":", ",", ":", ",", "1", "]", "+=", "boxes_coords", "[", ":", ",", "None", ",", "1", "]", "\n", "", "return", "point_coords_wrt_image", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_head.StandardPointHead.__init__": [[106, 142], ["torch.nn.Module.__init__", "range", "torch.nn.Conv1d", "torch.nn.init.normal_", "torch.nn.Conv1d", "point_head.StandardPointHead.add_module", "point_head.StandardPointHead.fc_layers.append", "fvcore.c2_msra_fill", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "        ", "\"\"\"\n        The following attributes are parsed from config:\n            fc_dim: the output dimension of each FC layers\n            num_fc: the number of FC layers\n            coarse_pred_each_layer: if True, coarse prediction features are concatenated to each\n                layer's input\n        \"\"\"", "\n", "super", "(", "StandardPointHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# fmt: off", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "POINT_HEAD", ".", "NUM_CLASSES", "\n", "fc_dim", "=", "cfg", ".", "MODEL", ".", "POINT_HEAD", ".", "FC_DIM", "\n", "num_fc", "=", "cfg", ".", "MODEL", ".", "POINT_HEAD", ".", "NUM_FC", "\n", "cls_agnostic_mask", "=", "cfg", ".", "MODEL", ".", "POINT_HEAD", ".", "CLS_AGNOSTIC_MASK", "\n", "self", ".", "coarse_pred_each_layer", "=", "cfg", ".", "MODEL", ".", "POINT_HEAD", ".", "COARSE_PRED_EACH_LAYER", "\n", "input_channels", "=", "input_shape", ".", "channels", "\n", "# fmt: on", "\n", "\n", "fc_dim_in", "=", "input_channels", "+", "num_classes", "\n", "self", ".", "fc_layers", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "num_fc", ")", ":", "\n", "            ", "fc", "=", "nn", ".", "Conv1d", "(", "fc_dim_in", ",", "fc_dim", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "True", ")", "\n", "self", ".", "add_module", "(", "\"fc{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "fc", ")", "\n", "self", ".", "fc_layers", ".", "append", "(", "fc", ")", "\n", "fc_dim_in", "=", "fc_dim", "\n", "fc_dim_in", "+=", "num_classes", "if", "self", ".", "coarse_pred_each_layer", "else", "0", "\n", "\n", "", "num_mask_classes", "=", "1", "if", "cls_agnostic_mask", "else", "num_classes", "\n", "self", ".", "predictor", "=", "nn", ".", "Conv1d", "(", "fc_dim_in", ",", "num_mask_classes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "\n", "for", "layer", "in", "self", ".", "fc_layers", ":", "\n", "            ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "# use normal distribution initialization for mask prediction layer", "\n", "", "nn", ".", "init", ".", "normal_", "(", "self", ".", "predictor", ".", "weight", ",", "std", "=", "0.001", ")", "\n", "if", "self", ".", "predictor", ".", "bias", "is", "not", "None", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "self", ".", "predictor", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_head.StandardPointHead.forward": [[143, 150], ["torch.cat", "point_head.StandardPointHead.predictor", "torch.nn.functional.relu", "layer", "detectron2.layers.cat"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["", "", "def", "forward", "(", "self", ",", "fine_grained_features", ",", "coarse_features", ")", ":", "\n", "        ", "x", "=", "torch", ".", "cat", "(", "(", "fine_grained_features", ",", "coarse_features", ")", ",", "dim", "=", "1", ")", "\n", "for", "layer", "in", "self", ".", "fc_layers", ":", "\n", "            ", "x", "=", "F", ".", "relu", "(", "layer", "(", "x", ")", ")", "\n", "if", "self", ".", "coarse_pred_each_layer", ":", "\n", "                ", "x", "=", "cat", "(", "(", "x", ",", "coarse_features", ")", ",", "dim", "=", "1", ")", "\n", "", "", "return", "self", ".", "predictor", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_head.roi_mask_point_loss": [[22, 97], ["detectron2.layers.cat", "detectron2.utils.events.get_event_storage().put_scalar", "torch.nn.functional.binary_cross_entropy_with_logits", "torch.no_grad", "mask_logits.size", "len", "detectron2.layers.cat.numel", "torch.arange", "detectron2.layers.cat", "detectron2.layers.cat.to", "mask_accurate.nonzero().size", "mask_accurate.numel", "detectron2.layers.cat.to", "mask_logits.size", "isinstance", "torch.tensor", "len", "detectron2.layers.cat.append", "mask_logits.sum", "detectron2.utils.events.get_event_storage", "len", "instances_per_image.gt_classes.to", "detectron2.layers.cat.append", "point_features.point_sample().squeeze", "mask_accurate.nonzero", "point_features.point_sample", "len", "gt_bit_masks.to().unsqueeze", "gt_bit_masks.to"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.get_event_storage", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.point_sample", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["def", "roi_mask_point_loss", "(", "mask_logits", ",", "instances", ",", "points_coord", ")", ":", "\n", "    ", "\"\"\"\n    Compute the point-based loss for instance segmentation mask predictions.\n\n    Args:\n        mask_logits (Tensor): A tensor of shape (R, C, P) or (R, 1, P) for class-specific or\n            class-agnostic, where R is the total number of predicted masks in all images, C is the\n            number of foreground classes, and P is the number of points sampled for each mask.\n            The values are logits.\n        instances (list[Instances]): A list of N Instances, where N is the number of images\n            in the batch. These instances are in 1:1 correspondence with the `mask_logits`. So, i_th\n            elememt of the list contains R_i objects and R_1 + ... + R_N is equal to R.\n            The ground-truth labels (class, box, mask, ...) associated with each instance are stored\n            in fields.\n        points_coords (Tensor): A tensor of shape (R, P, 2), where R is the total number of\n            predicted masks and P is the number of points for each mask. The coordinates are in\n            the image pixel coordinate space, i.e. [0, H] x [0, W].\n    Returns:\n        point_loss (Tensor): A scalar tensor containing the loss.\n    \"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "cls_agnostic_mask", "=", "mask_logits", ".", "size", "(", "1", ")", "==", "1", "\n", "total_num_masks", "=", "mask_logits", ".", "size", "(", "0", ")", "\n", "\n", "gt_classes", "=", "[", "]", "\n", "gt_mask_logits", "=", "[", "]", "\n", "idx", "=", "0", "\n", "for", "instances_per_image", "in", "instances", ":", "\n", "            ", "if", "len", "(", "instances_per_image", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "", "assert", "isinstance", "(", "\n", "instances_per_image", ".", "gt_masks", ",", "BitMasks", "\n", ")", ",", "\"Point head works with GT in 'bitmask' format. Set INPUT.MASK_FORMAT to 'bitmask'.\"", "\n", "\n", "if", "not", "cls_agnostic_mask", ":", "\n", "                ", "gt_classes_per_image", "=", "instances_per_image", ".", "gt_classes", ".", "to", "(", "dtype", "=", "torch", ".", "int64", ")", "\n", "gt_classes", ".", "append", "(", "gt_classes_per_image", ")", "\n", "\n", "", "gt_bit_masks", "=", "instances_per_image", ".", "gt_masks", ".", "tensor", "\n", "h", ",", "w", "=", "instances_per_image", ".", "gt_masks", ".", "image_size", "\n", "scale", "=", "torch", ".", "tensor", "(", "[", "w", ",", "h", "]", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "gt_bit_masks", ".", "device", ")", "\n", "points_coord_grid_sample_format", "=", "(", "\n", "points_coord", "[", "idx", ":", "idx", "+", "len", "(", "instances_per_image", ")", "]", "/", "scale", "\n", ")", "\n", "idx", "+=", "len", "(", "instances_per_image", ")", "\n", "gt_mask_logits", ".", "append", "(", "\n", "point_sample", "(", "\n", "gt_bit_masks", ".", "to", "(", "torch", ".", "float32", ")", ".", "unsqueeze", "(", "1", ")", ",", "\n", "points_coord_grid_sample_format", ",", "\n", "align_corners", "=", "False", ",", "\n", ")", ".", "squeeze", "(", "1", ")", "\n", ")", "\n", "\n", "", "", "if", "len", "(", "gt_mask_logits", ")", "==", "0", ":", "\n", "        ", "return", "mask_logits", ".", "sum", "(", ")", "*", "0", "\n", "\n", "", "gt_mask_logits", "=", "cat", "(", "gt_mask_logits", ")", "\n", "assert", "gt_mask_logits", ".", "numel", "(", ")", ">", "0", ",", "gt_mask_logits", ".", "shape", "\n", "\n", "if", "cls_agnostic_mask", ":", "\n", "        ", "mask_logits", "=", "mask_logits", "[", ":", ",", "0", "]", "\n", "", "else", ":", "\n", "        ", "indices", "=", "torch", ".", "arange", "(", "total_num_masks", ")", "\n", "gt_classes", "=", "cat", "(", "gt_classes", ",", "dim", "=", "0", ")", "\n", "mask_logits", "=", "mask_logits", "[", "indices", ",", "gt_classes", "]", "\n", "\n", "# Log the training accuracy (using gt classes and 0.0 threshold for the logits)", "\n", "", "mask_accurate", "=", "(", "mask_logits", ">", "0.0", ")", "==", "gt_mask_logits", ".", "to", "(", "dtype", "=", "torch", ".", "uint8", ")", "\n", "mask_accuracy", "=", "mask_accurate", ".", "nonzero", "(", ")", ".", "size", "(", "0", ")", "/", "mask_accurate", ".", "numel", "(", ")", "\n", "get_event_storage", "(", ")", ".", "put_scalar", "(", "\"point_rend/accuracy\"", ",", "mask_accuracy", ")", "\n", "\n", "point_loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "mask_logits", ",", "gt_mask_logits", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", ",", "reduction", "=", "\"mean\"", "\n", ")", "\n", "return", "point_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_head.build_point_head": [[152, 158], ["POINT_HEAD_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "", "def", "build_point_head", "(", "cfg", ",", "input_channels", ")", ":", "\n", "    ", "\"\"\"\n    Build a point head defined by `cfg.MODEL.POINT_HEAD.NAME`.\n    \"\"\"", "\n", "head_name", "=", "cfg", ".", "MODEL", ".", "POINT_HEAD", ".", "NAME", "\n", "return", "POINT_HEAD_REGISTRY", ".", "get", "(", "head_name", ")", "(", "cfg", ",", "input_channels", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.coarse_mask_head.CoarseMaskHead.__init__": [[19, 79], ["torch.nn.Module.__init__", "detectron2.layers.Conv2d", "coarse_mask_head.CoarseMaskHead.conv_layers.append", "range", "torch.nn.Linear", "torch.nn.init.normal_", "torch.nn.init.constant_", "detectron2.layers.Conv2d", "coarse_mask_head.CoarseMaskHead.conv_layers.append", "torch.nn.Linear", "coarse_mask_head.CoarseMaskHead.add_module", "coarse_mask_head.CoarseMaskHead.fcs.append", "fvcore.c2_msra_fill", "fvcore.c2_xavier_fill"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "        ", "\"\"\"\n        The following attributes are parsed from config:\n            conv_dim: the output dimension of the conv layers\n            fc_dim: the feature dimenstion of the FC layers\n            num_fc: the number of FC layers\n            output_side_resolution: side resolution of the output square mask prediction\n        \"\"\"", "\n", "super", "(", "CoarseMaskHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "self", ".", "num_classes", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NUM_CLASSES", "\n", "conv_dim", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "CONV_DIM", "\n", "self", ".", "fc_dim", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "FC_DIM", "\n", "num_fc", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "NUM_FC", "\n", "self", ".", "output_side_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "OUTPUT_SIDE_RESOLUTION", "\n", "self", ".", "input_channels", "=", "input_shape", ".", "channels", "\n", "self", ".", "input_h", "=", "input_shape", ".", "height", "\n", "self", ".", "input_w", "=", "input_shape", ".", "width", "\n", "# fmt: on", "\n", "\n", "self", ".", "conv_layers", "=", "[", "]", "\n", "if", "self", ".", "input_channels", ">", "conv_dim", ":", "\n", "            ", "self", ".", "reduce_channel_dim_conv", "=", "Conv2d", "(", "\n", "self", ".", "input_channels", ",", "\n", "conv_dim", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "bias", "=", "True", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", "\n", "self", ".", "conv_layers", ".", "append", "(", "self", ".", "reduce_channel_dim_conv", ")", "\n", "\n", "", "self", ".", "reduce_spatial_dim_conv", "=", "Conv2d", "(", "\n", "conv_dim", ",", "conv_dim", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ",", "padding", "=", "0", ",", "bias", "=", "True", ",", "activation", "=", "F", ".", "relu", "\n", ")", "\n", "self", ".", "conv_layers", ".", "append", "(", "self", ".", "reduce_spatial_dim_conv", ")", "\n", "\n", "input_dim", "=", "conv_dim", "*", "self", ".", "input_h", "*", "self", ".", "input_w", "\n", "input_dim", "//=", "4", "\n", "\n", "self", ".", "fcs", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "num_fc", ")", ":", "\n", "            ", "fc", "=", "nn", ".", "Linear", "(", "input_dim", ",", "self", ".", "fc_dim", ")", "\n", "self", ".", "add_module", "(", "\"coarse_mask_fc{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "fc", ")", "\n", "self", ".", "fcs", ".", "append", "(", "fc", ")", "\n", "input_dim", "=", "self", ".", "fc_dim", "\n", "\n", "", "output_dim", "=", "self", ".", "num_classes", "*", "self", ".", "output_side_resolution", "*", "self", ".", "output_side_resolution", "\n", "\n", "self", ".", "prediction", "=", "nn", ".", "Linear", "(", "self", ".", "fc_dim", ",", "output_dim", ")", "\n", "# use normal distribution initialization for mask prediction layer", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "prediction", ".", "weight", ",", "std", "=", "0.001", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "prediction", ".", "bias", ",", "0", ")", "\n", "\n", "for", "layer", "in", "self", ".", "conv_layers", ":", "\n", "            ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "", "for", "layer", "in", "self", ".", "fcs", ":", "\n", "            ", "weight_init", ".", "c2_xavier_fill", "(", "layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.coarse_mask_head.CoarseMaskHead.forward": [[80, 92], ["torch.nn.functional.relu.view", "torch.flatten", "coarse_mask_head.CoarseMaskHead.prediction().view", "layer", "torch.nn.functional.relu", "layer", "coarse_mask_head.CoarseMaskHead.prediction"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "# unlike BaseMaskRCNNHead, this head only outputs intermediate", "\n", "# features, because the features will be used later by PointHead.", "\n", "        ", "N", "=", "x", ".", "shape", "[", "0", "]", "\n", "x", "=", "x", ".", "view", "(", "N", ",", "self", ".", "input_channels", ",", "self", ".", "input_h", ",", "self", ".", "input_w", ")", "\n", "for", "layer", "in", "self", ".", "conv_layers", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "", "x", "=", "torch", ".", "flatten", "(", "x", ",", "start_dim", "=", "1", ")", "\n", "for", "layer", "in", "self", ".", "fcs", ":", "\n", "            ", "x", "=", "F", ".", "relu", "(", "layer", "(", "x", ")", ")", "\n", "", "return", "self", ".", "prediction", "(", "x", ")", ".", "view", "(", "\n", "N", ",", "self", ".", "num_classes", ",", "self", ".", "output_side_resolution", ",", "self", ".", "output_side_resolution", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.semantic_seg.PointRendSemSegHead.__init__": [[43, 52], ["torch.nn.Module.__init__", "semantic_seg.PointRendSemSegHead._init_point_head", "detectron2.modeling.SEM_SEG_HEADS_REGISTRY.get"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.semantic_seg.PointRendSemSegHead._init_point_head", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["\n", "", "def", "forward", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.semantic_seg.PointRendSemSegHead._init_point_head": [[53, 67], ["numpy.sum", "point_head.build_point_head", "detectron2.layers.ShapeSpec", "input_shape.items"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_head.build_point_head"], ["\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.semantic_seg.PointRendSemSegHead.forward": [[68, 136], ["semantic_seg.PointRendSemSegHead.coarse_sem_seg_head.layers", "semantic_seg.PointRendSemSegHead.coarse_sem_seg_head.losses", "point_features.point_sample", "detectron2.layers.cat", "semantic_seg.PointRendSemSegHead.point_head", "point_features.point_sample().squeeze().to", "torch.nn.functional.cross_entropy", "semantic_seg.PointRendSemSegHead.clone", "range", "torch.no_grad", "point_features.get_uncertain_point_coords_with_randomness", "torch.nn.functional.interpolate", "semantic_seg.calculate_uncertainty", "point_features.get_uncertain_point_coords_on_grid", "detectron2.layers.cat", "point_features.point_sample", "semantic_seg.PointRendSemSegHead.point_head", "point_indices.unsqueeze().expand.unsqueeze().expand.unsqueeze().expand", "sem_seg_logits.reshape().scatter_().view.reshape().scatter_().view.reshape().scatter_().view", "point_features.point_sample", "point_features.point_sample().squeeze", "point_features.point_sample", "point_indices.unsqueeze().expand.unsqueeze().expand.unsqueeze", "sem_seg_logits.reshape().scatter_().view.reshape().scatter_().view.reshape().scatter_", "point_features.point_sample", "targets.unsqueeze().to", "sem_seg_logits.reshape().scatter_().view.reshape().scatter_().view.reshape", "targets.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3PlusHead.layers", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.deeplab.semantic_seg.DeepLabV3Head.losses", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.point_sample", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.get_uncertain_point_coords_with_randomness", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.semantic_seg.calculate_uncertainty", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.get_uncertain_point_coords_on_grid", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.point_sample", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.point_sample", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.point_sample", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.point_features.point_sample", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.to"], ["images", "=", "[", "x", "[", "\"image\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "images", "=", "[", "(", "x", "-", "self", ".", "pixel_mean", ")", "/", "self", ".", "pixel_std", "for", "x", "in", "images", "]", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "self", ".", "backbone", ".", "size_divisibility", ")", "\n", "\n", "features", "=", "self", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "\n", "if", "\"sem_seg\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "targets", "=", "[", "x", "[", "\"sem_seg\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "targets", "=", "ImageList", ".", "from_tensors", "(", "\n", "targets", ",", "self", ".", "backbone", ".", "size_divisibility", ",", "self", ".", "sem_seg_head", ".", "ignore_value", "\n", ")", ".", "tensor", "\n", "", "else", ":", "\n", "            ", "targets", "=", "None", "\n", "", "results", ",", "losses", "=", "self", ".", "sem_seg_head", "(", "features", ",", "targets", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "losses", "\n", "\n", "", "processed_results", "=", "[", "]", "\n", "for", "result", ",", "input_per_image", ",", "image_size", "in", "zip", "(", "results", ",", "batched_inputs", ",", "images", ".", "image_sizes", ")", ":", "\n", "            ", "height", "=", "input_per_image", ".", "get", "(", "\"height\"", ")", "\n", "width", "=", "input_per_image", ".", "get", "(", "\"width\"", ")", "\n", "r", "=", "sem_seg_postprocess", "(", "result", ",", "image_size", ",", "height", ",", "width", ")", "\n", "processed_results", ".", "append", "(", "{", "\"sem_seg\"", ":", "r", "}", ")", "\n", "", "return", "processed_results", "\n", "\n", "\n", "", "", "def", "build_sem_seg_head", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build a semantic segmentation head from `cfg.MODEL.SEM_SEG_HEAD.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NAME", "\n", "return", "SEM_SEG_HEADS_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "\n", "\n", "", "@", "SEM_SEG_HEADS_REGISTRY", ".", "register", "(", ")", "\n", "class", "SemSegFPNHead", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "\"\"\"\n    A semantic segmentation head described in :paper:`PanopticFPN`.\n    It takes FPN features as input and merges information from all\n    levels of the FPN into single output.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "Dict", "[", "str", ",", "ShapeSpec", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "self", ".", "in_features", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IN_FEATURES", "\n", "feature_strides", "=", "{", "k", ":", "v", ".", "stride", "for", "k", ",", "v", "in", "input_shape", ".", "items", "(", ")", "}", "\n", "feature_channels", "=", "{", "k", ":", "v", ".", "channels", "for", "k", ",", "v", "in", "input_shape", ".", "items", "(", ")", "}", "\n", "self", ".", "ignore_value", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IGNORE_VALUE", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NUM_CLASSES", "\n", "conv_dims", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "CONVS_DIM", "\n", "self", ".", "common_stride", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "COMMON_STRIDE", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NORM", "\n", "self", ".", "loss_weight", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "LOSS_WEIGHT", "\n", "# fmt: on", "\n", "\n", "self", ".", "scale_heads", "=", "[", "]", "\n", "for", "in_feature", "in", "self", ".", "in_features", ":", "\n", "            ", "head_ops", "=", "[", "]", "\n", "head_length", "=", "max", "(", "\n", "1", ",", "int", "(", "np", ".", "log2", "(", "feature_strides", "[", "in_feature", "]", ")", "-", "np", ".", "log2", "(", "self", ".", "common_stride", ")", ")", "\n", ")", "\n", "for", "k", "in", "range", "(", "head_length", ")", ":", "\n", "                ", "norm_module", "=", "nn", ".", "GroupNorm", "(", "32", ",", "conv_dims", ")", "if", "norm", "==", "\"GN\"", "else", "None", "\n", "conv", "=", "Conv2d", "(", "\n", "feature_channels", "[", "in_feature", "]", "if", "k", "==", "0", "else", "conv_dims", ",", "\n", "conv_dims", ",", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.semantic_seg.calculate_uncertainty": [[19, 34], ["torch.topk"], "function", ["None"], ["\n", "SEM_SEG_HEADS_REGISTRY", "=", "Registry", "(", "\"SEM_SEG_HEADS\"", ")", "\n", "SEM_SEG_HEADS_REGISTRY", ".", "__doc__", "=", "\"\"\"\nRegistry for semantic segmentation heads, which make semantic segmentation predictions\nfrom feature maps.\n\"\"\"", "\n", "\n", "\n", "@", "META_ARCH_REGISTRY", ".", "register", "(", ")", "\n", "class", "SemanticSegmentor", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "\"\"\"\n    Main class for semantic segmentation architectures.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.__init__": [[27, 42], ["fvcore.transforms.transform.Transform.__init__", "color_augmentation.ColorAugSSDTransform._set_attributes", "locals"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "img_format", ",", "\n", "brightness_delta", "=", "32", ",", "\n", "contrast_low", "=", "0.5", ",", "\n", "contrast_high", "=", "1.5", ",", "\n", "saturation_low", "=", "0.5", ",", "\n", "saturation_high", "=", "1.5", ",", "\n", "hue_delta", "=", "18", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "img_format", "in", "[", "\"BGR\"", ",", "\"RGB\"", "]", "\n", "self", ".", "is_rgb", "=", "img_format", "==", "\"RGB\"", "\n", "del", "img_format", "\n", "self", ".", "_set_attributes", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.apply_coords": [[43, 45], ["None"], "methods", ["None"], ["", "def", "apply_coords", "(", "self", ",", "coords", ")", ":", "\n", "        ", "return", "coords", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.apply_segmentation": [[46, 48], ["None"], "methods", ["None"], ["", "def", "apply_segmentation", "(", "self", ",", "segmentation", ")", ":", "\n", "        ", "return", "segmentation", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.apply_image": [[49, 64], ["color_augmentation.ColorAugSSDTransform.brightness", "random.randrange", "color_augmentation.ColorAugSSDTransform.contrast", "color_augmentation.ColorAugSSDTransform.saturation", "color_augmentation.ColorAugSSDTransform.hue", "color_augmentation.ColorAugSSDTransform.saturation", "color_augmentation.ColorAugSSDTransform.hue", "color_augmentation.ColorAugSSDTransform.contrast"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.brightness", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.contrast", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.saturation", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.hue", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.saturation", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.hue", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.contrast"], ["", "def", "apply_image", "(", "self", ",", "img", ",", "interp", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "is_rgb", ":", "\n", "            ", "img", "=", "img", "[", ":", ",", ":", ",", "[", "2", ",", "1", ",", "0", "]", "]", "\n", "", "img", "=", "self", ".", "brightness", "(", "img", ")", "\n", "if", "random", ".", "randrange", "(", "2", ")", ":", "\n", "            ", "img", "=", "self", ".", "contrast", "(", "img", ")", "\n", "img", "=", "self", ".", "saturation", "(", "img", ")", "\n", "img", "=", "self", ".", "hue", "(", "img", ")", "\n", "", "else", ":", "\n", "            ", "img", "=", "self", ".", "saturation", "(", "img", ")", "\n", "img", "=", "self", ".", "hue", "(", "img", ")", "\n", "img", "=", "self", ".", "contrast", "(", "img", ")", "\n", "", "if", "self", ".", "is_rgb", ":", "\n", "            ", "img", "=", "img", "[", ":", ",", ":", ",", "[", "2", ",", "1", ",", "0", "]", "]", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert": [[65, 69], ["numpy.clip", "numpy.clip.astype", "numpy.clip.astype"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clip"], ["", "def", "convert", "(", "self", ",", "img", ",", "alpha", "=", "1", ",", "beta", "=", "0", ")", ":", "\n", "        ", "img", "=", "img", ".", "astype", "(", "np", ".", "float32", ")", "*", "alpha", "+", "beta", "\n", "img", "=", "np", ".", "clip", "(", "img", ",", "0", ",", "255", ")", "\n", "return", "img", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.brightness": [[70, 76], ["random.randrange", "color_augmentation.ColorAugSSDTransform.convert", "random.uniform"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "def", "brightness", "(", "self", ",", "img", ")", ":", "\n", "        ", "if", "random", ".", "randrange", "(", "2", ")", ":", "\n", "            ", "return", "self", ".", "convert", "(", "\n", "img", ",", "beta", "=", "random", ".", "uniform", "(", "-", "self", ".", "brightness_delta", ",", "self", ".", "brightness_delta", ")", "\n", ")", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.contrast": [[77, 81], ["random.randrange", "color_augmentation.ColorAugSSDTransform.convert", "random.uniform"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "def", "contrast", "(", "self", ",", "img", ")", ":", "\n", "        ", "if", "random", ".", "randrange", "(", "2", ")", ":", "\n", "            ", "return", "self", ".", "convert", "(", "img", ",", "alpha", "=", "random", ".", "uniform", "(", "self", ".", "contrast_low", ",", "self", ".", "contrast_high", ")", ")", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.saturation": [[82, 90], ["random.randrange", "cv2.cvtColor", "color_augmentation.ColorAugSSDTransform.convert", "cv2.cvtColor", "random.uniform"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "def", "saturation", "(", "self", ",", "img", ")", ":", "\n", "        ", "if", "random", ".", "randrange", "(", "2", ")", ":", "\n", "            ", "img", "=", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_BGR2HSV", ")", "\n", "img", "[", ":", ",", ":", ",", "1", "]", "=", "self", ".", "convert", "(", "\n", "img", "[", ":", ",", ":", ",", "1", "]", ",", "alpha", "=", "random", ".", "uniform", "(", "self", ".", "saturation_low", ",", "self", ".", "saturation_high", ")", "\n", ")", "\n", "return", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_HSV2BGR", ")", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.hue": [[91, 99], ["random.randrange", "cv2.cvtColor", "cv2.cvtColor", "img[].astype", "random.randint"], "methods", ["None"], ["", "def", "hue", "(", "self", ",", "img", ")", ":", "\n", "        ", "if", "random", ".", "randrange", "(", "2", ")", ":", "\n", "            ", "img", "=", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_BGR2HSV", ")", "\n", "img", "[", ":", ",", ":", ",", "0", "]", "=", "(", "\n", "img", "[", ":", ",", ":", ",", "0", "]", ".", "astype", "(", "int", ")", "+", "random", ".", "randint", "(", "-", "self", ".", "hue_delta", ",", "self", ".", "hue_delta", ")", "\n", ")", "%", "180", "\n", "return", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_HSV2BGR", ")", "\n", "", "return", "img", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.test_svm.get_chosen_costs": [[35, 59], ["svm_helper.parse_cost_list", "numpy.zeros", "range", "numpy.argmax", "numpy.save", "numpy.save", "numpy.array", "range", "os.path.join", "numpy.array", "os.path.join", "numpy.array", "len", "len", "svm_helper.get_svm_train_output_files", "float", "numpy.load"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.parse_cost_list", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.get_svm_train_output_files"], ["def", "get_chosen_costs", "(", "opts", ",", "num_classes", ")", ":", "\n", "    ", "costs_list", "=", "svm_helper", ".", "parse_cost_list", "(", "opts", ".", "costs_list", ")", "\n", "train_ap_matrix", "=", "np", ".", "zeros", "(", "(", "num_classes", ",", "len", "(", "costs_list", ")", ")", ")", "\n", "for", "cls", "in", "range", "(", "num_classes", ")", ":", "\n", "        ", "for", "cost_idx", "in", "range", "(", "len", "(", "costs_list", ")", ")", ":", "\n", "            ", "cost", "=", "costs_list", "[", "cost_idx", "]", "\n", "_", ",", "ap_out_file", "=", "svm_helper", ".", "get_svm_train_output_files", "(", "\n", "cls", ",", "cost", ",", "opts", ".", "output_path", ")", "\n", "train_ap_matrix", "[", "cls", "]", "[", "cost_idx", "]", "=", "float", "(", "\n", "np", ".", "load", "(", "ap_out_file", ",", "encoding", "=", "'latin1'", ")", "[", "0", "]", ")", "\n", "", "", "argmax_cls", "=", "np", ".", "argmax", "(", "train_ap_matrix", ",", "axis", "=", "1", ")", "\n", "chosen_cost", "=", "[", "costs_list", "[", "idx", "]", "for", "idx", "in", "argmax_cls", "]", "\n", "#logger.info('chosen_cost: {}'.format(chosen_cost))", "\n", "np", ".", "save", "(", "\n", "os", ".", "path", ".", "join", "(", "opts", ".", "output_path", ",", "'crossval_ap.npy'", ")", ",", "\n", "np", ".", "array", "(", "train_ap_matrix", ")", ")", "\n", "np", ".", "save", "(", "\n", "os", ".", "path", ".", "join", "(", "opts", ".", "output_path", ",", "'chosen_cost.npy'", ")", ",", "\n", "np", ".", "array", "(", "chosen_cost", ")", ")", "\n", "#logger.info('saved crossval_ap AP to file: {}'.format(", "\n", "#    os.path.join(opts.output_path, 'crossval_ap.npy')))", "\n", "#logger.info('saved chosen costs to file: {}'.format(", "\n", "#    os.path.join(opts.output_path, 'chosen_cost.npy')))", "\n", "return", "np", ".", "array", "(", "chosen_cost", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.test_svm.load_json": [[61, 68], ["os.path.exists", "list", "list", "open", "json.load", "json.load.keys", "data[].keys"], "function", ["None"], ["", "def", "load_json", "(", "file_path", ")", ":", "\n", "    ", "assert", "os", ".", "path", ".", "exists", "(", "file_path", ")", ",", "\"{} does not exist\"", ".", "format", "(", "file_path", ")", "\n", "with", "open", "(", "file_path", ",", "'r'", ")", "as", "fp", ":", "\n", "        ", "data", "=", "json", ".", "load", "(", "fp", ")", "\n", "", "img_ids", "=", "list", "(", "data", ".", "keys", "(", ")", ")", "\n", "cls_names", "=", "list", "(", "data", "[", "img_ids", "[", "0", "]", "]", ".", "keys", "(", ")", ")", "\n", "return", "img_ids", ",", "cls_names", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.test_svm.test_svm": [[70, 128], ["os.path.exists", "svm_helper.load_input_data", "svm_helper.normalize_features", "test_svm.get_chosen_costs", "numpy.zeros", "range", "logger.info", "numpy.save", "test_svm.load_json", "os.path.join", "pickle.load.decision_function", "svm_helper.get_precision_recall", "os.path.join", "os.path.join", "numpy.array", "open", "range", "open", "json.dump", "numpy.mean", "pickle.load", "pickle.load", "len", "numpy.where", "str", "str"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.load_input_data", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.normalize_features", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.test_svm.get_chosen_costs", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_low_shot_challenge_samples.load_json", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.get_precision_recall", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.dump"], ["", "def", "test_svm", "(", "opts", ")", ":", "\n", "    ", "assert", "os", ".", "path", ".", "exists", "(", "opts", ".", "data_file", ")", ",", "\"Data file not found. Abort!\"", "\n", "json_predictions", ",", "img_ids", ",", "cls_names", "=", "{", "}", ",", "[", "]", ",", "[", "]", "\n", "if", "opts", ".", "generate_json", ":", "\n", "        ", "img_ids", ",", "cls_names", "=", "load_json", "(", "opts", ".", "json_targets", ")", "\n", "\n", "", "features", ",", "targets", "=", "svm_helper", ".", "load_input_data", "(", "opts", ".", "data_file", ",", "\n", "opts", ".", "targets_data_file", ")", "\n", "# normalize the features: N x 9216 (example shape)", "\n", "features", "=", "svm_helper", ".", "normalize_features", "(", "features", ")", "\n", "num_classes", "=", "targets", ".", "shape", "[", "1", "]", "\n", "#logger.info('Num classes: {}'.format(num_classes))", "\n", "\n", "# get the chosen cost that maximizes the cross-validation AP per class", "\n", "costs_list", "=", "get_chosen_costs", "(", "opts", ",", "num_classes", ")", "\n", "\n", "ap_matrix", "=", "np", ".", "zeros", "(", "(", "num_classes", ",", "1", ")", ")", "\n", "for", "cls", "in", "range", "(", "num_classes", ")", ":", "\n", "        ", "cost", "=", "costs_list", "[", "cls", "]", "\n", "#logger.info('Testing model for cls: {} cost: {}'.format(cls, cost))", "\n", "model_file", "=", "os", ".", "path", ".", "join", "(", "\n", "opts", ".", "output_path", ",", "\n", "'cls'", "+", "str", "(", "cls", ")", "+", "'_cost'", "+", "str", "(", "cost", ")", "+", "'.pickle'", ")", "\n", "with", "open", "(", "model_file", ",", "'rb'", ")", "as", "fopen", ":", "\n", "            ", "if", "six", ".", "PY2", ":", "\n", "                ", "model", "=", "pickle", ".", "load", "(", "fopen", ")", "\n", "", "else", ":", "\n", "                ", "model", "=", "pickle", ".", "load", "(", "fopen", ",", "encoding", "=", "'latin1'", ")", "\n", "", "", "prediction", "=", "model", ".", "decision_function", "(", "features", ")", "\n", "if", "opts", ".", "generate_json", ":", "\n", "            ", "cls_name", "=", "cls_names", "[", "cls", "]", "\n", "for", "idx", "in", "range", "(", "len", "(", "prediction", ")", ")", ":", "\n", "                ", "img_id", "=", "img_ids", "[", "idx", "]", "\n", "if", "img_id", "in", "json_predictions", ":", "\n", "                    ", "json_predictions", "[", "img_id", "]", "[", "cls_name", "]", "=", "prediction", "[", "idx", "]", "\n", "", "else", ":", "\n", "                    ", "out_lbl", "=", "{", "}", "\n", "out_lbl", "[", "cls_name", "]", "=", "prediction", "[", "idx", "]", "\n", "json_predictions", "[", "img_id", "]", "=", "out_lbl", "\n", "\n", "", "", "", "cls_labels", "=", "targets", "[", ":", ",", "cls", "]", "\n", "# meaning of labels in VOC/COCO original loaded target files:", "\n", "# label 0 = not present, set it to -1 as svm train target", "\n", "# label 1 = present. Make the svm train target labels as -1, 1.", "\n", "evaluate_data_inds", "=", "(", "targets", "[", ":", ",", "cls", "]", "!=", "-", "1", ")", "\n", "eval_preds", "=", "prediction", "[", "evaluate_data_inds", "]", "\n", "eval_cls_labels", "=", "cls_labels", "[", "evaluate_data_inds", "]", "\n", "eval_cls_labels", "[", "np", ".", "where", "(", "eval_cls_labels", "==", "0", ")", "]", "=", "-", "1", "\n", "P", ",", "R", ",", "score", ",", "ap", "=", "svm_helper", ".", "get_precision_recall", "(", "\n", "eval_cls_labels", ",", "eval_preds", ")", "\n", "ap_matrix", "[", "cls", "]", "[", "0", "]", "=", "ap", "\n", "", "if", "opts", ".", "generate_json", ":", "\n", "        ", "output_file", "=", "os", ".", "path", ".", "join", "(", "opts", ".", "output_path", ",", "'json_preds.json'", ")", "\n", "with", "open", "(", "output_file", ",", "'w'", ")", "as", "fp", ":", "\n", "            ", "json", ".", "dump", "(", "json_predictions", ",", "fp", ")", "\n", "#logger.info('Saved json predictions to: {}'.format(output_file))", "\n", "", "", "logger", ".", "info", "(", "'Mean AP: {}'", ".", "format", "(", "np", ".", "mean", "(", "ap_matrix", ",", "axis", "=", "0", ")", ")", ")", "\n", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "opts", ".", "output_path", ",", "'test_ap.npy'", ")", ",", "np", ".", "array", "(", "ap_matrix", ")", ")", "\n", "#logger.info('saved test AP to file: {}'.format(", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.test_svm.main": [[132, 171], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "test_svm.test_svm", "len", "argparse.ArgumentParser.print_help", "sys.exit"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.test_svm.test_svm"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'SVM model test'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--data_file'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Numpy file containing image features and labels\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--json_targets'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Json file containing json targets\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--targets_data_file'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Numpy file containing image labels\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--costs_list'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "\"0.01,0.1\"", ",", "\n", "help", "=", "\"comma separated string containing list of costs\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--output_path'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"path where trained SVM models are saved\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--generate_json'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "0", ",", "\n", "help", "=", "\"Whether to generate json files for output\"", ")", "\n", "if", "len", "(", "sys", ".", "argv", ")", "==", "1", ":", "\n", "        ", "parser", ".", "print_help", "(", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "opts", "=", "parser", ".", "parse_args", "(", ")", "\n", "#logger.info(opts)", "\n", "test_svm", "(", "opts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.py2_py3_compatible_cost": [[30, 32], ["str", "float"], "function", ["None"], ["def", "py2_py3_compatible_cost", "(", "cost", ")", ":", "\n", "    ", "return", "str", "(", "float", "(", "\"{:.17f}\"", ".", "format", "(", "cost", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.get_svm_train_output_files": [[34, 40], ["os.path.join", "os.path.join", "svm_helper.py2_py3_compatible_cost", "str"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.py2_py3_compatible_cost"], ["", "def", "get_svm_train_output_files", "(", "cls", ",", "cost", ",", "output_path", ")", ":", "\n", "    ", "cls_cost", "=", "str", "(", "cls", ")", "+", "'_cost'", "+", "py2_py3_compatible_cost", "(", "cost", ")", "\n", "out_file", "=", "os", ".", "path", ".", "join", "(", "output_path", ",", "'cls'", "+", "cls_cost", "+", "'.pickle'", ")", "\n", "ap_matrix_out_file", "=", "os", ".", "path", ".", "join", "(", "output_path", ",", "\n", "'AP_cls'", "+", "cls_cost", "+", "'.npy'", ")", "\n", "return", "out_file", ",", "ap_matrix_out_file", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.parse_cost_list": [[42, 48], ["range", "float", "costs_list.append", "costs.split"], "function", ["None"], ["", "def", "parse_cost_list", "(", "costs", ")", ":", "\n", "    ", "costs_list", "=", "[", "float", "(", "cost", ")", "for", "cost", "in", "costs", ".", "split", "(", "\",\"", ")", "]", "\n", "start_num", ",", "end_num", "=", "4", ",", "20", "\n", "for", "num", "in", "range", "(", "start_num", ",", "end_num", ")", ":", "\n", "        ", "costs_list", ".", "append", "(", "0.5", "**", "num", ")", "\n", "", "return", "costs_list", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.normalize_features": [[50, 54], ["numpy.linalg.norm"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.norm"], ["", "def", "normalize_features", "(", "features", ")", ":", "\n", "    ", "feats_norm", "=", "np", ".", "linalg", ".", "norm", "(", "features", ",", "axis", "=", "1", ")", "\n", "features", "=", "features", "/", "(", "feats_norm", "+", "1e-5", ")", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "return", "features", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.load_input_data": [[56, 66], ["numpy.load", "numpy.array().astype", "numpy.array", "numpy.load"], "function", ["None"], ["", "def", "load_input_data", "(", "data_file", ",", "targets_file", ")", ":", "\n", "# load the features and the targets", "\n", "#logger.info('loading features and targets...')", "\n", "    ", "targets", "=", "np", ".", "load", "(", "targets_file", ",", "encoding", "=", "'latin1'", ")", "\n", "features", "=", "np", ".", "array", "(", "np", ".", "load", "(", "data_file", ",", "\n", "encoding", "=", "'latin1'", ")", ")", ".", "astype", "(", "np", ".", "float64", ")", "\n", "assert", "features", ".", "shape", "[", "0", "]", "==", "targets", ".", "shape", "[", "0", "]", ",", "\"Mismatched #images\"", "\n", "#logger.info('Loaded features: {} and targets: {}'.format(", "\n", "#    features.shape, targets.shape))", "\n", "return", "features", ",", "targets", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.calculate_ap": [[68, 83], ["range", "rec.reshape", "prec.reshape", "numpy.zeros", "numpy.ones", "numpy.vstack", "numpy.vstack", "max", "len", "numpy.where"], "function", ["None"], ["", "def", "calculate_ap", "(", "rec", ",", "prec", ")", ":", "\n", "    ", "\"\"\"\n    Computes the AP under the precision recall curve.\n    \"\"\"", "\n", "rec", ",", "prec", "=", "rec", ".", "reshape", "(", "rec", ".", "size", ",", "1", ")", ",", "prec", ".", "reshape", "(", "prec", ".", "size", ",", "1", ")", "\n", "z", ",", "o", "=", "np", ".", "zeros", "(", "(", "1", ",", "1", ")", ")", ",", "np", ".", "ones", "(", "(", "1", ",", "1", ")", ")", "\n", "mrec", ",", "mpre", "=", "np", ".", "vstack", "(", "(", "z", ",", "rec", ",", "o", ")", ")", ",", "np", ".", "vstack", "(", "(", "z", ",", "prec", ",", "z", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "mpre", ")", "-", "2", ",", "-", "1", ",", "-", "1", ")", ":", "\n", "        ", "mpre", "[", "i", "]", "=", "max", "(", "mpre", "[", "i", "]", ",", "mpre", "[", "i", "+", "1", "]", ")", "\n", "\n", "", "indices", "=", "np", ".", "where", "(", "mrec", "[", "1", ":", "]", "!=", "mrec", "[", "0", ":", "-", "1", "]", ")", "[", "0", "]", "+", "1", "\n", "ap", "=", "0", "\n", "for", "i", "in", "indices", ":", "\n", "        ", "ap", "=", "ap", "+", "(", "mrec", "[", "i", "]", "-", "mrec", "[", "i", "-", "1", "]", ")", "*", "mpre", "[", "i", "]", "\n", "", "return", "ap", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.get_precision_recall": [[85, 117], ["numpy.array", "numpy.hstack", "numpy.argsort", "numpy.array", "numpy.array", "np.array.copy", "range", "numpy.sum", "svm_helper.calculate_ap", "numpy.cumsum", "numpy.cumsum", "targets[].astype", "preds[].astype", "numpy.cumsum", "numpy.cumsum"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.calculate_ap"], ["", "def", "get_precision_recall", "(", "targets", ",", "preds", ")", ":", "\n", "    ", "\"\"\"\n    [P, R, score, ap] = get_precision_recall(targets, preds)\n    Input    :\n        targets  : number of occurrences of this class in the ith image\n        preds    : score for this image\n    Output   :\n        P, R   : precision and recall\n        score  : score which corresponds to the particular precision and recall\n        ap     : average precision\n    \"\"\"", "\n", "# binarize targets", "\n", "targets", "=", "np", ".", "array", "(", "targets", ">", "0", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "tog", "=", "np", ".", "hstack", "(", "(", "targets", "[", ":", ",", "np", ".", "newaxis", "]", ".", "astype", "(", "np", ".", "float64", ")", ",", "\n", "preds", "[", ":", ",", "np", ".", "newaxis", "]", ".", "astype", "(", "np", ".", "float64", ")", ")", ")", "\n", "ind", "=", "np", ".", "argsort", "(", "preds", ")", "\n", "ind", "=", "ind", "[", ":", ":", "-", "1", "]", "\n", "score", "=", "np", ".", "array", "(", "[", "tog", "[", "i", ",", "1", "]", "for", "i", "in", "ind", "]", ")", "\n", "sortcounts", "=", "np", ".", "array", "(", "[", "tog", "[", "i", ",", "0", "]", "for", "i", "in", "ind", "]", ")", "\n", "\n", "tp", "=", "sortcounts", "\n", "fp", "=", "sortcounts", ".", "copy", "(", ")", "\n", "for", "i", "in", "range", "(", "sortcounts", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "if", "sortcounts", "[", "i", "]", ">=", "1", ":", "\n", "            ", "fp", "[", "i", "]", "=", "0.", "\n", "", "elif", "sortcounts", "[", "i", "]", "<", "1", ":", "\n", "            ", "fp", "[", "i", "]", "=", "1.", "\n", "", "", "P", "=", "np", ".", "cumsum", "(", "tp", ")", "/", "(", "np", ".", "cumsum", "(", "tp", ")", "+", "np", ".", "cumsum", "(", "fp", ")", ")", "\n", "numinst", "=", "np", ".", "sum", "(", "targets", ")", "\n", "R", "=", "np", ".", "cumsum", "(", "tp", ")", "/", "numinst", "\n", "ap", "=", "calculate_ap", "(", "R", ",", "P", ")", "\n", "return", "P", ",", "R", ",", "score", ",", "ap", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.get_low_shot_output_file": [[119, 128], ["os.path.join", "svm_helper.py2_py3_compatible_cost", "str"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.py2_py3_compatible_cost"], ["", "def", "get_low_shot_output_file", "(", "opts", ",", "cls", ",", "cost", ",", "suffix", ")", ":", "\n", "# in case of low-shot training, we train for 5 independent samples", "\n", "# (sample{}) and vary low-shot amount (k{}). The input data should have", "\n", "# sample{}_k{} information that we extract in suffix below.", "\n", "# logger.info('Suffix: {}'.format(suffix))", "\n", "    ", "cls_cost", "=", "str", "(", "cls", ")", "+", "'_cost'", "+", "py2_py3_compatible_cost", "(", "cost", ")", "\n", "out_file", "=", "os", ".", "path", ".", "join", "(", "opts", ".", "output_path", ",", "\n", "'cls'", "+", "cls_cost", "+", "'_'", "+", "suffix", "+", "'.pickle'", ")", "\n", "return", "out_file", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.get_low_shot_svm_classes": [[130, 145], ["range", "len", "list", "logger.info", "set", "set", "targets[].tolist", "targets[].tolist"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["", "def", "get_low_shot_svm_classes", "(", "targets", ",", "dataset", ")", ":", "\n", "# classes for which SVM testing should be done", "\n", "    ", "num_classes", ",", "cls_list", "=", "None", ",", "None", "\n", "if", "dataset", "==", "'voc'", ":", "\n", "        ", "num_classes", "=", "targets", ".", "shape", "[", "1", "]", "\n", "cls_list", "=", "range", "(", "num_classes", ")", "\n", "", "elif", "dataset", "==", "'places'", ":", "\n", "# each image in places has a target cls [0, .... ,204]", "\n", "        ", "num_classes", "=", "len", "(", "set", "(", "targets", "[", ":", ",", "0", "]", ".", "tolist", "(", ")", ")", ")", "\n", "cls_list", "=", "list", "(", "set", "(", "targets", "[", ":", ",", "0", "]", ".", "tolist", "(", ")", ")", ")", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "'Dataset not recognized. Abort!'", ")", "\n", "#logger.info('Testing SVM for classes: {}'.format(cls_list))", "\n", "#logger.info('Num classes: {}'.format(num_classes))", "\n", "", "return", "num_classes", ",", "cls_list", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.get_cls_feats_labels": [[147, 172], ["targets[].astype", "targets.astype", "numpy.where", "out_cls_labels.reshape.reshape", "Exception", "numpy.where"], "function", ["None"], ["", "def", "get_cls_feats_labels", "(", "cls", ",", "features", ",", "targets", ",", "dataset", ")", ":", "\n", "    ", "out_feats", ",", "out_cls_labels", "=", "None", ",", "None", "\n", "if", "dataset", "==", "'voc'", ":", "\n", "        ", "cls_labels", "=", "targets", "[", ":", ",", "cls", "]", ".", "astype", "(", "dtype", "=", "np", ".", "int32", ",", "copy", "=", "True", ")", "\n", "# find the indices for positive/negative imgs. Remove the ignore label.", "\n", "out_data_inds", "=", "(", "targets", "[", ":", ",", "cls", "]", "!=", "-", "1", ")", "\n", "out_feats", "=", "features", "[", "out_data_inds", "]", "\n", "out_cls_labels", "=", "cls_labels", "[", "out_data_inds", "]", "\n", "# label 0 = not present, set it to -1 as svm train target.", "\n", "# Make the svm train target labels as -1, 1.", "\n", "out_cls_labels", "[", "np", ".", "where", "(", "out_cls_labels", "==", "0", ")", "]", "=", "-", "1", "\n", "", "elif", "dataset", "==", "'places'", ":", "\n", "        ", "out_feats", "=", "features", "\n", "out_cls_labels", "=", "targets", ".", "astype", "(", "dtype", "=", "np", ".", "int32", ",", "copy", "=", "True", ")", "\n", "# for the given class, get the relevant positive/negative images and", "\n", "# make the label 1, -1", "\n", "cls_inds", "=", "np", ".", "where", "(", "targets", "[", ":", ",", "0", "]", "==", "cls", ")", "\n", "non_cls_inds", "=", "(", "targets", "[", ":", ",", "0", "]", "!=", "cls", ")", "\n", "out_cls_labels", "[", "non_cls_inds", "]", "=", "-", "1", "\n", "out_cls_labels", "[", "cls_inds", "]", "=", "1", "\n", "# finally reshape into the format taken by sklearn svm package.", "\n", "out_cls_labels", "=", "out_cls_labels", ".", "reshape", "(", "-", "1", ")", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "'args.dataset not recognized'", ")", "\n", "", "return", "out_feats", ",", "out_cls_labels", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.test_svm_low_shot.load_json": [[36, 43], ["os.path.exists", "list", "list", "open", "json.load", "json.load.keys", "data[].keys"], "function", ["None"], ["def", "load_json", "(", "file_path", ")", ":", "\n", "    ", "assert", "os", ".", "path", ".", "exists", "(", "file_path", ")", ",", "\"{} does not exist\"", ".", "format", "(", "file_path", ")", "\n", "with", "open", "(", "file_path", ",", "'r'", ")", "as", "fp", ":", "\n", "        ", "data", "=", "json", ".", "load", "(", "fp", ")", "\n", "", "img_ids", "=", "list", "(", "data", ".", "keys", "(", ")", ")", "\n", "cls_names", "=", "list", "(", "data", "[", "img_ids", "[", "0", "]", "]", ".", "keys", "(", ")", ")", "\n", "return", "img_ids", ",", "cls_names", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.test_svm_low_shot.save_json_predictions": [[45, 73], ["len", "range", "os.path.join", "svm_helper.get_low_shot_output_file", "pickle.load.decision_function", "range", "open", "json.dump", "open", "len", "pickle.load", "pickle.load"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.get_low_shot_output_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.dump"], ["", "def", "save_json_predictions", "(", "opts", ",", "cost", ",", "sample_idx", ",", "k_low", ",", "features", ",", "cls_list", ",", "\n", "cls_names", ",", "img_ids", ")", ":", "\n", "    ", "num_classes", "=", "len", "(", "cls_list", ")", "\n", "json_predictions", "=", "{", "}", "\n", "for", "cls", "in", "range", "(", "num_classes", ")", ":", "\n", "        ", "suffix", "=", "'sample{}_k{}'", ".", "format", "(", "sample_idx", "+", "1", ",", "k_low", ")", "\n", "model_file", "=", "svm_helper", ".", "get_low_shot_output_file", "(", "\n", "opts", ",", "cls", ",", "cost", ",", "suffix", ")", "\n", "with", "open", "(", "model_file", ",", "'rb'", ")", "as", "fopen", ":", "\n", "            ", "if", "six", ".", "PY2", ":", "\n", "                ", "model", "=", "pickle", ".", "load", "(", "fopen", ")", "\n", "", "else", ":", "\n", "                ", "model", "=", "pickle", ".", "load", "(", "fopen", ",", "encoding", "=", "'latin1'", ")", "\n", "", "", "prediction", "=", "model", ".", "decision_function", "(", "features", ")", "\n", "cls_name", "=", "cls_names", "[", "cls", "]", "\n", "for", "idx", "in", "range", "(", "len", "(", "prediction", ")", ")", ":", "\n", "            ", "img_id", "=", "img_ids", "[", "idx", "]", "\n", "if", "img_id", "in", "json_predictions", ":", "\n", "                ", "json_predictions", "[", "img_id", "]", "[", "cls_name", "]", "=", "prediction", "[", "idx", "]", "\n", "", "else", ":", "\n", "                ", "out_lbl", "=", "{", "}", "\n", "out_lbl", "[", "cls_name", "]", "=", "prediction", "[", "idx", "]", "\n", "json_predictions", "[", "img_id", "]", "=", "out_lbl", "\n", "\n", "", "", "", "output_file", "=", "os", ".", "path", ".", "join", "(", "opts", ".", "output_path", ",", "\n", "'test_{}_json_preds.json'", ".", "format", "(", "suffix", ")", ")", "\n", "with", "open", "(", "output_file", ",", "'w'", ")", "as", "fp", ":", "\n", "        ", "json", ".", "dump", "(", "json_predictions", ",", "fp", ")", "\n", "#logger.info('Saved json predictions to: {}'.format(output_file))", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.test_svm_low_shot.test_svm_low_shot": [[76, 154], ["os.path.exists", "svm_helper.load_input_data", "svm_helper.normalize_features", "svm_helper.parse_cost_list", "svm_helper.get_low_shot_svm_classes", "range", "range", "int", "int", "test_svm_low_shot.load_json", "len", "numpy.zeros", "sample_ap_matrices.append", "len", "range", "opts.k_values.split", "opts.sample_inds.split", "len", "range", "os.path.join", "save_data.reshape.reshape", "numpy.save", "len", "len", "len", "numpy.zeros", "numpy.mean", "numpy.argmax", "test_svm_low_shot.save_json_predictions", "svm_helper.get_low_shot_output_file", "pickle.load.decision_function", "svm_helper.get_cls_feats_labels", "svm_helper.get_precision_recall", "open", "pickle.load", "pickle.load"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.load_input_data", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.normalize_features", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.parse_cost_list", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.get_low_shot_svm_classes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_low_shot_challenge_samples.load_json", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.test_svm_low_shot.save_json_predictions", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.get_low_shot_output_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.get_cls_feats_labels", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.get_precision_recall"], ["", "", "def", "test_svm_low_shot", "(", "opts", ")", ":", "\n", "    ", "k_values", "=", "[", "int", "(", "val", ")", "for", "val", "in", "opts", ".", "k_values", ".", "split", "(", "\",\"", ")", "]", "\n", "sample_inds", "=", "[", "int", "(", "val", ")", "for", "val", "in", "opts", ".", "sample_inds", ".", "split", "(", "\",\"", ")", "]", "\n", "#logger.info('Testing svm for k-values: {} and sample_inds: {}'.format(", "\n", "#    k_values, sample_inds))", "\n", "\n", "img_ids", ",", "cls_names", "=", "[", "]", ",", "[", "]", "\n", "if", "opts", ".", "generate_json", ":", "\n", "        ", "img_ids", ",", "cls_names", "=", "load_json", "(", "opts", ".", "json_targets", ")", "\n", "\n", "", "assert", "os", ".", "path", ".", "exists", "(", "opts", ".", "data_file", ")", ",", "\"Data file not found. Abort!\"", "\n", "# we test the svms on the full test set. Given the test features and the", "\n", "# targets, we test it for various k-values (low-shot), cost values and", "\n", "# 5 independent samples.", "\n", "features", ",", "targets", "=", "svm_helper", ".", "load_input_data", "(", "opts", ".", "data_file", ",", "\n", "opts", ".", "targets_data_file", ")", "\n", "# normalize the features: N x 9216 (example shape)", "\n", "features", "=", "svm_helper", ".", "normalize_features", "(", "features", ")", "\n", "\n", "# parse the cost values for training the SVM on", "\n", "costs_list", "=", "svm_helper", ".", "parse_cost_list", "(", "opts", ".", "costs_list", ")", "\n", "#logger.info('Testing SVM for costs: {}'.format(costs_list))", "\n", "\n", "# classes for which SVM testing should be done", "\n", "num_classes", ",", "cls_list", "=", "svm_helper", ".", "get_low_shot_svm_classes", "(", "\n", "targets", ",", "opts", ".", "dataset", ")", "\n", "\n", "# create the output for per sample, per k-value and per cost.", "\n", "sample_ap_matrices", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "len", "(", "sample_inds", ")", ")", ":", "\n", "        ", "ap_matrix", "=", "np", ".", "zeros", "(", "(", "len", "(", "k_values", ")", ",", "len", "(", "costs_list", ")", ")", ")", "\n", "sample_ap_matrices", ".", "append", "(", "ap_matrix", ")", "\n", "\n", "# the test goes like this: For a given sample, for a given k-value and a", "\n", "# given cost value, we evaluate the trained svm model for all classes.", "\n", "# After computing over all classes, we get the mean AP value over all", "\n", "# classes. We hence end up with: output = [sample][k_value][cost]", "\n", "", "for", "inds", "in", "range", "(", "len", "(", "sample_inds", ")", ")", ":", "\n", "        ", "sample_idx", "=", "sample_inds", "[", "inds", "]", "\n", "for", "k_idx", "in", "range", "(", "len", "(", "k_values", ")", ")", ":", "\n", "            ", "k_low", "=", "k_values", "[", "k_idx", "]", "\n", "suffix", "=", "'sample{}_k{}'", ".", "format", "(", "sample_idx", "+", "1", ",", "k_low", ")", "\n", "for", "cost_idx", "in", "range", "(", "len", "(", "costs_list", ")", ")", ":", "\n", "                ", "cost", "=", "costs_list", "[", "cost_idx", "]", "\n", "local_cost_ap", "=", "np", ".", "zeros", "(", "(", "num_classes", ",", "1", ")", ")", "\n", "for", "cls", "in", "cls_list", ":", "\n", "#logger.info(", "\n", "#    'Test sample/k_value/cost/cls: {}/{}/{}/{}'.format(", "\n", "#        sample_idx + 1, k_low, cost, cls))", "\n", "                    ", "model_file", "=", "svm_helper", ".", "get_low_shot_output_file", "(", "\n", "opts", ",", "cls", ",", "cost", ",", "suffix", ")", "\n", "with", "open", "(", "model_file", ",", "'rb'", ")", "as", "fopen", ":", "\n", "                        ", "if", "six", ".", "PY2", ":", "\n", "                            ", "model", "=", "pickle", ".", "load", "(", "fopen", ")", "\n", "", "else", ":", "\n", "                            ", "model", "=", "pickle", ".", "load", "(", "fopen", ",", "encoding", "=", "'latin1'", ")", "\n", "", "", "prediction", "=", "model", ".", "decision_function", "(", "features", ")", "\n", "eval_preds", ",", "eval_cls_labels", "=", "svm_helper", ".", "get_cls_feats_labels", "(", "\n", "cls", ",", "prediction", ",", "targets", ",", "opts", ".", "dataset", ")", "\n", "P", ",", "R", ",", "score", ",", "ap", "=", "svm_helper", ".", "get_precision_recall", "(", "\n", "eval_cls_labels", ",", "eval_preds", ")", "\n", "local_cost_ap", "[", "cls", "]", "[", "0", "]", "=", "ap", "\n", "", "mean_cost_ap", "=", "np", ".", "mean", "(", "local_cost_ap", ",", "axis", "=", "0", ")", "\n", "sample_ap_matrices", "[", "inds", "]", "[", "k_idx", "]", "[", "cost_idx", "]", "=", "mean_cost_ap", "\n", "", "out_k_sample_file", "=", "os", ".", "path", ".", "join", "(", "\n", "opts", ".", "output_path", ",", "\n", "'test_ap_sample{}_k{}.npy'", ".", "format", "(", "sample_idx", "+", "1", ",", "k_low", ")", ")", "\n", "save_data", "=", "sample_ap_matrices", "[", "inds", "]", "[", "k_idx", "]", "\n", "save_data", "=", "save_data", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "np", ".", "save", "(", "out_k_sample_file", ",", "save_data", ")", "\n", "#logger.info('Saved sample test k_idx AP to file: {} {}'.format(", "\n", "#    out_k_sample_file, save_data.shape))", "\n", "if", "opts", ".", "generate_json", ":", "\n", "                ", "argmax_cls", "=", "np", ".", "argmax", "(", "save_data", ",", "axis", "=", "1", ")", "\n", "chosen_cost", "=", "costs_list", "[", "argmax_cls", "[", "0", "]", "]", "\n", "#logger.info('chosen cost: {}'.format(chosen_cost))", "\n", "save_json_predictions", "(", "opts", ",", "chosen_cost", ",", "sample_idx", ",", "k_low", ",", "\n", "features", ",", "cls_list", ",", "cls_names", ",", "img_ids", ")", "\n", "#logger.info('All done!!')", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.test_svm_low_shot.main": [[157, 209], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "test_svm_low_shot.test_svm_low_shot", "len", "argparse.ArgumentParser.print_help", "sys.exit"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.test_svm_low_shot.test_svm_low_shot"], ["", "", "", "", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Low shot SVM model test'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--data_file'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Numpy file containing image features and labels\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--targets_data_file'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Numpy file containing image labels\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--json_targets'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Numpy file containing json targets\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--generate_json'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "0", ",", "\n", "help", "=", "\"Whether to generate json files for output\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--costs_list'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "\n", "\"0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,1.0,10.0,100.0\"", ",", "\n", "help", "=", "\"comma separated string containing list of costs\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--output_path'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"path where trained SVM models are saved\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--k_values'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "\"1,2,4,8,16,32,64,96\"", ",", "\n", "help", "=", "\"Low-shot k-values for svm testing. Comma separated\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--sample_inds'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "\"0,1,2,3,4\"", ",", "\n", "help", "=", "\"sample_inds for which to test svm. Comma separated\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--dataset'", ",", "type", "=", "str", ",", "default", "=", "\"voc\"", ",", "help", "=", "'voc | places'", ")", "\n", "if", "len", "(", "sys", ".", "argv", ")", "==", "1", ":", "\n", "        ", "parser", ".", "print_help", "(", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "opts", "=", "parser", ".", "parse_args", "(", ")", "\n", "#logger.info(opts)", "\n", "test_svm_low_shot", "(", "opts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.train_svm_low_shot_parallel.task": [[35, 63], ["svm_helper.get_low_shot_output_file", "os.path.exists", "sklearn.svm.LinearSVC", "svm_helper.get_cls_feats_labels", "sklearn.svm.LinearSVC.fit", "[].split", "open", "pickle.dump", "[].split", "opts.targets_data_file.split"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.get_low_shot_output_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.get_cls_feats_labels", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.dump"], ["def", "task", "(", "cls", ",", "cost", ",", "opts", ",", "features", ",", "targets", ")", ":", "\n", "    ", "suffix", "=", "'_'", ".", "join", "(", "\n", "opts", ".", "targets_data_file", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", ".", "split", "(", "'_'", ")", "[", "-", "2", ":", "]", ")", "\n", "out_file", "=", "svm_helper", ".", "get_low_shot_output_file", "(", "opts", ",", "cls", ",", "cost", ",", "suffix", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "out_file", ")", ":", "\n", "        ", "clf", "=", "LinearSVC", "(", "\n", "C", "=", "cost", ",", "\n", "class_weight", "=", "{", "\n", "1", ":", "2", ",", "\n", "-", "1", ":", "1", "\n", "}", ",", "\n", "intercept_scaling", "=", "1.0", ",", "\n", "verbose", "=", "0", ",", "\n", "penalty", "=", "'l2'", ",", "\n", "loss", "=", "'squared_hinge'", ",", "\n", "tol", "=", "0.0001", ",", "\n", "dual", "=", "True", ",", "\n", "max_iter", "=", "2000", ",", "\n", ")", "\n", "train_feats", ",", "train_cls_labels", "=", "svm_helper", ".", "get_cls_feats_labels", "(", "\n", "cls", ",", "features", ",", "targets", ",", "opts", ".", "dataset", ")", "\n", "clf", ".", "fit", "(", "train_feats", ",", "train_cls_labels", ")", "\n", "#cls_labels = targets[:, cls].astype(dtype=np.int32, copy=True)", "\n", "#cls_labels[np.where(cls_labels == 0)] = -1", "\n", "#clf.fit(features, cls_labels)", "\n", "with", "open", "(", "out_file", ",", "'wb'", ")", "as", "fwrite", ":", "\n", "            ", "pickle", ".", "dump", "(", "clf", ",", "fwrite", ")", "\n", "", "", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.train_svm_low_shot_parallel.mp_helper": [[65, 67], ["train_svm_low_shot_parallel.task"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.train_svm_kfold_parallel.task"], ["", "def", "mp_helper", "(", "args", ")", ":", "\n", "    ", "return", "task", "(", "*", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.train_svm_low_shot_parallel.train_svm_low_shot": [[69, 105], ["os.path.exists", "svm_helper.load_input_data", "svm_helper.normalize_features", "svm_helper.parse_cost_list", "svm_helper.get_low_shot_svm_classes", "multiprocessing.Pool", "tqdm.tqdm", "os.path.exists", "os.makedirs", "len", "len", "multiprocessing.cpu_count", "mp.Pool.imap_unordered", "args_cls.append", "args_cost.append", "zip"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.load_input_data", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.normalize_features", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.parse_cost_list", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.get_low_shot_svm_classes"], ["", "def", "train_svm_low_shot", "(", "opts", ")", ":", "\n", "    ", "assert", "os", ".", "path", ".", "exists", "(", "opts", ".", "data_file", ")", ",", "\"Data file not found. Abort!\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "opts", ".", "output_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "opts", ".", "output_path", ")", "\n", "\n", "", "features", ",", "targets", "=", "svm_helper", ".", "load_input_data", "(", "opts", ".", "data_file", ",", "\n", "opts", ".", "targets_data_file", ")", "\n", "# normalize the features: N x 9216 (example shape)", "\n", "features", "=", "svm_helper", ".", "normalize_features", "(", "features", ")", "\n", "\n", "# parse the cost values for training the SVM on", "\n", "costs_list", "=", "svm_helper", ".", "parse_cost_list", "(", "opts", ".", "costs_list", ")", "\n", "\n", "# classes for which SVM testing should be done", "\n", "num_classes", ",", "cls_list", "=", "svm_helper", ".", "get_low_shot_svm_classes", "(", "\n", "targets", ",", "opts", ".", "dataset", ")", "\n", "\n", "num_task", "=", "len", "(", "cls_list", ")", "*", "len", "(", "costs_list", ")", "\n", "args_cls", "=", "[", "]", "\n", "args_cost", "=", "[", "]", "\n", "for", "cls", "in", "cls_list", ":", "\n", "        ", "for", "cost", "in", "costs_list", ":", "\n", "            ", "args_cls", ".", "append", "(", "cls", ")", "\n", "args_cost", ".", "append", "(", "cost", ")", "\n", "", "", "args_opts", "=", "[", "opts", "]", "*", "num_task", "\n", "args_features", "=", "[", "features", "]", "*", "num_task", "\n", "args_targets", "=", "[", "targets", "]", "*", "num_task", "\n", "\n", "pool", "=", "mp", ".", "Pool", "(", "mp", ".", "cpu_count", "(", ")", ")", "\n", "for", "_", "in", "tqdm", ".", "tqdm", "(", "\n", "pool", ".", "imap_unordered", "(", "\n", "mp_helper", ",", "\n", "zip", "(", "args_cls", ",", "args_cost", ",", "args_opts", ",", "args_features", ",", "\n", "args_targets", ")", ")", ",", "\n", "total", "=", "num_task", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.train_svm_low_shot_parallel.main": [[107, 142], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "train_svm_low_shot_parallel.train_svm_low_shot", "len", "argparse.ArgumentParser.print_help", "sys.exit"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.train_svm_low_shot.train_svm_low_shot"], ["", "", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Low-shot SVM model training'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--data_file'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Numpy file containing image features\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--targets_data_file'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Numpy file containing image labels\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--costs_list'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "\"0.01,0.1\"", ",", "\n", "help", "=", "\"comma separated string containing list of costs\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--output_path'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"path where to save the trained SVM models\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--random_seed'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "100", ",", "\n", "help", "=", "\"random seed for SVM classifier training\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--dataset'", ",", "type", "=", "str", ",", "default", "=", "\"voc\"", ",", "help", "=", "'voc | places'", ")", "\n", "if", "len", "(", "sys", ".", "argv", ")", "==", "1", ":", "\n", "        ", "parser", ".", "print_help", "(", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "opts", "=", "parser", ".", "parse_args", "(", ")", "\n", "train_svm_low_shot", "(", "opts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.train_svm_kfold_parallel.task": [[35, 62], ["svm_helper.get_svm_train_output_files", "sklearn.svm.LinearSVC", "targets[].astype", "sklearn.model_selection.cross_val_score", "sklearn.svm.LinearSVC.fit", "numpy.save", "os.path.exists", "os.path.exists", "numpy.array", "open", "pickle.dump", "numpy.where", "sklearn.model_selection.cross_val_score.mean"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.get_svm_train_output_files", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.dump"], ["def", "task", "(", "cls", ",", "cost", ",", "opts", ",", "features", ",", "targets", ")", ":", "\n", "    ", "out_file", ",", "ap_out_file", "=", "svm_helper", ".", "get_svm_train_output_files", "(", "\n", "cls", ",", "cost", ",", "opts", ".", "output_path", ")", "\n", "if", "not", "(", "os", ".", "path", ".", "exists", "(", "out_file", ")", "and", "os", ".", "path", ".", "exists", "(", "ap_out_file", ")", ")", ":", "\n", "        ", "clf", "=", "LinearSVC", "(", "\n", "C", "=", "cost", ",", "\n", "class_weight", "=", "{", "\n", "1", ":", "2", ",", "\n", "-", "1", ":", "1", "\n", "}", ",", "\n", "intercept_scaling", "=", "1.0", ",", "\n", "verbose", "=", "0", ",", "\n", "penalty", "=", "'l2'", ",", "\n", "loss", "=", "'squared_hinge'", ",", "\n", "tol", "=", "0.0001", ",", "\n", "dual", "=", "True", ",", "\n", "max_iter", "=", "2000", ",", "\n", ")", "\n", "cls_labels", "=", "targets", "[", ":", ",", "cls", "]", ".", "astype", "(", "dtype", "=", "np", ".", "int32", ",", "copy", "=", "True", ")", "\n", "cls_labels", "[", "np", ".", "where", "(", "cls_labels", "==", "0", ")", "]", "=", "-", "1", "\n", "ap_scores", "=", "cross_val_score", "(", "\n", "clf", ",", "features", ",", "cls_labels", ",", "cv", "=", "3", ",", "scoring", "=", "'average_precision'", ")", "\n", "clf", ".", "fit", "(", "features", ",", "cls_labels", ")", "\n", "np", ".", "save", "(", "ap_out_file", ",", "np", ".", "array", "(", "[", "ap_scores", ".", "mean", "(", ")", "]", ")", ")", "\n", "with", "open", "(", "out_file", ",", "'wb'", ")", "as", "fwrite", ":", "\n", "            ", "pickle", ".", "dump", "(", "clf", ",", "fwrite", ")", "\n", "", "", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.train_svm_kfold_parallel.mp_helper": [[64, 66], ["train_svm_kfold_parallel.task"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.train_svm_kfold_parallel.task"], ["", "def", "mp_helper", "(", "args", ")", ":", "\n", "    ", "return", "task", "(", "*", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.train_svm_kfold_parallel.train_svm": [[68, 107], ["os.path.exists", "svm_helper.load_input_data", "svm_helper.normalize_features", "svm_helper.parse_cost_list", "multiprocessing.Pool", "tqdm.tqdm", "os.path.exists", "os.makedirs", "range", "len", "len", "multiprocessing.cpu_count", "mp.Pool.imap_unordered", "int", "args_cls.append", "args_cost.append", "zip", "opts.cls_list.split"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.load_input_data", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.normalize_features", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.parse_cost_list"], ["", "def", "train_svm", "(", "opts", ")", ":", "\n", "    ", "assert", "os", ".", "path", ".", "exists", "(", "opts", ".", "data_file", ")", ",", "\"Data file not found. Abort!\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "opts", ".", "output_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "opts", ".", "output_path", ")", "\n", "\n", "", "features", ",", "targets", "=", "svm_helper", ".", "load_input_data", "(", "opts", ".", "data_file", ",", "\n", "opts", ".", "targets_data_file", ")", "\n", "# normalize the features: N x 9216 (example shape)", "\n", "features", "=", "svm_helper", ".", "normalize_features", "(", "features", ")", "\n", "\n", "# parse the cost values for training the SVM on", "\n", "costs_list", "=", "svm_helper", ".", "parse_cost_list", "(", "opts", ".", "costs_list", ")", "\n", "\n", "# classes for which SVM training should be done", "\n", "if", "opts", ".", "cls_list", ":", "\n", "        ", "cls_list", "=", "[", "int", "(", "cls", ")", "for", "cls", "in", "opts", ".", "cls_list", ".", "split", "(", "\",\"", ")", "]", "\n", "", "else", ":", "\n", "        ", "num_classes", "=", "targets", ".", "shape", "[", "1", "]", "\n", "cls_list", "=", "range", "(", "num_classes", ")", "\n", "\n", "", "num_task", "=", "len", "(", "cls_list", ")", "*", "len", "(", "costs_list", ")", "\n", "args_cls", "=", "[", "]", "\n", "args_cost", "=", "[", "]", "\n", "for", "cls", "in", "cls_list", ":", "\n", "        ", "for", "cost", "in", "costs_list", ":", "\n", "            ", "args_cls", ".", "append", "(", "cls", ")", "\n", "args_cost", ".", "append", "(", "cost", ")", "\n", "", "", "args_opts", "=", "[", "opts", "]", "*", "num_task", "\n", "args_features", "=", "[", "features", "]", "*", "num_task", "\n", "args_targets", "=", "[", "targets", "]", "*", "num_task", "\n", "\n", "pool", "=", "mp", ".", "Pool", "(", "mp", ".", "cpu_count", "(", ")", ")", "\n", "for", "_", "in", "tqdm", ".", "tqdm", "(", "\n", "pool", ".", "imap_unordered", "(", "\n", "mp_helper", ",", "\n", "zip", "(", "args_cls", ",", "args_cost", ",", "args_opts", ",", "args_features", ",", "\n", "args_targets", ")", ")", ",", "\n", "total", "=", "num_task", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.train_svm_kfold_parallel.main": [[109, 148], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "train_svm_kfold_parallel.train_svm", "len", "argparse.ArgumentParser.print_help", "sys.exit"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.train_svm_kfold.train_svm"], ["", "", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'SVM model training'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--data_file'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Numpy file containing image features\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--targets_data_file'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Numpy file containing image labels\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--output_path'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"path where to save the trained SVM models\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--costs_list'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "\"0.01,0.1\"", ",", "\n", "help", "=", "\"comma separated string containing list of costs\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--random_seed'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "100", ",", "\n", "help", "=", "\"random seed for SVM classifier training\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "'--cls_list'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"comma separated string list of classes to train\"", ")", "\n", "if", "len", "(", "sys", ".", "argv", ")", "==", "1", ":", "\n", "        ", "parser", ".", "print_help", "(", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "opts", "=", "parser", ".", "parse_args", "(", ")", "\n", "train_svm", "(", "opts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.train_svm_low_shot.train_svm_low_shot": [[39, 100], ["os.path.exists", "svm_helper.load_input_data", "svm_helper.normalize_features", "svm_helper.parse_cost_list", "svm_helper.get_low_shot_svm_classes", "tqdm.tqdm", "os.path.exists", "os.makedirs", "range", "len", "time.time", "svm_helper.get_low_shot_output_file", "os.path.exists", "logger.info", "sklearn.svm.LinearSVC", "svm_helper.get_cls_feats_labels", "sklearn.svm.LinearSVC.fit", "[].split", "open", "pickle.dump", "[].split", "opts.targets_data_file.split"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.load_input_data", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.normalize_features", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.parse_cost_list", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.get_low_shot_svm_classes", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.get_low_shot_output_file", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.get_cls_feats_labels", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.dump"], ["def", "train_svm_low_shot", "(", "opts", ")", ":", "\n", "    ", "assert", "os", ".", "path", ".", "exists", "(", "opts", ".", "data_file", ")", ",", "\"Data file not found. Abort!\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "opts", ".", "output_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "opts", ".", "output_path", ")", "\n", "\n", "", "features", ",", "targets", "=", "svm_helper", ".", "load_input_data", "(", "opts", ".", "data_file", ",", "\n", "opts", ".", "targets_data_file", ")", "\n", "# normalize the features: N x 9216 (example shape)", "\n", "features", "=", "svm_helper", ".", "normalize_features", "(", "features", ")", "\n", "\n", "# parse the cost values for training the SVM on", "\n", "costs_list", "=", "svm_helper", ".", "parse_cost_list", "(", "opts", ".", "costs_list", ")", "\n", "#logger.info('Training SVM for costs: {}'.format(costs_list))", "\n", "\n", "# classes for which SVM testing should be done", "\n", "num_classes", ",", "cls_list", "=", "svm_helper", ".", "get_low_shot_svm_classes", "(", "\n", "targets", ",", "opts", ".", "dataset", ")", "\n", "\n", "for", "cls", "in", "tqdm", "(", "cls_list", ")", ":", "\n", "        ", "for", "cost_idx", "in", "range", "(", "len", "(", "costs_list", ")", ")", ":", "\n", "            ", "start", "=", "time", ".", "time", "(", ")", "\n", "cost", "=", "costs_list", "[", "cost_idx", "]", "\n", "suffix", "=", "'_'", ".", "join", "(", "\n", "opts", ".", "targets_data_file", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", ".", "split", "(", "'_'", ")", "\n", "[", "-", "2", ":", "]", ")", "\n", "out_file", "=", "svm_helper", ".", "get_low_shot_output_file", "(", "\n", "opts", ",", "cls", ",", "cost", ",", "suffix", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "out_file", ")", ":", "\n", "                ", "logger", ".", "info", "(", "'SVM model exists: {}'", ".", "format", "(", "out_file", ")", ")", "\n", "", "else", ":", "\n", "#logger.info('SVM model not found: {}'.format(out_file))", "\n", "#logger.info('Training model with the cost: {}'.format(cost))", "\n", "                ", "clf", "=", "LinearSVC", "(", "\n", "C", "=", "cost", ",", "\n", "class_weight", "=", "{", "\n", "1", ":", "2", ",", "\n", "-", "1", ":", "1", "\n", "}", ",", "\n", "intercept_scaling", "=", "1.0", ",", "\n", "verbose", "=", "0", ",", "\n", "penalty", "=", "'l2'", ",", "\n", "loss", "=", "'squared_hinge'", ",", "\n", "tol", "=", "0.0001", ",", "\n", "dual", "=", "True", ",", "\n", "max_iter", "=", "2000", ",", "\n", ")", "\n", "train_feats", ",", "train_cls_labels", "=", "svm_helper", ".", "get_cls_feats_labels", "(", "\n", "cls", ",", "features", ",", "targets", ",", "opts", ".", "dataset", ")", "\n", "#num_positives = len(np.where(train_cls_labels == 1)[0])", "\n", "#num_negatives = len(np.where(train_cls_labels == -1)[0])", "\n", "\n", "#logger.info('cls: {} has +ve: {} -ve: {} ratio: {}'.format(", "\n", "#    cls, num_positives, num_negatives,", "\n", "#    float(num_positives) / num_negatives)", "\n", "#)", "\n", "#logger.info('features: {} cls_labels: {}'.format(", "\n", "#    train_feats.shape, train_cls_labels.shape))", "\n", "clf", ".", "fit", "(", "train_feats", ",", "train_cls_labels", ")", "\n", "#logger.info('Saving SVM model to: {}'.format(out_file))", "\n", "with", "open", "(", "out_file", ",", "'wb'", ")", "as", "fwrite", ":", "\n", "                    ", "pickle", ".", "dump", "(", "clf", ",", "fwrite", ")", "\n", "#print(\"time: {:.4g} s\".format(time.time() - start))", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.train_svm_low_shot.main": [[104, 141], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "train_svm_low_shot.train_svm_low_shot", "len", "argparse.ArgumentParser.print_help", "sys.exit"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.train_svm_low_shot.train_svm_low_shot"], ["", "", "", "", "", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Low-shot SVM model training'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--data_file'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Numpy file containing image features\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--targets_data_file'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Numpy file containing image labels\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--costs_list'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "\"0.01,0.1\"", ",", "\n", "help", "=", "\"comma separated string containing list of costs\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--output_path'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"path where to save the trained SVM models\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--random_seed'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "100", ",", "\n", "help", "=", "\"random seed for SVM classifier training\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--dataset'", ",", "type", "=", "str", ",", "default", "=", "\"voc\"", ",", "help", "=", "'voc | places'", ")", "\n", "if", "len", "(", "sys", ".", "argv", ")", "==", "1", ":", "\n", "        ", "parser", ".", "print_help", "(", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "opts", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "#logger.info(opts)", "\n", "train_svm_low_shot", "(", "opts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.train_svm_kfold.train_svm": [[39, 117], ["os.path.exists", "svm_helper.load_input_data", "svm_helper.normalize_features", "svm_helper.parse_cost_list", "tqdm.tqdm", "os.path.exists", "os.makedirs", "range", "range", "range", "int", "len", "len", "time.time", "svm_helper.get_svm_train_output_files", "print", "opts.cls_list.split", "os.path.exists", "os.path.exists", "logger.info", "logger.info", "sklearn.svm.LinearSVC", "targets[].astype", "sklearn.model_selection.cross_val_score", "sklearn.svm.LinearSVC.fit", "numpy.save", "numpy.array", "open", "pickle.dump", "numpy.where", "time.time", "sklearn.model_selection.cross_val_score.mean"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.load_input_data", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.normalize_features", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.parse_cost_list", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.svm_helper.get_svm_train_output_files", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.dump"], ["def", "train_svm", "(", "opts", ")", ":", "\n", "    ", "assert", "os", ".", "path", ".", "exists", "(", "opts", ".", "data_file", ")", ",", "\"Data file not found. Abort!\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "opts", ".", "output_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "opts", ".", "output_path", ")", "\n", "\n", "", "features", ",", "targets", "=", "svm_helper", ".", "load_input_data", "(", "opts", ".", "data_file", ",", "\n", "opts", ".", "targets_data_file", ")", "\n", "# normalize the features: N x 9216 (example shape)", "\n", "features", "=", "svm_helper", ".", "normalize_features", "(", "features", ")", "\n", "\n", "# parse the cost values for training the SVM on", "\n", "costs_list", "=", "svm_helper", ".", "parse_cost_list", "(", "opts", ".", "costs_list", ")", "\n", "#logger.info('Training SVM for costs: {}'.format(costs_list))", "\n", "\n", "# classes for which SVM training should be done", "\n", "if", "opts", ".", "cls_list", ":", "\n", "        ", "cls_list", "=", "[", "int", "(", "cls", ")", "for", "cls", "in", "opts", ".", "cls_list", ".", "split", "(", "\",\"", ")", "]", "\n", "", "else", ":", "\n", "        ", "num_classes", "=", "targets", ".", "shape", "[", "1", "]", "\n", "cls_list", "=", "range", "(", "num_classes", ")", "\n", "#logger.info('Training SVM for classes: {}'.format(cls_list))", "\n", "\n", "", "for", "cls_idx", "in", "tqdm", "(", "range", "(", "len", "(", "cls_list", ")", ")", ")", ":", "\n", "        ", "cls", "=", "cls_list", "[", "cls_idx", "]", "\n", "for", "cost_idx", "in", "range", "(", "len", "(", "costs_list", ")", ")", ":", "\n", "            ", "start", "=", "time", ".", "time", "(", ")", "\n", "cost", "=", "costs_list", "[", "cost_idx", "]", "\n", "out_file", ",", "ap_out_file", "=", "svm_helper", ".", "get_svm_train_output_files", "(", "\n", "cls", ",", "cost", ",", "opts", ".", "output_path", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "out_file", ")", "and", "os", ".", "path", ".", "exists", "(", "ap_out_file", ")", ":", "\n", "                ", "logger", ".", "info", "(", "'SVM model exists: {}'", ".", "format", "(", "out_file", ")", ")", "\n", "logger", ".", "info", "(", "'AP file exists: {}'", ".", "format", "(", "ap_out_file", ")", ")", "\n", "", "else", ":", "\n", "#logger.info('Training model with the cost: {}'.format(cost))", "\n", "                ", "clf", "=", "LinearSVC", "(", "\n", "C", "=", "cost", ",", "\n", "class_weight", "=", "{", "\n", "1", ":", "2", ",", "\n", "-", "1", ":", "1", "\n", "}", ",", "\n", "intercept_scaling", "=", "1.0", ",", "\n", "verbose", "=", "0", ",", "\n", "penalty", "=", "'l2'", ",", "\n", "loss", "=", "'squared_hinge'", ",", "\n", "tol", "=", "0.0001", ",", "\n", "dual", "=", "True", ",", "\n", "max_iter", "=", "2000", ",", "\n", ")", "\n", "cls_labels", "=", "targets", "[", ":", ",", "cls", "]", ".", "astype", "(", "dtype", "=", "np", ".", "int32", ",", "copy", "=", "True", ")", "\n", "# meaning of labels in VOC/COCO original loaded target files:", "\n", "# label 0 = not present, set it to -1 as svm train target", "\n", "# label 1 = present. Make the svm train target labels as -1, 1.", "\n", "cls_labels", "[", "np", ".", "where", "(", "cls_labels", "==", "0", ")", "]", "=", "-", "1", "\n", "#num_positives = len(np.where(cls_labels == 1)[0])", "\n", "#num_negatives = len(cls_labels) - num_positives", "\n", "\n", "#logger.info('cls: {} has +ve: {} -ve: {} ratio: {}'.format(", "\n", "#    cls, num_positives, num_negatives,", "\n", "#    float(num_positives) / num_negatives)", "\n", "#)", "\n", "#logger.info('features: {} cls_labels: {}'.format(", "\n", "#    features.shape, cls_labels.shape))", "\n", "ap_scores", "=", "cross_val_score", "(", "\n", "clf", ",", "\n", "features", ",", "\n", "cls_labels", ",", "\n", "cv", "=", "3", ",", "\n", "scoring", "=", "'average_precision'", ")", "\n", "clf", ".", "fit", "(", "features", ",", "cls_labels", ")", "\n", "\n", "#logger.info('cls: {} cost: {} AP: {} mean:{}'.format(", "\n", "#    cls, cost, ap_scores, ap_scores.mean()))", "\n", "#logger.info('Saving cls cost AP to: {}'.format(ap_out_file))", "\n", "np", ".", "save", "(", "ap_out_file", ",", "np", ".", "array", "(", "[", "ap_scores", ".", "mean", "(", ")", "]", ")", ")", "\n", "#logger.info('Saving SVM model to: {}'.format(out_file))", "\n", "with", "open", "(", "out_file", ",", "'wb'", ")", "as", "fwrite", ":", "\n", "                    ", "pickle", ".", "dump", "(", "clf", ",", "fwrite", ")", "\n", "", "", "print", "(", "\"time: {:.4g} s\"", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.train_svm_kfold.main": [[119, 159], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "train_svm_kfold.train_svm", "len", "argparse.ArgumentParser.print_help", "sys.exit"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.train_svm_kfold.train_svm"], ["", "", "", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'SVM model training'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--data_file'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Numpy file containing image features\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--targets_data_file'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Numpy file containing image labels\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--output_path'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"path where to save the trained SVM models\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--costs_list'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "\"0.01,0.1\"", ",", "\n", "help", "=", "\"comma separated string containing list of costs\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--random_seed'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "100", ",", "\n", "help", "=", "\"random seed for SVM classifier training\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "'--cls_list'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"comma separated string list of classes to train\"", ")", "\n", "if", "len", "(", "sys", ".", "argv", ")", "==", "1", ":", "\n", "        ", "parser", ".", "print_help", "(", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "opts", "=", "parser", ".", "parse_args", "(", ")", "\n", "#logger.info(opts)", "\n", "train_svm", "(", "opts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.aggregate_low_shot_svm_stats.save_stats": [[33, 37], ["os.path.join", "numpy.save"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save"], ["def", "save_stats", "(", "output_dir", ",", "stat", ",", "output", ")", ":", "\n", "    ", "out_file", "=", "os", ".", "path", ".", "join", "(", "output_dir", ",", "'test_ap_{}.npy'", ".", "format", "(", "stat", ")", ")", "\n", "#logger.info('Saving {} to: {} {}'.format(stat, out_file, output.shape))", "\n", "np", ".", "save", "(", "out_file", ",", "output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.aggregate_low_shot_svm_stats.aggregate_stats": [[39, 96], ["range", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "aggregate_low_shot_svm_stats.save_stats", "aggregate_low_shot_svm_stats.save_stats", "aggregate_low_shot_svm_stats.save_stats", "aggregate_low_shot_svm_stats.save_stats", "numpy.argmax", "range", "range", "int", "int", "len", "range", "numpy.concatenate", "numpy.max().reshape", "numpy.min().reshape", "numpy.mean().reshape", "numpy.std().reshape", "np.concatenate.append", "np.concatenate.append", "np.concatenate.append", "np.concatenate.append", "len", "argmax_mean.append", "argmax_min.append", "argmax_max.append", "argmax_std.append", "len", "logger.info", "opts.k_values.split", "opts.sample_inds.split", "len", "os.path.join", "os.path.exists", "np.concatenate.append", "logger.info", "numpy.max", "numpy.min", "numpy.mean", "numpy.std", "round", "round", "round", "round", "numpy.load"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.aggregate_low_shot_svm_stats.save_stats", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.aggregate_low_shot_svm_stats.save_stats", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.aggregate_low_shot_svm_stats.save_stats", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.aggregate_low_shot_svm_stats.save_stats"], ["", "def", "aggregate_stats", "(", "opts", ")", ":", "\n", "    ", "k_values", "=", "[", "int", "(", "val", ")", "for", "val", "in", "opts", ".", "k_values", ".", "split", "(", "\",\"", ")", "]", "\n", "sample_inds", "=", "[", "int", "(", "val", ")", "for", "val", "in", "opts", ".", "sample_inds", ".", "split", "(", "\",\"", ")", "]", "\n", "#logger.info(", "\n", "#    'Aggregating stats for k-values: {} and sample_inds: {}'.format(", "\n", "#        k_values, sample_inds))", "\n", "\n", "output_mean", ",", "output_max", ",", "output_min", ",", "output_std", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "k_idx", "in", "range", "(", "len", "(", "k_values", ")", ")", ":", "\n", "        ", "k_low", "=", "k_values", "[", "k_idx", "]", "\n", "k_val_output", "=", "[", "]", "\n", "for", "inds", "in", "range", "(", "len", "(", "sample_inds", ")", ")", ":", "\n", "            ", "sample_idx", "=", "sample_inds", "[", "inds", "]", "\n", "file_name", "=", "'test_ap_sample{}_k{}.npy'", ".", "format", "(", "\n", "sample_idx", "+", "1", ",", "k_low", ")", "\n", "filepath", "=", "os", ".", "path", ".", "join", "(", "opts", ".", "output_path", ",", "file_name", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "filepath", ")", ":", "\n", "                ", "k_val_output", ".", "append", "(", "np", ".", "load", "(", "filepath", ",", "encoding", "=", "'latin1'", ")", ")", "\n", "", "else", ":", "\n", "                ", "logger", ".", "info", "(", "'file does not exist: {}'", ".", "format", "(", "filepath", ")", ")", "\n", "", "", "k_val_output", "=", "np", ".", "concatenate", "(", "k_val_output", ",", "axis", "=", "0", ")", "\n", "k_low_max", "=", "np", ".", "max", "(", "\n", "k_val_output", ",", "axis", "=", "0", ")", ".", "reshape", "(", "-", "1", ",", "k_val_output", ".", "shape", "[", "1", "]", ")", "\n", "k_low_min", "=", "np", ".", "min", "(", "\n", "k_val_output", ",", "axis", "=", "0", ")", ".", "reshape", "(", "-", "1", ",", "k_val_output", ".", "shape", "[", "1", "]", ")", "\n", "k_low_mean", "=", "np", ".", "mean", "(", "\n", "k_val_output", ",", "axis", "=", "0", ")", ".", "reshape", "(", "-", "1", ",", "k_val_output", ".", "shape", "[", "1", "]", ")", "\n", "k_low_std", "=", "np", ".", "std", "(", "\n", "k_val_output", ",", "axis", "=", "0", ")", ".", "reshape", "(", "-", "1", ",", "k_val_output", ".", "shape", "[", "1", "]", ")", "\n", "output_mean", ".", "append", "(", "k_low_mean", ")", "\n", "output_min", ".", "append", "(", "k_low_min", ")", "\n", "output_max", ".", "append", "(", "k_low_max", ")", "\n", "output_std", ".", "append", "(", "k_low_std", ")", "\n", "\n", "", "output_mean", "=", "np", ".", "concatenate", "(", "output_mean", ",", "axis", "=", "0", ")", "\n", "output_min", "=", "np", ".", "concatenate", "(", "output_min", ",", "axis", "=", "0", ")", "\n", "output_max", "=", "np", ".", "concatenate", "(", "output_max", ",", "axis", "=", "0", ")", "\n", "output_std", "=", "np", ".", "concatenate", "(", "output_std", ",", "axis", "=", "0", ")", "\n", "\n", "save_stats", "(", "opts", ".", "output_path", ",", "'mean'", ",", "output_mean", ")", "\n", "save_stats", "(", "opts", ".", "output_path", ",", "'min'", ",", "output_min", ")", "\n", "save_stats", "(", "opts", ".", "output_path", ",", "'max'", ",", "output_max", ")", "\n", "save_stats", "(", "opts", ".", "output_path", ",", "'std'", ",", "output_std", ")", "\n", "\n", "argmax_cls", "=", "np", ".", "argmax", "(", "output_mean", ",", "axis", "=", "1", ")", "\n", "argmax_mean", ",", "argmax_min", ",", "argmax_max", ",", "argmax_std", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "idx", "in", "range", "(", "len", "(", "argmax_cls", ")", ")", ":", "\n", "        ", "argmax_mean", ".", "append", "(", "100.0", "*", "output_mean", "[", "idx", ",", "argmax_cls", "[", "idx", "]", "]", ")", "\n", "argmax_min", ".", "append", "(", "100.0", "*", "output_min", "[", "idx", ",", "argmax_cls", "[", "idx", "]", "]", ")", "\n", "argmax_max", ".", "append", "(", "100.0", "*", "output_max", "[", "idx", ",", "argmax_cls", "[", "idx", "]", "]", ")", "\n", "argmax_std", ".", "append", "(", "100.0", "*", "output_std", "[", "idx", ",", "argmax_cls", "[", "idx", "]", "]", ")", "\n", "", "for", "idx", "in", "range", "(", "len", "(", "argmax_max", ")", ")", ":", "\n", "        ", "logger", ".", "info", "(", "'mean/min/max/std: {} / {} / {} / {}'", ".", "format", "(", "\n", "round", "(", "argmax_mean", "[", "idx", "]", ",", "2", ")", ",", "\n", "round", "(", "argmax_min", "[", "idx", "]", ",", "2", ")", ",", "\n", "round", "(", "argmax_max", "[", "idx", "]", ",", "2", ")", ",", "\n", "round", "(", "argmax_std", "[", "idx", "]", ",", "2", ")", ",", "\n", ")", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.aggregate_low_shot_svm_stats.main": [[100, 124], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "aggregate_low_shot_svm_stats.aggregate_stats", "len", "argparse.ArgumentParser.print_help", "sys.exit"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.svm_tools.aggregate_low_shot_svm_stats.aggregate_stats"], ["", "", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Low shot SVM model test'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--output_path'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Numpy file containing test AP result files\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--k_values'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Low-shot k-values for svm testing. Comma separated\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--sample_inds'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"sample_inds for which to test svm. Comma separated\"", ")", "\n", "if", "len", "(", "sys", ".", "argv", ")", "==", "1", ":", "\n", "        ", "parser", ".", "print_help", "(", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "opts", "=", "parser", ".", "parse_args", "(", ")", "\n", "#logger.info(opts)", "\n", "aggregate_stats", "(", "opts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_low_shot_challenge_samples.load_json": [[30, 45], ["os.path.exists", "sorted", "sorted", "range", "open", "json.load", "list", "list", "numpy.empty", "numpy.empty", "len", "range", "json.load.keys", "data[].keys", "len", "len", "len", "len", "len"], "function", ["None"], ["def", "load_json", "(", "file_path", ",", "ground_truth", "=", "True", ")", ":", "\n", "    ", "import", "json", "\n", "assert", "os", ".", "path", ".", "exists", "(", "file_path", ")", ",", "\"{} does not exist\"", ".", "format", "(", "file_path", ")", "\n", "with", "open", "(", "file_path", ",", "'r'", ")", "as", "fp", ":", "\n", "        ", "data", "=", "json", ".", "load", "(", "fp", ")", "\n", "", "img_ids", "=", "sorted", "(", "list", "(", "data", ".", "keys", "(", ")", ")", ")", "\n", "cls_names", "=", "sorted", "(", "list", "(", "data", "[", "img_ids", "[", "0", "]", "]", ".", "keys", "(", ")", ")", ")", "\n", "if", "ground_truth", ":", "\n", "        ", "output", "=", "np", ".", "empty", "(", "(", "len", "(", "img_ids", ")", ",", "len", "(", "cls_names", ")", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "", "else", ":", "\n", "        ", "output", "=", "np", ".", "empty", "(", "(", "len", "(", "img_ids", ")", ",", "len", "(", "cls_names", ")", ")", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "", "for", "idx", "in", "range", "(", "len", "(", "img_ids", ")", ")", ":", "\n", "        ", "for", "cls_idx", "in", "range", "(", "len", "(", "cls_names", ")", ")", ":", "\n", "            ", "output", "[", "idx", "]", "[", "cls_idx", "]", "=", "data", "[", "img_ids", "[", "idx", "]", "]", "[", "cls_names", "[", "cls_idx", "]", "]", "\n", "", "", "return", "output", ",", "img_ids", ",", "cls_names", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_low_shot_challenge_samples.save_json": [[47, 59], ["range", "logger.info", "len", "range", "open", "json.dump", "len", "int"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.dump"], ["", "def", "save_json", "(", "input_data", ",", "img_ids", ",", "cls_names", ",", "output_file", ")", ":", "\n", "    ", "output_dict", "=", "{", "}", "\n", "for", "img_idx", "in", "range", "(", "len", "(", "img_ids", ")", ")", ":", "\n", "        ", "img_id", "=", "img_ids", "[", "img_idx", "]", "\n", "out_lbl", "=", "{", "}", "\n", "for", "cls_idx", "in", "range", "(", "len", "(", "cls_names", ")", ")", ":", "\n", "            ", "name", "=", "cls_names", "[", "cls_idx", "]", "\n", "out_lbl", "[", "name", "]", "=", "int", "(", "input_data", "[", "img_idx", "]", "[", "cls_idx", "]", ")", "\n", "", "output_dict", "[", "img_id", "]", "=", "out_lbl", "\n", "", "logger", ".", "info", "(", "'Saving file: {}'", ".", "format", "(", "output_file", ")", ")", "\n", "with", "open", "(", "output_file", ",", "'w'", ")", "as", "fp", ":", "\n", "        ", "json", ".", "dump", "(", "output_dict", ",", "fp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_low_shot_challenge_samples.sample_symbol": [[61, 70], ["logger.info", "range", "random.sample", "numpy.where", "list"], "function", ["None"], ["", "", "def", "sample_symbol", "(", "input_targets", ",", "output_target", ",", "symbol", ",", "num", ")", ":", "\n", "    ", "logger", ".", "info", "(", "'Sampling symbol: {} for num: {}'", ".", "format", "(", "symbol", ",", "num", ")", ")", "\n", "num_classes", "=", "input_targets", ".", "shape", "[", "1", "]", "\n", "for", "idx", "in", "range", "(", "num_classes", ")", ":", "\n", "        ", "symbol_data", "=", "np", ".", "where", "(", "input_targets", "[", ":", ",", "idx", "]", "==", "symbol", ")", "[", "0", "]", "\n", "sampled", "=", "random", ".", "sample", "(", "list", "(", "symbol_data", ")", ",", "num", ")", "\n", "for", "index", "in", "sampled", ":", "\n", "            ", "output_target", "[", "index", ",", "idx", "]", "=", "symbol", "\n", "", "", "return", "output_target", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_low_shot_challenge_samples.generate_independent_sample": [[72, 97], ["range", "logger.info", "int", "opts.k_values.split", "logger.info", "create_voc_low_shot_challenge_samples.sample_symbol", "create_voc_low_shot_challenge_samples.sample_symbol", "os.path.join", "create_voc_low_shot_challenge_samples.save_json", "os.path.join", "logger.info", "numpy.save", "numpy.ones", "[].split", "opts.targets_data_file.split"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_low_shot_challenge_samples.sample_symbol", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_low_shot_challenge_samples.sample_symbol", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_low_shot_challenge_samples.save_json", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save"], ["", "def", "generate_independent_sample", "(", "opts", ",", "targets", ",", "img_ids", ",", "cls_names", ")", ":", "\n", "    ", "k_values", "=", "[", "int", "(", "val", ")", "for", "val", "in", "opts", ".", "k_values", ".", "split", "(", "\",\"", ")", "]", "\n", "# the way sample works is: for each independent sample, and a given k value", "\n", "# we create a matrix of the same shape as given targets file. We initialize", "\n", "# this matrix with -1 (ignore label). We then sample k positive and", "\n", "# (num_classes-1) * k negatives.", "\n", "# N x 20 shape", "\n", "num_classes", "=", "targets", ".", "shape", "[", "1", "]", "\n", "for", "idx", "in", "range", "(", "opts", ".", "num_samples", ")", ":", "\n", "        ", "for", "k", "in", "k_values", ":", "\n", "            ", "logger", ".", "info", "(", "'Sampling: {} time for k-value: {}'", ".", "format", "(", "idx", "+", "1", ",", "k", ")", ")", "\n", "output", "=", "np", ".", "ones", "(", "targets", ".", "shape", ",", "dtype", "=", "np", ".", "int32", ")", "*", "-", "1", "\n", "output", "=", "sample_symbol", "(", "targets", ",", "output", ",", "1", ",", "k", ")", "\n", "output", "=", "sample_symbol", "(", "targets", ",", "output", ",", "0", ",", "(", "num_classes", "-", "1", ")", "*", "k", ")", "\n", "prefix", "=", "opts", ".", "targets_data_file", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "output_file", "=", "os", ".", "path", ".", "join", "(", "\n", "opts", ".", "output_path", ",", "\n", "'{}_sample{}_k{}.json'", ".", "format", "(", "prefix", ",", "idx", "+", "1", ",", "k", ")", ")", "\n", "save_json", "(", "output", ",", "img_ids", ",", "cls_names", ",", "output_file", ")", "\n", "npy_output_file", "=", "os", ".", "path", ".", "join", "(", "\n", "opts", ".", "output_path", ",", "\n", "'{}_sample{}_k{}.npy'", ".", "format", "(", "prefix", ",", "idx", "+", "1", ",", "k", ")", ")", "\n", "logger", ".", "info", "(", "'Saving npy file: {}'", ".", "format", "(", "npy_output_file", ")", ")", "\n", "np", ".", "save", "(", "npy_output_file", ",", "output", ")", "\n", "", "", "logger", ".", "info", "(", "'Done!!'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_low_shot_challenge_samples.main": [[99, 128], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "create_voc_low_shot_challenge_samples.load_json", "create_voc_low_shot_challenge_samples.generate_independent_sample", "len", "argparse.ArgumentParser.print_help", "sys.exit"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_low_shot_challenge_samples.load_json", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_low_shot_challenge_samples.generate_independent_sample"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Sample Low shot data for VOC'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--targets_data_file'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Json file containing image labels\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--output_path'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"path where low-shot samples should be saved\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--k_values'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "\"1,2,4,8,16,32,64,96\"", ",", "\n", "help", "=", "\"Low-shot k-values for svm testing.\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--num_samples'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "5", ",", "\n", "help", "=", "\"Number of independent samples.\"", ")", "\n", "if", "len", "(", "sys", ".", "argv", ")", "==", "1", ":", "\n", "        ", "parser", ".", "print_help", "(", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "opts", "=", "parser", ".", "parse_args", "(", ")", "\n", "targets", ",", "img_ids", ",", "cls_names", "=", "load_json", "(", "opts", ".", "targets_data_file", ")", "\n", "generate_independent_sample", "(", "opts", ",", "targets", ",", "img_ids", ",", "cls_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_data_files.validate_files": [[32, 42], ["len", "output_files.append", "[].split", "item.split"], "function", ["None"], ["def", "validate_files", "(", "input_files", ")", ":", "\n", "    ", "\"\"\"\n    The valid files will have name: <class_name>_<split>.txt. We want to remove\n    all the other files from the input.\n    \"\"\"", "\n", "output_files", "=", "[", "]", "\n", "for", "item", "in", "input_files", ":", "\n", "        ", "if", "len", "(", "item", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ".", "split", "(", "'_'", ")", ")", "==", "2", ":", "\n", "            ", "output_files", ".", "append", "(", "item", ")", "\n", "", "", "return", "output_files", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_data_files.get_data_files": [[44, 73], ["os.path.join", "os.path.exists", "glob.glob", "create_voc_data_files.validate_files", "os.path.join", "glob.glob", "glob.glob", "create_voc_data_files.validate_files", "create_voc_data_files.validate_files", "glob.glob", "create_voc_data_files.validate_files", "create_voc_data_files.validate_files", "len", "len", "os.path.join", "os.path.join", "len", "len", "os.path.join", "len", "glob.glob", "glob.glob", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_data_files.validate_files", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_data_files.validate_files", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_data_files.validate_files", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_data_files.validate_files", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_data_files.validate_files"], ["", "def", "get_data_files", "(", "split", ",", "args", ")", ":", "\n", "    ", "data_dir", "=", "os", ".", "path", ".", "join", "(", "args", ".", "data_source_dir", ",", "'ImageSets/Main'", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "data_dir", ")", ",", "\"Data: {} doesn't exist\"", ".", "format", "(", "data_dir", ")", "\n", "test_data_files", "=", "glob", "(", "os", ".", "path", ".", "join", "(", "data_dir", ",", "'*_test.txt'", ")", ")", "\n", "test_data_files", "=", "validate_files", "(", "test_data_files", ")", "\n", "if", "args", ".", "separate_partitions", ">", "0", ":", "\n", "        ", "train_data_files", "=", "glob", "(", "os", ".", "path", ".", "join", "(", "data_dir", ",", "'*_train.txt'", ")", ")", "\n", "val_data_files", "=", "glob", "(", "os", ".", "path", ".", "join", "(", "data_dir", ",", "'*_val.txt'", ")", ")", "\n", "train_data_files", "=", "validate_files", "(", "train_data_files", ")", "\n", "val_data_files", "=", "validate_files", "(", "val_data_files", ")", "\n", "assert", "len", "(", "train_data_files", ")", "==", "len", "(", "val_data_files", ")", "\n", "if", "split", "==", "'train'", ":", "\n", "            ", "data_files", "=", "train_data_files", "\n", "", "elif", "split", "==", "'test'", ":", "\n", "            ", "data_files", "=", "test_data_files", "\n", "", "else", ":", "\n", "            ", "data_files", "=", "val_data_files", "\n", "", "", "else", ":", "\n", "        ", "train_data_files", "=", "glob", "(", "os", ".", "path", ".", "join", "(", "data_dir", ",", "'*_trainval.txt'", ")", ")", "\n", "if", "len", "(", "test_data_files", ")", "==", "0", ":", "\n", "# For VOC2012 dataset, we have trainval, val and train data.", "\n", "            ", "train_data_files", "=", "glob", "(", "os", ".", "path", ".", "join", "(", "data_dir", ",", "'*_train.txt'", ")", ")", "\n", "test_data_files", "=", "glob", "(", "os", ".", "path", ".", "join", "(", "data_dir", ",", "'*_val.txt'", ")", ")", "\n", "", "test_data_files", "=", "validate_files", "(", "test_data_files", ")", "\n", "train_data_files", "=", "validate_files", "(", "train_data_files", ")", "\n", "data_files", "=", "train_data_files", "if", "(", "split", "\n", "==", "'train'", ")", "else", "test_data_files", "\n", "", "assert", "len", "(", "train_data_files", ")", "==", "len", "(", "test_data_files", ")", ",", "\"Missing classes\"", "\n", "return", "data_files", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_data_files.get_images_labels_info": [[75, 130], ["os.path.exists", "create_voc_data_files.get_data_files", "enumerate", "sorted", "sorted", "img_labels_map.keys", "img_paths.append", "img_labels.append", "sorted", "sorted", "range", "open", "os.path.join", "cls_names.append", "img_labels_map.keys", "img_ids.append", "json_img_labels.append", "len", "range", "[].split", "len", "int", "line.strip().split", "int", "logger.info", "line.strip", "numpy.ones", "[].split", "len", "item.split"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_data_files.get_data_files"], ["", "def", "get_images_labels_info", "(", "split", ",", "args", ")", ":", "\n", "    ", "assert", "os", ".", "path", ".", "exists", "(", "args", ".", "data_source_dir", ")", ",", "\"Data source NOT found. Abort\"", "\n", "\n", "data_files", "=", "get_data_files", "(", "split", ",", "args", ")", "\n", "# we will construct a map for image name to the vector of -1, 0, 1", "\n", "# we sort the data_files which gives sorted class names as well", "\n", "img_labels_map", "=", "{", "}", "\n", "for", "cls_num", ",", "data_path", "in", "enumerate", "(", "sorted", "(", "data_files", ")", ")", ":", "\n", "# for this class, we have images and each image will have label", "\n", "# 1, -1, 0 -> present, not present, ignore respectively as in VOC data.", "\n", "        ", "with", "open", "(", "data_path", ",", "'r'", ")", "as", "fopen", ":", "\n", "            ", "for", "line", "in", "fopen", ":", "\n", "                ", "try", ":", "\n", "                    ", "img_name", ",", "orig_label", "=", "line", ".", "strip", "(", ")", ".", "split", "(", ")", "\n", "if", "img_name", "not", "in", "img_labels_map", ":", "\n", "                        ", "img_labels_map", "[", "img_name", "]", "=", "-", "np", ".", "ones", "(", "\n", "len", "(", "data_files", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "", "orig_label", "=", "int", "(", "orig_label", ")", "\n", "# in VOC data, -1 (not present), set it to 0 as train target", "\n", "if", "orig_label", "==", "-", "1", ":", "\n", "                        ", "orig_label", "=", "0", "\n", "# in VOC data, 0 (ignore), set it to -1 as train target", "\n", "", "elif", "orig_label", "==", "0", ":", "\n", "                        ", "orig_label", "=", "-", "1", "\n", "", "img_labels_map", "[", "img_name", "]", "[", "cls_num", "]", "=", "orig_label", "\n", "", "except", "Exception", ":", "\n", "                    ", "logger", ".", "info", "(", "'Error processing: {} data_path: {}'", ".", "format", "(", "\n", "line", ",", "data_path", ")", ")", "\n", "\n", "", "", "", "", "img_paths", ",", "img_labels", "=", "[", "]", ",", "[", "]", "\n", "for", "item", "in", "sorted", "(", "img_labels_map", ".", "keys", "(", ")", ")", ":", "\n", "        ", "img_paths", ".", "append", "(", "\n", "os", ".", "path", ".", "join", "(", "args", ".", "data_source_dir", ",", "'JPEGImages'", ",", "item", "+", "'.jpg'", ")", ")", "\n", "img_labels", ".", "append", "(", "img_labels_map", "[", "item", "]", ")", "\n", "\n", "", "output_dict", "=", "{", "}", "\n", "if", "args", ".", "generate_json", ":", "\n", "        ", "cls_names", "=", "[", "]", "\n", "for", "item", "in", "sorted", "(", "data_files", ")", ":", "\n", "            ", "name", "=", "item", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", ".", "split", "(", "'_'", ")", "[", "0", "]", "\n", "cls_names", ".", "append", "(", "name", ")", "\n", "\n", "", "img_ids", ",", "json_img_labels", "=", "[", "]", ",", "[", "]", "\n", "for", "item", "in", "sorted", "(", "img_labels_map", ".", "keys", "(", ")", ")", ":", "\n", "            ", "img_ids", ".", "append", "(", "item", ")", "\n", "json_img_labels", ".", "append", "(", "img_labels_map", "[", "item", "]", ")", "\n", "\n", "", "for", "img_idx", "in", "range", "(", "len", "(", "img_ids", ")", ")", ":", "\n", "            ", "img_id", "=", "img_ids", "[", "img_idx", "]", "\n", "out_lbl", "=", "{", "}", "\n", "for", "cls_idx", "in", "range", "(", "len", "(", "cls_names", ")", ")", ":", "\n", "                ", "name", "=", "cls_names", "[", "cls_idx", "]", "\n", "out_lbl", "[", "name", "]", "=", "int", "(", "json_img_labels", "[", "img_idx", "]", "[", "cls_idx", "]", ")", "\n", "", "output_dict", "[", "img_id", "]", "=", "out_lbl", "\n", "", "", "return", "img_paths", ",", "img_labels", ",", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_data_files.main": [[132, 190], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "logger.info", "partitions.append", "logger.info", "create_voc_data_files.get_images_labels_info", "os.path.join", "os.path.join", "logger.info", "logger.info", "logger.info", "logger.info", "numpy.save", "numpy.save", "numpy.array", "numpy.array", "os.path.join", "logger.info", "open", "json.dump", "numpy.array"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.tools.extract.parse_args", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.prepare_data.create_voc_data_files.get_images_labels_info", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.config.config.CfgNode.dump"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "\"Create VOC data files\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--data_source_dir'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Path to data directory containing ImageSets and JPEGImages\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--output_dir'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "\"Output directory where images/label information will be written\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--separate_partitions'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "0", ",", "\n", "help", "=", "\"Whether to create files separately for partitions train/test/val\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--generate_json'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "0", ",", "\n", "help", "=", "\"Whether to json files for partitions train/test/val\"", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "# given the data directory for the partitions train, val, and test, we will", "\n", "# write numpy files for each partition.", "\n", "partitions", "=", "[", "'train'", ",", "'test'", "]", "\n", "if", "args", ".", "separate_partitions", ">", "0", ":", "\n", "        ", "partitions", ".", "append", "(", "'val'", ")", "\n", "\n", "", "for", "partition", "in", "partitions", ":", "\n", "        ", "logger", ".", "info", "(", "\n", "'========Preparing {} data files========'", ".", "format", "(", "partition", ")", ")", "\n", "imgs_info", ",", "lbls_info", ",", "output_dict", "=", "get_images_labels_info", "(", "\n", "partition", ",", "args", ")", "\n", "img_info_out_path", "=", "os", ".", "path", ".", "join", "(", "args", ".", "output_dir", ",", "\n", "partition", "+", "'_images.npy'", ")", "\n", "label_info_out_path", "=", "os", ".", "path", ".", "join", "(", "args", ".", "output_dir", ",", "\n", "partition", "+", "'_labels.npy'", ")", "\n", "logger", ".", "info", "(", "\n", "'=================SAVING DATA files======================='", ")", "\n", "logger", ".", "info", "(", "'partition: {} saving img_paths to: {}'", ".", "format", "(", "\n", "partition", ",", "img_info_out_path", ")", ")", "\n", "logger", ".", "info", "(", "'partition: {} saving lbls_paths: {}'", ".", "format", "(", "\n", "partition", ",", "label_info_out_path", ")", ")", "\n", "logger", ".", "info", "(", "'partition: {} imgs: {}'", ".", "format", "(", "partition", ",", "\n", "np", ".", "array", "(", "imgs_info", ")", ".", "shape", ")", ")", "\n", "np", ".", "save", "(", "img_info_out_path", ",", "np", ".", "array", "(", "imgs_info", ")", ")", "\n", "np", ".", "save", "(", "label_info_out_path", ",", "np", ".", "array", "(", "lbls_info", ")", ")", "\n", "if", "args", ".", "generate_json", ":", "\n", "            ", "json_out_path", "=", "os", ".", "path", ".", "join", "(", "args", ".", "output_dir", ",", "\n", "partition", "+", "'_targets.json'", ")", "\n", "import", "json", "\n", "with", "open", "(", "json_out_path", ",", "'w'", ")", "as", "fp", ":", "\n", "                ", "json", ".", "dump", "(", "output_dict", ",", "fp", ")", "\n", "", "logger", ".", "info", "(", "'Saved Json to: {}'", ".", "format", "(", "json_out_path", ")", ")", "\n", "", "", "logger", ".", "info", "(", "'DONE!'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.third_party.clustering.Kmeans.__init__": [[120, 123], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "k", ",", "pca_dim", "=", "256", ")", ":", "\n", "        ", "self", ".", "k", "=", "k", "\n", "self", ".", "pca_dim", "=", "pca_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.third_party.clustering.Kmeans.cluster": [[124, 141], ["time.time", "clustering.preprocess_features", "clustering.run_kmeans", "numpy.array", "print", "time.time"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.third_party.clustering.preprocess_features", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.third_party.clustering.run_kmeans"], ["", "def", "cluster", "(", "self", ",", "feat", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "\"\"\"Performs k-means clustering.\n            Args:\n                x_data (np.array N * dim): data to cluster\n        \"\"\"", "\n", "end", "=", "time", ".", "time", "(", ")", "\n", "\n", "# PCA-reducing, whitening and L2-normalization", "\n", "xb", "=", "preprocess_features", "(", "feat", ",", "self", ".", "pca_dim", ")", "\n", "\n", "# cluster the data", "\n", "I", ",", "loss", "=", "run_kmeans", "(", "xb", ",", "self", ".", "k", ",", "verbose", ")", "\n", "self", ".", "labels", "=", "np", ".", "array", "(", "I", ")", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'k-means time: {0:.0f} s'", ".", "format", "(", "time", ".", "time", "(", ")", "-", "end", ")", ")", "\n", "\n", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.third_party.clustering.PIC.__init__": [[252, 264], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "args", "=", "None", ",", "\n", "sigma", "=", "0.2", ",", "\n", "nnn", "=", "5", ",", "\n", "alpha", "=", "0.001", ",", "\n", "distribute_singletons", "=", "True", ",", "\n", "pca_dim", "=", "256", ")", ":", "\n", "        ", "self", ".", "sigma", "=", "sigma", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "nnn", "=", "nnn", "\n", "self", ".", "distribute_singletons", "=", "distribute_singletons", "\n", "self", ".", "pca_dim", "=", "pca_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.third_party.clustering.PIC.cluster": [[265, 310], ["time.time", "clustering.preprocess_features", "clustering.make_graph", "clustering.run_pic", "set", "enumerate", "enumerate", "numpy.all", "images_lists[].append", "numpy.ones", "clustering.PIC.images_lists.append", "print", "images_lists[].append", "len", "time.time", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.third_party.clustering.preprocess_features", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.third_party.clustering.make_graph", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.third_party.clustering.run_pic", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.set"], ["", "def", "cluster", "(", "self", ",", "data", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "end", "=", "time", ".", "time", "(", ")", "\n", "\n", "# preprocess the data", "\n", "xb", "=", "preprocess_features", "(", "data", ",", "self", ".", "pca_dim", ")", "\n", "\n", "# construct nnn graph", "\n", "I", ",", "D", "=", "make_graph", "(", "xb", ",", "self", ".", "nnn", ")", "\n", "\n", "# run PIC", "\n", "clust", "=", "run_pic", "(", "I", ",", "D", ",", "self", ".", "sigma", ",", "self", ".", "alpha", ")", "\n", "images_lists", "=", "{", "}", "\n", "for", "h", "in", "set", "(", "clust", ")", ":", "\n", "            ", "images_lists", "[", "h", "]", "=", "[", "]", "\n", "", "for", "data", ",", "c", "in", "enumerate", "(", "clust", ")", ":", "\n", "            ", "images_lists", "[", "c", "]", ".", "append", "(", "data", ")", "\n", "\n", "# allocate singletons to clusters of their closest NN not singleton", "\n", "", "if", "self", ".", "distribute_singletons", ":", "\n", "            ", "clust_NN", "=", "{", "}", "\n", "for", "i", "in", "images_lists", ":", "\n", "# if singleton", "\n", "                ", "if", "len", "(", "images_lists", "[", "i", "]", ")", "==", "1", ":", "\n", "                    ", "s", "=", "images_lists", "[", "i", "]", "[", "0", "]", "\n", "# for NN", "\n", "for", "n", "in", "I", "[", "s", ",", "1", ":", "]", ":", "\n", "# if NN is not a singleton", "\n", "                        ", "if", "not", "len", "(", "images_lists", "[", "clust", "[", "n", "]", "]", ")", "==", "1", ":", "\n", "                            ", "clust_NN", "[", "s", "]", "=", "n", "\n", "break", "\n", "", "", "", "", "for", "s", "in", "clust_NN", ":", "\n", "                ", "del", "images_lists", "[", "clust", "[", "s", "]", "]", "\n", "clust", "[", "s", "]", "=", "clust", "[", "clust_NN", "[", "s", "]", "]", "\n", "images_lists", "[", "clust", "[", "s", "]", "]", ".", "append", "(", "s", ")", "\n", "\n", "", "", "self", ".", "images_lists", "=", "[", "]", "\n", "self", ".", "labels", "=", "-", "1", "*", "np", ".", "ones", "(", "(", "data", ".", "shape", "[", "0", "]", ",", ")", ",", "dtype", "=", "np", ".", "int", ")", "\n", "for", "i", ",", "c", "in", "enumerate", "(", "images_lists", ")", ":", "\n", "            ", "self", ".", "images_lists", ".", "append", "(", "images_lists", "[", "c", "]", ")", "\n", "self", ".", "labels", "[", "images_lists", "[", "c", "]", "]", "=", "i", "\n", "", "assert", "np", ".", "all", "(", "self", ".", "labels", "!=", "-", "1", ")", "\n", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'pic time: {0:.0f} s'", ".", "format", "(", "time", ".", "time", "(", ")", "-", "end", ")", ")", "\n", "", "return", "0", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.third_party.clustering.preprocess_features": [[13, 47], ["numpy.any", "numpy.any", "numpy.linalg.norm", "numpy.isnan", "Exception", "print", "faiss.PCAMatrix", "faiss.PCAMatrix.train", "faiss.PCAMatrix.apply_py", "numpy.isnan", "Exception", "numpy.isnan().sum().item", "float", "numpy.size", "numpy.isnan", "numpy.isnan().sum", "numpy.isnan"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train"], ["def", "preprocess_features", "(", "npdata", ",", "pca", ")", ":", "\n", "    ", "\"\"\"Preprocess an array of features.\n    Args:\n        npdata (np.array N * ndim): features to preprocess\n        pca (int): dim of output\n    Returns:\n        np.array of dim N * pca: data PCA-reduced, whitened and L2-normalized\n    \"\"\"", "\n", "_", ",", "ndim", "=", "npdata", ".", "shape", "\n", "#npdata =  npdata.astype('float32')", "\n", "assert", "npdata", ".", "dtype", "==", "np", ".", "float32", "\n", "\n", "if", "np", ".", "any", "(", "np", ".", "isnan", "(", "npdata", ")", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"nan occurs\"", ")", "\n", "", "if", "pca", "!=", "-", "1", ":", "\n", "        ", "print", "(", "\"\\nPCA from dim {} to dim {}\"", ".", "format", "(", "ndim", ",", "pca", ")", ")", "\n", "mat", "=", "faiss", ".", "PCAMatrix", "(", "ndim", ",", "pca", ",", "eigen_power", "=", "-", "0.5", ")", "\n", "mat", ".", "train", "(", "npdata", ")", "\n", "assert", "mat", ".", "is_trained", "\n", "npdata", "=", "mat", ".", "apply_py", "(", "npdata", ")", "\n", "", "if", "np", ".", "any", "(", "np", ".", "isnan", "(", "npdata", ")", ")", ":", "\n", "        ", "percent", "=", "np", ".", "isnan", "(", "npdata", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "/", "float", "(", "np", ".", "size", "(", "npdata", ")", ")", "*", "100", "\n", "if", "percent", ">", "0.1", ":", "\n", "            ", "raise", "Exception", "(", "\n", "\"More than 0.1% nan occurs after pca, percent: {}%\"", ".", "format", "(", "\n", "percent", ")", ")", "\n", "", "else", ":", "\n", "            ", "npdata", "[", "np", ".", "isnan", "(", "npdata", ")", "]", "=", "0.", "\n", "# L2 normalization", "\n", "", "", "row_sums", "=", "np", ".", "linalg", ".", "norm", "(", "npdata", ",", "axis", "=", "1", ")", "\n", "\n", "npdata", "=", "npdata", "/", "(", "row_sums", "[", ":", ",", "np", ".", "newaxis", "]", "+", "1e-10", ")", "\n", "\n", "return", "npdata", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.third_party.clustering.make_graph": [[49, 70], ["faiss.StandardGpuResources", "faiss.GpuIndexFlatConfig", "faiss.GpuIndexFlatL2", "faiss.GpuIndexFlatL2.add", "faiss.GpuIndexFlatL2.search", "int", "torch.cuda.device_count"], "function", ["None"], ["", "def", "make_graph", "(", "xb", ",", "nnn", ")", ":", "\n", "    ", "\"\"\"Builds a graph of nearest neighbors.\n    Args:\n        xb (np.array): data\n        nnn (int): number of nearest neighbors\n    Returns:\n        list: for each data the list of ids to its nnn nearest neighbors\n        list: for each data the list of distances to its nnn NN\n    \"\"\"", "\n", "N", ",", "dim", "=", "xb", ".", "shape", "\n", "\n", "# we need only a StandardGpuResources per GPU", "\n", "res", "=", "faiss", ".", "StandardGpuResources", "(", ")", "\n", "\n", "# L2", "\n", "flat_config", "=", "faiss", ".", "GpuIndexFlatConfig", "(", ")", "\n", "flat_config", ".", "device", "=", "int", "(", "torch", ".", "cuda", ".", "device_count", "(", ")", ")", "-", "1", "\n", "index", "=", "faiss", ".", "GpuIndexFlatL2", "(", "res", ",", "dim", ",", "flat_config", ")", "\n", "index", ".", "add", "(", "xb", ")", "\n", "D", ",", "I", "=", "index", ".", "search", "(", "xb", ",", "nnn", "+", "1", ")", "\n", "return", "I", ",", "D", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.third_party.clustering.run_kmeans": [[72, 106], ["faiss.Clustering", "numpy.random.randint", "faiss.StandardGpuResources", "faiss.GpuIndexFlatConfig", "faiss.GpuIndexFlatL2", "faiss.Clustering.train", "faiss.GpuIndexFlatL2.search", "faiss.vector_to_array", "print", "int"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train"], ["", "def", "run_kmeans", "(", "x", ",", "nmb_clusters", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"Runs kmeans on 1 GPU.\n    Args:\n        x: data\n        nmb_clusters (int): number of clusters\n    Returns:\n        list: ids of data in each cluster\n    \"\"\"", "\n", "n_data", ",", "d", "=", "x", ".", "shape", "\n", "\n", "# faiss implementation of k-means", "\n", "clus", "=", "faiss", ".", "Clustering", "(", "d", ",", "nmb_clusters", ")", "\n", "\n", "# Change faiss seed at each k-means so that the randomly picked", "\n", "# initialization centroids do not correspond to the same feature ids", "\n", "# from an epoch to another.", "\n", "clus", ".", "seed", "=", "np", ".", "random", ".", "randint", "(", "1234", ")", "\n", "\n", "clus", ".", "niter", "=", "20", "\n", "clus", ".", "max_points_per_centroid", "=", "10000000", "\n", "res", "=", "faiss", ".", "StandardGpuResources", "(", ")", "\n", "flat_config", "=", "faiss", ".", "GpuIndexFlatConfig", "(", ")", "\n", "flat_config", ".", "useFloat16", "=", "False", "\n", "flat_config", ".", "device", "=", "0", "\n", "index", "=", "faiss", ".", "GpuIndexFlatL2", "(", "res", ",", "d", ",", "flat_config", ")", "\n", "\n", "# perform the training", "\n", "clus", ".", "train", "(", "x", ",", "index", ")", "\n", "_", ",", "I", "=", "index", ".", "search", "(", "x", ",", "1", ")", "\n", "losses", "=", "faiss", ".", "vector_to_array", "(", "clus", ".", "obj", ")", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "'k-means loss evolution: {0}'", ".", "format", "(", "losses", ")", ")", "\n", "\n", "", "return", "[", "int", "(", "n", "[", "0", "]", ")", "for", "n", "in", "I", "]", ",", "losses", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.third_party.clustering.arrange_clustering": [[108, 116], ["enumerate", "numpy.argsort", "image_indexes.extend", "pseudolabels.extend", "numpy.asarray", "len"], "function", ["None"], ["", "def", "arrange_clustering", "(", "images_lists", ")", ":", "\n", "    ", "pseudolabels", "=", "[", "]", "\n", "image_indexes", "=", "[", "]", "\n", "for", "cluster", ",", "images", "in", "enumerate", "(", "images_lists", ")", ":", "\n", "        ", "image_indexes", ".", "extend", "(", "images", ")", "\n", "pseudolabels", ".", "extend", "(", "[", "cluster", "]", "*", "len", "(", "images", ")", ")", "\n", "", "indexes", "=", "np", ".", "argsort", "(", "image_indexes", ")", "\n", "return", "np", ".", "asarray", "(", "pseudolabels", ")", "[", "indexes", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.third_party.clustering.make_adjacencyW": [[143, 168], ["numpy.reshape", "numpy.multiply", "numpy.vectorize", "np.vectorize."], "function", ["None"], ["", "", "def", "make_adjacencyW", "(", "I", ",", "D", ",", "sigma", ")", ":", "\n", "    ", "\"\"\"Create adjacency matrix with a Gaussian kernel.\n    Args:\n        I (numpy array): for each vertex the ids to its nnn linked vertices\n                  + first column of identity.\n        D (numpy array): for each data the l2 distances to its nnn linked vertices\n                  + first column of zeros.\n        sigma (float): Bandwith of the Gaussian kernel.\n\n    Returns:\n        csr_matrix: affinity matrix of the graph.\n    \"\"\"", "\n", "V", ",", "k", "=", "I", ".", "shape", "\n", "k", "=", "k", "-", "1", "\n", "indices", "=", "np", ".", "reshape", "(", "np", ".", "delete", "(", "I", ",", "0", ",", "1", ")", ",", "(", "1", ",", "-", "1", ")", ")", "\n", "indptr", "=", "np", ".", "multiply", "(", "k", ",", "np", ".", "arange", "(", "V", "+", "1", ")", ")", "\n", "\n", "def", "exp_ker", "(", "d", ")", ":", "\n", "        ", "return", "np", ".", "exp", "(", "-", "d", "/", "sigma", "**", "2", ")", "\n", "\n", "", "exp_ker", "=", "np", ".", "vectorize", "(", "exp_ker", ")", "\n", "res_D", "=", "exp_ker", "(", "D", ")", "\n", "data", "=", "np", ".", "reshape", "(", "np", ".", "delete", "(", "res_D", ",", "0", ",", "1", ")", ",", "(", "1", ",", "-", "1", ")", ")", "\n", "adj_matrix", "=", "csr_matrix", "(", "(", "data", "[", "0", "]", ",", "indices", "[", "0", "]", ",", "indptr", ")", ",", "shape", "=", "(", "V", ",", "V", ")", ")", "\n", "return", "adj_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.third_party.clustering.run_pic": [[170, 201], ["clustering.make_adjacencyW", "time.time", "v0.astype", "time.time", "range", "make_adjacencyW.transpose", "numpy.ones", "numpy.zeros", "np.zeros.sum", "int", "W.transpose().dot", "clustering.find_maxima_cluster", "W.transpose"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.third_party.clustering.make_adjacencyW", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.third_party.clustering.find_maxima_cluster"], ["", "def", "run_pic", "(", "I", ",", "D", ",", "sigma", ",", "alpha", ")", ":", "\n", "    ", "\"\"\"Run PIC algorithm\"\"\"", "\n", "a", "=", "make_adjacencyW", "(", "I", ",", "D", ",", "sigma", ")", "\n", "graph", "=", "a", "+", "a", ".", "transpose", "(", ")", "\n", "cgraph", "=", "graph", "\n", "nim", "=", "graph", ".", "shape", "[", "0", "]", "\n", "\n", "W", "=", "graph", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "\n", "v0", "=", "np", ".", "ones", "(", "nim", ")", "/", "nim", "\n", "\n", "# power iterations", "\n", "v", "=", "v0", ".", "astype", "(", "'float32'", ")", "\n", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "dt", "=", "0", "\n", "for", "i", "in", "range", "(", "200", ")", ":", "\n", "        ", "vnext", "=", "np", ".", "zeros", "(", "nim", ",", "dtype", "=", "'float32'", ")", "\n", "\n", "vnext", "=", "vnext", "+", "W", ".", "transpose", "(", ")", ".", "dot", "(", "v", ")", "\n", "\n", "vnext", "=", "alpha", "*", "vnext", "+", "(", "1", "-", "alpha", ")", "/", "nim", "\n", "# L1 normalize", "\n", "vnext", "/=", "vnext", ".", "sum", "(", ")", "\n", "v", "=", "vnext", "\n", "\n", "if", "(", "i", "==", "200", "-", "1", ")", ":", "\n", "            ", "clust", "=", "find_maxima_cluster", "(", "W", ",", "v", ")", "\n", "\n", "", "", "return", "[", "int", "(", "i", ")", "for", "i", "in", "clust", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.third_party.clustering.find_maxima_cluster": [[203, 234], ["numpy.zeros", "list", "range", "range", "range", "range", "range", "numpy.ones"], "function", ["None"], ["", "def", "find_maxima_cluster", "(", "W", ",", "v", ")", ":", "\n", "    ", "n", ",", "m", "=", "W", ".", "shape", "\n", "assert", "(", "n", "==", "m", ")", "\n", "assign", "=", "np", ".", "zeros", "(", "n", ")", "\n", "# for each node", "\n", "pointers", "=", "list", "(", "range", "(", "n", ")", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "best_vi", "=", "0", "\n", "l0", "=", "W", ".", "indptr", "[", "i", "]", "\n", "l1", "=", "W", ".", "indptr", "[", "i", "+", "1", "]", "\n", "for", "l", "in", "range", "(", "l0", ",", "l1", ")", ":", "\n", "            ", "j", "=", "W", ".", "indices", "[", "l", "]", "\n", "vi", "=", "W", ".", "data", "[", "l", "]", "*", "(", "v", "[", "j", "]", "-", "v", "[", "i", "]", ")", "\n", "if", "vi", ">", "best_vi", ":", "\n", "                ", "best_vi", "=", "vi", "\n", "pointers", "[", "i", "]", "=", "j", "\n", "", "", "", "n_clus", "=", "0", "\n", "cluster_ids", "=", "-", "1", "*", "np", ".", "ones", "(", "n", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "if", "pointers", "[", "i", "]", "==", "i", ":", "\n", "            ", "cluster_ids", "[", "i", "]", "=", "n_clus", "\n", "n_clus", "=", "n_clus", "+", "1", "\n", "", "", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "# go from pointers to pointers starting from i until reached a local optim", "\n", "        ", "current_node", "=", "i", "\n", "while", "pointers", "[", "current_node", "]", "!=", "current_node", ":", "\n", "            ", "current_node", "=", "pointers", "[", "current_node", "]", "\n", "\n", "", "assign", "[", "i", "]", "=", "cluster_ids", "[", "current_node", "]", "\n", "assert", "(", "assign", "[", "i", "]", ">=", "0", ")", "\n", "", "return", "assign", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.places205.Places205.__init__": [[8, 11], ["image_list.ImageList.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "root", ",", "list_file", ",", "memcached", ",", "mclient_path", ",", "return_label", "=", "True", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Places205", ",", "self", ")", ".", "__init__", "(", "\n", "root", ",", "list_file", ",", "memcached", ",", "mclient_path", ",", "return_label", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.cifar.Cifar.__init__": [[13, 21], ["cifar.Cifar.set_cifar"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.cifar.Cifar100.set_cifar"], ["def", "__init__", "(", "self", ",", "root", ",", "split", ",", "return_label", "=", "True", ")", ":", "\n", "        ", "assert", "split", "in", "[", "'train'", ",", "'test'", "]", "\n", "self", ".", "root", "=", "root", "\n", "self", ".", "split", "=", "split", "\n", "self", ".", "return_label", "=", "return_label", "\n", "self", ".", "cifar", "=", "None", "\n", "self", ".", "set_cifar", "(", ")", "\n", "self", ".", "labels", "=", "self", ".", "cifar", ".", "targets", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.cifar.Cifar.set_cifar": [[22, 25], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "set_cifar", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.cifar.Cifar.get_length": [[26, 28], ["len"], "methods", ["None"], ["", "def", "get_length", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "cifar", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.cifar.Cifar.get_sample": [[29, 36], ["PIL.Image.fromarray"], "methods", ["None"], ["", "def", "get_sample", "(", "self", ",", "idx", ")", ":", "\n", "        ", "img", "=", "Image", ".", "fromarray", "(", "self", ".", "cifar", ".", "data", "[", "idx", "]", ")", "\n", "if", "self", ".", "return_label", ":", "\n", "            ", "target", "=", "self", ".", "labels", "[", "idx", "]", "# img: HWC, RGB", "\n", "return", "img", ",", "target", "\n", "", "else", ":", "\n", "            ", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.cifar.Cifar10.__init__": [[46, 48], ["cifar.Cifar.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "root", ",", "split", ",", "return_label", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "root", ",", "split", ",", "return_label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.cifar.Cifar10.set_cifar": [[49, 57], ["torchvision.datasets.CIFAR10", "Exception"], "methods", ["None"], ["", "def", "set_cifar", "(", "self", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "self", ".", "cifar", "=", "CIFAR10", "(", "\n", "root", "=", "self", ".", "root", ",", "train", "=", "self", ".", "split", "==", "'train'", ",", "download", "=", "False", ")", "\n", "", "except", ":", "\n", "            ", "raise", "Exception", "(", "\"Please download CIFAR10 manually, \\\n                  in case of downloading the dataset parallelly \\\n                  that may corrupt the dataset.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.cifar.Cifar100.__init__": [[62, 64], ["cifar.Cifar.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "root", ",", "split", ",", "return_label", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "root", ",", "split", ",", "return_label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.cifar.Cifar100.set_cifar": [[65, 73], ["torchvision.datasets.CIFAR100", "Exception"], "methods", ["None"], ["", "def", "set_cifar", "(", "self", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "self", ".", "cifar", "=", "CIFAR100", "(", "\n", "root", "=", "self", ".", "root", ",", "train", "=", "self", ".", "split", "==", "'train'", ",", "download", "=", "False", ")", "\n", "", "except", ":", "\n", "            ", "raise", "Exception", "(", "\"Please download CIFAR10 manually, \\\n                  in case of downloading the dataset parallelly \\\n                  that may corrupt the dataset.\"", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list.ImageList.__init__": [[11, 26], ["open", "f.readlines", "len", "zip", "os.path.join", "lines[].split", "int", "l.strip", "l.strip().split", "l.strip"], "methods", ["None"], ["\n", "\n", "def", "__init__", "(", "self", ",", "tensor", ":", "torch", ".", "Tensor", ",", "image_sizes", ":", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            tensor (Tensor): of shape (N, H, W) or (N, C_1, ..., C_K, H, W) where K >= 1\n            image_sizes (list[tuple[int, int]]): Each tuple is (h, w). It can\n                be smaller than (H, W) due to padding.\n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list.ImageList._init_memcached": [[27, 32], ["utils.McLoader"], "methods", ["None"], ["self", ".", "tensor", "=", "tensor", "\n", "self", ".", "image_sizes", "=", "image_sizes", "\n", "\n", "", "def", "__len__", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "len", "(", "self", ".", "image_sizes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list.ImageList.get_length": [[33, 35], ["len"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", "->", "torch", ".", "Tensor", ":", "\n", "        "]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list.ImageList.get_sample": [[36, 49], ["PIL.Image.open.convert", "image_list.ImageList._init_memcached", "image_list.ImageList.mc_loader", "PIL.Image.open"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list_multihead.ImageListMultihead._init_memcached"], ["\n", "size", "=", "self", ".", "image_sizes", "[", "idx", "]", "\n", "return", "self", ".", "tensor", "[", "idx", ",", "...", ",", ":", "size", "[", "0", "]", ",", ":", "size", "[", "1", "]", "]", "\n", "\n", "", "@", "torch", ".", "jit", ".", "unused", "\n", "def", "to", "(", "self", ",", "*", "args", ":", "Any", ",", "**", "kwargs", ":", "Any", ")", "->", "\"ImageList\"", ":", "\n", "        ", "cast_tensor", "=", "self", ".", "tensor", ".", "to", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "return", "ImageList", "(", "cast_tensor", ",", "self", ".", "image_sizes", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.imagenet.ImageNet.__init__": [[8, 11], ["image_list.ImageList.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "root", ",", "list_file", ",", "memcached", ",", "mclient_path", ",", "return_label", "=", "True", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "ImageNet", ",", "self", ")", ".", "__init__", "(", "\n", "root", ",", "list_file", ",", "memcached", ",", "mclient_path", ",", "return_label", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list_multihead.ImageListMultihead.__init__": [[12, 29], ["open", "f.readlines", "len", "zip", "os.path.join", "lines[].split", "l.strip", "torch.Tensor", "torch.Tensor", "l.strip().split", "int", "int", "l.strip", "l.split", "l.split"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "root", ",", "list_file", ",", "memcached", "=", "False", ",", "mclient_path", "=", "None", ",", "class_map", "=", "None", ")", ":", "\n", "        ", "with", "open", "(", "list_file", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "", "self", ".", "has_labels", "=", "len", "(", "lines", "[", "0", "]", ".", "split", "(", ")", ")", "==", "2", "\n", "if", "self", ".", "has_labels", ":", "\n", "            ", "self", ".", "fns", ",", "self", ".", "labels", "=", "zip", "(", "*", "[", "l", ".", "strip", "(", ")", ".", "split", "(", ")", "for", "l", "in", "lines", "]", ")", "\n", "if", "class_map", ":", "\n", "                ", "self", ".", "labels", "=", "[", "torch", ".", "Tensor", "(", "[", "int", "(", "class_map", "[", "i", "]", ")", "for", "i", "in", "l", ".", "split", "(", "','", ")", "]", ")", "for", "l", "in", "self", ".", "labels", "]", "\n", "", "else", ":", "\n", "                ", "self", ".", "labels", "=", "[", "torch", ".", "Tensor", "(", "[", "int", "(", "i", ")", "for", "i", "in", "l", ".", "split", "(", "','", ")", "]", ")", "for", "l", "in", "self", ".", "labels", "]", "\n", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "fns", "=", "[", "l", ".", "strip", "(", ")", "for", "l", "in", "lines", "]", "\n", "", "self", ".", "fns", "=", "[", "os", ".", "path", ".", "join", "(", "root", ",", "fn", ")", "for", "fn", "in", "self", ".", "fns", "]", "\n", "self", ".", "memcached", "=", "memcached", "\n", "self", ".", "mclient_path", "=", "mclient_path", "\n", "self", ".", "initialized", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list_multihead.ImageListMultihead._init_memcached": [[30, 35], ["utils.McLoader"], "methods", ["None"], ["", "def", "_init_memcached", "(", "self", ")", ":", "\n", "        ", "if", "not", "self", ".", "initialized", ":", "\n", "            ", "assert", "self", ".", "mclient_path", "is", "not", "None", "\n", "self", ".", "mc_loader", "=", "McLoader", "(", "self", ".", "mclient_path", ")", "\n", "self", ".", "initialized", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list_multihead.ImageListMultihead.get_length": [[36, 38], ["len"], "methods", ["None"], ["", "", "def", "get_length", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "fns", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list_multihead.ImageListMultihead.get_sample": [[39, 52], ["PIL.Image.open.convert", "image_list_multihead.ImageListMultihead._init_memcached", "image_list_multihead.ImageListMultihead.mc_loader", "PIL.Image.open"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.image_list_multihead.ImageListMultihead._init_memcached"], ["", "def", "get_sample", "(", "self", ",", "idx", ")", ":", "\n", "        ", "if", "self", ".", "memcached", ":", "\n", "            ", "self", ".", "_init_memcached", "(", ")", "\n", "", "if", "self", ".", "memcached", ":", "\n", "            ", "img", "=", "self", ".", "mc_loader", "(", "self", ".", "fns", "[", "idx", "]", ")", "\n", "", "else", ":", "\n", "            ", "img", "=", "Image", ".", "open", "(", "self", ".", "fns", "[", "idx", "]", ")", "\n", "", "img", "=", "img", ".", "convert", "(", "'RGB'", ")", "\n", "if", "self", ".", "has_labels", ":", "\n", "            ", "target", "=", "self", ".", "labels", "[", "idx", "]", "\n", "return", "img", ",", "target", "\n", "", "else", ":", "\n", "            ", "return", "img", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.utils.McLoader.__init__": [[16, 25], ["mc.MemcachedClient.GetInstance"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.utils.McLoader.__call__": [[26, 37], ["mc.pyvector", "utils.McLoader.mclient.Get", "mc.ConvertBuffer", "utils.pil_loader", "print"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.utils.pil_loader"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.data_sources.utils.pil_loader": [[9, 12], ["io.BytesIO", "PIL.Image.open"], "function", ["None"], ["            ", "nn", ".", "init", ".", "constant_", "(", "param", ",", "0", ")", "\n", "", "elif", "\"weight\"", "in", "name", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_normal_", "(", "param", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.pipelines.transforms.RandomAppliedTrans.__init__": [[30, 33], ["torchvision.transforms.RandomApply", "transforms.RandomAppliedTrans.utils.build_from_cfg"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.registry.build_from_cfg"], ["def", "__init__", "(", "self", ",", "transforms", ",", "p", "=", "0.5", ")", ":", "\n", "        ", "t", "=", "[", "build_from_cfg", "(", "t", ",", "PIPELINES", ")", "for", "t", "in", "transforms", "]", "\n", "self", ".", "trans", "=", "_transforms", ".", "RandomApply", "(", "t", ",", "p", "=", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.pipelines.transforms.RandomAppliedTrans.__call__": [[34, 36], ["torchvision.transforms.RandomAppliedTrans.trans"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img", ")", ":", "\n", "        ", "return", "self", ".", "trans", "(", "img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.pipelines.transforms.RandomAppliedTrans.__repr__": [[37, 40], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.pipelines.transforms.Lighting.__init__": [[58, 62], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "alphastd", "=", "0.1", "\n", "self", ".", "eigval", "=", "self", ".", "_IMAGENET_PCA", "[", "'eigval'", "]", "\n", "self", ".", "eigvec", "=", "self", ".", "_IMAGENET_PCA", "[", "'eigvec'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.pipelines.transforms.Lighting.__call__": [[63, 76], ["isinstance", "img.new().resize_().normal_", "torchvision.transforms.Lighting.eigvec.type_as().clone().mul().mul().sum().squeeze", "img.add", "type", "torchvision.transforms.Lighting.view().expand_as", "img.new().resize_", "torchvision.transforms.Lighting.eigvec.type_as().clone().mul().mul().sum", "torchvision.transforms.Lighting.view", "img.new", "torchvision.transforms.Lighting.eigvec.type_as().clone().mul().mul", "torchvision.transforms.Lighting.eigval.view().expand", "torchvision.transforms.Lighting.eigvec.type_as().clone().mul", "img.new().resize_().normal_.view().expand", "torchvision.transforms.Lighting.eigval.view", "torchvision.transforms.Lighting.eigvec.type_as().clone", "img.new().resize_().normal_.view", "torchvision.transforms.Lighting.eigvec.type_as"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone"], ["", "def", "__call__", "(", "self", ",", "img", ")", ":", "\n", "        ", "assert", "isinstance", "(", "img", ",", "torch", ".", "Tensor", ")", ",", "\"Expect torch.Tensor, got {}\"", ".", "format", "(", "type", "(", "img", ")", ")", "\n", "if", "self", ".", "alphastd", "==", "0", ":", "\n", "            ", "return", "img", "\n", "\n", "", "alpha", "=", "img", ".", "new", "(", ")", ".", "resize_", "(", "3", ")", ".", "normal_", "(", "0", ",", "self", ".", "alphastd", ")", "\n", "rgb", "=", "self", ".", "eigvec", ".", "type_as", "(", "img", ")", ".", "clone", "(", ")", ".", "mul", "(", "alpha", ".", "view", "(", "1", ",", "3", ")", ".", "expand", "(", "3", ",", "3", ")", ")", ".", "mul", "(", "self", ".", "eigval", ".", "view", "(", "1", ",", "3", ")", ".", "expand", "(", "3", ",", "3", ")", ")", ".", "sum", "(", "1", ")", ".", "squeeze", "(", ")", "\n", "\n", "return", "img", ".", "add", "(", "rgb", ".", "view", "(", "3", ",", "1", ",", "1", ")", ".", "expand_as", "(", "img", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.pipelines.transforms.Lighting.__repr__": [[77, 80], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.pipelines.transforms.GaussianBlur.__init__": [[86, 89], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "sigma_min", ",", "sigma_max", ")", ":", "\n", "        ", "self", ".", "sigma_min", "=", "sigma_min", "\n", "self", ".", "sigma_max", "=", "sigma_max", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.pipelines.transforms.GaussianBlur.__call__": [[90, 94], ["numpy.random.uniform", "img.filter.filter.filter", "PIL.ImageFilter.GaussianBlur"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img", ")", ":", "\n", "        ", "sigma", "=", "np", ".", "random", ".", "uniform", "(", "self", ".", "sigma_min", ",", "self", ".", "sigma_max", ")", "\n", "img", "=", "img", ".", "filter", "(", "ImageFilter", ".", "GaussianBlur", "(", "radius", "=", "sigma", ")", ")", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.pipelines.transforms.GaussianBlur.__repr__": [[95, 98], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.pipelines.transforms.Solarization.__init__": [[104, 106], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "threshold", "=", "128", ")", ":", "\n", "        ", "self", ".", "threshold", "=", "threshold", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.pipelines.transforms.Solarization.__call__": [[107, 111], ["numpy.array", "numpy.where", "PIL.Image.fromarray", "numpy.where.astype"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img", ")", ":", "\n", "        ", "img", "=", "np", ".", "array", "(", "img", ")", "\n", "img", "=", "np", ".", "where", "(", "img", "<", "self", ".", "threshold", ",", "img", ",", "255", "-", "img", ")", "\n", "return", "Image", ".", "fromarray", "(", "img", ".", "astype", "(", "np", ".", "uint8", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.pipelines.transforms.Solarization.__repr__": [[112, 115], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "return", "repr_str", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.sampler.DistributedSampler.__init__": [[13, 23], ["torch.utils.data.DistributedSampler.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "dataset", ",", "\n", "num_replicas", "=", "None", ",", "\n", "rank", "=", "None", ",", "\n", "shuffle", "=", "True", ",", "\n", "replace", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "dataset", ",", "num_replicas", "=", "num_replicas", ",", "rank", "=", "rank", ")", "\n", "self", ".", "shuffle", "=", "shuffle", "\n", "self", ".", "replace", "=", "replace", "\n", "self", ".", "unif_sampling_flag", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.sampler.DistributedSampler.__iter__": [[24, 32], ["iter", "sampler.DistributedSampler.generate_new_list"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.iter", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.sampler.DistributedSampler.generate_new_list"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "# deterministically shuffle based on epoch", "\n", "        ", "if", "not", "self", ".", "unif_sampling_flag", ":", "\n", "            ", "self", ".", "generate_new_list", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "unif_sampling_flag", "=", "False", "\n", "", "return", "iter", "(", "self", ".", "indices", "[", "self", ".", "rank", "*", "self", ".", "num_samples", ":", "(", "self", ".", "rank", "+", "1", ")", "*", "\n", "self", ".", "num_samples", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.sampler.DistributedSampler.generate_new_list": [[33, 53], ["torch.Generator", "torch.Generator.manual_seed", "torch.arange().tolist", "len", "torch.randint().tolist", "torch.randperm().tolist", "torch.arange", "len", "torch.randint", "torch.randperm", "len", "len", "len", "len"], "methods", ["None"], ["", "def", "generate_new_list", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "shuffle", ":", "\n", "            ", "g", "=", "torch", ".", "Generator", "(", ")", "\n", "g", ".", "manual_seed", "(", "self", ".", "epoch", ")", "\n", "if", "self", ".", "replace", ":", "\n", "                ", "indices", "=", "torch", ".", "randint", "(", "\n", "low", "=", "0", ",", "\n", "high", "=", "len", "(", "self", ".", "dataset", ")", ",", "\n", "size", "=", "(", "len", "(", "self", ".", "dataset", ")", ",", ")", ",", "\n", "generator", "=", "g", ")", ".", "tolist", "(", ")", "\n", "", "else", ":", "\n", "                ", "indices", "=", "torch", ".", "randperm", "(", "\n", "len", "(", "self", ".", "dataset", ")", ",", "generator", "=", "g", ")", ".", "tolist", "(", ")", "\n", "", "", "else", ":", "\n", "            ", "indices", "=", "torch", ".", "arange", "(", "len", "(", "self", ".", "dataset", ")", ")", ".", "tolist", "(", ")", "\n", "\n", "# add extra samples to make it evenly divisible", "\n", "", "indices", "+=", "indices", "[", ":", "(", "self", ".", "total_size", "-", "len", "(", "indices", ")", ")", "]", "\n", "assert", "len", "(", "indices", ")", "==", "self", ".", "total_size", "\n", "self", ".", "indices", "=", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.sampler.DistributedSampler.set_uniform_indices": [[54, 82], ["numpy.random.seed", "len", "enumerate", "enumerate", "numpy.array", "numpy.random.shuffle", "indices[].astype().tolist", "len", "len", "int", "images_lists[].append", "indices[].astype().tolist.extend", "len", "len", "len", "len", "range", "len", "numpy.random.choice", "indices[].astype", "len", "len"], "methods", ["None"], ["", "def", "set_uniform_indices", "(", "self", ",", "labels", ",", "num_classes", ")", ":", "\n", "        ", "self", ".", "unif_sampling_flag", "=", "True", "\n", "assert", "self", ".", "shuffle", ",", "\"Using uniform sampling, the indices must be shuffled.\"", "\n", "np", ".", "random", ".", "seed", "(", "self", ".", "epoch", ")", "\n", "assert", "(", "len", "(", "labels", ")", "==", "len", "(", "self", ".", "dataset", ")", ")", "\n", "N", "=", "len", "(", "labels", ")", "\n", "size_per_label", "=", "int", "(", "N", "/", "num_classes", ")", "+", "1", "\n", "indices", "=", "[", "]", "\n", "images_lists", "=", "[", "[", "]", "for", "i", "in", "range", "(", "num_classes", ")", "]", "\n", "for", "i", ",", "l", "in", "enumerate", "(", "labels", ")", ":", "\n", "            ", "images_lists", "[", "l", "]", ".", "append", "(", "i", ")", "\n", "", "for", "i", ",", "l", "in", "enumerate", "(", "images_lists", ")", ":", "\n", "            ", "if", "len", "(", "l", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "", "indices", ".", "extend", "(", "\n", "np", ".", "random", ".", "choice", "(", "\n", "l", ",", "size_per_label", ",", "replace", "=", "(", "len", "(", "l", ")", "<=", "size_per_label", ")", ")", ")", "\n", "", "indices", "=", "np", ".", "array", "(", "indices", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "indices", ")", "\n", "indices", "=", "indices", "[", ":", "N", "]", ".", "astype", "(", "np", ".", "int", ")", ".", "tolist", "(", ")", "\n", "\n", "# add extra samples to make it evenly divisible", "\n", "assert", "len", "(", "indices", ")", "<=", "self", ".", "total_size", ",", "\"{} vs {}\"", ".", "format", "(", "len", "(", "indices", ")", ",", "self", ".", "total_size", ")", "\n", "indices", "+=", "indices", "[", ":", "(", "self", ".", "total_size", "-", "len", "(", "indices", ")", ")", "]", "\n", "assert", "len", "(", "indices", ")", "==", "self", ".", "total_size", ",", "\"{} vs {}\"", ".", "format", "(", "len", "(", "indices", ")", ",", "self", ".", "total_size", ")", "\n", "self", ".", "indices", "=", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.sampler.GroupSampler.__init__": [[86, 96], ["hasattr", "dataset.flag.astype", "numpy.bincount", "enumerate", "int", "numpy.ceil"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "dataset", ",", "samples_per_gpu", "=", "1", ")", ":", "\n", "        ", "assert", "hasattr", "(", "dataset", ",", "'flag'", ")", "\n", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "samples_per_gpu", "=", "samples_per_gpu", "\n", "self", ".", "flag", "=", "dataset", ".", "flag", ".", "astype", "(", "np", ".", "int64", ")", "\n", "self", ".", "group_sizes", "=", "np", ".", "bincount", "(", "self", ".", "flag", ")", "\n", "self", ".", "num_samples", "=", "0", "\n", "for", "i", ",", "size", "in", "enumerate", "(", "self", ".", "group_sizes", ")", ":", "\n", "            ", "self", ".", "num_samples", "+=", "int", "(", "np", ".", "ceil", "(", "\n", "size", "/", "self", ".", "samples_per_gpu", ")", ")", "*", "self", ".", "samples_per_gpu", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.sampler.GroupSampler.__iter__": [[97, 120], ["enumerate", "numpy.concatenate", "numpy.concatenate", "indices.astype().tolist.astype().tolist.astype().tolist", "iter", "numpy.random.shuffle", "numpy.concatenate", "indices.astype().tolist.astype().tolist.append", "len", "numpy.where", "len", "len", "numpy.random.permutation", "indices.astype().tolist.astype().tolist.astype", "int", "numpy.random.choice", "range", "numpy.ceil", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.iter"], ["", "", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "indices", "=", "[", "]", "\n", "for", "i", ",", "size", "in", "enumerate", "(", "self", ".", "group_sizes", ")", ":", "\n", "            ", "if", "size", "==", "0", ":", "\n", "                ", "continue", "\n", "", "indice", "=", "np", ".", "where", "(", "self", ".", "flag", "==", "i", ")", "[", "0", "]", "\n", "assert", "len", "(", "indice", ")", "==", "size", "\n", "np", ".", "random", ".", "shuffle", "(", "indice", ")", "\n", "num_extra", "=", "int", "(", "np", ".", "ceil", "(", "size", "/", "self", ".", "samples_per_gpu", ")", "\n", ")", "*", "self", ".", "samples_per_gpu", "-", "len", "(", "indice", ")", "\n", "indice", "=", "np", ".", "concatenate", "(", "\n", "[", "indice", ",", "np", ".", "random", ".", "choice", "(", "indice", ",", "num_extra", ")", "]", ")", "\n", "indices", ".", "append", "(", "indice", ")", "\n", "", "indices", "=", "np", ".", "concatenate", "(", "indices", ")", "\n", "indices", "=", "[", "\n", "indices", "[", "i", "*", "self", ".", "samples_per_gpu", ":", "(", "i", "+", "1", ")", "*", "self", ".", "samples_per_gpu", "]", "\n", "for", "i", "in", "np", ".", "random", ".", "permutation", "(", "\n", "range", "(", "len", "(", "indices", ")", "//", "self", ".", "samples_per_gpu", ")", ")", "\n", "]", "\n", "indices", "=", "np", ".", "concatenate", "(", "indices", ")", "\n", "indices", "=", "indices", ".", "astype", "(", "np", ".", "int64", ")", ".", "tolist", "(", ")", "\n", "assert", "len", "(", "indices", ")", "==", "self", ".", "num_samples", "\n", "return", "iter", "(", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.sampler.GroupSampler.__len__": [[121, 123], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "num_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.sampler.DistributedGroupSampler.__init__": [[143, 169], ["mmcv.runner.get_dist_info", "hasattr", "numpy.bincount", "enumerate", "int", "math.ceil"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "dataset", ",", "\n", "samples_per_gpu", "=", "1", ",", "\n", "num_replicas", "=", "None", ",", "\n", "rank", "=", "None", ")", ":", "\n", "        ", "_rank", ",", "_num_replicas", "=", "get_dist_info", "(", ")", "\n", "if", "num_replicas", "is", "None", ":", "\n", "            ", "num_replicas", "=", "_num_replicas", "\n", "", "if", "rank", "is", "None", ":", "\n", "            ", "rank", "=", "_rank", "\n", "", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "samples_per_gpu", "=", "samples_per_gpu", "\n", "self", ".", "num_replicas", "=", "num_replicas", "\n", "self", ".", "rank", "=", "rank", "\n", "self", ".", "epoch", "=", "0", "\n", "\n", "assert", "hasattr", "(", "self", ".", "dataset", ",", "'flag'", ")", "\n", "self", ".", "flag", "=", "self", ".", "dataset", ".", "flag", "\n", "self", ".", "group_sizes", "=", "np", ".", "bincount", "(", "self", ".", "flag", ")", "\n", "\n", "self", ".", "num_samples", "=", "0", "\n", "for", "i", ",", "j", "in", "enumerate", "(", "self", ".", "group_sizes", ")", ":", "\n", "            ", "self", ".", "num_samples", "+=", "int", "(", "\n", "math", ".", "ceil", "(", "self", ".", "group_sizes", "[", "i", "]", "*", "1.0", "/", "self", ".", "samples_per_gpu", "/", "\n", "self", ".", "num_replicas", ")", ")", "*", "self", ".", "samples_per_gpu", "\n", "", "self", ".", "total_size", "=", "self", ".", "num_samples", "*", "self", ".", "num_replicas", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.sampler.DistributedGroupSampler.__iter__": [[170, 209], ["torch.Generator", "torch.Generator.manual_seed", "enumerate", "iter", "len", "len", "indice[].tolist", "indice[].tolist.copy", "range", "indice[].tolist.extend", "indices.extend", "list", "range", "numpy.where", "len", "len", "indice[].tolist.extend", "torch.randperm", "int", "len", "list", "math.ceil", "torch.randperm", "int"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.iter"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "# deterministically shuffle based on epoch", "\n", "        ", "g", "=", "torch", ".", "Generator", "(", ")", "\n", "g", ".", "manual_seed", "(", "self", ".", "epoch", ")", "\n", "\n", "indices", "=", "[", "]", "\n", "for", "i", ",", "size", "in", "enumerate", "(", "self", ".", "group_sizes", ")", ":", "\n", "            ", "if", "size", ">", "0", ":", "\n", "                ", "indice", "=", "np", ".", "where", "(", "self", ".", "flag", "==", "i", ")", "[", "0", "]", "\n", "assert", "len", "(", "indice", ")", "==", "size", "\n", "indice", "=", "indice", "[", "list", "(", "torch", ".", "randperm", "(", "int", "(", "size", ")", ",", "\n", "generator", "=", "g", ")", ")", "]", ".", "tolist", "(", ")", "\n", "extra", "=", "int", "(", "\n", "math", ".", "ceil", "(", "\n", "size", "*", "1.0", "/", "self", ".", "samples_per_gpu", "/", "self", ".", "num_replicas", ")", "\n", ")", "*", "self", ".", "samples_per_gpu", "*", "self", ".", "num_replicas", "-", "len", "(", "indice", ")", "\n", "# pad indice", "\n", "tmp", "=", "indice", ".", "copy", "(", ")", "\n", "for", "_", "in", "range", "(", "extra", "//", "size", ")", ":", "\n", "                    ", "indice", ".", "extend", "(", "tmp", ")", "\n", "", "indice", ".", "extend", "(", "tmp", "[", ":", "extra", "%", "size", "]", ")", "\n", "indices", ".", "extend", "(", "indice", ")", "\n", "\n", "", "", "assert", "len", "(", "indices", ")", "==", "self", ".", "total_size", "\n", "\n", "indices", "=", "[", "\n", "indices", "[", "j", "]", "for", "i", "in", "list", "(", "\n", "torch", ".", "randperm", "(", "\n", "len", "(", "indices", ")", "//", "self", ".", "samples_per_gpu", ",", "generator", "=", "g", ")", ")", "\n", "for", "j", "in", "range", "(", "i", "*", "self", ".", "samples_per_gpu", ",", "(", "i", "+", "1", ")", "*", "\n", "self", ".", "samples_per_gpu", ")", "\n", "]", "\n", "\n", "# subsample", "\n", "offset", "=", "self", ".", "num_samples", "*", "self", ".", "rank", "\n", "indices", "=", "indices", "[", "offset", ":", "offset", "+", "self", ".", "num_samples", "]", "\n", "assert", "len", "(", "indices", ")", "==", "self", ".", "num_samples", "\n", "\n", "return", "iter", "(", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.sampler.DistributedGroupSampler.__len__": [[210, 212], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "num_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.sampler.DistributedGroupSampler.set_epoch": [[213, 215], ["None"], "methods", ["None"], ["", "def", "set_epoch", "(", "self", ",", "epoch", ")", ":", "\n", "        ", "self", ".", "epoch", "=", "epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.sampler.DistributedGivenIterationSampler.__init__": [[219, 238], ["mmcv.runner.get_dist_info", "sampler.DistributedGivenIterationSampler.gen_new_list"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.sampler.DistributedGivenIterationSampler.gen_new_list"], ["    ", "def", "__init__", "(", "self", ",", "\n", "dataset", ",", "\n", "total_iter", ",", "\n", "batch_size", ",", "\n", "num_replicas", "=", "None", ",", "\n", "rank", "=", "None", ",", "\n", "last_iter", "=", "-", "1", ")", ":", "\n", "        ", "rank", ",", "world_size", "=", "get_dist_info", "(", ")", "\n", "assert", "rank", "<", "world_size", "\n", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "total_iter", "=", "total_iter", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "world_size", "=", "world_size", "\n", "self", ".", "rank", "=", "rank", "\n", "self", ".", "last_iter", "=", "last_iter", "\n", "\n", "self", ".", "total_size", "=", "self", ".", "total_iter", "*", "self", ".", "batch_size", "\n", "\n", "self", ".", "indices", "=", "self", ".", "gen_new_list", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.sampler.DistributedGivenIterationSampler.__iter__": [[239, 241], ["iter"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.events.EventStorage.iter"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "iter", "(", "self", ".", "indices", "[", "(", "self", ".", "last_iter", "+", "1", ")", "*", "self", ".", "batch_size", ":", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.sampler.DistributedGivenIterationSampler.set_uniform_indices": [[242, 273], ["numpy.random.seed", "len", "enumerate", "enumerate", "numpy.array", "numpy.random.shuffle", "indices[].astype", "numpy.tile", "numpy.random.shuffle", "len", "len", "int", "images_lists[].append", "numpy.tile.extend", "len", "range", "len", "numpy.random.choice", "len"], "methods", ["None"], ["", "def", "set_uniform_indices", "(", "self", ",", "labels", ",", "num_classes", ")", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "assert", "(", "len", "(", "labels", ")", "==", "len", "(", "self", ".", "dataset", ")", ")", "\n", "N", "=", "len", "(", "labels", ")", "\n", "size_per_label", "=", "int", "(", "N", "/", "num_classes", ")", "+", "1", "\n", "indices", "=", "[", "]", "\n", "images_lists", "=", "[", "[", "]", "for", "i", "in", "range", "(", "num_classes", ")", "]", "\n", "for", "i", ",", "l", "in", "enumerate", "(", "labels", ")", ":", "\n", "            ", "images_lists", "[", "l", "]", ".", "append", "(", "i", ")", "\n", "", "for", "i", ",", "l", "in", "enumerate", "(", "images_lists", ")", ":", "\n", "            ", "if", "len", "(", "l", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "", "indices", ".", "extend", "(", "\n", "np", ".", "random", ".", "choice", "(", "\n", "l", ",", "size_per_label", ",", "replace", "=", "(", "len", "(", "l", ")", "<=", "size_per_label", ")", ")", ")", "\n", "", "indices", "=", "np", ".", "array", "(", "indices", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "indices", ")", "\n", "indices", "=", "indices", "[", ":", "N", "]", ".", "astype", "(", "np", ".", "int", ")", "\n", "# repeat", "\n", "all_size", "=", "self", ".", "total_size", "*", "self", ".", "world_size", "\n", "indices", "=", "indices", "[", ":", "all_size", "]", "\n", "num_repeat", "=", "(", "all_size", "-", "1", ")", "//", "indices", ".", "shape", "[", "0", "]", "+", "1", "\n", "indices", "=", "np", ".", "tile", "(", "indices", ",", "num_repeat", ")", "\n", "indices", "=", "indices", "[", ":", "all_size", "]", "\n", "np", ".", "random", ".", "shuffle", "(", "indices", ")", "\n", "# slice", "\n", "beg", "=", "self", ".", "total_size", "*", "self", ".", "rank", "\n", "indices", "=", "indices", "[", "beg", ":", "beg", "+", "self", ".", "total_size", "]", "\n", "assert", "len", "(", "indices", ")", "==", "self", ".", "total_size", "\n", "# set", "\n", "self", ".", "indices", "=", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.sampler.DistributedGivenIterationSampler.gen_new_list": [[274, 293], ["numpy.random.seed", "numpy.arange", "numpy.tile", "numpy.random.shuffle", "len", "len"], "methods", ["None"], ["", "def", "gen_new_list", "(", "self", ")", ":", "\n", "\n", "# each process shuffle all list with same seed, and pick one piece according to rank", "\n", "        ", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "\n", "all_size", "=", "self", ".", "total_size", "*", "self", ".", "world_size", "\n", "indices", "=", "np", ".", "arange", "(", "len", "(", "self", ".", "dataset", ")", ")", "\n", "indices", "=", "indices", "[", ":", "all_size", "]", "\n", "num_repeat", "=", "(", "all_size", "-", "1", ")", "//", "indices", ".", "shape", "[", "0", "]", "+", "1", "\n", "indices", "=", "np", ".", "tile", "(", "indices", ",", "num_repeat", ")", "\n", "indices", "=", "indices", "[", ":", "all_size", "]", "\n", "\n", "np", ".", "random", ".", "shuffle", "(", "indices", ")", "\n", "beg", "=", "self", ".", "total_size", "*", "self", ".", "rank", "\n", "indices", "=", "indices", "[", "beg", ":", "beg", "+", "self", ".", "total_size", "]", "\n", "\n", "assert", "len", "(", "indices", ")", "==", "self", ".", "total_size", "\n", "\n", "return", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.sampler.DistributedGivenIterationSampler.__len__": [[294, 300], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "# note here we do not take last iter into consideration, since __len__", "\n", "# should only be used for displaying, the correct remaining size is", "\n", "# handled by dataloader", "\n", "#return self.total_size - (self.last_iter+1)*self.batch_size", "\n", "        ", "return", "self", ".", "total_size", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.sampler.DistributedGivenIterationSampler.set_epoch": [[301, 303], ["None"], "methods", ["None"], ["", "def", "set_epoch", "(", "self", ",", "epoch", ")", ":", "\n", "        ", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.build_loader.PrefetchLoader.__init__": [[98, 102], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "loader", ",", "mean", ",", "std", ")", ":", "\n", "        ", "self", ".", "loader", "=", "loader", "\n", "self", ".", "_mean", "=", "mean", "\n", "self", ".", "_std", "=", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.build_loader.PrefetchLoader.__iter__": [[103, 123], ["torch.cuda.Stream", "torch.tensor().cuda().view", "torch.tensor().cuda().view", "torch.cuda.current_stream().wait_stream", "torch.tensor().cuda", "torch.tensor().cuda", "torch.cuda.stream", "next_input_dict[].cuda", "next_input_dict[].cuda.float().sub_().div_", "torch.cuda.current_stream", "torch.tensor", "torch.tensor", "next_input_dict[].cuda.float().sub_", "next_input_dict[].cuda.float"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "stream", "=", "torch", ".", "cuda", ".", "Stream", "(", ")", "\n", "first", "=", "True", "\n", "self", ".", "mean", "=", "torch", ".", "tensor", "(", "[", "x", "*", "255", "for", "x", "in", "self", ".", "_mean", "]", ")", ".", "cuda", "(", ")", ".", "view", "(", "1", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "std", "=", "torch", ".", "tensor", "(", "[", "x", "*", "255", "for", "x", "in", "self", ".", "_std", "]", ")", ".", "cuda", "(", ")", ".", "view", "(", "1", ",", "3", ",", "1", ",", "1", ")", "\n", "\n", "for", "next_input_dict", "in", "self", ".", "loader", ":", "\n", "            ", "with", "torch", ".", "cuda", ".", "stream", "(", "stream", ")", ":", "\n", "                ", "data", "=", "next_input_dict", "[", "'img'", "]", ".", "cuda", "(", "non_blocking", "=", "True", ")", "\n", "next_input_dict", "[", "'img'", "]", "=", "data", ".", "float", "(", ")", ".", "sub_", "(", "self", ".", "mean", ")", ".", "div_", "(", "self", ".", "std", ")", "\n", "\n", "", "if", "not", "first", ":", "\n", "                ", "yield", "input", "\n", "", "else", ":", "\n", "                ", "first", "=", "False", "\n", "\n", "", "torch", ".", "cuda", ".", "current_stream", "(", ")", ".", "wait_stream", "(", "stream", ")", "\n", "input", "=", "next_input_dict", "\n", "\n", "", "yield", "input", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.build_loader.PrefetchLoader.__len__": [[124, 126], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "loader", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.build_loader.PrefetchLoader.sampler": [[127, 130], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "sampler", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "loader", ".", "sampler", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.build_loader.PrefetchLoader.dataset": [[131, 134], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "dataset", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "loader", ".", "dataset", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.build_loader.build_dataloader": [[22, 87], ["torch.utils.data.DataLoader", "mmcv.runner.get_dist_info", "sampler.DistributedSampler", "kwargs.get", "kwargs.pop", "kwargs.pop", "build_loader.PrefetchLoader", "torch.utils.data.RandomSampler", "functools.partial"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["", "def", "build_dataloader", "(", "dataset", ",", "\n", "imgs_per_gpu", ",", "\n", "workers_per_gpu", ",", "\n", "num_gpus", "=", "1", ",", "\n", "dist", "=", "True", ",", "\n", "shuffle", "=", "True", ",", "\n", "replace", "=", "False", ",", "\n", "seed", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Build PyTorch DataLoader.\n\n    In distributed training, each GPU/process has a dataloader.\n    In non-distributed training, there is only one dataloader for all GPUs.\n\n    Args:\n        dataset (Dataset): A PyTorch dataset.\n        imgs_per_gpu (int): Number of images on each GPU, i.e., batch size of\n            each GPU.\n        workers_per_gpu (int): How many subprocesses to use for data loading\n            for each GPU.\n        num_gpus (int): Number of GPUs. Only used in non-distributed training.\n        dist (bool): Distributed training/test or not. Default: True.\n        shuffle (bool): Whether to shuffle the data at every epoch.\n            Default: True.\n        replace (bool): Replace or not in random shuffle.\n            It works on when shuffle is True.\n        kwargs: any keyword argument to be used to initialize DataLoader\n\n    Returns:\n        DataLoader: A PyTorch dataloader.\n    \"\"\"", "\n", "if", "dist", ":", "\n", "        ", "rank", ",", "world_size", "=", "get_dist_info", "(", ")", "\n", "sampler", "=", "DistributedSampler", "(", "\n", "dataset", ",", "world_size", ",", "rank", ",", "shuffle", "=", "shuffle", ",", "replace", "=", "replace", ")", "\n", "batch_size", "=", "imgs_per_gpu", "\n", "num_workers", "=", "workers_per_gpu", "\n", "", "else", ":", "\n", "        ", "if", "replace", ":", "\n", "            ", "raise", "NotImplemented", "\n", "", "sampler", "=", "RandomSampler", "(", "\n", "dataset", ")", "if", "shuffle", "else", "None", "# TODO: set replace", "\n", "batch_size", "=", "num_gpus", "*", "imgs_per_gpu", "\n", "num_workers", "=", "num_gpus", "*", "workers_per_gpu", "\n", "\n", "", "if", "kwargs", ".", "get", "(", "'prefetch'", ")", "is", "not", "None", ":", "\n", "        ", "prefetch", "=", "kwargs", ".", "pop", "(", "'prefetch'", ")", "\n", "img_norm_cfg", "=", "kwargs", ".", "pop", "(", "'img_norm_cfg'", ")", "\n", "", "else", ":", "\n", "        ", "prefetch", "=", "False", "\n", "\n", "", "data_loader", "=", "DataLoader", "(", "\n", "dataset", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "sampler", "=", "sampler", ",", "\n", "num_workers", "=", "num_workers", ",", "\n", "collate_fn", "=", "partial", "(", "collate", ",", "samples_per_gpu", "=", "imgs_per_gpu", ")", ",", "\n", "pin_memory", "=", "True", ",", "\n", "worker_init_fn", "=", "worker_init_fn", "if", "seed", "is", "not", "None", "else", "None", ",", "\n", "**", "kwargs", ")", "\n", "\n", "if", "prefetch", ":", "\n", "        ", "data_loader", "=", "PrefetchLoader", "(", "data_loader", ",", "img_norm_cfg", "[", "'mean'", "]", ",", "img_norm_cfg", "[", "'std'", "]", ")", "\n", "\n", "", "return", "data_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.build_loader.worker_init_fn": [[89, 92], ["numpy.random.seed", "random.seed"], "function", ["None"], ["", "def", "worker_init_fn", "(", "seed", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "random", ".", "seed", "(", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.apis.train.set_random_seed": [[20, 37], ["random.seed", "numpy.random.seed", "torch.manual_seed", "torch.manual_seed", "torch.cuda.manual_seed_all", "torch.cuda.manual_seed_all"], "function", ["None"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Train a model'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'train config file path'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--work_dir'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "'the dir to save logs and models'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--resume_from'", ",", "help", "=", "'the checkpoint file to resume from'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--pretrained'", ",", "default", "=", "None", ",", "help", "=", "'pretrained model file'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--gpus'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "1", ",", "\n", "help", "=", "'number of gpus to use '", "\n", "'(only applicable to non-distributed training)'", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.apis.train.parse_losses": [[39, 61], ["collections.OrderedDict", "losses.items", "sum", "collections.OrderedDict.items", "isinstance", "loss_value.data.clone.item", "loss_value.data.clone.mean", "isinstance", "torch.is_available", "torch.is_initialized", "loss_value.data.clone.data.clone", "torch.all_reduce", "sum", "TypeError", "collections.OrderedDict.items", "loss_value.data.clone.div_", "torch.get_world_size", "_loss.mean"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size"], ["parser", ".", "add_argument", "(", "\n", "'--deterministic'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'whether to set deterministic options for CUDNN backend.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--debug'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'debug (one gpu - disable DistributedDataParallel). With this flag, you can set breakpoints'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--launcher'", ",", "\n", "choices", "=", "[", "'none'", ",", "'pytorch'", ",", "'slurm'", ",", "'mpi'", "]", ",", "\n", "default", "=", "'none'", ",", "\n", "help", "=", "'job launcher'", ")", "\n", "parser", ".", "add_argument", "(", "'--local_rank'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "parser", ".", "add_argument", "(", "'--port'", ",", "type", "=", "int", ",", "default", "=", "29500", ",", "\n", "help", "=", "'port only works when launcher==\"slurm\"'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "if", "'LOCAL_RANK'", "not", "in", "os", ".", "environ", ":", "\n", "        ", "os", ".", "environ", "[", "'LOCAL_RANK'", "]", "=", "str", "(", "args", ".", "local_rank", ")", "\n", "\n", "", "return", "args", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.apis.train.batch_processor": [[63, 86], ["model", "train.parse_losses", "dict", "len"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.apis.train.parse_losses"], ["    ", "print", "(", "f\"Using num gpus: {torch.cuda.device_count()}\"", ")", "\n", "args", "=", "parse_args", "(", ")", "\n", "\n", "cfg", "=", "Config", ".", "fromfile", "(", "args", ".", "config", ")", "\n", "# set cudnn_benchmark", "\n", "if", "cfg", ".", "get", "(", "'cudnn_benchmark'", ",", "False", ")", ":", "\n", "        ", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "True", "\n", "# update configs according to CLI args", "\n", "", "if", "args", ".", "work_dir", "is", "not", "None", ":", "\n", "        ", "cfg", ".", "work_dir", "=", "args", ".", "work_dir", "\n", "", "if", "args", ".", "resume_from", "is", "not", "None", ":", "\n", "        ", "cfg", ".", "resume_from", "=", "args", ".", "resume_from", "\n", "", "cfg", ".", "gpus", "=", "args", ".", "gpus", "\n", "\n", "# check memcached package exists", "\n", "if", "importlib", ".", "util", ".", "find_spec", "(", "'mc'", ")", "is", "None", ":", "\n", "        ", "traverse_replace", "(", "cfg", ",", "'memcached'", ",", "False", ")", "\n", "\n", "# init distributed env first, since logger depends on the dist info.", "\n", "", "if", "args", ".", "launcher", "==", "'none'", ":", "\n", "        ", "distributed", "=", "False", "\n", "if", "not", "args", ".", "debug", ":", "\n", "            ", "assert", "cfg", ".", "model", ".", "type", "not", "in", "[", "'DeepCluster'", ",", "'MOCO'", ",", "'SimCLR'", ",", "'ODC'", ",", "'NPID'", "]", ","]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.apis.train.train_model": [[88, 111], ["openselfsup.utils.get_root_logger", "cfg.get", "cfg.get", "openselfsup.utils.print_log", "openselfsup.utils.print_log", "openselfsup.utils.print_log", "train._dist_train", "train._non_dist_train", "cfg.optimizer_config.get"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.print_log", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.print_log", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.print_log", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.apis.train._dist_train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.apis.train._non_dist_train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["cfg", ".", "model", ".", "type", ")", "\n", "", "", "else", ":", "\n", "        ", "distributed", "=", "True", "\n", "if", "args", ".", "launcher", "==", "'slurm'", ":", "\n", "            ", "cfg", ".", "dist_params", "[", "'port'", "]", "=", "args", ".", "port", "\n", "", "init_dist", "(", "args", ".", "launcher", ",", "**", "cfg", ".", "dist_params", ")", "\n", "\n", "# create work_dir", "\n", "", "mmcv", ".", "mkdir_or_exist", "(", "osp", ".", "abspath", "(", "cfg", ".", "work_dir", ")", ")", "\n", "# init the logger before other steps", "\n", "timestamp", "=", "time", ".", "strftime", "(", "'%Y%m%d_%H%M%S'", ",", "time", ".", "localtime", "(", ")", ")", "\n", "log_file", "=", "osp", ".", "join", "(", "cfg", ".", "work_dir", ",", "'train_{}.log'", ".", "format", "(", "timestamp", ")", ")", "\n", "logger", "=", "get_root_logger", "(", "log_file", "=", "log_file", ",", "log_level", "=", "cfg", ".", "log_level", ")", "\n", "\n", "# init the meta dict to record some important information such as", "\n", "# environment info and seed, which will be logged", "\n", "meta", "=", "dict", "(", ")", "\n", "# log env info", "\n", "env_info_dict", "=", "collect_env", "(", ")", "\n", "env_info", "=", "'\\n'", ".", "join", "(", "[", "(", "'{}: {}'", ".", "format", "(", "k", ",", "v", ")", ")", "\n", "for", "k", ",", "v", "in", "env_info_dict", ".", "items", "(", ")", "]", ")", "\n", "dash_line", "=", "'-'", "*", "60", "+", "'\\n'", "\n", "logger", ".", "info", "(", "'Environment info:\\n'", "+", "dash_line", "+", "env_info", "+", "'\\n'", "+", "\n", "dash_line", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.apis.train.build_optimizer": [[113, 179], ["hasattr", "optimizer_cfg.copy.copy", "optimizer_cfg.copy.pop", "mmcv.runner.obj_from_dict", "isinstance", "model.named_parameters", "getattr", "getattr.", "dict", "optimizer_cfg.pop.items", "params.append", "optimizer_cfg.copy.pop", "params.append", "re.search", "model.parameters", "options.items", "key.endswith", "openselfsup.utils.print_log", "torch.is_initialized", "torch.get_rank"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.print_log", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank"], ["\n", "# log some basic info", "\n", "logger", ".", "info", "(", "'Distributed training: {}'", ".", "format", "(", "distributed", ")", ")", "\n", "logger", ".", "info", "(", "'Config:\\n{}'", ".", "format", "(", "cfg", ".", "text", ")", ")", "\n", "\n", "# set random seeds", "\n", "if", "args", ".", "seed", "is", "not", "None", ":", "\n", "        ", "logger", ".", "info", "(", "'Set random seed to {}, deterministic: {}'", ".", "format", "(", "\n", "args", ".", "seed", ",", "args", ".", "deterministic", ")", ")", "\n", "set_random_seed", "(", "args", ".", "seed", ",", "deterministic", "=", "args", ".", "deterministic", ")", "\n", "", "cfg", ".", "seed", "=", "args", ".", "seed", "\n", "meta", "[", "'seed'", "]", "=", "args", ".", "seed", "\n", "\n", "if", "args", ".", "pretrained", "is", "not", "None", ":", "\n", "        ", "assert", "isinstance", "(", "args", ".", "pretrained", ",", "str", ")", "\n", "cfg", ".", "model", ".", "pretrained", "=", "args", ".", "pretrained", "\n", "", "model", "=", "build_model", "(", "cfg", ".", "model", ")", "\n", "if", "args", ".", "debug", ":", "\n", "# TODO(cjrd) fix this hardcoding?", "\n", "        ", "logger", ".", "info", "(", "\n", "\"DEBUGGING enabled, setting batch size to 64 to allow 1 gpu debugging\"", ")", "\n", "cfg", ".", "data", ".", "batch_size", "=", "64", "\n", "model", ".", "set_debug", "(", ")", "\n", "\n", "", "datasets", "=", "[", "build_dataset", "(", "cfg", ".", "data", ".", "train", ")", "]", "\n", "assert", "len", "(", "cfg", ".", "workflow", ")", "==", "1", ",", "\"Validation is called by hook.\"", "\n", "if", "cfg", ".", "checkpoint_config", "is", "not", "None", ":", "\n", "# save openselfsup version, config file content and class names in", "\n", "# checkpoints as meta data", "\n", "        ", "cfg", ".", "checkpoint_config", ".", "meta", "=", "dict", "(", "\n", "openselfsup_version", "=", "__version__", ",", "config", "=", "cfg", ".", "text", ")", "\n", "# add an attribute for visualization convenience", "\n", "", "train_model", "(", "\n", "model", ",", "\n", "datasets", ",", "\n", "cfg", ",", "\n", "distributed", "=", "distributed", ",", "\n", "timestamp", "=", "timestamp", ",", "\n", "meta", "=", "meta", ",", "\n", "debug", "=", "args", ".", "debug", ")", "\n", "\n", "\n", "", "if", "__name__", "==", "'__main__'", ":", "\n", "    ", "main", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.apis.train._dist_train": [[181, 260], ["getattr", "train.build_optimizer", "mmcv.parallel.MMDistributedDataParallel", "openselfsup.hooks.DistOptimizerHook", "mmcv.runner.IterBasedRunner.register_training_hooks", "cfg.get", "isinstance", "torch.cuda.device_count", "torch.cuda.device_count", "int", "openselfsup.utils.print_log", "openselfsup.datasets.build_dataloader", "apex.amp.initialize", "openselfsup.utils.print_log", "cfg.get", "mmcv.runner.Runner", "mmcv.runner.IterBasedRunner", "cfg.get", "mmcv.runner.IterBasedRunner.register_hook", "mmcv.runner.IterBasedRunner.register_hook", "mmcv.runner.IterBasedRunner.resume", "cfg.get", "mmcv.runner.IterBasedRunner.run", "mmcv.runner.IterBasedRunner.run", "mmcv.parallel.MMDistributedDataParallel.cuda", "mmcv.parallel.MMDistributedDataParallel.cuda", "mmcv.runner.DistSamplerSeedHook", "dict", "dict", "openselfsup.hooks.build_hook", "mmcv.runner.IterBasedRunner.load_checkpoint", "getattr", "getattr", "next", "torch.cuda.current_device", "torch.cuda.current_device", "mmcv.parallel.MMDistributedDataParallel.parameters"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.apis.train.build_optimizer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.print_log", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.build_loader.build_dataloader", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.print_log", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.builder.build_hook"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.apis.train._non_dist_train": [[262, 338], ["getattr", "mmcv.parallel.MMDataParallel().cuda", "train.build_optimizer", "openselfsup.hooks.NonDistOptimizerHook", "mmcv.runner.IterBasedRunner.register_training_hooks", "cfg.get", "int", "openselfsup.utils.print_log", "isinstance", "openselfsup.datasets.build_dataloader", "NotImplementedError", "cfg.get", "mmcv.runner.Runner", "mmcv.runner.IterBasedRunner", "mmcv.runner.IterBasedRunner.register_hook", "mmcv.runner.IterBasedRunner.resume", "cfg.get", "mmcv.runner.IterBasedRunner.run", "mmcv.runner.IterBasedRunner.run", "mmcv.parallel.MMDataParallel", "dict", "dict", "openselfsup.hooks.build_hook", "mmcv.runner.IterBasedRunner.load_checkpoint", "getattr", "getattr", "range"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.apis.train.build_optimizer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.print_log", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.build_loader.build_dataloader", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.builder.build_hook"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.odc.ODC.__init__": [[29, 53], ["torch.Module.__init__", "builder.build_backbone", "builder.build_neck", "odc.ODC.init_weights", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "odc.ODC.loss_weight.sum", "utils.Sobel", "builder.build_head", "builder.build_memory", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_neck", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_head", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_memory"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "with_sobel", "=", "False", ",", "\n", "neck", "=", "None", ",", "\n", "head", "=", "None", ",", "\n", "memory_bank", "=", "None", ",", "\n", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "ODC", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "with_sobel", "=", "with_sobel", "\n", "if", "with_sobel", ":", "\n", "            ", "self", ".", "sobel_layer", "=", "Sobel", "(", ")", "\n", "", "self", ".", "backbone", "=", "builder", ".", "build_backbone", "(", "backbone", ")", "\n", "self", ".", "neck", "=", "builder", ".", "build_neck", "(", "neck", ")", "\n", "if", "head", "is", "not", "None", ":", "\n", "            ", "self", ".", "head", "=", "builder", ".", "build_head", "(", "head", ")", "\n", "", "if", "memory_bank", "is", "not", "None", ":", "\n", "            ", "self", ".", "memory_bank", "=", "builder", ".", "build_memory", "(", "memory_bank", ")", "\n", "", "self", ".", "init_weights", "(", "pretrained", "=", "pretrained", ")", "\n", "\n", "# set reweight tensors", "\n", "self", ".", "num_classes", "=", "head", ".", "num_classes", "\n", "self", ".", "loss_weight", "=", "torch", ".", "ones", "(", "(", "self", ".", "num_classes", ",", ")", ",", "\n", "dtype", "=", "torch", ".", "float32", ")", ".", "cuda", "(", ")", "\n", "self", ".", "loss_weight", "/=", "self", ".", "loss_weight", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.odc.ODC.init_weights": [[54, 66], ["odc.ODC.backbone.init_weights", "odc.ODC.neck.init_weights", "odc.ODC.head.init_weights", "odc.ODC.utils.print_log"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.print_log"], ["", "def", "init_weights", "(", "self", ",", "pretrained", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize the weights of model.\n\n        Args:\n            pretrained (str, optional): Path to pre-trained weights.\n                Default: None.\n        \"\"\"", "\n", "if", "pretrained", "is", "not", "None", ":", "\n", "            ", "print_log", "(", "'load model from: {}'", ".", "format", "(", "pretrained", ")", ",", "logger", "=", "'root'", ")", "\n", "", "self", ".", "backbone", ".", "init_weights", "(", "pretrained", "=", "pretrained", ")", "\n", "self", ".", "neck", ".", "init_weights", "(", "init_linear", "=", "'kaiming'", ")", "\n", "self", ".", "head", ".", "init_weights", "(", "init_linear", "=", "'normal'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.odc.ODC.forward_backbone": [[67, 81], ["odc.ODC.backbone", "odc.ODC.sobel_layer"], "methods", ["None"], ["", "def", "forward_backbone", "(", "self", ",", "img", ")", ":", "\n", "        ", "\"\"\"Forward backbone.\n\n        Args:\n            img (Tensor): Input images of shape (N, C, H, W).\n                Typically these should be mean centered and std scaled.\n\n        Returns:\n            tuple[Tensor]: backbone outputs.\n        \"\"\"", "\n", "if", "self", ".", "with_sobel", ":", "\n", "            ", "img", "=", "self", ".", "sobel_layer", "(", "img", ")", "\n", "", "x", "=", "self", ".", "backbone", "(", "img", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.odc.ODC.forward_train": [[82, 110], ["odc.ODC.forward_backbone", "odc.ODC.neck", "odc.ODC.head", "odc.ODC.head.loss", "odc.ODC.memory_bank.update_samples_memory", "feature[].detach", "odc.ODC.memory_bank.label_bank[].cuda", "idx.cpu"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.multi_cls_head.MultiClsHead.loss", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory.update_samples_memory", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda"], ["", "def", "forward_train", "(", "self", ",", "img", ",", "idx", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Forward computation during training.\n\n        Args:\n            img (Tensor): Input images of shape (N, C, H, W).\n                Typically these should be mean centered and std scaled.\n            idx (Tensor): Index corresponding to each image.\n            kwargs: Any keyword arguments to be used to forward.\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "# forward & backward", "\n", "x", "=", "self", ".", "forward_backbone", "(", "img", ")", "\n", "feature", "=", "self", ".", "neck", "(", "x", ")", "\n", "outs", "=", "self", ".", "head", "(", "feature", ")", "\n", "if", "self", ".", "memory_bank", ".", "label_bank", ".", "is_cuda", ":", "\n", "            ", "loss_inputs", "=", "(", "outs", ",", "self", ".", "memory_bank", ".", "label_bank", "[", "idx", "]", ")", "\n", "", "else", ":", "\n", "            ", "loss_inputs", "=", "(", "outs", ",", "self", ".", "memory_bank", ".", "label_bank", "[", "idx", ".", "cpu", "(", ")", "]", ".", "cuda", "(", ")", ")", "\n", "", "losses", "=", "self", ".", "head", ".", "loss", "(", "*", "loss_inputs", ")", "\n", "\n", "# update samples memory", "\n", "change_ratio", "=", "self", ".", "memory_bank", ".", "update_samples_memory", "(", "\n", "idx", ",", "feature", "[", "0", "]", ".", "detach", "(", ")", ")", "\n", "losses", "[", "'change_ratio'", "]", "=", "change_ratio", "\n", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.odc.ODC.forward_test": [[111, 117], ["odc.ODC.forward_backbone", "odc.ODC.head", "dict", "out.cpu", "zip", "range", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone"], ["", "def", "forward_test", "(", "self", ",", "img", ",", "**", "kwargs", ")", ":", "\n", "        ", "x", "=", "self", ".", "forward_backbone", "(", "img", ")", "# tuple", "\n", "outs", "=", "self", ".", "head", "(", "x", ")", "\n", "keys", "=", "[", "'head{}'", ".", "format", "(", "i", ")", "for", "i", "in", "range", "(", "len", "(", "outs", ")", ")", "]", "\n", "out_tensors", "=", "[", "out", ".", "cpu", "(", ")", "for", "out", "in", "outs", "]", "# NxC", "\n", "return", "dict", "(", "zip", "(", "keys", ",", "out_tensors", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.odc.ODC.forward": [[118, 127], ["odc.ODC.forward_train", "odc.ODC.forward_test", "odc.ODC.forward_backbone", "Exception"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_test", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone"], ["", "def", "forward", "(", "self", ",", "img", ",", "mode", "=", "'train'", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "mode", "==", "'train'", ":", "\n", "            ", "return", "self", ".", "forward_train", "(", "img", ",", "**", "kwargs", ")", "\n", "", "elif", "mode", "==", "'test'", ":", "\n", "            ", "return", "self", ".", "forward_test", "(", "img", ",", "**", "kwargs", ")", "\n", "", "elif", "mode", "==", "'extract'", ":", "\n", "            ", "return", "self", ".", "forward_backbone", "(", "img", ")", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\"No such mode: {}\"", ".", "format", "(", "mode", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.odc.ODC.set_reweight": [[128, 148], ["numpy.bincount().astype", "odc.ODC.loss_weight.copy_", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "inv_hist.sum", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "odc.ODC.memory_bank.label_bank.cpu().numpy", "odc.ODC.memory_bank.label_bank.numpy", "numpy.bincount", "odc.ODC.memory_bank.label_bank.cpu"], "methods", ["None"], ["", "", "def", "set_reweight", "(", "self", ",", "labels", "=", "None", ",", "reweight_pow", "=", "0.5", ")", ":", "\n", "        ", "\"\"\"Loss re-weighting.\n\n        Re-weighting the loss according to the number of samples in each class.\n\n        Args:\n            labels (numpy.ndarray): Label assignments. Default: None.\n            reweight_pow (float): The power of re-weighting. Default: 0.5.\n        \"\"\"", "\n", "if", "labels", "is", "None", ":", "\n", "            ", "if", "self", ".", "memory_bank", ".", "label_bank", ".", "is_cuda", ":", "\n", "                ", "labels", "=", "self", ".", "memory_bank", ".", "label_bank", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "                ", "labels", "=", "self", ".", "memory_bank", ".", "label_bank", ".", "numpy", "(", ")", "\n", "", "", "hist", "=", "np", ".", "bincount", "(", "\n", "labels", ",", "minlength", "=", "self", ".", "num_classes", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "inv_hist", "=", "(", "1.", "/", "(", "hist", "+", "1e-5", ")", ")", "**", "reweight_pow", "\n", "weight", "=", "inv_hist", "/", "inv_hist", ".", "sum", "(", ")", "\n", "self", ".", "loss_weight", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "weight", ")", ")", "\n", "self", ".", "head", ".", "criterion", "=", "nn", ".", "CrossEntropyLoss", "(", "weight", "=", "self", ".", "loss_weight", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.simclr.SimCLR.__init__": [[26, 32], ["torch.Module.__init__", "builder.build_backbone", "builder.build_neck", "builder.build_head", "simclr.SimCLR.init_weights"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_neck", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_head", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights"], ["def", "__init__", "(", "self", ",", "backbone", ",", "neck", "=", "None", ",", "head", "=", "None", ",", "pretrained", "=", "None", ")", ":", "\n", "        ", "super", "(", "SimCLR", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "backbone", "=", "builder", ".", "build_backbone", "(", "backbone", ")", "\n", "self", ".", "neck", "=", "builder", ".", "build_neck", "(", "neck", ")", "\n", "self", ".", "head", "=", "builder", ".", "build_head", "(", "head", ")", "\n", "self", ".", "init_weights", "(", "pretrained", "=", "pretrained", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.simclr.SimCLR._create_buffer": [[33, 42], ["torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.arange().cuda", "torch.arange().cuda", "torch.arange().cuda", "torch.arange().cuda", "torch.arange().unsqueeze().repeat().view().squeeze().cuda", "torch.arange().unsqueeze().repeat().view().squeeze().cuda", "torch.arange().unsqueeze().repeat().view().squeeze().cuda", "torch.arange().unsqueeze().repeat().view().squeeze().cuda", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange().unsqueeze().repeat().view().squeeze", "torch.arange().unsqueeze().repeat().view().squeeze", "torch.arange().unsqueeze().repeat().view().squeeze", "torch.arange().unsqueeze().repeat().view().squeeze", "torch.arange().unsqueeze().repeat().view", "torch.arange().unsqueeze().repeat().view", "torch.arange().unsqueeze().repeat().view", "torch.arange().unsqueeze().repeat().view", "torch.arange().unsqueeze().repeat", "torch.arange().unsqueeze().repeat", "torch.arange().unsqueeze().repeat", "torch.arange().unsqueeze().repeat", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange", "torch.arange", "torch.arange", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda"], ["", "@", "staticmethod", "\n", "def", "_create_buffer", "(", "N", ")", ":", "\n", "        ", "mask", "=", "1", "-", "torch", ".", "eye", "(", "N", "*", "2", ",", "dtype", "=", "torch", ".", "uint8", ")", ".", "cuda", "(", ")", "\n", "pos_ind", "=", "(", "torch", ".", "arange", "(", "N", "*", "2", ")", ".", "cuda", "(", ")", ",", "\n", "2", "*", "torch", ".", "arange", "(", "N", ",", "dtype", "=", "torch", ".", "long", ")", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "\n", "1", ",", "2", ")", ".", "view", "(", "-", "1", ",", "1", ")", ".", "squeeze", "(", ")", ".", "cuda", "(", ")", ")", "\n", "neg_mask", "=", "torch", ".", "ones", "(", "(", "N", "*", "2", ",", "N", "*", "2", "-", "1", ")", ",", "dtype", "=", "torch", ".", "uint8", ")", ".", "cuda", "(", ")", "\n", "neg_mask", "[", "pos_ind", "]", "=", "0", "\n", "return", "mask", ",", "pos_ind", ",", "neg_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.simclr.SimCLR.init_weights": [[43, 54], ["simclr.SimCLR.backbone.init_weights", "simclr.SimCLR.neck.init_weights", "simclr.SimCLR.utils.print_log"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.print_log"], ["", "def", "init_weights", "(", "self", ",", "pretrained", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize the weights of model.\n\n        Args:\n            pretrained (str, optional): Path to pre-trained weights.\n                Default: None.\n        \"\"\"", "\n", "if", "pretrained", "is", "not", "None", ":", "\n", "            ", "print_log", "(", "'load model from: {}'", ".", "format", "(", "pretrained", ")", ",", "logger", "=", "'root'", ")", "\n", "", "self", ".", "backbone", ".", "init_weights", "(", "pretrained", "=", "pretrained", ")", "\n", "self", ".", "neck", ".", "init_weights", "(", "init_linear", "=", "'kaiming'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.simclr.SimCLR.forward_backbone": [[55, 67], ["simclr.SimCLR.backbone"], "methods", ["None"], ["", "def", "forward_backbone", "(", "self", ",", "img", ")", ":", "\n", "        ", "\"\"\"Forward backbone.\n\n        Args:\n            img (Tensor): Input images of shape (N, C, H, W).\n                Typically these should be mean centered and std scaled.\n\n        Returns:\n            tuple[Tensor]: backbone outputs.\n        \"\"\"", "\n", "x", "=", "self", ".", "backbone", "(", "img", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.simclr.SimCLR.forward_train": [[68, 97], ["img.reshape.reshape.reshape", "simclr.SimCLR.forward_backbone", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "simclr.SimCLR._create_buffer", "torch.masked_select().reshape", "torch.masked_select().reshape", "torch.masked_select().reshape", "torch.masked_select().reshape", "s[].unsqueeze", "torch.masked_select().reshape", "torch.masked_select().reshape", "torch.masked_select().reshape", "torch.masked_select().reshape", "simclr.SimCLR.head", "img.reshape.reshape.dim", "img.reshape.reshape.dim", "img.reshape.reshape.size", "img.reshape.reshape.size", "img.reshape.reshape.size", "simclr.SimCLR.neck", "utils.GatherLayer.apply", "torch.cat.size", "torch.cat.size", "torch.cat.permute", "torch.cat.permute", "torch.masked_select().reshape.size", "torch.masked_select().reshape.size", "torch.masked_select().reshape.size", "torch.masked_select().reshape.size", "img.reshape.reshape.size", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.cat.size", "torch.cat.size", "torch.masked_select", "torch.masked_select", "torch.masked_select", "torch.masked_select", "torch.masked_select", "torch.masked_select", "torch.masked_select", "torch.masked_select"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.simclr.SimCLR._create_buffer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.norm"], ["", "def", "forward_train", "(", "self", ",", "img", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Forward computation during training.\n\n        Args:\n            img (Tensor): Input of two concatenated images of shape (N, 2, C, H, W).\n                Typically these should be mean centered and std scaled.\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "assert", "img", ".", "dim", "(", ")", "==", "5", ",", "\"Input must have 5 dims, got: {}\"", ".", "format", "(", "img", ".", "dim", "(", ")", ")", "\n", "img", "=", "img", ".", "reshape", "(", "\n", "img", ".", "size", "(", "0", ")", "*", "2", ",", "img", ".", "size", "(", "2", ")", ",", "img", ".", "size", "(", "3", ")", ",", "img", ".", "size", "(", "4", ")", ")", "\n", "x", "=", "self", ".", "forward_backbone", "(", "img", ")", "# 2n", "\n", "z", "=", "self", ".", "neck", "(", "x", ")", "[", "0", "]", "# (2n)xd", "\n", "z", "=", "z", "/", "(", "torch", ".", "norm", "(", "z", ",", "p", "=", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "+", "1e-10", ")", "\n", "z", "=", "torch", ".", "cat", "(", "GatherLayer", ".", "apply", "(", "z", ")", ",", "dim", "=", "0", ")", "# (2N)xd", "\n", "assert", "z", ".", "size", "(", "0", ")", "%", "2", "==", "0", "\n", "N", "=", "z", ".", "size", "(", "0", ")", "//", "2", "\n", "s", "=", "torch", ".", "matmul", "(", "z", ",", "z", ".", "permute", "(", "1", ",", "0", ")", ")", "# (2N)x(2N)", "\n", "mask", ",", "pos_ind", ",", "neg_mask", "=", "self", ".", "_create_buffer", "(", "N", ")", "\n", "# remove diagonal, (2N)x(2N-1)", "\n", "s", "=", "torch", ".", "masked_select", "(", "s", ",", "mask", "==", "1", ")", ".", "reshape", "(", "s", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "positive", "=", "s", "[", "pos_ind", "]", ".", "unsqueeze", "(", "1", ")", "# (2N)x1", "\n", "# select negative, (2N)x(2N-2)", "\n", "negative", "=", "torch", ".", "masked_select", "(", "s", ",", "neg_mask", "==", "1", ")", ".", "reshape", "(", "s", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "losses", "=", "self", ".", "head", "(", "positive", ",", "negative", ")", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.simclr.SimCLR.forward_test": [[98, 100], ["None"], "methods", ["None"], ["", "def", "forward_test", "(", "self", ",", "img", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.simclr.SimCLR.forward": [[101, 110], ["simclr.SimCLR.forward_train", "simclr.SimCLR.forward_test", "simclr.SimCLR.forward_backbone", "Exception"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_test", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone"], ["", "def", "forward", "(", "self", ",", "img", ",", "mode", "=", "'train'", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "mode", "==", "'train'", ":", "\n", "            ", "return", "self", ".", "forward_train", "(", "img", ",", "**", "kwargs", ")", "\n", "", "elif", "mode", "==", "'test'", ":", "\n", "            ", "return", "self", ".", "forward_test", "(", "img", ",", "**", "kwargs", ")", "\n", "", "elif", "mode", "==", "'extract'", ":", "\n", "            ", "return", "self", ".", "forward_backbone", "(", "img", ")", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\"No such mode: {}\"", ".", "format", "(", "mode", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.npid.NPID.__init__": [[29, 46], ["torch.Module.__init__", "builder.build_backbone", "builder.build_neck", "builder.build_head", "builder.build_memory", "npid.NPID.init_weights"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_neck", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_head", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_memory", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.npid.NPID.init_weights": [[47, 58], ["npid.NPID.backbone.init_weights", "npid.NPID.neck.init_weights", "npid.NPID.utils.print_log"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.print_log"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.npid.NPID.forward_backbone": [[59, 71], ["npid.NPID.backbone"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.npid.NPID.forward_train": [[72, 118], ["npid.NPID.forward_backbone", "idx.cuda.cuda.cuda", "torch.functional.normalize", "torch.functional.normalize", "npid.NPID.memory_bank.multinomial.draw", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select().view", "torch.index_select().view", "torch.index_select().view", "torch.index_select().view", "torch.einsum().unsqueeze", "torch.einsum().unsqueeze", "torch.einsum().unsqueeze", "torch.einsum().unsqueeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "npid.NPID.head", "npid.NPID.neck", "neg_idx.flatten.flatten.view", "neg_idx.flatten.flatten.flatten", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "npid.NPID.memory_bank.update", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.functional.normalize.detach", "idx.cuda.cuda.view", "wrong.sum().item", "npid.NPID.memory_bank.multinomial.draw", "torch.functional.normalize.unsqueeze", "wrong.sum().item", "wrong.sum", "wrong.sum"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.draw", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.draw"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.npid.NPID.forward_test": [[119, 121], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.npid.NPID.forward": [[122, 131], ["npid.NPID.forward_train", "npid.NPID.forward_test", "npid.NPID.forward_backbone", "Exception"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_test", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.rotation_pred.RotationPred.__init__": [[23, 29], ["torch.Module.__init__", "builder.build_backbone", "rotation_pred.RotationPred.init_weights", "builder.build_head"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_head"], ["\n", "\n", "", "@", "DATASETS", ".", "register_module", "\n", "class", "RotationPredDataset", "(", "BaseDataset", ")", ":", "\n", "    ", "\"\"\"Dataset for rotation prediction.\n    \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.rotation_pred.RotationPred.init_weights": [[30, 41], ["rotation_pred.RotationPred.backbone.init_weights", "rotation_pred.RotationPred.head.init_weights", "rotation_pred.RotationPred.utils.print_log"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.print_log"], ["def", "__init__", "(", "self", ",", "data_source", ",", "pipeline", ")", ":", "\n", "        ", "super", "(", "RotationPredDataset", ",", "self", ")", ".", "__init__", "(", "data_source", ",", "pipeline", ")", "\n", "\n", "", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "img", "=", "self", ".", "data_source", ".", "get_sample", "(", "idx", ")", "\n", "assert", "isinstance", "(", "img", ",", "Image", ".", "Image", ")", ",", "'The output from the data source must be an Image, got: {}. \\\n            Please ensure that the list file does not contain labels.'", ".", "format", "(", "\n", "type", "(", "img", ")", ")", "\n", "img", "=", "self", ".", "pipeline", "(", "img", ")", "\n", "img", "=", "torch", ".", "stack", "(", "rotate", "(", "img", ")", ",", "dim", "=", "0", ")", "\n", "rotation_labels", "=", "torch", ".", "LongTensor", "(", "[", "0", ",", "1", ",", "2", ",", "3", "]", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.rotation_pred.RotationPred.forward_backbone": [[42, 54], ["rotation_pred.RotationPred.backbone"], "methods", ["None"], ["return", "dict", "(", "img", "=", "img", ",", "rot_label", "=", "rotation_labels", ")", "\n", "\n", "", "def", "evaluate", "(", "self", ",", "scores", ",", "keyword", ",", "logger", "=", "None", ")", ":", "\n", "        ", "raise", "NotImplemented", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.rotation_pred.RotationPred.forward_train": [[55, 72], ["rotation_pred.RotationPred.forward_backbone", "rotation_pred.RotationPred.head", "rotation_pred.RotationPred.head.loss"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.multi_cls_head.MultiClsHead.loss"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.rotation_pred.RotationPred.forward_test": [[73, 79], ["rotation_pred.RotationPred.forward_backbone", "rotation_pred.RotationPred.head", "dict", "out.cpu", "zip", "range", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.rotation_pred.RotationPred.forward": [[80, 95], ["img.view.view.view", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "rotation_pred.RotationPred.forward_train", "img.view.view.dim", "torch.flatten.dim", "torch.flatten.dim", "img.view.view.size", "img.view.view.size", "img.view.view.size", "rotation_pred.RotationPred.forward_test", "img.view.view.size", "img.view.view.size", "rotation_pred.RotationPred.forward_backbone", "Exception"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_test", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build": [[8, 44], ["isinstance", "cfg.get", "cfg.get().get", "builder.build_backbone", "torch.randn", "build_backbone.", "isinstance", "torch.nn.Sequential", "openselfsup.utils.build_from_cfg", "[].find", "openselfsup.utils.build_from_cfg", "cfg.get", "registry.BACKBONES", "registry.NECKS", "registry.MEMORIES", "registry.HEADS", "registry.LOSSES", "registry.MODELS"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.registry.build_from_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.registry.build_from_cfg", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["def", "_concat_dataset", "(", "cfg", ",", "default_args", "=", "None", ")", ":", "\n", "    ", "ann_files", "=", "cfg", "[", "'ann_file'", "]", "\n", "img_prefixes", "=", "cfg", ".", "get", "(", "'img_prefix'", ",", "None", ")", "\n", "seg_prefixes", "=", "cfg", ".", "get", "(", "'seg_prefix'", ",", "None", ")", "\n", "proposal_files", "=", "cfg", ".", "get", "(", "'proposal_file'", ",", "None", ")", "\n", "\n", "datasets", "=", "[", "]", "\n", "num_dset", "=", "len", "(", "ann_files", ")", "\n", "for", "i", "in", "range", "(", "num_dset", ")", ":", "\n", "        ", "data_cfg", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "data_cfg", "[", "'ann_file'", "]", "=", "ann_files", "[", "i", "]", "\n", "if", "isinstance", "(", "img_prefixes", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "data_cfg", "[", "'img_prefix'", "]", "=", "img_prefixes", "[", "i", "]", "\n", "", "if", "isinstance", "(", "seg_prefixes", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "data_cfg", "[", "'seg_prefix'", "]", "=", "seg_prefixes", "[", "i", "]", "\n", "", "if", "isinstance", "(", "proposal_files", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "data_cfg", "[", "'proposal_file'", "]", "=", "proposal_files", "[", "i", "]", "\n", "", "datasets", ".", "append", "(", "build_dataset", "(", "data_cfg", ",", "default_args", ")", ")", "\n", "\n", "", "return", "ConcatDataset", "(", "datasets", ")", "\n", "\n", "\n", "", "def", "build_dataset", "(", "cfg", ",", "default_args", "=", "None", ")", ":", "\n", "    ", "if", "isinstance", "(", "cfg", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "dataset", "=", "ConcatDataset", "(", "[", "build_dataset", "(", "c", ",", "default_args", ")", "for", "c", "in", "cfg", "]", ")", "\n", "", "elif", "cfg", "[", "'type'", "]", "==", "'RepeatDataset'", ":", "\n", "        ", "dataset", "=", "RepeatDataset", "(", "\n", "build_dataset", "(", "cfg", "[", "'dataset'", "]", ",", "default_args", ")", ",", "cfg", "[", "'times'", "]", ")", "\n", "", "else", ":", "\n", "        ", "dataset", "=", "build_from_cfg", "(", "cfg", ",", "DATASETS", ",", "default_args", ")", "\n", "\n", "", "return", "dataset", "\n", "\n", "\n", "", "def", "build_datasource", "(", "cfg", ")", ":", "\n", "    ", "return", "build_from_cfg", "(", "cfg", ",", "DATASOURCES", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone": [[46, 49], ["builder.build"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_neck": [[51, 54], ["builder.build"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_memory": [[56, 59], ["builder.build"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_head": [[61, 64], ["builder.build"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_loss": [[66, 69], ["builder.build"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_model": [[71, 74], ["builder.build"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.deepcluster.DeepCluster.__init__": [[29, 50], ["torch.Module.__init__", "builder.build_backbone", "builder.build_neck", "deepcluster.DeepCluster.init_weights", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "deepcluster.DeepCluster.loss_weight.sum", "utils.Sobel", "builder.build_head", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_neck", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_head"], [".", "format", "(", "len", "(", "self", ".", "labels", ")", ",", "len", "(", "labels", ")", ")", "\n", "self", ".", "labels", "=", "labels", "[", ":", "]", "\n", "\n", "", "def", "evaluate", "(", "self", ",", "scores", ",", "keyword", ",", "logger", "=", "None", ")", ":", "\n", "\n", "        ", "raise", "NotImplemented", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.deepcluster.DeepCluster.init_weights": [[51, 63], ["deepcluster.DeepCluster.backbone.init_weights", "deepcluster.DeepCluster.neck.init_weights", "deepcluster.DeepCluster.head.init_weights", "deepcluster.DeepCluster.utils.print_log"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.print_log"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.deepcluster.DeepCluster.forward_backbone": [[64, 78], ["deepcluster.DeepCluster.backbone", "deepcluster.DeepCluster.sobel_layer"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.deepcluster.DeepCluster.forward_train": [[79, 98], ["deepcluster.DeepCluster.forward_backbone", "deepcluster.DeepCluster.neck", "deepcluster.DeepCluster.head", "deepcluster.DeepCluster.head.loss", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.multi_cls_head.MultiClsHead.loss"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.deepcluster.DeepCluster.forward_test": [[99, 105], ["deepcluster.DeepCluster.forward_backbone", "deepcluster.DeepCluster.head", "dict", "out.cpu", "zip", "range", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.deepcluster.DeepCluster.forward": [[106, 115], ["deepcluster.DeepCluster.forward_train", "deepcluster.DeepCluster.forward_test", "deepcluster.DeepCluster.forward_backbone", "Exception"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_test", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.deepcluster.DeepCluster.set_reweight": [[116, 131], ["numpy.bincount().astype", "deepcluster.DeepCluster.loss_weight.copy_", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "inv_hist.sum", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.bincount"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.classification.Classification.__init__": [[23, 36], ["moco.BaseModel.__init__", "builder.build_backbone", "classification.Classification.init_weights", "utils.Sobel", "builder.build_head"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_head"], ["", "return", "dict", "(", "img", "=", "img", ",", "gt_label", "=", "target", ")", "\n", "\n", "", "def", "evaluate", "(", "self", ",", "scores", ",", "keyword", ",", "logger", "=", "None", ",", "topk", "=", "(", "1", ",", "5", ")", ")", ":", "\n", "        ", "eval_res", "=", "{", "}", "\n", "\n", "target", "=", "torch", ".", "LongTensor", "(", "self", ".", "data_source", ".", "labels", ")", "\n", "assert", "scores", ".", "size", "(", "0", ")", "==", "target", ".", "size", "(", "0", ")", ",", "\"Inconsistent length for results and labels, {} vs {}\"", ".", "format", "(", "\n", "scores", ".", "size", "(", "0", ")", ",", "target", ".", "size", "(", "0", ")", ")", "\n", "num", "=", "scores", ".", "size", "(", "0", ")", "\n", "_", ",", "pred", "=", "scores", ".", "topk", "(", "max", "(", "topk", ")", ",", "dim", "=", "1", ",", "largest", "=", "True", ",", "sorted", "=", "True", ")", "\n", "pred", "=", "pred", ".", "t", "(", ")", "\n", "correct", "=", "pred", ".", "eq", "(", "target", ".", "view", "(", "1", ",", "-", "1", ")", ".", "expand_as", "(", "pred", ")", ")", "# KxN", "\n", "for", "k", "in", "topk", ":", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.classification.Classification.init_weights": [[37, 48], ["classification.Classification.backbone.init_weights", "classification.Classification.head.init_weights", "classification.Classification.utils.print_log"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.print_log"], ["            ", "correct_k", "=", "correct", "[", ":", "k", "]", ".", "view", "(", "-", "1", ")", ".", "float", "(", ")", ".", "sum", "(", "0", ")", ".", "item", "(", ")", "\n", "acc", "=", "correct_k", "*", "100.0", "/", "num", "\n", "eval_res", "[", "\"{}_top{}\"", ".", "format", "(", "keyword", ",", "k", ")", "]", "=", "acc", "\n", "if", "logger", "is", "not", "None", "and", "logger", "!=", "'silent'", ":", "\n", "                ", "print_log", "(", "\n", "\"{}_top{}: {:.03f}\"", ".", "format", "(", "keyword", ",", "k", ",", "acc", ")", ",", "\n", "logger", "=", "logger", ")", "\n", "", "", "return", "eval_res", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.classification.Classification.forward_backbone": [[49, 63], ["classification.Classification.backbone", "classification.Classification.sobel_layer"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.classification.Classification.forward_train": [[64, 81], ["classification.Classification.forward_backbone", "classification.Classification.head", "classification.Classification.head.loss"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.multi_cls_head.MultiClsHead.loss"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.classification.Classification.forward_test": [[82, 88], ["classification.Classification.forward_backbone", "classification.Classification.head", "dict", "out.cpu", "zip", "range", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.classification.Classification.aug_test": [[89, 94], ["numpy.mean", "classification.Classification.head", "classification.Classification.forward_backbone"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.classification.Classification.forward": [[95, 104], ["classification.Classification.forward_train", "classification.Classification.forward_test", "classification.Classification.forward_backbone", "Exception"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_test", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.BaseModel.__init__": [[15, 18], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "BaseModel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "debug", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.BaseModel.set_debug": [[19, 21], ["None"], "methods", ["None"], ["", "def", "set_debug", "(", "self", ")", ":", "\n", "        ", "self", ".", "debug", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.BaseModel.train_step": [[22, 28], ["moco.BaseModel.", "moco.BaseModel._parse_losses", "dict", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BaseModel._parse_losses"], ["", "def", "train_step", "(", "self", ",", "data", ",", "optimizer", ",", "**", "kwargs", ")", ":", "\n", "        ", "losses", "=", "self", "(", "**", "data", ")", "\n", "loss", ",", "log_vars", "=", "self", ".", "_parse_losses", "(", "losses", ")", "\n", "outputs", "=", "dict", "(", "loss", "=", "loss", ",", "log_vars", "=", "log_vars", ",", "\n", "num_samples", "=", "len", "(", "data", "[", "'img'", "]", ".", "data", ")", ")", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.BaseModel.eval_step": [[29, 35], ["moco.BaseModel.", "moco.BaseModel._parse_losses", "dict", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BaseModel._parse_losses"], ["", "def", "eval_step", "(", "self", ",", "data", ",", "optimizer", ",", "**", "kwargs", ")", ":", "\n", "        ", "losses", "=", "self", "(", "**", "data", ")", "\n", "loss", ",", "log_vars", "=", "self", ".", "_parse_losses", "(", "losses", ")", "\n", "outputs", "=", "dict", "(", "loss", "=", "loss", ",", "log_vars", "=", "log_vars", ",", "\n", "num_samples", "=", "len", "(", "data", "[", "'img'", "]", ".", "data", ")", ")", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.BaseModel.val": [[36, 42], ["moco.BaseModel.", "moco.BaseModel._parse_losses", "dict", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BaseModel._parse_losses"], ["", "def", "val", "(", "self", ",", "data", ",", "optimizer", ",", "**", "kwargs", ")", ":", "\n", "        ", "losses", "=", "self", "(", "**", "data", ")", "\n", "loss", ",", "log_vars", "=", "self", ".", "_parse_losses", "(", "losses", ")", "\n", "outputs", "=", "dict", "(", "loss", "=", "loss", ",", "log_vars", "=", "log_vars", ",", "\n", "num_samples", "=", "len", "(", "data", "[", "'img'", "]", ".", "data", ")", ")", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.BaseModel._parse_losses": [[43, 75], ["collections.OrderedDict", "losses.items", "sum", "collections.OrderedDict.items", "isinstance", "loss_value.data.clone.data.clone.item", "loss_value.data.clone.data.clone.mean", "isinstance", "torch.is_available", "torch.is_available", "torch.is_available", "torch.is_initialized", "torch.is_initialized", "torch.is_initialized", "loss_value.data.clone.data.clone.data.clone", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "sum", "TypeError", "collections.OrderedDict.items", "loss_value.data.clone.data.clone.div_", "torch.get_world_size", "torch.get_world_size", "torch.get_world_size", "_loss.mean"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size"], ["", "def", "_parse_losses", "(", "self", ",", "losses", ")", ":", "\n", "        ", "\"\"\"Parse the raw outputs (losses) of the network.\n        Args:\n            losses (dict): Raw output of the network, which usually contain\n                losses and other necessary infomation.\n        Returns:\n            tuple[Tensor, dict]: (loss, log_vars), loss is the loss tensor \\\n                which may be a weighted sum of all losses, log_vars contains \\\n                all the variables to be sent to the logger.\n        \"\"\"", "\n", "log_vars", "=", "OrderedDict", "(", ")", "\n", "for", "loss_name", ",", "loss_value", "in", "losses", ".", "items", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "loss_value", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "log_vars", "[", "loss_name", "]", "=", "loss_value", ".", "mean", "(", ")", "\n", "", "elif", "isinstance", "(", "loss_value", ",", "list", ")", ":", "\n", "                ", "log_vars", "[", "loss_name", "]", "=", "sum", "(", "_loss", ".", "mean", "(", ")", "for", "_loss", "in", "loss_value", ")", "\n", "", "else", ":", "\n", "                ", "raise", "TypeError", "(", "\n", "f'{loss_name} is not a tensor or list of tensors'", ")", "\n", "\n", "", "", "loss", "=", "sum", "(", "_value", "for", "_key", ",", "_value", "in", "log_vars", ".", "items", "(", ")", "\n", "if", "'loss'", "in", "_key", ")", "\n", "\n", "log_vars", "[", "'loss'", "]", "=", "loss", "\n", "for", "loss_name", ",", "loss_value", "in", "log_vars", ".", "items", "(", ")", ":", "\n", "# reduce loss when distributed training", "\n", "            ", "if", "dist", ".", "is_available", "(", ")", "and", "dist", ".", "is_initialized", "(", ")", ":", "\n", "                ", "loss_value", "=", "loss_value", ".", "data", ".", "clone", "(", ")", "\n", "dist", ".", "all_reduce", "(", "loss_value", ".", "div_", "(", "dist", ".", "get_world_size", "(", ")", ")", ")", "\n", "", "log_vars", "[", "loss_name", "]", "=", "loss_value", ".", "item", "(", ")", "\n", "\n", "", "return", "loss", ",", "log_vars", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.MOCO.__init__": [[99, 126], ["moco.BaseModel.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "moco.MOCO.encoder_k.parameters", "builder.build_head", "moco.MOCO.init_weights", "moco.MOCO.register_buffer", "torch.functional.normalize", "torch.functional.normalize", "torch.functional.normalize", "moco.MOCO.register_buffer", "builder.build_backbone", "builder.build_neck", "builder.build_backbone", "builder.build_neck", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_head", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_neck", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_neck"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", "=", "None", ",", "\n", "head", "=", "None", ",", "\n", "pretrained", "=", "None", ",", "\n", "queue_len", "=", "65536", ",", "\n", "feat_dim", "=", "128", ",", "\n", "momentum", "=", "0.999", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "MOCO", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "encoder_q", "=", "nn", ".", "Sequential", "(", "\n", "builder", ".", "build_backbone", "(", "backbone", ")", ",", "builder", ".", "build_neck", "(", "neck", ")", ")", "\n", "self", ".", "encoder_k", "=", "nn", ".", "Sequential", "(", "\n", "builder", ".", "build_backbone", "(", "backbone", ")", ",", "builder", ".", "build_neck", "(", "neck", ")", ")", "\n", "self", ".", "backbone", "=", "self", ".", "encoder_q", "[", "0", "]", "\n", "for", "param", "in", "self", ".", "encoder_k", ".", "parameters", "(", ")", ":", "\n", "            ", "param", ".", "requires_grad", "=", "False", "\n", "", "self", ".", "head", "=", "builder", ".", "build_head", "(", "head", ")", "\n", "self", ".", "init_weights", "(", "pretrained", "=", "pretrained", ")", "\n", "\n", "self", ".", "queue_len", "=", "queue_len", "\n", "self", ".", "momentum", "=", "momentum", "\n", "\n", "# create the queue", "\n", "self", ".", "register_buffer", "(", "\"queue\"", ",", "torch", ".", "randn", "(", "feat_dim", ",", "queue_len", ")", ")", "\n", "self", ".", "queue", "=", "nn", ".", "functional", ".", "normalize", "(", "self", ".", "queue", ",", "dim", "=", "0", ")", "\n", "self", ".", "register_buffer", "(", "\"queue_ptr\"", ",", "torch", ".", "zeros", "(", "1", ",", "dtype", "=", "torch", ".", "long", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.MOCO.init_weights": [[127, 141], ["moco.MOCO.encoder_q[].init_weights", "moco.MOCO.encoder_q[].init_weights", "zip", "moco.MOCO.utils.print_log", "moco.MOCO.encoder_q.parameters", "moco.MOCO.encoder_k.parameters", "param_k.data.copy_"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.print_log"], ["", "def", "init_weights", "(", "self", ",", "pretrained", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize the weights of model.\n\n        Args:\n            pretrained (str, optional): Path to pre-trained weights.\n                Default: None.\n        \"\"\"", "\n", "if", "pretrained", "is", "not", "None", ":", "\n", "            ", "print_log", "(", "'load model from: {}'", ".", "format", "(", "pretrained", ")", ",", "logger", "=", "'root'", ")", "\n", "", "self", ".", "encoder_q", "[", "0", "]", ".", "init_weights", "(", "pretrained", "=", "pretrained", ")", "\n", "self", ".", "encoder_q", "[", "1", "]", ".", "init_weights", "(", "init_linear", "=", "'kaiming'", ")", "\n", "for", "param_q", ",", "param_k", "in", "zip", "(", "self", ".", "encoder_q", ".", "parameters", "(", ")", ",", "\n", "self", ".", "encoder_k", ".", "parameters", "(", ")", ")", ":", "\n", "            ", "param_k", ".", "data", ".", "copy_", "(", "param_q", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.MOCO._momentum_update_key_encoder": [[142, 149], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "zip", "moco.MOCO.encoder_q.parameters", "moco.MOCO.encoder_k.parameters"], "methods", ["None"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_momentum_update_key_encoder", "(", "self", ")", ":", "\n", "        ", "\"\"\"Momentum update of the key encoder.\"\"\"", "\n", "for", "param_q", ",", "param_k", "in", "zip", "(", "self", ".", "encoder_q", ".", "parameters", "(", ")", ",", "\n", "self", ".", "encoder_k", ".", "parameters", "(", ")", ")", ":", "\n", "            ", "param_k", ".", "data", "=", "param_k", ".", "data", "*", "self", ".", "momentum", "+", "param_q", ".", "data", "*", "(", "1.", "-", "self", ".", "momentum", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.MOCO._dequeue_and_enqueue": [[150, 167], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "int", "concat_all_gather.transpose", "moco.concat_all_gather"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.concat_all_gather"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_dequeue_and_enqueue", "(", "self", ",", "keys", ")", ":", "\n", "        ", "\"\"\"Update queue.\"\"\"", "\n", "# gather keys before updating queue", "\n", "if", "not", "self", ".", "debug", ":", "\n", "            ", "keys", "=", "concat_all_gather", "(", "keys", ")", "\n", "\n", "", "batch_size", "=", "keys", ".", "shape", "[", "0", "]", "\n", "\n", "ptr", "=", "int", "(", "self", ".", "queue_ptr", ")", "\n", "assert", "self", ".", "queue_len", "%", "batch_size", "==", "0", "# for simplicity", "\n", "\n", "# replace the keys at ptr (dequeue and enqueue)", "\n", "self", ".", "queue", "[", ":", ",", "ptr", ":", "ptr", "+", "batch_size", "]", "=", "keys", ".", "transpose", "(", "0", ",", "1", ")", "\n", "ptr", "=", "(", "ptr", "+", "batch_size", ")", "%", "self", ".", "queue_len", "# move pointer", "\n", "\n", "self", ".", "queue_ptr", "[", "0", "]", "=", "ptr", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.MOCO._batch_shuffle_ddp": [[168, 195], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "moco.concat_all_gather", "torch.randperm().cuda", "torch.randperm().cuda", "torch.randperm().cuda", "torch.randperm().cuda", "torch.randperm().cuda", "torch.randperm().cuda", "torch.randperm().cuda", "torch.randperm().cuda", "torch.randperm().cuda", "torch.distributed.broadcast", "torch.distributed.broadcast", "torch.distributed.broadcast", "torch.distributed.broadcast", "torch.distributed.broadcast", "torch.distributed.broadcast", "torch.distributed.broadcast", "torch.distributed.broadcast", "torch.distributed.broadcast", "torch.argsort", "torch.argsort", "torch.argsort", "torch.argsort", "torch.argsort", "torch.argsort", "torch.argsort", "torch.argsort", "torch.argsort", "torch.distributed.get_rank", "torch.distributed.get_rank", "torch.distributed.get_rank", "torch.distributed.get_rank", "torch.distributed.get_rank", "torch.distributed.get_rank", "torch.distributed.get_rank", "torch.distributed.get_rank", "torch.distributed.get_rank", "torch.randperm().cuda.view", "torch.randperm().cuda.view", "torch.randperm().cuda.view", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.concat_all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_batch_shuffle_ddp", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Batch shuffle, for making use of BatchNorm.\n\n        *** Only support DistributedDataParallel (DDP) model. ***\n        \"\"\"", "\n", "# gather from all gpus", "\n", "batch_size_this", "=", "x", ".", "shape", "[", "0", "]", "\n", "x_gather", "=", "concat_all_gather", "(", "x", ")", "\n", "batch_size_all", "=", "x_gather", ".", "shape", "[", "0", "]", "\n", "\n", "num_gpus", "=", "batch_size_all", "//", "batch_size_this", "\n", "\n", "# random shuffle index", "\n", "idx_shuffle", "=", "torch", ".", "randperm", "(", "batch_size_all", ")", ".", "cuda", "(", ")", "\n", "\n", "# broadcast to all gpus", "\n", "torch", ".", "distributed", ".", "broadcast", "(", "idx_shuffle", ",", "src", "=", "0", ")", "\n", "\n", "# index for restoring", "\n", "idx_unshuffle", "=", "torch", ".", "argsort", "(", "idx_shuffle", ")", "\n", "\n", "# shuffled index for this gpu", "\n", "gpu_idx", "=", "torch", ".", "distributed", ".", "get_rank", "(", ")", "\n", "idx_this", "=", "idx_shuffle", ".", "view", "(", "num_gpus", ",", "-", "1", ")", "[", "gpu_idx", "]", "\n", "\n", "return", "x_gather", "[", "idx_this", "]", ",", "idx_unshuffle", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.MOCO._batch_unshuffle_ddp": [[196, 214], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "moco.concat_all_gather", "torch.distributed.get_rank", "torch.distributed.get_rank", "torch.distributed.get_rank", "torch.distributed.get_rank", "torch.distributed.get_rank", "torch.distributed.get_rank", "torch.distributed.get_rank", "torch.distributed.get_rank", "torch.distributed.get_rank", "idx_unshuffle.view"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.concat_all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_rank"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_batch_unshuffle_ddp", "(", "self", ",", "x", ",", "idx_unshuffle", ")", ":", "\n", "        ", "\"\"\"Undo batch shuffle.\n\n        *** Only support DistributedDataParallel (DDP) model. ***\n        \"\"\"", "\n", "# gather from all gpus", "\n", "batch_size_this", "=", "x", ".", "shape", "[", "0", "]", "\n", "x_gather", "=", "concat_all_gather", "(", "x", ")", "\n", "batch_size_all", "=", "x_gather", ".", "shape", "[", "0", "]", "\n", "\n", "num_gpus", "=", "batch_size_all", "//", "batch_size_this", "\n", "\n", "# restored index for this gpu", "\n", "gpu_idx", "=", "torch", ".", "distributed", ".", "get_rank", "(", ")", "\n", "idx_this", "=", "idx_unshuffle", ".", "view", "(", "num_gpus", ",", "-", "1", ")", "[", "gpu_idx", "]", "\n", "\n", "return", "x_gather", "[", "idx_this", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.MOCO.forward_train": [[215, 259], ["img[].contiguous", "img[].contiguous", "torch.functional.normalize", "torch.functional.normalize", "torch.functional.normalize", "torch.einsum().unsqueeze", "torch.einsum().unsqueeze", "torch.einsum().unsqueeze", "torch.einsum().unsqueeze", "torch.einsum().unsqueeze", "torch.einsum().unsqueeze", "torch.einsum().unsqueeze", "torch.einsum().unsqueeze", "torch.einsum().unsqueeze", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "moco.MOCO.head", "moco.MOCO._dequeue_and_enqueue", "img.dim", "img.dim", "moco.MOCO.encoder_q", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "moco.MOCO._momentum_update_key_encoder", "torch.functional.normalize", "torch.functional.normalize", "torch.functional.normalize", "moco.MOCO._batch_shuffle_ddp", "moco.MOCO.encoder_k", "moco.MOCO._batch_unshuffle_ddp", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "moco.MOCO.queue.clone().detach", "moco.MOCO.queue.clone"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.MOCO._dequeue_and_enqueue", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.MOCO._momentum_update_key_encoder", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.MOCO._batch_shuffle_ddp", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.MOCO._batch_unshuffle_ddp", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone"], ["", "def", "forward_train", "(", "self", ",", "img", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Forward computation during training.\n\n        Args:\n            img (Tensor): Input of two concatenated images of shape (N, 2, C, H, W).\n                Typically these should be mean centered and std scaled.\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "assert", "img", ".", "dim", "(", ")", "==", "5", ",", "\"Input must have 5 dims, got: {}\"", ".", "format", "(", "img", ".", "dim", "(", ")", ")", "\n", "im_q", "=", "img", "[", ":", ",", "0", ",", "...", "]", ".", "contiguous", "(", ")", "\n", "im_k", "=", "img", "[", ":", ",", "1", ",", "...", "]", ".", "contiguous", "(", ")", "\n", "# compute query features", "\n", "q", "=", "self", ".", "encoder_q", "(", "im_q", ")", "[", "0", "]", "# queries: NxC", "\n", "q", "=", "nn", ".", "functional", ".", "normalize", "(", "q", ",", "dim", "=", "1", ")", "\n", "\n", "# compute key features", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "# no gradient to keys", "\n", "            ", "self", ".", "_momentum_update_key_encoder", "(", ")", "# update the key encoder", "\n", "\n", "# shuffle for making use of BN", "\n", "if", "not", "self", ".", "debug", ":", "\n", "                ", "im_k", ",", "idx_unshuffle", "=", "self", ".", "_batch_shuffle_ddp", "(", "im_k", ")", "\n", "\n", "", "k", "=", "self", ".", "encoder_k", "(", "im_k", ")", "[", "0", "]", "# keys: NxC", "\n", "k", "=", "nn", ".", "functional", ".", "normalize", "(", "k", ",", "dim", "=", "1", ")", "\n", "\n", "# undo shuffle", "\n", "if", "not", "self", ".", "debug", ":", "\n", "                ", "k", "=", "self", ".", "_batch_unshuffle_ddp", "(", "k", ",", "idx_unshuffle", ")", "\n", "\n", "# compute logits", "\n", "# Einstein sum is more intuitive", "\n", "# positive logits: Nx1", "\n", "", "", "l_pos", "=", "torch", ".", "einsum", "(", "'nc,nc->n'", ",", "[", "q", ",", "k", "]", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "# negative logits: NxK", "\n", "l_neg", "=", "torch", ".", "einsum", "(", "'nc,ck->nk'", ",", "[", "q", ",", "self", ".", "queue", ".", "clone", "(", ")", ".", "detach", "(", ")", "]", ")", "\n", "\n", "losses", "=", "self", ".", "head", "(", "l_pos", ",", "l_neg", ")", "\n", "self", ".", "_dequeue_and_enqueue", "(", "k", ")", "\n", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.MOCO.forward_test": [[260, 262], ["None"], "methods", ["None"], ["", "def", "forward_test", "(", "self", ",", "img", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.MOCO.forward": [[263, 272], ["moco.MOCO.forward_train", "moco.MOCO.forward_test", "moco.MOCO.backbone", "Exception"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_test"], ["", "def", "forward", "(", "self", ",", "img", ",", "mode", "=", "'train'", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "mode", "==", "'train'", ":", "\n", "            ", "return", "self", ".", "forward_train", "(", "img", ",", "**", "kwargs", ")", "\n", "", "elif", "mode", "==", "'test'", ":", "\n", "            ", "return", "self", ".", "forward_test", "(", "img", ",", "**", "kwargs", ")", "\n", "", "elif", "mode", "==", "'extract'", ":", "\n", "            ", "return", "self", ".", "backbone", "(", "img", ")", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\"No such mode: {}\"", ".", "format", "(", "mode", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.moco.concat_all_gather": [[275, 289], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.distributed.all_gather", "torch.distributed.all_gather", "torch.distributed.all_gather", "torch.cat", "torch.cat", "torch.cat", "torch.ones_like", "torch.ones_like", "torch.ones_like", "range", "torch.distributed.get_world_size", "torch.distributed.get_world_size", "torch.distributed.get_world_size"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size"], ["", "", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "concat_all_gather", "(", "tensor", ")", ":", "\n", "    ", "\"\"\"Performs all_gather operation on the provided tensors.\n\n    *** Warning ***: torch.distributed.all_gather has no gradient.\n    \"\"\"", "\n", "tensors_gather", "=", "[", "\n", "torch", ".", "ones_like", "(", "tensor", ")", "\n", "for", "_", "in", "range", "(", "torch", ".", "distributed", ".", "get_world_size", "(", ")", ")", "\n", "]", "\n", "torch", ".", "distributed", ".", "all_gather", "(", "tensors_gather", ",", "tensor", ",", "async_op", "=", "False", ")", "\n", "\n", "output", "=", "torch", ".", "cat", "(", "tensors_gather", ",", "dim", "=", "0", ")", "\n", "return", "output", "\n", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BaseModel.__init__": [[15, 18], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["    ", "\"\"\"Dataset for BYOL.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "data_source", ",", "pipeline1", ",", "pipeline2", ",", "prefetch", "=", "False", ")", ":", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BaseModel.set_debug": [[19, 21], ["None"], "methods", ["None"], ["        ", "self", ".", "data_source", "=", "build_datasource", "(", "data_source", ")", "\n", "pipeline1", "=", "[", "build_from_cfg", "(", "p", ",", "PIPELINES", ")", "for", "p", "in", "pipeline1", "]", "\n", "self", ".", "pipeline1", "=", "Compose", "(", "pipeline1", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BaseModel.train_step": [[22, 28], ["byol.BaseModel.", "byol.BaseModel._parse_losses", "dict", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BaseModel._parse_losses"], ["pipeline2", "=", "[", "build_from_cfg", "(", "p", ",", "PIPELINES", ")", "for", "p", "in", "pipeline2", "]", "\n", "self", ".", "pipeline2", "=", "Compose", "(", "pipeline2", ")", "\n", "self", ".", "prefetch", "=", "prefetch", "\n", "\n", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "data_source", ".", "get_length", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BaseModel.eval_step": [[29, 35], ["byol.BaseModel.", "byol.BaseModel._parse_losses", "dict", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BaseModel._parse_losses"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "img", "=", "self", ".", "data_source", ".", "get_sample", "(", "idx", ")", "\n", "img1", "=", "self", ".", "pipeline1", "(", "img", ")", "\n", "img2", "=", "self", ".", "pipeline2", "(", "img", ")", "\n", "if", "self", ".", "prefetch", ":", "\n", "            ", "img1", "=", "torch", ".", "from_numpy", "(", "to_numpy", "(", "img1", ")", ")", "\n", "img2", "=", "torch", ".", "from_numpy", "(", "to_numpy", "(", "img2", ")", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BaseModel.val": [[36, 42], ["byol.BaseModel.", "byol.BaseModel._parse_losses", "dict", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BaseModel._parse_losses"], ["\n", "", "img_cat", "=", "torch", ".", "cat", "(", "(", "img1", ".", "unsqueeze", "(", "0", ")", ",", "img2", ".", "unsqueeze", "(", "0", ")", ")", ",", "dim", "=", "0", ")", "\n", "return", "dict", "(", "img", "=", "img_cat", ")", "\n", "\n", "", "def", "evaluate", "(", "self", ",", "scores", ",", "keyword", ",", "logger", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "raise", "NotImplemented", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BaseModel._parse_losses": [[43, 75], ["collections.OrderedDict", "losses.items", "sum", "collections.OrderedDict.items", "isinstance", "loss_value.data.clone.data.clone.item", "loss_value.data.clone.data.clone.mean", "isinstance", "torch.is_available", "torch.is_available", "torch.is_available", "torch.is_initialized", "torch.is_initialized", "torch.is_initialized", "loss_value.data.clone.data.clone.data.clone", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "sum", "TypeError", "collections.OrderedDict.items", "loss_value.data.clone.data.clone.div_", "torch.get_world_size", "torch.get_world_size", "torch.get_world_size", "_loss.mean"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.get_world_size"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BYOL.__init__": [[94, 114], ["byol.BaseModel.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "byol.BYOL.target_net.parameters", "builder.build_head", "byol.BYOL.init_weights", "builder.build_backbone", "builder.build_neck", "builder.build_backbone", "builder.build_neck"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_head", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_neck", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_neck"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BYOL.init_weights": [[115, 131], ["byol.BYOL.online_net[].init_weights", "byol.BYOL.online_net[].init_weights", "zip", "byol.BYOL.head.init_weights", "byol.BYOL.utils.print_log", "byol.BYOL.online_net.parameters", "byol.BYOL.target_net.parameters", "param_tgt.data.copy_"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.print_log"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BYOL._momentum_update": [[132, 139], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "zip", "byol.BYOL.online_net.parameters", "byol.BYOL.target_net.parameters"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BYOL.momentum_update": [[140, 143], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "byol.BYOL._momentum_update"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BYOL._momentum_update"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BYOL.forward_train": [[144, 168], ["img[].contiguous", "img[].contiguous", "dict", "img.dim", "img.dim", "byol.BYOL.online_net", "byol.BYOL.online_net", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "[].clone().detach", "[].clone().detach", "byol.BYOL.head", "byol.BYOL.head", "[].clone", "[].clone", "byol.BYOL.target_net", "byol.BYOL.target_net"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BYOL.forward_test": [[169, 171], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BYOL.forward": [[172, 181], ["byol.BYOL.forward_train", "byol.BYOL.forward_test", "byol.BYOL.backbone", "Exception"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_test"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.__init__": [[25, 33], ["torch.Module.__init__", "builder.build_backbone", "relative_loc.RelativeLoc.init_weights", "builder.build_neck", "builder.build_head"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_neck", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_head"], ["w_grid", "=", "w", "//", "split_per_side", "\n", "h_patch", "=", "h_grid", "-", "patch_jitter", "\n", "w_patch", "=", "w_grid", "-", "patch_jitter", "\n", "assert", "h_patch", ">", "0", "and", "w_patch", ">", "0", "\n", "patches", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "split_per_side", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "split_per_side", ")", ":", "\n", "            ", "p", "=", "TF", ".", "crop", "(", "img", ",", "i", "*", "h_grid", ",", "j", "*", "w_grid", ",", "h_grid", ",", "w_grid", ")", "\n", "p", "=", "RandomCrop", "(", "(", "h_patch", ",", "w_patch", ")", ")", "(", "p", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.init_weights": [[34, 46], ["relative_loc.RelativeLoc.backbone.init_weights", "relative_loc.RelativeLoc.neck.init_weights", "relative_loc.RelativeLoc.head.init_weights", "relative_loc.RelativeLoc.utils.print_log"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.print_log"], ["patches", ".", "append", "(", "p", ")", "\n", "", "", "return", "patches", "\n", "\n", "\n", "", "@", "DATASETS", ".", "register_module", "\n", "class", "RelativeLocDataset", "(", "BaseDataset", ")", ":", "\n", "    ", "\"\"\"Dataset for relative patch location.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "data_source", ",", "pipeline", ",", "format_pipeline", ")", ":", "\n", "        ", "super", "(", "RelativeLocDataset", ",", "self", ")", ".", "__init__", "(", "data_source", ",", "pipeline", ")", "\n", "format_pipeline", "=", "[", "build_from_cfg", "(", "p", ",", "PIPELINES", ")", "for", "p", "in", "format_pipeline", "]", "\n", "self", ".", "format_pipeline", "=", "Compose", "(", "format_pipeline", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone": [[47, 59], ["relative_loc.RelativeLoc.backbone"], "methods", ["None"], ["\n", "", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "img", "=", "self", ".", "data_source", ".", "get_sample", "(", "idx", ")", "\n", "assert", "isinstance", "(", "img", ",", "Image", ".", "Image", ")", ",", "'The output from the data source must be an Image, got: {}. \\\n            Please ensure that the list file does not contain labels.'", ".", "format", "(", "\n", "type", "(", "img", ")", ")", "\n", "img", "=", "self", ".", "pipeline", "(", "img", ")", "\n", "patches", "=", "image_to_patches", "(", "img", ")", "\n", "patches", "=", "[", "self", ".", "format_pipeline", "(", "p", ")", "for", "p", "in", "patches", "]", "\n", "perms", "=", "[", "]", "\n", "# create a list of patch pairs", "\n", "[", "perms", ".", "append", "(", "torch", ".", "cat", "(", "(", "patches", "[", "i", "]", ",", "patches", "[", "4", "]", ")", ",", "dim", "=", "0", ")", ")", "for", "i", "in", "range", "(", "9", ")", "if", "i", "!=", "4", "]", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_train": [[60, 81], ["torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "relative_loc.RelativeLoc.forward_backbone", "relative_loc.RelativeLoc.forward_backbone", "relative_loc.RelativeLoc.neck", "relative_loc.RelativeLoc.head", "relative_loc.RelativeLoc.head.loss", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.multi_cls_head.MultiClsHead.loss", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], ["# create corresponding labels for patch pairs", "\n", "patch_labels", "=", "torch", ".", "LongTensor", "(", "[", "0", ",", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", "]", ")", "\n", "return", "dict", "(", "img", "=", "torch", ".", "stack", "(", "perms", ")", ",", "patch_label", "=", "patch_labels", ")", "# 8(2C)HW, 8", "\n", "\n", "", "def", "evaluate", "(", "self", ",", "scores", ",", "keyword", ",", "logger", "=", "None", ")", ":", "\n", "        ", "raise", "NotImplemented", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_test": [[82, 92], ["torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "relative_loc.RelativeLoc.forward_backbone", "relative_loc.RelativeLoc.forward_backbone", "relative_loc.RelativeLoc.neck", "relative_loc.RelativeLoc.head", "dict", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "out.cpu", "zip", "range", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward": [[93, 108], ["img.view.view.view", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "relative_loc.RelativeLoc.forward_train", "img.view.view.dim", "torch.flatten.dim", "torch.flatten.dim", "img.view.view.size", "img.view.view.size", "img.view.view.size", "relative_loc.RelativeLoc.forward_test", "img.view.view.size", "img.view.view.size", "relative_loc.RelativeLoc.forward_backbone", "Exception"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_test", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.relative_loc.RelativeLoc.forward_backbone"], []], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.LinearNeck.__init__": [[32, 38], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "with_avg_pool", "=", "True", ")", ":", "\n", "        ", "super", "(", "LinearNeck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "with_avg_pool", "=", "with_avg_pool", "\n", "if", "with_avg_pool", ":", "\n", "            ", "self", ".", "avgpool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "(", "1", ",", "1", ")", ")", "\n", "", "self", ".", "fc", "=", "nn", ".", "Linear", "(", "in_channels", ",", "out_channels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.LinearNeck.init_weights": [[39, 41], ["necks._init_weights"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks._init_weights"], ["", "def", "init_weights", "(", "self", ",", "init_linear", "=", "'normal'", ")", ":", "\n", "        ", "_init_weights", "(", "self", ",", "init_linear", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.LinearNeck.forward": [[42, 48], ["len", "necks.LinearNeck.avgpool", "necks.LinearNeck.fc", "necks.LinearNeck.view", "necks.LinearNeck.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "len", "(", "x", ")", "==", "1", "\n", "x", "=", "x", "[", "0", "]", "\n", "if", "self", ".", "with_avg_pool", ":", "\n", "            ", "x", "=", "self", ".", "avgpool", "(", "x", ")", "\n", "", "return", "[", "self", ".", "fc", "(", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.RelativeLocNeck.__init__": [[55, 81], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.Dropout", "torch.Dropout", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "packaging.version.parse", "packaging.version.parse", "utils.build_norm_layer", "torch.BatchNorm1d", "torch.BatchNorm1d", "dict"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.norm.build_norm_layer"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "sync_bn", "=", "False", ",", "\n", "with_avg_pool", "=", "True", ")", ":", "\n", "        ", "super", "(", "RelativeLocNeck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "with_avg_pool", "=", "with_avg_pool", "\n", "if", "with_avg_pool", ":", "\n", "            ", "self", ".", "avgpool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "(", "1", ",", "1", ")", ")", "\n", "\n", "", "if", "version", ".", "parse", "(", "torch", ".", "__version__", ")", "<", "version", ".", "parse", "(", "\"1.4.0\"", ")", ":", "\n", "            ", "self", ".", "expand_for_syncbn", "=", "True", "\n", "", "else", ":", "\n", "            ", "self", ".", "expand_for_syncbn", "=", "False", "\n", "\n", "", "self", ".", "fc", "=", "nn", ".", "Linear", "(", "in_channels", "*", "2", ",", "out_channels", ")", "\n", "if", "sync_bn", ":", "\n", "            ", "_", ",", "self", ".", "bn", "=", "build_norm_layer", "(", "\n", "dict", "(", "type", "=", "'SyncBN'", ",", "momentum", "=", "0.003", ")", ",", "\n", "out_channels", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "bn", "=", "nn", ".", "BatchNorm1d", "(", "\n", "out_channels", ",", "momentum", "=", "0.003", ")", "\n", "", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "drop", "=", "nn", ".", "Dropout", "(", ")", "\n", "self", ".", "sync_bn", "=", "sync_bn", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.RelativeLocNeck.init_weights": [[82, 84], ["necks._init_weights"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks._init_weights"], ["", "def", "init_weights", "(", "self", ",", "init_linear", "=", "'normal'", ")", ":", "\n", "        ", "_init_weights", "(", "self", ",", "init_linear", ",", "std", "=", "0.005", ",", "bias", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.RelativeLocNeck._forward_syncbn": [[85, 92], ["module.dim", "module().squeeze().squeeze", "module", "module().squeeze", "module", "module.unsqueeze().unsqueeze", "module.unsqueeze"], "methods", ["None"], ["", "def", "_forward_syncbn", "(", "self", ",", "module", ",", "x", ")", ":", "\n", "        ", "assert", "x", ".", "dim", "(", ")", "==", "2", "\n", "if", "self", ".", "expand_for_syncbn", ":", "\n", "            ", "x", "=", "module", "(", "x", ".", "unsqueeze", "(", "-", "1", ")", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "squeeze", "(", "-", "1", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "module", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.RelativeLocNeck.forward": [[93, 107], ["necks.RelativeLocNeck.view", "necks.RelativeLocNeck.fc", "necks.RelativeLocNeck.relu", "necks.RelativeLocNeck.drop", "len", "necks.RelativeLocNeck.avgpool", "necks.RelativeLocNeck.size", "necks.RelativeLocNeck._forward_syncbn", "necks.RelativeLocNeck.bn"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.NonLinearNeckSimCLR._forward_syncbn"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "len", "(", "x", ")", "==", "1", "\n", "x", "=", "x", "[", "0", "]", "\n", "if", "self", ".", "with_avg_pool", ":", "\n", "            ", "x", "=", "self", ".", "avgpool", "(", "x", ")", "\n", "", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "x", "=", "self", ".", "fc", "(", "x", ")", "\n", "if", "self", ".", "sync_bn", ":", "\n", "            ", "x", "=", "self", ".", "_forward_syncbn", "(", "self", ".", "bn", ",", "x", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "self", ".", "bn", "(", "x", ")", "\n", "", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "drop", "(", "x", ")", "\n", "return", "[", "x", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.NonLinearNeckV0.__init__": [[114, 143], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.Dropout", "torch.Dropout", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "packaging.version.parse", "packaging.version.parse", "utils.build_norm_layer", "torch.BatchNorm1d", "torch.BatchNorm1d", "dict"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.norm.build_norm_layer"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "hid_channels", ",", "\n", "out_channels", ",", "\n", "sync_bn", "=", "False", ",", "\n", "with_avg_pool", "=", "True", ")", ":", "\n", "        ", "super", "(", "NonLinearNeckV0", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "with_avg_pool", "=", "with_avg_pool", "\n", "if", "with_avg_pool", ":", "\n", "            ", "self", ".", "avgpool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "(", "1", ",", "1", ")", ")", "\n", "\n", "", "if", "version", ".", "parse", "(", "torch", ".", "__version__", ")", "<", "version", ".", "parse", "(", "\"1.4.0\"", ")", ":", "\n", "            ", "self", ".", "expand_for_syncbn", "=", "True", "\n", "", "else", ":", "\n", "            ", "self", ".", "expand_for_syncbn", "=", "False", "\n", "\n", "", "self", ".", "fc0", "=", "nn", ".", "Linear", "(", "in_channels", ",", "hid_channels", ")", "\n", "if", "sync_bn", ":", "\n", "            ", "_", ",", "self", ".", "bn0", "=", "build_norm_layer", "(", "\n", "dict", "(", "type", "=", "'SyncBN'", ",", "momentum", "=", "0.001", ",", "affine", "=", "False", ")", ",", "\n", "hid_channels", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "bn0", "=", "nn", ".", "BatchNorm1d", "(", "\n", "hid_channels", ",", "momentum", "=", "0.001", ",", "affine", "=", "False", ")", "\n", "\n", "", "self", ".", "fc1", "=", "nn", ".", "Linear", "(", "hid_channels", ",", "out_channels", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "drop", "=", "nn", ".", "Dropout", "(", ")", "\n", "self", ".", "sync_bn", "=", "sync_bn", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.NonLinearNeckV0.init_weights": [[144, 146], ["necks._init_weights"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks._init_weights"], ["", "def", "init_weights", "(", "self", ",", "init_linear", "=", "'normal'", ")", ":", "\n", "        ", "_init_weights", "(", "self", ",", "init_linear", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.NonLinearNeckV0._forward_syncbn": [[147, 154], ["module.dim", "module().squeeze().squeeze", "module", "module().squeeze", "module", "module.unsqueeze().unsqueeze", "module.unsqueeze"], "methods", ["None"], ["", "def", "_forward_syncbn", "(", "self", ",", "module", ",", "x", ")", ":", "\n", "        ", "assert", "x", ".", "dim", "(", ")", "==", "2", "\n", "if", "self", ".", "expand_for_syncbn", ":", "\n", "            ", "x", "=", "module", "(", "x", ".", "unsqueeze", "(", "-", "1", ")", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "squeeze", "(", "-", "1", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "module", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.NonLinearNeckV0.forward": [[155, 171], ["necks.NonLinearNeckV0.view", "necks.NonLinearNeckV0.fc0", "necks.NonLinearNeckV0.relu", "necks.NonLinearNeckV0.drop", "necks.NonLinearNeckV0.fc1", "necks.NonLinearNeckV0.relu", "len", "necks.NonLinearNeckV0.avgpool", "necks.NonLinearNeckV0.size", "necks.NonLinearNeckV0._forward_syncbn", "necks.NonLinearNeckV0.bn0"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.NonLinearNeckSimCLR._forward_syncbn"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "len", "(", "x", ")", "==", "1", "\n", "x", "=", "x", "[", "0", "]", "\n", "if", "self", ".", "with_avg_pool", ":", "\n", "            ", "x", "=", "self", ".", "avgpool", "(", "x", ")", "\n", "", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "x", "=", "self", ".", "fc0", "(", "x", ")", "\n", "if", "self", ".", "sync_bn", ":", "\n", "            ", "x", "=", "self", ".", "_forward_syncbn", "(", "self", ".", "bn0", ",", "x", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "self", ".", "bn0", "(", "x", ")", "\n", "", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "drop", "(", "x", ")", "\n", "x", "=", "self", ".", "fc1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "return", "[", "x", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.NonLinearNeckV1.__init__": [[178, 190], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "hid_channels", ",", "\n", "out_channels", ",", "\n", "with_avg_pool", "=", "True", ")", ":", "\n", "        ", "super", "(", "NonLinearNeckV1", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "with_avg_pool", "=", "with_avg_pool", "\n", "if", "with_avg_pool", ":", "\n", "            ", "self", ".", "avgpool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "(", "1", ",", "1", ")", ")", "\n", "", "self", ".", "mlp", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "in_channels", ",", "hid_channels", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Linear", "(", "hid_channels", ",", "out_channels", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.NonLinearNeckV1.init_weights": [[191, 193], ["necks._init_weights"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks._init_weights"], ["", "def", "init_weights", "(", "self", ",", "init_linear", "=", "'normal'", ")", ":", "\n", "        ", "_init_weights", "(", "self", ",", "init_linear", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.NonLinearNeckV1.forward": [[194, 200], ["len", "necks.NonLinearNeckV1.avgpool", "necks.NonLinearNeckV1.mlp", "necks.NonLinearNeckV1.view", "necks.NonLinearNeckV1.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "len", "(", "x", ")", "==", "1", "\n", "x", "=", "x", "[", "0", "]", "\n", "if", "self", ".", "with_avg_pool", ":", "\n", "            ", "x", "=", "self", ".", "avgpool", "(", "x", ")", "\n", "", "return", "[", "self", ".", "mlp", "(", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.NonLinearNeckV2.__init__": [[207, 221], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.Linear", "torch.Linear", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "hid_channels", ",", "\n", "out_channels", ",", "\n", "with_avg_pool", "=", "True", ")", ":", "\n", "        ", "super", "(", "NonLinearNeckV2", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "with_avg_pool", "=", "with_avg_pool", "\n", "if", "with_avg_pool", ":", "\n", "            ", "self", ".", "avgpool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "(", "1", ",", "1", ")", ")", "\n", "", "self", ".", "mlp", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "in_channels", ",", "hid_channels", ")", ",", "\n", "nn", ".", "BatchNorm1d", "(", "hid_channels", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Linear", "(", "hid_channels", ",", "out_channels", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.NonLinearNeckV2.init_weights": [[222, 224], ["necks._init_weights"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks._init_weights"], ["", "def", "init_weights", "(", "self", ",", "init_linear", "=", "'normal'", ")", ":", "\n", "        ", "_init_weights", "(", "self", ",", "init_linear", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.NonLinearNeckV2.forward": [[225, 231], ["len", "len", "necks.NonLinearNeckV2.avgpool", "necks.NonLinearNeckV2.mlp", "necks.NonLinearNeckV2.view", "necks.NonLinearNeckV2.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "len", "(", "x", ")", "==", "1", ",", "\"Got: {}\"", ".", "format", "(", "len", "(", "x", ")", ")", "\n", "x", "=", "x", "[", "0", "]", "\n", "if", "self", ".", "with_avg_pool", ":", "\n", "            ", "x", "=", "self", ".", "avgpool", "(", "x", ")", "\n", "", "return", "[", "self", ".", "mlp", "(", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.NonLinearNeckSimCLR.__init__": [[253, 303], ["torch.Module.__init__", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "range", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "packaging.version.parse", "packaging.version.parse", "utils.build_norm_layer", "torch.BatchNorm1d", "torch.BatchNorm1d", "necks.NonLinearNeckSimCLR.add_module", "necks.NonLinearNeckSimCLR.fc_names.append", "dict", "torch.Linear", "torch.Linear", "necks.NonLinearNeckSimCLR.bn_names.append", "necks.NonLinearNeckSimCLR.bn_names.append", "necks.NonLinearNeckSimCLR.add_module", "necks.NonLinearNeckSimCLR.add_module", "torch.BatchNorm1d", "torch.BatchNorm1d", "utils.build_norm_layer", "dict"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.norm.build_norm_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.norm.build_norm_layer"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "hid_channels", ",", "\n", "out_channels", ",", "\n", "num_layers", "=", "2", ",", "\n", "sync_bn", "=", "True", ",", "\n", "with_bias", "=", "False", ",", "\n", "with_last_bn", "=", "True", ",", "\n", "with_avg_pool", "=", "True", ")", ":", "\n", "        ", "super", "(", "NonLinearNeckSimCLR", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "sync_bn", "=", "sync_bn", "\n", "self", ".", "with_last_bn", "=", "with_last_bn", "\n", "self", ".", "with_avg_pool", "=", "with_avg_pool", "\n", "if", "with_avg_pool", ":", "\n", "            ", "self", ".", "avgpool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "(", "1", ",", "1", ")", ")", "\n", "\n", "", "if", "version", ".", "parse", "(", "torch", ".", "__version__", ")", "<", "version", ".", "parse", "(", "\"1.4.0\"", ")", ":", "\n", "            ", "self", ".", "expand_for_syncbn", "=", "True", "\n", "", "else", ":", "\n", "            ", "self", ".", "expand_for_syncbn", "=", "False", "\n", "\n", "", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "fc0", "=", "nn", ".", "Linear", "(", "in_channels", ",", "hid_channels", ",", "bias", "=", "with_bias", ")", "\n", "if", "sync_bn", ":", "\n", "            ", "_", ",", "self", ".", "bn0", "=", "build_norm_layer", "(", "\n", "dict", "(", "type", "=", "'SyncBN'", ")", ",", "hid_channels", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "bn0", "=", "nn", ".", "BatchNorm1d", "(", "hid_channels", ")", "\n", "\n", "", "self", ".", "fc_names", "=", "[", "]", "\n", "self", ".", "bn_names", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "num_layers", ")", ":", "\n", "            ", "this_channels", "=", "out_channels", "if", "i", "==", "num_layers", "-", "1", "else", "hid_channels", "\n", "self", ".", "add_module", "(", "\n", "\"fc{}\"", ".", "format", "(", "i", ")", ",", "\n", "nn", ".", "Linear", "(", "hid_channels", ",", "this_channels", ",", "bias", "=", "with_bias", ")", ")", "\n", "self", ".", "fc_names", ".", "append", "(", "\"fc{}\"", ".", "format", "(", "i", ")", ")", "\n", "if", "i", "!=", "num_layers", "-", "1", "or", "self", ".", "with_last_bn", ":", "\n", "                ", "if", "sync_bn", ":", "\n", "                    ", "self", ".", "add_module", "(", "\n", "\"bn{}\"", ".", "format", "(", "i", ")", ",", "\n", "build_norm_layer", "(", "dict", "(", "type", "=", "'SyncBN'", ")", ",", "this_channels", ")", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "add_module", "(", "\n", "\"bn{}\"", ".", "format", "(", "i", ")", ",", "\n", "nn", ".", "BatchNorm1d", "(", "this_channels", ")", ")", "\n", "", "self", ".", "bn_names", ".", "append", "(", "\"bn{}\"", ".", "format", "(", "i", ")", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "bn_names", ".", "append", "(", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.NonLinearNeckSimCLR.init_weights": [[304, 306], ["necks._init_weights"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks._init_weights"], ["", "", "", "def", "init_weights", "(", "self", ",", "init_linear", "=", "'normal'", ")", ":", "\n", "        ", "_init_weights", "(", "self", ",", "init_linear", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.NonLinearNeckSimCLR._forward_syncbn": [[307, 314], ["module.dim", "module().squeeze().squeeze", "module", "module().squeeze", "module", "module.unsqueeze().unsqueeze", "module.unsqueeze"], "methods", ["None"], ["", "def", "_forward_syncbn", "(", "self", ",", "module", ",", "x", ")", ":", "\n", "        ", "assert", "x", ".", "dim", "(", ")", "==", "2", "\n", "if", "self", ".", "expand_for_syncbn", ":", "\n", "            ", "x", "=", "module", "(", "x", ".", "unsqueeze", "(", "-", "1", ")", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "squeeze", "(", "-", "1", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "module", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.NonLinearNeckSimCLR.forward": [[315, 337], ["getattr.view", "necks.NonLinearNeckSimCLR.fc0", "zip", "len", "necks.NonLinearNeckSimCLR.avgpool", "getattr.size", "necks.NonLinearNeckSimCLR._forward_syncbn", "necks.NonLinearNeckSimCLR.bn0", "getattr", "necks.NonLinearNeckSimCLR.relu", "getattr.", "getattr", "necks.NonLinearNeckSimCLR._forward_syncbn", "getattr."], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.NonLinearNeckSimCLR._forward_syncbn", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.NonLinearNeckSimCLR._forward_syncbn"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "len", "(", "x", ")", "==", "1", "\n", "x", "=", "x", "[", "0", "]", "\n", "if", "self", ".", "with_avg_pool", ":", "\n", "            ", "x", "=", "self", ".", "avgpool", "(", "x", ")", "\n", "", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "x", "=", "self", ".", "fc0", "(", "x", ")", "\n", "if", "self", ".", "sync_bn", ":", "\n", "            ", "x", "=", "self", ".", "_forward_syncbn", "(", "self", ".", "bn0", ",", "x", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "self", ".", "bn0", "(", "x", ")", "\n", "", "for", "fc_name", ",", "bn_name", "in", "zip", "(", "self", ".", "fc_names", ",", "self", ".", "bn_names", ")", ":", "\n", "            ", "fc", "=", "getattr", "(", "self", ",", "fc_name", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "fc", "(", "x", ")", "\n", "if", "bn_name", "is", "not", "None", ":", "\n", "                ", "bn", "=", "getattr", "(", "self", ",", "bn_name", ")", "\n", "if", "self", ".", "sync_bn", ":", "\n", "                    ", "x", "=", "self", ".", "_forward_syncbn", "(", "bn", ",", "x", ")", "\n", "", "else", ":", "\n", "                    ", "x", "=", "bn", "(", "x", ")", "\n", "", "", "", "return", "[", "x", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.AvgPoolNeck.__init__": [[344, 347], ["torch.Module.__init__", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "AvgPoolNeck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "avg_pool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "(", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.AvgPoolNeck.init_weights": [[348, 350], ["None"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks.AvgPoolNeck.forward": [[351, 354], ["len", "necks.AvgPoolNeck.avg_pool"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "len", "(", "x", ")", "==", "1", "\n", "return", "[", "self", ".", "avg_pool", "(", "x", "[", "0", "]", ")", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.necks._init_weights": [[10, 25], ["module.modules", "isinstance", "isinstance", "mmcv.cnn.normal_init", "mmcv.cnn.kaiming_init", "torch.init.constant_", "torch.init.constant_"], "function", ["None"], ["def", "_init_weights", "(", "module", ",", "init_linear", "=", "'normal'", ",", "std", "=", "0.01", ",", "bias", "=", "0.", ")", ":", "\n", "    ", "assert", "init_linear", "in", "[", "'normal'", ",", "'kaiming'", "]", ",", "\"Undefined init_linear: {}\"", ".", "format", "(", "init_linear", ")", "\n", "for", "m", "in", "module", ".", "modules", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "            ", "if", "init_linear", "==", "'normal'", ":", "\n", "                ", "normal_init", "(", "m", ",", "std", "=", "std", ",", "bias", "=", "bias", ")", "\n", "", "else", ":", "\n", "                ", "kaiming_init", "(", "m", ",", "mode", "=", "'fan_in'", ",", "nonlinearity", "=", "'relu'", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "(", "nn", ".", "BatchNorm1d", ",", "nn", ".", "BatchNorm2d", ",", "\n", "nn", ".", "GroupNorm", ",", "nn", ".", "SyncBatchNorm", ")", ")", ":", "\n", "            ", "if", "m", ".", "weight", "is", "not", "None", ":", "\n", "                ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "weight", ",", "1", ")", "\n", "", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.cls_head.ClsHead.__init__": [[13, 32], ["torch.Module.__init__", "torch.Linear", "torch.BCEWithLogitsLoss", "torch.CrossEntropyLoss", "torch.AdaptiveAvgPool2d"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "\n", "with_avg_pool", "=", "False", ",", "\n", "in_channels", "=", "2048", ",", "\n", "num_classes", "=", "1000", ",", "\n", "use_bce_loss", "=", "False", ")", ":", "\n", "        ", "super", "(", "ClsHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "with_avg_pool", "=", "with_avg_pool", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "use_bce_loss", "=", "use_bce_loss", "\n", "\n", "if", "self", ".", "use_bce_loss", ":", "\n", "            ", "self", ".", "criterion", "=", "nn", ".", "BCEWithLogitsLoss", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "criterion", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "", "if", "self", ".", "with_avg_pool", ":", "\n", "            ", "self", ".", "avg_pool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "(", "1", ",", "1", ")", ")", "\n", "", "self", ".", "fc_cls", "=", "nn", ".", "Linear", "(", "in_channels", ",", "num_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.cls_head.ClsHead.init_weights": [[33, 48], ["cls_head.ClsHead.modules", "isinstance", "isinstance", "mmcv.cnn.normal_init", "mmcv.cnn.kaiming_init", "torch.init.constant_", "torch.init.constant_"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ",", "init_linear", "=", "'normal'", ",", "std", "=", "0.01", ",", "bias", "=", "0.", ")", ":", "\n", "        ", "assert", "init_linear", "in", "[", "'normal'", ",", "'kaiming'", "]", ",", "\"Undefined init_linear: {}\"", ".", "format", "(", "init_linear", ")", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                ", "if", "init_linear", "==", "'normal'", ":", "\n", "                    ", "normal_init", "(", "m", ",", "std", "=", "std", ",", "bias", "=", "bias", ")", "\n", "", "else", ":", "\n", "                    ", "kaiming_init", "(", "m", ",", "mode", "=", "'fan_in'", ",", "nonlinearity", "=", "'relu'", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "\n", "(", "nn", ".", "BatchNorm2d", ",", "nn", ".", "GroupNorm", ",", "nn", ".", "SyncBatchNorm", ")", ")", ":", "\n", "                ", "if", "m", ".", "weight", "is", "not", "None", ":", "\n", "                    ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "weight", ",", "1", ")", "\n", "", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.cls_head.ClsHead.forward": [[49, 59], ["cls_head.ClsHead.view", "cls_head.ClsHead.fc_cls", "isinstance", "cls_head.ClsHead.avg_pool", "cls_head.ClsHead.size", "len", "cls_head.ClsHead.dim", "cls_head.ClsHead.dim"], "methods", ["None"], ["", "", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "isinstance", "(", "x", ",", "(", "tuple", ",", "list", ")", ")", "and", "len", "(", "x", ")", "==", "1", "\n", "x", "=", "x", "[", "0", "]", "\n", "if", "self", ".", "with_avg_pool", ":", "\n", "            ", "assert", "x", ".", "dim", "(", ")", "==", "4", ",", "\"Tensor must has 4 dims, got: {}\"", ".", "format", "(", "x", ".", "dim", "(", ")", ")", "\n", "x", "=", "self", ".", "avg_pool", "(", "x", ")", "\n", "", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "cls_score", "=", "self", ".", "fc_cls", "(", "x", ")", "\n", "return", "[", "cls_score", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.cls_head.ClsHead.loss": [[60, 69], ["dict", "cls_head.ClsHead.criterion", "isinstance", "utils.auroc", "utils.accuracy", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.accuracy.auroc", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.eval.accuracy"], ["", "def", "loss", "(", "self", ",", "cls_score", ",", "labels", ")", ":", "\n", "        ", "losses", "=", "dict", "(", ")", "\n", "assert", "isinstance", "(", "cls_score", ",", "(", "tuple", ",", "list", ")", ")", "and", "len", "(", "cls_score", ")", "==", "1", "\n", "losses", "[", "'loss'", "]", "=", "self", ".", "criterion", "(", "cls_score", "[", "0", "]", ",", "labels", ")", "\n", "if", "self", ".", "use_bce_loss", ":", "\n", "            ", "losses", "[", "'auroc'", "]", "=", "auroc", "(", "cls_score", "[", "0", "]", ",", "labels", ")", "\n", "", "else", ":", "\n", "            ", "losses", "[", "'acc'", "]", "=", "accuracy", "(", "cls_score", "[", "0", "]", ",", "labels", ")", "\n", "", "return", "losses", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.multi_cls_head.MultiClsHead.__init__": [[16, 50], ["dict", "torch.Module.__init__", "utils.MultiPooling", "torch.ModuleList", "torch.BCELoss", "torch.CrossEntropyLoss", "torch.ModuleList", "multi_cls_head.MultiClsHead.fcs.append", "torch.Linear", "torch.Linear", "utils.build_norm_layer"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.norm.build_norm_layer"], ["def", "__init__", "(", "self", ",", "\n", "pool_type", "=", "'adaptive'", ",", "\n", "in_indices", "=", "(", "0", ",", ")", ",", "\n", "with_last_layer_unpool", "=", "False", ",", "\n", "backbone", "=", "'resnet50'", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "num_classes", "=", "1000", ",", "\n", "use_bce_loss", "=", "False", ")", ":", "\n", "        ", "super", "(", "MultiClsHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "norm_cfg", "[", "'type'", "]", "in", "[", "'BN'", ",", "'SyncBN'", ",", "'GN'", ",", "'null'", "]", "\n", "\n", "self", ".", "with_last_layer_unpool", "=", "with_last_layer_unpool", "\n", "self", ".", "with_norm", "=", "norm_cfg", "[", "'type'", "]", "!=", "'null'", "\n", "\n", "if", "use_bce_loss", ":", "\n", "            ", "self", ".", "criterion", "=", "nn", ".", "BCELoss", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "criterion", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "", "self", ".", "multi_pooling", "=", "MultiPooling", "(", "pool_type", ",", "in_indices", ",", "backbone", ")", "\n", "\n", "if", "self", ".", "with_norm", ":", "\n", "            ", "self", ".", "norms", "=", "nn", ".", "ModuleList", "(", "[", "\n", "build_norm_layer", "(", "norm_cfg", ",", "self", ".", "FEAT_CHANNELS", "[", "backbone", "]", "[", "l", "]", ")", "[", "1", "]", "\n", "for", "l", "in", "in_indices", "\n", "]", ")", "\n", "\n", "", "self", ".", "fcs", "=", "nn", ".", "ModuleList", "(", "[", "\n", "nn", ".", "Linear", "(", "self", ".", "multi_pooling", ".", "POOL_DIMS", "[", "backbone", "]", "[", "l", "]", ",", "num_classes", ")", "\n", "for", "l", "in", "in_indices", "\n", "]", ")", "\n", "if", "with_last_layer_unpool", ":", "\n", "            ", "self", ".", "fcs", ".", "append", "(", "\n", "nn", ".", "Linear", "(", "self", ".", "FEAT_LAST_UNPOOL", "[", "backbone", "]", ",", "num_classes", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.multi_cls_head.MultiClsHead.init_weights": [[51, 62], ["multi_cls_head.MultiClsHead.modules", "isinstance", "torch.init.normal_", "torch.init.constant_", "isinstance", "torch.init.constant_", "torch.init.constant_"], "methods", ["None"], ["", "", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                ", "nn", ".", "init", ".", "normal_", "(", "m", ".", "weight", ",", "0", ",", "0.01", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "\n", "(", "nn", ".", "BatchNorm2d", ",", "nn", ".", "GroupNorm", ",", "nn", ".", "SyncBatchNorm", ")", ")", ":", "\n", "                ", "if", "m", ".", "weight", "is", "not", "None", ":", "\n", "                    ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "weight", ",", "1", ")", "\n", "", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.multi_cls_head.MultiClsHead.forward": [[63, 75], ["isinstance", "multi_cls_head.MultiClsHead.multi_pooling", "multi_cls_head.MultiClsHead.append", "xx.view", "fc", "n", "xx.size", "zip", "zip"], "methods", ["None"], ["", "", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "isinstance", "(", "x", ",", "(", "list", ",", "tuple", ")", ")", "\n", "if", "self", ".", "with_last_layer_unpool", ":", "\n", "            ", "last_x", "=", "x", "[", "-", "1", "]", "\n", "", "x", "=", "self", ".", "multi_pooling", "(", "x", ")", "\n", "if", "self", ".", "with_norm", ":", "\n", "            ", "x", "=", "[", "n", "(", "xx", ")", "for", "n", ",", "xx", "in", "zip", "(", "self", ".", "norms", ",", "x", ")", "]", "\n", "", "if", "self", ".", "with_last_layer_unpool", ":", "\n", "            ", "x", ".", "append", "(", "last_x", ")", "\n", "", "x", "=", "[", "xx", ".", "view", "(", "xx", ".", "size", "(", "0", ")", ",", "-", "1", ")", "for", "xx", "in", "x", "]", "\n", "x", "=", "[", "fc", "(", "xx", ")", "for", "fc", ",", "xx", "in", "zip", "(", "self", ".", "fcs", ",", "x", ")", "]", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.multi_cls_head.MultiClsHead.loss": [[76, 83], ["dict", "enumerate", "multi_cls_head.MultiClsHead.criterion", "utils.accuracy"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.simclr-converter.eval.accuracy"], ["", "def", "loss", "(", "self", ",", "cls_score", ",", "labels", ")", ":", "\n", "        ", "losses", "=", "dict", "(", ")", "\n", "for", "i", ",", "s", "in", "enumerate", "(", "cls_score", ")", ":", "\n", "# keys must contain \"loss\"", "\n", "            ", "losses", "[", "'loss.{}'", ".", "format", "(", "i", "+", "1", ")", "]", "=", "self", ".", "criterion", "(", "s", ",", "labels", ")", "\n", "losses", "[", "'acc.{}'", ".", "format", "(", "i", "+", "1", ")", "]", "=", "accuracy", "(", "s", ",", "labels", ")", "\n", "", "return", "losses", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.latent_pred_head.LatentPredictHead.__init__": [[13, 17], ["torch.Module.__init__", "builder.build_neck"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.builder.build_neck"], ["def", "__init__", "(", "self", ",", "predictor", ",", "size_average", "=", "True", ")", ":", "\n", "        ", "super", "(", "LatentPredictHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "predictor", "=", "builder", ".", "build_neck", "(", "predictor", ")", "\n", "self", ".", "size_average", "=", "size_average", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.latent_pred_head.LatentPredictHead.init_weights": [[18, 20], ["latent_pred_head.LatentPredictHead.predictor.init_weights"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights"], ["", "def", "init_weights", "(", "self", ",", "init_linear", "=", "'normal'", ")", ":", "\n", "        ", "self", ".", "predictor", ".", "init_weights", "(", "init_linear", "=", "init_linear", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.latent_pred_head.LatentPredictHead.forward": [[21, 38], ["torch.functional.normalize", "torch.functional.normalize", "torch.functional.normalize", "torch.functional.normalize", "dict", "latent_pred_head.LatentPredictHead.predictor", "input.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "\"\"\"Forward head.\n\n        Args:\n            input (Tensor): NxC input features.\n            target (Tensor): NxC target features.\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "pred", "=", "self", ".", "predictor", "(", "[", "input", "]", ")", "[", "0", "]", "\n", "pred_norm", "=", "nn", ".", "functional", ".", "normalize", "(", "pred", ",", "dim", "=", "1", ")", "\n", "target_norm", "=", "nn", ".", "functional", ".", "normalize", "(", "target", ",", "dim", "=", "1", ")", "\n", "loss", "=", "-", "2", "*", "(", "pred_norm", "*", "target_norm", ")", ".", "sum", "(", ")", "\n", "if", "self", ".", "size_average", ":", "\n", "            ", "loss", "/=", "input", ".", "size", "(", "0", ")", "\n", "", "return", "dict", "(", "loss", "=", "loss", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.latent_pred_head.LatentClsHead.__init__": [[45, 50], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "predictor", ")", ":", "\n", "        ", "super", "(", "LatentClsHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "predictor", "=", "nn", ".", "Linear", "(", "predictor", ".", "in_channels", ",", "\n", "predictor", ".", "num_classes", ")", "\n", "self", ".", "criterion", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.latent_pred_head.LatentClsHead.init_weights": [[51, 53], ["mmcv.cnn.normal_init"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ",", "init_linear", "=", "'normal'", ")", ":", "\n", "        ", "normal_init", "(", "self", ".", "predictor", ",", "std", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.latent_pred_head.LatentClsHead.forward": [[54, 69], ["latent_pred_head.LatentClsHead.predictor", "latent_pred_head.LatentClsHead.criterion", "dict", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.argmax().detach", "torch.argmax().detach", "torch.argmax().detach", "torch.argmax().detach", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "latent_pred_head.LatentClsHead.predictor"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "\"\"\"Forward head.\n\n        Args:\n            input (Tensor): NxC input features.\n            target (Tensor): NxC target features.\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "pred", "=", "self", ".", "predictor", "(", "input", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "label", "=", "torch", ".", "argmax", "(", "self", ".", "predictor", "(", "target", ")", ",", "dim", "=", "1", ")", ".", "detach", "(", ")", "\n", "", "loss", "=", "self", ".", "criterion", "(", "pred", ",", "label", ")", "\n", "return", "dict", "(", "loss", "=", "loss", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.contrastive_head.ContrastiveHead.__init__": [[17, 21], ["torch.Module.__init__", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__"], ["def", "__init__", "(", "self", ",", "temperature", "=", "0.1", ")", ":", "\n", "        ", "super", "(", "ContrastiveHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "criterion", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "self", ".", "temperature", "=", "temperature", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.heads.contrastive_head.ContrastiveHead.forward": [[22, 39], ["pos.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "dict", "contrastive_head.ContrastiveHead.criterion", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda"], ["", "def", "forward", "(", "self", ",", "pos", ",", "neg", ")", ":", "\n", "        ", "\"\"\"Forward head.\n\n        Args:\n            pos (Tensor): Nx1 positive similarity.\n            neg (Tensor): Nxk negative similarity.\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "N", "=", "pos", ".", "size", "(", "0", ")", "\n", "logits", "=", "torch", ".", "cat", "(", "(", "pos", ",", "neg", ")", ",", "dim", "=", "1", ")", "\n", "logits", "/=", "self", ".", "temperature", "\n", "labels", "=", "torch", ".", "zeros", "(", "(", "N", ",", ")", ",", "dtype", "=", "torch", ".", "long", ")", ".", "cuda", "(", ")", "\n", "losses", "=", "dict", "(", ")", "\n", "losses", "[", "'loss'", "]", "=", "self", ".", "criterion", "(", "logits", ",", "labels", ")", "\n", "return", "losses", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.__init__": [[20, 28], ["torch.Module.__init__", "mmcv.runner.get_dist_info", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.randn().cuda", "torch.functional.normalize", "torch.functional.normalize", "torch.functional.normalize", "simple_memory.SimpleMemory.utils.AliasMethod", "simple_memory.SimpleMemory.multinomial.cuda", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda"], ["def", "__init__", "(", "self", ",", "length", ",", "feat_dim", ",", "momentum", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "SimpleMemory", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "rank", ",", "self", ".", "num_replicas", "=", "get_dist_info", "(", ")", "\n", "self", ".", "feature_bank", "=", "torch", ".", "randn", "(", "length", ",", "feat_dim", ")", ".", "cuda", "(", ")", "\n", "self", ".", "feature_bank", "=", "nn", ".", "functional", ".", "normalize", "(", "self", ".", "feature_bank", ")", "\n", "self", ".", "momentum", "=", "momentum", "\n", "self", ".", "multinomial", "=", "AliasMethod", "(", "torch", ".", "ones", "(", "length", ")", ")", "\n", "self", ".", "multinomial", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory.update": [[29, 43], ["torch.functional.normalize", "torch.functional.normalize", "torch.functional.normalize", "simple_memory.SimpleMemory._gather", "torch.functional.normalize", "torch.functional.normalize", "torch.functional.normalize"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory._gather"], ["", "def", "update", "(", "self", ",", "ind", ",", "feature", ")", ":", "\n", "        ", "\"\"\"Update features in memory bank.\n\n        Args:\n            ind (Tensor): Indices for the batch of features.\n            feature (Tensor): Batch of features.\n        \"\"\"", "\n", "feature_norm", "=", "nn", ".", "functional", ".", "normalize", "(", "feature", ")", "\n", "ind", ",", "feature_norm", "=", "self", ".", "_gather", "(", "ind", ",", "feature_norm", ")", "\n", "feature_old", "=", "self", ".", "feature_bank", "[", "ind", ",", "...", "]", "\n", "feature_new", "=", "(", "1", "-", "self", ".", "momentum", ")", "*", "feature_old", "+", "self", ".", "momentum", "*", "feature_norm", "\n", "feature_new_norm", "=", "nn", ".", "functional", ".", "normalize", "(", "feature_new", ")", "\n", "self", ".", "feature_bank", "[", "ind", ",", "...", "]", "=", "feature_new_norm", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.simple_memory.SimpleMemory._gather": [[44, 66], ["torch.all_gather", "torch.all_gather", "torch.all_gather", "torch.all_gather", "torch.all_gather", "torch.all_gather", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "range", "range", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda"], ["", "def", "_gather", "(", "self", ",", "ind", ",", "feature", ")", ":", "\n", "        ", "\"\"\"Gather indices and features.\n\n        Args:\n            ind (Tensor): Indices for the batch of features.\n            feature (Tensor): Batch of features.\n\n        Returns:\n            Tensor: Gathered indices.\n            Tensor: Gathered features.\n        \"\"\"", "\n", "ind_gathered", "=", "[", "\n", "torch", ".", "ones_like", "(", "ind", ")", ".", "cuda", "(", ")", "for", "_", "in", "range", "(", "self", ".", "num_replicas", ")", "\n", "]", "\n", "feature_gathered", "=", "[", "\n", "torch", ".", "ones_like", "(", "feature", ")", ".", "cuda", "(", ")", "for", "_", "in", "range", "(", "self", ".", "num_replicas", ")", "\n", "]", "\n", "dist", ".", "all_gather", "(", "ind_gathered", ",", "ind", ")", "\n", "dist", ".", "all_gather", "(", "feature_gathered", ",", "feature", ")", "\n", "ind_gathered", "=", "torch", ".", "cat", "(", "ind_gathered", ",", "dim", "=", "0", ")", "\n", "feature_gathered", "=", "torch", ".", "cat", "(", "feature_gathered", ",", "dim", "=", "0", ")", "\n", "return", "ind_gathered", ",", "feature_gathered", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory.__init__": [[24, 41], ["torch.Module.__init__", "mmcv.runner.get_dist_info", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "sklearn.cluster.KMeans", "kwargs.get", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["def", "__init__", "(", "self", ",", "length", ",", "feat_dim", ",", "momentum", ",", "num_classes", ",", "min_cluster", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "ODCMemory", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "rank", ",", "self", ".", "num_replicas", "=", "get_dist_info", "(", ")", "\n", "if", "self", ".", "rank", "==", "0", ":", "\n", "            ", "self", ".", "feature_bank", "=", "torch", ".", "zeros", "(", "(", "length", ",", "feat_dim", ")", ",", "\n", "dtype", "=", "torch", ".", "float32", ")", "\n", "", "self", ".", "label_bank", "=", "torch", ".", "zeros", "(", "(", "length", ",", ")", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "self", ".", "centroids", "=", "torch", ".", "zeros", "(", "(", "num_classes", ",", "feat_dim", ")", ",", "\n", "dtype", "=", "torch", ".", "float32", ")", ".", "cuda", "(", ")", "\n", "self", ".", "kmeans", "=", "KMeans", "(", "n_clusters", "=", "2", ",", "random_state", "=", "0", ",", "max_iter", "=", "20", ")", "\n", "self", ".", "feat_dim", "=", "feat_dim", "\n", "self", ".", "initialized", "=", "False", "\n", "self", ".", "momentum", "=", "momentum", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "min_cluster", "=", "min_cluster", "\n", "self", ".", "debug", "=", "kwargs", ".", "get", "(", "'debug'", ",", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory.init_memory": [[42, 54], ["odc_memory.ODCMemory.label_bank.copy_", "torch.broadcast", "torch.broadcast", "torch.broadcast", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "odc_memory.ODCMemory.feature_bank.copy_", "odc_memory.ODCMemory._compute_centroids", "odc_memory.ODCMemory.centroids.copy_", "numpy.linalg.norm().reshape", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.bincount", "numpy.linalg.norm"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory._compute_centroids", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.norm"], ["", "def", "init_memory", "(", "self", ",", "feature", ",", "label", ")", ":", "\n", "        ", "\"\"\"Initialize memory modules.\"\"\"", "\n", "self", ".", "initialized", "=", "True", "\n", "self", ".", "label_bank", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "label", ")", ".", "long", "(", ")", ")", "\n", "# make sure no empty clusters", "\n", "assert", "(", "np", ".", "bincount", "(", "label", ",", "minlength", "=", "self", ".", "num_classes", ")", "!=", "0", ")", ".", "all", "(", ")", "\n", "if", "self", ".", "rank", "==", "0", ":", "\n", "            ", "feature", "/=", "(", "np", ".", "linalg", ".", "norm", "(", "feature", ",", "axis", "=", "1", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "+", "1e-10", ")", "\n", "self", ".", "feature_bank", ".", "copy_", "(", "torch", ".", "from_numpy", "(", "feature", ")", ")", "\n", "centroids", "=", "self", ".", "_compute_centroids", "(", ")", "\n", "self", ".", "centroids", ".", "copy_", "(", "centroids", ")", "\n", "", "dist", ".", "broadcast", "(", "self", ".", "centroids", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory._compute_centroids_ind": [[55, 64], ["len", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "enumerate", "odc_memory.ODCMemory.feature_bank[].mean", "numpy.where", "odc_memory.ODCMemory.label_bank.numpy"], "methods", ["None"], ["", "def", "_compute_centroids_ind", "(", "self", ",", "cinds", ")", ":", "\n", "        ", "\"\"\"Compute a few centroids.\"\"\"", "\n", "assert", "self", ".", "rank", "==", "0", "\n", "num", "=", "len", "(", "cinds", ")", "\n", "centroids", "=", "torch", ".", "zeros", "(", "(", "num", ",", "self", ".", "feat_dim", ")", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "for", "i", ",", "c", "in", "enumerate", "(", "cinds", ")", ":", "\n", "            ", "ind", "=", "np", ".", "where", "(", "self", ".", "label_bank", ".", "numpy", "(", ")", "==", "c", ")", "[", "0", "]", "\n", "centroids", "[", "i", ",", ":", "]", "=", "self", ".", "feature_bank", "[", "ind", ",", ":", "]", ".", "mean", "(", "dim", "=", "0", ")", "\n", "", "return", "centroids", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory._compute_centroids": [[65, 80], ["odc_memory.ODCMemory.label_bank.numpy", "numpy.argsort", "numpy.insert", "numpy.insert", "odc_memory.ODCMemory.centroids.cpu().clone", "zip", "len", "len", "odc_memory.ODCMemory.feature_bank[].mean", "numpy.where", "odc_memory.ODCMemory.centroids.cpu"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone"], ["", "def", "_compute_centroids", "(", "self", ")", ":", "\n", "        ", "\"\"\"Compute all non-empty centroids.\"\"\"", "\n", "assert", "self", ".", "rank", "==", "0", "\n", "l", "=", "self", ".", "label_bank", ".", "numpy", "(", ")", "\n", "argl", "=", "np", ".", "argsort", "(", "l", ")", "\n", "sortl", "=", "l", "[", "argl", "]", "\n", "diff_pos", "=", "np", ".", "where", "(", "sortl", "[", "1", ":", "]", "-", "sortl", "[", ":", "-", "1", "]", "!=", "0", ")", "[", "0", "]", "+", "1", "\n", "start", "=", "np", ".", "insert", "(", "diff_pos", ",", "0", ",", "0", ")", "\n", "end", "=", "np", ".", "insert", "(", "diff_pos", ",", "len", "(", "diff_pos", ")", ",", "len", "(", "l", ")", ")", "\n", "class_start", "=", "sortl", "[", "start", "]", "\n", "# keep empty class centroids unchanged", "\n", "centroids", "=", "self", ".", "centroids", ".", "cpu", "(", ")", ".", "clone", "(", ")", "\n", "for", "i", ",", "st", ",", "ed", "in", "zip", "(", "class_start", ",", "start", ",", "end", ")", ":", "\n", "            ", "centroids", "[", "i", ",", ":", "]", "=", "self", ".", "feature_bank", "[", "argl", "[", "st", ":", "ed", "]", ",", ":", "]", ".", "mean", "(", "dim", "=", "0", ")", "\n", "", "return", "centroids", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory._gather": [[81, 100], ["torch.all_gather", "torch.all_gather", "torch.all_gather", "torch.all_gather", "torch.all_gather", "torch.all_gather", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "torch.ones_like().cuda", "range", "range", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.comm.all_gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.wrappers.cat", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda"], ["", "def", "_gather", "(", "self", ",", "ind", ",", "feature", ")", ":", "\n", "        ", "\"\"\"Gather indices and features.\"\"\"", "\n", "# if not hasattr(self, 'ind_gathered'):", "\n", "#    self.ind_gathered = [torch.ones_like(ind).cuda()", "\n", "#                         for _ in range(self.num_replicas)]", "\n", "# if not hasattr(self, 'feature_gathered'):", "\n", "#    self.feature_gathered = [torch.ones_like(feature).cuda()", "\n", "#                             for _ in range(self.num_replicas)]", "\n", "ind_gathered", "=", "[", "\n", "torch", ".", "ones_like", "(", "ind", ")", ".", "cuda", "(", ")", "for", "_", "in", "range", "(", "self", ".", "num_replicas", ")", "\n", "]", "\n", "feature_gathered", "=", "[", "\n", "torch", ".", "ones_like", "(", "feature", ")", ".", "cuda", "(", ")", "for", "_", "in", "range", "(", "self", ".", "num_replicas", ")", "\n", "]", "\n", "dist", ".", "all_gather", "(", "ind_gathered", ",", "ind", ")", "\n", "dist", ".", "all_gather", "(", "feature_gathered", ",", "feature", ")", "\n", "ind_gathered", "=", "torch", ".", "cat", "(", "ind_gathered", ",", "dim", "=", "0", ")", "\n", "feature_gathered", "=", "torch", ".", "cat", "(", "feature_gathered", ",", "dim", "=", "0", ")", "\n", "return", "ind_gathered", ",", "feature_gathered", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory.update_samples_memory": [[101, 128], ["odc_memory.ODCMemory._gather", "ind.cpu.cpu.cpu", "torch.barrier", "torch.barrier", "torch.barrier", "torch.broadcast", "torch.broadcast", "torch.broadcast", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm.argmax", "torch.mm.argmax", "torch.mm.argmax", "torch.mm.argmax.cpu", "similarity_to_centroids.argmax.cpu.clone", "odc_memory.ODCMemory.feature_bank[].cuda", "feature_norm.cpu", "feature_norm.permute", "float", "feature.norm().view", "feature_new.norm().view", "feature.norm", "feature_new.norm"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory._gather", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.norm", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.ConvModule.norm"], ["", "def", "update_samples_memory", "(", "self", ",", "ind", ",", "feature", ")", ":", "\n", "        ", "\"\"\"Update samples memory.\"\"\"", "\n", "assert", "self", ".", "initialized", "\n", "feature_norm", "=", "feature", "/", "(", "feature", ".", "norm", "(", "dim", "=", "1", ")", ".", "view", "(", "-", "1", ",", "1", ")", "+", "1e-10", "\n", ")", "# normalize", "\n", "ind", ",", "feature_norm", "=", "self", ".", "_gather", "(", "\n", "ind", ",", "feature_norm", ")", "# ind: (N*w), feature: (N*w)xk, cuda tensor", "\n", "ind", "=", "ind", ".", "cpu", "(", ")", "\n", "if", "self", ".", "rank", "==", "0", ":", "\n", "            ", "feature_old", "=", "self", ".", "feature_bank", "[", "ind", ",", "...", "]", ".", "cuda", "(", ")", "\n", "feature_new", "=", "(", "1", "-", "self", ".", "momentum", ")", "*", "feature_old", "+", "self", ".", "momentum", "*", "feature_norm", "\n", "feature_norm", "=", "feature_new", "/", "(", "\n", "feature_new", ".", "norm", "(", "dim", "=", "1", ")", ".", "view", "(", "-", "1", ",", "1", ")", "+", "1e-10", ")", "\n", "self", ".", "feature_bank", "[", "ind", ",", "...", "]", "=", "feature_norm", ".", "cpu", "(", ")", "\n", "", "dist", ".", "barrier", "(", ")", "\n", "dist", ".", "broadcast", "(", "feature_norm", ",", "0", ")", "\n", "# compute new labels", "\n", "similarity_to_centroids", "=", "torch", ".", "mm", "(", "self", ".", "centroids", ",", "\n", "feature_norm", ".", "permute", "(", "1", ",", "0", ")", ")", "# CxN", "\n", "newlabel", "=", "similarity_to_centroids", ".", "argmax", "(", "dim", "=", "0", ")", "# cuda tensor", "\n", "newlabel_cpu", "=", "newlabel", ".", "cpu", "(", ")", "\n", "change_ratio", "=", "(", "newlabel_cpu", "!=", "\n", "self", ".", "label_bank", "[", "ind", "]", ")", ".", "sum", "(", ")", ".", "float", "(", ")", ".", "cuda", "(", ")", "/", "float", "(", "newlabel_cpu", ".", "shape", "[", "0", "]", ")", "\n", "self", ".", "label_bank", "[", "ind", "]", "=", "newlabel_cpu", ".", "clone", "(", ")", "# copy to cpu", "\n", "return", "change_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory.deal_with_small_clusters": [[129, 161], ["numpy.bincount", "[].tolist", "odc_memory.ODCMemory._redirect_empty_clusters", "odc_memory.ODCMemory.label_bank.numpy", "print", "len", "numpy.where", "len", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.where", "numpy.bincount.min", "len", "torch.mm().argmax", "torch.mm().argmax", "torch.mm().argmax", "torch.mm().argmax", "torch.mm().argmax", "torch.mm().argmax", "torch.mm().argmax", "torch.mm().argmax", "torch.mm().argmax", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda.cpu().numpy", "torch.zeros().cuda.cpu().numpy", "torch.zeros().cuda.cpu().numpy", "odc_memory.ODCMemory.label_bank.numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.setdiff1d", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros().cuda.cpu", "torch.zeros().cuda.cpu", "torch.zeros().cuda.cpu", "numpy.arange", "numpy.array", "odc_memory.ODCMemory.feature_bank[].cuda().permute", "odc_memory.ODCMemory.feature_bank[].cuda"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory._redirect_empty_clusters", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda"], ["", "def", "deal_with_small_clusters", "(", "self", ")", ":", "\n", "        ", "\"\"\"Deal with small clusters.\"\"\"", "\n", "# check empty class", "\n", "hist", "=", "np", ".", "bincount", "(", "self", ".", "label_bank", ".", "numpy", "(", ")", ",", "minlength", "=", "self", ".", "num_classes", ")", "\n", "small_clusters", "=", "np", ".", "where", "(", "hist", "<", "self", ".", "min_cluster", ")", "[", "0", "]", ".", "tolist", "(", ")", "\n", "if", "self", ".", "debug", "and", "self", ".", "rank", "==", "0", ":", "\n", "            ", "print", "(", "\"mincluster: {}, num of small class: {}\"", ".", "format", "(", "\n", "hist", ".", "min", "(", ")", ",", "len", "(", "small_clusters", ")", ")", ")", "\n", "", "if", "len", "(", "small_clusters", ")", "==", "0", ":", "\n", "            ", "return", "\n", "# re-assign samples in small clusters to make them empty", "\n", "", "for", "s", "in", "small_clusters", ":", "\n", "            ", "ind", "=", "np", ".", "where", "(", "self", ".", "label_bank", ".", "numpy", "(", ")", "==", "s", ")", "[", "0", "]", "\n", "if", "len", "(", "ind", ")", ">", "0", ":", "\n", "                ", "inclusion", "=", "torch", ".", "from_numpy", "(", "\n", "np", ".", "setdiff1d", "(", "\n", "np", ".", "arange", "(", "self", ".", "num_classes", ")", ",", "\n", "np", ".", "array", "(", "small_clusters", ")", ",", "\n", "assume_unique", "=", "True", ")", ")", ".", "cuda", "(", ")", "\n", "if", "self", ".", "rank", "==", "0", ":", "\n", "                    ", "target_ind", "=", "torch", ".", "mm", "(", "\n", "self", ".", "centroids", "[", "inclusion", ",", ":", "]", ",", "\n", "self", ".", "feature_bank", "[", "ind", ",", ":", "]", ".", "cuda", "(", ")", ".", "permute", "(", "\n", "1", ",", "0", ")", ")", ".", "argmax", "(", "dim", "=", "0", ")", "\n", "target", "=", "inclusion", "[", "target_ind", "]", "\n", "", "else", ":", "\n", "                    ", "target", "=", "torch", ".", "zeros", "(", "(", "ind", ".", "shape", "[", "0", "]", ",", ")", ",", "\n", "dtype", "=", "torch", ".", "int64", ")", ".", "cuda", "(", ")", "\n", "", "dist", ".", "all_reduce", "(", "target", ")", "\n", "self", ".", "label_bank", "[", "ind", "]", "=", "torch", ".", "from_numpy", "(", "target", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "# deal with empty cluster", "\n", "", "", "self", ".", "_redirect_empty_clusters", "(", "small_clusters", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory.update_centroids_memory": [[162, 175], ["torch.broadcast", "torch.broadcast", "torch.broadcast", "print", "odc_memory.ODCMemory._compute_centroids", "odc_memory.ODCMemory.centroids.copy_", "odc_memory.ODCMemory._compute_centroids_ind", "odc_memory.ODCMemory.cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory._compute_centroids", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory._compute_centroids_ind", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda"], ["", "def", "update_centroids_memory", "(", "self", ",", "cinds", "=", "None", ")", ":", "\n", "        ", "\"\"\"Update centroids memory.\"\"\"", "\n", "if", "self", ".", "rank", "==", "0", ":", "\n", "            ", "if", "self", ".", "debug", ":", "\n", "                ", "print", "(", "\"updating centroids ...\"", ")", "\n", "", "if", "cinds", "is", "None", ":", "\n", "                ", "center", "=", "self", ".", "_compute_centroids", "(", ")", "\n", "self", ".", "centroids", ".", "copy_", "(", "center", ")", "\n", "", "else", ":", "\n", "                ", "center", "=", "self", ".", "_compute_centroids_ind", "(", "cinds", ")", "\n", "self", ".", "centroids", "[", "\n", "torch", ".", "LongTensor", "(", "cinds", ")", ".", "cuda", "(", ")", ",", ":", "]", "=", "center", ".", "cuda", "(", ")", "\n", "", "", "dist", ".", "broadcast", "(", "self", ".", "centroids", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory._partition_max_cluster": [[176, 196], ["numpy.any", "odc_memory.ODCMemory.kmeans.fit", "numpy.where", "len", "numpy.isnan", "Exception", "print", "numpy.random.choice", "numpy.setdiff1d", "max_cluster_features.numpy", "len", "len", "len"], "methods", ["None"], ["", "def", "_partition_max_cluster", "(", "self", ",", "max_cluster", ")", ":", "\n", "        ", "\"\"\"Partition the largest cluster into two sub-clusters.\"\"\"", "\n", "assert", "self", ".", "rank", "==", "0", "\n", "max_cluster_inds", "=", "np", ".", "where", "(", "self", ".", "label_bank", "==", "max_cluster", ")", "[", "0", "]", "\n", "\n", "assert", "len", "(", "max_cluster_inds", ")", ">=", "2", "\n", "max_cluster_features", "=", "self", ".", "feature_bank", "[", "max_cluster_inds", ",", ":", "]", "\n", "if", "np", ".", "any", "(", "np", ".", "isnan", "(", "max_cluster_features", ".", "numpy", "(", ")", ")", ")", ":", "\n", "            ", "raise", "Exception", "(", "\"Has nan in features.\"", ")", "\n", "", "kmeans_ret", "=", "self", ".", "kmeans", ".", "fit", "(", "max_cluster_features", ")", "\n", "sub_cluster1_ind", "=", "max_cluster_inds", "[", "kmeans_ret", ".", "labels_", "==", "0", "]", "\n", "sub_cluster2_ind", "=", "max_cluster_inds", "[", "kmeans_ret", ".", "labels_", "==", "1", "]", "\n", "if", "not", "(", "len", "(", "sub_cluster1_ind", ")", ">", "0", "and", "len", "(", "sub_cluster2_ind", ")", ">", "0", ")", ":", "\n", "            ", "print", "(", "\n", "\"Warning: kmeans partition fails, resort to random partition.\"", ")", "\n", "sub_cluster1_ind", "=", "np", ".", "random", ".", "choice", "(", "\n", "max_cluster_inds", ",", "len", "(", "max_cluster_inds", ")", "//", "2", ",", "replace", "=", "False", ")", "\n", "sub_cluster2_ind", "=", "np", ".", "setdiff1d", "(", "\n", "max_cluster_inds", ",", "sub_cluster1_ind", ",", "assume_unique", "=", "True", ")", "\n", "", "return", "sub_cluster1_ind", ",", "sub_cluster2_ind", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory._redirect_empty_clusters": [[197, 234], ["numpy.bincount().argmax().item", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "torch.broadcast", "torch.broadcast", "torch.broadcast", "torch.broadcast", "torch.broadcast", "torch.broadcast", "odc_memory.ODCMemory.update_centroids_memory", "odc_memory.ODCMemory._partition_max_cluster", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.from_numpy().long().cuda", "torch.from_numpy().long().cuda", "torch.from_numpy().long().cuda", "torch.from_numpy().long().cuda", "torch.from_numpy().long().cuda", "torch.from_numpy().long().cuda", "torch.from_numpy().long().cuda", "torch.from_numpy().long().cuda", "torch.from_numpy().long().cuda", "torch.from_numpy().long().cuda", "torch.from_numpy().long().cuda", "torch.from_numpy().long().cuda", "torch.from_numpy().long().cuda", "torch.from_numpy().long().cuda", "torch.from_numpy().long().cuda", "torch.from_numpy().long().cuda", "torch.from_numpy().long().cuda", "torch.from_numpy().long().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda.cpu().numpy", "torch.zeros().cuda.cpu().numpy", "torch.zeros().cuda.cpu().numpy", "torch.zeros().cuda.cpu().numpy", "torch.zeros().cuda.cpu().numpy", "torch.zeros().cuda.cpu().numpy", "numpy.bincount().argmax", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().long", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros().cuda.cpu", "torch.zeros().cuda.cpu", "torch.zeros().cuda.cpu", "torch.zeros().cuda.cpu", "torch.zeros().cuda.cpu", "torch.zeros().cuda.cpu", "numpy.bincount", "len", "len", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory.update_centroids_memory", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory._partition_max_cluster", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda"], ["", "def", "_redirect_empty_clusters", "(", "self", ",", "empty_clusters", ")", ":", "\n", "        ", "\"\"\"Re-direct empty clusters.\"\"\"", "\n", "for", "e", "in", "empty_clusters", ":", "\n", "            ", "assert", "(", "self", ".", "label_bank", "!=", "e", ")", ".", "all", "(", ")", ".", "item", "(", ")", ",", "\"Cluster #{} is not an empty cluster.\"", ".", "format", "(", "e", ")", "\n", "max_cluster", "=", "np", ".", "bincount", "(", "\n", "self", ".", "label_bank", ",", "minlength", "=", "self", ".", "num_classes", ")", ".", "argmax", "(", ")", ".", "item", "(", ")", "\n", "# gather partitioning indices", "\n", "if", "self", ".", "rank", "==", "0", ":", "\n", "                ", "sub_cluster1_ind", ",", "sub_cluster2_ind", "=", "self", ".", "_partition_max_cluster", "(", "\n", "max_cluster", ")", "\n", "size1", "=", "torch", ".", "LongTensor", "(", "[", "len", "(", "sub_cluster1_ind", ")", "]", ")", ".", "cuda", "(", ")", "\n", "size2", "=", "torch", ".", "LongTensor", "(", "[", "len", "(", "sub_cluster2_ind", ")", "]", ")", ".", "cuda", "(", ")", "\n", "sub_cluster1_ind_tensor", "=", "torch", ".", "from_numpy", "(", "\n", "sub_cluster1_ind", ")", ".", "long", "(", ")", ".", "cuda", "(", ")", "\n", "sub_cluster2_ind_tensor", "=", "torch", ".", "from_numpy", "(", "\n", "sub_cluster2_ind", ")", ".", "long", "(", ")", ".", "cuda", "(", ")", "\n", "", "else", ":", "\n", "                ", "size1", "=", "torch", ".", "LongTensor", "(", "[", "0", "]", ")", ".", "cuda", "(", ")", "\n", "size2", "=", "torch", ".", "LongTensor", "(", "[", "0", "]", ")", ".", "cuda", "(", ")", "\n", "", "dist", ".", "all_reduce", "(", "size1", ")", "\n", "dist", ".", "all_reduce", "(", "size2", ")", "\n", "if", "self", ".", "rank", "!=", "0", ":", "\n", "                ", "sub_cluster1_ind_tensor", "=", "torch", ".", "zeros", "(", "\n", "(", "size1", ",", ")", ",", "dtype", "=", "torch", ".", "int64", ")", ".", "cuda", "(", ")", "\n", "sub_cluster2_ind_tensor", "=", "torch", ".", "zeros", "(", "\n", "(", "size2", ",", ")", ",", "dtype", "=", "torch", ".", "int64", ")", ".", "cuda", "(", ")", "\n", "", "dist", ".", "broadcast", "(", "sub_cluster1_ind_tensor", ",", "0", ")", "\n", "dist", ".", "broadcast", "(", "sub_cluster2_ind_tensor", ",", "0", ")", "\n", "if", "self", ".", "rank", "!=", "0", ":", "\n", "                ", "sub_cluster1_ind", "=", "sub_cluster1_ind_tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "sub_cluster2_ind", "=", "sub_cluster2_ind_tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "# reassign samples in partition #2 to the empty class", "\n", "", "self", ".", "label_bank", "[", "sub_cluster2_ind", "]", "=", "e", "\n", "# update centroids of max_cluster and e", "\n", "self", ".", "update_centroids_memory", "(", "[", "max_cluster", ",", "e", "]", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.BasicBlock.__init__": [[15, 49], ["dict", "torch.Module.__init__", "utils.build_norm_layer", "utils.build_norm_layer", "utils.build_conv_layer", "resnet.BasicBlock.add_module", "utils.build_conv_layer", "resnet.BasicBlock.add_module", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.norm.build_norm_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.norm.build_norm_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.build_conv_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.build_conv_layer"], ["get_norm", ",", "\n", ")", "\n", "\n", "from", ".", "backbone", "import", "Backbone", "\n", "from", ".", "build", "import", "BACKBONE_REGISTRY", "\n", "\n", "__all__", "=", "[", "\n", "\"ResNetBlockBase\"", ",", "\n", "\"BasicBlock\"", ",", "\n", "\"BottleneckBlock\"", ",", "\n", "\"DeformBottleneckBlock\"", ",", "\n", "\"BasicStem\"", ",", "\n", "\"ResNet\"", ",", "\n", "\"make_stage\"", ",", "\n", "\"build_resnet_backbone\"", ",", "\n", "]", "\n", "\n", "\n", "class", "BasicBlock", "(", "CNNBlockBase", ")", ":", "\n", "    ", "\"\"\"\n    The basic residual block for ResNet-18 and ResNet-34 defined in :paper:`ResNet`,\n    with two 3x3 conv layers and a projection shortcut if needed.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "*", ",", "stride", "=", "1", ",", "norm", "=", "\"BN\"", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            in_channels (int): Number of input channels.\n            out_channels (int): Number of output channels.\n            stride (int): Stride for the first conv.\n            norm (str or callable): normalization for all conv layers.\n                See :func:`layers.get_norm` for supported format.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "stride", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.BasicBlock.norm1": [[50, 53], ["getattr"], "methods", ["None"], ["if", "in_channels", "!=", "out_channels", ":", "\n", "            ", "self", ".", "shortcut", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.BasicBlock.norm2": [[54, 57], ["getattr"], "methods", ["None"], ["kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.BasicBlock.forward": [[58, 75], ["resnet.BasicBlock.conv1", "resnet.BasicBlock.norm1", "resnet.BasicBlock.relu", "resnet.BasicBlock.conv2", "resnet.BasicBlock.norm2", "resnet.BasicBlock.relu", "resnet.BasicBlock.downsample"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.norm1", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.Bottleneck.norm2"], [")", "\n", "", "else", ":", "\n", "            ", "self", ".", "shortcut", "=", "None", "\n", "\n", "", "self", ".", "conv1", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "\n", "self", ".", "conv2", "=", "Conv2d", "(", "\n", "out_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.Bottleneck.__init__": [[80, 146], ["dict", "torch.Module.__init__", "utils.build_norm_layer", "utils.build_norm_layer", "utils.build_norm_layer", "utils.build_conv_layer", "resnet.Bottleneck.add_module", "utils.build_conv_layer", "resnet.Bottleneck.add_module", "utils.build_conv_layer", "resnet.Bottleneck.add_module", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.norm.build_norm_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.norm.build_norm_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.norm.build_norm_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.build_conv_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.build_conv_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.build_conv_layer"], [")", "\n", "\n", "for", "layer", "in", "[", "self", ".", "conv1", ",", "self", ".", "conv2", ",", "self", ".", "shortcut", "]", ":", "\n", "            ", "if", "layer", "is", "not", "None", ":", "# shortcut can be None", "\n", "                ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "\n", "", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "\n", "if", "self", ".", "shortcut", "is", "not", "None", ":", "\n", "            ", "shortcut", "=", "self", ".", "shortcut", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "shortcut", "=", "x", "\n", "\n", "", "out", "+=", "shortcut", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "return", "out", "\n", "\n", "\n", "", "", "class", "BottleneckBlock", "(", "CNNBlockBase", ")", ":", "\n", "    ", "\"\"\"\n    The standard bottleneck residual block used by ResNet-50, 101 and 152\n    defined in :paper:`ResNet`.  It contains 3 conv layers with kernels\n    1x1, 3x3, 1x1, and a projection shortcut if needed.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "*", ",", "\n", "bottleneck_channels", ",", "\n", "stride", "=", "1", ",", "\n", "num_groups", "=", "1", ",", "\n", "norm", "=", "\"BN\"", ",", "\n", "stride_in_1x1", "=", "False", ",", "\n", "dilation", "=", "1", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            bottleneck_channels (int): number of output channels for the 3x3\n                \"bottleneck\" conv layers.\n            num_groups (int): number of groups for the 3x3 conv layer.\n            norm (str or callable): normalization for all conv layers.\n                See :func:`layers.get_norm` for supported format.\n            stride_in_1x1 (bool): when stride>1, whether to put stride in the\n                first 1x1 convolution or the bottleneck 3x3 convolution.\n            dilation (int): the dilation rate of the 3x3 conv layer.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "stride", ")", "\n", "\n", "if", "in_channels", "!=", "out_channels", ":", "\n", "            ", "self", ".", "shortcut", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "shortcut", "=", "None", "\n", "\n", "# The original MSRA ResNet models have stride in the first 1x1 conv", "\n", "# The subsequent fb.torch.resnet and Caffe2 ResNe[X]t implementations have", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.Bottleneck.norm1": [[147, 150], ["getattr"], "methods", ["None"], ["# stride in the 3x3 conv", "\n", "", "stride_1x1", ",", "stride_3x3", "=", "(", "stride", ",", "1", ")", "if", "stride_in_1x1", "else", "(", "1", ",", "stride", ")", "\n", "\n", "self", ".", "conv1", "=", "Conv2d", "(", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.Bottleneck.norm2": [[151, 154], ["getattr"], "methods", ["None"], ["in_channels", ",", "\n", "bottleneck_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride_1x1", ",", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.Bottleneck.norm3": [[155, 158], ["getattr"], "methods", ["None"], ["bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "bottleneck_channels", ")", ",", "\n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.Bottleneck.forward": [[159, 190], ["resnet.Bottleneck.relu", "resnet.Bottleneck.conv1", "resnet.Bottleneck.norm1", "resnet.Bottleneck.relu", "resnet.Bottleneck.conv2", "resnet.Bottleneck.norm2", "resnet.Bottleneck.relu", "resnet.Bottleneck.conv3", "resnet.Bottleneck.norm3", "torch.checkpoint", "torch.checkpoint", "resnet.Bottleneck.forward._inner_forward"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.norm1", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.Bottleneck.norm2", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.Bottleneck.norm3"], ["self", ".", "conv2", "=", "Conv2d", "(", "\n", "bottleneck_channels", ",", "\n", "bottleneck_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride_3x3", ",", "\n", "padding", "=", "1", "*", "dilation", ",", "\n", "bias", "=", "False", ",", "\n", "groups", "=", "num_groups", ",", "\n", "dilation", "=", "dilation", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "bottleneck_channels", ")", ",", "\n", ")", "\n", "\n", "self", ".", "conv3", "=", "Conv2d", "(", "\n", "bottleneck_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "\n", "for", "layer", "in", "[", "self", ".", "conv1", ",", "self", ".", "conv2", ",", "self", ".", "conv3", ",", "self", ".", "shortcut", "]", ":", "\n", "            ", "if", "layer", "is", "not", "None", ":", "# shortcut can be None", "\n", "                ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "\n", "# Zero-initialize the last normalization in each residual branch,", "\n", "# so that at the beginning, the residual branch starts with zeros,", "\n", "# and each residual block behaves like an identity.", "\n", "# See Sec 5.1 in \"Accurate, Large Minibatch SGD: Training ImageNet in 1 Hour\":", "\n", "# \"For BN layers, the learnable scaling coefficient \u03b3 is initialized", "\n", "# to be 1, except for each residual block's last BN", "\n", "# where \u03b3 is initialized to be 0.\"", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.__init__": [[291, 356], ["dict", "torch.Module.__init__", "resnet.ResNet._make_stem_layer", "enumerate", "resnet.ResNet._freeze_stages", "KeyError", "len", "len", "max", "resnet.make_res_layer", "resnet.ResNet.add_module", "resnet.ResNet.res_layers.append", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet._make_stem_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet._freeze_stages", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnext.make_res_layer"], ["out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "\n", "for", "layer", "in", "[", "self", ".", "conv1", ",", "self", ".", "conv2", ",", "self", ".", "conv3", ",", "self", ".", "shortcut", "]", ":", "\n", "            ", "if", "layer", "is", "not", "None", ":", "# shortcut can be None", "\n", "                ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "\n", "", "", "nn", ".", "init", ".", "constant_", "(", "self", ".", "conv2_offset", ".", "weight", ",", "0", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "conv2_offset", ".", "bias", ",", "0", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "\n", "if", "self", ".", "deform_modulated", ":", "\n", "            ", "offset_mask", "=", "self", ".", "conv2_offset", "(", "out", ")", "\n", "offset_x", ",", "offset_y", ",", "mask", "=", "torch", ".", "chunk", "(", "offset_mask", ",", "3", ",", "dim", "=", "1", ")", "\n", "offset", "=", "torch", ".", "cat", "(", "(", "offset_x", ",", "offset_y", ")", ",", "dim", "=", "1", ")", "\n", "mask", "=", "mask", ".", "sigmoid", "(", ")", "\n", "out", "=", "self", ".", "conv2", "(", "out", ",", "offset", ",", "mask", ")", "\n", "", "else", ":", "\n", "            ", "offset", "=", "self", ".", "conv2_offset", "(", "out", ")", "\n", "out", "=", "self", ".", "conv2", "(", "out", ",", "offset", ")", "\n", "", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "\n", "if", "self", ".", "shortcut", "is", "not", "None", ":", "\n", "            ", "shortcut", "=", "self", ".", "shortcut", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "shortcut", "=", "x", "\n", "\n", "", "out", "+=", "shortcut", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "return", "out", "\n", "\n", "\n", "", "", "class", "BasicStem", "(", "CNNBlockBase", ")", ":", "\n", "    ", "\"\"\"\n    The standard ResNet stem (layers before the first residual block).\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "in_channels", "=", "3", ",", "out_channels", "=", "64", ",", "norm", "=", "\"BN\"", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            norm (str or callable): norm after the first conv layer.\n                See :func:`layers.get_norm` for supported format.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "4", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "conv1", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "7", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "3", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "weight_init", ".", "c2_msra_fill", "(", "self", ".", "conv1", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.norm1": [[357, 360], ["getattr"], "methods", ["None"], ["x", "=", "F", ".", "relu_", "(", "x", ")", "\n", "x", "=", "F", ".", "max_pool2d", "(", "x", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet._make_stem_layer": [[361, 374], ["utils.build_conv_layer", "utils.build_norm_layer", "resnet.ResNet.add_module", "torch.ReLU", "torch.ReLU", "torch.MaxPool2d", "torch.MaxPool2d"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.build_conv_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.norm.build_norm_layer"], ["\n", "", "", "class", "ResNet", "(", "Backbone", ")", ":", "\n", "    ", "\"\"\"\n    Implement :paper:`ResNet`.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "stem", ",", "stages", ",", "num_classes", "=", "None", ",", "out_features", "=", "None", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet._freeze_stages": [[375, 387], ["range", "resnet.ResNet.norm1.eval", "getattr", "getattr.eval", "getattr.parameters", "getattr.parameters"], "methods", ["None"], ["\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "stem", "=", "stem", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "\n", "current_stride", "=", "self", ".", "stem", ".", "stride", "\n", "self", ".", "_out_feature_strides", "=", "{", "\"stem\"", ":", "current_stride", "}", "\n", "self", ".", "_out_feature_channels", "=", "{", "\"stem\"", ":", "self", ".", "stem", ".", "out_channels", "}", "\n", "\n", "self", ".", "stages_and_names", "=", "[", "]", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights": [[388, 407], ["isinstance", "resnet.ResNet.utils.get_root_logger", "mmcv.runner.load_checkpoint", "resnet.ResNet.modules", "TypeError", "isinstance", "resnet.ResNet.modules", "mmcv.cnn.kaiming_init", "isinstance", "isinstance", "mmcv.cnn.constant_init", "mmcv.cnn.constant_init", "isinstance", "mmcv.cnn.constant_init"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.get_root_logger"], ["for", "i", ",", "blocks", "in", "enumerate", "(", "stages", ")", ":", "\n", "            ", "assert", "len", "(", "blocks", ")", ">", "0", ",", "len", "(", "blocks", ")", "\n", "for", "block", "in", "blocks", ":", "\n", "                ", "assert", "isinstance", "(", "block", ",", "CNNBlockBase", ")", ",", "block", "\n", "\n", "", "name", "=", "\"res\"", "+", "str", "(", "i", "+", "2", ")", "\n", "stage", "=", "nn", ".", "Sequential", "(", "*", "blocks", ")", "\n", "\n", "self", ".", "add_module", "(", "name", ",", "stage", ")", "\n", "self", ".", "stages_and_names", ".", "append", "(", "(", "stage", ",", "name", ")", ")", "\n", "\n", "self", ".", "_out_feature_strides", "[", "name", "]", "=", "current_stride", "=", "int", "(", "\n", "current_stride", "*", "np", ".", "prod", "(", "[", "k", ".", "stride", "for", "k", "in", "blocks", "]", ")", "\n", ")", "\n", "self", ".", "_out_feature_channels", "[", "name", "]", "=", "curr_channels", "=", "blocks", "[", "-", "1", "]", ".", "out_channels", "\n", "\n", "", "if", "num_classes", "is", "not", "None", ":", "\n", "            ", "self", ".", "avgpool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "(", "1", ",", "1", ")", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "curr_channels", ",", "num_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.forward": [[408, 423], ["resnet.ResNet.conv1", "resnet.ResNet.norm1", "resnet.ResNet.relu", "resnet.ResNet.maxpool", "enumerate", "tuple", "outs.append", "getattr", "getattr.", "outs.append"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.norm1"], ["# Sec 5.1 in \"Accurate, Large Minibatch SGD: Training ImageNet in 1 Hour\":", "\n", "# \"The 1000-way fully-connected layer is initialized by", "\n", "# drawing weights from a zero-mean Gaussian with standard deviation of 0.01.\"", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "linear", ".", "weight", ",", "std", "=", "0.01", ")", "\n", "name", "=", "\"linear\"", "\n", "\n", "", "if", "out_features", "is", "None", ":", "\n", "            ", "out_features", "=", "[", "name", "]", "\n", "", "self", ".", "_out_features", "=", "out_features", "\n", "assert", "len", "(", "self", ".", "_out_features", ")", "\n", "children", "=", "[", "x", "[", "0", "]", "for", "x", "in", "self", ".", "named_children", "(", ")", "]", "\n", "for", "out_feature", "in", "self", ".", "_out_features", ":", "\n", "            ", "assert", "out_feature", "in", "children", ",", "\"Available children: {}\"", ".", "format", "(", "\", \"", ".", "join", "(", "children", ")", ")", "\n", "\n", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train": [[424, 443], ["super().train", "resnet.ResNet._freeze_stages", "resnet.ResNet.modules", "resnet.ResNet.modules", "isinstance", "isinstance", "m.eval", "m.train", "m.parameters"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet._freeze_stages", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train"], ["\n", "assert", "x", ".", "dim", "(", ")", "==", "4", ",", "f\"ResNet takes an input of shape (N, C, H, W). Got {x.shape} instead!\"", "\n", "outputs", "=", "{", "}", "\n", "x", "=", "self", ".", "stem", "(", "x", ")", "\n", "if", "\"stem\"", "in", "self", ".", "_out_features", ":", "\n", "            ", "outputs", "[", "\"stem\"", "]", "=", "x", "\n", "", "for", "stage", ",", "name", "in", "self", ".", "stages_and_names", ":", "\n", "            ", "x", "=", "stage", "(", "x", ")", "\n", "if", "name", "in", "self", ".", "_out_features", ":", "\n", "                ", "outputs", "[", "name", "]", "=", "x", "\n", "", "", "if", "self", ".", "num_classes", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "avgpool", "(", "x", ")", "\n", "x", "=", "torch", ".", "flatten", "(", "x", ",", "1", ")", "\n", "x", "=", "self", ".", "linear", "(", "x", ")", "\n", "if", "\"linear\"", "in", "self", ".", "_out_features", ":", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.make_res_layer": [[192, 241], ["dict", "layers.append", "range", "torch.Sequential", "torch.Sequential", "block", "layers.append", "utils.build_conv_layer", "block", "utils.build_norm_layer"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.build_conv_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.norm.build_norm_layer"], ["# TODO this somehow hurts performance when training GN models from scratch.", "\n", "# Add it as an option when we need to use this code to train a backbone.", "\n", "\n", "", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "\n", "if", "self", ".", "shortcut", "is", "not", "None", ":", "\n", "            ", "shortcut", "=", "self", ".", "shortcut", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "shortcut", "=", "x", "\n", "\n", "", "out", "+=", "shortcut", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "return", "out", "\n", "\n", "\n", "", "", "class", "DeformBottleneckBlock", "(", "CNNBlockBase", ")", ":", "\n", "    ", "\"\"\"\n    Similar to :class:`BottleneckBlock`, but with :paper:`deformable conv <deformconv>`\n    in the 3x3 convolution.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "*", ",", "\n", "bottleneck_channels", ",", "\n", "stride", "=", "1", ",", "\n", "num_groups", "=", "1", ",", "\n", "norm", "=", "\"BN\"", ",", "\n", "stride_in_1x1", "=", "False", ",", "\n", "dilation", "=", "1", ",", "\n", "deform_modulated", "=", "False", ",", "\n", "deform_num_groups", "=", "1", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "stride", ")", "\n", "self", ".", "deform_modulated", "=", "deform_modulated", "\n", "\n", "if", "in_channels", "!=", "out_channels", ":", "\n", "            ", "self", ".", "shortcut", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnext.Bottleneck.__init__": [[13, 76], ["resnet.Bottleneck.__init__", "utils.build_norm_layer", "utils.build_norm_layer", "utils.build_norm_layer", "utils.build_conv_layer", "resnext.Bottleneck.add_module", "resnext.Bottleneck.add_module", "utils.build_conv_layer", "resnext.Bottleneck.add_module", "resnext.Bottleneck.dcn.pop", "utils.build_conv_layer", "utils.build_conv_layer", "math.floor"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.norm.build_norm_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.norm.build_norm_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.norm.build_norm_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.build_conv_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.build_conv_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.build_conv_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.build_conv_layer"], ["    ", "def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "groups", "=", "1", ",", "base_width", "=", "4", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Bottleneck block for ResNeXt.\n        If style is \"pytorch\", the stride-two layer is the 3x3 conv layer,\n        if it is \"caffe\", the stride-two layer is the first 1x1 conv layer.\n        \"\"\"", "\n", "super", "(", "Bottleneck", ",", "self", ")", ".", "__init__", "(", "inplanes", ",", "planes", ",", "**", "kwargs", ")", "\n", "\n", "if", "groups", "==", "1", ":", "\n", "            ", "width", "=", "self", ".", "planes", "\n", "", "else", ":", "\n", "            ", "width", "=", "math", ".", "floor", "(", "self", ".", "planes", "*", "(", "base_width", "/", "64", ")", ")", "*", "groups", "\n", "\n", "", "self", ".", "norm1_name", ",", "norm1", "=", "build_norm_layer", "(", "\n", "self", ".", "norm_cfg", ",", "width", ",", "postfix", "=", "1", ")", "\n", "self", ".", "norm2_name", ",", "norm2", "=", "build_norm_layer", "(", "\n", "self", ".", "norm_cfg", ",", "width", ",", "postfix", "=", "2", ")", "\n", "self", ".", "norm3_name", ",", "norm3", "=", "build_norm_layer", "(", "\n", "self", ".", "norm_cfg", ",", "self", ".", "planes", "*", "self", ".", "expansion", ",", "postfix", "=", "3", ")", "\n", "\n", "self", ".", "conv1", "=", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "self", ".", "inplanes", ",", "\n", "width", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "self", ".", "conv1_stride", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "add_module", "(", "self", ".", "norm1_name", ",", "norm1", ")", "\n", "fallback_on_stride", "=", "False", "\n", "self", ".", "with_modulated_dcn", "=", "False", "\n", "if", "self", ".", "with_dcn", ":", "\n", "            ", "fallback_on_stride", "=", "self", ".", "dcn", ".", "pop", "(", "'fallback_on_stride'", ",", "False", ")", "\n", "", "if", "not", "self", ".", "with_dcn", "or", "fallback_on_stride", ":", "\n", "            ", "self", ".", "conv2", "=", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "width", ",", "\n", "width", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "self", ".", "conv2_stride", ",", "\n", "padding", "=", "self", ".", "dilation", ",", "\n", "dilation", "=", "self", ".", "dilation", ",", "\n", "groups", "=", "groups", ",", "\n", "bias", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "assert", "self", ".", "conv_cfg", "is", "None", ",", "'conv_cfg must be None for DCN'", "\n", "self", ".", "conv2", "=", "build_conv_layer", "(", "\n", "self", ".", "dcn", ",", "\n", "width", ",", "\n", "width", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "self", ".", "conv2_stride", ",", "\n", "padding", "=", "self", ".", "dilation", ",", "\n", "dilation", "=", "self", ".", "dilation", ",", "\n", "groups", "=", "groups", ",", "\n", "bias", "=", "False", ")", "\n", "\n", "", "self", ".", "add_module", "(", "self", ".", "norm2_name", ",", "norm2", ")", "\n", "self", ".", "conv3", "=", "build_conv_layer", "(", "\n", "self", ".", "conv_cfg", ",", "\n", "width", ",", "\n", "self", ".", "planes", "*", "self", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "add_module", "(", "self", ".", "norm3_name", ",", "norm3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnext.ResNeXt.__init__": [[189, 223], ["resnet.ResNet.__init__", "enumerate", "resnext.ResNeXt._freeze_stages", "resnext.make_res_layer", "resnext.ResNeXt.add_module", "resnext.ResNeXt.res_layers.append"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet._freeze_stages", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnext.make_res_layer"], ["def", "__init__", "(", "self", ",", "groups", "=", "1", ",", "base_width", "=", "4", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "ResNeXt", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "groups", "=", "groups", "\n", "self", ".", "base_width", "=", "base_width", "\n", "\n", "self", ".", "inplanes", "=", "64", "\n", "self", ".", "res_layers", "=", "[", "]", "\n", "for", "i", ",", "num_blocks", "in", "enumerate", "(", "self", ".", "stage_blocks", ")", ":", "\n", "            ", "stride", "=", "self", ".", "strides", "[", "i", "]", "\n", "dilation", "=", "self", ".", "dilations", "[", "i", "]", "\n", "dcn", "=", "self", ".", "dcn", "if", "self", ".", "stage_with_dcn", "[", "i", "]", "else", "None", "\n", "gcb", "=", "self", ".", "gcb", "if", "self", ".", "stage_with_gcb", "[", "i", "]", "else", "None", "\n", "planes", "=", "64", "*", "2", "**", "i", "\n", "res_layer", "=", "make_res_layer", "(", "\n", "self", ".", "block", ",", "\n", "self", ".", "inplanes", ",", "\n", "planes", ",", "\n", "num_blocks", ",", "\n", "stride", "=", "stride", ",", "\n", "dilation", "=", "dilation", ",", "\n", "groups", "=", "self", ".", "groups", ",", "\n", "base_width", "=", "self", ".", "base_width", ",", "\n", "style", "=", "self", ".", "style", ",", "\n", "with_cp", "=", "self", ".", "with_cp", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "dcn", "=", "dcn", ",", "\n", "gcb", "=", "gcb", ")", "\n", "self", ".", "inplanes", "=", "planes", "*", "self", ".", "block", ".", "expansion", "\n", "layer_name", "=", "'layer{}'", ".", "format", "(", "i", "+", "1", ")", "\n", "self", ".", "add_module", "(", "layer_name", ",", "res_layer", ")", "\n", "self", ".", "res_layers", ".", "append", "(", "layer_name", ")", "\n", "\n", "", "self", ".", "_freeze_stages", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnext.make_res_layer": [[78, 139], ["dict", "layers.append", "range", "torch.Sequential", "torch.Sequential", "block", "layers.append", "utils.build_conv_layer", "block", "utils.build_norm_layer"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.conv_module.build_conv_layer", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.norm.build_norm_layer"], ["", "", "def", "make_res_layer", "(", "block", ",", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "blocks", ",", "\n", "stride", "=", "1", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "base_width", "=", "4", ",", "\n", "style", "=", "'pytorch'", ",", "\n", "with_cp", "=", "False", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "dcn", "=", "None", ",", "\n", "gcb", "=", "None", ")", ":", "\n", "    ", "downsample", "=", "None", "\n", "if", "stride", "!=", "1", "or", "inplanes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "        ", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "build_conv_layer", "(", "\n", "conv_cfg", ",", "\n", "inplanes", ",", "\n", "planes", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "bias", "=", "False", ")", ",", "\n", "build_norm_layer", "(", "norm_cfg", ",", "planes", "*", "block", ".", "expansion", ")", "[", "1", "]", ",", "\n", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", "=", "inplanes", ",", "\n", "planes", "=", "planes", ",", "\n", "stride", "=", "stride", ",", "\n", "dilation", "=", "dilation", ",", "\n", "downsample", "=", "downsample", ",", "\n", "groups", "=", "groups", ",", "\n", "base_width", "=", "base_width", ",", "\n", "style", "=", "style", ",", "\n", "with_cp", "=", "with_cp", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "dcn", "=", "dcn", ",", "\n", "gcb", "=", "gcb", ")", ")", "\n", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n", "for", "i", "in", "range", "(", "1", ",", "blocks", ")", ":", "\n", "        ", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", "=", "inplanes", ",", "\n", "planes", "=", "planes", ",", "\n", "stride", "=", "1", ",", "\n", "dilation", "=", "dilation", ",", "\n", "groups", "=", "groups", ",", "\n", "base_width", "=", "base_width", ",", "\n", "style", "=", "style", ",", "\n", "with_cp", "=", "with_cp", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "dcn", "=", "dcn", ",", "\n", "gcb", "=", "gcb", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.optimizer_hook.DistOptimizerHook.__init__": [[10, 16], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "update_interval", "=", "1", ",", "grad_clip", "=", "None", ",", "coalesce", "=", "True", ",", "bucket_size_mb", "=", "-", "1", ",", "use_fp16", "=", "False", ")", ":", "\n", "        ", "self", ".", "grad_clip", "=", "grad_clip", "\n", "self", ".", "coalesce", "=", "coalesce", "\n", "self", ".", "bucket_size_mb", "=", "bucket_size_mb", "\n", "self", ".", "update_interval", "=", "update_interval", "\n", "self", ".", "use_fp16", "=", "use_fp16", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.optimizer_hook.DistOptimizerHook.before_run": [[17, 19], ["runner.optimizer.zero_grad"], "methods", ["None"], ["", "def", "before_run", "(", "self", ",", "runner", ")", ":", "\n", "        ", "runner", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.optimizer_hook.DistOptimizerHook.after_train_iter": [[20, 32], ["optimizer_hook.DistOptimizerHook.every_n_iters", "runner.outputs[].backward", "runner.optimizer.step", "runner.optimizer.zero_grad", "apex.amp.scale_loss", "scaled_loss.backward", "optimizer_hook.DistOptimizerHook.clip_grads", "runner.model.parameters"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.swap_align2nat._SwapAlign2Nat.backward", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.optimizers.LARS.step", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.swap_align2nat._SwapAlign2Nat.backward"], ["", "def", "after_train_iter", "(", "self", ",", "runner", ")", ":", "\n", "        ", "runner", ".", "outputs", "[", "'loss'", "]", "/=", "self", ".", "update_interval", "\n", "if", "self", ".", "use_fp16", ":", "\n", "            ", "with", "apex", ".", "amp", ".", "scale_loss", "(", "runner", ".", "outputs", "[", "'loss'", "]", ",", "runner", ".", "optimizer", ")", "as", "scaled_loss", ":", "\n", "                ", "scaled_loss", ".", "backward", "(", ")", "\n", "", "", "else", ":", "\n", "            ", "runner", ".", "outputs", "[", "'loss'", "]", ".", "backward", "(", ")", "\n", "", "if", "self", ".", "every_n_iters", "(", "runner", ",", "self", ".", "update_interval", ")", ":", "\n", "            ", "if", "self", ".", "grad_clip", "is", "not", "None", ":", "\n", "                ", "self", ".", "clip_grads", "(", "runner", ".", "model", ".", "parameters", "(", ")", ")", "\n", "", "runner", ".", "optimizer", ".", "step", "(", ")", "\n", "runner", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.optimizer_hook.NonDistOptimizerHook.__init__": [[37, 41], ["print"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "update_interval", "=", "1", ",", "grad_clip", "=", "None", ")", ":", "\n", "        ", "print", "(", "f\"Using update interval {update_interval}\"", ")", "\n", "self", ".", "update_interval", "=", "update_interval", "\n", "self", ".", "grad_clip", "=", "grad_clip", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.optimizer_hook.NonDistOptimizerHook.before_run": [[42, 44], ["runner.optimizer.zero_grad"], "methods", ["None"], ["", "def", "before_run", "(", "self", ",", "runner", ")", ":", "\n", "        ", "runner", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.optimizer_hook.NonDistOptimizerHook.after_train_iter": [[45, 53], ["runner.outputs[].backward", "optimizer_hook.NonDistOptimizerHook.every_n_iters", "runner.optimizer.step", "runner.optimizer.zero_grad", "optimizer_hook.NonDistOptimizerHook.clip_grads", "runner.model.parameters"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.layers.swap_align2nat._SwapAlign2Nat.backward", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.optimizers.LARS.step"], ["", "def", "after_train_iter", "(", "self", ",", "runner", ")", ":", "\n", "        ", "runner", ".", "outputs", "[", "'loss'", "]", "/=", "self", ".", "update_interval", "\n", "runner", ".", "outputs", "[", "'loss'", "]", ".", "backward", "(", ")", "\n", "if", "self", ".", "every_n_iters", "(", "runner", ",", "self", ".", "update_interval", ")", ":", "\n", "            ", "if", "self", ".", "grad_clip", "is", "not", "None", ":", "\n", "                ", "self", ".", "clip_grads", "(", "runner", ".", "model", ".", "parameters", "(", ")", ")", "\n", "", "runner", ".", "optimizer", ".", "step", "(", ")", "\n", "runner", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.odc_hook.ODCHook.__init__": [[24, 38], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "centroids_update_interval", ",", "\n", "deal_with_small_clusters_interval", ",", "\n", "evaluate_interval", ",", "\n", "reweight", ",", "\n", "reweight_pow", ",", "\n", "dist_mode", "=", "True", ")", ":", "\n", "        ", "assert", "dist_mode", ",", "\"non-dist mode is not implemented\"", "\n", "self", ".", "centroids_update_interval", "=", "centroids_update_interval", "\n", "self", ".", "deal_with_small_clusters_interval", "=", "deal_with_small_clusters_interval", "\n", "self", ".", "evaluate_interval", "=", "evaluate_interval", "\n", "self", ".", "reweight", "=", "reweight", "\n", "self", ".", "reweight_pow", "=", "reweight_pow", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.odc_hook.ODCHook.after_train_iter": [[39, 57], ["odc_hook.ODCHook.every_n_iters", "odc_hook.ODCHook.every_n_iters", "runner.model.module.set_reweight", "odc_hook.ODCHook.every_n_iters", "runner.model.module.memory_bank.update_centroids_memory", "runner.model.module.memory_bank.deal_with_small_clusters", "odc_hook.ODCHook.evaluate", "new_labels.cpu.cpu.cpu", "new_labels.cpu.cpu.numpy"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.deepcluster.DeepCluster.set_reweight", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory.update_centroids_memory", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory.deal_with_small_clusters", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.deepcluster_hook.DeepClusterHook.evaluate"], ["", "def", "after_train_iter", "(", "self", ",", "runner", ")", ":", "\n", "# centroids update", "\n", "        ", "if", "self", ".", "every_n_iters", "(", "runner", ",", "self", ".", "centroids_update_interval", ")", ":", "\n", "            ", "runner", ".", "model", ".", "module", ".", "memory_bank", ".", "update_centroids_memory", "(", ")", "\n", "\n", "# deal with small clusters", "\n", "", "if", "self", ".", "every_n_iters", "(", "runner", ",", "self", ".", "deal_with_small_clusters_interval", ")", ":", "\n", "            ", "runner", ".", "model", ".", "module", ".", "memory_bank", ".", "deal_with_small_clusters", "(", ")", "\n", "\n", "# reweight", "\n", "", "runner", ".", "model", ".", "module", ".", "set_reweight", "(", ")", "\n", "\n", "# evaluate", "\n", "if", "self", ".", "every_n_iters", "(", "runner", ",", "self", ".", "evaluate_interval", ")", ":", "\n", "            ", "new_labels", "=", "runner", ".", "model", ".", "module", ".", "memory_bank", ".", "label_bank", "\n", "if", "new_labels", ".", "is_cuda", ":", "\n", "                ", "new_labels", "=", "new_labels", ".", "cpu", "(", ")", "\n", "", "self", ".", "evaluate", "(", "runner", ",", "new_labels", ".", "numpy", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.odc_hook.ODCHook.after_train_epoch": [[58, 68], ["odc_hook.ODCHook.every_n_epochs", "numpy.save", "new_labels.cpu.cpu.cpu", "new_labels.cpu.cpu.numpy"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save"], ["", "", "def", "after_train_epoch", "(", "self", ",", "runner", ")", ":", "\n", "# save cluster", "\n", "        ", "if", "self", ".", "every_n_epochs", "(", "runner", ",", "10", ")", "and", "runner", ".", "rank", "==", "0", ":", "\n", "            ", "new_labels", "=", "runner", ".", "model", ".", "module", ".", "memory_bank", ".", "label_bank", "\n", "if", "new_labels", ".", "is_cuda", ":", "\n", "                ", "new_labels", "=", "new_labels", ".", "cpu", "(", ")", "\n", "", "np", ".", "save", "(", "\n", "\"{}/cluster_epoch_{}.npy\"", ".", "format", "(", "runner", ".", "work_dir", ",", "\n", "runner", ".", "epoch", ")", ",", "\n", "new_labels", ".", "numpy", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.odc_hook.ODCHook.evaluate": [[69, 80], ["numpy.bincount", "numpy.bincount.min", "numpy.bincount.max", "odc_hook.ODCHook.utils.print_log", "empty_cls.item", "minimal_cls_size.item", "maximal_cls_size.item"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.print_log"], ["", "", "def", "evaluate", "(", "self", ",", "runner", ",", "new_labels", ")", ":", "\n", "        ", "hist", "=", "np", ".", "bincount", "(", "\n", "new_labels", ",", "minlength", "=", "runner", ".", "model", ".", "module", ".", "memory_bank", ".", "num_classes", ")", "\n", "empty_cls", "=", "(", "hist", "==", "0", ")", ".", "sum", "(", ")", "\n", "minimal_cls_size", ",", "maximal_cls_size", "=", "hist", ".", "min", "(", ")", ",", "hist", ".", "max", "(", ")", "\n", "if", "runner", ".", "rank", "==", "0", ":", "\n", "            ", "print_log", "(", "\n", "\"empty_num: {}\\tmin_cluster: {}\\tmax_cluster:{}\"", ".", "format", "(", "\n", "empty_cls", ".", "item", "(", ")", ",", "minimal_cls_size", ".", "item", "(", ")", ",", "\n", "maximal_cls_size", ".", "item", "(", ")", ")", ",", "\n", "logger", "=", "'root'", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.validate_hook.ValidateHook.__init__": [[25, 55], ["isinstance", "eval_kwargs.get", "eval_kwargs.get", "datasets.build_dataloader", "isinstance", "datasets.build_dataset", "TypeError", "eval_kwargs.get", "eval_kwargs.get", "dict", "type"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.build_loader.build_dataloader", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.builder.build_dataset", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.model_zoo.model_zoo.get"], ["def", "__init__", "(", "self", ",", "\n", "dataset", ",", "\n", "dist_mode", "=", "True", ",", "\n", "initial", "=", "True", ",", "\n", "interval", "=", "1", ",", "\n", "**", "eval_kwargs", ")", ":", "\n", "        ", "from", "openselfsup", "import", "datasets", "\n", "if", "isinstance", "(", "dataset", ",", "Dataset", ")", ":", "\n", "            ", "self", ".", "dataset", "=", "dataset", "\n", "", "elif", "isinstance", "(", "dataset", ",", "dict", ")", ":", "\n", "            ", "self", ".", "dataset", "=", "datasets", ".", "build_dataset", "(", "dataset", ")", "\n", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "\n", "'dataset must be a Dataset object or a dict, not {}'", ".", "format", "(", "\n", "type", "(", "dataset", ")", ")", ")", "\n", "", "self", ".", "run_after_epoch", "=", "eval_kwargs", ".", "get", "(", "'by_epoch'", ",", "True", ")", "\n", "self", ".", "val_name", "=", "eval_kwargs", ".", "get", "(", "'name'", ",", "\"unnamed-val-hook\"", ")", "\n", "self", ".", "data_loader", "=", "datasets", ".", "build_dataloader", "(", "\n", "self", ".", "dataset", ",", "\n", "eval_kwargs", "[", "'imgs_per_gpu'", "]", ",", "\n", "eval_kwargs", "[", "'workers_per_gpu'", "]", ",", "\n", "dist", "=", "dist_mode", ",", "\n", "shuffle", "=", "False", ",", "\n", "prefetch", "=", "eval_kwargs", ".", "get", "(", "'prefetch'", ",", "False", ")", ",", "\n", "img_norm_cfg", "=", "eval_kwargs", ".", "get", "(", "'img_norm_cfg'", ",", "dict", "(", ")", ")", ",", "\n", ")", "\n", "self", ".", "dist_mode", "=", "dist_mode", "\n", "self", ".", "initial", "=", "initial", "\n", "self", ".", "interval", "=", "interval", "\n", "self", ".", "eval_kwargs", "=", "eval_kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.validate_hook.ValidateHook.before_run": [[56, 59], ["validate_hook.ValidateHook._run_validate"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.validate_hook.ValidateHook._run_validate"], ["", "def", "before_run", "(", "self", ",", "runner", ")", ":", "\n", "        ", "if", "self", ".", "initial", ":", "\n", "            ", "self", ".", "_run_validate", "(", "runner", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.validate_hook.ValidateHook.after_train_epoch": [[60, 66], ["validate_hook.ValidateHook._run_validate", "validate_hook.ValidateHook.every_n_epochs"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.validate_hook.ValidateHook._run_validate"], ["", "", "def", "after_train_epoch", "(", "self", ",", "runner", ")", ":", "\n", "        ", "if", "not", "self", ".", "run_after_epoch", ":", "\n", "            ", "return", "\n", "", "if", "not", "self", ".", "every_n_epochs", "(", "runner", ",", "self", ".", "interval", ")", ":", "\n", "            ", "return", "\n", "", "self", ".", "_run_validate", "(", "runner", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.validate_hook.ValidateHook.after_train_iter": [[67, 73], ["validate_hook.ValidateHook._run_validate", "validate_hook.ValidateHook.every_n_iters"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.validate_hook.ValidateHook._run_validate"], ["", "def", "after_train_iter", "(", "self", ",", "runner", ")", ":", "\n", "        ", "if", "self", ".", "run_after_epoch", ":", "\n", "            ", "return", "\n", "", "if", "not", "self", ".", "every_n_iters", "(", "runner", ",", "self", ".", "interval", ")", ":", "\n", "            ", "return", "\n", "", "self", ".", "_run_validate", "(", "runner", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.validate_hook.ValidateHook._run_validate": [[74, 88], ["runner.model.eval", "runner.model.train", "runner.model", "validate_hook.ValidateHook.utils.dist_forward_collect", "validate_hook.ValidateHook.utils.nondist_forward_collect", "validate_hook.ValidateHook.utils.nondist_forward_collect.items", "len", "len", "validate_hook.ValidateHook._evaluate", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect.dist_forward_collect", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect.nondist_forward_collect", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.validate_hook.ValidateHook._evaluate"], ["", "def", "_run_validate", "(", "self", ",", "runner", ")", ":", "\n", "        ", "runner", ".", "model", ".", "eval", "(", ")", "\n", "func", "=", "lambda", "**", "x", ":", "runner", ".", "model", "(", "mode", "=", "'test'", ",", "**", "x", ")", "\n", "if", "self", ".", "dist_mode", ":", "\n", "            ", "results", "=", "dist_forward_collect", "(", "\n", "func", ",", "self", ".", "data_loader", ",", "runner", ".", "rank", ",", "\n", "len", "(", "self", ".", "dataset", ")", ")", "# dict{key: np.ndarray}", "\n", "", "else", ":", "\n", "            ", "results", "=", "nondist_forward_collect", "(", "func", ",", "self", ".", "data_loader", ",", "\n", "len", "(", "self", ".", "dataset", ")", ")", "\n", "", "if", "runner", ".", "rank", "==", "0", ":", "\n", "            ", "for", "name", ",", "val", "in", "results", ".", "items", "(", ")", ":", "\n", "                ", "self", ".", "_evaluate", "(", "runner", ",", "torch", ".", "from_numpy", "(", "val", ")", ",", "name", ")", "\n", "", "", "runner", ".", "model", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.validate_hook.ValidateHook._evaluate": [[89, 98], ["validate_hook.ValidateHook.dataset.evaluate", "validate_hook.ValidateHook.items"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.deepcluster_hook.DeepClusterHook.evaluate"], ["", "def", "_evaluate", "(", "self", ",", "runner", ",", "results", ",", "keyword", ")", ":", "\n", "        ", "eval_res", "=", "self", ".", "dataset", ".", "evaluate", "(", "\n", "results", ",", "\n", "keyword", "=", "keyword", ",", "\n", "logger", "=", "runner", ".", "logger", ",", "\n", "**", "self", ".", "eval_kwargs", "[", "'eval_param'", "]", ")", "\n", "for", "name", ",", "val", "in", "eval_res", ".", "items", "(", ")", ":", "\n", "            ", "runner", ".", "log_buffer", ".", "output", "[", "\"{}-{}\"", ".", "format", "(", "self", ".", "val_name", ",", "name", ")", "]", "=", "val", "\n", "", "runner", ".", "log_buffer", ".", "ready", "=", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.extractor.Extractor.__init__": [[20, 42], ["isinstance", "datasets.build_dataloader", "torch.AdaptiveAvgPool2d", "isinstance", "datasets.build_dataset", "TypeError", "type"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.build_loader.build_dataloader", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.builder.build_dataset"], ["        ", "return", "instances", ".", "scores", "if", "select", "is", "None", "else", "instances", ".", "scores", "[", "select", "]", "\n", "", "return", "None", "\n", "\n", "\n", "", "def", "extract_boxes_xywh_from_instances", "(", "instances", ":", "Instances", ",", "select", "=", "None", ")", ":", "\n", "    ", "if", "instances", ".", "has", "(", "\"pred_boxes\"", ")", ":", "\n", "        ", "boxes_xywh", "=", "instances", ".", "pred_boxes", ".", "tensor", ".", "clone", "(", ")", "\n", "boxes_xywh", "[", ":", ",", "2", "]", "-=", "boxes_xywh", "[", ":", ",", "0", "]", "\n", "boxes_xywh", "[", ":", ",", "3", "]", "-=", "boxes_xywh", "[", ":", ",", "1", "]", "\n", "return", "boxes_xywh", "if", "select", "is", "None", "else", "boxes_xywh", "[", "select", "]", "\n", "", "return", "None", "\n", "\n", "\n", "", "def", "create_extractor", "(", "visualizer", ":", "object", ")", ":", "\n", "    ", "\"\"\"\n    Create an extractor for the provided visualizer\n    \"\"\"", "\n", "if", "isinstance", "(", "visualizer", ",", "CompoundVisualizer", ")", ":", "\n", "        ", "extractors", "=", "[", "create_extractor", "(", "v", ")", "for", "v", "in", "visualizer", ".", "visualizers", "]", "\n", "return", "CompoundExtractor", "(", "extractors", ")", "\n", "", "elif", "isinstance", "(", "visualizer", ",", "DensePoseResultsVisualizer", ")", ":", "\n", "        ", "return", "DensePoseResultExtractor", "(", ")", "\n", "", "elif", "isinstance", "(", "visualizer", ",", "ScoredBoundingBoxVisualizer", ")", ":", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.extractor.Extractor._forward_func": [[43, 48], ["runner.model", "last_layer_feat.view.view.view", "dict", "runner.model.module.neck", "last_layer_feat.view.view.size", "last_layer_feat.view.view.cpu"], "methods", ["None"], ["        ", "return", "CompoundExtractor", "(", "[", "extract_boxes_xywh_from_instances", ",", "extract_scores_from_instances", "]", ")", "\n", "", "elif", "isinstance", "(", "visualizer", ",", "BoundingBoxVisualizer", ")", ":", "\n", "        ", "return", "extract_boxes_xywh_from_instances", "\n", "", "else", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "error", "(", "f\"Could not create extractor for {visualizer}\"", ")", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.extractor.Extractor.__call__": [[49, 62], ["extractor.Extractor._forward_func", "extractor.Extractor.utils.dist_forward_collect", "extractor.Extractor.utils.nondist_forward_collect", "len", "len"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.extractor.Extractor._forward_func", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect.dist_forward_collect", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.collect.nondist_forward_collect"], ["return", "None", "\n", "\n", "\n", "", "", "class", "BoundingBoxExtractor", "(", "object", ")", ":", "\n", "    ", "\"\"\"\n    Extracts bounding boxes from instances\n    \"\"\"", "\n", "\n", "def", "__call__", "(", "self", ",", "instances", ":", "Instances", ")", ":", "\n", "        ", "boxes_xywh", "=", "extract_boxes_xywh_from_instances", "(", "instances", ")", "\n", "return", "boxes_xywh", "\n", "\n", "\n", "", "", "class", "ScoredBoundingBoxExtractor", "(", "object", ")", ":", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.deepcluster_hook.DeepClusterHook.__init__": [[32, 55], ["extractor.Extractor", "deepcluster_hook.DeepClusterHook.third_party.clustering.pop"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "extractor", ",", "\n", "clustering", ",", "\n", "unif_sampling", ",", "\n", "reweight", ",", "\n", "reweight_pow", ",", "\n", "init_memory", "=", "False", ",", "# for ODC", "\n", "initial", "=", "True", ",", "\n", "interval", "=", "1", ",", "\n", "dist_mode", "=", "True", ",", "\n", "data_loaders", "=", "None", ")", ":", "\n", "        ", "self", ".", "extractor", "=", "Extractor", "(", "dist_mode", "=", "dist_mode", ",", "**", "extractor", ")", "\n", "self", ".", "clustering_type", "=", "clustering", ".", "pop", "(", "'type'", ")", "\n", "self", ".", "clustering_cfg", "=", "clustering", "\n", "self", ".", "unif_sampling", "=", "unif_sampling", "\n", "self", ".", "reweight", "=", "reweight", "\n", "self", ".", "reweight_pow", "=", "reweight_pow", "\n", "self", ".", "init_memory", "=", "init_memory", "\n", "self", ".", "initial", "=", "initial", "\n", "self", ".", "interval", "=", "interval", "\n", "self", ".", "dist_mode", "=", "dist_mode", "\n", "self", ".", "data_loaders", "=", "data_loaders", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.deepcluster_hook.DeepClusterHook.before_run": [[56, 59], ["deepcluster_hook.DeepClusterHook.deepcluster"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.deepcluster_hook.DeepClusterHook.deepcluster"], ["", "def", "before_run", "(", "self", ",", "runner", ")", ":", "\n", "        ", "if", "self", ".", "initial", ":", "\n", "            ", "self", ".", "deepcluster", "(", "runner", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.deepcluster_hook.DeepClusterHook.after_train_epoch": [[60, 64], ["deepcluster_hook.DeepClusterHook.deepcluster", "deepcluster_hook.DeepClusterHook.every_n_epochs"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.deepcluster_hook.DeepClusterHook.deepcluster"], ["", "", "def", "after_train_epoch", "(", "self", ",", "runner", ")", ":", "\n", "        ", "if", "not", "self", ".", "every_n_epochs", "(", "runner", ",", "self", ".", "interval", ")", ":", "\n", "            ", "return", "\n", "", "self", ".", "deepcluster", "(", "runner", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.deepcluster_hook.DeepClusterHook.deepcluster": [[65, 114], ["runner.model.eval", "deepcluster_hook.DeepClusterHook.extractor", "runner.model.train", "list", "deepcluster_hook.DeepClusterHook.data_loaders[].dataset.assign_labels", "runner.model.module.head.init_weights", "clustering_algo.cluster", "isinstance", "clustering_algo.labels.astype", "numpy.save", "deepcluster_hook.DeepClusterHook.evaluate", "numpy.zeros", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.broadcast", "torch.broadcast", "torch.from_numpy().cuda.cpu().numpy", "torch.from_numpy().cuda.cpu().numpy", "deepcluster_hook.DeepClusterHook.data_loaders[].sampler.set_uniform_indices", "runner.model.module.set_reweight", "runner.model.module.head.state_dict().values", "runner.model.module.memory_bank.init_memory", "torch.broadcast", "torch.broadcast", "len", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy().cuda.cpu", "torch.from_numpy().cuda.cpu", "runner.model.module.head.state_dict"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.train", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.datasets.deepcluster.DeepClusterDataset.assign_labels", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.backbones.resnet.ResNet.init_weights", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.third_party.clustering.PIC.cluster", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.deepcluster_hook.DeepClusterHook.evaluate", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.alias_multinomial.AliasMethod.cuda", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.loader.sampler.DistributedGivenIterationSampler.set_uniform_indices", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.deepcluster.DeepCluster.set_reweight", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.memories.odc_memory.ODCMemory.init_memory"], ["", "def", "deepcluster", "(", "self", ",", "runner", ")", ":", "\n", "# step 1: get features", "\n", "        ", "runner", ".", "model", ".", "eval", "(", ")", "\n", "features", "=", "self", ".", "extractor", "(", "runner", ")", "\n", "runner", ".", "model", ".", "train", "(", ")", "\n", "\n", "# step 2: get labels", "\n", "if", "not", "self", ".", "dist_mode", "or", "(", "self", ".", "dist_mode", "and", "runner", ".", "rank", "==", "0", ")", ":", "\n", "            ", "clustering_algo", "=", "_clustering", ".", "__dict__", "[", "self", ".", "clustering_type", "]", "(", "\n", "**", "self", ".", "clustering_cfg", ")", "\n", "# Features are normalized during clustering", "\n", "clustering_algo", ".", "cluster", "(", "features", ",", "verbose", "=", "True", ")", "\n", "assert", "isinstance", "(", "clustering_algo", ".", "labels", ",", "np", ".", "ndarray", ")", "\n", "new_labels", "=", "clustering_algo", ".", "labels", ".", "astype", "(", "np", ".", "int64", ")", "\n", "np", ".", "save", "(", "\n", "\"{}/cluster_epoch_{}.npy\"", ".", "format", "(", "runner", ".", "work_dir", ",", "\n", "runner", ".", "epoch", ")", ",", "new_labels", ")", "\n", "self", ".", "evaluate", "(", "runner", ",", "new_labels", ")", "\n", "", "else", ":", "\n", "            ", "new_labels", "=", "np", ".", "zeros", "(", "(", "len", "(", "self", ".", "data_loaders", "[", "0", "]", ".", "dataset", ")", ",", ")", ",", "\n", "dtype", "=", "np", ".", "int64", ")", "\n", "\n", "", "if", "self", ".", "dist_mode", ":", "\n", "            ", "new_labels_tensor", "=", "torch", ".", "from_numpy", "(", "new_labels", ")", ".", "cuda", "(", ")", "\n", "dist", ".", "broadcast", "(", "new_labels_tensor", ",", "0", ")", "\n", "new_labels", "=", "new_labels_tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "new_labels_list", "=", "list", "(", "new_labels", ")", "\n", "\n", "# step 3: assign new labels", "\n", "self", ".", "data_loaders", "[", "0", "]", ".", "dataset", ".", "assign_labels", "(", "new_labels_list", ")", "\n", "\n", "# step 4 (a): set uniform sampler", "\n", "if", "self", ".", "unif_sampling", ":", "\n", "            ", "self", ".", "data_loaders", "[", "0", "]", ".", "sampler", ".", "set_uniform_indices", "(", "\n", "new_labels_list", ",", "self", ".", "clustering_cfg", ".", "k", ")", "\n", "\n", "# step 4 (b): set loss reweight", "\n", "", "if", "self", ".", "reweight", ":", "\n", "            ", "runner", ".", "model", ".", "module", ".", "set_reweight", "(", "new_labels", ",", "self", ".", "reweight_pow", ")", "\n", "\n", "# step 5: randomize classifier", "\n", "", "runner", ".", "model", ".", "module", ".", "head", ".", "init_weights", "(", "init_linear", "=", "'normal'", ")", "\n", "if", "self", ".", "dist_mode", ":", "\n", "            ", "for", "p", "in", "runner", ".", "model", ".", "module", ".", "head", ".", "state_dict", "(", ")", ".", "values", "(", ")", ":", "\n", "                ", "dist", ".", "broadcast", "(", "p", ",", "0", ")", "\n", "\n", "# step 6: init memory for ODC", "\n", "", "", "if", "self", ".", "init_memory", ":", "\n", "            ", "runner", ".", "model", ".", "module", ".", "memory_bank", ".", "init_memory", "(", "features", ",", "new_labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.deepcluster_hook.DeepClusterHook.evaluate": [[115, 125], ["numpy.bincount", "numpy.bincount.min", "numpy.bincount.max", "deepcluster_hook.DeepClusterHook.utils.print_log", "empty_cls.item", "minimal_cls_size.item", "maximal_cls_size.item"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.logger.print_log"], ["", "", "def", "evaluate", "(", "self", ",", "runner", ",", "new_labels", ")", ":", "\n", "        ", "hist", "=", "np", ".", "bincount", "(", "new_labels", ",", "minlength", "=", "self", ".", "clustering_cfg", ".", "k", ")", "\n", "empty_cls", "=", "(", "hist", "==", "0", ")", ".", "sum", "(", ")", "\n", "minimal_cls_size", ",", "maximal_cls_size", "=", "hist", ".", "min", "(", ")", ",", "hist", ".", "max", "(", ")", "\n", "if", "runner", ".", "rank", "==", "0", ":", "\n", "            ", "print_log", "(", "\n", "\"empty_num: {}\\tmin_cluster: {}\\tmax_cluster:{}\"", ".", "format", "(", "\n", "empty_cls", ".", "item", "(", ")", ",", "minimal_cls_size", ".", "item", "(", ")", ",", "\n", "maximal_cls_size", ".", "item", "(", ")", ")", ",", "\n", "logger", "=", "'root'", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.builder.build_hook": [[6, 8], ["openselfsup.utils.build_from_cfg"], "function", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.utils.registry.build_from_cfg"], ["\n", "\n", "def", "_concat_dataset", "(", "cfg", ",", "default_args", "=", "None", ")", ":", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.__init__": [[21, 24], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "end_momentum", "=", "1.", ",", "update_interval", "=", "1", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "end_momentum", "=", "end_momentum", "\n", "self", ".", "update_interval", "=", "update_interval", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.before_train_iter": [[25, 37], ["hasattr", "hasattr", "byol_hook.BYOLHook.every_n_iters", "math.cos", "float"], "methods", ["None"], ["", "def", "before_train_iter", "(", "self", ",", "runner", ")", ":", "\n", "        ", "assert", "hasattr", "(", "runner", ".", "model", ".", "module", ",", "'momentum'", ")", ",", "\"The runner must have attribute \\\"momentum\\\" in BYOLHook.\"", "\n", "assert", "hasattr", "(", "runner", ".", "model", ".", "module", ",", "'base_momentum'", ")", ",", "\"The runner must have attribute \\\"base_momentum\\\" in BYOLHook.\"", "\n", "if", "self", ".", "every_n_iters", "(", "runner", ",", "self", ".", "update_interval", ")", ":", "\n", "            ", "cur_iter", "=", "runner", ".", "iter", "\n", "max_iter", "=", "runner", ".", "max_iters", "\n", "base_m", "=", "runner", ".", "model", ".", "module", ".", "base_momentum", "\n", "m", "=", "self", ".", "end_momentum", "-", "(", "self", ".", "end_momentum", "-", "base_m", ")", "*", "(", "\n", "cos", "(", "pi", "*", "cur_iter", "/", "float", "(", "max_iter", ")", ")", "+", "1", ")", "/", "2", "\n", "runner", ".", "model", ".", "module", ".", "momentum", "=", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.hooks.byol_hook.BYOLHook.after_train_iter": [[38, 44], ["byol_hook.BYOLHook.every_n_iters", "mmcv.parallel.is_module_wrapper", "runner.model.module.momentum_update", "runner.model.momentum_update"], "methods", ["home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BYOL.momentum_update", "home.repos.pwc.inspect_result.cjrd_self-supervised-pretraining.models.byol.BYOL.momentum_update"], ["", "", "def", "after_train_iter", "(", "self", ",", "runner", ")", ":", "\n", "        ", "if", "self", ".", "every_n_iters", "(", "runner", ",", "self", ".", "update_interval", ")", ":", "\n", "            ", "if", "is_module_wrapper", "(", "runner", ".", "model", ")", ":", "\n", "                ", "runner", ".", "model", ".", "module", ".", "momentum_update", "(", ")", "\n", "", "else", ":", "\n", "                ", "runner", ".", "model", ".", "momentum_update", "(", ")", "\n", "", "", "", "", ""]]}