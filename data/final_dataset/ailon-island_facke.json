{"home.repos.pwc.inspect_result.ailon-island_facke.None.finetune_DDPM.Transform.__init__": [[45, 47], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "Transform", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.None.finetune_DDPM.Transform.__call__": [[48, 50], ["None"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "*", "2", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.None.finetune_DDPM.DeTransform.__init__": [[54, 56], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "DeTransform", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.None.finetune_DDPM.DeTransform.__call__": [[57, 59], ["None"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "(", "x", "+", "1", ")", "/", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.None.finetune_DDPM.Trainer.__init__": [[63, 82], ["super().__init__", "os.path.join", "min", "print", "print", "len"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["    ", "def", "__init__", "(", "self", ",", "loader", ",", "model", ",", "opt", ",", "start_epoch", ",", "epoch_iter", ",", "visualizer", ")", ":", "\n", "        ", "super", "(", "Trainer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "opt", "=", "opt", "\n", "self", ".", "loader", "=", "loader", "\n", "self", ".", "losses", "=", "[", "]", "\n", "self", ".", "start_epoch", "=", "start_epoch", "\n", "self", ".", "start_epoch_iter", "=", "epoch_iter", "\n", "self", ".", "total_iter", "=", "(", "start_epoch", "-", "1", ")", "*", "len", "(", "loader", ")", "+", "epoch_iter", "\n", "self", ".", "memory_last", "=", "0", "\n", "self", ".", "memory_first", "=", "None", "\n", "self", ".", "visualizer", "=", "visualizer", "\n", "self", ".", "sample_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "checkpoints_dir", ",", "opt", ".", "name", ",", "'samples'", ",", "'train'", ")", "\n", "self", ".", "sample_size", "=", "min", "(", "8", ",", "opt", ".", "batchSize", ")", "\n", "\n", "if", "opt", ".", "verbose", ":", "\n", "            ", "print", "(", "'Trainer initialized.'", ")", "\n", "", "if", "opt", ".", "debug", ":", "\n", "            ", "print", "(", "'Model instance in trainer iter: {}.'", ".", "format", "(", "self", ".", "model", ".", "module", ".", "iter", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.None.finetune_DDPM.Trainer.train": [[83, 204], ["time.time", "enumerate", "print", "print", "finetune_DDPM.Trainer.model.train", "len", "model", "model.items", "finetune_DDPM.Trainer.model.module.optim.zero_grad", "loss_dict[].backward", "finetune_DDPM.Trainer.model.module.optim.step", "finetune_DDPM.Trainer.model.module.update_ema", "print", "time.time", "img_source.to.to.to", "visualizer.print_current_errors", "visualizer.plot_current_errors", "finetune_DDPM.Trainer.model.eval", "finetune_DDPM.Trainer.model.module.save", "finetune_DDPM.Trainer.model.module.save", "numpy.savetxt", "print", "print", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "sorted", "isinstance", "loss.detach().cpu().item", "os.path.exists", "os.mkdir", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "numpy.stack().transpose.append", "detransform().numpy", "range", "range", "print", "numpy.stack().transpose", "utils.utils.plot.plot_batch", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "isinstance", "model.items", "time.time", "torch.zeros_like.cpu().numpy", "torch.zeros_like.cpu().numpy", "torch.zeros_like.cpu().numpy", "numpy.stack().transpose.append", "numpy.stack().transpose.append", "img_source[].repeat", "finetune_DDPM.Trainer.model.module.swap", "detransform().numpy", "range", "os.path.join", "loss.detach().cpu", "detransform", "numpy.stack().transpose.append", "numpy.stack", "torch.zeros_like.cpu", "torch.zeros_like.cpu", "torch.zeros_like.cpu", "img_source.to.to.cpu", "detransform", "loss.detach", "detransform().numpy.cpu", "str", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.None.train_SimSwap.Trainer.train", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.zero_grad", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.MixedPrecisionTrainer.backward", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.update_ema", "home.repos.pwc.inspect_result.ailon-island_facke.utils.visualizer.Visualizer.print_current_errors", "home.repos.pwc.inspect_result.ailon-island_facke.utils.visualizer.Visualizer.plot_current_errors", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.save", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.save", "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.mkdir", "home.repos.pwc.inspect_result.ailon-island_facke.utils.plot.plot_batch", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.swap"], ["", "", "def", "train", "(", "self", ",", "epoch_idx", ")", ":", "\n", "        ", "opt", "=", "self", ".", "opt", "\n", "\n", "if", "opt", ".", "verbose", ":", "\n", "            ", "print", "(", "'Training...'", ")", "\n", "", "if", "opt", ".", "debug", ":", "\n", "            ", "print", "(", "'Model instance to be trained iter: {}.'", ".", "format", "(", "self", ".", "model", ".", "module", ".", "iter", ")", ")", "\n", "\n", "", "epoch_start_time", "=", "time", ".", "time", "(", ")", "\n", "epoch_iter", "=", "self", ".", "start_epoch_iter", "if", "epoch_idx", "==", "self", ".", "start_epoch", "else", "0", "\n", "visualizer", "=", "self", ".", "visualizer", "\n", "display_delta", "=", "self", ".", "total_iter", "%", "opt", ".", "display_freq", "\n", "print_delta", "=", "self", ".", "total_iter", "%", "opt", ".", "print_freq", "\n", "save_delta", "=", "self", ".", "total_iter", "%", "opt", ".", "save_latest_freq", "\n", "\n", "for", "batch_idx", ",", "(", "(", "img_source", ",", "_", ")", ",", "(", "_", ",", "_", ")", ",", "_", ")", "in", "enumerate", "(", "self", ".", "loader", ",", "start", "=", "1", ")", ":", "\n", "            ", "self", ".", "model", ".", "train", "(", ")", "\n", "if", "opt", ".", "debug", ":", "\n", "                ", "print", "(", "'Batch {}: model instance to be trained iter: {}.'", ".", "format", "(", "batch_idx", ",", "self", ".", "model", ".", "module", ".", "iter", ")", ")", "\n", "\n", "", "if", "self", ".", "total_iter", "%", "opt", ".", "print_freq", "==", "print_delta", ":", "\n", "                ", "iter_start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "", "if", "len", "(", "opt", ".", "gpu_ids", ")", ":", "\n", "                ", "img_source", "=", "img_source", ".", "to", "(", "'cuda'", ")", "\n", "\n", "# count iterations", "\n", "", "batch_size", "=", "img_source", ".", "shape", "[", "0", "]", "\n", "self", ".", "total_iter", "+=", "batch_size", "\n", "self", ".", "model", ".", "module", ".", "iter", "=", "self", ".", "total_iter", "\n", "epoch_iter", "+=", "batch_size", "\n", "\n", "########### FORWARD ###########", "\n", "loss_dict", "=", "model", "(", "img_source", ")", "\n", "\n", "############ LOSSES ############", "\n", "# gather losses", "\n", "for", "k", ",", "v", "in", "loss_dict", ".", "items", "(", ")", ":", "\n", "                ", "loss_dict", "[", "k", "]", "=", "torch", ".", "mean", "(", "v", ")", "if", "not", "isinstance", "(", "v", ",", "int", ")", "else", "v", "\n", "\n", "# loss dictionary", "\n", "# loss_dict = dict(zip(self.model.module.loss_names, losses))", "\n", "\n", "\n", "############ BACKWARD ############", "\n", "", "self", ".", "model", ".", "module", ".", "optim", ".", "zero_grad", "(", ")", "\n", "loss_dict", "[", "'loss'", "]", ".", "backward", "(", ")", "\n", "self", ".", "model", ".", "module", ".", "optim", ".", "step", "(", ")", "\n", "\n", "# save loss", "\n", "losses", "=", "[", "v", "for", "k", ",", "v", "in", "sorted", "(", "loss_dict", ".", "items", "(", ")", ")", "]", "\n", "losses", "=", "[", "loss", "if", "isinstance", "(", "loss", ",", "int", ")", "else", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "for", "loss", "in", "losses", "]", "\n", "self", ".", "losses", "+=", "[", "losses", "]", "\n", "\n", "# print result", "\n", "if", "self", ".", "total_iter", "%", "opt", ".", "print_freq", "==", "print_delta", ":", "\n", "                ", "errors", "=", "loss_dict", "\n", "avg_iter_time", "=", "(", "time", ".", "time", "(", ")", "-", "iter_start_time", ")", "/", "opt", ".", "print_freq", "\n", "visualizer", ".", "print_current_errors", "(", "epoch_idx", ",", "epoch_iter", ",", "errors", ",", "avg_iter_time", ")", "\n", "visualizer", ".", "plot_current_errors", "(", "errors", ",", "self", ".", "total_iter", ")", "\n", "\n", "# display images", "\n", "", "if", "self", ".", "total_iter", "%", "opt", ".", "display_freq", "==", "display_delta", ":", "\n", "                ", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "sample_path", ")", ":", "\n", "                    ", "os", ".", "mkdir", "(", "self", ".", "sample_path", ")", "\n", "\n", "", "self", ".", "model", ".", "eval", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "img_source", "=", "img_source", "[", ":", "self", ".", "sample_size", "]", "\n", "\n", "imgs", "=", "[", "]", "\n", "zero_img", "=", "(", "torch", ".", "zeros_like", "(", "img_source", "[", "0", ",", "...", "]", ")", ")", "\n", "imgs", ".", "append", "(", "zero_img", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "save_img", "=", "(", "detransform", "(", "img_source", ".", "cpu", "(", ")", ")", ")", ".", "numpy", "(", ")", "\n", "\n", "for", "r", "in", "range", "(", "self", ".", "sample_size", ")", ":", "\n", "                        ", "imgs", ".", "append", "(", "save_img", "[", "r", ",", "...", "]", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "self", ".", "sample_size", ")", ":", "\n", "                        ", "imgs", ".", "append", "(", "save_img", "[", "i", ",", "...", "]", ")", "\n", "\n", "image_infer", "=", "img_source", "[", "i", ",", "...", "]", ".", "repeat", "(", "self", ".", "sample_size", ",", "1", ",", "1", ",", "1", ")", "\n", "img_fake", "=", "self", ".", "model", ".", "module", ".", "swap", "(", "img_source", ",", "image_infer", ")", "\n", "img_fake", "=", "(", "detransform", "(", "img_fake", ".", "cpu", "(", ")", ")", ")", ".", "numpy", "(", ")", "\n", "\n", "for", "j", "in", "range", "(", "self", ".", "sample_size", ")", ":", "\n", "                            ", "imgs", ".", "append", "(", "img_fake", "[", "j", ",", "...", "]", ")", "\n", "\n", "", "", "print", "(", "\"Save test data for iter {}.\"", ".", "format", "(", "self", ".", "total_iter", ")", ")", "\n", "imgs", "=", "np", ".", "stack", "(", "imgs", ",", "axis", "=", "0", ")", ".", "transpose", "(", "0", ",", "2", ",", "3", ",", "1", ")", "\n", "plot_batch", "(", "imgs", ",", "os", ".", "path", ".", "join", "(", "self", ".", "sample_path", ",", "'step_'", "+", "str", "(", "self", ".", "total_iter", ")", "+", "'.jpg'", ")", ")", "\n", "\n", "# visuals = OrderedDict([('source_img', utils.tensor2im(img_target[0])),", "\n", "#                        ('id_img', utils.tensor2im(img_source[0])),", "\n", "#                        ('generated_img', utils.tensor2im(img_fake.data[0]))", "\n", "#                        ])", "\n", "# visualizer.display_current_results(visuals, epoch_idx, self.total_iter)", "\n", "\n", "# save model", "\n", "", "", "if", "(", "self", ".", "total_iter", "%", "opt", ".", "save_latest_freq", "==", "save_delta", ")", ":", "\n", "                ", "self", ".", "model", ".", "module", ".", "save", "(", "'latest'", ")", "\n", "self", ".", "model", ".", "module", ".", "save", "(", "'{}_iter'", ".", "format", "(", "self", ".", "total_iter", ")", ")", "\n", "np", ".", "savetxt", "(", "iter_path", ",", "(", "epoch_idx", ",", "epoch_iter", ")", ",", "delimiter", "=", "','", ",", "fmt", "=", "'%d'", ")", "\n", "\n", "# memory log", "\n", "", "if", "opt", ".", "memory_check", ":", "\n", "                ", "if", "self", ".", "memory_first", "is", "None", ":", "\n", "                    ", "self", ".", "memory_first", "=", "torch", ".", "cuda", ".", "memory_allocated", "(", ")", "\n", "", "print", "(", "\n", "\"Memory increase: {}MiB\"", ".", "format", "(", "(", "torch", ".", "cuda", ".", "memory_allocated", "(", ")", "-", "self", ".", "memory_last", ")", "/", "1024.", "/", "1024.", ")", ")", "\n", "print", "(", "\"Total memory increase: {}MiB\"", ".", "format", "(", "\n", "(", "torch", ".", "cuda", ".", "memory_allocated", "(", ")", "-", "self", ".", "memory_first", ")", "/", "1024.", "/", "1024.", ")", ")", "\n", "self", ".", "memory_last", "=", "torch", ".", "cuda", ".", "memory_allocated", "(", ")", "\n", "\n", "\n", "# update ema", "\n", "", "self", ".", "model", ".", "module", ".", "update_ema", "(", ")", "\n", "\n", "# early stop", "\n", "if", "epoch_iter", ">=", "opt", ".", "max_dataset_size", ":", "\n", "                ", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.None.finetune_DDPM.test": [[207, 287], ["time.time", "model.eval", "print", "enumerate", "utils.loss.get_loss_dict", "visualizer.print_current_errors_test", "visualizer.plot_current_errors_test", "print", "tqdm.tqdm", "len", "model", "model.items", "time.time", "img_source.to.to", "len", "min", "os.path.join", "torch.mean", "torch.mean", "torch.mean", "sorted", "isinstance", "loss.detach().cpu().item", "os.path.exists", "os.mkdir", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "np.stack().transpose.append", "detransform().numpy", "range", "range", "numpy.stack().transpose", "utils.plot.plot_batch", "isinstance", "model.items", "zip", "torch.zeros_like.cpu().numpy", "np.stack().transpose.append", "np.stack().transpose.append", "img_source[].repeat", "model.module.swap", "detransform().numpy", "range", "os.path.join", "loss.detach().cpu", "detransform", "np.stack().transpose.append", "numpy.stack", "torch.zeros_like.cpu", "img_source.to.cpu", "detransform", "loss.detach", "detransform().numpy.cpu", "str"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.get_loss_dict", "home.repos.pwc.inspect_result.ailon-island_facke.utils.visualizer.Visualizer.print_current_errors_test", "home.repos.pwc.inspect_result.ailon-island_facke.utils.visualizer.Visualizer.plot_current_errors_test", "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.mkdir", "home.repos.pwc.inspect_result.ailon-island_facke.utils.plot.plot_batch", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.swap"], ["", "", "", "", "def", "test", "(", "opt", ",", "model", ",", "loader", ",", "epoch_idx", ",", "total_iter", ",", "visualizer", ")", ":", "\n", "    ", "test_start_time", "=", "time", ".", "time", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "test_iter", "=", "0", "\n", "\n", "test_losses", "=", "[", "]", "\n", "\n", "print", "(", "'Testing...'", ")", "\n", "if", "opt", ".", "debug", ":", "\n", "        ", "print", "(", "'Model instance being tested iter: {}.'", ".", "format", "(", "model", ".", "module", ".", "iter", ")", ")", "\n", "", "for", "batch_idx", ",", "(", "(", "img_source", ",", "_", ")", ",", "(", "_", ",", "_", ")", ",", "_", ")", "in", "enumerate", "(", "\n", "tqdm", ".", "tqdm", "(", "loader", ")", ")", ":", "\n", "        ", "batch_size", "=", "img_source", ".", "shape", "[", "0", "]", "\n", "test_iter", "+=", "batch_size", "\n", "\n", "if", "len", "(", "opt", ".", "gpu_ids", ")", ":", "\n", "            ", "img_source", "=", "img_source", ".", "to", "(", "'cuda'", ")", "\n", "\n", "########### FORWARD ###########", "\n", "", "loss_dict", "=", "model", "(", "img_source", ")", "\n", "\n", "# gather losses", "\n", "for", "k", ",", "v", "in", "loss_dict", ".", "items", "(", ")", ":", "\n", "            ", "loss_dict", "[", "k", "]", "=", "torch", ".", "mean", "(", "v", ")", "if", "not", "isinstance", "(", "v", ",", "int", ")", "else", "v", "\n", "\n", "# save loss", "\n", "", "losses", "=", "[", "v", "for", "k", ",", "v", "in", "sorted", "(", "loss_dict", ".", "items", "(", ")", ")", "]", "\n", "losses", "=", "[", "loss", "if", "isinstance", "(", "loss", ",", "int", ")", "else", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "for", "loss", "in", "losses", "]", "\n", "if", "not", "len", "(", "test_losses", ")", ":", "\n", "            ", "test_losses", "=", "losses", "\n", "", "else", ":", "\n", "            ", "test_losses", "=", "[", "test_loss", "+", "loss", "*", "batch_size", "\n", "for", "test_loss", ",", "loss", "in", "zip", "(", "test_losses", ",", "losses", ")", "]", "\n", "\n", "# display images", "\n", "", "if", "batch_idx", "==", "0", ":", "\n", "            ", "sample_size", "=", "min", "(", "8", ",", "opt", ".", "batchSize", ")", "\n", "sample_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "checkpoints_dir", ",", "opt", ".", "name", ",", "'samples'", ",", "'test'", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "sample_path", ")", ":", "\n", "                ", "os", ".", "mkdir", "(", "sample_path", ")", "\n", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "img_source", "=", "img_source", "[", ":", "sample_size", "]", "\n", "\n", "imgs", "=", "[", "]", "\n", "zero_img", "=", "(", "torch", ".", "zeros_like", "(", "img_source", "[", "0", ",", "...", "]", ")", ")", "\n", "imgs", ".", "append", "(", "zero_img", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "save_img", "=", "(", "detransform", "(", "img_source", ".", "cpu", "(", ")", ")", ")", ".", "numpy", "(", ")", "\n", "\n", "for", "r", "in", "range", "(", "sample_size", ")", ":", "\n", "                    ", "imgs", ".", "append", "(", "save_img", "[", "r", ",", "...", "]", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "sample_size", ")", ":", "\n", "                    ", "imgs", ".", "append", "(", "save_img", "[", "i", ",", "...", "]", ")", "\n", "\n", "image_infer", "=", "img_source", "[", "i", ",", "...", "]", ".", "repeat", "(", "sample_size", ",", "1", ",", "1", ",", "1", ")", "\n", "img_fake", "=", "model", ".", "module", ".", "swap", "(", "img_source", ",", "image_infer", ")", "\n", "img_fake", "=", "(", "detransform", "(", "img_fake", ".", "cpu", "(", ")", ")", ")", ".", "numpy", "(", ")", "\n", "#", "\n", "# image_infer = img_source[i, ...].repeat(sample_size, 1, 1, 1)", "\n", "# img_fake = model.module.G(image_infer, latent_ID).cpu().numpy()", "\n", "\n", "for", "j", "in", "range", "(", "sample_size", ")", ":", "\n", "                        ", "imgs", ".", "append", "(", "img_fake", "[", "j", ",", "...", "]", ")", "\n", "\n", "", "", "imgs", "=", "np", ".", "stack", "(", "imgs", ",", "axis", "=", "0", ")", ".", "transpose", "(", "0", ",", "2", ",", "3", ",", "1", ")", "\n", "plot_batch", "(", "imgs", ",", "os", ".", "path", ".", "join", "(", "sample_path", ",", "'step_'", "+", "str", "(", "total_iter", ")", "+", "'.jpg'", ")", ")", "\n", "\n", "# early stop", "\n", "", "", "if", "test_iter", ">=", "opt", ".", "max_dataset_size", ":", "\n", "            ", "break", "\n", "\n", "# print result", "\n", "", "", "test_losses", "=", "[", "test_loss", "/", "test_iter", "for", "test_loss", "in", "test_losses", "]", "\n", "test_losses", "=", "get_loss_dict", "(", "model", ".", "module", ".", "loss_names", ",", "test_losses", ",", "opt", ")", "\n", "test_time", "=", "time", ".", "time", "(", ")", "-", "test_start_time", "\n", "visualizer", ".", "print_current_errors_test", "(", "epoch_idx", ",", "total_iter", ",", "test_losses", ",", "test_time", ")", "\n", "visualizer", ".", "plot_current_errors_test", "(", "test_losses", ",", "total_iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.None.demo_ILVR.Transform.__int__": [[26, 28], ["super().__int__"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.None.demo_ILVR.DeTransform.__int__"], ["    ", "def", "__int__", "(", "self", ")", ":", "\n", "        ", "super", "(", "Transform", ",", "self", ")", ".", "__int__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.None.demo_ILVR.Transform.__call__": [[29, 31], ["None"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "*", "2", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.None.demo_ILVR.DeTransform.__int__": [[35, 37], ["super().__int__"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.None.demo_ILVR.DeTransform.__int__"], ["    ", "def", "__int__", "(", "self", ")", ":", "\n", "        ", "super", "(", "DeTransform", ",", "self", ")", ".", "__int__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.None.demo_ILVR.DeTransform.__call__": [[38, 40], ["None"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "(", "x", "+", "1", ")", "/", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.None.train_CVAE.Trainer.__init__": [[33, 52], ["super().__init__", "os.path.join", "min", "print", "print", "len"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["    ", "def", "__init__", "(", "self", ",", "loader", ",", "model", ",", "opt", ",", "start_epoch", ",", "epoch_iter", ",", "visualizer", ")", ":", "\n", "        ", "super", "(", "Trainer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "opt", "=", "opt", "\n", "self", ".", "loader", "=", "loader", "\n", "self", ".", "losses", "=", "[", "]", "\n", "self", ".", "start_epoch", "=", "start_epoch", "\n", "self", ".", "start_epoch_iter", "=", "epoch_iter", "\n", "self", ".", "total_iter", "=", "(", "start_epoch", "-", "1", ")", "*", "len", "(", "loader", ")", "+", "epoch_iter", "\n", "self", ".", "memory_last", "=", "0", "\n", "self", ".", "memory_first", "=", "None", "\n", "self", ".", "visualizer", "=", "visualizer", "\n", "self", ".", "sample_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "checkpoints_dir", ",", "opt", ".", "name", ",", "'samples'", ",", "'train'", ")", "\n", "self", ".", "sample_size", "=", "min", "(", "8", ",", "opt", ".", "batchSize", ")", "\n", "\n", "if", "opt", ".", "verbose", ":", "\n", "            ", "print", "(", "'Trainer initialized.'", ")", "\n", "", "if", "opt", ".", "debug", ":", "\n", "            ", "print", "(", "'Model instance in trainer iter: {}.'", ".", "format", "(", "self", ".", "model", ".", "module", ".", "iter", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.None.train_CVAE.Trainer.train": [[54, 188], ["time.time", "enumerate", "print", "print", "train_CVAE.Trainer.model.train", "len", "len", "is_same_ID[].detach().item", "model", "utils.utils.loss.get_loss_dict", "train_CVAE.Trainer.model.module.optim.zero_grad", "loss_G.backward", "train_CVAE.Trainer.model.module.optim.step", "train_CVAE.Trainer.model.module.optim_D.zero_grad", "loss_D.backward", "train_CVAE.Trainer.model.module.optim_D.step", "print", "time.time", "utils.utils.loss.get_loss_dict", "visualizer.print_current_errors", "visualizer.plot_current_errors", "train_CVAE.Trainer.model.module.eval", "train_CVAE.Trainer.model.module.save", "train_CVAE.Trainer.model.module.save", "numpy.savetxt", "print", "print", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "img_target.to", "latent_ID.to", "is_same_ID[].detach", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "isinstance", "loss.detach().cpu().item", "os.path.exists", "os.mkdir", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "img_source[].to", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "numpy.stack().transpose.append", "detransformer_Arcface().numpy", "range", "range", "print", "numpy.stack().transpose", "utils.utils.plot.plot_batch", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "isinstance", "time.time", "torch.zeros_like.cpu().numpy", "torch.zeros_like.cpu().numpy", "numpy.stack().transpose.append", "numpy.stack().transpose.append", "img_source[].repeat", "model.module().cpu().numpy", "range", "os.path.join", "loss.detach().cpu", "detransformer_Arcface", "numpy.stack().transpose.append", "numpy.stack", "torch.zeros_like.cpu", "torch.zeros_like.cpu", "img_source[].to.cpu", "model.module().cpu", "loss.detach", "str", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "model.module"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.None.train_SimSwap.Trainer.train", "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.get_loss_dict", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.zero_grad", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.MixedPrecisionTrainer.backward", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.zero_grad", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.MixedPrecisionTrainer.backward", "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.get_loss_dict", "home.repos.pwc.inspect_result.ailon-island_facke.utils.visualizer.Visualizer.print_current_errors", "home.repos.pwc.inspect_result.ailon-island_facke.utils.visualizer.Visualizer.plot_current_errors", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.save", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.save", "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.mkdir", "home.repos.pwc.inspect_result.ailon-island_facke.utils.plot.plot_batch"], ["", "", "def", "train", "(", "self", ",", "epoch_idx", ")", ":", "\n", "        ", "opt", "=", "self", ".", "opt", "\n", "\n", "if", "opt", ".", "verbose", ":", "\n", "            ", "print", "(", "'Training...'", ")", "\n", "", "if", "opt", ".", "debug", ":", "\n", "            ", "print", "(", "'Model instance to be trained iter: {}.'", ".", "format", "(", "self", ".", "model", ".", "module", ".", "iter", ")", ")", "\n", "\n", "", "epoch_start_time", "=", "time", ".", "time", "(", ")", "\n", "epoch_iter", "=", "self", ".", "start_epoch_iter", "if", "epoch_idx", "==", "self", ".", "start_epoch", "else", "0", "\n", "visualizer", "=", "self", ".", "visualizer", "\n", "display_delta", "=", "self", ".", "total_iter", "%", "opt", ".", "display_freq", "\n", "print_delta", "=", "self", ".", "total_iter", "%", "opt", ".", "print_freq", "\n", "save_delta", "=", "self", ".", "total_iter", "%", "opt", ".", "save_latest_freq", "\n", "\n", "for", "batch_idx", ",", "(", "(", "img_source", ",", "img_target", ")", ",", "(", "latent_ID", ",", "_", ")", ",", "is_same_ID", ")", "in", "enumerate", "(", "self", ".", "loader", ",", "start", "=", "1", ")", ":", "\n", "            ", "self", ".", "model", ".", "train", "(", ")", "\n", "if", "opt", ".", "debug", ":", "\n", "                ", "print", "(", "'Batch {}: model instance to be trained iter: {}.'", ".", "format", "(", "batch_idx", ",", "self", ".", "model", ".", "module", ".", "iter", ")", ")", "\n", "\n", "", "if", "self", ".", "total_iter", "%", "opt", ".", "print_freq", "==", "print_delta", ":", "\n", "                ", "iter_start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "", "if", "len", "(", "opt", ".", "gpu_ids", ")", ":", "\n", "                ", "img_target", ",", "latent_ID", "=", "img_target", ".", "to", "(", "'cuda'", ")", ",", "latent_ID", ".", "to", "(", "'cuda'", ")", "\n", "\n", "\n", "# count iterations", "\n", "", "batch_size", "=", "len", "(", "is_same_ID", ")", "\n", "self", ".", "total_iter", "+=", "batch_size", "\n", "self", ".", "model", ".", "module", ".", "iter", "=", "self", ".", "total_iter", "\n", "epoch_iter", "+=", "batch_size", "\n", "\n", "\n", "is_same_ID", "=", "is_same_ID", "[", "0", "]", ".", "detach", "(", ")", ".", "item", "(", ")", "\n", "\n", "########### FORWARD ###########", "\n", "[", "losses", ",", "_", "]", "=", "model", "(", "img_target", ",", "latent_ID", ",", "is_same_ID", ")", "\n", "\n", "############ LOSSES ############", "\n", "# gather losses", "\n", "losses", "=", "[", "torch", ".", "mean", "(", "x", ")", "if", "not", "isinstance", "(", "x", ",", "int", ")", "else", "x", "for", "x", "in", "losses", "]", "\n", "\n", "# loss dictionary", "\n", "# loss_dict = dict(zip(self.model.module.loss_names, losses))", "\n", "loss_dict", "=", "get_loss_dict", "(", "self", ".", "model", ".", "module", ".", "loss_names", ",", "losses", ",", "opt", ")", "\n", "\n", "# calculate final loss scalar", "\n", "loss_G", "=", "loss_dict", "[", "'G_GAN'", "]", "+", "loss_dict", "[", "'G_Rec'", "]", "+", "loss_dict", "[", "'G_KL'", "]", "+", "loss_dict", "[", "'G_ID'", "]", "\n", "loss_D", "=", "loss_dict", "[", "'D_real'", "]", "+", "loss_dict", "[", "'D_fake'", "]", "+", "loss_dict", "[", "'D_GP'", "]", "\n", "\n", "\n", "############ BACKWARD ############", "\n", "self", ".", "model", ".", "module", ".", "optim", ".", "zero_grad", "(", ")", "\n", "loss_G", ".", "backward", "(", ")", "\n", "self", ".", "model", ".", "module", ".", "optim", ".", "step", "(", ")", "\n", "self", ".", "model", ".", "module", ".", "optim_D", ".", "zero_grad", "(", ")", "\n", "loss_D", ".", "backward", "(", ")", "\n", "self", ".", "model", ".", "module", ".", "optim_D", ".", "step", "(", ")", "\n", "\n", "# save loss", "\n", "losses", "=", "[", "loss", "if", "isinstance", "(", "loss", ",", "int", ")", "else", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "for", "loss", "in", "losses", "]", "\n", "self", ".", "losses", "+=", "[", "losses", "]", "\n", "\n", "# print result", "\n", "if", "self", ".", "total_iter", "%", "opt", ".", "print_freq", "==", "print_delta", ":", "\n", "                ", "errors", "=", "get_loss_dict", "(", "self", ".", "model", ".", "module", ".", "loss_names", ",", "losses", ",", "opt", ")", "\n", "avg_iter_time", "=", "(", "time", ".", "time", "(", ")", "-", "iter_start_time", ")", "/", "opt", ".", "print_freq", "\n", "visualizer", ".", "print_current_errors", "(", "epoch_idx", ",", "epoch_iter", ",", "errors", ",", "avg_iter_time", ")", "\n", "visualizer", ".", "plot_current_errors", "(", "errors", ",", "self", ".", "total_iter", ")", "\n", "\n", "# display images", "\n", "", "if", "self", ".", "total_iter", "%", "opt", ".", "display_freq", "==", "display_delta", ":", "\n", "                ", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "sample_path", ")", ":", "\n", "                    ", "os", ".", "mkdir", "(", "self", ".", "sample_path", ")", "\n", "", "'''\n                self.model.module.M1.eval()\n                self.model.module.E.eval()\n                self.model.module.M2.eval()\n                self.model.module.D.eval()\n                '''", "\n", "self", ".", "model", ".", "module", ".", "eval", "(", ")", "\n", "self", ".", "model", ".", "module", ".", "isTrain", "=", "False", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "img_source", "=", "img_source", "[", ":", "self", ".", "sample_size", "]", ".", "to", "(", "'cuda'", ")", "\n", "latent_ID", "=", "latent_ID", "[", ":", "self", ".", "sample_size", "]", "\n", "\n", "imgs", "=", "[", "]", "\n", "zero_img", "=", "(", "torch", ".", "zeros_like", "(", "img_source", "[", "0", ",", "...", "]", ")", ")", "\n", "imgs", ".", "append", "(", "zero_img", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "save_img", "=", "(", "detransformer_Arcface", "(", "img_source", ".", "cpu", "(", ")", ")", ")", ".", "numpy", "(", ")", "\n", "\n", "for", "r", "in", "range", "(", "self", ".", "sample_size", ")", ":", "\n", "                        ", "imgs", ".", "append", "(", "save_img", "[", "r", ",", "...", "]", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "self", ".", "sample_size", ")", ":", "\n", "                        ", "imgs", ".", "append", "(", "save_img", "[", "i", ",", "...", "]", ")", "\n", "\n", "image_infer", "=", "img_source", "[", "i", ",", "...", "]", ".", "repeat", "(", "self", ".", "sample_size", ",", "1", ",", "1", ",", "1", ")", "\n", "img_fake", "=", "model", ".", "module", "(", "image_infer", ",", "latent_ID", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "for", "j", "in", "range", "(", "self", ".", "sample_size", ")", ":", "\n", "                            ", "imgs", ".", "append", "(", "img_fake", "[", "j", ",", "...", "]", ")", "\n", "\n", "", "", "print", "(", "\"Save test data for iter {}.\"", ".", "format", "(", "self", ".", "total_iter", ")", ")", "\n", "imgs", "=", "np", ".", "stack", "(", "imgs", ",", "axis", "=", "0", ")", ".", "transpose", "(", "0", ",", "2", ",", "3", ",", "1", ")", "\n", "plot_batch", "(", "imgs", ",", "os", ".", "path", ".", "join", "(", "self", ".", "sample_path", ",", "'step_'", "+", "str", "(", "self", ".", "total_iter", ")", "+", "'.jpg'", ")", ")", "\n", "", "self", ".", "model", ".", "module", ".", "isTrain", "=", "True", "\n", "\n", "\n", "# visuals = OrderedDict([('source_img', utils.tensor2im(img_target[0])),", "\n", "#                        ('id_img', utils.tensor2im(img_source[0])),", "\n", "#                        ('generated_img', utils.tensor2im(img_fake.data[0]))", "\n", "#                        ])", "\n", "# visualizer.display_current_results(visuals, epoch_idx, self.total_iter)", "\n", "\n", "# save model", "\n", "", "if", "(", "self", ".", "total_iter", "%", "opt", ".", "save_latest_freq", "==", "save_delta", ")", ":", "\n", "                ", "self", ".", "model", ".", "module", ".", "save", "(", "'latest'", ")", "\n", "self", ".", "model", ".", "module", ".", "save", "(", "'{}_iter'", ".", "format", "(", "self", ".", "total_iter", ")", ")", "\n", "np", ".", "savetxt", "(", "iter_path", ",", "(", "epoch_idx", ",", "epoch_iter", ")", ",", "delimiter", "=", "','", ",", "fmt", "=", "'%d'", ")", "\n", "\n", "# memory log", "\n", "", "if", "opt", ".", "memory_check", ":", "\n", "                ", "if", "self", ".", "memory_first", "is", "None", ":", "\n", "                    ", "self", ".", "memory_first", "=", "torch", ".", "cuda", ".", "memory_allocated", "(", ")", "\n", "", "print", "(", "\"Memory increase: {}MiB\"", ".", "format", "(", "(", "torch", ".", "cuda", ".", "memory_allocated", "(", ")", "-", "self", ".", "memory_last", ")", "/", "1024.", "/", "1024.", ")", ")", "\n", "print", "(", "\"Total memory increase: {}MiB\"", ".", "format", "(", "\n", "(", "torch", ".", "cuda", ".", "memory_allocated", "(", ")", "-", "self", ".", "memory_first", ")", "/", "1024.", "/", "1024.", ")", ")", "\n", "self", ".", "memory_last", "=", "torch", ".", "cuda", ".", "memory_allocated", "(", ")", "\n", "\n", "# early stop", "\n", "", "if", "epoch_iter", ">=", "opt", ".", "max_dataset_size", ":", "\n", "                ", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.None.train_CVAE.test": [[191, 276], ["time.time", "model.eval", "print", "enumerate", "utils.loss.get_loss_dict", "visualizer.print_current_errors_test", "visualizer.plot_current_errors_test", "print", "tqdm.tqdm", "len", "len", "is_same_ID[].detach().item", "model", "time.time", "loss.detach().cpu().item", "len", "min", "os.path.join", "model.module.eval", "img_target.to", "latent_ID.to", "is_same_ID[].detach", "torch.mean", "torch.mean", "os.path.exists", "os.mkdir", "torch.no_grad", "torch.no_grad", "img_source[].to", "torch.zeros_like", "torch.zeros_like", "np.stack().transpose.append", "detransformer_Arcface().numpy", "range", "range", "numpy.stack().transpose", "utils.plot.plot_batch", "isinstance", "loss.detach().cpu", "zip", "torch.zeros_like.cpu().numpy", "np.stack().transpose.append", "np.stack().transpose.append", "img_source[].repeat", "model.module().cpu().numpy", "range", "os.path.join", "detransformer_Arcface", "np.stack().transpose.append", "numpy.stack", "loss.detach", "torch.zeros_like.cpu", "img_source[].to.cpu", "model.module().cpu", "str", "model.module"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.get_loss_dict", "home.repos.pwc.inspect_result.ailon-island_facke.utils.visualizer.Visualizer.print_current_errors_test", "home.repos.pwc.inspect_result.ailon-island_facke.utils.visualizer.Visualizer.plot_current_errors_test", "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.mkdir", "home.repos.pwc.inspect_result.ailon-island_facke.utils.plot.plot_batch"], ["", "", "", "", "def", "test", "(", "opt", ",", "model", ",", "loader", ",", "epoch_idx", ",", "total_iter", ",", "visualizer", ")", ":", "\n", "    ", "test_start_time", "=", "time", ".", "time", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "test_iter", "=", "0", "\n", "\n", "test_losses", "=", "[", "]", "\n", "\n", "print", "(", "'Testing...'", ")", "\n", "if", "opt", ".", "debug", ":", "\n", "        ", "print", "(", "'Model instance being tested iter: {}.'", ".", "format", "(", "model", ".", "module", ".", "iter", ")", ")", "\n", "", "for", "batch_idx", ",", "(", "(", "img_source", ",", "img_target", ")", ",", "(", "latent_ID", ",", "_", ")", ",", "is_same_ID", ")", "in", "enumerate", "(", "tqdm", ".", "tqdm", "(", "loader", ")", ")", ":", "\n", "        ", "batch_size", "=", "len", "(", "is_same_ID", ")", "\n", "test_iter", "+=", "batch_size", "\n", "\n", "if", "len", "(", "opt", ".", "gpu_ids", ")", ":", "\n", "            ", "img_target", ",", "latent_ID", "=", "img_target", ".", "to", "(", "'cuda'", ")", ",", "latent_ID", ".", "to", "(", "'cuda'", ")", "\n", "\n", "", "is_same_ID", "=", "is_same_ID", "[", "0", "]", ".", "detach", "(", ")", ".", "item", "(", ")", "\n", "\n", "########### FORWARD ###########", "\n", "[", "losses", ",", "_", "]", "=", "model", "(", "img_target", ",", "latent_ID", ",", "is_same_ID", ")", "\n", "\n", "# gather losses", "\n", "losses", "=", "[", "torch", ".", "mean", "(", "x", ")", "if", "not", "isinstance", "(", "x", ",", "int", ")", "else", "x", "for", "x", "in", "losses", "]", "\n", "losses", "=", "[", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "for", "loss", "in", "losses", "]", "\n", "\n", "# save loss", "\n", "if", "not", "len", "(", "test_losses", ")", ":", "\n", "            ", "test_losses", "=", "losses", "\n", "", "else", ":", "\n", "            ", "test_losses", "=", "[", "\n", "test_loss", "+", "loss", "*", "batch_size", "\n", "for", "test_loss", ",", "loss", "in", "zip", "(", "test_losses", ",", "losses", ")", "]", "\n", "\n", "# display images", "\n", "", "if", "batch_idx", "==", "0", ":", "\n", "            ", "sample_size", "=", "min", "(", "8", ",", "opt", ".", "batchSize", ")", "\n", "sample_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "checkpoints_dir", ",", "opt", ".", "name", ",", "'samples'", ",", "'test'", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "sample_path", ")", ":", "\n", "                ", "os", ".", "mkdir", "(", "sample_path", ")", "\n", "", "'''\n            self.model.module.M1.eval()\n            self.model.module.E.eval()\n            self.model.module.M2.eval()\n            self.model.module.D.eval()\n            '''", "\n", "model", ".", "module", ".", "eval", "(", ")", "\n", "model", ".", "module", ".", "isTrain", "=", "False", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "img_source", "=", "img_source", "[", ":", "sample_size", "]", ".", "to", "(", "'cuda'", ")", "\n", "latent_ID", "=", "latent_ID", "[", ":", "sample_size", "]", "\n", "\n", "imgs", "=", "[", "]", "\n", "zero_img", "=", "(", "torch", ".", "zeros_like", "(", "img_source", "[", "0", ",", "...", "]", ")", ")", "\n", "imgs", ".", "append", "(", "zero_img", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "save_img", "=", "(", "detransformer_Arcface", "(", "img_source", ".", "cpu", "(", ")", ")", ")", ".", "numpy", "(", ")", "\n", "\n", "for", "r", "in", "range", "(", "sample_size", ")", ":", "\n", "                    ", "imgs", ".", "append", "(", "save_img", "[", "r", ",", "...", "]", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "sample_size", ")", ":", "\n", "                    ", "imgs", ".", "append", "(", "save_img", "[", "i", ",", "...", "]", ")", "\n", "\n", "image_infer", "=", "img_source", "[", "i", ",", "...", "]", ".", "repeat", "(", "sample_size", ",", "1", ",", "1", ",", "1", ")", "\n", "img_fake", "=", "model", ".", "module", "(", "image_infer", ",", "latent_ID", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "for", "j", "in", "range", "(", "sample_size", ")", ":", "\n", "                        ", "imgs", ".", "append", "(", "img_fake", "[", "j", ",", "...", "]", ")", "\n", "\n", "", "", "imgs", "=", "np", ".", "stack", "(", "imgs", ",", "axis", "=", "0", ")", ".", "transpose", "(", "0", ",", "2", ",", "3", ",", "1", ")", "\n", "plot_batch", "(", "imgs", ",", "os", ".", "path", ".", "join", "(", "sample_path", ",", "'step_'", "+", "str", "(", "total_iter", ")", "+", "'.jpg'", ")", ")", "\n", "", "model", ".", "module", ".", "isTrain", "=", "True", "\n", "\n", "# early stop", "\n", "", "if", "test_iter", ">=", "opt", ".", "max_dataset_size", ":", "\n", "            ", "break", "\n", "\n", "# print result", "\n", "", "", "test_losses", "=", "[", "test_loss", "/", "test_iter", "for", "test_loss", "in", "test_losses", "]", "\n", "test_losses", "=", "get_loss_dict", "(", "model", ".", "module", ".", "loss_names", ",", "test_losses", ",", "opt", ")", "\n", "test_time", "=", "time", ".", "time", "(", ")", "-", "test_start_time", "\n", "visualizer", ".", "print_current_errors_test", "(", "epoch_idx", ",", "total_iter", ",", "test_losses", ",", "test_time", ")", "\n", "visualizer", ".", "plot_current_errors_test", "(", "test_losses", ",", "total_iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.None.benchmark.logger": [[37, 44], ["os.path.join", "os.path.join", "print", "open", "log_file.write"], "function", ["None"], ["def", "logger", "(", "msg", ")", ":", "\n", "    ", "save_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "checkpoints_dir", ",", "opt", ".", "name", ")", "\n", "file_name", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "'benchmark_log.txt'", ")", "\n", "\n", "with", "open", "(", "file_name", ",", "'a'", ")", "as", "log_file", ":", "\n", "        ", "log_file", ".", "write", "(", "\"{}\\n\"", ".", "format", "(", "msg", ")", ")", "\n", "", "print", "(", "msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.None.train_SimSwap.Trainer.__init__": [[33, 52], ["super().__init__", "os.path.join", "min", "print", "print", "len"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["    ", "def", "__init__", "(", "self", ",", "loader", ",", "model", ",", "opt", ",", "start_epoch", ",", "epoch_iter", ",", "visualizer", ")", ":", "\n", "        ", "super", "(", "Trainer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "opt", "=", "opt", "\n", "self", ".", "loader", "=", "loader", "\n", "self", ".", "losses", "=", "[", "]", "\n", "self", ".", "start_epoch", "=", "start_epoch", "\n", "self", ".", "start_epoch_iter", "=", "epoch_iter", "\n", "self", ".", "total_iter", "=", "(", "start_epoch", "-", "1", ")", "*", "len", "(", "loader", ")", "+", "epoch_iter", "\n", "self", ".", "memory_last", "=", "0", "\n", "self", ".", "memory_first", "=", "None", "\n", "self", ".", "visualizer", "=", "visualizer", "\n", "self", ".", "sample_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "checkpoints_dir", ",", "opt", ".", "name", ",", "'samples'", ",", "'train'", ")", "\n", "self", ".", "sample_size", "=", "min", "(", "8", ",", "opt", ".", "batchSize", ")", "\n", "\n", "if", "opt", ".", "verbose", ":", "\n", "            ", "print", "(", "'Trainer initialized.'", ")", "\n", "", "if", "opt", ".", "debug", ":", "\n", "            ", "print", "(", "'Model instance in trainer iter: {}.'", ".", "format", "(", "self", ".", "model", ".", "module", ".", "iter", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.None.train_SimSwap.Trainer.train": [[54, 181], ["time.time", "enumerate", "print", "print", "train_SimSwap.Trainer.model.train", "len", "len", "is_same_ID[].detach().item", "model", "utils.utils.loss.get_loss_dict", "train_SimSwap.Trainer.model.module.optim_G.zero_grad", "loss_G.backward", "train_SimSwap.Trainer.model.module.optim_G.step", "train_SimSwap.Trainer.model.module.optim_D.zero_grad", "loss_D.backward", "train_SimSwap.Trainer.model.module.optim_D.step", "print", "time.time", "print", "utils.utils.loss.get_loss_dict", "visualizer.print_current_errors", "visualizer.plot_current_errors", "train_SimSwap.Trainer.model.module.G.eval", "train_SimSwap.Trainer.model.module.save", "train_SimSwap.Trainer.model.module.save", "numpy.savetxt", "print", "print", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "img_source.to", "img_target.to", "latent_ID.to", "latent_ID_target.to", "is_same_ID[].detach", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "isinstance", "loss.detach().cpu().item", "os.path.exists", "os.mkdir", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "numpy.stack().transpose.append", "detransformer_Arcface().numpy", "range", "range", "print", "numpy.stack().transpose", "utils.utils.plot.plot_batch", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "isinstance", "utils.utils.loss.get_loss_dict.get", "time.time", "torch.zeros_like.cpu().numpy", "torch.zeros_like.cpu().numpy", "numpy.stack().transpose.append", "numpy.stack().transpose.append", "img_source[].repeat", "train_SimSwap.Trainer.model.module.G().cpu().numpy", "range", "os.path.join", "utils.utils.loss.get_loss_dict.get", "loss.detach().cpu", "detransformer_Arcface", "numpy.stack().transpose.append", "numpy.stack", "torch.zeros_like.cpu", "torch.zeros_like.cpu", "img_source.cpu", "train_SimSwap.Trainer.model.module.G().cpu", "loss.detach", "str", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "torch.cuda.memory_allocated", "train_SimSwap.Trainer.model.module.G"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.None.train_SimSwap.Trainer.train", "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.get_loss_dict", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.zero_grad", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.MixedPrecisionTrainer.backward", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.zero_grad", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.MixedPrecisionTrainer.backward", "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.get_loss_dict", "home.repos.pwc.inspect_result.ailon-island_facke.utils.visualizer.Visualizer.print_current_errors", "home.repos.pwc.inspect_result.ailon-island_facke.utils.visualizer.Visualizer.plot_current_errors", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.save", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.save", "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.mkdir", "home.repos.pwc.inspect_result.ailon-island_facke.utils.plot.plot_batch", "home.repos.pwc.inspect_result.ailon-island_facke.insightface_func.face_detect_crop_single.Face_detect_crop.get", "home.repos.pwc.inspect_result.ailon-island_facke.insightface_func.face_detect_crop_single.Face_detect_crop.get"], ["", "", "def", "train", "(", "self", ",", "epoch_idx", ")", ":", "\n", "        ", "opt", "=", "self", ".", "opt", "\n", "\n", "if", "opt", ".", "verbose", ":", "\n", "            ", "print", "(", "'Training...'", ")", "\n", "", "if", "opt", ".", "debug", ":", "\n", "            ", "print", "(", "'Model instance to be trained iter: {}.'", ".", "format", "(", "self", ".", "model", ".", "module", ".", "iter", ")", ")", "\n", "\n", "", "epoch_start_time", "=", "time", ".", "time", "(", ")", "\n", "epoch_iter", "=", "self", ".", "start_epoch_iter", "if", "epoch_idx", "==", "self", ".", "start_epoch", "else", "0", "\n", "visualizer", "=", "self", ".", "visualizer", "\n", "display_delta", "=", "self", ".", "total_iter", "%", "opt", ".", "display_freq", "\n", "print_delta", "=", "self", ".", "total_iter", "%", "opt", ".", "print_freq", "\n", "save_delta", "=", "self", ".", "total_iter", "%", "opt", ".", "save_latest_freq", "\n", "\n", "for", "batch_idx", ",", "(", "(", "img_source", ",", "img_target", ")", ",", "(", "latent_ID", ",", "latent_ID_target", ")", ",", "is_same_ID", ")", "in", "enumerate", "(", "self", ".", "loader", ",", "start", "=", "1", ")", ":", "\n", "            ", "self", ".", "model", ".", "train", "(", ")", "\n", "if", "opt", ".", "debug", ":", "\n", "                ", "print", "(", "'Batch {}: model instance to be trained iter: {}.'", ".", "format", "(", "batch_idx", ",", "self", ".", "model", ".", "module", ".", "iter", ")", ")", "\n", "\n", "", "if", "self", ".", "total_iter", "%", "opt", ".", "print_freq", "==", "print_delta", ":", "\n", "                ", "iter_start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "", "if", "len", "(", "opt", ".", "gpu_ids", ")", ":", "\n", "                ", "img_source", ",", "img_target", ",", "latent_ID", ",", "latent_ID_target", "=", "img_source", ".", "to", "(", "'cuda'", ")", ",", "img_target", ".", "to", "(", "'cuda'", ")", ",", "latent_ID", ".", "to", "(", "'cuda'", ")", ",", "latent_ID_target", ".", "to", "(", "'cuda'", ")", "\n", "\n", "# count iterations", "\n", "", "batch_size", "=", "len", "(", "is_same_ID", ")", "\n", "self", ".", "total_iter", "+=", "batch_size", "\n", "self", ".", "model", ".", "module", ".", "iter", "=", "self", ".", "total_iter", "\n", "epoch_iter", "+=", "batch_size", "\n", "\n", "if", "opt", ".", "ID_check", ":", "\n", "                ", "print", "(", "is_same_ID", ")", "\n", "", "is_same_ID", "=", "is_same_ID", "[", "0", "]", ".", "detach", "(", ")", ".", "item", "(", ")", "\n", "\n", "########### FORWARD ###########", "\n", "[", "losses", ",", "_", "]", "=", "model", "(", "img_source", ",", "img_target", ",", "latent_ID", ",", "latent_ID_target", ")", "\n", "\n", "############ LOSSES ############", "\n", "# gather losses", "\n", "losses", "=", "[", "torch", ".", "mean", "(", "x", ")", "if", "not", "isinstance", "(", "x", ",", "int", ")", "else", "x", "for", "x", "in", "losses", "]", "\n", "\n", "# loss dictionary", "\n", "# loss_dict = dict(zip(self.model.module.loss_names, losses))", "\n", "loss_dict", "=", "get_loss_dict", "(", "self", ".", "model", ".", "module", ".", "loss_names", ",", "losses", ",", "opt", ")", "\n", "\n", "# calculate final loss scalar", "\n", "loss_G", "=", "loss_dict", "[", "'G_GAN'", "]", "+", "loss_dict", ".", "get", "(", "'G_VGG'", ",", "0", ")", "+", "loss_dict", ".", "get", "(", "'G_FM'", ",", "0", ")", "+", "loss_dict", "[", "'G_ID'", "]", "+", "loss_dict", "[", "'G_rec'", "]", "*", "is_same_ID", "\n", "loss_D", "=", "(", "loss_dict", "[", "'D_fake'", "]", "+", "loss_dict", "[", "'D_real'", "]", ")", "+", "loss_dict", "[", "'D_GP'", "]", "\n", "\n", "############ BACKWARD ############", "\n", "self", ".", "model", ".", "module", ".", "optim_G", ".", "zero_grad", "(", ")", "\n", "loss_G", ".", "backward", "(", ")", "\n", "self", ".", "model", ".", "module", ".", "optim_G", ".", "step", "(", ")", "\n", "self", ".", "model", ".", "module", ".", "optim_D", ".", "zero_grad", "(", ")", "\n", "loss_D", ".", "backward", "(", ")", "\n", "self", ".", "model", ".", "module", ".", "optim_D", ".", "step", "(", ")", "\n", "\n", "# save loss", "\n", "losses", "=", "[", "loss", "if", "isinstance", "(", "loss", ",", "int", ")", "else", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "for", "loss", "in", "losses", "]", "\n", "self", ".", "losses", "+=", "[", "losses", "]", "\n", "\n", "# print result", "\n", "if", "self", ".", "total_iter", "%", "opt", ".", "print_freq", "==", "print_delta", ":", "\n", "                ", "errors", "=", "get_loss_dict", "(", "self", ".", "model", ".", "module", ".", "loss_names", ",", "losses", ",", "opt", ")", "\n", "avg_iter_time", "=", "(", "time", ".", "time", "(", ")", "-", "iter_start_time", ")", "/", "opt", ".", "print_freq", "\n", "visualizer", ".", "print_current_errors", "(", "epoch_idx", ",", "epoch_iter", ",", "errors", ",", "avg_iter_time", ")", "\n", "visualizer", ".", "plot_current_errors", "(", "errors", ",", "self", ".", "total_iter", ")", "\n", "\n", "# display images", "\n", "", "if", "self", ".", "total_iter", "%", "opt", ".", "display_freq", "==", "display_delta", ":", "\n", "                ", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "sample_path", ")", ":", "\n", "                    ", "os", ".", "mkdir", "(", "self", ".", "sample_path", ")", "\n", "\n", "", "self", ".", "model", ".", "module", ".", "G", ".", "eval", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "img_source", "=", "img_source", "[", ":", "self", ".", "sample_size", "]", "\n", "latent_ID", "=", "latent_ID", "[", ":", "self", ".", "sample_size", "]", "\n", "\n", "imgs", "=", "[", "]", "\n", "zero_img", "=", "(", "torch", ".", "zeros_like", "(", "img_source", "[", "0", ",", "...", "]", ")", ")", "\n", "imgs", ".", "append", "(", "zero_img", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "save_img", "=", "(", "detransformer_Arcface", "(", "img_source", ".", "cpu", "(", ")", ")", ")", ".", "numpy", "(", ")", "\n", "\n", "for", "r", "in", "range", "(", "self", ".", "sample_size", ")", ":", "\n", "                        ", "imgs", ".", "append", "(", "save_img", "[", "r", ",", "...", "]", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "self", ".", "sample_size", ")", ":", "\n", "                        ", "imgs", ".", "append", "(", "save_img", "[", "i", ",", "...", "]", ")", "\n", "\n", "image_infer", "=", "img_source", "[", "i", ",", "...", "]", ".", "repeat", "(", "self", ".", "sample_size", ",", "1", ",", "1", ",", "1", ")", "\n", "img_fake", "=", "self", ".", "model", ".", "module", ".", "G", "(", "image_infer", ",", "latent_ID", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "for", "j", "in", "range", "(", "self", ".", "sample_size", ")", ":", "\n", "                            ", "imgs", ".", "append", "(", "img_fake", "[", "j", ",", "...", "]", ")", "\n", "\n", "", "", "print", "(", "\"Save test data for iter {}.\"", ".", "format", "(", "self", ".", "total_iter", ")", ")", "\n", "imgs", "=", "np", ".", "stack", "(", "imgs", ",", "axis", "=", "0", ")", ".", "transpose", "(", "0", ",", "2", ",", "3", ",", "1", ")", "\n", "plot_batch", "(", "imgs", ",", "os", ".", "path", ".", "join", "(", "self", ".", "sample_path", ",", "'step_'", "+", "str", "(", "self", ".", "total_iter", ")", "+", "'.jpg'", ")", ")", "\n", "\n", "\n", "\n", "# visuals = OrderedDict([('source_img', utils.tensor2im(img_target[0])),", "\n", "#                        ('id_img', utils.tensor2im(img_source[0])),", "\n", "#                        ('generated_img', utils.tensor2im(img_fake.data[0]))", "\n", "#                        ])", "\n", "# visualizer.display_current_results(visuals, epoch_idx, self.total_iter)", "\n", "\n", "# save model", "\n", "", "", "if", "(", "self", ".", "total_iter", "%", "opt", ".", "save_latest_freq", "==", "save_delta", ")", ":", "\n", "                ", "self", ".", "model", ".", "module", ".", "save", "(", "'latest'", ")", "\n", "self", ".", "model", ".", "module", ".", "save", "(", "'{}_iter'", ".", "format", "(", "self", ".", "total_iter", ")", ")", "\n", "np", ".", "savetxt", "(", "iter_path", ",", "(", "epoch_idx", ",", "epoch_iter", ")", ",", "delimiter", "=", "','", ",", "fmt", "=", "'%d'", ")", "\n", "\n", "# memory log", "\n", "", "if", "opt", ".", "memory_check", ":", "\n", "                ", "if", "self", ".", "memory_first", "is", "None", ":", "\n", "                    ", "self", ".", "memory_first", "=", "torch", ".", "cuda", ".", "memory_allocated", "(", ")", "\n", "", "print", "(", "\"Memory increase: {}MiB\"", ".", "format", "(", "(", "torch", ".", "cuda", ".", "memory_allocated", "(", ")", "-", "self", ".", "memory_last", ")", "/", "1024.", "/", "1024.", ")", ")", "\n", "print", "(", "\"Total memory increase: {}MiB\"", ".", "format", "(", "\n", "(", "torch", ".", "cuda", ".", "memory_allocated", "(", ")", "-", "self", ".", "memory_first", ")", "/", "1024.", "/", "1024.", ")", ")", "\n", "self", ".", "memory_last", "=", "torch", ".", "cuda", ".", "memory_allocated", "(", ")", "\n", "\n", "# early stop", "\n", "", "if", "epoch_iter", ">=", "opt", ".", "max_dataset_size", ":", "\n", "                ", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.None.train_SimSwap.test": [[184, 262], ["time.time", "model.eval", "print", "enumerate", "utils.loss.get_loss_dict", "visualizer.print_current_errors_test", "visualizer.plot_current_errors_test", "print", "tqdm.tqdm", "len", "len", "is_same_ID[].detach().item", "model", "time.time", "loss.detach().cpu().item", "len", "min", "os.path.join", "img_source.to", "img_target.to", "latent_ID.to", "latent_ID_target.to", "is_same_ID[].detach", "torch.mean", "torch.mean", "os.path.exists", "os.mkdir", "torch.no_grad", "torch.no_grad", "torch.zeros_like", "torch.zeros_like", "np.stack().transpose.append", "detransformer_Arcface().numpy", "range", "range", "numpy.stack().transpose", "utils.plot.plot_batch", "isinstance", "loss.detach().cpu", "zip", "torch.zeros_like.cpu().numpy", "np.stack().transpose.append", "np.stack().transpose.append", "img_source[].repeat", "model.module.G().cpu().numpy", "range", "os.path.join", "detransformer_Arcface", "np.stack().transpose.append", "numpy.stack", "loss.detach", "torch.zeros_like.cpu", "img_source.cpu", "model.module.G().cpu", "str", "model.module.G"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.get_loss_dict", "home.repos.pwc.inspect_result.ailon-island_facke.utils.visualizer.Visualizer.print_current_errors_test", "home.repos.pwc.inspect_result.ailon-island_facke.utils.visualizer.Visualizer.plot_current_errors_test", "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.mkdir", "home.repos.pwc.inspect_result.ailon-island_facke.utils.plot.plot_batch"], ["", "", "", "", "def", "test", "(", "opt", ",", "model", ",", "loader", ",", "epoch_idx", ",", "total_iter", ",", "visualizer", ")", ":", "\n", "    ", "test_start_time", "=", "time", ".", "time", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "test_iter", "=", "0", "\n", "\n", "test_losses", "=", "[", "]", "\n", "\n", "print", "(", "'Testing...'", ")", "\n", "if", "opt", ".", "debug", ":", "\n", "        ", "print", "(", "'Model instance being tested iter: {}.'", ".", "format", "(", "model", ".", "module", ".", "iter", ")", ")", "\n", "", "for", "batch_idx", ",", "(", "(", "img_source", ",", "img_target", ")", ",", "(", "latent_ID", ",", "latent_ID_target", ")", ",", "is_same_ID", ")", "in", "enumerate", "(", "tqdm", ".", "tqdm", "(", "loader", ")", ")", ":", "\n", "        ", "batch_size", "=", "len", "(", "is_same_ID", ")", "\n", "test_iter", "+=", "batch_size", "\n", "\n", "if", "len", "(", "opt", ".", "gpu_ids", ")", ":", "\n", "            ", "img_source", ",", "img_target", ",", "latent_ID", ",", "latent_ID_target", "=", "img_source", ".", "to", "(", "'cuda'", ")", ",", "img_target", ".", "to", "(", "'cuda'", ")", ",", "latent_ID", ".", "to", "(", "'cuda'", ")", ",", "latent_ID_target", ".", "to", "(", "'cuda'", ")", "\n", "\n", "", "is_same_ID", "=", "is_same_ID", "[", "0", "]", ".", "detach", "(", ")", ".", "item", "(", ")", "\n", "\n", "########### FORWARD ###########", "\n", "[", "losses", ",", "_", "]", "=", "model", "(", "img_source", ",", "img_target", ",", "latent_ID", ",", "latent_ID_target", ")", "\n", "\n", "# gather losses", "\n", "losses", "=", "[", "torch", ".", "mean", "(", "x", ")", "if", "not", "isinstance", "(", "x", ",", "int", ")", "else", "x", "for", "x", "in", "losses", "]", "\n", "losses", "=", "[", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "for", "loss", "in", "losses", "]", "\n", "\n", "# save loss", "\n", "if", "not", "len", "(", "test_losses", ")", ":", "\n", "            ", "test_losses", "=", "losses", "\n", "", "else", ":", "\n", "            ", "test_losses", "=", "[", "\n", "test_loss", "+", "loss", "*", "batch_size", "if", "is_same_ID", "or", "loss_name", "!=", "'G_rec'", "else", "\n", "test_loss", "\n", "for", "loss_name", ",", "test_loss", ",", "loss", "in", "zip", "(", "model", ".", "module", ".", "loss_names", ",", "test_losses", ",", "losses", ")", "]", "\n", "\n", "# display images", "\n", "", "if", "batch_idx", "==", "0", ":", "\n", "            ", "sample_size", "=", "min", "(", "8", ",", "opt", ".", "batchSize", ")", "\n", "sample_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "checkpoints_dir", ",", "opt", ".", "name", ",", "'samples'", ",", "'test'", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "sample_path", ")", ":", "\n", "                ", "os", ".", "mkdir", "(", "sample_path", ")", "\n", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "img_source", "=", "img_source", "[", ":", "sample_size", "]", "\n", "latent_ID", "=", "latent_ID", "[", ":", "sample_size", "]", "\n", "\n", "imgs", "=", "[", "]", "\n", "zero_img", "=", "(", "torch", ".", "zeros_like", "(", "img_source", "[", "0", ",", "...", "]", ")", ")", "\n", "imgs", ".", "append", "(", "zero_img", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "save_img", "=", "(", "detransformer_Arcface", "(", "img_source", ".", "cpu", "(", ")", ")", ")", ".", "numpy", "(", ")", "\n", "\n", "for", "r", "in", "range", "(", "sample_size", ")", ":", "\n", "                    ", "imgs", ".", "append", "(", "save_img", "[", "r", ",", "...", "]", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "sample_size", ")", ":", "\n", "                    ", "imgs", ".", "append", "(", "save_img", "[", "i", ",", "...", "]", ")", "\n", "\n", "image_infer", "=", "img_source", "[", "i", ",", "...", "]", ".", "repeat", "(", "sample_size", ",", "1", ",", "1", ",", "1", ")", "\n", "img_fake", "=", "model", ".", "module", ".", "G", "(", "image_infer", ",", "latent_ID", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "for", "j", "in", "range", "(", "sample_size", ")", ":", "\n", "                        ", "imgs", ".", "append", "(", "img_fake", "[", "j", ",", "...", "]", ")", "\n", "\n", "", "", "imgs", "=", "np", ".", "stack", "(", "imgs", ",", "axis", "=", "0", ")", ".", "transpose", "(", "0", ",", "2", ",", "3", ",", "1", ")", "\n", "plot_batch", "(", "imgs", ",", "os", ".", "path", ".", "join", "(", "sample_path", ",", "'step_'", "+", "str", "(", "total_iter", ")", "+", "'.jpg'", ")", ")", "\n", "\n", "# early stop", "\n", "", "", "if", "test_iter", ">=", "opt", ".", "max_dataset_size", ":", "\n", "            ", "break", "\n", "\n", "# print result", "\n", "", "", "test_losses", "=", "[", "test_loss", "/", "test_iter", "for", "test_loss", "in", "test_losses", "]", "\n", "test_losses", "=", "get_loss_dict", "(", "model", ".", "module", ".", "loss_names", ",", "test_losses", ",", "opt", ")", "\n", "test_time", "=", "time", ".", "time", "(", ")", "-", "test_start_time", "\n", "visualizer", ".", "print_current_errors_test", "(", "epoch_idx", ",", "total_iter", ",", "test_losses", ",", "test_time", ")", "\n", "visualizer", ".", "plot_current_errors_test", "(", "test_losses", ",", "total_iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.None.swap.logger": [[37, 44], ["os.path.join", "os.path.join", "print", "open", "log_file.write"], "function", ["None"], ["def", "logger", "(", "msg", ")", ":", "\n", "    ", "save_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "output_path", ",", "opt", ".", "name", ")", "\n", "file_name", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "'swap_log.txt'", ")", "\n", "\n", "with", "open", "(", "file_name", ",", "'a'", ")", "as", "log_file", ":", "\n", "        ", "log_file", ".", "write", "(", "\"{}\\n\"", ".", "format", "(", "msg", ")", ")", "\n", "", "print", "(", "msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.None.swap.read_img": [[46, 55], ["range", "torch.stack", "torch.stack", "transform", "PIL.Image.open().convert", "PIL.Image.open", "os.path.join"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.utils.face_align_ffhqandnewarc.transform"], ["", "def", "read_img", "(", "pth", ",", "transform", ",", "opt", ")", ":", "\n", "    ", "img", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "opt", ".", "num_to_swap", ")", ":", "\n", "        ", "img", "+=", "[", "Image", ".", "open", "(", "os", ".", "path", ".", "join", "(", "pth", ",", "'{}.{}'", ".", "format", "(", "i", ",", "opt", ".", "input_format", ")", ")", ")", ".", "convert", "(", "'RGB'", ")", "]", "\n", "img", "[", "-", "1", "]", "=", "transform", "(", "img", "[", "-", "1", "]", ")", "\n", "\n", "", "img", "=", "torch", ".", "stack", "(", "img", ")", "\n", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.html.HTML.__init__": [[7, 20], ["os.path.join", "dominate.document", "os.path.exists", "os.makedirs", "os.path.exists", "os.makedirs", "meta", "str"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "web_dir", ",", "title", ",", "refresh", "=", "0", ")", ":", "\n", "        ", "self", ".", "title", "=", "title", "\n", "self", ".", "web_dir", "=", "web_dir", "\n", "self", ".", "img_dir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "web_dir", ",", "'images'", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "web_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "web_dir", ")", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "img_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "img_dir", ")", "\n", "\n", "", "self", ".", "doc", "=", "dominate", ".", "document", "(", "title", "=", "title", ")", "\n", "if", "refresh", ">", "0", ":", "\n", "            ", "with", "self", ".", "doc", ".", "head", ":", "\n", "                ", "meta", "(", "http_equiv", "=", "\"refresh\"", ",", "content", "=", "str", "(", "refresh", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.html.HTML.get_image_dir": [[21, 23], ["None"], "methods", ["None"], ["", "", "", "def", "get_image_dir", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "img_dir", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.html.HTML.add_header": [[24, 27], ["h3"], "methods", ["None"], ["", "def", "add_header", "(", "self", ",", "str", ")", ":", "\n", "        ", "with", "self", ".", "doc", ":", "\n", "            ", "h3", "(", "str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.html.HTML.add_table": [[28, 31], ["table", "html.HTML.doc.add"], "methods", ["None"], ["", "", "def", "add_table", "(", "self", ",", "border", "=", "1", ")", ":", "\n", "        ", "self", ".", "t", "=", "table", "(", "border", "=", "border", ",", "style", "=", "\"table-layout: fixed;\"", ")", "\n", "self", ".", "doc", ".", "add", "(", "self", ".", "t", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.html.HTML.add_images": [[32, 43], ["html.HTML.add_table", "tr", "zip", "td", "p", "br", "p", "a", "img", "os.path.join", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.utils.html.HTML.add_table"], ["", "def", "add_images", "(", "self", ",", "ims", ",", "txts", ",", "links", ",", "width", "=", "512", ")", ":", "\n", "        ", "self", ".", "add_table", "(", ")", "\n", "with", "self", ".", "t", ":", "\n", "            ", "with", "tr", "(", ")", ":", "\n", "                ", "for", "im", ",", "txt", ",", "link", "in", "zip", "(", "ims", ",", "txts", ",", "links", ")", ":", "\n", "                    ", "with", "td", "(", "style", "=", "\"word-wrap: break-word;\"", ",", "halign", "=", "\"center\"", ",", "valign", "=", "\"top\"", ")", ":", "\n", "                        ", "with", "p", "(", ")", ":", "\n", "                            ", "with", "a", "(", "href", "=", "os", ".", "path", ".", "join", "(", "'images'", ",", "link", ")", ")", ":", "\n", "                                ", "img", "(", "style", "=", "\"width:%dpx\"", "%", "(", "width", ")", ",", "src", "=", "os", ".", "path", ".", "join", "(", "'images'", ",", "im", ")", ")", "\n", "", "br", "(", ")", "\n", "p", "(", "txt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.html.HTML.save": [[44, 49], ["open", "open.write", "open.close", "html.HTML.doc.render"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.Logger.close"], ["", "", "", "", "", "", "def", "save", "(", "self", ")", ":", "\n", "        ", "html_file", "=", "'%s/index.html'", "%", "self", ".", "web_dir", "\n", "f", "=", "open", "(", "html_file", ",", "'wt'", ")", "\n", "f", ".", "write", "(", "self", ".", "doc", ".", "render", "(", ")", ")", "\n", "f", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.visualizer.Visualizer.__init__": [[19, 42], ["os.path.join", "os.path.join", "tf.summary.FileWriter", "os.path.join", "tf.summary.FileWriter", "os.path.join", "os.path.join", "print", "utils.mkdirs", "open", "time.strftime", "log_file.write"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.mkdirs"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "# self.opt = opt", "\n", "        ", "self", ".", "tf_log", "=", "opt", ".", "tf_log", "\n", "self", ".", "use_html", "=", "opt", ".", "isTrain", "and", "not", "opt", ".", "no_html", "\n", "self", ".", "win_size", "=", "opt", ".", "display_winsize", "\n", "self", ".", "name", "=", "opt", ".", "name", "\n", "if", "self", ".", "tf_log", ":", "\n", "            ", "import", "tensorflow", "as", "tf", "\n", "self", ".", "tf", "=", "tf", "\n", "self", ".", "log_dir", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "checkpoints_dir", ",", "opt", ".", "name", ",", "'logs'", ")", "\n", "self", ".", "writer", "=", "tf", ".", "summary", ".", "FileWriter", "(", "self", ".", "log_dir", ")", "\n", "self", ".", "log_dir_test", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "checkpoints_dir", ",", "opt", ".", "name", ",", "'logs'", ")", "\n", "self", ".", "writer_test", "=", "tf", ".", "summary", ".", "FileWriter", "(", "self", ".", "log_dir_test", ")", "\n", "\n", "", "if", "self", ".", "use_html", ":", "\n", "            ", "self", ".", "web_dir", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "checkpoints_dir", ",", "opt", ".", "name", ",", "'web'", ")", "\n", "self", ".", "img_dir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "web_dir", ",", "'images'", ")", "\n", "print", "(", "'create web directory %s...'", "%", "self", ".", "web_dir", ")", "\n", "util", ".", "mkdirs", "(", "[", "self", ".", "web_dir", ",", "self", ".", "img_dir", "]", ")", "\n", "", "self", ".", "log_name", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "checkpoints_dir", ",", "opt", ".", "name", ",", "'loss_log.txt'", ")", "\n", "with", "open", "(", "self", ".", "log_name", ",", "\"a\"", ")", "as", "log_file", ":", "\n", "            ", "now", "=", "time", ".", "strftime", "(", "\"%c\"", ")", "\n", "log_file", ".", "write", "(", "'================ Training Loss (%s) ================\\n'", "%", "now", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.visualizer.Visualizer.display_current_results": [[44, 100], ["visuals.items", "visualizer.Visualizer.tf.Summary", "visualizer.Visualizer.writer.add_summary", "visuals.items", "html.HTML", "range", "html.HTML.save", "scipy.misc.toimage().save", "visualizer.Visualizer.tf.Summary.Image", "img_summaries.append", "isinstance", "html.HTML.add_header", "visuals.items", "StringIO", "visualizer.Visualizer.tf.Summary.Value", "range", "os.path.join", "utils.save_image", "isinstance", "len", "html.HTML.add_images", "int", "html.HTML.add_images", "html.HTML.add_images", "BytesIO", "scipy.misc.toimage", "BytesIO.getvalue", "len", "os.path.join", "utils.save_image", "range", "ims.append", "txts.append", "links.append", "round", "len", "ims.append", "txts.append", "links.append", "len", "str"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.save", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.save", "home.repos.pwc.inspect_result.ailon-island_facke.utils.html.HTML.add_header", "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.save_image", "home.repos.pwc.inspect_result.ailon-island_facke.utils.html.HTML.add_images", "home.repos.pwc.inspect_result.ailon-island_facke.utils.html.HTML.add_images", "home.repos.pwc.inspect_result.ailon-island_facke.utils.html.HTML.add_images", "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.save_image"], ["", "", "def", "display_current_results", "(", "self", ",", "visuals", ",", "epoch", ",", "step", ")", ":", "\n", "        ", "if", "self", ".", "tf_log", ":", "# show images in tensorboard output", "\n", "            ", "img_summaries", "=", "[", "]", "\n", "for", "label", ",", "image_numpy", "in", "visuals", ".", "items", "(", ")", ":", "\n", "# Write the image to a string", "\n", "                ", "try", ":", "\n", "                    ", "s", "=", "StringIO", "(", ")", "\n", "", "except", ":", "\n", "                    ", "s", "=", "BytesIO", "(", ")", "\n", "", "scipy", ".", "misc", ".", "toimage", "(", "image_numpy", ")", ".", "save", "(", "s", ",", "format", "=", "\"jpeg\"", ")", "\n", "# Create an Image object", "\n", "img_sum", "=", "self", ".", "tf", ".", "Summary", ".", "Image", "(", "encoded_image_string", "=", "s", ".", "getvalue", "(", ")", ",", "height", "=", "image_numpy", ".", "shape", "[", "0", "]", ",", "width", "=", "image_numpy", ".", "shape", "[", "1", "]", ")", "\n", "# Create a Summary value", "\n", "img_summaries", ".", "append", "(", "self", ".", "tf", ".", "Summary", ".", "Value", "(", "tag", "=", "label", ",", "image", "=", "img_sum", ")", ")", "\n", "\n", "# Create and write Summary", "\n", "", "summary", "=", "self", ".", "tf", ".", "Summary", "(", "value", "=", "img_summaries", ")", "\n", "self", ".", "writer", ".", "add_summary", "(", "summary", ",", "step", ")", "\n", "\n", "", "if", "self", ".", "use_html", ":", "# save images to a html file", "\n", "            ", "for", "label", ",", "image_numpy", "in", "visuals", ".", "items", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "image_numpy", ",", "list", ")", ":", "\n", "                    ", "for", "i", "in", "range", "(", "len", "(", "image_numpy", ")", ")", ":", "\n", "                        ", "img_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "img_dir", ",", "'epoch%.3d_%s_%d.jpg'", "%", "(", "epoch", ",", "label", ",", "i", ")", ")", "\n", "util", ".", "save_image", "(", "image_numpy", "[", "i", "]", ",", "img_path", ")", "\n", "", "", "else", ":", "\n", "                    ", "img_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "img_dir", ",", "'epoch%.3d_%s.jpg'", "%", "(", "epoch", ",", "label", ")", ")", "\n", "util", ".", "save_image", "(", "image_numpy", ",", "img_path", ")", "\n", "\n", "# update website", "\n", "", "", "webpage", "=", "html", ".", "HTML", "(", "self", ".", "web_dir", ",", "'Experiment name = %s'", "%", "self", ".", "name", ",", "refresh", "=", "30", ")", "\n", "for", "n", "in", "range", "(", "epoch", ",", "0", ",", "-", "1", ")", ":", "\n", "                ", "webpage", ".", "add_header", "(", "'epoch [%d]'", "%", "n", ")", "\n", "ims", "=", "[", "]", "\n", "txts", "=", "[", "]", "\n", "links", "=", "[", "]", "\n", "\n", "for", "label", ",", "image_numpy", "in", "visuals", ".", "items", "(", ")", ":", "\n", "                    ", "if", "isinstance", "(", "image_numpy", ",", "list", ")", ":", "\n", "                        ", "for", "i", "in", "range", "(", "len", "(", "image_numpy", ")", ")", ":", "\n", "                            ", "img_path", "=", "'epoch%.3d_%s_%d.jpg'", "%", "(", "n", ",", "label", ",", "i", ")", "\n", "ims", ".", "append", "(", "img_path", ")", "\n", "txts", ".", "append", "(", "label", "+", "str", "(", "i", ")", ")", "\n", "links", ".", "append", "(", "img_path", ")", "\n", "", "", "else", ":", "\n", "                        ", "img_path", "=", "'epoch%.3d_%s.jpg'", "%", "(", "n", ",", "label", ")", "\n", "ims", ".", "append", "(", "img_path", ")", "\n", "txts", ".", "append", "(", "label", ")", "\n", "links", ".", "append", "(", "img_path", ")", "\n", "", "", "if", "len", "(", "ims", ")", "<", "10", ":", "\n", "                    ", "webpage", ".", "add_images", "(", "ims", ",", "txts", ",", "links", ",", "width", "=", "self", ".", "win_size", ")", "\n", "", "else", ":", "\n", "                    ", "num", "=", "int", "(", "round", "(", "len", "(", "ims", ")", "/", "2.0", ")", ")", "\n", "webpage", ".", "add_images", "(", "ims", "[", ":", "num", "]", ",", "txts", "[", ":", "num", "]", ",", "links", "[", ":", "num", "]", ",", "width", "=", "self", ".", "win_size", ")", "\n", "webpage", ".", "add_images", "(", "ims", "[", "num", ":", "]", ",", "txts", "[", "num", ":", "]", ",", "links", "[", "num", ":", "]", ",", "width", "=", "self", ".", "win_size", ")", "\n", "", "", "webpage", ".", "save", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.visualizer.Visualizer.plot_current_errors": [[102, 107], ["errors.items", "visualizer.Visualizer.tf.Summary", "visualizer.Visualizer.writer.add_summary", "visualizer.Visualizer.tf.Summary.Value"], "methods", ["None"], ["", "", "def", "plot_current_errors", "(", "self", ",", "errors", ",", "step", ")", ":", "\n", "        ", "if", "self", ".", "tf_log", ":", "\n", "            ", "for", "tag", ",", "value", "in", "errors", ".", "items", "(", ")", ":", "\n", "                ", "summary", "=", "self", ".", "tf", ".", "Summary", "(", "value", "=", "[", "self", ".", "tf", ".", "Summary", ".", "Value", "(", "tag", "=", "tag", ",", "simple_value", "=", "value", ")", "]", ")", "\n", "self", ".", "writer", ".", "add_summary", "(", "summary", ",", "step", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.visualizer.Visualizer.print_current_errors": [[109, 117], ["errors.items", "print", "open", "log_file.write"], "methods", ["None"], ["", "", "", "def", "print_current_errors", "(", "self", ",", "epoch", ",", "i", ",", "errors", ",", "t", ")", ":", "\n", "        ", "message", "=", "'(epoch: %d, iters: %d, time: %.3f) '", "%", "(", "epoch", ",", "i", ",", "t", ")", "\n", "for", "k", ",", "v", "in", "errors", ".", "items", "(", ")", ":", "\n", "            ", "message", "+=", "'%s: %.3f '", "%", "(", "k", ",", "v", ")", "\n", "\n", "", "print", "(", "message", ")", "\n", "with", "open", "(", "self", ".", "log_name", ",", "\"a\"", ")", "as", "log_file", ":", "\n", "            ", "log_file", ".", "write", "(", "'%s\\n'", "%", "message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.visualizer.Visualizer.display_current_results_test": [[123, 180], ["visuals.items", "visualizer.Visualizer.tf.Summary", "visualizer.Visualizer.writer_test.add_summary", "visuals.items", "html.HTML", "range", "html.HTML.save", "scipy.misc.toimage().save", "visualizer.Visualizer.tf.Summary.Image", "img_summaries.append", "isinstance", "html.HTML.add_header", "visuals.items", "StringIO", "visualizer.Visualizer.tf.Summary.Value", "range", "os.path.join", "utils.save_image", "isinstance", "len", "html.HTML.add_images", "int", "html.HTML.add_images", "html.HTML.add_images", "BytesIO", "scipy.misc.toimage", "BytesIO.getvalue", "len", "os.path.join", "utils.save_image", "range", "ims.append", "txts.append", "links.append", "round", "len", "ims.append", "txts.append", "links.append", "len", "str"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.save", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.save", "home.repos.pwc.inspect_result.ailon-island_facke.utils.html.HTML.add_header", "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.save_image", "home.repos.pwc.inspect_result.ailon-island_facke.utils.html.HTML.add_images", "home.repos.pwc.inspect_result.ailon-island_facke.utils.html.HTML.add_images", "home.repos.pwc.inspect_result.ailon-island_facke.utils.html.HTML.add_images", "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.save_image"], ["", "", "def", "display_current_results_test", "(", "self", ",", "visuals", ",", "epoch", ",", "step", ")", ":", "\n", "        ", "if", "self", ".", "tf_log", ":", "# show images in tensorboard output", "\n", "            ", "img_summaries", "=", "[", "]", "\n", "for", "label", ",", "image_numpy", "in", "visuals", ".", "items", "(", ")", ":", "\n", "# Write the image to a string", "\n", "                ", "try", ":", "\n", "                    ", "s", "=", "StringIO", "(", ")", "\n", "", "except", ":", "\n", "                    ", "s", "=", "BytesIO", "(", ")", "\n", "", "scipy", ".", "misc", ".", "toimage", "(", "image_numpy", ")", ".", "save", "(", "s", ",", "format", "=", "\"jpeg\"", ")", "\n", "# Create an Image object", "\n", "img_sum", "=", "self", ".", "tf", ".", "Summary", ".", "Image", "(", "encoded_image_string", "=", "s", ".", "getvalue", "(", ")", ",", "height", "=", "image_numpy", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "image_numpy", ".", "shape", "[", "1", "]", ")", "\n", "# Create a Summary value", "\n", "img_summaries", ".", "append", "(", "self", ".", "tf", ".", "Summary", ".", "Value", "(", "tag", "=", "label", ",", "image", "=", "img_sum", ")", ")", "\n", "\n", "# Create and write Summary", "\n", "", "summary", "=", "self", ".", "tf", ".", "Summary", "(", "value", "=", "img_summaries", ")", "\n", "self", ".", "writer_test", ".", "add_summary", "(", "summary", ",", "step", ")", "\n", "\n", "", "if", "self", ".", "use_html", ":", "# save images to a html file", "\n", "            ", "for", "label", ",", "image_numpy", "in", "visuals", ".", "items", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "image_numpy", ",", "list", ")", ":", "\n", "                    ", "for", "i", "in", "range", "(", "len", "(", "image_numpy", ")", ")", ":", "\n", "                        ", "img_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "img_dir", ",", "'epoch%.3d_%s_%d_test.jpg'", "%", "(", "epoch", ",", "label", ",", "i", ")", ")", "\n", "util", ".", "save_image", "(", "image_numpy", "[", "i", "]", ",", "img_path", ")", "\n", "", "", "else", ":", "\n", "                    ", "img_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "img_dir", ",", "'epoch%.3d_%s_test.jpg'", "%", "(", "epoch", ",", "label", ")", ")", "\n", "util", ".", "save_image", "(", "image_numpy", ",", "img_path", ")", "\n", "\n", "# update website", "\n", "", "", "webpage", "=", "html", ".", "HTML", "(", "self", ".", "web_dir", ",", "'Experiment name = %s'", "%", "self", ".", "name", ",", "refresh", "=", "30", ")", "\n", "for", "n", "in", "range", "(", "epoch", ",", "0", ",", "-", "1", ")", ":", "\n", "                ", "webpage", ".", "add_header", "(", "'epoch [%d]'", "%", "n", ")", "\n", "ims", "=", "[", "]", "\n", "txts", "=", "[", "]", "\n", "links", "=", "[", "]", "\n", "\n", "for", "label", ",", "image_numpy", "in", "visuals", ".", "items", "(", ")", ":", "\n", "                    ", "if", "isinstance", "(", "image_numpy", ",", "list", ")", ":", "\n", "                        ", "for", "i", "in", "range", "(", "len", "(", "image_numpy", ")", ")", ":", "\n", "                            ", "img_path", "=", "'epoch%.3d_%s_%d_test.jpg'", "%", "(", "n", ",", "label", ",", "i", ")", "\n", "ims", ".", "append", "(", "img_path", ")", "\n", "txts", ".", "append", "(", "label", "+", "str", "(", "i", ")", ")", "\n", "links", ".", "append", "(", "img_path", ")", "\n", "", "", "else", ":", "\n", "                        ", "img_path", "=", "'epoch%.3d_%s_test.jpg'", "%", "(", "n", ",", "label", ")", "\n", "ims", ".", "append", "(", "img_path", ")", "\n", "txts", ".", "append", "(", "label", ")", "\n", "links", ".", "append", "(", "img_path", ")", "\n", "", "", "if", "len", "(", "ims", ")", "<", "10", ":", "\n", "                    ", "webpage", ".", "add_images", "(", "ims", ",", "txts", ",", "links", ",", "width", "=", "self", ".", "win_size", ")", "\n", "", "else", ":", "\n", "                    ", "num", "=", "int", "(", "round", "(", "len", "(", "ims", ")", "/", "2.0", ")", ")", "\n", "webpage", ".", "add_images", "(", "ims", "[", ":", "num", "]", ",", "txts", "[", ":", "num", "]", ",", "links", "[", ":", "num", "]", ",", "width", "=", "self", ".", "win_size", ")", "\n", "webpage", ".", "add_images", "(", "ims", "[", "num", ":", "]", ",", "txts", "[", "num", ":", "]", ",", "links", "[", "num", ":", "]", ",", "width", "=", "self", ".", "win_size", ")", "\n", "", "", "webpage", ".", "save", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.visualizer.Visualizer.plot_current_errors_test": [[182, 187], ["errors.items", "visualizer.Visualizer.tf.Summary", "visualizer.Visualizer.writer.add_summary", "visualizer.Visualizer.tf.Summary.Value"], "methods", ["None"], ["", "", "def", "plot_current_errors_test", "(", "self", ",", "errors", ",", "step", ")", ":", "\n", "        ", "if", "self", ".", "tf_log", ":", "\n", "            ", "for", "tag", ",", "value", "in", "errors", ".", "items", "(", ")", ":", "\n", "                ", "summary", "=", "self", ".", "tf", ".", "Summary", "(", "value", "=", "[", "self", ".", "tf", ".", "Summary", ".", "Value", "(", "tag", "=", "tag", ",", "simple_value", "=", "value", ")", "]", ")", "\n", "self", ".", "writer", ".", "add_summary", "(", "summary", ",", "step", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.visualizer.Visualizer.print_current_errors_test": [[189, 198], ["errors.items", "print", "open", "log_file.write"], "methods", ["None"], ["", "", "", "def", "print_current_errors_test", "(", "self", ",", "epoch", ",", "i", ",", "errors", ",", "t", ")", ":", "\n", "        ", "message", "=", "'(TEST epoch: %d, iters: %d, time: %.3f) '", "%", "(", "epoch", ",", "i", ",", "t", ")", "\n", "for", "k", ",", "v", "in", "errors", ".", "items", "(", ")", ":", "\n", "            ", "if", "v", "!=", "0", ":", "\n", "                ", "message", "+=", "'%s: %.3f '", "%", "(", "k", ",", "v", ")", "\n", "\n", "", "", "print", "(", "message", ")", "\n", "with", "open", "(", "self", ".", "log_name", ",", "\"a\"", ")", "as", "log_file", ":", "\n", "            ", "log_file", ".", "write", "(", "'%s\\n'", "%", "message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.visualizer.Visualizer.save_images": [[204, 223], ["webpage.get_image_dir", "ntpath.basename", "webpage.add_header", "visuals.items", "webpage.add_images", "os.path.splitext", "os.path.join", "utils.save_image", "ims.append", "txts.append", "links.append"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.utils.html.HTML.get_image_dir", "home.repos.pwc.inspect_result.ailon-island_facke.utils.html.HTML.add_header", "home.repos.pwc.inspect_result.ailon-island_facke.utils.html.HTML.add_images", "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.save_image"], ["", "", "def", "save_images", "(", "self", ",", "webpage", ",", "visuals", ",", "image_path", ")", ":", "\n", "        ", "image_dir", "=", "webpage", ".", "get_image_dir", "(", ")", "\n", "short_path", "=", "ntpath", ".", "basename", "(", "image_path", "[", "0", "]", ")", "\n", "name", "=", "os", ".", "path", ".", "splitext", "(", "short_path", ")", "[", "0", "]", "\n", "\n", "webpage", ".", "add_header", "(", "name", ")", "\n", "ims", "=", "[", "]", "\n", "txts", "=", "[", "]", "\n", "links", "=", "[", "]", "\n", "\n", "for", "label", ",", "image_numpy", "in", "visuals", ".", "items", "(", ")", ":", "\n", "            ", "image_name", "=", "'%s_%s.jpg'", "%", "(", "name", ",", "label", ")", "\n", "save_path", "=", "os", ".", "path", ".", "join", "(", "image_dir", ",", "image_name", ")", "\n", "util", ".", "save_image", "(", "image_numpy", ",", "save_path", ")", "\n", "\n", "ims", ".", "append", "(", "image_name", ")", "\n", "txts", ".", "append", "(", "label", ")", "\n", "links", ".", "append", "(", "image_name", ")", "\n", "", "webpage", ".", "add_images", "(", "ims", ",", "txts", ",", "links", ",", "width", "=", "self", ".", "win_size", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.IDExtract.IDExtractor.__init__": [[7, 33], ["torch.nn.Module.__init__", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "IDExtract.IDExtractor.net.eval", "torchvision.transforms.Normalize", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "IDExtract.IDExtractor.net.to", "IDExtract.IDExtractor.net.to", "torchvision.transforms.Normalize", "torch.device", "torch.device", "torch.device", "torch.device"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.load", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.load", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.load", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.load", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.load", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.load", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.load", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.load"], ["    ", "def", "__init__", "(", "self", ",", "opt", ",", "model", "=", "'Arcface'", ")", ":", "\n", "        ", "super", "(", "IDExtractor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "model", "==", "'Arcface'", ":", "\n", "            ", "checkpoint", "=", "opt", ".", "Arc_path", "\n", "self", ".", "interp_size", "=", "(", "112", ",", "112", ")", "\n", "", "elif", "model", "==", "'Cosface'", ":", "\n", "            ", "checkpoint", "=", "opt", ".", "Cos_path", "\n", "self", ".", "interp_size", "=", "(", "112", ",", "96", ")", "\n", "\n", "\n", "", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "checkpoint", "=", "torch", ".", "load", "(", "checkpoint", ")", "\n", "", "else", ":", "\n", "            ", "checkpoint", "=", "torch", ".", "load", "(", "checkpoint", ",", "map_location", "=", "torch", ".", "device", "(", "'cpu'", ")", ")", "\n", "", "self", ".", "net", "=", "checkpoint", "[", "'model'", "]", ".", "module", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "self", ".", "net", "=", "self", ".", "net", ".", "to", "(", "'cuda'", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "net", "=", "self", ".", "net", ".", "to", "(", "'cpu'", ")", "\n", "", "self", ".", "net", ".", "eval", "(", ")", "\n", "\n", "# transformation", "\n", "self", ".", "INnorm", "=", "transforms", ".", "Normalize", "(", "(", "0.485", ",", "0.456", ",", "0.406", ")", ",", "(", "0.229", ",", "0.224", ",", "0.225", ")", ")", "# normalization of ImageNet", "\n", "self", ".", "transform", "=", "transforms", ".", "Normalize", "(", "mean", "=", "(", "0.5", ",", "0.5", ",", "0.5", ")", ",", "std", "=", "(", "0.5", ",", "0.5", ",", "0.5", ")", ")", "if", "model", "==", "'CosFace'", "else", "self", ".", "INnorm", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.IDExtract.IDExtractor.forward": [[34, 41], ["torch.interpolate", "torch.interpolate", "IDExtract.IDExtractor.net", "torch.normalize", "torch.normalize"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "img", ")", ":", "\n", "        ", "img_interp", "=", "F", ".", "interpolate", "(", "img", ",", "size", "=", "self", ".", "interp_size", ")", "\n", "# img_interp = self.transform(img_interp)", "\n", "latent_ID", "=", "self", ".", "net", "(", "img_interp", ")", "\n", "latent_ID", "=", "F", ".", "normalize", "(", "latent_ID", ",", "p", "=", "2", ",", "dim", "=", "1", ")", "\n", "\n", "return", "latent_ID", "", "", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.resizer.Resizer.__init__": [[9, 54], ["torch.nn.Module.__init__", "resizer.Resizer.fix_scale_and_size", "numpy.any", "numpy.argsort", "torch.nn.ParameterList", "torch.nn.ParameterList", "numpy.array", "int", "resizer.Resizer.contributions", "torch.tensor", "weights_list.append", "field_of_view_list.append", "numpy.array", "torch.nn.Parameter", "torch.nn.Parameter", "torch.reshape", "torch.tensor", "field_of_view.T.astype", "list", "len"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__", "home.repos.pwc.inspect_result.ailon-island_facke.utils.resizer.Resizer.fix_scale_and_size", "home.repos.pwc.inspect_result.ailon-island_facke.utils.resizer.Resizer.contributions"], ["    ", "def", "__init__", "(", "self", ",", "in_shape", ",", "scale_factor", "=", "None", ",", "output_shape", "=", "None", ",", "kernel", "=", "None", ",", "antialiasing", "=", "True", ")", ":", "\n", "        ", "super", "(", "Resizer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# First standardize values and fill missing arguments (if needed) by deriving scale from output shape or vice versa", "\n", "scale_factor", ",", "output_shape", "=", "self", ".", "fix_scale_and_size", "(", "in_shape", ",", "output_shape", ",", "scale_factor", ")", "\n", "\n", "# Choose interpolation method, each method has the matching kernel size", "\n", "method", ",", "kernel_width", "=", "{", "\n", "\"cubic\"", ":", "(", "cubic", ",", "4.0", ")", ",", "\n", "\"lanczos2\"", ":", "(", "lanczos2", ",", "4.0", ")", ",", "\n", "\"lanczos3\"", ":", "(", "lanczos3", ",", "6.0", ")", ",", "\n", "\"box\"", ":", "(", "box", ",", "1.0", ")", ",", "\n", "\"linear\"", ":", "(", "linear", ",", "2.0", ")", ",", "\n", "None", ":", "(", "cubic", ",", "4.0", ")", "# set default interpolation method as cubic", "\n", "}", ".", "get", "(", "kernel", ")", "\n", "\n", "# Antialiasing is only used when downscaling", "\n", "antialiasing", "*=", "(", "np", ".", "any", "(", "np", ".", "array", "(", "scale_factor", ")", "<", "1", ")", ")", "\n", "\n", "# Sort indices of dimensions according to scale of each dimension. since we are going dim by dim this is efficient", "\n", "sorted_dims", "=", "np", ".", "argsort", "(", "np", ".", "array", "(", "scale_factor", ")", ")", "\n", "self", ".", "sorted_dims", "=", "[", "int", "(", "dim", ")", "for", "dim", "in", "sorted_dims", "if", "scale_factor", "[", "dim", "]", "!=", "1", "]", "\n", "\n", "# Iterate over dimensions to calculate local weights for resizing and resize each time in one direction", "\n", "field_of_view_list", "=", "[", "]", "\n", "weights_list", "=", "[", "]", "\n", "for", "dim", "in", "self", ".", "sorted_dims", ":", "\n", "# for each coordinate (along 1 dim), calculate which coordinates in the input image affect its result and the", "\n", "# weights that multiply the values there to get its result.", "\n", "            ", "weights", ",", "field_of_view", "=", "self", ".", "contributions", "(", "in_shape", "[", "dim", "]", ",", "output_shape", "[", "dim", "]", ",", "scale_factor", "[", "dim", "]", ",", "method", ",", "\n", "kernel_width", ",", "antialiasing", ")", "\n", "\n", "# convert to torch tensor", "\n", "weights", "=", "torch", ".", "tensor", "(", "weights", ".", "T", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "# We add singleton dimensions to the weight matrix so we can multiply it with the big tensor we get for", "\n", "# tmp_im[field_of_view.T], (bsxfun style)", "\n", "weights_list", ".", "append", "(", "\n", "nn", ".", "Parameter", "(", "torch", ".", "reshape", "(", "weights", ",", "list", "(", "weights", ".", "shape", ")", "+", "(", "len", "(", "scale_factor", ")", "-", "1", ")", "*", "[", "1", "]", ")", ",", "\n", "requires_grad", "=", "False", ")", ")", "\n", "field_of_view_list", ".", "append", "(", "\n", "nn", ".", "Parameter", "(", "torch", ".", "tensor", "(", "field_of_view", ".", "T", ".", "astype", "(", "np", ".", "int32", ")", ",", "dtype", "=", "torch", ".", "long", ")", ",", "requires_grad", "=", "False", ")", ")", "\n", "\n", "", "self", ".", "field_of_view", "=", "nn", ".", "ParameterList", "(", "field_of_view_list", ")", "\n", "self", ".", "weights", "=", "nn", ".", "ParameterList", "(", "weights_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.resizer.Resizer.forward": [[55, 75], ["zip", "torch.transpose", "torch.sum", "torch.transpose"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "in_tensor", ")", ":", "\n", "        ", "x", "=", "in_tensor", "\n", "\n", "# Use the affecting position values and the set of weights to calculate the result of resizing along this 1 dim", "\n", "for", "dim", ",", "fov", ",", "w", "in", "zip", "(", "self", ".", "sorted_dims", ",", "self", ".", "field_of_view", ",", "self", ".", "weights", ")", ":", "\n", "# To be able to act on each dim, we swap so that dim 0 is the wanted dim to resize", "\n", "            ", "x", "=", "torch", ".", "transpose", "(", "x", ",", "dim", ",", "0", ")", "\n", "\n", "# This is a bit of a complicated multiplication: x[field_of_view.T] is a tensor of order image_dims+1.", "\n", "# for each pixel in the output-image it matches the positions the influence it from the input image (along 1 dim", "\n", "# only, this is why it only adds 1 dim to 5the shape). We then multiply, for each pixel, its set of positions with", "\n", "# the matching set of weights. we do this by this big tensor element-wise multiplication (MATLAB bsxfun style:", "\n", "# matching dims are multiplied element-wise while singletons mean that the matching dim is all multiplied by the", "\n", "# same number", "\n", "x", "=", "torch", ".", "sum", "(", "x", "[", "fov", "]", "*", "w", ",", "dim", "=", "0", ")", "\n", "\n", "# Finally we swap back the axes to the original order", "\n", "x", "=", "torch", ".", "transpose", "(", "x", ",", "dim", ",", "0", ")", "\n", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.resizer.Resizer.fix_scale_and_size": [[76, 103], ["list", "numpy.uint", "numpy.isscalar", "list", "list", "numpy.array", "numpy.ceil", "len", "numpy.uint", "numpy.array", "len", "len", "numpy.array", "numpy.array", "numpy.array", "len"], "methods", ["None"], ["", "def", "fix_scale_and_size", "(", "self", ",", "input_shape", ",", "output_shape", ",", "scale_factor", ")", ":", "\n", "# First fixing the scale-factor (if given) to be standardized the function expects (a list of scale factors in the", "\n", "# same size as the number of input dimensions)", "\n", "        ", "if", "scale_factor", "is", "not", "None", ":", "\n", "# By default, if scale-factor is a scalar we assume 2d resizing and duplicate it.", "\n", "            ", "if", "np", ".", "isscalar", "(", "scale_factor", ")", "and", "len", "(", "input_shape", ")", ">", "1", ":", "\n", "                ", "scale_factor", "=", "[", "scale_factor", ",", "scale_factor", "]", "\n", "\n", "# We extend the size of scale-factor list to the size of the input by assigning 1 to all the unspecified scales", "\n", "", "scale_factor", "=", "list", "(", "scale_factor", ")", "\n", "scale_factor", "=", "[", "1", "]", "*", "(", "len", "(", "input_shape", ")", "-", "len", "(", "scale_factor", ")", ")", "+", "scale_factor", "\n", "\n", "# Fixing output-shape (if given): extending it to the size of the input-shape, by assigning the original input-size", "\n", "# to all the unspecified dimensions", "\n", "", "if", "output_shape", "is", "not", "None", ":", "\n", "            ", "output_shape", "=", "list", "(", "input_shape", "[", "len", "(", "output_shape", ")", ":", "]", ")", "+", "list", "(", "np", ".", "uint", "(", "np", ".", "array", "(", "output_shape", ")", ")", ")", "\n", "\n", "# Dealing with the case of non-give scale-factor, calculating according to output-shape. note that this is", "\n", "# sub-optimal, because there can be different scales to the same output-shape.", "\n", "", "if", "scale_factor", "is", "None", ":", "\n", "            ", "scale_factor", "=", "1.0", "*", "np", ".", "array", "(", "output_shape", ")", "/", "np", ".", "array", "(", "input_shape", ")", "\n", "\n", "# Dealing with missing output-shape. calculating according to scale-factor", "\n", "", "if", "output_shape", "is", "None", ":", "\n", "            ", "output_shape", "=", "np", ".", "uint", "(", "np", ".", "ceil", "(", "np", ".", "array", "(", "input_shape", ")", "*", "np", ".", "array", "(", "scale_factor", ")", ")", ")", "\n", "\n", "", "return", "scale_factor", ",", "output_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.resizer.Resizer.contributions": [[104, 168], ["numpy.arange", "numpy.floor", "numpy.squeeze", "fixed_kernel", "numpy.sum", "numpy.uint", "numpy.nonzero", "numpy.squeeze", "numpy.squeeze", "numpy.ceil", "numpy.int16", "numpy.expand_dims", "numpy.concatenate", "numpy.any", "numpy.mod", "kernel", "numpy.arange", "numpy.arange", "numpy.expand_dims", "numpy.arange", "numpy.expand_dims"], "methods", ["None"], ["", "def", "contributions", "(", "self", ",", "in_length", ",", "out_length", ",", "scale", ",", "kernel", ",", "kernel_width", ",", "antialiasing", ")", ":", "\n", "# This function calculates a set of 'filters' and a set of field_of_view that will later on be applied", "\n", "# such that each position from the field_of_view will be multiplied with a matching filter from the", "\n", "# 'weights' based on the interpolation method and the distance of the sub-pixel location from the pixel centers", "\n", "# around it. This is only done for one dimension of the image.", "\n", "\n", "# When anti-aliasing is activated (default and only for downscaling) the receptive field is stretched to size of", "\n", "# 1/sf. this means filtering is more 'low-pass filter'.", "\n", "        ", "fixed_kernel", "=", "(", "lambda", "arg", ":", "scale", "*", "kernel", "(", "scale", "*", "arg", ")", ")", "if", "antialiasing", "else", "kernel", "\n", "kernel_width", "*=", "1.0", "/", "scale", "if", "antialiasing", "else", "1.0", "\n", "\n", "# These are the coordinates of the output image", "\n", "out_coordinates", "=", "np", ".", "arange", "(", "1", ",", "out_length", "+", "1", ")", "\n", "\n", "# since both scale-factor and output size can be provided simulatneously, perserving the center of the image requires shifting", "\n", "# the output coordinates. the deviation is because out_length doesn't necesary equal in_length*scale.", "\n", "# to keep the center we need to subtract half of this deivation so that we get equal margins for boths sides and center is preserved.", "\n", "shifted_out_coordinates", "=", "out_coordinates", "-", "(", "out_length", "-", "in_length", "*", "scale", ")", "/", "2", "\n", "\n", "# These are the matching positions of the output-coordinates on the input image coordinates.", "\n", "# Best explained by example: say we have 4 horizontal pixels for HR and we downscale by SF=2 and get 2 pixels:", "\n", "# [1,2,3,4] -> [1,2]. Remember each pixel number is the middle of the pixel.", "\n", "# The scaling is done between the distances and not pixel numbers (the right boundary of pixel 4 is transformed to", "\n", "# the right boundary of pixel 2. pixel 1 in the small image matches the boundary between pixels 1 and 2 in the big", "\n", "# one and not to pixel 2. This means the position is not just multiplication of the old pos by scale-factor).", "\n", "# So if we measure distance from the left border, middle of pixel 1 is at distance d=0.5, border between 1 and 2 is", "\n", "# at d=1, and so on (d = p - 0.5).  we calculate (d_new = d_old / sf) which means:", "\n", "# (p_new-0.5 = (p_old-0.5) / sf)     ->          p_new = p_old/sf + 0.5 * (1-1/sf)", "\n", "match_coordinates", "=", "shifted_out_coordinates", "/", "scale", "+", "0.5", "*", "(", "1", "-", "1", "/", "scale", ")", "\n", "\n", "# This is the left boundary to start multiplying the filter from, it depends on the size of the filter", "\n", "left_boundary", "=", "np", ".", "floor", "(", "match_coordinates", "-", "kernel_width", "/", "2", ")", "\n", "\n", "# Kernel width needs to be enlarged because when covering has sub-pixel borders, it must 'see' the pixel centers", "\n", "# of the pixels it only covered a part from. So we add one pixel at each side to consider (weights can zeroize them)", "\n", "expanded_kernel_width", "=", "np", ".", "ceil", "(", "kernel_width", ")", "+", "2", "\n", "\n", "# Determine a set of field_of_view for each each output position, these are the pixels in the input image", "\n", "# that the pixel in the output image 'sees'. We get a matrix whos horizontal dim is the output pixels (big) and the", "\n", "# vertical dim is the pixels it 'sees' (kernel_size + 2)", "\n", "field_of_view", "=", "np", ".", "squeeze", "(", "\n", "np", ".", "int16", "(", "np", ".", "expand_dims", "(", "left_boundary", ",", "axis", "=", "1", ")", "+", "np", ".", "arange", "(", "expanded_kernel_width", ")", "-", "1", ")", ")", "\n", "\n", "# Assign weight to each pixel in the field of view. A matrix whos horizontal dim is the output pixels and the", "\n", "# vertical dim is a list of weights matching to the pixel in the field of view (that are specified in", "\n", "# 'field_of_view')", "\n", "weights", "=", "fixed_kernel", "(", "1.0", "*", "np", ".", "expand_dims", "(", "match_coordinates", ",", "axis", "=", "1", ")", "-", "field_of_view", "-", "1", ")", "\n", "\n", "# Normalize weights to sum up to 1. be careful from dividing by 0", "\n", "sum_weights", "=", "np", ".", "sum", "(", "weights", ",", "axis", "=", "1", ")", "\n", "sum_weights", "[", "sum_weights", "==", "0", "]", "=", "1.0", "\n", "weights", "=", "1.0", "*", "weights", "/", "np", ".", "expand_dims", "(", "sum_weights", ",", "axis", "=", "1", ")", "\n", "\n", "# We use this mirror structure as a trick for reflection padding at the boundaries", "\n", "mirror", "=", "np", ".", "uint", "(", "np", ".", "concatenate", "(", "(", "np", ".", "arange", "(", "in_length", ")", ",", "np", ".", "arange", "(", "in_length", "-", "1", ",", "-", "1", ",", "step", "=", "-", "1", ")", ")", ")", ")", "\n", "field_of_view", "=", "mirror", "[", "np", ".", "mod", "(", "field_of_view", ",", "mirror", ".", "shape", "[", "0", "]", ")", "]", "\n", "\n", "# Get rid of  weights and pixel positions that are of zero weight", "\n", "non_zero_out_pixels", "=", "np", ".", "nonzero", "(", "np", ".", "any", "(", "weights", ",", "axis", "=", "0", ")", ")", "\n", "weights", "=", "np", ".", "squeeze", "(", "weights", "[", ":", ",", "non_zero_out_pixels", "]", ")", "\n", "field_of_view", "=", "np", ".", "squeeze", "(", "field_of_view", "[", ":", ",", "non_zero_out_pixels", "]", ")", "\n", "\n", "# Final products are the relative positions and the matching weights, both are output_size X fixed_kernel_size", "\n", "return", "weights", ",", "field_of_view", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.resizer.cubic": [[173, 179], ["numpy.abs"], "function", ["None"], ["", "", "def", "cubic", "(", "x", ")", ":", "\n", "    ", "absx", "=", "np", ".", "abs", "(", "x", ")", "\n", "absx2", "=", "absx", "**", "2", "\n", "absx3", "=", "absx", "**", "3", "\n", "return", "(", "(", "1.5", "*", "absx3", "-", "2.5", "*", "absx2", "+", "1", ")", "*", "(", "absx", "<=", "1", ")", "+", "\n", "(", "-", "0.5", "*", "absx3", "+", "2.5", "*", "absx2", "-", "4", "*", "absx", "+", "2", ")", "*", "(", "(", "1", "<", "absx", ")", "&", "(", "absx", "<=", "2", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.resizer.lanczos2": [[181, 185], ["abs", "numpy.sin", "numpy.sin", "numpy.finfo", "numpy.finfo"], "function", ["None"], ["", "def", "lanczos2", "(", "x", ")", ":", "\n", "    ", "return", "(", "(", "(", "np", ".", "sin", "(", "pi", "*", "x", ")", "*", "np", ".", "sin", "(", "pi", "*", "x", "/", "2", ")", "+", "np", ".", "finfo", "(", "np", ".", "float32", ")", ".", "eps", ")", "/", "\n", "(", "(", "pi", "**", "2", "*", "x", "**", "2", "/", "2", ")", "+", "np", ".", "finfo", "(", "np", ".", "float32", ")", ".", "eps", ")", ")", "\n", "*", "(", "abs", "(", "x", ")", "<", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.resizer.box": [[187, 189], ["None"], "function", ["None"], ["", "def", "box", "(", "x", ")", ":", "\n", "    ", "return", "(", "(", "-", "0.5", "<=", "x", ")", "&", "(", "x", "<", "0.5", ")", ")", "*", "1.0", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.resizer.lanczos3": [[191, 195], ["abs", "numpy.sin", "numpy.sin", "numpy.finfo", "numpy.finfo"], "function", ["None"], ["", "def", "lanczos3", "(", "x", ")", ":", "\n", "    ", "return", "(", "(", "(", "np", ".", "sin", "(", "pi", "*", "x", ")", "*", "np", ".", "sin", "(", "pi", "*", "x", "/", "3", ")", "+", "np", ".", "finfo", "(", "np", ".", "float32", ")", ".", "eps", ")", "/", "\n", "(", "(", "pi", "**", "2", "*", "x", "**", "2", "/", "3", ")", "+", "np", ".", "finfo", "(", "np", ".", "float32", ")", ".", "eps", ")", ")", "\n", "*", "(", "abs", "(", "x", ")", "<", "3", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.resizer.linear": [[197, 199], ["None"], "function", ["None"], ["", "def", "linear", "(", "x", ")", ":", "\n", "    ", "return", "(", "x", "+", "1", ")", "*", "(", "(", "-", "1", "<=", "x", ")", "&", "(", "x", "<", "0", ")", ")", "+", "(", "1", "-", "x", ")", "*", "(", "(", "0", "<=", "x", ")", "&", "(", "x", "<=", "1", ")", ")", "", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.GANLoss.__init__": [[15, 26], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["    ", "def", "__init__", "(", "self", ",", "gan_mode", ",", "real_label", "=", "1.", ",", "fake_label", "=", "0.", ",", "Tensor", "=", "torch", ".", "FloatTensor", ",", "opt", "=", "None", ")", ":", "\n", "        ", "super", "(", "GANLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "gan_mode", "=", "gan_mode", "\n", "self", ".", "real_label", "=", "real_label", "\n", "self", ".", "fake_label", "=", "fake_label", "\n", "self", ".", "real_label_tensor", "=", "None", "\n", "self", ".", "fake_label_tensor", "=", "None", "\n", "self", ".", "zero_tensor", "=", "None", "\n", "self", ".", "Tensor", "=", "Tensor", "\n", "self", ".", "opt", "=", "opt", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.GANLoss.get_target_tensor": [[28, 39], ["loss.GANLoss.real_label_tensor.expand_as", "loss.GANLoss.fake_label_tensor.expand_as", "loss.GANLoss.Tensor().fill_", "loss.GANLoss.real_label_tensor.requires_grad_", "loss.GANLoss.Tensor().fill_", "loss.GANLoss.fake_label_tensor.requires_grad_", "loss.GANLoss.Tensor", "loss.GANLoss.Tensor"], "methods", ["None"], ["", "def", "get_target_tensor", "(", "self", ",", "input", ",", "is_real", ")", ":", "\n", "        ", "if", "is_real", ":", "\n", "            ", "if", "self", ".", "real_label_tensor", "==", "None", ":", "\n", "                ", "self", ".", "real_label_tensor", "=", "self", ".", "Tensor", "(", "1", ")", ".", "fill_", "(", "self", ".", "real_label", ")", "\n", "self", ".", "real_label_tensor", ".", "requires_grad_", "(", "False", ")", "\n", "", "return", "self", ".", "real_label_tensor", ".", "expand_as", "(", "input", ")", "\n", "", "else", ":", "# fake", "\n", "            ", "if", "self", ".", "fake_label_tensor", "==", "None", ":", "\n", "                ", "self", ".", "fake_label_tensor", "=", "self", ".", "Tensor", "(", "1", ")", ".", "fill_", "(", "self", ".", "fake_label", ")", "\n", "self", ".", "fake_label_tensor", ".", "requires_grad_", "(", "False", ")", "\n", "", "return", "self", ".", "fake_label_tensor", ".", "expand_as", "(", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.GANLoss.get_zero_tensor": [[41, 46], ["loss.GANLoss.zero_tensor.expand_as", "loss.GANLoss.Tensor().fill_", "loss.GANLoss.zero_tensor.requires_grad_", "loss.GANLoss.Tensor"], "methods", ["None"], ["", "", "def", "get_zero_tensor", "(", "self", ",", "input", ")", ":", "\n", "        ", "if", "self", ".", "zero_tensor", "==", "None", ":", "\n", "            ", "self", ".", "zero_tensor", "=", "self", ".", "Tensor", "(", "1", ")", ".", "fill_", "(", "0", ")", "\n", "self", ".", "zero_tensor", ".", "requires_grad_", "(", "False", ")", "\n", "", "return", "self", ".", "zero_tensor", ".", "expand_as", "(", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.GANLoss.loss": [[48, 69], ["input.mean.GANLoss.get_target_tensor", "torch.binary_cross_entropy_with_logits", "torch.binary_cross_entropy_with_logits", "input.mean.GANLoss.get_target_tensor", "torch.mse_loss", "torch.mse_loss", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "input.mean", "input.mean.GANLoss.get_zero_tensor", "input.mean.GANLoss.get_zero_tensor", "input.mean"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.GANLoss.get_target_tensor", "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.GANLoss.get_target_tensor", "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.GANLoss.get_zero_tensor", "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.GANLoss.get_zero_tensor"], ["", "def", "loss", "(", "self", ",", "input", ",", "is_real", ",", "forD", "=", "True", ")", ":", "\n", "        ", "if", "self", ".", "gan_mode", "==", "'original'", ":", "# cross entropy", "\n", "            ", "target_tensor", "=", "self", ".", "get_target_tensor", "(", "input", ",", "is_real", ")", "\n", "loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "input", ",", "target_tensor", ")", "\n", "", "elif", "self", ".", "gan_mode", "==", "'ls'", ":", "\n", "            ", "target_tensor", "=", "self", ".", "get_target_tensor", "(", "input", ",", "is_real", ")", "# MSE loss", "\n", "loss", "=", "F", ".", "mse_loss", "(", "input", ",", "target_tensor", ")", "\n", "", "elif", "self", ".", "gan_mode", "==", "'hinge'", ":", "\n", "            ", "if", "forD", ":", "\n", "                ", "if", "is_real", ":", "\n", "                    ", "minval", "=", "torch", ".", "min", "(", "input", "-", "1", ",", "self", ".", "get_zero_tensor", "(", "input", ")", ")", "\n", "", "else", ":", "\n", "                    ", "minval", "=", "torch", ".", "min", "(", "-", "input", "-", "1", ",", "self", ".", "get_zero_tensor", "(", "input", ")", ")", "\n", "", "loss", "=", "-", "torch", ".", "mean", "(", "minval", ")", "\n", "", "else", ":", "# wgan", "\n", "                ", "if", "is_real", ":", "\n", "                    ", "loss", "=", "-", "input", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "                    ", "loss", "=", "input", ".", "mean", "(", ")", "\n", "\n", "", "", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.GANLoss.__call__": [[71, 86], ["isinstance", "loss.GANLoss.loss", "isinstance", "loss.GANLoss.loss", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "len", "loss.GANLoss.size", "loss.GANLoss.view", "len", "loss.GANLoss.size"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.GANLoss.loss", "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.GANLoss.loss"], ["", "def", "__call__", "(", "self", ",", "input", ",", "is_real", ",", "forD", "=", "True", ")", ":", "\n", "        ", "if", "isinstance", "(", "input", ",", "list", ")", ":", "\n", "            ", "loss", "=", "0", "\n", "for", "pred", "in", "input", ":", "\n", "                ", "if", "isinstance", "(", "pred", ",", "list", ")", ":", "\n", "                    ", "pred", "=", "pred", "[", "-", "1", "]", "\n", "\n", "", "loss_tensor", "=", "self", ".", "loss", "(", "pred", ",", "is_real", ",", "forD", ")", "\n", "bs", "=", "1", "if", "len", "(", "loss_tensor", ".", "size", "(", ")", ")", "==", "0", "else", "loss_tensor", ".", "size", "(", "0", ")", "# what is this bs?", "\n", "new_loss", "=", "torch", ".", "mean", "(", "loss_tensor", ".", "view", "(", "bs", ",", "-", "1", ")", ",", "dim", "=", "1", ")", "\n", "loss", "+=", "new_loss", "\n", "\n", "", "return", "loss", "/", "len", "(", "input", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "loss", "(", "input", ",", "is_real", ",", "forD", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.IDLoss.__init__": [[90, 94], ["torch.nn.Module.__init__", "torch.nn.CosineSimilarity", "torch.nn.CosineSimilarity"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "IDLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "sim", "=", "nn", ".", "CosineSimilarity", "(", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.IDLoss.forward": [[95, 100], ["loss.mean.IDLoss.sim", "loss.mean.mean.mean"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "        ", "sim", "=", "self", ".", "sim", "(", "x", ",", "y", ")", "\n", "loss", "=", "1", "-", "sim", "\n", "loss", "=", "loss", ".", "mean", "(", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.GPLoss.__init__": [[104, 106], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "GPLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.GPLoss.forward": [[107, 129], ["torch.rand().expand_as().cuda", "torch.rand().expand_as().cuda", "torch.rand().expand_as().cuda", "torch.rand().expand_as().cuda", "torch.autograd.Variable", "torch.autograd.Variable", "D.forward", "grad.view.view.view", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "grad.view.view.size", "torch.rand().expand_as", "torch.rand().expand_as", "torch.rand().expand_as", "torch.rand().expand_as", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "D.forward.size"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.forward"], ["", "def", "forward", "(", "self", ",", "D", ",", "img_real", ",", "img_fake", ")", ":", "\n", "# interpolation", "\n", "        ", "batch_size", "=", "img_fake", ".", "shape", "[", "0", "]", "\n", "alpha", "=", "torch", ".", "rand", "(", "batch_size", ",", "1", ",", "1", ",", "1", ")", ".", "expand_as", "(", "img_fake", ")", ".", "cuda", "(", ")", "\n", "img_interp", "=", "Variable", "(", "alpha", "*", "img_real", "+", "(", "1", "-", "alpha", ")", "*", "img_fake", ",", "requires_grad", "=", "True", ")", "\n", "\n", "# get gradients", "\n", "pred_interp", "=", "D", ".", "forward", "(", "img_interp", ")", "\n", "pred_interp", "=", "pred_interp", "[", "-", "1", "]", "\n", "grad", "=", "torch", ".", "autograd", ".", "grad", "(", "outputs", "=", "pred_interp", ",", "\n", "inputs", "=", "img_interp", ",", "\n", "grad_outputs", "=", "torch", ".", "ones", "(", "pred_interp", ".", "size", "(", ")", ")", ".", "cuda", "(", ")", ",", "\n", "retain_graph", "=", "True", ",", "\n", "create_graph", "=", "True", ",", "\n", "only_inputs", "=", "True", ")", "[", "0", "]", "\n", "\n", "# compute loss", "\n", "grad", "=", "grad", ".", "view", "(", "grad", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "grad_norm", "=", "torch", ".", "norm", "(", "grad", ",", "dim", "=", "1", ")", "\n", "loss", "=", "torch", ".", "mean", "(", "(", "grad_norm", "-", "1", ")", "**", "2", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.FMLoss.__init__": [[133, 149], ["torch.nn.Module.__init__", "torch.nn.L1Loss", "torch.nn.L1Loss"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "FMLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "opt", ".", "feat_mode", "==", "\"w\"", ":", "\n", "            ", "self", ".", "feat_left", "=", "1", "\n", "self", ".", "feat_right", "=", "-", "1", "\n", "", "elif", "opt", ".", "feat_mode", "==", "\"o\"", ":", "\n", "            ", "self", ".", "feat_left", "=", "0", "\n", "self", ".", "feat_right", "=", "-", "1", "\n", "", "elif", "opt", ".", "feat_mode", "==", "\"w*\"", ":", "\n", "            ", "self", ".", "feat_left", "=", "0", "\n", "self", ".", "feat_right", "=", "-", "2", "\n", "# self.feat_weight = 4. / (opt.n_layers_D + 1)", "\n", "", "self", ".", "feat_weight", "=", "None", "\n", "self", ".", "D_weight", "=", "1.", "/", "opt", ".", "num_D", "\n", "self", ".", "diff", "=", "nn", ".", "L1Loss", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.FMLoss.forward": [[151, 162], ["zip", "zip", "loss.FMLoss.diff", "feat_layer_real.detach", "len"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "feat", ")", ":", "\n", "        ", "if", "self", ".", "feat_weight", "is", "None", ":", "\n", "            ", "self", ".", "feat_weight", "=", "4.", "/", "(", "len", "(", "feat", "[", "0", "]", "[", "0", "]", ")", "+", "self", ".", "feat_right", "-", "self", ".", "feat_left", ")", "\n", "\n", "", "loss", "=", "0", "\n", "for", "(", "feat_D_real", ",", "feat_D_fake", ")", "in", "zip", "(", "*", "feat", ")", ":", "\n", "            ", "for", "(", "feat_layer_real", ",", "feat_layer_fake", ")", "in", "zip", "(", "feat_D_real", "[", "self", ".", "feat_left", ":", "self", ".", "feat_right", "]", ",", "feat_D_fake", "[", "self", ".", "feat_left", ":", "self", ".", "feat_right", "]", ")", ":", "\n", "                ", "loss", "+=", "self", ".", "diff", "(", "feat_layer_real", ".", "detach", "(", ")", ",", "feat_layer_fake", ")", "\n", "", "", "loss", "=", "self", ".", "feat_weight", "*", "self", ".", "D_weight", "*", "loss", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.KLLoss.__init__": [[164, 167], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["    ", "def", "__init__", "(", "self", ",", "Weight", ")", ":", "\n", "        ", "super", "(", "KLLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "Weight", "=", "Weight", "\n", "", "def", "forward", "(", "self", ",", "mu", ",", "log_var", ")", ":", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.KLLoss.forward": [[167, 170], ["torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "log_var.exp"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "mu", ",", "log_var", ")", ":", "\n", "        ", "kld_loss", "=", "torch", ".", "mean", "(", "-", "0.5", "*", "torch", ".", "sum", "(", "1", "+", "log_var", "-", "mu", "**", "2", "-", "log_var", ".", "exp", "(", ")", ",", "dim", "=", "1", ")", ",", "dim", "=", "0", ")", "\n", "return", "self", ".", "Weight", "*", "kld_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.loss.get_loss_dict": [[7, 13], ["dict", "zip", "dict.pop"], "function", ["None"], ["def", "get_loss_dict", "(", "names", ",", "losses", ",", "opt", ")", ":", "\n", "    ", "loss_dict", "=", "dict", "(", "zip", "(", "names", ",", "losses", ")", ")", "\n", "if", "opt", ".", "no_ganFeat_loss", ":", "\n", "        ", "loss_dict", ".", "pop", "(", "'G_FM'", ")", "\n", "\n", "", "return", "loss_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.plot.postprocess": [[5, 11], ["numpy.clip"], "function", ["None"], ["def", "postprocess", "(", "x", ")", ":", "\n", "    ", "\"\"\"[0,1] to uint8.\"\"\"", "\n", "\n", "x", "=", "np", ".", "clip", "(", "255", "*", "x", ",", "0", ",", "255", ")", "\n", "x", "=", "np", ".", "cast", "[", "np", ".", "uint8", "]", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.plot.tile": [[12, 25], ["numpy.zeros", "range", "range"], "function", ["None"], ["", "def", "tile", "(", "X", ",", "rows", ",", "cols", ")", ":", "\n", "    ", "\"\"\"Tile images for display.\"\"\"", "\n", "tiling", "=", "np", ".", "zeros", "(", "(", "rows", "*", "X", ".", "shape", "[", "1", "]", ",", "cols", "*", "X", ".", "shape", "[", "2", "]", ",", "X", ".", "shape", "[", "3", "]", ")", ",", "dtype", "=", "X", ".", "dtype", ")", "\n", "for", "i", "in", "range", "(", "rows", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "cols", ")", ":", "\n", "            ", "idx", "=", "i", "*", "cols", "+", "j", "\n", "if", "idx", "<", "X", ".", "shape", "[", "0", "]", ":", "\n", "                ", "img", "=", "X", "[", "idx", ",", "...", "]", "\n", "tiling", "[", "\n", "i", "*", "X", ".", "shape", "[", "1", "]", ":", "(", "i", "+", "1", ")", "*", "X", ".", "shape", "[", "1", "]", ",", "\n", "j", "*", "X", ".", "shape", "[", "2", "]", ":", "(", "j", "+", "1", ")", "*", "X", ".", "shape", "[", "2", "]", ",", "\n", ":", "]", "=", "img", "\n", "", "", "", "return", "tiling", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.plot.plot_batch": [[27, 38], ["plot.postprocess", "math.sqrt", "math.ceil", "plot.tile", "numpy.squeeze", "PIL.Image.fromarray().save", "PIL.Image.fromarray", "numpy.random.choice"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.utils.plot.postprocess", "home.repos.pwc.inspect_result.ailon-island_facke.utils.plot.tile", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.save"], ["", "def", "plot_batch", "(", "X", ",", "out_path", ")", ":", "\n", "    ", "\"\"\"Save batch of images tiled.\"\"\"", "\n", "n_channels", "=", "X", ".", "shape", "[", "3", "]", "\n", "if", "n_channels", ">", "3", ":", "\n", "        ", "X", "=", "X", "[", ":", ",", ":", ",", ":", ",", "np", ".", "random", ".", "choice", "(", "n_channels", ",", "size", "=", "3", ")", "]", "\n", "", "X", "=", "postprocess", "(", "X", ")", "\n", "rc", "=", "math", ".", "sqrt", "(", "X", ".", "shape", "[", "0", "]", ")", "\n", "rows", "=", "cols", "=", "math", ".", "ceil", "(", "rc", ")", "\n", "canvas", "=", "tile", "(", "X", ",", "rows", ",", "cols", ")", "\n", "canvas", "=", "np", ".", "squeeze", "(", "canvas", ")", "\n", "PIL", ".", "Image", ".", "fromarray", "(", "canvas", ")", ".", "save", "(", "out_path", ")", "", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.Colorize.__init__": [[90, 93], ["utils.labelcolormap", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.labelcolormap"], ["    ", "def", "__init__", "(", "self", ",", "n", "=", "35", ")", ":", "\n", "        ", "self", ".", "cmap", "=", "labelcolormap", "(", "n", ")", "\n", "self", ".", "cmap", "=", "torch", ".", "from_numpy", "(", "self", ".", "cmap", "[", ":", "n", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.Colorize.__call__": [[94, 105], ["gray_image.size", "torch.ByteTensor().fill_", "range", "len", "torch.ByteTensor"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "gray_image", ")", ":", "\n", "        ", "size", "=", "gray_image", ".", "size", "(", ")", "\n", "color_image", "=", "torch", ".", "ByteTensor", "(", "3", ",", "size", "[", "1", "]", ",", "size", "[", "2", "]", ")", ".", "fill_", "(", "0", ")", "\n", "\n", "for", "label", "in", "range", "(", "0", ",", "len", "(", "self", ".", "cmap", ")", ")", ":", "\n", "            ", "mask", "=", "(", "label", "==", "gray_image", "[", "0", "]", ")", ".", "cpu", "(", ")", "\n", "color_image", "[", "0", "]", "[", "mask", "]", "=", "self", ".", "cmap", "[", "label", "]", "[", "0", "]", "\n", "color_image", "[", "1", "]", "[", "mask", "]", "=", "self", ".", "cmap", "[", "label", "]", "[", "1", "]", "\n", "color_image", "[", "2", "]", "[", "mask", "]", "=", "self", ".", "cmap", "[", "label", "]", "[", "2", "]", "\n", "\n", "", "return", "color_image", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.tensor2im": [[14, 29], ["isinstance", "image_tensor.cpu().float().numpy", "numpy.clip", "np.clip.astype", "range", "len", "np.clip.append", "image_tensor.cpu().float", "numpy.transpose", "utils.tensor2im", "image_tensor.cpu", "numpy.transpose"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.tensor2im"], ["def", "tensor2im", "(", "image_tensor", ",", "imtype", "=", "np", ".", "uint8", ",", "normalize", "=", "True", ")", ":", "\n", "    ", "if", "isinstance", "(", "image_tensor", ",", "list", ")", ":", "\n", "        ", "image_numpy", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "image_tensor", ")", ")", ":", "\n", "            ", "image_numpy", ".", "append", "(", "tensor2im", "(", "image_tensor", "[", "i", "]", ",", "imtype", ",", "normalize", ")", ")", "\n", "", "return", "image_numpy", "\n", "", "image_numpy", "=", "image_tensor", ".", "cpu", "(", ")", ".", "float", "(", ")", ".", "numpy", "(", ")", "\n", "if", "normalize", ":", "\n", "        ", "image_numpy", "=", "(", "np", ".", "transpose", "(", "image_numpy", ",", "(", "1", ",", "2", ",", "0", ")", ")", "+", "1", ")", "/", "2.0", "*", "255.0", "\n", "", "else", ":", "\n", "        ", "image_numpy", "=", "np", ".", "transpose", "(", "image_numpy", ",", "(", "1", ",", "2", ",", "0", ")", ")", "*", "255.0", "\n", "", "image_numpy", "=", "np", ".", "clip", "(", "image_numpy", ",", "0", ",", "255", ")", "\n", "if", "image_numpy", ".", "shape", "[", "2", "]", "==", "1", "or", "image_numpy", ".", "shape", "[", "2", "]", ">", "3", ":", "\n", "        ", "image_numpy", "=", "image_numpy", "[", ":", ",", ":", ",", "0", "]", "\n", "", "return", "image_numpy", ".", "astype", "(", "imtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.tensor2label": [[31, 40], ["label_tensor.cpu().float.cpu().float", "numpy.transpose", "np.transpose.astype", "utils.tensor2im", "utils.Colorize", "label_tensor.cpu().float.numpy", "label_tensor.cpu().float.cpu", "label_tensor.cpu().float.size", "label_tensor.cpu().float.max"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.tensor2im"], ["", "def", "tensor2label", "(", "label_tensor", ",", "n_label", ",", "imtype", "=", "np", ".", "uint8", ")", ":", "\n", "    ", "if", "n_label", "==", "0", ":", "\n", "        ", "return", "tensor2im", "(", "label_tensor", ",", "imtype", ")", "\n", "", "label_tensor", "=", "label_tensor", ".", "cpu", "(", ")", ".", "float", "(", ")", "\n", "if", "label_tensor", ".", "size", "(", ")", "[", "0", "]", ">", "1", ":", "\n", "        ", "label_tensor", "=", "label_tensor", ".", "max", "(", "0", ",", "keepdim", "=", "True", ")", "[", "1", "]", "\n", "", "label_tensor", "=", "Colorize", "(", "n_label", ")", "(", "label_tensor", ")", "\n", "label_numpy", "=", "np", ".", "transpose", "(", "label_tensor", ".", "numpy", "(", ")", ",", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "return", "label_numpy", ".", "astype", "(", "imtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.save_image": [[41, 44], ["PIL.Image.fromarray", "Image.fromarray.save"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.save"], ["", "def", "save_image", "(", "image_numpy", ",", "image_path", ")", ":", "\n", "    ", "image_pil", "=", "Image", ".", "fromarray", "(", "image_numpy", ")", "\n", "image_pil", ".", "save", "(", "image_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.mkdirs": [[45, 51], ["isinstance", "utils.mkdir", "isinstance", "utils.mkdir"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.mkdir", "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.mkdir"], ["", "def", "mkdirs", "(", "paths", ")", ":", "\n", "    ", "if", "isinstance", "(", "paths", ",", "list", ")", "and", "not", "isinstance", "(", "paths", ",", "str", ")", ":", "\n", "        ", "for", "path", "in", "paths", ":", "\n", "            ", "mkdir", "(", "path", ")", "\n", "", "", "else", ":", "\n", "        ", "mkdir", "(", "paths", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.mkdir": [[52, 55], ["os.path.exists", "os.makedirs"], "function", ["None"], ["", "", "def", "mkdir", "(", "path", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.uint82bin": [[61, 64], ["str", "range"], "function", ["None"], ["", "", "def", "uint82bin", "(", "n", ",", "count", "=", "8", ")", ":", "\n", "    ", "\"\"\"returns the binary of integer n, count refers to amount of bits\"\"\"", "\n", "return", "''", ".", "join", "(", "[", "str", "(", "(", "n", ">>", "y", ")", "&", "1", ")", "for", "y", "in", "range", "(", "count", "-", "1", ",", "-", "1", ",", "-", "1", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.labelcolormap": [[65, 88], ["numpy.array", "numpy.zeros", "range", "range", "utils.uint82bin", "numpy.uint8", "numpy.uint8", "numpy.uint8"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.uint82bin"], ["", "def", "labelcolormap", "(", "N", ")", ":", "\n", "    ", "if", "N", "==", "35", ":", "# cityscape", "\n", "        ", "cmap", "=", "np", ".", "array", "(", "[", "(", "0", ",", "0", ",", "0", ")", ",", "(", "0", ",", "0", ",", "0", ")", ",", "(", "0", ",", "0", ",", "0", ")", ",", "(", "0", ",", "0", ",", "0", ")", ",", "(", "0", ",", "0", ",", "0", ")", ",", "(", "111", ",", "74", ",", "0", ")", ",", "(", "81", ",", "0", ",", "81", ")", ",", "\n", "(", "128", ",", "64", ",", "128", ")", ",", "(", "244", ",", "35", ",", "232", ")", ",", "(", "250", ",", "170", ",", "160", ")", ",", "(", "230", ",", "150", ",", "140", ")", ",", "(", "70", ",", "70", ",", "70", ")", ",", "(", "102", ",", "102", ",", "156", ")", ",", "(", "190", ",", "153", ",", "153", ")", ",", "\n", "(", "180", ",", "165", ",", "180", ")", ",", "(", "150", ",", "100", ",", "100", ")", ",", "(", "150", ",", "120", ",", "90", ")", ",", "(", "153", ",", "153", ",", "153", ")", ",", "(", "153", ",", "153", ",", "153", ")", ",", "(", "250", ",", "170", ",", "30", ")", ",", "(", "220", ",", "220", ",", "0", ")", ",", "\n", "(", "107", ",", "142", ",", "35", ")", ",", "(", "152", ",", "251", ",", "152", ")", ",", "(", "70", ",", "130", ",", "180", ")", ",", "(", "220", ",", "20", ",", "60", ")", ",", "(", "255", ",", "0", ",", "0", ")", ",", "(", "0", ",", "0", ",", "142", ")", ",", "(", "0", ",", "0", ",", "70", ")", ",", "\n", "(", "0", ",", "60", ",", "100", ")", ",", "(", "0", ",", "0", ",", "90", ")", ",", "(", "0", ",", "0", ",", "110", ")", ",", "(", "0", ",", "80", ",", "100", ")", ",", "(", "0", ",", "0", ",", "230", ")", ",", "(", "119", ",", "11", ",", "32", ")", ",", "(", "0", ",", "0", ",", "142", ")", "]", ",", "\n", "dtype", "=", "np", ".", "uint8", ")", "\n", "", "else", ":", "\n", "        ", "cmap", "=", "np", ".", "zeros", "(", "(", "N", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "for", "i", "in", "range", "(", "N", ")", ":", "\n", "            ", "r", ",", "g", ",", "b", "=", "0", ",", "0", ",", "0", "\n", "id", "=", "i", "\n", "for", "j", "in", "range", "(", "7", ")", ":", "\n", "                ", "str_id", "=", "uint82bin", "(", "id", ")", "\n", "r", "=", "r", "^", "(", "np", ".", "uint8", "(", "str_id", "[", "-", "1", "]", ")", "<<", "(", "7", "-", "j", ")", ")", "\n", "g", "=", "g", "^", "(", "np", ".", "uint8", "(", "str_id", "[", "-", "2", "]", ")", "<<", "(", "7", "-", "j", ")", ")", "\n", "b", "=", "b", "^", "(", "np", ".", "uint8", "(", "str_id", "[", "-", "3", "]", ")", "<<", "(", "7", "-", "j", ")", ")", "\n", "id", "=", "id", ">>", "3", "\n", "", "cmap", "[", "i", ",", "0", "]", "=", "r", "\n", "cmap", "[", "i", ",", "1", "]", "=", "g", "\n", "cmap", "[", "i", ",", "2", "]", "=", "b", "\n", "", "", "return", "cmap", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.face_align_ffhqandnewarc.estimate_norm": [[55, 79], ["skimage.transform.SimilarityTransform", "numpy.insert", "float", "numpy.arange", "trans.SimilarityTransform.estimate", "numpy.dot", "numpy.sum", "numpy.ones", "numpy.sqrt", "numpy.sum"], "function", ["None"], ["def", "estimate_norm", "(", "lmk", ",", "image_size", "=", "112", ",", "mode", "=", "'ffhq'", ")", ":", "\n", "    ", "assert", "lmk", ".", "shape", "==", "(", "5", ",", "2", ")", "\n", "tform", "=", "trans", ".", "SimilarityTransform", "(", ")", "\n", "lmk_tran", "=", "np", ".", "insert", "(", "lmk", ",", "2", ",", "values", "=", "np", ".", "ones", "(", "5", ")", ",", "axis", "=", "1", ")", "\n", "min_M", "=", "[", "]", "\n", "min_index", "=", "[", "]", "\n", "min_error", "=", "float", "(", "'inf'", ")", "\n", "if", "mode", "==", "'ffhq'", ":", "\n", "# assert image_size == 112", "\n", "        ", "src", "=", "ffhq_src", "*", "image_size", "/", "512", "\n", "", "else", ":", "\n", "        ", "src", "=", "src_map", "*", "image_size", "/", "112", "\n", "", "for", "i", "in", "np", ".", "arange", "(", "src", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "tform", ".", "estimate", "(", "lmk", ",", "src", "[", "i", "]", ")", "\n", "M", "=", "tform", ".", "params", "[", "0", ":", "2", ",", ":", "]", "\n", "results", "=", "np", ".", "dot", "(", "M", ",", "lmk_tran", ".", "T", ")", "\n", "results", "=", "results", ".", "T", "\n", "error", "=", "np", ".", "sum", "(", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "(", "results", "-", "src", "[", "i", "]", ")", "**", "2", ",", "axis", "=", "1", ")", ")", ")", "\n", "#         print(error)", "\n", "if", "error", "<", "min_error", ":", "\n", "            ", "min_error", "=", "error", "\n", "min_M", "=", "M", "\n", "min_index", "=", "i", "\n", "", "", "return", "min_M", ",", "min_index", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.face_align_ffhqandnewarc.norm_crop": [[81, 92], ["face_align_ffhqandnewarc.estimate_norm", "face_align_ffhqandnewarc.estimate_norm", "cv2.warpAffine", "cv2.warpAffine", "face_align_ffhqandnewarc.estimate_norm", "cv2.warpAffine"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.utils.face_align_ffhqandnewarc.estimate_norm", "home.repos.pwc.inspect_result.ailon-island_facke.utils.face_align_ffhqandnewarc.estimate_norm", "home.repos.pwc.inspect_result.ailon-island_facke.utils.face_align_ffhqandnewarc.estimate_norm"], ["", "def", "norm_crop", "(", "img", ",", "landmark", ",", "image_size", "=", "112", ",", "mode", "=", "'ffhq'", ")", ":", "\n", "    ", "if", "mode", "==", "'Both'", ":", "\n", "        ", "M_None", ",", "_", "=", "estimate_norm", "(", "landmark", ",", "image_size", ",", "mode", "=", "'newarc'", ")", "\n", "M_ffhq", ",", "_", "=", "estimate_norm", "(", "landmark", ",", "image_size", ",", "mode", "=", "'ffhq'", ")", "\n", "warped_None", "=", "cv2", ".", "warpAffine", "(", "img", ",", "M_None", ",", "(", "image_size", ",", "image_size", ")", ",", "borderValue", "=", "0.0", ")", "\n", "warped_ffhq", "=", "cv2", ".", "warpAffine", "(", "img", ",", "M_ffhq", ",", "(", "image_size", ",", "image_size", ")", ",", "borderValue", "=", "0.0", ")", "\n", "return", "warped_ffhq", ",", "warped_None", "\n", "", "else", ":", "\n", "        ", "M", ",", "pose_index", "=", "estimate_norm", "(", "landmark", ",", "image_size", ",", "mode", ")", "\n", "warped", "=", "cv2", ".", "warpAffine", "(", "img", ",", "M", ",", "(", "image_size", ",", "image_size", ")", ",", "borderValue", "=", "0.0", ")", "\n", "return", "warped", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.face_align_ffhqandnewarc.square_crop": [[93, 106], ["cv2.resize", "numpy.zeros", "int", "int", "float", "float", "float", "float"], "function", ["None"], ["", "", "def", "square_crop", "(", "im", ",", "S", ")", ":", "\n", "    ", "if", "im", ".", "shape", "[", "0", "]", ">", "im", ".", "shape", "[", "1", "]", ":", "\n", "        ", "height", "=", "S", "\n", "width", "=", "int", "(", "float", "(", "im", ".", "shape", "[", "1", "]", ")", "/", "im", ".", "shape", "[", "0", "]", "*", "S", ")", "\n", "scale", "=", "float", "(", "S", ")", "/", "im", ".", "shape", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "width", "=", "S", "\n", "height", "=", "int", "(", "float", "(", "im", ".", "shape", "[", "0", "]", ")", "/", "im", ".", "shape", "[", "1", "]", "*", "S", ")", "\n", "scale", "=", "float", "(", "S", ")", "/", "im", ".", "shape", "[", "1", "]", "\n", "", "resized_im", "=", "cv2", ".", "resize", "(", "im", ",", "(", "width", ",", "height", ")", ")", "\n", "det_im", "=", "np", ".", "zeros", "(", "(", "S", ",", "S", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "det_im", "[", ":", "resized_im", ".", "shape", "[", "0", "]", ",", ":", "resized_im", ".", "shape", "[", "1", "]", ",", ":", "]", "=", "resized_im", "\n", "return", "det_im", ",", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.face_align_ffhqandnewarc.transform": [[108, 125], ["skimage.transform.SimilarityTransform", "skimage.transform.SimilarityTransform", "skimage.transform.SimilarityTransform", "skimage.transform.SimilarityTransform", "cv2.warpAffine", "float"], "function", ["None"], ["", "def", "transform", "(", "data", ",", "center", ",", "output_size", ",", "scale", ",", "rotation", ")", ":", "\n", "    ", "scale_ratio", "=", "scale", "\n", "rot", "=", "float", "(", "rotation", ")", "*", "np", ".", "pi", "/", "180.0", "\n", "#translation = (output_size/2-center[0]*scale_ratio, output_size/2-center[1]*scale_ratio)", "\n", "t1", "=", "trans", ".", "SimilarityTransform", "(", "scale", "=", "scale_ratio", ")", "\n", "cx", "=", "center", "[", "0", "]", "*", "scale_ratio", "\n", "cy", "=", "center", "[", "1", "]", "*", "scale_ratio", "\n", "t2", "=", "trans", ".", "SimilarityTransform", "(", "translation", "=", "(", "-", "1", "*", "cx", ",", "-", "1", "*", "cy", ")", ")", "\n", "t3", "=", "trans", ".", "SimilarityTransform", "(", "rotation", "=", "rot", ")", "\n", "t4", "=", "trans", ".", "SimilarityTransform", "(", "translation", "=", "(", "output_size", "/", "2", ",", "\n", "output_size", "/", "2", ")", ")", "\n", "t", "=", "t1", "+", "t2", "+", "t3", "+", "t4", "\n", "M", "=", "t", ".", "params", "[", "0", ":", "2", "]", "\n", "cropped", "=", "cv2", ".", "warpAffine", "(", "data", ",", "\n", "M", ",", "(", "output_size", ",", "output_size", ")", ",", "\n", "borderValue", "=", "0.0", ")", "\n", "return", "cropped", ",", "M", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.face_align_ffhqandnewarc.trans_points2d": [[127, 137], ["numpy.zeros", "range", "numpy.array", "numpy.dot"], "function", ["None"], ["", "def", "trans_points2d", "(", "pts", ",", "M", ")", ":", "\n", "    ", "new_pts", "=", "np", ".", "zeros", "(", "shape", "=", "pts", ".", "shape", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "i", "in", "range", "(", "pts", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "pt", "=", "pts", "[", "i", "]", "\n", "new_pt", "=", "np", ".", "array", "(", "[", "pt", "[", "0", "]", ",", "pt", "[", "1", "]", ",", "1.", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "new_pt", "=", "np", ".", "dot", "(", "M", ",", "new_pt", ")", "\n", "#print('new_pt', new_pt.shape, new_pt)", "\n", "new_pts", "[", "i", "]", "=", "new_pt", "[", "0", ":", "2", "]", "\n", "\n", "", "return", "new_pts", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.face_align_ffhqandnewarc.trans_points3d": [[139, 152], ["numpy.sqrt", "numpy.zeros", "range", "numpy.array", "numpy.dot"], "function", ["None"], ["", "def", "trans_points3d", "(", "pts", ",", "M", ")", ":", "\n", "    ", "scale", "=", "np", ".", "sqrt", "(", "M", "[", "0", "]", "[", "0", "]", "*", "M", "[", "0", "]", "[", "0", "]", "+", "M", "[", "0", "]", "[", "1", "]", "*", "M", "[", "0", "]", "[", "1", "]", ")", "\n", "#print(scale)", "\n", "new_pts", "=", "np", ".", "zeros", "(", "shape", "=", "pts", ".", "shape", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "i", "in", "range", "(", "pts", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "pt", "=", "pts", "[", "i", "]", "\n", "new_pt", "=", "np", ".", "array", "(", "[", "pt", "[", "0", "]", ",", "pt", "[", "1", "]", ",", "1.", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "new_pt", "=", "np", ".", "dot", "(", "M", ",", "new_pt", ")", "\n", "#print('new_pt', new_pt.shape, new_pt)", "\n", "new_pts", "[", "i", "]", "[", "0", ":", "2", "]", "=", "new_pt", "[", "0", ":", "2", "]", "\n", "new_pts", "[", "i", "]", "[", "2", "]", "=", "pts", "[", "i", "]", "[", "2", "]", "*", "scale", "\n", "\n", "", "return", "new_pts", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.utils.face_align_ffhqandnewarc.trans_points": [[154, 159], ["face_align_ffhqandnewarc.trans_points2d", "face_align_ffhqandnewarc.trans_points3d"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.utils.face_align_ffhqandnewarc.trans_points2d", "home.repos.pwc.inspect_result.ailon-island_facke.utils.face_align_ffhqandnewarc.trans_points3d"], ["", "def", "trans_points", "(", "pts", ",", "M", ")", ":", "\n", "    ", "if", "pts", ".", "shape", "[", "1", "]", "==", "2", ":", "\n", "        ", "return", "trans_points2d", "(", "pts", ",", "M", ")", "\n", "", "else", ":", "\n", "        ", "return", "trans_points3d", "(", "pts", ",", "M", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.LossType.is_vb": [[97, 99], ["None"], "methods", ["None"], ["def", "is_vb", "(", "self", ")", ":", "\n", "        ", "return", "self", "==", "LossType", ".", "KL", "or", "self", "==", "LossType", ".", "RESCALED_KL", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.__init__": [[118, 169], ["numpy.array", "int", "numpy.cumprod", "numpy.append", "numpy.append", "numpy.sqrt", "numpy.sqrt", "numpy.log", "numpy.sqrt", "numpy.sqrt", "numpy.log", "len", "numpy.append", "numpy.sqrt", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log"], ["def", "__init__", "(", "\n", "self", ",", "\n", "*", ",", "\n", "betas", ",", "\n", "model_mean_type", ",", "\n", "model_var_type", ",", "\n", "loss_type", ",", "\n", "rescale_timesteps", "=", "False", ",", "\n", ")", ":", "\n", "        ", "self", ".", "model_mean_type", "=", "model_mean_type", "\n", "self", ".", "model_var_type", "=", "model_var_type", "\n", "self", ".", "loss_type", "=", "loss_type", "\n", "self", ".", "rescale_timesteps", "=", "rescale_timesteps", "\n", "\n", "# Use float64 for accuracy.", "\n", "betas", "=", "np", ".", "array", "(", "betas", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "self", ".", "betas", "=", "betas", "\n", "assert", "len", "(", "betas", ".", "shape", ")", "==", "1", ",", "\"betas must be 1-D\"", "\n", "assert", "(", "betas", ">", "0", ")", ".", "all", "(", ")", "and", "(", "betas", "<=", "1", ")", ".", "all", "(", ")", "\n", "\n", "self", ".", "num_timesteps", "=", "int", "(", "betas", ".", "shape", "[", "0", "]", ")", "\n", "\n", "alphas", "=", "1.0", "-", "betas", "\n", "self", ".", "alphas_cumprod", "=", "np", ".", "cumprod", "(", "alphas", ",", "axis", "=", "0", ")", "\n", "self", ".", "alphas_cumprod_prev", "=", "np", ".", "append", "(", "1.0", ",", "self", ".", "alphas_cumprod", "[", ":", "-", "1", "]", ")", "\n", "self", ".", "alphas_cumprod_next", "=", "np", ".", "append", "(", "self", ".", "alphas_cumprod", "[", "1", ":", "]", ",", "0.0", ")", "\n", "assert", "self", ".", "alphas_cumprod_prev", ".", "shape", "==", "(", "self", ".", "num_timesteps", ",", ")", "\n", "\n", "# calculations for diffusion q(x_t | x_{t-1}) and others", "\n", "self", ".", "sqrt_alphas_cumprod", "=", "np", ".", "sqrt", "(", "self", ".", "alphas_cumprod", ")", "\n", "self", ".", "sqrt_one_minus_alphas_cumprod", "=", "np", ".", "sqrt", "(", "1.0", "-", "self", ".", "alphas_cumprod", ")", "\n", "self", ".", "log_one_minus_alphas_cumprod", "=", "np", ".", "log", "(", "1.0", "-", "self", ".", "alphas_cumprod", ")", "\n", "self", ".", "sqrt_recip_alphas_cumprod", "=", "np", ".", "sqrt", "(", "1.0", "/", "self", ".", "alphas_cumprod", ")", "\n", "self", ".", "sqrt_recipm1_alphas_cumprod", "=", "np", ".", "sqrt", "(", "1.0", "/", "self", ".", "alphas_cumprod", "-", "1", ")", "\n", "\n", "# calculations for posterior q(x_{t-1} | x_t, x_0)", "\n", "self", ".", "posterior_variance", "=", "(", "\n", "betas", "*", "(", "1.0", "-", "self", ".", "alphas_cumprod_prev", ")", "/", "(", "1.0", "-", "self", ".", "alphas_cumprod", ")", "\n", ")", "\n", "# log calculation clipped because the posterior variance is 0 at the", "\n", "# beginning of the diffusion chain.", "\n", "self", ".", "posterior_log_variance_clipped", "=", "np", ".", "log", "(", "\n", "np", ".", "append", "(", "self", ".", "posterior_variance", "[", "1", "]", ",", "self", ".", "posterior_variance", "[", "1", ":", "]", ")", "\n", ")", "\n", "self", ".", "posterior_mean_coef1", "=", "(", "\n", "betas", "*", "np", ".", "sqrt", "(", "self", ".", "alphas_cumprod_prev", ")", "/", "(", "1.0", "-", "self", ".", "alphas_cumprod", ")", "\n", ")", "\n", "self", ".", "posterior_mean_coef2", "=", "(", "\n", "(", "1.0", "-", "self", ".", "alphas_cumprod_prev", ")", "\n", "*", "np", ".", "sqrt", "(", "alphas", ")", "\n", "/", "(", "1.0", "-", "self", ".", "alphas_cumprod", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.q_mean_variance": [[171, 187], ["gaussian_diffusion._extract_into_tensor", "gaussian_diffusion._extract_into_tensor", "gaussian_diffusion._extract_into_tensor"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor"], ["", "def", "q_mean_variance", "(", "self", ",", "x_start", ",", "t", ")", ":", "\n", "        ", "\"\"\"\n        Get the distribution q(x_t | x_0).\n\n        :param x_start: the [N x C x ...] tensor of noiseless inputs.\n        :param t: the number of diffusion steps (minus 1). Here, 0 means one step.\n        :return: A tuple (mean, variance, log_variance), all of x_start's shape.\n        \"\"\"", "\n", "mean", "=", "(", "\n", "_extract_into_tensor", "(", "self", ".", "sqrt_alphas_cumprod", ",", "t", ",", "x_start", ".", "shape", ")", "*", "x_start", "\n", ")", "\n", "variance", "=", "_extract_into_tensor", "(", "1.0", "-", "self", ".", "alphas_cumprod", ",", "t", ",", "x_start", ".", "shape", ")", "\n", "log_variance", "=", "_extract_into_tensor", "(", "\n", "self", ".", "log_one_minus_alphas_cumprod", ",", "t", ",", "x_start", ".", "shape", "\n", ")", "\n", "return", "mean", ",", "variance", ",", "log_variance", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.q_sample": [[188, 206], ["torch.randn_like", "gaussian_diffusion._extract_into_tensor", "gaussian_diffusion._extract_into_tensor"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor"], ["", "def", "q_sample", "(", "self", ",", "x_start", ",", "t", ",", "noise", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Diffuse the data for a given number of diffusion steps.\n\n        In other words, sample from q(x_t | x_0).\n\n        :param x_start: the initial data batch.\n        :param t: the number of diffusion steps (minus 1). Here, 0 means one step.\n        :param noise: if specified, the split-out normal noise.\n        :return: A noisy version of x_start.\n        \"\"\"", "\n", "if", "noise", "is", "None", ":", "\n", "            ", "noise", "=", "th", ".", "randn_like", "(", "x_start", ")", "\n", "", "assert", "noise", ".", "shape", "==", "x_start", ".", "shape", "\n", "return", "(", "\n", "_extract_into_tensor", "(", "self", ".", "sqrt_alphas_cumprod", ",", "t", ",", "x_start", ".", "shape", ")", "*", "x_start", "\n", "+", "_extract_into_tensor", "(", "self", ".", "sqrt_one_minus_alphas_cumprod", ",", "t", ",", "x_start", ".", "shape", ")", "\n", "*", "noise", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.q_posterior_mean_variance": [[208, 231], ["gaussian_diffusion._extract_into_tensor", "gaussian_diffusion._extract_into_tensor", "gaussian_diffusion._extract_into_tensor", "gaussian_diffusion._extract_into_tensor"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor"], ["", "def", "q_posterior_mean_variance", "(", "self", ",", "x_start", ",", "x_t", ",", "t", ")", ":", "\n", "        ", "\"\"\"\n        Compute the mean and variance of the diffusion posterior:\n\n            q(x_{t-1} | x_t, x_0)\n\n        \"\"\"", "\n", "assert", "x_start", ".", "shape", "==", "x_t", ".", "shape", "\n", "posterior_mean", "=", "(", "\n", "_extract_into_tensor", "(", "self", ".", "posterior_mean_coef1", ",", "t", ",", "x_t", ".", "shape", ")", "*", "x_start", "\n", "+", "_extract_into_tensor", "(", "self", ".", "posterior_mean_coef2", ",", "t", ",", "x_t", ".", "shape", ")", "*", "x_t", "\n", ")", "\n", "posterior_variance", "=", "_extract_into_tensor", "(", "self", ".", "posterior_variance", ",", "t", ",", "x_t", ".", "shape", ")", "\n", "posterior_log_variance_clipped", "=", "_extract_into_tensor", "(", "\n", "self", ".", "posterior_log_variance_clipped", ",", "t", ",", "x_t", ".", "shape", "\n", ")", "\n", "assert", "(", "\n", "posterior_mean", ".", "shape", "[", "0", "]", "\n", "==", "posterior_variance", ".", "shape", "[", "0", "]", "\n", "==", "posterior_log_variance_clipped", ".", "shape", "[", "0", "]", "\n", "==", "x_start", ".", "shape", "[", "0", "]", "\n", ")", "\n", "return", "posterior_mean", ",", "posterior_variance", ",", "posterior_log_variance_clipped", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.p_mean_variance": [[232, 326], ["model", "gaussian_diffusion.GaussianDiffusion._scale_timesteps", "torch.split", "gaussian_diffusion._extract_into_tensor", "gaussian_diffusion._extract_into_tensor", "gaussian_diffusion.GaussianDiffusion.p_mean_variance.process_xstart"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion._scale_timesteps", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor"], ["", "def", "p_mean_variance", "(", "\n", "self", ",", "model", ",", "x", ",", "t", ",", "clip_denoised", "=", "True", ",", "denoised_fn", "=", "None", ",", "model_kwargs", "=", "None", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Apply the model to get p(x_{t-1} | x_t), as well as a prediction of\n        the initial x, x_0.\n\n        :param model: the model, which takes a signal and a batch of timesteps\n                      as input.\n        :param x: the [N x C x ...] tensor at time t.\n        :param t: a 1-D Tensor of timesteps.\n        :param clip_denoised: if True, clip the denoised signal into [-1, 1].\n        :param denoised_fn: if not None, a function which applies to the\n            x_start prediction before it is used to sample. Applies before\n            clip_denoised.\n        :param model_kwargs: if not None, a dict of extra keyword arguments to\n            pass to the model. This can be used for conditioning.\n        :return: a dict with the following keys:\n                 - 'mean': the model mean output.\n                 - 'variance': the model variance output.\n                 - 'log_variance': the log of 'variance'.\n                 - 'pred_xstart': the prediction for x_0.\n        \"\"\"", "\n", "if", "model_kwargs", "is", "None", ":", "\n", "            ", "model_kwargs", "=", "{", "}", "\n", "\n", "", "B", ",", "C", "=", "x", ".", "shape", "[", ":", "2", "]", "\n", "assert", "t", ".", "shape", "==", "(", "B", ",", ")", "\n", "model_output", "=", "model", "(", "x", ",", "self", ".", "_scale_timesteps", "(", "t", ")", ",", "**", "model_kwargs", ")", "\n", "\n", "if", "self", ".", "model_var_type", "in", "[", "ModelVarType", ".", "LEARNED", ",", "ModelVarType", ".", "LEARNED_RANGE", "]", ":", "\n", "            ", "assert", "model_output", ".", "shape", "==", "(", "B", ",", "C", "*", "2", ",", "*", "x", ".", "shape", "[", "2", ":", "]", ")", "\n", "model_output", ",", "model_var_values", "=", "th", ".", "split", "(", "model_output", ",", "C", ",", "dim", "=", "1", ")", "\n", "if", "self", ".", "model_var_type", "==", "ModelVarType", ".", "LEARNED", ":", "\n", "                ", "model_log_variance", "=", "model_var_values", "\n", "model_variance", "=", "th", ".", "exp", "(", "model_log_variance", ")", "\n", "", "else", ":", "\n", "                ", "min_log", "=", "_extract_into_tensor", "(", "\n", "self", ".", "posterior_log_variance_clipped", ",", "t", ",", "x", ".", "shape", "\n", ")", "\n", "max_log", "=", "_extract_into_tensor", "(", "np", ".", "log", "(", "self", ".", "betas", ")", ",", "t", ",", "x", ".", "shape", ")", "\n", "# The model_var_values is [-1, 1] for [min_var, max_var].", "\n", "frac", "=", "(", "model_var_values", "+", "1", ")", "/", "2", "\n", "model_log_variance", "=", "frac", "*", "max_log", "+", "(", "1", "-", "frac", ")", "*", "min_log", "\n", "model_variance", "=", "th", ".", "exp", "(", "model_log_variance", ")", "\n", "", "", "else", ":", "\n", "            ", "model_variance", ",", "model_log_variance", "=", "{", "\n", "# for fixedlarge, we set the initial (log-)variance like so", "\n", "# to get a better decoder log likelihood.", "\n", "ModelVarType", ".", "FIXED_LARGE", ":", "(", "\n", "np", ".", "append", "(", "self", ".", "posterior_variance", "[", "1", "]", ",", "self", ".", "betas", "[", "1", ":", "]", ")", ",", "\n", "np", ".", "log", "(", "np", ".", "append", "(", "self", ".", "posterior_variance", "[", "1", "]", ",", "self", ".", "betas", "[", "1", ":", "]", ")", ")", ",", "\n", ")", ",", "\n", "ModelVarType", ".", "FIXED_SMALL", ":", "(", "\n", "self", ".", "posterior_variance", ",", "\n", "self", ".", "posterior_log_variance_clipped", ",", "\n", ")", ",", "\n", "}", "[", "self", ".", "model_var_type", "]", "\n", "model_variance", "=", "_extract_into_tensor", "(", "model_variance", ",", "t", ",", "x", ".", "shape", ")", "\n", "model_log_variance", "=", "_extract_into_tensor", "(", "model_log_variance", ",", "t", ",", "x", ".", "shape", ")", "\n", "\n", "", "def", "process_xstart", "(", "x", ")", ":", "\n", "            ", "if", "denoised_fn", "is", "not", "None", ":", "\n", "                ", "x", "=", "denoised_fn", "(", "x", ")", "\n", "", "if", "clip_denoised", ":", "\n", "                ", "return", "x", ".", "clamp", "(", "-", "1", ",", "1", ")", "\n", "", "return", "x", "\n", "\n", "", "if", "self", ".", "model_mean_type", "==", "ModelMeanType", ".", "PREVIOUS_X", ":", "\n", "            ", "pred_xstart", "=", "process_xstart", "(", "\n", "self", ".", "_predict_xstart_from_xprev", "(", "x_t", "=", "x", ",", "t", "=", "t", ",", "xprev", "=", "model_output", ")", "\n", ")", "\n", "model_mean", "=", "model_output", "\n", "", "elif", "self", ".", "model_mean_type", "in", "[", "ModelMeanType", ".", "START_X", ",", "ModelMeanType", ".", "EPSILON", "]", ":", "\n", "            ", "if", "self", ".", "model_mean_type", "==", "ModelMeanType", ".", "START_X", ":", "\n", "                ", "pred_xstart", "=", "process_xstart", "(", "model_output", ")", "\n", "", "else", ":", "\n", "                ", "pred_xstart", "=", "process_xstart", "(", "\n", "self", ".", "_predict_xstart_from_eps", "(", "x_t", "=", "x", ",", "t", "=", "t", ",", "eps", "=", "model_output", ")", "\n", ")", "\n", "", "model_mean", ",", "_", ",", "_", "=", "self", ".", "q_posterior_mean_variance", "(", "\n", "x_start", "=", "pred_xstart", ",", "x_t", "=", "x", ",", "t", "=", "t", "\n", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "self", ".", "model_mean_type", ")", "\n", "\n", "", "assert", "(", "\n", "model_mean", ".", "shape", "==", "model_log_variance", ".", "shape", "==", "pred_xstart", ".", "shape", "==", "x", ".", "shape", "\n", ")", "\n", "return", "{", "\n", "\"mean\"", ":", "model_mean", ",", "\n", "\"variance\"", ":", "model_variance", ",", "\n", "\"log_variance\"", ":", "model_log_variance", ",", "\n", "\"pred_xstart\"", ":", "pred_xstart", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion._predict_xstart_from_eps": [[328, 333], ["gaussian_diffusion._extract_into_tensor", "gaussian_diffusion._extract_into_tensor"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor"], ["", "def", "_predict_xstart_from_eps", "(", "self", ",", "x_t", ",", "t", ",", "eps", ")", ":", "\n", "        ", "assert", "x_t", ".", "shape", "==", "eps", ".", "shape", "\n", "return", "(", "\n", "_extract_into_tensor", "(", "self", ".", "sqrt_recip_alphas_cumprod", ",", "t", ",", "x_t", ".", "shape", ")", "*", "x_t", "\n", "-", "_extract_into_tensor", "(", "self", ".", "sqrt_recipm1_alphas_cumprod", ",", "t", ",", "x_t", ".", "shape", ")", "*", "eps", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion._predict_xstart_from_xprev": [[335, 343], ["gaussian_diffusion._extract_into_tensor", "gaussian_diffusion._extract_into_tensor"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor"], ["", "def", "_predict_xstart_from_xprev", "(", "self", ",", "x_t", ",", "t", ",", "xprev", ")", ":", "\n", "        ", "assert", "x_t", ".", "shape", "==", "xprev", ".", "shape", "\n", "return", "(", "# (xprev - coef2*x_t) / coef1", "\n", "_extract_into_tensor", "(", "1.0", "/", "self", ".", "posterior_mean_coef1", ",", "t", ",", "x_t", ".", "shape", ")", "*", "xprev", "\n", "-", "_extract_into_tensor", "(", "\n", "self", ".", "posterior_mean_coef2", "/", "self", ".", "posterior_mean_coef1", ",", "t", ",", "x_t", ".", "shape", "\n", ")", "\n", "*", "x_t", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion._predict_eps_from_xstart": [[345, 350], ["gaussian_diffusion._extract_into_tensor", "gaussian_diffusion._extract_into_tensor"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor"], ["", "def", "_predict_eps_from_xstart", "(", "self", ",", "x_t", ",", "t", ",", "pred_xstart", ")", ":", "\n", "        ", "return", "(", "\n", "_extract_into_tensor", "(", "self", ".", "sqrt_recip_alphas_cumprod", ",", "t", ",", "x_t", ".", "shape", ")", "*", "x_t", "\n", "-", "pred_xstart", "\n", ")", "/", "_extract_into_tensor", "(", "self", ".", "sqrt_recipm1_alphas_cumprod", ",", "t", ",", "x_t", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion._scale_timesteps": [[351, 355], ["t.float"], "methods", ["None"], ["", "def", "_scale_timesteps", "(", "self", ",", "t", ")", ":", "\n", "        ", "if", "self", ".", "rescale_timesteps", ":", "\n", "            ", "return", "t", ".", "float", "(", ")", "*", "(", "1000.0", "/", "self", ".", "num_timesteps", ")", "\n", "", "return", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.condition_mean": [[356, 370], ["cond_fn", "gaussian_diffusion.GaussianDiffusion._scale_timesteps", "p_mean_var[].float", "cond_fn.float"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion._scale_timesteps"], ["", "def", "condition_mean", "(", "self", ",", "cond_fn", ",", "p_mean_var", ",", "x", ",", "t", ",", "model_kwargs", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Compute the mean for the previous step, given a function cond_fn that\n        computes the gradient of a conditional log probability with respect to\n        x. In particular, cond_fn computes grad(log(p(y|x))), and we want to\n        condition on y.\n\n        This uses the conditioning strategy from Sohl-Dickstein et al. (2015).\n        \"\"\"", "\n", "gradient", "=", "cond_fn", "(", "x", ",", "self", ".", "_scale_timesteps", "(", "t", ")", ",", "**", "model_kwargs", ")", "\n", "new_mean", "=", "(", "\n", "p_mean_var", "[", "\"mean\"", "]", ".", "float", "(", ")", "+", "p_mean_var", "[", "\"variance\"", "]", "*", "gradient", ".", "float", "(", ")", "\n", ")", "\n", "return", "new_mean", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.condition_score": [[371, 394], ["gaussian_diffusion._extract_into_tensor", "gaussian_diffusion.GaussianDiffusion._predict_eps_from_xstart", "p_mean_var.copy", "gaussian_diffusion.GaussianDiffusion._predict_xstart_from_eps", "gaussian_diffusion.GaussianDiffusion.q_posterior_mean_variance", "cond_fn", "gaussian_diffusion.GaussianDiffusion._scale_timesteps"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion._predict_eps_from_xstart", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion._predict_xstart_from_eps", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.q_posterior_mean_variance", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion._scale_timesteps"], ["", "def", "condition_score", "(", "self", ",", "cond_fn", ",", "p_mean_var", ",", "x", ",", "t", ",", "model_kwargs", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Compute what the p_mean_variance output would have been, should the\n        model's score function be conditioned by cond_fn.\n\n        See condition_mean() for details on cond_fn.\n\n        Unlike condition_mean(), this instead uses the conditioning strategy\n        from Song et al (2020).\n        \"\"\"", "\n", "alpha_bar", "=", "_extract_into_tensor", "(", "self", ".", "alphas_cumprod", ",", "t", ",", "x", ".", "shape", ")", "\n", "\n", "eps", "=", "self", ".", "_predict_eps_from_xstart", "(", "x", ",", "t", ",", "p_mean_var", "[", "\"pred_xstart\"", "]", ")", "\n", "eps", "=", "eps", "-", "(", "1", "-", "alpha_bar", ")", ".", "sqrt", "(", ")", "*", "cond_fn", "(", "\n", "x", ",", "self", ".", "_scale_timesteps", "(", "t", ")", ",", "**", "model_kwargs", "\n", ")", "\n", "\n", "out", "=", "p_mean_var", ".", "copy", "(", ")", "\n", "out", "[", "\"pred_xstart\"", "]", "=", "self", ".", "_predict_xstart_from_eps", "(", "x", ",", "t", ",", "eps", ")", "\n", "out", "[", "\"mean\"", "]", ",", "_", ",", "_", "=", "self", ".", "q_posterior_mean_variance", "(", "\n", "x_start", "=", "out", "[", "\"pred_xstart\"", "]", ",", "x_t", "=", "x", ",", "t", "=", "t", "\n", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.p_sample": [[395, 440], ["gaussian_diffusion.GaussianDiffusion.p_mean_variance", "torch.randn_like", "gaussian_diffusion.GaussianDiffusion.condition_mean", "torch.exp", "len"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion.p_mean_variance", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion.condition_mean"], ["", "def", "p_sample", "(", "\n", "self", ",", "\n", "model", ",", "\n", "x", ",", "\n", "t", ",", "\n", "clip_denoised", "=", "True", ",", "\n", "denoised_fn", "=", "None", ",", "\n", "cond_fn", "=", "None", ",", "\n", "model_kwargs", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Sample x_{t-1} from the model at the given timestep.\n\n        :param model: the model to sample from.\n        :param x: the current tensor at x_{t-1}.\n        :param t: the value of t, starting at 0 for the first diffusion step.\n        :param clip_denoised: if True, clip the x_start prediction to [-1, 1].\n        :param denoised_fn: if not None, a function which applies to the\n            x_start prediction before it is used to sample.\n        :param cond_fn: if not None, this is a gradient function that acts\n                        similarly to the model.\n        :param model_kwargs: if not None, a dict of extra keyword arguments to\n            pass to the model. This can be used for conditioning.\n        :return: a dict containing the following keys:\n                 - 'sample': a random sample from the model.\n                 - 'pred_xstart': a prediction of x_0.\n        \"\"\"", "\n", "out", "=", "self", ".", "p_mean_variance", "(", "\n", "model", ",", "\n", "x", ",", "\n", "t", ",", "\n", "clip_denoised", "=", "clip_denoised", ",", "\n", "denoised_fn", "=", "denoised_fn", ",", "\n", "model_kwargs", "=", "model_kwargs", ",", "\n", ")", "\n", "noise", "=", "th", ".", "randn_like", "(", "x", ")", "\n", "nonzero_mask", "=", "(", "\n", "(", "t", "!=", "0", ")", ".", "float", "(", ")", ".", "view", "(", "-", "1", ",", "*", "(", "[", "1", "]", "*", "(", "len", "(", "x", ".", "shape", ")", "-", "1", ")", ")", ")", "\n", ")", "# no noise when t == 0", "\n", "if", "cond_fn", "is", "not", "None", ":", "\n", "            ", "out", "[", "\"mean\"", "]", "=", "self", ".", "condition_mean", "(", "\n", "cond_fn", ",", "out", ",", "x", ",", "t", ",", "model_kwargs", "=", "model_kwargs", "\n", ")", "\n", "", "sample", "=", "out", "[", "\"mean\"", "]", "+", "nonzero_mask", "*", "th", ".", "exp", "(", "0.5", "*", "out", "[", "\"log_variance\"", "]", ")", "*", "noise", "\n", "return", "{", "\"sample\"", ":", "sample", ",", "\"pred_xstart\"", ":", "out", "[", "\"pred_xstart\"", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.p_sample_loop": [[441, 491], ["gaussian_diffusion.GaussianDiffusion.p_sample_loop_progressive"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.p_sample_loop_progressive"], ["", "def", "p_sample_loop", "(", "\n", "self", ",", "\n", "model", ",", "\n", "shape", ",", "\n", "noise", "=", "None", ",", "\n", "clip_denoised", "=", "True", ",", "\n", "denoised_fn", "=", "None", ",", "\n", "cond_fn", "=", "None", ",", "\n", "model_kwargs", "=", "None", ",", "\n", "device", "=", "None", ",", "\n", "progress", "=", "False", ",", "\n", "resizers", "=", "None", ",", "\n", "range_t", "=", "0", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Generate samples from the model.\n\n        :param model: the model module.\n        :param shape: the shape of the samples, (N, C, H, W).\n        :param noise: if specified, the noise from the encoder to sample.\n                      Should be of the same shape as `shape`.\n        :param clip_denoised: if True, clip x_start predictions to [-1, 1].\n        :param denoised_fn: if not None, a function which applies to the\n            x_start prediction before it is used to sample.\n        :param cond_fn: if not None, this is a gradient function that acts\n                        similarly to the model.\n        :param model_kwargs: if not None, a dict of extra keyword arguments to\n            pass to the model. This can be used for conditioning.\n        :param device: if specified, the device to create the samples on.\n                       If not specified, use a model parameter's device.\n        :param progress: if True, show a tqdm progress bar.\n        :return: a non-differentiable batch of samples.\n        \"\"\"", "\n", "final", "=", "None", "\n", "for", "sample", "in", "self", ".", "p_sample_loop_progressive", "(", "\n", "model", ",", "\n", "shape", ",", "\n", "noise", "=", "noise", ",", "\n", "clip_denoised", "=", "clip_denoised", ",", "\n", "denoised_fn", "=", "denoised_fn", ",", "\n", "cond_fn", "=", "cond_fn", ",", "\n", "model_kwargs", "=", "model_kwargs", ",", "\n", "device", "=", "device", ",", "\n", "progress", "=", "progress", ",", "\n", "resizers", "=", "resizers", ",", "\n", "range_t", "=", "range_t", ",", "\n", ")", ":", "\n", "            ", "final", "=", "sample", "\n", "\n", "", "return", "final", "[", "\"sample\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.p_sample_loop_progressive": [[494, 558], ["isinstance", "torch.randn", "list", "tqdm", "torch.tensor", "model_kwargs.pop", "next", "range", "torch.no_grad", "gaussian_diffusion.GaussianDiffusion.p_sample", "model.parameters", "up", "up", "down", "down", "gaussian_diffusion.GaussianDiffusion.q_sample"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.p_sample", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.q_sample"], ["", "def", "p_sample_loop_progressive", "(", "\n", "self", ",", "\n", "model", ",", "\n", "shape", ",", "\n", "noise", "=", "None", ",", "\n", "clip_denoised", "=", "True", ",", "\n", "denoised_fn", "=", "None", ",", "\n", "cond_fn", "=", "None", ",", "\n", "model_kwargs", "=", "None", ",", "\n", "device", "=", "None", ",", "\n", "progress", "=", "False", ",", "\n", "resizers", "=", "None", ",", "\n", "range_t", "=", "0", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Generate samples from the model and yield intermediate samples from\n        each timestep of diffusion.\n\n        Arguments are the same as p_sample_loop().\n        Returns a generator over dicts, where each dict is the return value of\n        p_sample().\n        \"\"\"", "\n", "if", "device", "is", "None", ":", "\n", "            ", "device", "=", "next", "(", "model", ".", "parameters", "(", ")", ")", ".", "device", "\n", "", "assert", "isinstance", "(", "shape", ",", "(", "tuple", ",", "list", ")", ")", "\n", "if", "noise", "is", "not", "None", ":", "\n", "            ", "img", "=", "noise", "\n", "", "else", ":", "\n", "            ", "img", "=", "th", ".", "randn", "(", "*", "shape", ",", "device", "=", "device", ")", "\n", "", "indices", "=", "list", "(", "range", "(", "self", ".", "num_timesteps", ")", ")", "[", ":", ":", "-", "1", "]", "\n", "\n", "if", "progress", ":", "\n", "# Lazy import so that we don't depend on tqdm.", "\n", "            ", "from", "tqdm", ".", "auto", "import", "tqdm", "\n", "\n", "indices", "=", "tqdm", "(", "indices", ")", "\n", "\n", "", "if", "resizers", "is", "not", "None", ":", "\n", "            ", "down", ",", "up", "=", "resizers", "\n", "\n", "", "for", "i", "in", "indices", ":", "\n", "            ", "t", "=", "th", ".", "tensor", "(", "[", "i", "]", "*", "shape", "[", "0", "]", ",", "device", "=", "device", ")", "\n", "q_noise", "=", "model_kwargs", ".", "pop", "(", "'q_noise'", ",", "None", ")", "\n", "with", "th", ".", "no_grad", "(", ")", ":", "\n", "                ", "out", "=", "self", ".", "p_sample", "(", "\n", "model", ",", "\n", "img", ",", "\n", "t", ",", "\n", "clip_denoised", "=", "clip_denoised", ",", "\n", "denoised_fn", "=", "denoised_fn", ",", "\n", "cond_fn", "=", "cond_fn", ",", "\n", "model_kwargs", "=", "model_kwargs", ",", "\n", ")", "\n", "\n", "#### ILVR ####", "\n", "if", "resizers", "is", "not", "None", ":", "\n", "                    ", "if", "i", ">", "range_t", ":", "\n", "# out[\"sample\"] = out[\"sample\"] - up(down(out[\"sample\"])) + up(", "\n", "#     down(self.q_sample(model_kwargs[\"ref_img\"], t, th.randn(*shape, device=device))))", "\n", "                        ", "out", "[", "\"sample\"", "]", "=", "out", "[", "\"sample\"", "]", "-", "up", "(", "down", "(", "out", "[", "\"sample\"", "]", ")", ")", "+", "up", "(", "\n", "down", "(", "self", ".", "q_sample", "(", "model_kwargs", "[", "\"ref_img\"", "]", ",", "t", ",", "q_noise", ")", ")", ")", "\n", "\n", "", "", "yield", "out", "\n", "img", "=", "out", "[", "\"sample\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.ddim_sample": [[559, 608], ["gaussian_diffusion.GaussianDiffusion.p_mean_variance", "gaussian_diffusion.GaussianDiffusion._predict_eps_from_xstart", "gaussian_diffusion._extract_into_tensor", "gaussian_diffusion._extract_into_tensor", "torch.randn_like", "gaussian_diffusion.GaussianDiffusion.condition_score", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "len"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion.p_mean_variance", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion._predict_eps_from_xstart", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion.condition_score"], ["", "", "", "def", "ddim_sample", "(", "\n", "self", ",", "\n", "model", ",", "\n", "x", ",", "\n", "t", ",", "\n", "clip_denoised", "=", "True", ",", "\n", "denoised_fn", "=", "None", ",", "\n", "cond_fn", "=", "None", ",", "\n", "model_kwargs", "=", "None", ",", "\n", "eta", "=", "0.0", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Sample x_{t-1} from the model using DDIM.\n\n        Same usage as p_sample().\n        \"\"\"", "\n", "out", "=", "self", ".", "p_mean_variance", "(", "\n", "model", ",", "\n", "x", ",", "\n", "t", ",", "\n", "clip_denoised", "=", "clip_denoised", ",", "\n", "denoised_fn", "=", "denoised_fn", ",", "\n", "model_kwargs", "=", "model_kwargs", ",", "\n", ")", "\n", "if", "cond_fn", "is", "not", "None", ":", "\n", "            ", "out", "=", "self", ".", "condition_score", "(", "cond_fn", ",", "out", ",", "x", ",", "t", ",", "model_kwargs", "=", "model_kwargs", ")", "\n", "\n", "# Usually our model outputs epsilon, but we re-derive it", "\n", "# in case we used x_start or x_prev prediction.", "\n", "", "eps", "=", "self", ".", "_predict_eps_from_xstart", "(", "x", ",", "t", ",", "out", "[", "\"pred_xstart\"", "]", ")", "\n", "\n", "alpha_bar", "=", "_extract_into_tensor", "(", "self", ".", "alphas_cumprod", ",", "t", ",", "x", ".", "shape", ")", "\n", "alpha_bar_prev", "=", "_extract_into_tensor", "(", "self", ".", "alphas_cumprod_prev", ",", "t", ",", "x", ".", "shape", ")", "\n", "sigma", "=", "(", "\n", "eta", "\n", "*", "th", ".", "sqrt", "(", "(", "1", "-", "alpha_bar_prev", ")", "/", "(", "1", "-", "alpha_bar", ")", ")", "\n", "*", "th", ".", "sqrt", "(", "1", "-", "alpha_bar", "/", "alpha_bar_prev", ")", "\n", ")", "\n", "# Equation 12.", "\n", "noise", "=", "th", ".", "randn_like", "(", "x", ")", "\n", "mean_pred", "=", "(", "\n", "out", "[", "\"pred_xstart\"", "]", "*", "th", ".", "sqrt", "(", "alpha_bar_prev", ")", "\n", "+", "th", ".", "sqrt", "(", "1", "-", "alpha_bar_prev", "-", "sigma", "**", "2", ")", "*", "eps", "\n", ")", "\n", "nonzero_mask", "=", "(", "\n", "(", "t", "!=", "0", ")", ".", "float", "(", ")", ".", "view", "(", "-", "1", ",", "*", "(", "[", "1", "]", "*", "(", "len", "(", "x", ".", "shape", ")", "-", "1", ")", ")", ")", "\n", ")", "# no noise when t == 0", "\n", "sample", "=", "mean_pred", "+", "nonzero_mask", "*", "sigma", "*", "noise", "\n", "return", "{", "\"sample\"", ":", "sample", ",", "\"pred_xstart\"", ":", "out", "[", "\"pred_xstart\"", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.ddim_reverse_sample": [[609, 646], ["gaussian_diffusion.GaussianDiffusion.p_mean_variance", "gaussian_diffusion._extract_into_tensor", "gaussian_diffusion._extract_into_tensor", "torch.sqrt", "torch.sqrt", "gaussian_diffusion._extract_into_tensor"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion.p_mean_variance", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor"], ["", "def", "ddim_reverse_sample", "(", "\n", "self", ",", "\n", "model", ",", "\n", "x", ",", "\n", "t", ",", "\n", "clip_denoised", "=", "True", ",", "\n", "denoised_fn", "=", "None", ",", "\n", "model_kwargs", "=", "None", ",", "\n", "eta", "=", "0.0", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Sample x_{t+1} from the model using DDIM reverse ODE.\n        \"\"\"", "\n", "assert", "eta", "==", "0.0", ",", "\"Reverse ODE only for deterministic path\"", "\n", "out", "=", "self", ".", "p_mean_variance", "(", "\n", "model", ",", "\n", "x", ",", "\n", "t", ",", "\n", "clip_denoised", "=", "clip_denoised", ",", "\n", "denoised_fn", "=", "denoised_fn", ",", "\n", "model_kwargs", "=", "model_kwargs", ",", "\n", ")", "\n", "# Usually our model outputs epsilon, but we re-derive it", "\n", "# in case we used x_start or x_prev prediction.", "\n", "eps", "=", "(", "\n", "_extract_into_tensor", "(", "self", ".", "sqrt_recip_alphas_cumprod", ",", "t", ",", "x", ".", "shape", ")", "*", "x", "\n", "-", "out", "[", "\"pred_xstart\"", "]", "\n", ")", "/", "_extract_into_tensor", "(", "self", ".", "sqrt_recipm1_alphas_cumprod", ",", "t", ",", "x", ".", "shape", ")", "\n", "alpha_bar_next", "=", "_extract_into_tensor", "(", "self", ".", "alphas_cumprod_next", ",", "t", ",", "x", ".", "shape", ")", "\n", "\n", "# Equation 12. reversed", "\n", "mean_pred", "=", "(", "\n", "out", "[", "\"pred_xstart\"", "]", "*", "th", ".", "sqrt", "(", "alpha_bar_next", ")", "\n", "+", "th", ".", "sqrt", "(", "1", "-", "alpha_bar_next", ")", "*", "eps", "\n", ")", "\n", "\n", "return", "{", "\"sample\"", ":", "mean_pred", ",", "\"pred_xstart\"", ":", "out", "[", "\"pred_xstart\"", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.ddim_sample_loop": [[647, 680], ["gaussian_diffusion.GaussianDiffusion.ddim_sample_loop_progressive"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.ddim_sample_loop_progressive"], ["", "def", "ddim_sample_loop", "(", "\n", "self", ",", "\n", "model", ",", "\n", "shape", ",", "\n", "noise", "=", "None", ",", "\n", "clip_denoised", "=", "True", ",", "\n", "denoised_fn", "=", "None", ",", "\n", "cond_fn", "=", "None", ",", "\n", "model_kwargs", "=", "None", ",", "\n", "device", "=", "None", ",", "\n", "progress", "=", "False", ",", "\n", "eta", "=", "0.0", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Generate samples from the model using DDIM.\n\n        Same usage as p_sample_loop().\n        \"\"\"", "\n", "final", "=", "None", "\n", "for", "sample", "in", "self", ".", "ddim_sample_loop_progressive", "(", "\n", "model", ",", "\n", "shape", ",", "\n", "noise", "=", "noise", ",", "\n", "clip_denoised", "=", "clip_denoised", ",", "\n", "denoised_fn", "=", "denoised_fn", ",", "\n", "cond_fn", "=", "cond_fn", ",", "\n", "model_kwargs", "=", "model_kwargs", ",", "\n", "device", "=", "device", ",", "\n", "progress", "=", "progress", ",", "\n", "eta", "=", "eta", ",", "\n", ")", ":", "\n", "            ", "final", "=", "sample", "\n", "", "return", "final", "[", "\"sample\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.ddim_sample_loop_progressive": [[681, 730], ["isinstance", "torch.randn", "list", "tqdm", "torch.tensor", "next", "range", "torch.no_grad", "gaussian_diffusion.GaussianDiffusion.ddim_sample", "model.parameters"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.ddim_sample"], ["", "def", "ddim_sample_loop_progressive", "(", "\n", "self", ",", "\n", "model", ",", "\n", "shape", ",", "\n", "noise", "=", "None", ",", "\n", "clip_denoised", "=", "True", ",", "\n", "denoised_fn", "=", "None", ",", "\n", "cond_fn", "=", "None", ",", "\n", "model_kwargs", "=", "None", ",", "\n", "device", "=", "None", ",", "\n", "progress", "=", "False", ",", "\n", "eta", "=", "0.0", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Use DDIM to sample from the model and yield intermediate samples from\n        each timestep of DDIM.\n\n        Same usage as p_sample_loop_progressive().\n        \"\"\"", "\n", "if", "device", "is", "None", ":", "\n", "            ", "device", "=", "next", "(", "model", ".", "parameters", "(", ")", ")", ".", "device", "\n", "", "assert", "isinstance", "(", "shape", ",", "(", "tuple", ",", "list", ")", ")", "\n", "if", "noise", "is", "not", "None", ":", "\n", "            ", "img", "=", "noise", "\n", "", "else", ":", "\n", "            ", "img", "=", "th", ".", "randn", "(", "*", "shape", ",", "device", "=", "device", ")", "\n", "", "indices", "=", "list", "(", "range", "(", "self", ".", "num_timesteps", ")", ")", "[", ":", ":", "-", "1", "]", "\n", "\n", "if", "progress", ":", "\n", "# Lazy import so that we don't depend on tqdm.", "\n", "            ", "from", "tqdm", ".", "auto", "import", "tqdm", "\n", "\n", "indices", "=", "tqdm", "(", "indices", ")", "\n", "\n", "", "for", "i", "in", "indices", ":", "\n", "            ", "t", "=", "th", ".", "tensor", "(", "[", "i", "]", "*", "shape", "[", "0", "]", ",", "device", "=", "device", ")", "\n", "with", "th", ".", "no_grad", "(", ")", ":", "\n", "                ", "out", "=", "self", ".", "ddim_sample", "(", "\n", "model", ",", "\n", "img", ",", "\n", "t", ",", "\n", "clip_denoised", "=", "clip_denoised", ",", "\n", "denoised_fn", "=", "denoised_fn", ",", "\n", "cond_fn", "=", "cond_fn", ",", "\n", "model_kwargs", "=", "model_kwargs", ",", "\n", "eta", "=", "eta", ",", "\n", ")", "\n", "yield", "out", "\n", "img", "=", "out", "[", "\"sample\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion._vb_terms_bpd": [[731, 765], ["gaussian_diffusion.GaussianDiffusion.q_posterior_mean_variance", "gaussian_diffusion.GaussianDiffusion.p_mean_variance", "losses.normal_kl", "torch.where", "nn.mean_flat", "numpy.log", "losses.discretized_gaussian_log_likelihood", "nn.mean_flat", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.q_posterior_mean_variance", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion.p_mean_variance", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.losses.normal_kl", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.mean_flat", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.losses.discretized_gaussian_log_likelihood", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.mean_flat", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log"], ["", "", "", "def", "_vb_terms_bpd", "(", "\n", "self", ",", "model", ",", "x_start", ",", "x_t", ",", "t", ",", "clip_denoised", "=", "True", ",", "model_kwargs", "=", "None", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Get a term for the variational lower-bound.\n\n        The resulting units are bits (rather than nats, as one might expect).\n        This allows for comparison to other papers.\n\n        :return: a dict with the following keys:\n                 - 'output': a shape [N] tensor of NLLs or KLs.\n                 - 'pred_xstart': the x_0 predictions.\n        \"\"\"", "\n", "true_mean", ",", "_", ",", "true_log_variance_clipped", "=", "self", ".", "q_posterior_mean_variance", "(", "\n", "x_start", "=", "x_start", ",", "x_t", "=", "x_t", ",", "t", "=", "t", "\n", ")", "\n", "out", "=", "self", ".", "p_mean_variance", "(", "\n", "model", ",", "x_t", ",", "t", ",", "clip_denoised", "=", "clip_denoised", ",", "model_kwargs", "=", "model_kwargs", "\n", ")", "\n", "kl", "=", "normal_kl", "(", "\n", "true_mean", ",", "true_log_variance_clipped", ",", "out", "[", "\"mean\"", "]", ",", "out", "[", "\"log_variance\"", "]", "\n", ")", "\n", "kl", "=", "mean_flat", "(", "kl", ")", "/", "np", ".", "log", "(", "2.0", ")", "\n", "\n", "decoder_nll", "=", "-", "discretized_gaussian_log_likelihood", "(", "\n", "x_start", ",", "means", "=", "out", "[", "\"mean\"", "]", ",", "log_scales", "=", "0.5", "*", "out", "[", "\"log_variance\"", "]", "\n", ")", "\n", "assert", "decoder_nll", ".", "shape", "==", "x_start", ".", "shape", "\n", "decoder_nll", "=", "mean_flat", "(", "decoder_nll", ")", "/", "np", ".", "log", "(", "2.0", ")", "\n", "\n", "# At the first timestep return the decoder NLL,", "\n", "# otherwise return KL(q(x_{t-1}|x_t,x_0) || p(x_{t-1}|x_t))", "\n", "output", "=", "th", ".", "where", "(", "(", "t", "==", "0", ")", ",", "decoder_nll", ",", "kl", ")", "\n", "return", "{", "\"output\"", ":", "output", ",", "\"pred_xstart\"", ":", "out", "[", "\"pred_xstart\"", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.training_losses": [[766, 840], ["gaussian_diffusion.GaussianDiffusion.q_sample", "torch.randn_like", "gaussian_diffusion.GaussianDiffusion._vb_terms_bpd", "model", "nn.mean_flat", "NotImplementedError", "gaussian_diffusion.GaussianDiffusion._scale_timesteps", "torch.split", "torch.cat", "gaussian_diffusion.GaussianDiffusion._vb_terms_bpd", "model.detach", "gaussian_diffusion.GaussianDiffusion.q_posterior_mean_variance"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.q_sample", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion._vb_terms_bpd", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.mean_flat", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion._scale_timesteps", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion._vb_terms_bpd", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.q_posterior_mean_variance"], ["", "def", "training_losses", "(", "self", ",", "model", ",", "x_start", ",", "t", ",", "model_kwargs", "=", "None", ",", "noise", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Compute training losses for a single timestep.\n\n        :param model: the model to evaluate loss on.\n        :param x_start: the [N x C x ...] tensor of inputs.\n        :param t: a batch of timestep indices.\n        :param model_kwargs: if not None, a dict of extra keyword arguments to\n            pass to the model. This can be used for conditioning.\n        :param noise: if specified, the specific Gaussian noise to try to remove.\n        :return: a dict with the key \"loss\" containing a tensor of shape [N].\n                 Some mean or variance settings may also have other keys.\n        \"\"\"", "\n", "if", "model_kwargs", "is", "None", ":", "\n", "            ", "model_kwargs", "=", "{", "}", "\n", "", "if", "noise", "is", "None", ":", "\n", "            ", "noise", "=", "th", ".", "randn_like", "(", "x_start", ")", "\n", "", "x_t", "=", "self", ".", "q_sample", "(", "x_start", ",", "t", ",", "noise", "=", "noise", ")", "\n", "\n", "terms", "=", "{", "}", "\n", "\n", "if", "self", ".", "loss_type", "==", "LossType", ".", "KL", "or", "self", ".", "loss_type", "==", "LossType", ".", "RESCALED_KL", ":", "\n", "            ", "terms", "[", "\"loss\"", "]", "=", "self", ".", "_vb_terms_bpd", "(", "\n", "model", "=", "model", ",", "\n", "x_start", "=", "x_start", ",", "\n", "x_t", "=", "x_t", ",", "\n", "t", "=", "t", ",", "\n", "clip_denoised", "=", "False", ",", "\n", "model_kwargs", "=", "model_kwargs", ",", "\n", ")", "[", "\"output\"", "]", "\n", "if", "self", ".", "loss_type", "==", "LossType", ".", "RESCALED_KL", ":", "\n", "                ", "terms", "[", "\"loss\"", "]", "*=", "self", ".", "num_timesteps", "\n", "", "", "elif", "self", ".", "loss_type", "==", "LossType", ".", "MSE", "or", "self", ".", "loss_type", "==", "LossType", ".", "RESCALED_MSE", ":", "\n", "            ", "model_output", "=", "model", "(", "x_t", ",", "self", ".", "_scale_timesteps", "(", "t", ")", ",", "**", "model_kwargs", ")", "\n", "\n", "if", "self", ".", "model_var_type", "in", "[", "\n", "ModelVarType", ".", "LEARNED", ",", "\n", "ModelVarType", ".", "LEARNED_RANGE", ",", "\n", "]", ":", "\n", "                ", "B", ",", "C", "=", "x_t", ".", "shape", "[", ":", "2", "]", "\n", "assert", "model_output", ".", "shape", "==", "(", "B", ",", "C", "*", "2", ",", "*", "x_t", ".", "shape", "[", "2", ":", "]", ")", "\n", "model_output", ",", "model_var_values", "=", "th", ".", "split", "(", "model_output", ",", "C", ",", "dim", "=", "1", ")", "\n", "# Learn the variance using the variational bound, but don't let", "\n", "# it affect our mean prediction.", "\n", "frozen_out", "=", "th", ".", "cat", "(", "[", "model_output", ".", "detach", "(", ")", ",", "model_var_values", "]", ",", "dim", "=", "1", ")", "\n", "terms", "[", "\"vb\"", "]", "=", "self", ".", "_vb_terms_bpd", "(", "\n", "model", "=", "lambda", "*", "args", ",", "r", "=", "frozen_out", ":", "r", ",", "\n", "x_start", "=", "x_start", ",", "\n", "x_t", "=", "x_t", ",", "\n", "t", "=", "t", ",", "\n", "clip_denoised", "=", "False", ",", "\n", ")", "[", "\"output\"", "]", "\n", "if", "self", ".", "loss_type", "==", "LossType", ".", "RESCALED_MSE", ":", "\n", "# Divide by 1000 for equivalence with initial implementation.", "\n", "# Without a factor of 1/1000, the VB term hurts the MSE term.", "\n", "                    ", "terms", "[", "\"vb\"", "]", "*=", "self", ".", "num_timesteps", "/", "1000.0", "\n", "\n", "", "", "target", "=", "{", "\n", "ModelMeanType", ".", "PREVIOUS_X", ":", "self", ".", "q_posterior_mean_variance", "(", "\n", "x_start", "=", "x_start", ",", "x_t", "=", "x_t", ",", "t", "=", "t", "\n", ")", "[", "0", "]", ",", "\n", "ModelMeanType", ".", "START_X", ":", "x_start", ",", "\n", "ModelMeanType", ".", "EPSILON", ":", "noise", ",", "\n", "}", "[", "self", ".", "model_mean_type", "]", "\n", "assert", "model_output", ".", "shape", "==", "target", ".", "shape", "==", "x_start", ".", "shape", "\n", "terms", "[", "\"mse\"", "]", "=", "mean_flat", "(", "(", "target", "-", "model_output", ")", "**", "2", ")", "\n", "if", "\"vb\"", "in", "terms", ":", "\n", "                ", "terms", "[", "\"loss\"", "]", "=", "terms", "[", "\"mse\"", "]", "+", "terms", "[", "\"vb\"", "]", "\n", "", "else", ":", "\n", "                ", "terms", "[", "\"loss\"", "]", "=", "terms", "[", "\"mse\"", "]", "\n", "", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "self", ".", "loss_type", ")", "\n", "\n", "", "return", "terms", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion._prior_bpd": [[841, 858], ["torch.tensor", "gaussian_diffusion.GaussianDiffusion.q_mean_variance", "losses.normal_kl", "nn.mean_flat", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.q_mean_variance", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.losses.normal_kl", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.mean_flat", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log"], ["", "def", "_prior_bpd", "(", "self", ",", "x_start", ")", ":", "\n", "        ", "\"\"\"\n        Get the prior KL term for the variational lower-bound, measured in\n        bits-per-dim.\n\n        This term can't be optimized, as it only depends on the encoder.\n\n        :param x_start: the [N x C x ...] tensor of inputs.\n        :return: a batch of [N] KL values (in bits), one per batch element.\n        \"\"\"", "\n", "batch_size", "=", "x_start", ".", "shape", "[", "0", "]", "\n", "t", "=", "th", ".", "tensor", "(", "[", "self", ".", "num_timesteps", "-", "1", "]", "*", "batch_size", ",", "device", "=", "x_start", ".", "device", ")", "\n", "qt_mean", ",", "_", ",", "qt_log_variance", "=", "self", ".", "q_mean_variance", "(", "x_start", ",", "t", ")", "\n", "kl_prior", "=", "normal_kl", "(", "\n", "mean1", "=", "qt_mean", ",", "logvar1", "=", "qt_log_variance", ",", "mean2", "=", "0.0", ",", "logvar2", "=", "0.0", "\n", ")", "\n", "return", "mean_flat", "(", "kl_prior", ")", "/", "np", ".", "log", "(", "2.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.calc_bpd_loop": [[859, 914], ["torch.stack", "torch.stack", "torch.stack", "gaussian_diffusion.GaussianDiffusion._prior_bpd", "list", "torch.tensor", "torch.randn_like", "gaussian_diffusion.GaussianDiffusion.q_sample", "torch.stack.append", "torch.stack.append", "gaussian_diffusion.GaussianDiffusion._predict_eps_from_xstart", "torch.stack.append", "torch.stack.sum", "range", "torch.no_grad", "gaussian_diffusion.GaussianDiffusion._vb_terms_bpd", "nn.mean_flat", "nn.mean_flat"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion._prior_bpd", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.q_sample", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion._predict_eps_from_xstart", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion._vb_terms_bpd", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.mean_flat", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.mean_flat"], ["", "def", "calc_bpd_loop", "(", "self", ",", "model", ",", "x_start", ",", "clip_denoised", "=", "True", ",", "model_kwargs", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Compute the entire variational lower-bound, measured in bits-per-dim,\n        as well as other related quantities.\n\n        :param model: the model to evaluate loss on.\n        :param x_start: the [N x C x ...] tensor of inputs.\n        :param clip_denoised: if True, clip denoised samples.\n        :param model_kwargs: if not None, a dict of extra keyword arguments to\n            pass to the model. This can be used for conditioning.\n\n        :return: a dict containing the following keys:\n                 - total_bpd: the total variational lower-bound, per batch element.\n                 - prior_bpd: the prior term in the lower-bound.\n                 - vb: an [N x T] tensor of terms in the lower-bound.\n                 - xstart_mse: an [N x T] tensor of x_0 MSEs for each timestep.\n                 - mse: an [N x T] tensor of epsilon MSEs for each timestep.\n        \"\"\"", "\n", "device", "=", "x_start", ".", "device", "\n", "batch_size", "=", "x_start", ".", "shape", "[", "0", "]", "\n", "\n", "vb", "=", "[", "]", "\n", "xstart_mse", "=", "[", "]", "\n", "mse", "=", "[", "]", "\n", "for", "t", "in", "list", "(", "range", "(", "self", ".", "num_timesteps", ")", ")", "[", ":", ":", "-", "1", "]", ":", "\n", "            ", "t_batch", "=", "th", ".", "tensor", "(", "[", "t", "]", "*", "batch_size", ",", "device", "=", "device", ")", "\n", "noise", "=", "th", ".", "randn_like", "(", "x_start", ")", "\n", "x_t", "=", "self", ".", "q_sample", "(", "x_start", "=", "x_start", ",", "t", "=", "t_batch", ",", "noise", "=", "noise", ")", "\n", "# Calculate VLB term at the current timestep", "\n", "with", "th", ".", "no_grad", "(", ")", ":", "\n", "                ", "out", "=", "self", ".", "_vb_terms_bpd", "(", "\n", "model", ",", "\n", "x_start", "=", "x_start", ",", "\n", "x_t", "=", "x_t", ",", "\n", "t", "=", "t_batch", ",", "\n", "clip_denoised", "=", "clip_denoised", ",", "\n", "model_kwargs", "=", "model_kwargs", ",", "\n", ")", "\n", "", "vb", ".", "append", "(", "out", "[", "\"output\"", "]", ")", "\n", "xstart_mse", ".", "append", "(", "mean_flat", "(", "(", "out", "[", "\"pred_xstart\"", "]", "-", "x_start", ")", "**", "2", ")", ")", "\n", "eps", "=", "self", ".", "_predict_eps_from_xstart", "(", "x_t", ",", "t_batch", ",", "out", "[", "\"pred_xstart\"", "]", ")", "\n", "mse", ".", "append", "(", "mean_flat", "(", "(", "eps", "-", "noise", ")", "**", "2", ")", ")", "\n", "\n", "", "vb", "=", "th", ".", "stack", "(", "vb", ",", "dim", "=", "1", ")", "\n", "xstart_mse", "=", "th", ".", "stack", "(", "xstart_mse", ",", "dim", "=", "1", ")", "\n", "mse", "=", "th", ".", "stack", "(", "mse", ",", "dim", "=", "1", ")", "\n", "\n", "prior_bpd", "=", "self", ".", "_prior_bpd", "(", "x_start", ")", "\n", "total_bpd", "=", "vb", ".", "sum", "(", "dim", "=", "1", ")", "+", "prior_bpd", "\n", "return", "{", "\n", "\"total_bpd\"", ":", "total_bpd", ",", "\n", "\"prior_bpd\"", ":", "prior_bpd", ",", "\n", "\"vb\"", ":", "vb", ",", "\n", "\"xstart_mse\"", ":", "xstart_mse", ",", "\n", "\"mse\"", ":", "mse", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.get_named_beta_schedule": [[18, 43], ["numpy.linspace", "gaussian_diffusion.betas_for_alpha_bar", "NotImplementedError", "math.cos"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.betas_for_alpha_bar"], ["def", "get_named_beta_schedule", "(", "schedule_name", ",", "num_diffusion_timesteps", ")", ":", "\n", "    ", "\"\"\"\n    Get a pre-defined beta schedule for the given name.\n\n    The beta schedule library consists of beta schedules which remain similar\n    in the limit of num_diffusion_timesteps.\n    Beta schedules may be added, but should not be removed or changed once\n    they are committed to maintain backwards compatibility.\n    \"\"\"", "\n", "if", "schedule_name", "==", "\"linear\"", ":", "\n", "# Linear schedule from Ho et al, extended to work for any number of", "\n", "# diffusion steps.", "\n", "        ", "scale", "=", "1000", "/", "num_diffusion_timesteps", "\n", "beta_start", "=", "scale", "*", "0.0001", "\n", "beta_end", "=", "scale", "*", "0.02", "\n", "return", "np", ".", "linspace", "(", "\n", "beta_start", ",", "beta_end", ",", "num_diffusion_timesteps", ",", "dtype", "=", "np", ".", "float64", "\n", ")", "\n", "", "elif", "schedule_name", "==", "\"cosine\"", ":", "\n", "        ", "return", "betas_for_alpha_bar", "(", "\n", "num_diffusion_timesteps", ",", "\n", "lambda", "t", ":", "math", ".", "cos", "(", "(", "t", "+", "0.008", ")", "/", "1.008", "*", "math", ".", "pi", "/", "2", ")", "**", "2", ",", "\n", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "f\"unknown beta schedule: {schedule_name}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.betas_for_alpha_bar": [[45, 63], ["range", "numpy.array", "betas.append", "min", "alpha_bar", "alpha_bar"], "function", ["None"], ["", "", "def", "betas_for_alpha_bar", "(", "num_diffusion_timesteps", ",", "alpha_bar", ",", "max_beta", "=", "0.999", ")", ":", "\n", "    ", "\"\"\"\n    Create a beta schedule that discretizes the given alpha_t_bar function,\n    which defines the cumulative product of (1-beta) over time from t = [0,1].\n\n    :param num_diffusion_timesteps: the number of betas to produce.\n    :param alpha_bar: a lambda that takes an argument t from 0 to 1 and\n                      produces the cumulative product of (1-beta) up to that\n                      part of the diffusion process.\n    :param max_beta: the maximum beta to use; use values lower than 1 to\n                     prevent singularities.\n    \"\"\"", "\n", "betas", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_diffusion_timesteps", ")", ":", "\n", "        ", "t1", "=", "i", "/", "num_diffusion_timesteps", "\n", "t2", "=", "(", "i", "+", "1", ")", "/", "num_diffusion_timesteps", "\n", "betas", ".", "append", "(", "min", "(", "1", "-", "alpha_bar", "(", "t2", ")", "/", "alpha_bar", "(", "t1", ")", ",", "max_beta", ")", ")", "\n", "", "return", "np", ".", "array", "(", "betas", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion._extract_into_tensor": [[917, 933], ["[].float", "[].float.expand", "len", "len", "torch.from_numpy().to", "torch.from_numpy"], "function", ["None"], ["", "", "def", "_extract_into_tensor", "(", "arr", ",", "timesteps", ",", "broadcast_shape", ")", ":", "\n", "    ", "\"\"\"\n    Extract values from a 1-D numpy array for a batch of indices.\n\n    :param arr: the 1-D numpy array.\n    :param timesteps: a tensor of indices into the array to extract.\n    :param broadcast_shape: a larger shape of K dimensions with the batch\n                            dimension equal to the length of timesteps.\n    :return: a tensor of shape [batch_size, 1, ...] where the shape has K dims.\n    \"\"\"", "\n", "# print(timesteps)", "\n", "# print(len(arr))", "\n", "res", "=", "th", ".", "from_numpy", "(", "arr", ")", ".", "to", "(", "device", "=", "timesteps", ".", "device", ")", "[", "timesteps", "]", ".", "float", "(", ")", "\n", "while", "len", "(", "res", ".", "shape", ")", "<", "len", "(", "broadcast_shape", ")", ":", "\n", "        ", "res", "=", "res", "[", "...", ",", "None", "]", "\n", "", "return", "res", ".", "expand", "(", "broadcast_shape", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.dist_util.setup_dist": [[21, 43], ["torch.is_initialized", "comm.bcast", "str", "str", "comm.bcast", "str", "torch.init_process_group", "socket.gethostbyname", "dist_util._find_free_port", "torch.cuda.is_available", "socket.getfqdn"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.dist_util._find_free_port"], ["def", "setup_dist", "(", ")", ":", "\n", "    ", "\"\"\"\n    Setup a distributed process group.\n    \"\"\"", "\n", "if", "dist", ".", "is_initialized", "(", ")", ":", "\n", "        ", "return", "\n", "# os.environ[\"CUDA_VISIBLE_DEVICES\"] = f\"{MPI.COMM_WORLD.Get_rank() % GPUS_PER_NODE}\"", "\n", "\n", "", "comm", "=", "MPI", ".", "COMM_WORLD", "\n", "backend", "=", "\"gloo\"", "if", "not", "th", ".", "cuda", ".", "is_available", "(", ")", "else", "\"nccl\"", "\n", "\n", "if", "backend", "==", "\"gloo\"", ":", "\n", "        ", "hostname", "=", "\"localhost\"", "\n", "", "else", ":", "\n", "        ", "hostname", "=", "socket", ".", "gethostbyname", "(", "socket", ".", "getfqdn", "(", ")", ")", "\n", "", "os", ".", "environ", "[", "\"MASTER_ADDR\"", "]", "=", "comm", ".", "bcast", "(", "hostname", ",", "root", "=", "0", ")", "\n", "os", ".", "environ", "[", "\"RANK\"", "]", "=", "str", "(", "comm", ".", "rank", ")", "\n", "os", ".", "environ", "[", "\"WORLD_SIZE\"", "]", "=", "str", "(", "comm", ".", "size", ")", "\n", "\n", "port", "=", "comm", ".", "bcast", "(", "_find_free_port", "(", ")", ",", "root", "=", "0", ")", "\n", "os", ".", "environ", "[", "\"MASTER_PORT\"", "]", "=", "str", "(", "port", ")", "\n", "dist", ".", "init_process_group", "(", "backend", "=", "backend", ",", "init_method", "=", "\"env://\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.dist_util.dev": [[45, 52], ["torch.cuda.is_available", "torch.device", "torch.device"], "function", ["None"], ["", "def", "dev", "(", ")", ":", "\n", "    ", "\"\"\"\n    Get the device to use for torch.distributed.\n    \"\"\"", "\n", "if", "th", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "return", "th", ".", "device", "(", "f\"cuda\"", ")", "\n", "", "return", "th", ".", "device", "(", "\"cpu\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.dist_util.load_state_dict": [[54, 75], ["torch.load", "mpi4py.MPI.COMM_WORLD.Get_rank", "mpi4py.MPI.COMM_WORLD.bcast", "range", "mpi4py.MPI.COMM_WORLD.bcast", "bytes", "range", "io.BytesIO", "blobfile.BlobFile", "f.read", "len", "len", "len", "mpi4py.MPI.COMM_WORLD.bcast", "mpi4py.MPI.COMM_WORLD.bcast"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.load"], ["", "def", "load_state_dict", "(", "path", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Load a PyTorch file without redundant fetches across MPI ranks.\n    \"\"\"", "\n", "chunk_size", "=", "2", "**", "30", "# MPI has a relatively small size limit", "\n", "if", "MPI", ".", "COMM_WORLD", ".", "Get_rank", "(", ")", "==", "0", ":", "\n", "        ", "with", "bf", ".", "BlobFile", "(", "path", ",", "\"rb\"", ")", "as", "f", ":", "\n", "            ", "data", "=", "f", ".", "read", "(", ")", "\n", "", "num_chunks", "=", "len", "(", "data", ")", "//", "chunk_size", "\n", "if", "len", "(", "data", ")", "%", "chunk_size", ":", "\n", "            ", "num_chunks", "+=", "1", "\n", "", "MPI", ".", "COMM_WORLD", ".", "bcast", "(", "num_chunks", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "data", ")", ",", "chunk_size", ")", ":", "\n", "            ", "MPI", ".", "COMM_WORLD", ".", "bcast", "(", "data", "[", "i", ":", "i", "+", "chunk_size", "]", ")", "\n", "", "", "else", ":", "\n", "        ", "num_chunks", "=", "MPI", ".", "COMM_WORLD", ".", "bcast", "(", "None", ")", "\n", "data", "=", "bytes", "(", ")", "\n", "for", "_", "in", "range", "(", "num_chunks", ")", ":", "\n", "            ", "data", "+=", "MPI", ".", "COMM_WORLD", ".", "bcast", "(", "None", ")", "\n", "\n", "", "", "return", "th", ".", "load", "(", "io", ".", "BytesIO", "(", "data", ")", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.dist_util.sync_params": [[77, 84], ["torch.no_grad", "torch.broadcast"], "function", ["None"], ["", "def", "sync_params", "(", "params", ")", ":", "\n", "    ", "\"\"\"\n    Synchronize a sequence of Tensors across ranks from rank 0.\n    \"\"\"", "\n", "for", "p", "in", "params", ":", "\n", "        ", "with", "th", ".", "no_grad", "(", ")", ":", "\n", "            ", "dist", ".", "broadcast", "(", "p", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.dist_util._find_free_port": [[86, 94], ["socket.socket", "socket.socket.bind", "socket.socket.setsockopt", "socket.socket.close", "socket.socket.getsockname"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.Logger.close"], ["", "", "", "def", "_find_free_port", "(", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "s", "=", "socket", ".", "socket", "(", "socket", ".", "AF_INET", ",", "socket", ".", "SOCK_STREAM", ")", "\n", "s", ".", "bind", "(", "(", "\"\"", ",", "0", ")", ")", "\n", "s", ".", "setsockopt", "(", "socket", ".", "SOL_SOCKET", ",", "socket", ".", "SO_REUSEADDR", ",", "1", ")", "\n", "return", "s", ".", "getsockname", "(", ")", "[", "1", "]", "\n", "", "finally", ":", "\n", "        ", "s", ".", "close", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion.__init__": [[72, 87], ["set", "len", "gaussian_diffusion.GaussianDiffusion", "enumerate", "numpy.array", "gaussian_diffusion.GaussianDiffusion.__init__", "new_betas.append", "respace.SpacedDiffusion.timestep_map.append"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["def", "__init__", "(", "self", ",", "use_timesteps", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "use_timesteps", "=", "set", "(", "use_timesteps", ")", "\n", "self", ".", "timestep_map", "=", "[", "]", "\n", "self", ".", "original_num_steps", "=", "len", "(", "kwargs", "[", "\"betas\"", "]", ")", "\n", "\n", "base_diffusion", "=", "GaussianDiffusion", "(", "**", "kwargs", ")", "# pylint: disable=missing-kwoa", "\n", "last_alpha_cumprod", "=", "1.0", "\n", "new_betas", "=", "[", "]", "\n", "for", "i", ",", "alpha_cumprod", "in", "enumerate", "(", "base_diffusion", ".", "alphas_cumprod", ")", ":", "\n", "            ", "if", "i", "in", "self", ".", "use_timesteps", ":", "\n", "                ", "new_betas", ".", "append", "(", "1", "-", "alpha_cumprod", "/", "last_alpha_cumprod", ")", "\n", "last_alpha_cumprod", "=", "alpha_cumprod", "\n", "self", ".", "timestep_map", ".", "append", "(", "i", ")", "\n", "", "", "kwargs", "[", "\"betas\"", "]", "=", "np", ".", "array", "(", "new_betas", ")", "\n", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion.p_mean_variance": [[88, 92], ["super().p_mean_variance", "respace.SpacedDiffusion._wrap_model"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion.p_mean_variance", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion._wrap_model"], ["", "def", "p_mean_variance", "(", "\n", "self", ",", "model", ",", "*", "args", ",", "**", "kwargs", "\n", ")", ":", "# pylint: disable=signature-differs", "\n", "        ", "return", "super", "(", ")", ".", "p_mean_variance", "(", "self", ".", "_wrap_model", "(", "model", ")", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion.training_losses": [[93, 97], ["super().training_losses", "respace.SpacedDiffusion._wrap_model"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion.training_losses", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion._wrap_model"], ["", "def", "training_losses", "(", "\n", "self", ",", "model", ",", "*", "args", ",", "**", "kwargs", "\n", ")", ":", "# pylint: disable=signature-differs", "\n", "        ", "return", "super", "(", ")", ".", "training_losses", "(", "self", ".", "_wrap_model", "(", "model", ")", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion.condition_mean": [[98, 100], ["super().condition_mean", "respace.SpacedDiffusion._wrap_model"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion.condition_mean", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion._wrap_model"], ["", "def", "condition_mean", "(", "self", ",", "cond_fn", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "condition_mean", "(", "self", ".", "_wrap_model", "(", "cond_fn", ")", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion.condition_score": [[101, 103], ["super().condition_score", "respace.SpacedDiffusion._wrap_model"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion.condition_score", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion._wrap_model"], ["", "def", "condition_score", "(", "self", ",", "cond_fn", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "condition_score", "(", "self", ".", "_wrap_model", "(", "cond_fn", ")", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion._wrap_model": [[104, 109], ["isinstance", "respace._WrappedModel"], "methods", ["None"], ["", "def", "_wrap_model", "(", "self", ",", "model", ")", ":", "\n", "        ", "if", "isinstance", "(", "model", ",", "_WrappedModel", ")", ":", "\n", "            ", "return", "model", "\n", "", "return", "_WrappedModel", "(", "\n", "model", ",", "self", ".", "timestep_map", ",", "self", ".", "rescale_timesteps", ",", "self", ".", "original_num_steps", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion._scale_timesteps": [[111, 114], ["None"], "methods", ["None"], ["", "def", "_scale_timesteps", "(", "self", ",", "t", ")", ":", "\n", "# Scaling is done by the wrapped model.", "\n", "        ", "return", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace._WrappedModel.__init__": [[117, 122], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "timestep_map", ",", "rescale_timesteps", ",", "original_num_steps", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "timestep_map", "=", "timestep_map", "\n", "self", ".", "rescale_timesteps", "=", "rescale_timesteps", "\n", "self", ".", "original_num_steps", "=", "original_num_steps", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace._WrappedModel.__call__": [[123, 129], ["torch.tensor", "respace._WrappedModel.model", "new_ts.float"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "x", ",", "ts", ",", "**", "kwargs", ")", ":", "\n", "        ", "map_tensor", "=", "th", ".", "tensor", "(", "self", ".", "timestep_map", ",", "device", "=", "ts", ".", "device", ",", "dtype", "=", "ts", ".", "dtype", ")", "\n", "new_ts", "=", "map_tensor", "[", "ts", "]", "\n", "if", "self", ".", "rescale_timesteps", ":", "\n", "            ", "new_ts", "=", "new_ts", ".", "float", "(", ")", "*", "(", "1000.0", "/", "self", ".", "original_num_steps", ")", "\n", "", "return", "self", ".", "model", "(", "x", ",", "new_ts", ",", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.space_timesteps": [[7, 61], ["isinstance", "enumerate", "set", "section_counts.startswith", "len", "len", "range", "int", "range", "ValueError", "int", "ValueError", "taken_steps.append", "section_counts.split", "len", "set", "round", "len", "range", "range"], "function", ["None"], ["def", "space_timesteps", "(", "num_timesteps", ",", "section_counts", ")", ":", "\n", "    ", "\"\"\"\n    Create a list of timesteps to use from an original diffusion process,\n    given the number of timesteps we want to take from equally-sized portions\n    of the original process.\n\n    For example, if there's 300 timesteps and the section counts are [10,15,20]\n    then the first 100 timesteps are strided to be 10 timesteps, the second 100\n    are strided to be 15 timesteps, and the final 100 are strided to be 20.\n\n    If the stride is a string starting with \"ddim\", then the fixed striding\n    from the DDIM paper is used, and only one section is allowed.\n\n    :param num_timesteps: the number of diffusion steps in the original\n                          process to divide up.\n    :param section_counts: either a list of numbers, or a string containing\n                           comma-separated numbers, indicating the step count\n                           per section. As a special case, use \"ddimN\" where N\n                           is a number of steps to use the striding from the\n                           DDIM paper.\n    :return: a set of diffusion steps from the original process to use.\n    \"\"\"", "\n", "if", "isinstance", "(", "section_counts", ",", "str", ")", ":", "\n", "        ", "if", "section_counts", ".", "startswith", "(", "\"ddim\"", ")", ":", "\n", "            ", "desired_count", "=", "int", "(", "section_counts", "[", "len", "(", "\"ddim\"", ")", ":", "]", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "num_timesteps", ")", ":", "\n", "                ", "if", "len", "(", "range", "(", "0", ",", "num_timesteps", ",", "i", ")", ")", "==", "desired_count", ":", "\n", "                    ", "return", "set", "(", "range", "(", "0", ",", "num_timesteps", ",", "i", ")", ")", "\n", "", "", "raise", "ValueError", "(", "\n", "f\"cannot create exactly {num_timesteps} steps with an integer stride\"", "\n", ")", "\n", "", "section_counts", "=", "[", "int", "(", "x", ")", "for", "x", "in", "section_counts", ".", "split", "(", "\",\"", ")", "]", "\n", "", "size_per", "=", "num_timesteps", "//", "len", "(", "section_counts", ")", "\n", "extra", "=", "num_timesteps", "%", "len", "(", "section_counts", ")", "\n", "start_idx", "=", "0", "\n", "all_steps", "=", "[", "]", "\n", "for", "i", ",", "section_count", "in", "enumerate", "(", "section_counts", ")", ":", "\n", "        ", "size", "=", "size_per", "+", "(", "1", "if", "i", "<", "extra", "else", "0", ")", "\n", "if", "size", "<", "section_count", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"cannot divide section of {size} steps into {section_count}\"", "\n", ")", "\n", "", "if", "section_count", "<=", "1", ":", "\n", "            ", "frac_stride", "=", "1", "\n", "", "else", ":", "\n", "            ", "frac_stride", "=", "(", "size", "-", "1", ")", "/", "(", "section_count", "-", "1", ")", "\n", "", "cur_idx", "=", "0.0", "\n", "taken_steps", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "section_count", ")", ":", "\n", "            ", "taken_steps", ".", "append", "(", "start_idx", "+", "round", "(", "cur_idx", ")", ")", "\n", "cur_idx", "+=", "frac_stride", "\n", "", "all_steps", "+=", "taken_steps", "\n", "start_idx", "+=", "size", "\n", "", "return", "set", "(", "all_steps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.AttentionPool2d.__init__": [[27, 42], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.conv_nd", "torch.conv_nd", "unet.QKVAttention", "torch.randn", "torch.randn", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.conv_nd", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.conv_nd"], ["def", "__init__", "(", "\n", "self", ",", "\n", "spacial_dim", ":", "int", ",", "\n", "embed_dim", ":", "int", ",", "\n", "num_heads_channels", ":", "int", ",", "\n", "output_dim", ":", "int", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "positional_embedding", "=", "nn", ".", "Parameter", "(", "\n", "th", ".", "randn", "(", "embed_dim", ",", "spacial_dim", "**", "2", "+", "1", ")", "/", "embed_dim", "**", "0.5", "\n", ")", "\n", "self", ".", "qkv_proj", "=", "conv_nd", "(", "1", ",", "embed_dim", ",", "3", "*", "embed_dim", ",", "1", ")", "\n", "self", ".", "c_proj", "=", "conv_nd", "(", "1", ",", "embed_dim", ",", "output_dim", "or", "embed_dim", ",", "1", ")", "\n", "self", ".", "num_heads", "=", "embed_dim", "//", "num_heads_channels", "\n", "self", ".", "attention", "=", "QKVAttention", "(", "self", ".", "num_heads", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.AttentionPool2d.forward": [[43, 52], ["unet.AttentionPool2d.reshape", "torch.cat", "torch.cat", "torch.cat", "unet.AttentionPool2d.qkv_proj", "unet.AttentionPool2d.attention", "unet.AttentionPool2d.c_proj", "unet.AttentionPool2d.positional_embedding[].to", "unet.AttentionPool2d.mean"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "b", ",", "c", ",", "*", "_spatial", "=", "x", ".", "shape", "\n", "x", "=", "x", ".", "reshape", "(", "b", ",", "c", ",", "-", "1", ")", "# NC(HW)", "\n", "x", "=", "th", ".", "cat", "(", "[", "x", ".", "mean", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "True", ")", ",", "x", "]", ",", "dim", "=", "-", "1", ")", "# NC(HW+1)", "\n", "x", "=", "x", "+", "self", ".", "positional_embedding", "[", "None", ",", ":", ",", ":", "]", ".", "to", "(", "x", ".", "dtype", ")", "# NC(HW+1)", "\n", "x", "=", "self", ".", "qkv_proj", "(", "x", ")", "\n", "x", "=", "self", ".", "attention", "(", "x", ")", "\n", "x", "=", "self", ".", "c_proj", "(", "x", ")", "\n", "return", "x", "[", ":", ",", ":", ",", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.TimestepBlock.forward": [[59, 64], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "forward", "(", "self", ",", "x", ",", "emb", ")", ":", "\n", "        ", "\"\"\"\n        Apply the module to `x` given `emb` timestep embeddings.\n        \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.TimestepEmbedSequential.forward": [[72, 79], ["isinstance", "layer", "layer"], "methods", ["None"], ["def", "forward", "(", "self", ",", "x", ",", "emb", ")", ":", "\n", "        ", "for", "layer", "in", "self", ":", "\n", "            ", "if", "isinstance", "(", "layer", ",", "TimestepBlock", ")", ":", "\n", "                ", "x", "=", "layer", "(", "x", ",", "emb", ")", "\n", "", "else", ":", "\n", "                ", "x", "=", "layer", "(", "x", ")", "\n", "", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.Upsample.__init__": [[91, 99], ["torch.Module.__init__", "torch.conv_nd"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.conv_nd"], ["def", "__init__", "(", "self", ",", "channels", ",", "use_conv", ",", "dims", "=", "2", ",", "out_channels", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "channels", "=", "channels", "\n", "self", ".", "out_channels", "=", "out_channels", "or", "channels", "\n", "self", ".", "use_conv", "=", "use_conv", "\n", "self", ".", "dims", "=", "dims", "\n", "if", "use_conv", ":", "\n", "            ", "self", ".", "conv", "=", "conv_nd", "(", "dims", ",", "self", ".", "channels", ",", "self", ".", "out_channels", ",", "3", ",", "padding", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.Upsample.forward": [[100, 111], ["torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "unet.Upsample.conv"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "x", ".", "shape", "[", "1", "]", "==", "self", ".", "channels", "\n", "if", "self", ".", "dims", "==", "3", ":", "\n", "            ", "x", "=", "F", ".", "interpolate", "(", "\n", "x", ",", "(", "x", ".", "shape", "[", "2", "]", ",", "x", ".", "shape", "[", "3", "]", "*", "2", ",", "x", ".", "shape", "[", "4", "]", "*", "2", ")", ",", "mode", "=", "\"nearest\"", "\n", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "F", ".", "interpolate", "(", "x", ",", "scale_factor", "=", "2", ",", "mode", "=", "\"nearest\"", ")", "\n", "", "if", "self", ".", "use_conv", ":", "\n", "            ", "x", "=", "self", ".", "conv", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.Downsample.__init__": [[123, 137], ["torch.Module.__init__", "torch.conv_nd", "torch.avg_pool_nd"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.conv_nd", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.avg_pool_nd"], ["def", "__init__", "(", "self", ",", "channels", ",", "use_conv", ",", "dims", "=", "2", ",", "out_channels", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "channels", "=", "channels", "\n", "self", ".", "out_channels", "=", "out_channels", "or", "channels", "\n", "self", ".", "use_conv", "=", "use_conv", "\n", "self", ".", "dims", "=", "dims", "\n", "stride", "=", "2", "if", "dims", "!=", "3", "else", "(", "1", ",", "2", ",", "2", ")", "\n", "if", "use_conv", ":", "\n", "            ", "self", ".", "op", "=", "conv_nd", "(", "\n", "dims", ",", "self", ".", "channels", ",", "self", ".", "out_channels", ",", "3", ",", "stride", "=", "stride", ",", "padding", "=", "1", "\n", ")", "\n", "", "else", ":", "\n", "            ", "assert", "self", ".", "channels", "==", "self", ".", "out_channels", "\n", "self", ".", "op", "=", "avg_pool_nd", "(", "dims", ",", "kernel_size", "=", "stride", ",", "stride", "=", "stride", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.Downsample.forward": [[138, 141], ["unet.Downsample.op"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "x", ".", "shape", "[", "1", "]", "==", "self", ".", "channels", "\n", "return", "self", ".", "op", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.ResBlock.__init__": [[160, 223], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.normalization", "torch.SiLU", "torch.SiLU", "torch.SiLU", "torch.conv_nd", "unet.Upsample", "unet.Upsample", "torch.SiLU", "torch.SiLU", "torch.SiLU", "torch.linear", "torch.normalization", "torch.SiLU", "torch.SiLU", "torch.SiLU", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.zero_module", "torch.Identity", "torch.Identity", "torch.Identity", "unet.Downsample", "unet.Downsample", "torch.Identity", "torch.Identity", "torch.Identity", "torch.conv_nd", "torch.conv_nd", "torch.conv_nd"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.normalization", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.conv_nd", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.linear", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.normalization", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.zero_module", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.conv_nd", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.conv_nd", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.conv_nd"], ["def", "__init__", "(", "\n", "self", ",", "\n", "channels", ",", "\n", "emb_channels", ",", "\n", "dropout", ",", "\n", "out_channels", "=", "None", ",", "\n", "use_conv", "=", "False", ",", "\n", "use_scale_shift_norm", "=", "False", ",", "\n", "dims", "=", "2", ",", "\n", "use_checkpoint", "=", "False", ",", "\n", "up", "=", "False", ",", "\n", "down", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "channels", "=", "channels", "\n", "self", ".", "emb_channels", "=", "emb_channels", "\n", "self", ".", "dropout", "=", "dropout", "\n", "self", ".", "out_channels", "=", "out_channels", "or", "channels", "\n", "self", ".", "use_conv", "=", "use_conv", "\n", "self", ".", "use_checkpoint", "=", "use_checkpoint", "\n", "self", ".", "use_scale_shift_norm", "=", "use_scale_shift_norm", "\n", "\n", "self", ".", "in_layers", "=", "nn", ".", "Sequential", "(", "\n", "normalization", "(", "channels", ")", ",", "\n", "nn", ".", "SiLU", "(", ")", ",", "\n", "conv_nd", "(", "dims", ",", "channels", ",", "self", ".", "out_channels", ",", "3", ",", "padding", "=", "1", ")", ",", "\n", ")", "\n", "\n", "self", ".", "updown", "=", "up", "or", "down", "\n", "\n", "if", "up", ":", "\n", "            ", "self", ".", "h_upd", "=", "Upsample", "(", "channels", ",", "False", ",", "dims", ")", "\n", "self", ".", "x_upd", "=", "Upsample", "(", "channels", ",", "False", ",", "dims", ")", "\n", "", "elif", "down", ":", "\n", "            ", "self", ".", "h_upd", "=", "Downsample", "(", "channels", ",", "False", ",", "dims", ")", "\n", "self", ".", "x_upd", "=", "Downsample", "(", "channels", ",", "False", ",", "dims", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "h_upd", "=", "self", ".", "x_upd", "=", "nn", ".", "Identity", "(", ")", "\n", "\n", "", "self", ".", "emb_layers", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "SiLU", "(", ")", ",", "\n", "linear", "(", "\n", "emb_channels", ",", "\n", "2", "*", "self", ".", "out_channels", "if", "use_scale_shift_norm", "else", "self", ".", "out_channels", ",", "\n", ")", ",", "\n", ")", "\n", "self", ".", "out_layers", "=", "nn", ".", "Sequential", "(", "\n", "normalization", "(", "self", ".", "out_channels", ")", ",", "\n", "nn", ".", "SiLU", "(", ")", ",", "\n", "nn", ".", "Dropout", "(", "p", "=", "dropout", ")", ",", "\n", "zero_module", "(", "\n", "conv_nd", "(", "dims", ",", "self", ".", "out_channels", ",", "self", ".", "out_channels", ",", "3", ",", "padding", "=", "1", ")", "\n", ")", ",", "\n", ")", "\n", "\n", "if", "self", ".", "out_channels", "==", "channels", ":", "\n", "            ", "self", ".", "skip_connection", "=", "nn", ".", "Identity", "(", ")", "\n", "", "elif", "use_conv", ":", "\n", "            ", "self", ".", "skip_connection", "=", "conv_nd", "(", "\n", "dims", ",", "channels", ",", "self", ".", "out_channels", ",", "3", ",", "padding", "=", "1", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "skip_connection", "=", "conv_nd", "(", "dims", ",", "channels", ",", "self", ".", "out_channels", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.ResBlock.forward": [[224, 234], ["torch.checkpoint", "unet.ResBlock.parameters"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.checkpoint"], ["", "", "def", "forward", "(", "self", ",", "x", ",", "emb", ")", ":", "\n", "        ", "\"\"\"\n        Apply the block to a Tensor, conditioned on a timestep embedding.\n\n        :param x: an [N x C x ...] Tensor of features.\n        :param emb: an [N x emb_channels] Tensor of timestep embeddings.\n        :return: an [N x C x ...] Tensor of outputs.\n        \"\"\"", "\n", "return", "checkpoint", "(", "\n", "self", ".", "_forward", ",", "(", "x", ",", "emb", ")", ",", "self", ".", "parameters", "(", ")", ",", "self", ".", "use_checkpoint", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.ResBlock._forward": [[236, 257], ["unet.ResBlock.emb_layers().type", "in_rest", "unet.ResBlock.h_upd", "unet.ResBlock.x_upd", "in_conv", "unet.ResBlock.in_layers", "len", "len", "torch.chunk", "torch.chunk", "torch.chunk", "out_rest", "unet.ResBlock.out_layers", "unet.ResBlock.skip_connection", "unet.ResBlock.emb_layers", "out_norm"], "methods", ["None"], ["", "def", "_forward", "(", "self", ",", "x", ",", "emb", ")", ":", "\n", "        ", "if", "self", ".", "updown", ":", "\n", "            ", "in_rest", ",", "in_conv", "=", "self", ".", "in_layers", "[", ":", "-", "1", "]", ",", "self", ".", "in_layers", "[", "-", "1", "]", "\n", "h", "=", "in_rest", "(", "x", ")", "\n", "h", "=", "self", ".", "h_upd", "(", "h", ")", "\n", "x", "=", "self", ".", "x_upd", "(", "x", ")", "\n", "h", "=", "in_conv", "(", "h", ")", "\n", "", "else", ":", "\n", "            ", "h", "=", "self", ".", "in_layers", "(", "x", ")", "\n", "", "emb_out", "=", "self", ".", "emb_layers", "(", "emb", ")", ".", "type", "(", "h", ".", "dtype", ")", "\n", "while", "len", "(", "emb_out", ".", "shape", ")", "<", "len", "(", "h", ".", "shape", ")", ":", "\n", "            ", "emb_out", "=", "emb_out", "[", "...", ",", "None", "]", "\n", "", "if", "self", ".", "use_scale_shift_norm", ":", "\n", "            ", "out_norm", ",", "out_rest", "=", "self", ".", "out_layers", "[", "0", "]", ",", "self", ".", "out_layers", "[", "1", ":", "]", "\n", "scale", ",", "shift", "=", "th", ".", "chunk", "(", "emb_out", ",", "2", ",", "dim", "=", "1", ")", "\n", "h", "=", "out_norm", "(", "h", ")", "*", "(", "1", "+", "scale", ")", "+", "shift", "\n", "h", "=", "out_rest", "(", "h", ")", "\n", "", "else", ":", "\n", "            ", "h", "=", "h", "+", "emb_out", "\n", "h", "=", "self", ".", "out_layers", "(", "h", ")", "\n", "", "return", "self", ".", "skip_connection", "(", "x", ")", "+", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.AttentionBlock.__init__": [[267, 295], ["torch.Module.__init__", "torch.normalization", "torch.conv_nd", "torch.zero_module", "unet.QKVAttention", "unet.QKVAttentionLegacy", "torch.conv_nd"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.normalization", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.conv_nd", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.zero_module", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.conv_nd"], ["def", "__init__", "(", "\n", "self", ",", "\n", "channels", ",", "\n", "num_heads", "=", "1", ",", "\n", "num_head_channels", "=", "-", "1", ",", "\n", "use_checkpoint", "=", "False", ",", "\n", "use_new_attention_order", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "channels", "=", "channels", "\n", "if", "num_head_channels", "==", "-", "1", ":", "\n", "            ", "self", ".", "num_heads", "=", "num_heads", "\n", "", "else", ":", "\n", "            ", "assert", "(", "\n", "channels", "%", "num_head_channels", "==", "0", "\n", ")", ",", "f\"q,k,v channels {channels} is not divisible by num_head_channels {num_head_channels}\"", "\n", "self", ".", "num_heads", "=", "channels", "//", "num_head_channels", "\n", "", "self", ".", "use_checkpoint", "=", "use_checkpoint", "\n", "self", ".", "norm", "=", "normalization", "(", "channels", ")", "\n", "self", ".", "qkv", "=", "conv_nd", "(", "1", ",", "channels", ",", "channels", "*", "3", ",", "1", ")", "\n", "if", "use_new_attention_order", ":", "\n", "# split qkv before split heads", "\n", "            ", "self", ".", "attention", "=", "QKVAttention", "(", "self", ".", "num_heads", ")", "\n", "", "else", ":", "\n", "# split heads before split qkv", "\n", "            ", "self", ".", "attention", "=", "QKVAttentionLegacy", "(", "self", ".", "num_heads", ")", "\n", "\n", "", "self", ".", "proj_out", "=", "zero_module", "(", "conv_nd", "(", "1", ",", "channels", ",", "channels", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.AttentionBlock.forward": [[296, 298], ["torch.checkpoint", "unet.AttentionBlock.parameters"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.checkpoint"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "checkpoint", "(", "self", ".", "_forward", ",", "(", "x", ",", ")", ",", "self", ".", "parameters", "(", ")", ",", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.AttentionBlock._forward": [[299, 306], ["x.reshape.reshape.reshape", "unet.AttentionBlock.qkv", "unet.AttentionBlock.attention", "unet.AttentionBlock.proj_out", "unet.AttentionBlock.norm"], "methods", ["None"], ["", "def", "_forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "b", ",", "c", ",", "*", "spatial", "=", "x", ".", "shape", "\n", "x", "=", "x", ".", "reshape", "(", "b", ",", "c", ",", "-", "1", ")", "\n", "qkv", "=", "self", ".", "qkv", "(", "self", ".", "norm", "(", "x", ")", ")", "\n", "h", "=", "self", ".", "attention", "(", "qkv", ")", "\n", "h", "=", "self", ".", "proj_out", "(", "h", ")", "\n", "return", "(", "x", "+", "h", ")", ".", "reshape", "(", "b", ",", "c", ",", "*", "spatial", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.QKVAttentionLegacy.__init__": [[333, 336], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["def", "__init__", "(", "self", ",", "n_heads", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_heads", "=", "n_heads", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.QKVAttentionLegacy.forward": [[337, 355], ["qkv.reshape().split", "torch.einsum", "torch.einsum", "torch.einsum", "torch.softmax().type", "torch.softmax().type", "torch.softmax().type", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum.reshape", "math.sqrt", "qkv.reshape", "math.sqrt", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax().type.float"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "qkv", ")", ":", "\n", "        ", "\"\"\"\n        Apply QKV attention.\n\n        :param qkv: an [N x (H * 3 * C) x T] tensor of Qs, Ks, and Vs.\n        :return: an [N x (H * C) x T] tensor after attention.\n        \"\"\"", "\n", "bs", ",", "width", ",", "length", "=", "qkv", ".", "shape", "\n", "assert", "width", "%", "(", "3", "*", "self", ".", "n_heads", ")", "==", "0", "\n", "ch", "=", "width", "//", "(", "3", "*", "self", ".", "n_heads", ")", "\n", "q", ",", "k", ",", "v", "=", "qkv", ".", "reshape", "(", "bs", "*", "self", ".", "n_heads", ",", "ch", "*", "3", ",", "length", ")", ".", "split", "(", "ch", ",", "dim", "=", "1", ")", "\n", "scale", "=", "1", "/", "math", ".", "sqrt", "(", "math", ".", "sqrt", "(", "ch", ")", ")", "\n", "weight", "=", "th", ".", "einsum", "(", "\n", "\"bct,bcs->bts\"", ",", "q", "*", "scale", ",", "k", "*", "scale", "\n", ")", "# More stable with f16 than dividing afterwards", "\n", "weight", "=", "th", ".", "softmax", "(", "weight", ".", "float", "(", ")", ",", "dim", "=", "-", "1", ")", ".", "type", "(", "weight", ".", "dtype", ")", "\n", "a", "=", "th", ".", "einsum", "(", "\"bts,bcs->bct\"", ",", "weight", ",", "v", ")", "\n", "return", "a", ".", "reshape", "(", "bs", ",", "-", "1", ",", "length", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.QKVAttentionLegacy.count_flops": [[356, 359], ["unet.count_flops_attn"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.count_flops_attn"], ["", "@", "staticmethod", "\n", "def", "count_flops", "(", "model", ",", "_x", ",", "y", ")", ":", "\n", "        ", "return", "count_flops_attn", "(", "model", ",", "_x", ",", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.QKVAttention.__init__": [[366, 369], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["def", "__init__", "(", "self", ",", "n_heads", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_heads", "=", "n_heads", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.QKVAttention.forward": [[370, 390], ["qkv.chunk", "torch.einsum", "torch.einsum", "torch.einsum", "torch.softmax().type", "torch.softmax().type", "torch.softmax().type", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum.reshape", "math.sqrt", "v.reshape", "math.sqrt", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax().type.float"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "qkv", ")", ":", "\n", "        ", "\"\"\"\n        Apply QKV attention.\n\n        :param qkv: an [N x (3 * H * C) x T] tensor of Qs, Ks, and Vs.\n        :return: an [N x (H * C) x T] tensor after attention.\n        \"\"\"", "\n", "bs", ",", "width", ",", "length", "=", "qkv", ".", "shape", "\n", "assert", "width", "%", "(", "3", "*", "self", ".", "n_heads", ")", "==", "0", "\n", "ch", "=", "width", "//", "(", "3", "*", "self", ".", "n_heads", ")", "\n", "q", ",", "k", ",", "v", "=", "qkv", ".", "chunk", "(", "3", ",", "dim", "=", "1", ")", "\n", "scale", "=", "1", "/", "math", ".", "sqrt", "(", "math", ".", "sqrt", "(", "ch", ")", ")", "\n", "weight", "=", "th", ".", "einsum", "(", "\n", "\"bct,bcs->bts\"", ",", "\n", "(", "q", "*", "scale", ")", ".", "view", "(", "bs", "*", "self", ".", "n_heads", ",", "ch", ",", "length", ")", ",", "\n", "(", "k", "*", "scale", ")", ".", "view", "(", "bs", "*", "self", ".", "n_heads", ",", "ch", ",", "length", ")", ",", "\n", ")", "# More stable with f16 than dividing afterwards", "\n", "weight", "=", "th", ".", "softmax", "(", "weight", ".", "float", "(", ")", ",", "dim", "=", "-", "1", ")", ".", "type", "(", "weight", ".", "dtype", ")", "\n", "a", "=", "th", ".", "einsum", "(", "\"bts,bcs->bct\"", ",", "weight", ",", "v", ".", "reshape", "(", "bs", "*", "self", ".", "n_heads", ",", "ch", ",", "length", ")", ")", "\n", "return", "a", ".", "reshape", "(", "bs", ",", "-", "1", ",", "length", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.QKVAttention.count_flops": [[391, 394], ["unet.count_flops_attn"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.count_flops_attn"], ["", "@", "staticmethod", "\n", "def", "count_flops", "(", "model", ",", "_x", ",", "y", ")", ":", "\n", "        ", "return", "count_flops_attn", "(", "model", ",", "_x", ",", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.UNetModel.__init__": [[427, 616], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "int", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "enumerate", "unet.TimestepEmbedSequential", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.linear", "torch.SiLU", "torch.SiLU", "torch.SiLU", "torch.linear", "torch.Embedding", "torch.Embedding", "torch.Embedding", "range", "unet.ResBlock", "unet.AttentionBlock", "unet.ResBlock", "list", "range", "torch.normalization", "torch.SiLU", "torch.SiLU", "torch.SiLU", "torch.zero_module", "unet.TimestepEmbedSequential", "int", "unet.UNetModel.input_blocks.append", "input_block_chans.append", "unet.UNetModel.input_blocks.append", "input_block_chans.append", "enumerate", "input_block_chans.pop", "int", "unet.UNetModel.output_blocks.append", "torch.conv_nd", "torch.conv_nd", "unet.ResBlock", "layers.append", "unet.TimestepEmbedSequential", "len", "unet.TimestepEmbedSequential", "unet.ResBlock", "layers.append", "layers.append", "unet.TimestepEmbedSequential", "unet.AttentionBlock", "unet.AttentionBlock", "int", "unet.ResBlock", "unet.Downsample", "int", "unet.ResBlock", "unet.Upsample"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.linear", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.linear", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.normalization", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.zero_module", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.conv_nd", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.conv_nd"], ["def", "__init__", "(", "\n", "self", ",", "\n", "image_size", ",", "\n", "in_channels", ",", "\n", "model_channels", ",", "\n", "out_channels", ",", "\n", "num_res_blocks", ",", "\n", "attention_resolutions", ",", "\n", "dropout", "=", "0", ",", "\n", "channel_mult", "=", "(", "1", ",", "2", ",", "4", ",", "8", ")", ",", "\n", "conv_resample", "=", "True", ",", "\n", "dims", "=", "2", ",", "\n", "num_classes", "=", "None", ",", "\n", "use_checkpoint", "=", "False", ",", "\n", "use_fp16", "=", "False", ",", "\n", "num_heads", "=", "1", ",", "\n", "num_head_channels", "=", "-", "1", ",", "\n", "num_heads_upsample", "=", "-", "1", ",", "\n", "use_scale_shift_norm", "=", "False", ",", "\n", "resblock_updown", "=", "False", ",", "\n", "use_new_attention_order", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "num_heads_upsample", "==", "-", "1", ":", "\n", "            ", "num_heads_upsample", "=", "num_heads", "\n", "\n", "", "self", ".", "image_size", "=", "image_size", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "model_channels", "=", "model_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "num_res_blocks", "=", "num_res_blocks", "\n", "self", ".", "attention_resolutions", "=", "attention_resolutions", "\n", "self", ".", "dropout", "=", "dropout", "\n", "self", ".", "channel_mult", "=", "channel_mult", "\n", "self", ".", "conv_resample", "=", "conv_resample", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "use_checkpoint", "=", "use_checkpoint", "\n", "self", ".", "dtype", "=", "th", ".", "float16", "if", "use_fp16", "else", "th", ".", "float32", "\n", "self", ".", "num_heads", "=", "num_heads", "\n", "self", ".", "num_head_channels", "=", "num_head_channels", "\n", "self", ".", "num_heads_upsample", "=", "num_heads_upsample", "\n", "\n", "time_embed_dim", "=", "model_channels", "*", "4", "\n", "self", ".", "time_embed", "=", "nn", ".", "Sequential", "(", "\n", "linear", "(", "model_channels", ",", "time_embed_dim", ")", ",", "\n", "nn", ".", "SiLU", "(", ")", ",", "\n", "linear", "(", "time_embed_dim", ",", "time_embed_dim", ")", ",", "\n", ")", "\n", "\n", "if", "self", ".", "num_classes", "is", "not", "None", ":", "\n", "            ", "self", ".", "label_emb", "=", "nn", ".", "Embedding", "(", "num_classes", ",", "time_embed_dim", ")", "\n", "\n", "", "ch", "=", "input_ch", "=", "int", "(", "channel_mult", "[", "0", "]", "*", "model_channels", ")", "\n", "self", ".", "input_blocks", "=", "nn", ".", "ModuleList", "(", "\n", "[", "TimestepEmbedSequential", "(", "conv_nd", "(", "dims", ",", "in_channels", ",", "ch", ",", "3", ",", "padding", "=", "1", ")", ")", "]", "\n", ")", "\n", "self", ".", "_feature_size", "=", "ch", "\n", "input_block_chans", "=", "[", "ch", "]", "\n", "ds", "=", "1", "\n", "for", "level", ",", "mult", "in", "enumerate", "(", "channel_mult", ")", ":", "\n", "            ", "for", "_", "in", "range", "(", "num_res_blocks", ")", ":", "\n", "                ", "layers", "=", "[", "\n", "ResBlock", "(", "\n", "ch", ",", "\n", "time_embed_dim", ",", "\n", "dropout", ",", "\n", "out_channels", "=", "int", "(", "mult", "*", "model_channels", ")", ",", "\n", "dims", "=", "dims", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "use_scale_shift_norm", "=", "use_scale_shift_norm", ",", "\n", ")", "\n", "]", "\n", "ch", "=", "int", "(", "mult", "*", "model_channels", ")", "\n", "if", "ds", "in", "attention_resolutions", ":", "\n", "                    ", "layers", ".", "append", "(", "\n", "AttentionBlock", "(", "\n", "ch", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "num_heads", "=", "num_heads", ",", "\n", "num_head_channels", "=", "num_head_channels", ",", "\n", "use_new_attention_order", "=", "use_new_attention_order", ",", "\n", ")", "\n", ")", "\n", "", "self", ".", "input_blocks", ".", "append", "(", "TimestepEmbedSequential", "(", "*", "layers", ")", ")", "\n", "self", ".", "_feature_size", "+=", "ch", "\n", "input_block_chans", ".", "append", "(", "ch", ")", "\n", "", "if", "level", "!=", "len", "(", "channel_mult", ")", "-", "1", ":", "\n", "                ", "out_ch", "=", "ch", "\n", "self", ".", "input_blocks", ".", "append", "(", "\n", "TimestepEmbedSequential", "(", "\n", "ResBlock", "(", "\n", "ch", ",", "\n", "time_embed_dim", ",", "\n", "dropout", ",", "\n", "out_channels", "=", "out_ch", ",", "\n", "dims", "=", "dims", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "use_scale_shift_norm", "=", "use_scale_shift_norm", ",", "\n", "down", "=", "True", ",", "\n", ")", "\n", "if", "resblock_updown", "\n", "else", "Downsample", "(", "\n", "ch", ",", "conv_resample", ",", "dims", "=", "dims", ",", "out_channels", "=", "out_ch", "\n", ")", "\n", ")", "\n", ")", "\n", "ch", "=", "out_ch", "\n", "input_block_chans", ".", "append", "(", "ch", ")", "\n", "ds", "*=", "2", "\n", "self", ".", "_feature_size", "+=", "ch", "\n", "\n", "", "", "self", ".", "middle_block", "=", "TimestepEmbedSequential", "(", "\n", "ResBlock", "(", "\n", "ch", ",", "\n", "time_embed_dim", ",", "\n", "dropout", ",", "\n", "dims", "=", "dims", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "use_scale_shift_norm", "=", "use_scale_shift_norm", ",", "\n", ")", ",", "\n", "AttentionBlock", "(", "\n", "ch", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "num_heads", "=", "num_heads", ",", "\n", "num_head_channels", "=", "num_head_channels", ",", "\n", "use_new_attention_order", "=", "use_new_attention_order", ",", "\n", ")", ",", "\n", "ResBlock", "(", "\n", "ch", ",", "\n", "time_embed_dim", ",", "\n", "dropout", ",", "\n", "dims", "=", "dims", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "use_scale_shift_norm", "=", "use_scale_shift_norm", ",", "\n", ")", ",", "\n", ")", "\n", "self", ".", "_feature_size", "+=", "ch", "\n", "\n", "self", ".", "output_blocks", "=", "nn", ".", "ModuleList", "(", "[", "]", ")", "\n", "for", "level", ",", "mult", "in", "list", "(", "enumerate", "(", "channel_mult", ")", ")", "[", ":", ":", "-", "1", "]", ":", "\n", "            ", "for", "i", "in", "range", "(", "num_res_blocks", "+", "1", ")", ":", "\n", "                ", "ich", "=", "input_block_chans", ".", "pop", "(", ")", "\n", "layers", "=", "[", "\n", "ResBlock", "(", "\n", "ch", "+", "ich", ",", "\n", "time_embed_dim", ",", "\n", "dropout", ",", "\n", "out_channels", "=", "int", "(", "model_channels", "*", "mult", ")", ",", "\n", "dims", "=", "dims", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "use_scale_shift_norm", "=", "use_scale_shift_norm", ",", "\n", ")", "\n", "]", "\n", "ch", "=", "int", "(", "model_channels", "*", "mult", ")", "\n", "if", "ds", "in", "attention_resolutions", ":", "\n", "                    ", "layers", ".", "append", "(", "\n", "AttentionBlock", "(", "\n", "ch", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "num_heads", "=", "num_heads_upsample", ",", "\n", "num_head_channels", "=", "num_head_channels", ",", "\n", "use_new_attention_order", "=", "use_new_attention_order", ",", "\n", ")", "\n", ")", "\n", "", "if", "level", "and", "i", "==", "num_res_blocks", ":", "\n", "                    ", "out_ch", "=", "ch", "\n", "layers", ".", "append", "(", "\n", "ResBlock", "(", "\n", "ch", ",", "\n", "time_embed_dim", ",", "\n", "dropout", ",", "\n", "out_channels", "=", "out_ch", ",", "\n", "dims", "=", "dims", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "use_scale_shift_norm", "=", "use_scale_shift_norm", ",", "\n", "up", "=", "True", ",", "\n", ")", "\n", "if", "resblock_updown", "\n", "else", "Upsample", "(", "ch", ",", "conv_resample", ",", "dims", "=", "dims", ",", "out_channels", "=", "out_ch", ")", "\n", ")", "\n", "ds", "//=", "2", "\n", "", "self", ".", "output_blocks", ".", "append", "(", "TimestepEmbedSequential", "(", "*", "layers", ")", ")", "\n", "self", ".", "_feature_size", "+=", "ch", "\n", "\n", "", "", "self", ".", "out", "=", "nn", ".", "Sequential", "(", "\n", "normalization", "(", "ch", ")", ",", "\n", "nn", ".", "SiLU", "(", ")", ",", "\n", "zero_module", "(", "conv_nd", "(", "dims", ",", "input_ch", ",", "out_channels", ",", "3", ",", "padding", "=", "1", ")", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.UNetModel.convert_to_fp16": [[618, 625], ["unet.UNetModel.input_blocks.apply", "unet.UNetModel.middle_block.apply", "unet.UNetModel.output_blocks.apply"], "methods", ["None"], ["", "def", "convert_to_fp16", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Convert the torso of the model to float16.\n        \"\"\"", "\n", "self", ".", "input_blocks", ".", "apply", "(", "convert_module_to_f16", ")", "\n", "self", ".", "middle_block", ".", "apply", "(", "convert_module_to_f16", ")", "\n", "self", ".", "output_blocks", ".", "apply", "(", "convert_module_to_f16", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.UNetModel.convert_to_fp32": [[626, 633], ["unet.UNetModel.input_blocks.apply", "unet.UNetModel.middle_block.apply", "unet.UNetModel.output_blocks.apply"], "methods", ["None"], ["", "def", "convert_to_fp32", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Convert the torso of the model to float32.\n        \"\"\"", "\n", "self", ".", "input_blocks", ".", "apply", "(", "convert_module_to_f32", ")", "\n", "self", ".", "middle_block", ".", "apply", "(", "convert_module_to_f32", ")", "\n", "self", ".", "output_blocks", ".", "apply", "(", "convert_module_to_f32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.UNetModel.forward": [[634, 665], ["unet.UNetModel.time_embed", "x.type", "unet.UNetModel.middle_block", "module.type", "unet.UNetModel.out", "torch.timestep_embedding", "module", "hs.append", "torch.cat", "torch.cat", "torch.cat", "module", "unet.UNetModel.label_emb", "hs.pop"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.timestep_embedding"], ["", "def", "forward", "(", "self", ",", "x", ",", "timesteps", ",", "y", "=", "None", ",", "ref_img", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Apply the model to an input batch.\n\n        :param x: an [N x C x ...] Tensor of inputs.\n        :param timesteps: a 1-D batch of timesteps.\n        :param y: an [N] Tensor of labels, if class-conditional.\n        :return: an [N x C x ...] Tensor of outputs.\n        \"\"\"", "\n", "\n", "assert", "(", "y", "is", "not", "None", ")", "==", "(", "\n", "self", ".", "num_classes", "is", "not", "None", "\n", ")", ",", "\"must specify y if and only if the model is class-conditional\"", "\n", "\n", "hs", "=", "[", "]", "\n", "emb", "=", "self", ".", "time_embed", "(", "timestep_embedding", "(", "timesteps", ",", "self", ".", "model_channels", ")", ")", "\n", "\n", "if", "self", ".", "num_classes", "is", "not", "None", ":", "\n", "            ", "assert", "y", ".", "shape", "==", "(", "x", ".", "shape", "[", "0", "]", ",", ")", "\n", "emb", "=", "emb", "+", "self", ".", "label_emb", "(", "y", ")", "\n", "\n", "", "h", "=", "x", ".", "type", "(", "self", ".", "dtype", ")", "\n", "for", "module", "in", "self", ".", "input_blocks", ":", "\n", "            ", "h", "=", "module", "(", "h", ",", "emb", ")", "\n", "hs", ".", "append", "(", "h", ")", "\n", "", "h", "=", "self", ".", "middle_block", "(", "h", ",", "emb", ")", "\n", "for", "module", "in", "self", ".", "output_blocks", ":", "\n", "            ", "h", "=", "th", ".", "cat", "(", "[", "h", ",", "hs", ".", "pop", "(", ")", "]", ",", "dim", "=", "1", ")", "\n", "h", "=", "module", "(", "h", ",", "emb", ")", "\n", "", "h", "=", "h", ".", "type", "(", "x", ".", "dtype", ")", "\n", "return", "self", ".", "out", "(", "h", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.SuperResModel.__init__": [[674, 676], ["unet.UNetModel.__init__"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["def", "__init__", "(", "self", ",", "image_size", ",", "in_channels", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "image_size", ",", "in_channels", "*", "2", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.SuperResModel.forward": [[677, 682], ["torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.cat", "torch.cat", "torch.cat", "unet.UNetModel.forward"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.forward"], ["", "def", "forward", "(", "self", ",", "x", ",", "timesteps", ",", "low_res", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "_", ",", "_", ",", "new_height", ",", "new_width", "=", "x", ".", "shape", "\n", "upsampled", "=", "F", ".", "interpolate", "(", "low_res", ",", "(", "new_height", ",", "new_width", ")", ",", "mode", "=", "\"bilinear\"", ")", "\n", "x", "=", "th", ".", "cat", "(", "[", "x", ",", "upsampled", "]", ",", "dim", "=", "1", ")", "\n", "return", "super", "(", ")", ".", "forward", "(", "x", ",", "timesteps", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.EncoderUNetModel.__init__": [[691, 857], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "int", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "enumerate", "unet.TimestepEmbedSequential", "torch.linear", "torch.SiLU", "torch.SiLU", "torch.SiLU", "torch.linear", "range", "unet.ResBlock", "unet.AttentionBlock", "unet.ResBlock", "torch.Sequential", "torch.Sequential", "torch.Sequential", "unet.TimestepEmbedSequential", "int", "unet.EncoderUNetModel.input_blocks.append", "input_block_chans.append", "unet.EncoderUNetModel.input_blocks.append", "input_block_chans.append", "torch.normalization", "torch.SiLU", "torch.SiLU", "torch.SiLU", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.zero_module", "torch.Flatten", "torch.Flatten", "torch.Flatten", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.conv_nd", "unet.ResBlock", "layers.append", "unet.TimestepEmbedSequential", "len", "unet.TimestepEmbedSequential", "torch.conv_nd", "torch.normalization", "torch.SiLU", "torch.SiLU", "torch.SiLU", "unet.AttentionPool2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "unet.AttentionBlock", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Sequential", "torch.Sequential", "torch.Sequential", "NotImplementedError", "int", "unet.ResBlock", "unet.Downsample", "torch.Linear", "torch.Linear", "torch.Linear", "torch.normalization", "torch.SiLU", "torch.SiLU", "torch.SiLU", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.linear", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.linear", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.normalization", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.zero_module", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.conv_nd", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.conv_nd", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.normalization", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.normalization"], ["def", "__init__", "(", "\n", "self", ",", "\n", "image_size", ",", "\n", "in_channels", ",", "\n", "model_channels", ",", "\n", "out_channels", ",", "\n", "num_res_blocks", ",", "\n", "attention_resolutions", ",", "\n", "dropout", "=", "0", ",", "\n", "channel_mult", "=", "(", "1", ",", "2", ",", "4", ",", "8", ")", ",", "\n", "conv_resample", "=", "True", ",", "\n", "dims", "=", "2", ",", "\n", "use_checkpoint", "=", "False", ",", "\n", "use_fp16", "=", "False", ",", "\n", "num_heads", "=", "1", ",", "\n", "num_head_channels", "=", "-", "1", ",", "\n", "num_heads_upsample", "=", "-", "1", ",", "\n", "use_scale_shift_norm", "=", "False", ",", "\n", "resblock_updown", "=", "False", ",", "\n", "use_new_attention_order", "=", "False", ",", "\n", "pool", "=", "\"adaptive\"", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "num_heads_upsample", "==", "-", "1", ":", "\n", "            ", "num_heads_upsample", "=", "num_heads", "\n", "\n", "", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "model_channels", "=", "model_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "num_res_blocks", "=", "num_res_blocks", "\n", "self", ".", "attention_resolutions", "=", "attention_resolutions", "\n", "self", ".", "dropout", "=", "dropout", "\n", "self", ".", "channel_mult", "=", "channel_mult", "\n", "self", ".", "conv_resample", "=", "conv_resample", "\n", "self", ".", "use_checkpoint", "=", "use_checkpoint", "\n", "self", ".", "dtype", "=", "th", ".", "float16", "if", "use_fp16", "else", "th", ".", "float32", "\n", "self", ".", "num_heads", "=", "num_heads", "\n", "self", ".", "num_head_channels", "=", "num_head_channels", "\n", "self", ".", "num_heads_upsample", "=", "num_heads_upsample", "\n", "\n", "time_embed_dim", "=", "model_channels", "*", "4", "\n", "self", ".", "time_embed", "=", "nn", ".", "Sequential", "(", "\n", "linear", "(", "model_channels", ",", "time_embed_dim", ")", ",", "\n", "nn", ".", "SiLU", "(", ")", ",", "\n", "linear", "(", "time_embed_dim", ",", "time_embed_dim", ")", ",", "\n", ")", "\n", "\n", "ch", "=", "int", "(", "channel_mult", "[", "0", "]", "*", "model_channels", ")", "\n", "self", ".", "input_blocks", "=", "nn", ".", "ModuleList", "(", "\n", "[", "TimestepEmbedSequential", "(", "conv_nd", "(", "dims", ",", "in_channels", ",", "ch", ",", "3", ",", "padding", "=", "1", ")", ")", "]", "\n", ")", "\n", "self", ".", "_feature_size", "=", "ch", "\n", "input_block_chans", "=", "[", "ch", "]", "\n", "ds", "=", "1", "\n", "for", "level", ",", "mult", "in", "enumerate", "(", "channel_mult", ")", ":", "\n", "            ", "for", "_", "in", "range", "(", "num_res_blocks", ")", ":", "\n", "                ", "layers", "=", "[", "\n", "ResBlock", "(", "\n", "ch", ",", "\n", "time_embed_dim", ",", "\n", "dropout", ",", "\n", "out_channels", "=", "int", "(", "mult", "*", "model_channels", ")", ",", "\n", "dims", "=", "dims", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "use_scale_shift_norm", "=", "use_scale_shift_norm", ",", "\n", ")", "\n", "]", "\n", "ch", "=", "int", "(", "mult", "*", "model_channels", ")", "\n", "if", "ds", "in", "attention_resolutions", ":", "\n", "                    ", "layers", ".", "append", "(", "\n", "AttentionBlock", "(", "\n", "ch", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "num_heads", "=", "num_heads", ",", "\n", "num_head_channels", "=", "num_head_channels", ",", "\n", "use_new_attention_order", "=", "use_new_attention_order", ",", "\n", ")", "\n", ")", "\n", "", "self", ".", "input_blocks", ".", "append", "(", "TimestepEmbedSequential", "(", "*", "layers", ")", ")", "\n", "self", ".", "_feature_size", "+=", "ch", "\n", "input_block_chans", ".", "append", "(", "ch", ")", "\n", "", "if", "level", "!=", "len", "(", "channel_mult", ")", "-", "1", ":", "\n", "                ", "out_ch", "=", "ch", "\n", "self", ".", "input_blocks", ".", "append", "(", "\n", "TimestepEmbedSequential", "(", "\n", "ResBlock", "(", "\n", "ch", ",", "\n", "time_embed_dim", ",", "\n", "dropout", ",", "\n", "out_channels", "=", "out_ch", ",", "\n", "dims", "=", "dims", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "use_scale_shift_norm", "=", "use_scale_shift_norm", ",", "\n", "down", "=", "True", ",", "\n", ")", "\n", "if", "resblock_updown", "\n", "else", "Downsample", "(", "\n", "ch", ",", "conv_resample", ",", "dims", "=", "dims", ",", "out_channels", "=", "out_ch", "\n", ")", "\n", ")", "\n", ")", "\n", "ch", "=", "out_ch", "\n", "input_block_chans", ".", "append", "(", "ch", ")", "\n", "ds", "*=", "2", "\n", "self", ".", "_feature_size", "+=", "ch", "\n", "\n", "", "", "self", ".", "middle_block", "=", "TimestepEmbedSequential", "(", "\n", "ResBlock", "(", "\n", "ch", ",", "\n", "time_embed_dim", ",", "\n", "dropout", ",", "\n", "dims", "=", "dims", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "use_scale_shift_norm", "=", "use_scale_shift_norm", ",", "\n", ")", ",", "\n", "AttentionBlock", "(", "\n", "ch", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "num_heads", "=", "num_heads", ",", "\n", "num_head_channels", "=", "num_head_channels", ",", "\n", "use_new_attention_order", "=", "use_new_attention_order", ",", "\n", ")", ",", "\n", "ResBlock", "(", "\n", "ch", ",", "\n", "time_embed_dim", ",", "\n", "dropout", ",", "\n", "dims", "=", "dims", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "use_scale_shift_norm", "=", "use_scale_shift_norm", ",", "\n", ")", ",", "\n", ")", "\n", "self", ".", "_feature_size", "+=", "ch", "\n", "self", ".", "pool", "=", "pool", "\n", "if", "pool", "==", "\"adaptive\"", ":", "\n", "            ", "self", ".", "out", "=", "nn", ".", "Sequential", "(", "\n", "normalization", "(", "ch", ")", ",", "\n", "nn", ".", "SiLU", "(", ")", ",", "\n", "nn", ".", "AdaptiveAvgPool2d", "(", "(", "1", ",", "1", ")", ")", ",", "\n", "zero_module", "(", "conv_nd", "(", "dims", ",", "ch", ",", "out_channels", ",", "1", ")", ")", ",", "\n", "nn", ".", "Flatten", "(", ")", ",", "\n", ")", "\n", "", "elif", "pool", "==", "\"attention\"", ":", "\n", "            ", "assert", "num_head_channels", "!=", "-", "1", "\n", "self", ".", "out", "=", "nn", ".", "Sequential", "(", "\n", "normalization", "(", "ch", ")", ",", "\n", "nn", ".", "SiLU", "(", ")", ",", "\n", "AttentionPool2d", "(", "\n", "(", "image_size", "//", "ds", ")", ",", "ch", ",", "num_head_channels", ",", "out_channels", "\n", ")", ",", "\n", ")", "\n", "", "elif", "pool", "==", "\"spatial\"", ":", "\n", "            ", "self", ".", "out", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "self", ".", "_feature_size", ",", "2048", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Linear", "(", "2048", ",", "self", ".", "out_channels", ")", ",", "\n", ")", "\n", "", "elif", "pool", "==", "\"spatial_v2\"", ":", "\n", "            ", "self", ".", "out", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "self", ".", "_feature_size", ",", "2048", ")", ",", "\n", "normalization", "(", "2048", ")", ",", "\n", "nn", ".", "SiLU", "(", ")", ",", "\n", "nn", ".", "Linear", "(", "2048", ",", "self", ".", "out_channels", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "f\"Unexpected {pool} pooling\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.EncoderUNetModel.convert_to_fp16": [[858, 864], ["unet.EncoderUNetModel.input_blocks.apply", "unet.EncoderUNetModel.middle_block.apply"], "methods", ["None"], ["", "", "def", "convert_to_fp16", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Convert the torso of the model to float16.\n        \"\"\"", "\n", "self", ".", "input_blocks", ".", "apply", "(", "convert_module_to_f16", ")", "\n", "self", ".", "middle_block", ".", "apply", "(", "convert_module_to_f16", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.EncoderUNetModel.convert_to_fp32": [[865, 871], ["unet.EncoderUNetModel.input_blocks.apply", "unet.EncoderUNetModel.middle_block.apply"], "methods", ["None"], ["", "def", "convert_to_fp32", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Convert the torso of the model to float32.\n        \"\"\"", "\n", "self", ".", "input_blocks", ".", "apply", "(", "convert_module_to_f32", ")", "\n", "self", ".", "middle_block", ".", "apply", "(", "convert_module_to_f32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.EncoderUNetModel.forward": [[872, 896], ["unet.EncoderUNetModel.time_embed", "x.type", "unet.EncoderUNetModel.middle_block", "unet.EncoderUNetModel.pool.startswith", "torch.timestep_embedding", "module", "unet.EncoderUNetModel.pool.startswith", "results.append", "torch.cat", "torch.cat", "torch.cat", "unet.EncoderUNetModel.out", "h.type.type.type", "unet.EncoderUNetModel.out", "results.append", "h.type.type.type().mean", "h.type.type.type().mean", "h.type.type.type", "h.type.type.type"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.timestep_embedding"], ["", "def", "forward", "(", "self", ",", "x", ",", "timesteps", ")", ":", "\n", "        ", "\"\"\"\n        Apply the model to an input batch.\n\n        :param x: an [N x C x ...] Tensor of inputs.\n        :param timesteps: a 1-D batch of timesteps.\n        :return: an [N x K] Tensor of outputs.\n        \"\"\"", "\n", "emb", "=", "self", ".", "time_embed", "(", "timestep_embedding", "(", "timesteps", ",", "self", ".", "model_channels", ")", ")", "\n", "\n", "results", "=", "[", "]", "\n", "h", "=", "x", ".", "type", "(", "self", ".", "dtype", ")", "\n", "for", "module", "in", "self", ".", "input_blocks", ":", "\n", "            ", "h", "=", "module", "(", "h", ",", "emb", ")", "\n", "if", "self", ".", "pool", ".", "startswith", "(", "\"spatial\"", ")", ":", "\n", "                ", "results", ".", "append", "(", "h", ".", "type", "(", "x", ".", "dtype", ")", ".", "mean", "(", "dim", "=", "(", "2", ",", "3", ")", ")", ")", "\n", "", "", "h", "=", "self", ".", "middle_block", "(", "h", ",", "emb", ")", "\n", "if", "self", ".", "pool", ".", "startswith", "(", "\"spatial\"", ")", ":", "\n", "            ", "results", ".", "append", "(", "h", ".", "type", "(", "x", ".", "dtype", ")", ".", "mean", "(", "dim", "=", "(", "2", ",", "3", ")", ")", ")", "\n", "h", "=", "th", ".", "cat", "(", "results", ",", "axis", "=", "-", "1", ")", "\n", "return", "self", ".", "out", "(", "h", ")", "\n", "", "else", ":", "\n", "            ", "h", "=", "h", ".", "type", "(", "x", ".", "dtype", ")", "\n", "return", "self", ".", "out", "(", "h", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.count_flops_attn": [[308, 326], ["int", "torch.DoubleTensor", "numpy.prod"], "function", ["None"], ["", "", "def", "count_flops_attn", "(", "model", ",", "_x", ",", "y", ")", ":", "\n", "    ", "\"\"\"\n    A counter for the `thop` package to count the operations in an\n    attention operation.\n    Meant to be used like:\n        macs, params = thop.profile(\n            model,\n            inputs=(inputs, timestamps),\n            custom_ops={QKVAttention: QKVAttention.count_flops},\n        )\n    \"\"\"", "\n", "b", ",", "c", ",", "*", "spatial", "=", "y", "[", "0", "]", ".", "shape", "\n", "num_spatial", "=", "int", "(", "np", ".", "prod", "(", "spatial", ")", ")", "\n", "# We perform two matmuls with the same number of ops.", "\n", "# The first computes the weight matrix, the second computes", "\n", "# the combination of the value vectors.", "\n", "matmul_ops", "=", "2", "*", "b", "*", "(", "num_spatial", "**", "2", ")", "*", "c", "\n", "model", ".", "total_ops", "+=", "th", ".", "DoubleTensor", "(", "[", "matmul_ops", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.TrainLoop.__init__": [[23, 113], ["torch.cuda.is_available", "torch.cuda.is_available", "train_util.TrainLoop._load_and_sync_parameters", "fp16_util.MixedPrecisionTrainer", "torch.optim.AdamW", "torch.optim.AdamW", "isinstance", "resample.UniformSampler", "dist_util.dev", "train_util.TrainLoop._load_optimizer_state", "torch.cuda.is_available", "torch.cuda.is_available", "torch.nn.parallel.distributed.DistributedDataParallel", "torch.nn.parallel.distributed.DistributedDataParallel", "float", "torch.get_world_size", "torch.get_world_size", "train_util.TrainLoop._load_ema_parameters", "copy.deepcopy", "logger.warn", "ema_rate.split", "range", "torch.get_world_size", "torch.get_world_size", "len"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.TrainLoop._load_and_sync_parameters", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.dist_util.dev", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.TrainLoop._load_optimizer_state", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.TrainLoop._load_ema_parameters", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.warn"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "*", ",", "\n", "model", ",", "\n", "diffusion", ",", "\n", "data", ",", "\n", "batch_size", ",", "\n", "microbatch", ",", "\n", "lr", ",", "\n", "ema_rate", ",", "\n", "log_interval", ",", "\n", "save_interval", ",", "\n", "resume_checkpoint", ",", "\n", "use_fp16", "=", "False", ",", "\n", "fp16_scale_growth", "=", "1e-3", ",", "\n", "schedule_sampler", "=", "None", ",", "\n", "weight_decay", "=", "0.0", ",", "\n", "lr_anneal_steps", "=", "0", ",", "\n", "distributed", "=", "False", ",", "\n", "device", "=", "None", ",", "\n", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "diffusion", "=", "diffusion", "\n", "self", ".", "data", "=", "data", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "microbatch", "=", "microbatch", "if", "microbatch", ">", "0", "else", "batch_size", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "ema_rate", "=", "(", "\n", "[", "ema_rate", "]", "\n", "if", "isinstance", "(", "ema_rate", ",", "float", ")", "\n", "else", "[", "float", "(", "x", ")", "for", "x", "in", "ema_rate", ".", "split", "(", "\",\"", ")", "]", "\n", ")", "\n", "self", ".", "log_interval", "=", "log_interval", "\n", "self", ".", "save_interval", "=", "save_interval", "\n", "self", ".", "resume_checkpoint", "=", "resume_checkpoint", "\n", "self", ".", "use_fp16", "=", "use_fp16", "\n", "self", ".", "fp16_scale_growth", "=", "fp16_scale_growth", "\n", "self", ".", "schedule_sampler", "=", "schedule_sampler", "or", "UniformSampler", "(", "diffusion", ")", "\n", "self", ".", "weight_decay", "=", "weight_decay", "\n", "self", ".", "lr_anneal_steps", "=", "lr_anneal_steps", "\n", "self", ".", "distriubted", "=", "distributed", "\n", "\n", "self", ".", "step", "=", "0", "\n", "self", ".", "resume_step", "=", "0", "\n", "self", ".", "global_batch", "=", "self", ".", "batch_size", "*", "dist", ".", "get_world_size", "(", ")", "if", "distributed", "else", "self", ".", "batch_size", "\n", "self", ".", "device", "=", "dist_util", ".", "dev", "(", ")", "if", "distributed", "else", "device", "\n", "\n", "self", ".", "sync_cuda", "=", "th", ".", "cuda", ".", "is_available", "(", ")", "\n", "\n", "self", ".", "_load_and_sync_parameters", "(", ")", "\n", "self", ".", "mp_trainer", "=", "MixedPrecisionTrainer", "(", "\n", "model", "=", "self", ".", "model", ",", "\n", "use_fp16", "=", "self", ".", "use_fp16", ",", "\n", "fp16_scale_growth", "=", "fp16_scale_growth", ",", "\n", ")", "\n", "\n", "self", ".", "opt", "=", "AdamW", "(", "\n", "self", ".", "mp_trainer", ".", "master_params", ",", "lr", "=", "self", ".", "lr", ",", "weight_decay", "=", "self", ".", "weight_decay", "\n", ")", "\n", "if", "self", ".", "resume_step", ":", "\n", "            ", "self", ".", "_load_optimizer_state", "(", ")", "\n", "# Model was resumed, either due to a restart or a checkpoint", "\n", "# being specified at the command line.", "\n", "self", ".", "ema_params", "=", "[", "\n", "self", ".", "_load_ema_parameters", "(", "rate", ")", "for", "rate", "in", "self", ".", "ema_rate", "\n", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "ema_params", "=", "[", "\n", "copy", ".", "deepcopy", "(", "self", ".", "mp_trainer", ".", "master_params", ")", "\n", "for", "_", "in", "range", "(", "len", "(", "self", ".", "ema_rate", ")", ")", "\n", "]", "\n", "\n", "", "if", "distributed", "and", "th", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "self", ".", "use_ddp", "=", "True", "\n", "self", ".", "ddp_model", "=", "DDP", "(", "\n", "self", ".", "model", ",", "\n", "device_ids", "=", "[", "self", ".", "device", "]", ",", "\n", "output_device", "=", "self", ".", "device", ",", "\n", "broadcast_buffers", "=", "False", ",", "\n", "bucket_cap_mb", "=", "128", ",", "\n", "find_unused_parameters", "=", "False", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "if", "distributed", "and", "dist", ".", "get_world_size", "(", ")", ">", "1", ":", "\n", "                ", "logger", ".", "warn", "(", "\n", "\"Distributed training requires CUDA. \"", "\n", "\"Gradients will not be synchronized properly!\"", "\n", ")", "\n", "", "self", ".", "use_ddp", "=", "False", "\n", "self", ".", "ddp_model", "=", "self", ".", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.TrainLoop._load_and_sync_parameters": [[114, 133], ["train_util.find_resume_checkpoint", "train_util.parse_resume_step_from_filename", "dist_util.sync_params", "logger.log", "train_util.TrainLoop.model.load_state_dict", "torch.get_rank", "torch.get_rank", "logger.log", "train_util.TrainLoop.model.load_state_dict", "train_util.TrainLoop.model.parameters", "torch.load", "torch.load", "dist_util.load_state_dict"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.find_resume_checkpoint", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.parse_resume_step_from_filename", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.dist_util.sync_params", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.dist_util.load_state_dict", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.dist_util.load_state_dict", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.load", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.load", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.dist_util.load_state_dict"], ["", "", "def", "_load_and_sync_parameters", "(", "self", ")", ":", "\n", "        ", "resume_checkpoint", "=", "find_resume_checkpoint", "(", ")", "or", "self", ".", "resume_checkpoint", "\n", "\n", "if", "resume_checkpoint", ":", "\n", "            ", "self", ".", "resume_step", "=", "parse_resume_step_from_filename", "(", "resume_checkpoint", ")", "\n", "if", "self", ".", "distributed", ":", "\n", "                ", "if", "dist", ".", "get_rank", "(", ")", "==", "0", ":", "\n", "                    ", "logger", ".", "log", "(", "f\"loading model from checkpoint: {resume_checkpoint}...\"", ")", "\n", "self", ".", "model", ".", "load_state_dict", "(", "\n", "dist_util", ".", "load_state_dict", "(", "\n", "resume_checkpoint", ",", "map_location", "=", "self", ".", "device", "\n", ")", "\n", ")", "\n", "", "dist_util", ".", "sync_params", "(", "self", ".", "model", ".", "parameters", "(", ")", ")", "\n", "", "else", ":", "\n", "                ", "logger", ".", "log", "(", "f\"loading model from checkpoint: {resume_checkpoint}...\"", ")", "\n", "self", ".", "model", ".", "load_state_dict", "(", "\n", "th", ".", "load", "(", "\n", "resume_checkpoint", ",", "map_location", "=", "self", ".", "device", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.TrainLoop._load_ema_parameters": [[137, 159], ["copy.deepcopy", "train_util.find_ema_checkpoint", "train_util.find_resume_checkpoint", "dist_util.sync_params", "logger.log", "torch.load", "torch.load", "train_util.TrainLoop.mp_trainer.state_dict_to_master_params", "torch.get_rank", "torch.get_rank", "logger.log", "dist_util.load_state_dict", "train_util.TrainLoop.mp_trainer.state_dict_to_master_params"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.find_ema_checkpoint", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.find_resume_checkpoint", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.dist_util.sync_params", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.load", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.load", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.state_dict_to_master_params", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.dist_util.load_state_dict", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.state_dict_to_master_params"], ["", "", "", "def", "_load_ema_parameters", "(", "self", ",", "rate", ")", ":", "\n", "        ", "ema_params", "=", "copy", ".", "deepcopy", "(", "self", ".", "mp_trainer", ".", "master_params", ")", "\n", "\n", "main_checkpoint", "=", "find_resume_checkpoint", "(", ")", "or", "self", ".", "resume_checkpoint", "\n", "ema_checkpoint", "=", "find_ema_checkpoint", "(", "main_checkpoint", ",", "self", ".", "resume_step", ",", "rate", ")", "\n", "if", "ema_checkpoint", ":", "\n", "            ", "if", "self", ".", "distributed", ":", "\n", "                ", "if", "dist", ".", "get_rank", "(", ")", "==", "0", ":", "\n", "                    ", "logger", ".", "log", "(", "f\"loading EMA from checkpoint: {ema_checkpoint}...\"", ")", "\n", "state_dict", "=", "dist_util", ".", "load_state_dict", "(", "\n", "ema_checkpoint", ",", "map_location", "=", "self", ".", "device", "\n", ")", "\n", "ema_params", "=", "self", ".", "mp_trainer", ".", "state_dict_to_master_params", "(", "state_dict", ")", "\n", "", "dist_util", ".", "sync_params", "(", "ema_params", ")", "\n", "", "else", ":", "\n", "                ", "logger", ".", "log", "(", "f\"loading EMA from checkpoint: {ema_checkpoint}...\"", ")", "\n", "state_dict", "=", "th", ".", "load", "(", "\n", "ema_checkpoint", ",", "map_location", "=", "self", ".", "device", "\n", ")", "\n", "ema_params", "=", "self", ".", "mp_trainer", ".", "state_dict_to_master_params", "(", "state_dict", ")", "\n", "\n", "", "", "return", "ema_params", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.TrainLoop._load_optimizer_state": [[160, 176], ["blobfile.join", "blobfile.exists", "train_util.find_resume_checkpoint", "blobfile.dirname", "logger.log", "train_util.TrainLoop.opt.load_state_dict", "dist_util.load_state_dict", "torch.load", "torch.load"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.find_resume_checkpoint", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.dist_util.load_state_dict", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.dist_util.load_state_dict", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.load", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.load"], ["", "def", "_load_optimizer_state", "(", "self", ")", ":", "\n", "        ", "main_checkpoint", "=", "find_resume_checkpoint", "(", ")", "or", "self", ".", "resume_checkpoint", "\n", "opt_checkpoint", "=", "bf", ".", "join", "(", "\n", "bf", ".", "dirname", "(", "main_checkpoint", ")", ",", "f\"opt{self.resume_step:06}.pt\"", "\n", ")", "\n", "if", "bf", ".", "exists", "(", "opt_checkpoint", ")", ":", "\n", "            ", "logger", ".", "log", "(", "f\"loading optimizer state from checkpoint: {opt_checkpoint}\"", ")", "\n", "if", "self", ".", "distriubted", ":", "\n", "                ", "state_dict", "=", "dist_util", ".", "load_state_dict", "(", "\n", "opt_checkpoint", ",", "map_location", "=", "self", ".", "device", "\n", ")", "\n", "", "else", ":", "\n", "                ", "state_dict", "=", "th", ".", "load", "(", "\n", "opt_checkpoint", ",", "map_location", "=", "self", ".", "device", "\n", ")", "\n", "", "self", ".", "opt", ".", "load_state_dict", "(", "state_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.TrainLoop.run_loop": [[177, 195], ["next", "train_util.TrainLoop.run_step", "train_util.TrainLoop.save", "logger.dumpkvs", "train_util.TrainLoop.save", "os.environ.get"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.TrainLoop.run_step", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.save", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.dumpkvs", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.save", "home.repos.pwc.inspect_result.ailon-island_facke.insightface_func.face_detect_crop_single.Face_detect_crop.get"], ["", "", "def", "run_loop", "(", "self", ")", ":", "\n", "        ", "while", "(", "\n", "not", "self", ".", "lr_anneal_steps", "\n", "or", "self", ".", "step", "+", "self", ".", "resume_step", "<", "self", ".", "lr_anneal_steps", "\n", ")", ":", "\n", "            ", "batch", ",", "cond", "=", "next", "(", "self", ".", "data", ")", "\n", "self", ".", "run_step", "(", "batch", ",", "cond", ")", "\n", "if", "self", ".", "step", "%", "self", ".", "log_interval", "==", "0", ":", "\n", "                ", "logger", ".", "dumpkvs", "(", ")", "\n", "", "if", "self", ".", "step", "%", "self", ".", "save_interval", "==", "0", ":", "\n", "                ", "self", ".", "save", "(", ")", "\n", "# Run for a finite amount of time in integration tests.", "\n", "if", "os", ".", "environ", ".", "get", "(", "\"DIFFUSION_TRAINING_TEST\"", ",", "\"\"", ")", "and", "self", ".", "step", ">", "0", ":", "\n", "                    ", "return", "\n", "", "", "self", ".", "step", "+=", "1", "\n", "# Save the last checkpoint if it wasn't already saved.", "\n", "", "if", "(", "self", ".", "step", "-", "1", ")", "%", "self", ".", "save_interval", "!=", "0", ":", "\n", "            ", "self", ".", "save", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.TrainLoop.run_step": [[196, 203], ["train_util.TrainLoop.forward_backward", "train_util.TrainLoop.mp_trainer.optimize", "train_util.TrainLoop._anneal_lr", "train_util.TrainLoop.log_step", "train_util.TrainLoop._update_ema"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.TrainLoop.forward_backward", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.MixedPrecisionTrainer.optimize", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.TrainLoop._anneal_lr", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.TrainLoop.log_step", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.TrainLoop._update_ema"], ["", "", "def", "run_step", "(", "self", ",", "batch", ",", "cond", ")", ":", "\n", "        ", "self", ".", "forward_backward", "(", "batch", ",", "cond", ")", "\n", "took_step", "=", "self", ".", "mp_trainer", ".", "optimize", "(", "self", ".", "opt", ")", "\n", "if", "took_step", ":", "\n", "            ", "self", ".", "_update_ema", "(", ")", "\n", "", "self", ".", "_anneal_lr", "(", ")", "\n", "self", ".", "log_step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.TrainLoop.forward_backward": [[204, 239], ["train_util.TrainLoop.mp_trainer.zero_grad", "range", "batch[].to", "train_util.TrainLoop.schedule_sampler.sample", "functools.partial", "isinstance", "train_util.log_loss_dict", "train_util.TrainLoop.mp_trainer.backward", "v[].to", "functools.partial.", "train_util.TrainLoop.schedule_sampler.update_with_local_losses", "cond.items", "train_util.TrainLoop.ddp_model.no_sync", "functools.partial.", "losses[].detach", "functools.partial.items"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.zero_grad", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.resample.ScheduleSampler.sample", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.log_loss_dict", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.MixedPrecisionTrainer.backward", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.resample.LossAwareSampler.update_with_local_losses"], ["", "def", "forward_backward", "(", "self", ",", "batch", ",", "cond", ")", ":", "\n", "        ", "self", ".", "mp_trainer", ".", "zero_grad", "(", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "batch", ".", "shape", "[", "0", "]", ",", "self", ".", "microbatch", ")", ":", "\n", "            ", "micro", "=", "batch", "[", "i", ":", "i", "+", "self", ".", "microbatch", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "micro_cond", "=", "{", "\n", "k", ":", "v", "[", "i", ":", "i", "+", "self", ".", "microbatch", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "for", "k", ",", "v", "in", "cond", ".", "items", "(", ")", "\n", "}", "\n", "last_batch", "=", "(", "i", "+", "self", ".", "microbatch", ")", ">=", "batch", ".", "shape", "[", "0", "]", "\n", "t", ",", "weights", "=", "self", ".", "schedule_sampler", ".", "sample", "(", "micro", ".", "shape", "[", "0", "]", ",", "self", ".", "device", ")", "\n", "\n", "compute_losses", "=", "functools", ".", "partial", "(", "\n", "self", ".", "diffusion", ".", "training_losses", ",", "\n", "self", ".", "ddp_model", ",", "\n", "micro", ",", "\n", "t", ",", "\n", "model_kwargs", "=", "micro_cond", ",", "\n", ")", "\n", "\n", "if", "last_batch", "or", "not", "self", ".", "use_ddp", ":", "\n", "                ", "losses", "=", "compute_losses", "(", ")", "\n", "", "else", ":", "\n", "                ", "with", "self", ".", "ddp_model", ".", "no_sync", "(", ")", ":", "\n", "                    ", "losses", "=", "compute_losses", "(", ")", "\n", "\n", "", "", "if", "isinstance", "(", "self", ".", "schedule_sampler", ",", "LossAwareSampler", ")", ":", "\n", "                ", "self", ".", "schedule_sampler", ".", "update_with_local_losses", "(", "\n", "t", ",", "losses", "[", "\"loss\"", "]", ".", "detach", "(", ")", "\n", ")", "\n", "\n", "", "loss", "=", "(", "losses", "[", "\"loss\"", "]", "*", "weights", ")", ".", "mean", "(", ")", "\n", "log_loss_dict", "(", "\n", "self", ".", "diffusion", ",", "t", ",", "{", "k", ":", "v", "*", "weights", "for", "k", ",", "v", "in", "losses", ".", "items", "(", ")", "}", "\n", ")", "\n", "self", ".", "mp_trainer", ".", "backward", "(", "loss", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.TrainLoop._update_ema": [[240, 243], ["zip", "nn.update_ema"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.update_ema"], ["", "", "def", "_update_ema", "(", "self", ")", ":", "\n", "        ", "for", "rate", ",", "params", "in", "zip", "(", "self", ".", "ema_rate", ",", "self", ".", "ema_params", ")", ":", "\n", "            ", "update_ema", "(", "params", ",", "self", ".", "mp_trainer", ".", "master_params", ",", "rate", "=", "rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.TrainLoop._anneal_lr": [[244, 251], ["None"], "methods", ["None"], ["", "", "def", "_anneal_lr", "(", "self", ")", ":", "\n", "        ", "if", "not", "self", ".", "lr_anneal_steps", ":", "\n", "            ", "return", "\n", "", "frac_done", "=", "(", "self", ".", "step", "+", "self", ".", "resume_step", ")", "/", "self", ".", "lr_anneal_steps", "\n", "lr", "=", "self", ".", "lr", "*", "(", "1", "-", "frac_done", ")", "\n", "for", "param_group", "in", "self", ".", "opt", ".", "param_groups", ":", "\n", "            ", "param_group", "[", "\"lr\"", "]", "=", "lr", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.TrainLoop.log_step": [[252, 255], ["logger.logkv", "logger.logkv"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.logkv", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.logkv"], ["", "", "def", "log_step", "(", "self", ")", ":", "\n", "        ", "logger", ".", "logkv", "(", "\"step\"", ",", "self", ".", "step", "+", "self", ".", "resume_step", ")", "\n", "logger", ".", "logkv", "(", "\"samples\"", ",", "(", "self", ".", "step", "+", "self", ".", "resume_step", "+", "1", ")", "*", "self", ".", "global_batch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.TrainLoop.save": [[256, 281], ["train_util.TrainLoop.save.save_checkpoint"], "methods", ["None"], ["", "def", "save", "(", "self", ")", ":", "\n", "        ", "def", "save_checkpoint", "(", "rate", ",", "params", ")", ":", "\n", "            ", "state_dict", "=", "self", ".", "mp_trainer", ".", "master_params_to_state_dict", "(", "params", ")", "\n", "if", "not", "self", ".", "distriubted", "or", "dist", ".", "get_rank", "(", ")", "==", "0", ":", "\n", "                ", "logger", ".", "log", "(", "f\"saving model {rate}...\"", ")", "\n", "if", "not", "rate", ":", "\n", "                    ", "filename", "=", "f\"model{(self.step+self.resume_step):06d}.pt\"", "\n", "", "else", ":", "\n", "                    ", "filename", "=", "f\"ema_{rate}_{(self.step+self.resume_step):06d}.pt\"", "\n", "", "with", "bf", ".", "BlobFile", "(", "bf", ".", "join", "(", "get_blob_logdir", "(", ")", ",", "filename", ")", ",", "\"wb\"", ")", "as", "f", ":", "\n", "                    ", "th", ".", "save", "(", "state_dict", ",", "f", ")", "\n", "\n", "", "", "", "save_checkpoint", "(", "0", ",", "self", ".", "mp_trainer", ".", "master_params", ")", "\n", "for", "rate", ",", "params", "in", "zip", "(", "self", ".", "ema_rate", ",", "self", ".", "ema_params", ")", ":", "\n", "            ", "save_checkpoint", "(", "rate", ",", "params", ")", "\n", "\n", "", "if", "not", "self", ".", "distriubted", "or", "dist", ".", "get_rank", "(", ")", "==", "0", ":", "\n", "            ", "with", "bf", ".", "BlobFile", "(", "\n", "bf", ".", "join", "(", "get_blob_logdir", "(", ")", ",", "f\"opt{(self.step+self.resume_step):06d}.pt\"", ")", ",", "\n", "\"wb\"", ",", "\n", ")", "as", "f", ":", "\n", "                ", "th", ".", "save", "(", "self", ".", "opt", ".", "state_dict", "(", ")", ",", "f", ")", "\n", "\n", "", "", "if", "self", ".", "distriubted", ":", "\n", "            ", "dist", ".", "barrier", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.parse_resume_step_from_filename": [[283, 296], ["filename.split", "len", "split[].split", "int"], "function", ["None"], ["", "", "", "def", "parse_resume_step_from_filename", "(", "filename", ")", ":", "\n", "    ", "\"\"\"\n    Parse filenames of the form path/to/modelNNNNNN.pt, where NNNNNN is the\n    checkpoint's number of steps.\n    \"\"\"", "\n", "split", "=", "filename", ".", "split", "(", "\"model\"", ")", "\n", "if", "len", "(", "split", ")", "<", "2", ":", "\n", "        ", "return", "0", "\n", "", "split1", "=", "split", "[", "-", "1", "]", ".", "split", "(", "\".\"", ")", "[", "0", "]", "\n", "try", ":", "\n", "        ", "return", "int", "(", "split1", ")", "\n", "", "except", "ValueError", ":", "\n", "        ", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.get_blob_logdir": [[298, 302], ["logger.get_dir"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.get_dir"], ["", "", "def", "get_blob_logdir", "(", ")", ":", "\n", "# You can change this to be a separate path to save checkpoints to", "\n", "# a blobstore or some external drive.", "\n", "    ", "return", "logger", ".", "get_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.find_resume_checkpoint": [[304, 308], ["None"], "function", ["None"], ["", "def", "find_resume_checkpoint", "(", ")", ":", "\n", "# On your infrastructure, you may want to override this to automatically", "\n", "# discover the latest checkpoint on your blob storage, etc.", "\n", "    ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.find_ema_checkpoint": [[310, 318], ["blobfile.join", "blobfile.exists", "blobfile.dirname"], "function", ["None"], ["", "def", "find_ema_checkpoint", "(", "main_checkpoint", ",", "step", ",", "rate", ")", ":", "\n", "    ", "if", "main_checkpoint", "is", "None", ":", "\n", "        ", "return", "None", "\n", "", "filename", "=", "f\"ema_{rate}_{(step):06d}.pt\"", "\n", "path", "=", "bf", ".", "join", "(", "bf", ".", "dirname", "(", "main_checkpoint", ")", ",", "filename", ")", "\n", "if", "bf", ".", "exists", "(", "path", ")", ":", "\n", "        ", "return", "path", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.train_util.log_loss_dict": [[320, 327], ["losses.items", "logger.logkv_mean", "zip", "values.mean().item", "ts.cpu().numpy", "values.detach().cpu().numpy", "int", "logger.logkv_mean", "values.mean", "ts.cpu", "values.detach().cpu", "values.detach"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.logkv_mean", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.logkv_mean"], ["", "def", "log_loss_dict", "(", "diffusion", ",", "ts", ",", "losses", ")", ":", "\n", "    ", "for", "key", ",", "values", "in", "losses", ".", "items", "(", ")", ":", "\n", "        ", "logger", ".", "logkv_mean", "(", "key", ",", "values", ".", "mean", "(", ")", ".", "item", "(", ")", ")", "\n", "# Log the quantiles (four quartiles, in particular).", "\n", "for", "sub_t", ",", "sub_loss", "in", "zip", "(", "ts", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "values", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ":", "\n", "            ", "quartile", "=", "int", "(", "4", "*", "sub_t", "/", "diffusion", ".", "num_timesteps", ")", "\n", "logger", ".", "logkv_mean", "(", "f\"{key}_q{quartile}\"", ",", "sub_loss", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.diffusion_defaults": [[11, 24], ["dict"], "function", ["None"], ["def", "diffusion_defaults", "(", ")", ":", "\n", "    ", "\"\"\"\n    Defaults for image and classifier training.\n    \"\"\"", "\n", "return", "dict", "(", "\n", "learn_sigma", "=", "False", ",", "\n", "diffusion_steps", "=", "1000", ",", "\n", "noise_schedule", "=", "\"linear\"", ",", "\n", "timestep_respacing", "=", "\"\"", ",", "\n", "use_kl", "=", "False", ",", "\n", "predict_xstart", "=", "False", ",", "\n", "rescale_timesteps", "=", "False", ",", "\n", "rescale_learned_sigmas", "=", "False", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.classifier_defaults": [[27, 40], ["dict"], "function", ["None"], ["", "def", "classifier_defaults", "(", ")", ":", "\n", "    ", "\"\"\"\n    Defaults for classifier models.\n    \"\"\"", "\n", "return", "dict", "(", "\n", "image_size", "=", "64", ",", "\n", "classifier_use_fp16", "=", "False", ",", "\n", "classifier_width", "=", "128", ",", "\n", "classifier_depth", "=", "2", ",", "\n", "classifier_attention_resolutions", "=", "\"32,16,8\"", ",", "# 16", "\n", "classifier_use_scale_shift_norm", "=", "True", ",", "# False", "\n", "classifier_resblock_updown", "=", "True", ",", "# False", "\n", "classifier_pool", "=", "\"attention\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.model_and_diffusion_defaults": [[43, 66], ["dict", "dict.update", "script_util.diffusion_defaults"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.diffusion_defaults"], ["", "def", "model_and_diffusion_defaults", "(", ")", ":", "\n", "    ", "\"\"\"\n    Defaults for image training.\n    \"\"\"", "\n", "res", "=", "dict", "(", "\n", "image_size", "=", "64", ",", "\n", "num_channels", "=", "128", ",", "\n", "num_res_blocks", "=", "2", ",", "\n", "num_heads", "=", "4", ",", "\n", "num_heads_upsample", "=", "-", "1", ",", "\n", "num_head_channels", "=", "-", "1", ",", "\n", "attention_resolutions", "=", "\"16,8\"", ",", "\n", "channel_mult", "=", "\"\"", ",", "\n", "dropout", "=", "0.0", ",", "\n", "class_cond", "=", "False", ",", "\n", "use_checkpoint", "=", "False", ",", "\n", "use_scale_shift_norm", "=", "True", ",", "\n", "resblock_updown", "=", "False", ",", "\n", "fp16", "=", "False", ",", "\n", "use_new_attention_order", "=", "False", ",", "\n", ")", "\n", "res", ".", "update", "(", "diffusion_defaults", "(", ")", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.classifier_and_diffusion_defaults": [[68, 72], ["script_util.classifier_defaults", "classifier_defaults.update", "script_util.diffusion_defaults"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.classifier_defaults", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.diffusion_defaults"], ["", "def", "classifier_and_diffusion_defaults", "(", ")", ":", "\n", "    ", "res", "=", "classifier_defaults", "(", ")", "\n", "res", ".", "update", "(", "diffusion_defaults", "(", ")", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.create_model_and_diffusion": [[74, 128], ["script_util.create_model", "script_util.create_gaussian_diffusion"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.models.models.create_model", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.create_gaussian_diffusion"], ["", "def", "create_model_and_diffusion", "(", "\n", "image_size", ",", "\n", "class_cond", ",", "\n", "learn_sigma", ",", "\n", "num_channels", ",", "\n", "num_res_blocks", ",", "\n", "channel_mult", ",", "\n", "num_heads", ",", "\n", "num_head_channels", ",", "\n", "num_heads_upsample", ",", "\n", "attention_resolutions", ",", "\n", "dropout", ",", "\n", "diffusion_steps", ",", "\n", "noise_schedule", ",", "\n", "timestep_respacing", ",", "\n", "use_kl", ",", "\n", "predict_xstart", ",", "\n", "rescale_timesteps", ",", "\n", "rescale_learned_sigmas", ",", "\n", "use_checkpoint", ",", "\n", "use_scale_shift_norm", ",", "\n", "resblock_updown", ",", "\n", "fp16", ",", "\n", "use_new_attention_order", ",", "\n", ")", ":", "\n", "    ", "model", "=", "create_model", "(", "\n", "image_size", ",", "\n", "num_channels", ",", "\n", "num_res_blocks", ",", "\n", "channel_mult", "=", "channel_mult", ",", "\n", "learn_sigma", "=", "learn_sigma", ",", "\n", "class_cond", "=", "class_cond", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "attention_resolutions", "=", "attention_resolutions", ",", "\n", "num_heads", "=", "num_heads", ",", "\n", "num_head_channels", "=", "num_head_channels", ",", "\n", "num_heads_upsample", "=", "num_heads_upsample", ",", "\n", "use_scale_shift_norm", "=", "use_scale_shift_norm", ",", "\n", "dropout", "=", "dropout", ",", "\n", "resblock_updown", "=", "resblock_updown", ",", "\n", "use_fp16", "=", "fp16", ",", "\n", "use_new_attention_order", "=", "use_new_attention_order", ",", "\n", ")", "\n", "diffusion", "=", "create_gaussian_diffusion", "(", "\n", "steps", "=", "diffusion_steps", ",", "\n", "learn_sigma", "=", "learn_sigma", ",", "\n", "noise_schedule", "=", "noise_schedule", ",", "\n", "use_kl", "=", "use_kl", ",", "\n", "predict_xstart", "=", "predict_xstart", ",", "\n", "rescale_timesteps", "=", "rescale_timesteps", ",", "\n", "rescale_learned_sigmas", "=", "rescale_learned_sigmas", ",", "\n", "timestep_respacing", "=", "timestep_respacing", ",", "\n", ")", "\n", "return", "model", ",", "diffusion", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.create_model": [[130, 184], ["attention_resolutions.split", "unet.UNetModel", "tuple", "attention_ds.append", "tuple", "int", "int", "tuple.split", "ValueError"], "function", ["None"], ["", "def", "create_model", "(", "\n", "image_size", ",", "\n", "num_channels", ",", "\n", "num_res_blocks", ",", "\n", "channel_mult", "=", "\"\"", ",", "\n", "learn_sigma", "=", "False", ",", "\n", "class_cond", "=", "False", ",", "\n", "use_checkpoint", "=", "False", ",", "\n", "attention_resolutions", "=", "\"16\"", ",", "\n", "num_heads", "=", "1", ",", "\n", "num_head_channels", "=", "-", "1", ",", "\n", "num_heads_upsample", "=", "-", "1", ",", "\n", "use_scale_shift_norm", "=", "False", ",", "\n", "dropout", "=", "0", ",", "\n", "resblock_updown", "=", "False", ",", "\n", "use_fp16", "=", "False", ",", "\n", "use_new_attention_order", "=", "False", ",", "\n", ")", ":", "\n", "    ", "if", "channel_mult", "==", "\"\"", ":", "\n", "        ", "if", "image_size", "==", "512", ":", "\n", "            ", "channel_mult", "=", "(", "0.5", ",", "1", ",", "1", ",", "2", ",", "2", ",", "4", ",", "4", ")", "\n", "", "elif", "image_size", "==", "256", ":", "\n", "            ", "channel_mult", "=", "(", "1", ",", "1", ",", "2", ",", "2", ",", "4", ",", "4", ")", "\n", "", "elif", "image_size", "==", "128", ":", "\n", "            ", "channel_mult", "=", "(", "1", ",", "1", ",", "2", ",", "3", ",", "4", ")", "\n", "", "elif", "image_size", "==", "64", ":", "\n", "            ", "channel_mult", "=", "(", "1", ",", "2", ",", "3", ",", "4", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f\"unsupported image size: {image_size}\"", ")", "\n", "", "", "else", ":", "\n", "        ", "channel_mult", "=", "tuple", "(", "int", "(", "ch_mult", ")", "for", "ch_mult", "in", "channel_mult", ".", "split", "(", "\",\"", ")", ")", "\n", "\n", "", "attention_ds", "=", "[", "]", "\n", "for", "res", "in", "attention_resolutions", ".", "split", "(", "\",\"", ")", ":", "\n", "        ", "attention_ds", ".", "append", "(", "image_size", "//", "int", "(", "res", ")", ")", "\n", "\n", "", "return", "UNetModel", "(", "\n", "image_size", "=", "image_size", ",", "\n", "in_channels", "=", "3", ",", "\n", "model_channels", "=", "num_channels", ",", "\n", "out_channels", "=", "(", "3", "if", "not", "learn_sigma", "else", "6", ")", ",", "\n", "num_res_blocks", "=", "num_res_blocks", ",", "\n", "attention_resolutions", "=", "tuple", "(", "attention_ds", ")", ",", "\n", "dropout", "=", "dropout", ",", "\n", "channel_mult", "=", "channel_mult", ",", "\n", "num_classes", "=", "(", "NUM_CLASSES", "if", "class_cond", "else", "None", ")", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "use_fp16", "=", "use_fp16", ",", "\n", "num_heads", "=", "num_heads", ",", "\n", "num_head_channels", "=", "num_head_channels", ",", "\n", "num_heads_upsample", "=", "num_heads_upsample", ",", "\n", "use_scale_shift_norm", "=", "use_scale_shift_norm", ",", "\n", "resblock_updown", "=", "resblock_updown", ",", "\n", "use_new_attention_order", "=", "use_new_attention_order", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.create_classifier_and_diffusion": [[187, 226], ["script_util.create_classifier", "script_util.create_gaussian_diffusion"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.create_classifier", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.create_gaussian_diffusion"], ["", "def", "create_classifier_and_diffusion", "(", "\n", "image_size", ",", "\n", "classifier_use_fp16", ",", "\n", "classifier_width", ",", "\n", "classifier_depth", ",", "\n", "classifier_attention_resolutions", ",", "\n", "classifier_use_scale_shift_norm", ",", "\n", "classifier_resblock_updown", ",", "\n", "classifier_pool", ",", "\n", "learn_sigma", ",", "\n", "diffusion_steps", ",", "\n", "noise_schedule", ",", "\n", "timestep_respacing", ",", "\n", "use_kl", ",", "\n", "predict_xstart", ",", "\n", "rescale_timesteps", ",", "\n", "rescale_learned_sigmas", ",", "\n", ")", ":", "\n", "    ", "classifier", "=", "create_classifier", "(", "\n", "image_size", ",", "\n", "classifier_use_fp16", ",", "\n", "classifier_width", ",", "\n", "classifier_depth", ",", "\n", "classifier_attention_resolutions", ",", "\n", "classifier_use_scale_shift_norm", ",", "\n", "classifier_resblock_updown", ",", "\n", "classifier_pool", ",", "\n", ")", "\n", "diffusion", "=", "create_gaussian_diffusion", "(", "\n", "steps", "=", "diffusion_steps", ",", "\n", "learn_sigma", "=", "learn_sigma", ",", "\n", "noise_schedule", "=", "noise_schedule", ",", "\n", "use_kl", "=", "use_kl", ",", "\n", "predict_xstart", "=", "predict_xstart", ",", "\n", "rescale_timesteps", "=", "rescale_timesteps", ",", "\n", "rescale_learned_sigmas", "=", "rescale_learned_sigmas", ",", "\n", "timestep_respacing", "=", "timestep_respacing", ",", "\n", ")", "\n", "return", "classifier", ",", "diffusion", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.create_classifier": [[228, 266], ["classifier_attention_resolutions.split", "unet.EncoderUNetModel", "attention_ds.append", "tuple", "int", "ValueError"], "function", ["None"], ["", "def", "create_classifier", "(", "\n", "image_size", ",", "\n", "classifier_use_fp16", ",", "\n", "classifier_width", ",", "\n", "classifier_depth", ",", "\n", "classifier_attention_resolutions", ",", "\n", "classifier_use_scale_shift_norm", ",", "\n", "classifier_resblock_updown", ",", "\n", "classifier_pool", ",", "\n", ")", ":", "\n", "    ", "if", "image_size", "==", "512", ":", "\n", "        ", "channel_mult", "=", "(", "0.5", ",", "1", ",", "1", ",", "2", ",", "2", ",", "4", ",", "4", ")", "\n", "", "elif", "image_size", "==", "256", ":", "\n", "        ", "channel_mult", "=", "(", "1", ",", "1", ",", "2", ",", "2", ",", "4", ",", "4", ")", "\n", "", "elif", "image_size", "==", "128", ":", "\n", "        ", "channel_mult", "=", "(", "1", ",", "1", ",", "2", ",", "3", ",", "4", ")", "\n", "", "elif", "image_size", "==", "64", ":", "\n", "        ", "channel_mult", "=", "(", "1", ",", "2", ",", "3", ",", "4", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"unsupported image size: {image_size}\"", ")", "\n", "\n", "", "attention_ds", "=", "[", "]", "\n", "for", "res", "in", "classifier_attention_resolutions", ".", "split", "(", "\",\"", ")", ":", "\n", "        ", "attention_ds", ".", "append", "(", "image_size", "//", "int", "(", "res", ")", ")", "\n", "\n", "", "return", "EncoderUNetModel", "(", "\n", "image_size", "=", "image_size", ",", "\n", "in_channels", "=", "3", ",", "\n", "model_channels", "=", "classifier_width", ",", "\n", "out_channels", "=", "1000", ",", "\n", "num_res_blocks", "=", "classifier_depth", ",", "\n", "attention_resolutions", "=", "tuple", "(", "attention_ds", ")", ",", "\n", "channel_mult", "=", "channel_mult", ",", "\n", "use_fp16", "=", "classifier_use_fp16", ",", "\n", "num_head_channels", "=", "64", ",", "\n", "use_scale_shift_norm", "=", "classifier_use_scale_shift_norm", ",", "\n", "resblock_updown", "=", "classifier_resblock_updown", ",", "\n", "pool", "=", "classifier_pool", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.sr_model_and_diffusion_defaults": [[269, 278], ["script_util.model_and_diffusion_defaults", "model_and_diffusion_defaults.copy().keys", "inspect.getfullargspec", "model_and_diffusion_defaults.copy"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.model_and_diffusion_defaults"], ["", "def", "sr_model_and_diffusion_defaults", "(", ")", ":", "\n", "    ", "res", "=", "model_and_diffusion_defaults", "(", ")", "\n", "res", "[", "\"large_size\"", "]", "=", "256", "\n", "res", "[", "\"small_size\"", "]", "=", "64", "\n", "arg_names", "=", "inspect", ".", "getfullargspec", "(", "sr_create_model_and_diffusion", ")", "[", "0", "]", "\n", "for", "k", "in", "res", ".", "copy", "(", ")", ".", "keys", "(", ")", ":", "\n", "        ", "if", "k", "not", "in", "arg_names", ":", "\n", "            ", "del", "res", "[", "k", "]", "\n", "", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.sr_create_model_and_diffusion": [[280, 332], ["script_util.sr_create_model", "script_util.create_gaussian_diffusion"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.sr_create_model", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.create_gaussian_diffusion"], ["", "def", "sr_create_model_and_diffusion", "(", "\n", "large_size", ",", "\n", "small_size", ",", "\n", "class_cond", ",", "\n", "learn_sigma", ",", "\n", "num_channels", ",", "\n", "num_res_blocks", ",", "\n", "num_heads", ",", "\n", "num_head_channels", ",", "\n", "num_heads_upsample", ",", "\n", "attention_resolutions", ",", "\n", "dropout", ",", "\n", "diffusion_steps", ",", "\n", "noise_schedule", ",", "\n", "timestep_respacing", ",", "\n", "use_kl", ",", "\n", "predict_xstart", ",", "\n", "rescale_timesteps", ",", "\n", "rescale_learned_sigmas", ",", "\n", "use_checkpoint", ",", "\n", "use_scale_shift_norm", ",", "\n", "resblock_updown", ",", "\n", "use_fp16", ",", "\n", ")", ":", "\n", "    ", "model", "=", "sr_create_model", "(", "\n", "large_size", ",", "\n", "small_size", ",", "\n", "num_channels", ",", "\n", "num_res_blocks", ",", "\n", "learn_sigma", "=", "learn_sigma", ",", "\n", "class_cond", "=", "class_cond", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "attention_resolutions", "=", "attention_resolutions", ",", "\n", "num_heads", "=", "num_heads", ",", "\n", "num_head_channels", "=", "num_head_channels", ",", "\n", "num_heads_upsample", "=", "num_heads_upsample", ",", "\n", "use_scale_shift_norm", "=", "use_scale_shift_norm", ",", "\n", "dropout", "=", "dropout", ",", "\n", "resblock_updown", "=", "resblock_updown", ",", "\n", "use_fp16", "=", "use_fp16", ",", "\n", ")", "\n", "diffusion", "=", "create_gaussian_diffusion", "(", "\n", "steps", "=", "diffusion_steps", ",", "\n", "learn_sigma", "=", "learn_sigma", ",", "\n", "noise_schedule", "=", "noise_schedule", ",", "\n", "use_kl", "=", "use_kl", ",", "\n", "predict_xstart", "=", "predict_xstart", ",", "\n", "rescale_timesteps", "=", "rescale_timesteps", ",", "\n", "rescale_learned_sigmas", "=", "rescale_learned_sigmas", ",", "\n", "timestep_respacing", "=", "timestep_respacing", ",", "\n", ")", "\n", "return", "model", ",", "diffusion", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.sr_create_model": [[334, 383], ["attention_resolutions.split", "unet.SuperResModel", "attention_ds.append", "tuple", "ValueError", "int"], "function", ["None"], ["", "def", "sr_create_model", "(", "\n", "large_size", ",", "\n", "small_size", ",", "\n", "num_channels", ",", "\n", "num_res_blocks", ",", "\n", "learn_sigma", ",", "\n", "class_cond", ",", "\n", "use_checkpoint", ",", "\n", "attention_resolutions", ",", "\n", "num_heads", ",", "\n", "num_head_channels", ",", "\n", "num_heads_upsample", ",", "\n", "use_scale_shift_norm", ",", "\n", "dropout", ",", "\n", "resblock_updown", ",", "\n", "use_fp16", ",", "\n", ")", ":", "\n", "    ", "_", "=", "small_size", "# hack to prevent unused variable", "\n", "\n", "if", "large_size", "==", "512", ":", "\n", "        ", "channel_mult", "=", "(", "1", ",", "1", ",", "2", ",", "2", ",", "4", ",", "4", ")", "\n", "", "elif", "large_size", "==", "256", ":", "\n", "        ", "channel_mult", "=", "(", "1", ",", "1", ",", "2", ",", "2", ",", "4", ",", "4", ")", "\n", "", "elif", "large_size", "==", "64", ":", "\n", "        ", "channel_mult", "=", "(", "1", ",", "2", ",", "3", ",", "4", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"unsupported large size: {large_size}\"", ")", "\n", "\n", "", "attention_ds", "=", "[", "]", "\n", "for", "res", "in", "attention_resolutions", ".", "split", "(", "\",\"", ")", ":", "\n", "        ", "attention_ds", ".", "append", "(", "large_size", "//", "int", "(", "res", ")", ")", "\n", "\n", "", "return", "SuperResModel", "(", "\n", "image_size", "=", "large_size", ",", "\n", "in_channels", "=", "3", ",", "\n", "model_channels", "=", "num_channels", ",", "\n", "out_channels", "=", "(", "3", "if", "not", "learn_sigma", "else", "6", ")", ",", "\n", "num_res_blocks", "=", "num_res_blocks", ",", "\n", "attention_resolutions", "=", "tuple", "(", "attention_ds", ")", ",", "\n", "dropout", "=", "dropout", ",", "\n", "channel_mult", "=", "channel_mult", ",", "\n", "num_classes", "=", "(", "NUM_CLASSES", "if", "class_cond", "else", "None", ")", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "num_heads", "=", "num_heads", ",", "\n", "num_head_channels", "=", "num_head_channels", ",", "\n", "num_heads_upsample", "=", "num_heads_upsample", ",", "\n", "use_scale_shift_norm", "=", "use_scale_shift_norm", ",", "\n", "resblock_updown", "=", "resblock_updown", ",", "\n", "use_fp16", "=", "use_fp16", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.create_gaussian_diffusion": [[386, 424], ["gaussian_diffusion.get_named_beta_schedule", "respace.SpacedDiffusion", "respace.space_timesteps"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.get_named_beta_schedule", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.space_timesteps"], ["", "def", "create_gaussian_diffusion", "(", "\n", "*", ",", "\n", "steps", "=", "1000", ",", "\n", "learn_sigma", "=", "False", ",", "\n", "sigma_small", "=", "False", ",", "\n", "noise_schedule", "=", "\"linear\"", ",", "\n", "use_kl", "=", "False", ",", "\n", "predict_xstart", "=", "False", ",", "\n", "rescale_timesteps", "=", "False", ",", "\n", "rescale_learned_sigmas", "=", "False", ",", "\n", "timestep_respacing", "=", "\"\"", ",", "\n", ")", ":", "\n", "    ", "betas", "=", "gd", ".", "get_named_beta_schedule", "(", "noise_schedule", ",", "steps", ")", "\n", "if", "use_kl", ":", "\n", "        ", "loss_type", "=", "gd", ".", "LossType", ".", "RESCALED_KL", "\n", "", "elif", "rescale_learned_sigmas", ":", "\n", "        ", "loss_type", "=", "gd", ".", "LossType", ".", "RESCALED_MSE", "\n", "", "else", ":", "\n", "        ", "loss_type", "=", "gd", ".", "LossType", ".", "MSE", "\n", "", "if", "not", "timestep_respacing", ":", "\n", "        ", "timestep_respacing", "=", "[", "steps", "]", "\n", "", "return", "SpacedDiffusion", "(", "\n", "use_timesteps", "=", "space_timesteps", "(", "steps", ",", "timestep_respacing", ")", ",", "\n", "betas", "=", "betas", ",", "\n", "model_mean_type", "=", "(", "\n", "gd", ".", "ModelMeanType", ".", "EPSILON", "if", "not", "predict_xstart", "else", "gd", ".", "ModelMeanType", ".", "START_X", "\n", ")", ",", "\n", "model_var_type", "=", "(", "\n", "(", "\n", "gd", ".", "ModelVarType", ".", "FIXED_LARGE", "\n", "if", "not", "sigma_small", "\n", "else", "gd", ".", "ModelVarType", ".", "FIXED_SMALL", "\n", ")", "\n", "if", "not", "learn_sigma", "\n", "else", "gd", ".", "ModelVarType", ".", "LEARNED_RANGE", "\n", ")", ",", "\n", "loss_type", "=", "loss_type", ",", "\n", "rescale_timesteps", "=", "rescale_timesteps", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.add_dict_to_argparser": [[427, 435], ["default_dict.items", "type", "parser.add_argument", "isinstance"], "function", ["None"], ["", "def", "add_dict_to_argparser", "(", "parser", ",", "default_dict", ")", ":", "\n", "    ", "for", "k", ",", "v", "in", "default_dict", ".", "items", "(", ")", ":", "\n", "        ", "v_type", "=", "type", "(", "v", ")", "\n", "if", "v", "is", "None", ":", "\n", "            ", "v_type", "=", "str", "\n", "", "elif", "isinstance", "(", "v", ",", "bool", ")", ":", "\n", "            ", "v_type", "=", "str2bool", "\n", "", "parser", ".", "add_argument", "(", "f\"--{k}\"", ",", "default", "=", "v", ",", "type", "=", "v_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.args_to_dict": [[437, 439], ["getattr"], "function", ["None"], ["", "", "def", "args_to_dict", "(", "args", ",", "keys", ")", ":", "\n", "    ", "return", "{", "k", ":", "getattr", "(", "args", ",", "k", ")", "for", "k", "in", "keys", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.str2bool": [[441, 453], ["isinstance", "v.lower", "v.lower", "argparse.ArgumentTypeError"], "function", ["None"], ["", "def", "str2bool", "(", "v", ")", ":", "\n", "    ", "\"\"\"\n    https://stackoverflow.com/questions/15008758/parsing-boolean-values-with-argparse\n    \"\"\"", "\n", "if", "isinstance", "(", "v", ",", "bool", ")", ":", "\n", "        ", "return", "v", "\n", "", "if", "v", ".", "lower", "(", ")", "in", "(", "\"yes\"", ",", "\"true\"", ",", "\"t\"", ",", "\"y\"", ",", "\"1\"", ")", ":", "\n", "        ", "return", "True", "\n", "", "elif", "v", ".", "lower", "(", ")", "in", "(", "\"no\"", ",", "\"false\"", ",", "\"f\"", ",", "\"n\"", ",", "\"0\"", ")", ":", "\n", "        ", "return", "False", "\n", "", "else", ":", "\n", "        ", "raise", "argparse", ".", "ArgumentTypeError", "(", "\"boolean value expected\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.image_datasets.ImageDataset.__init__": [[83, 99], ["torch.utils.data.Dataset.__init__"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "resolution", ",", "\n", "image_paths", ",", "\n", "classes", "=", "None", ",", "\n", "shard", "=", "0", ",", "\n", "num_shards", "=", "1", ",", "\n", "random_crop", "=", "False", ",", "\n", "random_flip", "=", "True", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "resolution", "=", "resolution", "\n", "self", ".", "local_images", "=", "image_paths", "[", "shard", ":", "]", "[", ":", ":", "num_shards", "]", "\n", "self", ".", "local_classes", "=", "None", "if", "classes", "is", "None", "else", "classes", "[", "shard", ":", "]", "[", ":", ":", "num_shards", "]", "\n", "self", ".", "random_crop", "=", "random_crop", "\n", "self", ".", "random_flip", "=", "random_flip", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.image_datasets.ImageDataset.__len__": [[100, 102], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "local_images", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.image_datasets.ImageDataset.__getitem__": [[103, 124], ["PIL.Image.open.convert", "blobfile.BlobFile", "PIL.Image.open", "PIL.Image.open.load", "image_datasets.random_crop_arr", "image_datasets.center_crop_arr", "numpy.array", "numpy.transpose", "random.random", "center_crop_arr.astype"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.load", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.image_datasets.random_crop_arr", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.image_datasets.center_crop_arr"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "path", "=", "self", ".", "local_images", "[", "idx", "]", "\n", "with", "bf", ".", "BlobFile", "(", "path", ",", "\"rb\"", ")", "as", "f", ":", "\n", "            ", "pil_image", "=", "Image", ".", "open", "(", "f", ")", "\n", "pil_image", ".", "load", "(", ")", "\n", "", "pil_image", "=", "pil_image", ".", "convert", "(", "\"RGB\"", ")", "\n", "\n", "if", "self", ".", "random_crop", ":", "\n", "            ", "arr", "=", "random_crop_arr", "(", "pil_image", ",", "self", ".", "resolution", ")", "\n", "", "else", ":", "\n", "            ", "arr", "=", "center_crop_arr", "(", "pil_image", ",", "self", ".", "resolution", ")", "\n", "\n", "", "if", "self", ".", "random_flip", "and", "random", ".", "random", "(", ")", "<", "0.5", ":", "\n", "            ", "arr", "=", "arr", "[", ":", ",", ":", ":", "-", "1", "]", "\n", "\n", "", "arr", "=", "arr", ".", "astype", "(", "np", ".", "float32", ")", "/", "127.5", "-", "1", "\n", "\n", "out_dict", "=", "{", "}", "\n", "if", "self", ".", "local_classes", "is", "not", "None", ":", "\n", "            ", "out_dict", "[", "\"y\"", "]", "=", "np", ".", "array", "(", "self", ".", "local_classes", "[", "idx", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "", "return", "np", ".", "transpose", "(", "arr", ",", "[", "2", ",", "0", ",", "1", "]", ")", ",", "out_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.image_datasets.load_data": [[11, 68], ["image_datasets._list_image_files_recursively", "image_datasets.ImageDataset", "ValueError", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "mpi4py.MPI.COMM_WORLD.Get_rank", "mpi4py.MPI.COMM_WORLD.Get_size", "blobfile.basename().split", "enumerate", "sorted", "blobfile.basename", "set"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.image_datasets._list_image_files_recursively"], ["def", "load_data", "(", "\n", "*", ",", "\n", "data_dir", ",", "\n", "batch_size", ",", "\n", "image_size", ",", "\n", "class_cond", "=", "False", ",", "\n", "deterministic", "=", "False", ",", "\n", "random_crop", "=", "False", ",", "\n", "random_flip", "=", "True", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    For a dataset, create a generator over (images, kwargs) pairs.\n\n    Each images is an NCHW float tensor, and the kwargs dict contains zero or\n    more keys, each of which map to a batched Tensor of their own.\n    The kwargs dict can be used for class labels, in which case the key is \"y\"\n    and the values are integer tensors of class labels.\n\n    :param data_dir: a dataset directory.\n    :param batch_size: the batch size of each returned pair.\n    :param image_size: the size to which images are resized.\n    :param class_cond: if True, include a \"y\" key in returned dicts for class\n                       label. If classes are not available and this is true, an\n                       exception will be raised.\n    :param deterministic: if True, yield results in a deterministic order.\n    :param random_crop: if True, randomly crop the images for augmentation.\n    :param random_flip: if True, randomly flip the images for augmentation.\n    \"\"\"", "\n", "if", "not", "data_dir", ":", "\n", "        ", "raise", "ValueError", "(", "\"unspecified data directory\"", ")", "\n", "", "all_files", "=", "_list_image_files_recursively", "(", "data_dir", ")", "\n", "classes", "=", "None", "\n", "if", "class_cond", ":", "\n", "# Assume classes are the first part of the filename,", "\n", "# before an underscore.", "\n", "        ", "class_names", "=", "[", "bf", ".", "basename", "(", "path", ")", ".", "split", "(", "\"_\"", ")", "[", "0", "]", "for", "path", "in", "all_files", "]", "\n", "sorted_classes", "=", "{", "x", ":", "i", "for", "i", ",", "x", "in", "enumerate", "(", "sorted", "(", "set", "(", "class_names", ")", ")", ")", "}", "\n", "classes", "=", "[", "sorted_classes", "[", "x", "]", "for", "x", "in", "class_names", "]", "\n", "", "dataset", "=", "ImageDataset", "(", "\n", "image_size", ",", "\n", "all_files", ",", "\n", "classes", "=", "classes", ",", "\n", "shard", "=", "MPI", ".", "COMM_WORLD", ".", "Get_rank", "(", ")", ",", "\n", "num_shards", "=", "MPI", ".", "COMM_WORLD", ".", "Get_size", "(", ")", ",", "\n", "random_crop", "=", "random_crop", ",", "\n", "random_flip", "=", "random_flip", ",", "\n", ")", "\n", "if", "deterministic", ":", "\n", "        ", "loader", "=", "DataLoader", "(", "\n", "dataset", ",", "batch_size", "=", "batch_size", ",", "shuffle", "=", "False", ",", "num_workers", "=", "1", ",", "drop_last", "=", "True", "\n", ")", "\n", "", "else", ":", "\n", "        ", "loader", "=", "DataLoader", "(", "\n", "dataset", ",", "batch_size", "=", "batch_size", ",", "shuffle", "=", "True", ",", "num_workers", "=", "1", ",", "drop_last", "=", "True", "\n", ")", "\n", "", "while", "True", ":", "\n", "        ", "yield", "from", "loader", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.image_datasets._list_image_files_recursively": [[70, 80], ["sorted", "blobfile.listdir", "blobfile.join", "entry.split", "results.append", "blobfile.isdir", "ext.lower", "results.extend", "image_datasets._list_image_files_recursively"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.image_datasets._list_image_files_recursively"], ["", "", "def", "_list_image_files_recursively", "(", "data_dir", ")", ":", "\n", "    ", "results", "=", "[", "]", "\n", "for", "entry", "in", "sorted", "(", "bf", ".", "listdir", "(", "data_dir", ")", ")", ":", "\n", "        ", "full_path", "=", "bf", ".", "join", "(", "data_dir", ",", "entry", ")", "\n", "ext", "=", "entry", ".", "split", "(", "\".\"", ")", "[", "-", "1", "]", "\n", "if", "\".\"", "in", "entry", "and", "ext", ".", "lower", "(", ")", "in", "[", "\"jpg\"", ",", "\"jpeg\"", ",", "\"png\"", ",", "\"gif\"", "]", ":", "\n", "            ", "results", ".", "append", "(", "full_path", ")", "\n", "", "elif", "bf", ".", "isdir", "(", "full_path", ")", ":", "\n", "            ", "results", ".", "extend", "(", "_list_image_files_recursively", "(", "full_path", ")", ")", "\n", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.image_datasets.center_crop_arr": [[126, 144], ["pil_image.resize.resize", "numpy.array", "min", "pil_image.resize.resize", "min", "tuple", "tuple", "round"], "function", ["None"], ["", "", "def", "center_crop_arr", "(", "pil_image", ",", "image_size", ")", ":", "\n", "# We are not on a new enough PIL to support the `reducing_gap`", "\n", "# argument, which uses BOX downsampling at powers of two first.", "\n", "# Thus, we do it by hand to improve downsample quality.", "\n", "    ", "while", "min", "(", "*", "pil_image", ".", "size", ")", ">=", "2", "*", "image_size", ":", "\n", "        ", "pil_image", "=", "pil_image", ".", "resize", "(", "\n", "tuple", "(", "x", "//", "2", "for", "x", "in", "pil_image", ".", "size", ")", ",", "resample", "=", "Image", ".", "BOX", "\n", ")", "\n", "\n", "", "scale", "=", "image_size", "/", "min", "(", "*", "pil_image", ".", "size", ")", "\n", "pil_image", "=", "pil_image", ".", "resize", "(", "\n", "tuple", "(", "round", "(", "x", "*", "scale", ")", "for", "x", "in", "pil_image", ".", "size", ")", ",", "resample", "=", "Image", ".", "BICUBIC", "\n", ")", "\n", "\n", "arr", "=", "np", ".", "array", "(", "pil_image", ")", "\n", "crop_y", "=", "(", "arr", ".", "shape", "[", "0", "]", "-", "image_size", ")", "//", "2", "\n", "crop_x", "=", "(", "arr", ".", "shape", "[", "1", "]", "-", "image_size", ")", "//", "2", "\n", "return", "arr", "[", "crop_y", ":", "crop_y", "+", "image_size", ",", "crop_x", ":", "crop_x", "+", "image_size", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.image_datasets.random_crop_arr": [[146, 168], ["math.ceil", "math.ceil", "random.randrange", "pil_image.resize.resize", "numpy.array", "random.randrange", "random.randrange", "min", "pil_image.resize.resize", "min", "tuple", "tuple", "round"], "function", ["None"], ["", "def", "random_crop_arr", "(", "pil_image", ",", "image_size", ",", "min_crop_frac", "=", "0.8", ",", "max_crop_frac", "=", "1.0", ")", ":", "\n", "    ", "min_smaller_dim_size", "=", "math", ".", "ceil", "(", "image_size", "/", "max_crop_frac", ")", "\n", "max_smaller_dim_size", "=", "math", ".", "ceil", "(", "image_size", "/", "min_crop_frac", ")", "\n", "smaller_dim_size", "=", "random", ".", "randrange", "(", "min_smaller_dim_size", ",", "max_smaller_dim_size", "+", "1", ")", "\n", "\n", "# We are not on a new enough PIL to support the `reducing_gap`", "\n", "# argument, which uses BOX downsampling at powers of two first.", "\n", "# Thus, we do it by hand to improve downsample quality.", "\n", "while", "min", "(", "*", "pil_image", ".", "size", ")", ">=", "2", "*", "smaller_dim_size", ":", "\n", "        ", "pil_image", "=", "pil_image", ".", "resize", "(", "\n", "tuple", "(", "x", "//", "2", "for", "x", "in", "pil_image", ".", "size", ")", ",", "resample", "=", "Image", ".", "BOX", "\n", ")", "\n", "\n", "", "scale", "=", "smaller_dim_size", "/", "min", "(", "*", "pil_image", ".", "size", ")", "\n", "pil_image", "=", "pil_image", ".", "resize", "(", "\n", "tuple", "(", "round", "(", "x", "*", "scale", ")", "for", "x", "in", "pil_image", ".", "size", ")", ",", "resample", "=", "Image", ".", "BICUBIC", "\n", ")", "\n", "\n", "arr", "=", "np", ".", "array", "(", "pil_image", ")", "\n", "crop_y", "=", "random", ".", "randrange", "(", "arr", ".", "shape", "[", "0", "]", "-", "image_size", "+", "1", ")", "\n", "crop_x", "=", "random", ".", "randrange", "(", "arr", ".", "shape", "[", "1", "]", "-", "image_size", "+", "1", ")", "\n", "return", "arr", "[", "crop_y", ":", "crop_y", "+", "image_size", ",", "crop_x", ":", "crop_x", "+", "image_size", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.KVWriter.writekvs": [[27, 29], ["None"], "methods", ["None"], ["    ", "def", "writekvs", "(", "self", ",", "kvs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.SeqWriter.writeseq": [[32, 34], ["None"], "methods", ["None"], ["    ", "def", "writeseq", "(", "self", ",", "seq", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.HumanOutputFormat.__init__": [[37, 47], ["isinstance", "open", "hasattr"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "filename_or_file", ")", ":", "\n", "        ", "if", "isinstance", "(", "filename_or_file", ",", "str", ")", ":", "\n", "            ", "self", ".", "file", "=", "open", "(", "filename_or_file", ",", "\"wt\"", ")", "\n", "self", ".", "own_file", "=", "True", "\n", "", "else", ":", "\n", "            ", "assert", "hasattr", "(", "filename_or_file", ",", "\"read\"", ")", ",", "(", "\n", "\"expected file or str, got %s\"", "%", "filename_or_file", "\n", ")", "\n", "self", ".", "file", "=", "filename_or_file", "\n", "self", ".", "own_file", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.HumanOutputFormat.writekvs": [[48, 79], ["sorted", "sorted", "lines.append", "logger.HumanOutputFormat.file.write", "logger.HumanOutputFormat.file.flush", "kvs.items", "hasattr", "logger.HumanOutputFormat._truncate", "len", "print", "max", "max", "key2str.items", "lines.append", "str", "map", "map", "logger.HumanOutputFormat._truncate", "key2str.keys", "key2str.values", "kv[].lower", "len", "len"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.HumanOutputFormat._truncate", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.HumanOutputFormat._truncate"], ["", "", "def", "writekvs", "(", "self", ",", "kvs", ")", ":", "\n", "# Create strings for printing", "\n", "        ", "key2str", "=", "{", "}", "\n", "for", "(", "key", ",", "val", ")", "in", "sorted", "(", "kvs", ".", "items", "(", ")", ")", ":", "\n", "            ", "if", "hasattr", "(", "val", ",", "\"__float__\"", ")", ":", "\n", "                ", "valstr", "=", "\"%-8.3g\"", "%", "val", "\n", "", "else", ":", "\n", "                ", "valstr", "=", "str", "(", "val", ")", "\n", "", "key2str", "[", "self", ".", "_truncate", "(", "key", ")", "]", "=", "self", ".", "_truncate", "(", "valstr", ")", "\n", "\n", "# Find max widths", "\n", "", "if", "len", "(", "key2str", ")", "==", "0", ":", "\n", "            ", "print", "(", "\"WARNING: tried to write empty key-value dict\"", ")", "\n", "return", "\n", "", "else", ":", "\n", "            ", "keywidth", "=", "max", "(", "map", "(", "len", ",", "key2str", ".", "keys", "(", ")", ")", ")", "\n", "valwidth", "=", "max", "(", "map", "(", "len", ",", "key2str", ".", "values", "(", ")", ")", ")", "\n", "\n", "# Write out the data", "\n", "", "dashes", "=", "\"-\"", "*", "(", "keywidth", "+", "valwidth", "+", "7", ")", "\n", "lines", "=", "[", "dashes", "]", "\n", "for", "(", "key", ",", "val", ")", "in", "sorted", "(", "key2str", ".", "items", "(", ")", ",", "key", "=", "lambda", "kv", ":", "kv", "[", "0", "]", ".", "lower", "(", ")", ")", ":", "\n", "            ", "lines", ".", "append", "(", "\n", "\"| %s%s | %s%s |\"", "\n", "%", "(", "key", ",", "\" \"", "*", "(", "keywidth", "-", "len", "(", "key", ")", ")", ",", "val", ",", "\" \"", "*", "(", "valwidth", "-", "len", "(", "val", ")", ")", ")", "\n", ")", "\n", "", "lines", ".", "append", "(", "dashes", ")", "\n", "self", ".", "file", ".", "write", "(", "\"\\n\"", ".", "join", "(", "lines", ")", "+", "\"\\n\"", ")", "\n", "\n", "# Flush the output to the file", "\n", "self", ".", "file", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.HumanOutputFormat._truncate": [[80, 83], ["len"], "methods", ["None"], ["", "def", "_truncate", "(", "self", ",", "s", ")", ":", "\n", "        ", "maxlen", "=", "30", "\n", "return", "s", "[", ":", "maxlen", "-", "3", "]", "+", "\"...\"", "if", "len", "(", "s", ")", ">", "maxlen", "else", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.HumanOutputFormat.writeseq": [[84, 92], ["list", "enumerate", "logger.HumanOutputFormat.file.write", "logger.HumanOutputFormat.file.flush", "logger.HumanOutputFormat.file.write", "logger.HumanOutputFormat.file.write", "len"], "methods", ["None"], ["", "def", "writeseq", "(", "self", ",", "seq", ")", ":", "\n", "        ", "seq", "=", "list", "(", "seq", ")", "\n", "for", "(", "i", ",", "elem", ")", "in", "enumerate", "(", "seq", ")", ":", "\n", "            ", "self", ".", "file", ".", "write", "(", "elem", ")", "\n", "if", "i", "<", "len", "(", "seq", ")", "-", "1", ":", "# add space unless this is the last one", "\n", "                ", "self", ".", "file", ".", "write", "(", "\" \"", ")", "\n", "", "", "self", ".", "file", ".", "write", "(", "\"\\n\"", ")", "\n", "self", ".", "file", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.HumanOutputFormat.close": [[93, 96], ["logger.HumanOutputFormat.file.close"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.Logger.close"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "own_file", ":", "\n", "            ", "self", ".", "file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.JSONOutputFormat.__init__": [[99, 101], ["open"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "filename", ")", ":", "\n", "        ", "self", ".", "file", "=", "open", "(", "filename", ",", "\"wt\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.JSONOutputFormat.writekvs": [[102, 108], ["sorted", "logger.JSONOutputFormat.file.write", "logger.JSONOutputFormat.file.flush", "kvs.items", "hasattr", "float", "json.dumps"], "methods", ["None"], ["", "def", "writekvs", "(", "self", ",", "kvs", ")", ":", "\n", "        ", "for", "k", ",", "v", "in", "sorted", "(", "kvs", ".", "items", "(", ")", ")", ":", "\n", "            ", "if", "hasattr", "(", "v", ",", "\"dtype\"", ")", ":", "\n", "                ", "kvs", "[", "k", "]", "=", "float", "(", "v", ")", "\n", "", "", "self", ".", "file", ".", "write", "(", "json", ".", "dumps", "(", "kvs", ")", "+", "\"\\n\"", ")", "\n", "self", ".", "file", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.JSONOutputFormat.close": [[109, 111], ["logger.JSONOutputFormat.file.close"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.Logger.close"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "self", ".", "file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.CSVOutputFormat.__init__": [[114, 118], ["open"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "filename", ")", ":", "\n", "        ", "self", ".", "file", "=", "open", "(", "filename", ",", "\"w+t\"", ")", "\n", "self", ".", "keys", "=", "[", "]", "\n", "self", ".", "sep", "=", "\",\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.CSVOutputFormat.writekvs": [[119, 145], ["list", "list.sort", "enumerate", "logger.CSVOutputFormat.file.write", "logger.CSVOutputFormat.file.flush", "logger.CSVOutputFormat.keys.extend", "logger.CSVOutputFormat.file.seek", "logger.CSVOutputFormat.file.readlines", "logger.CSVOutputFormat.file.seek", "enumerate", "logger.CSVOutputFormat.file.write", "kvs.get", "kvs.keys", "logger.CSVOutputFormat.file.write", "logger.CSVOutputFormat.file.write", "logger.CSVOutputFormat.file.write", "logger.CSVOutputFormat.file.write", "logger.CSVOutputFormat.file.write", "logger.CSVOutputFormat.file.write", "logger.CSVOutputFormat.file.write", "str", "len"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.insightface_func.face_detect_crop_single.Face_detect_crop.get"], ["", "def", "writekvs", "(", "self", ",", "kvs", ")", ":", "\n", "# Add our current row to the history", "\n", "        ", "extra_keys", "=", "list", "(", "kvs", ".", "keys", "(", ")", "-", "self", ".", "keys", ")", "\n", "extra_keys", ".", "sort", "(", ")", "\n", "if", "extra_keys", ":", "\n", "            ", "self", ".", "keys", ".", "extend", "(", "extra_keys", ")", "\n", "self", ".", "file", ".", "seek", "(", "0", ")", "\n", "lines", "=", "self", ".", "file", ".", "readlines", "(", ")", "\n", "self", ".", "file", ".", "seek", "(", "0", ")", "\n", "for", "(", "i", ",", "k", ")", "in", "enumerate", "(", "self", ".", "keys", ")", ":", "\n", "                ", "if", "i", ">", "0", ":", "\n", "                    ", "self", ".", "file", ".", "write", "(", "\",\"", ")", "\n", "", "self", ".", "file", ".", "write", "(", "k", ")", "\n", "", "self", ".", "file", ".", "write", "(", "\"\\n\"", ")", "\n", "for", "line", "in", "lines", "[", "1", ":", "]", ":", "\n", "                ", "self", ".", "file", ".", "write", "(", "line", "[", ":", "-", "1", "]", ")", "\n", "self", ".", "file", ".", "write", "(", "self", ".", "sep", "*", "len", "(", "extra_keys", ")", ")", "\n", "self", ".", "file", ".", "write", "(", "\"\\n\"", ")", "\n", "", "", "for", "(", "i", ",", "k", ")", "in", "enumerate", "(", "self", ".", "keys", ")", ":", "\n", "            ", "if", "i", ">", "0", ":", "\n", "                ", "self", ".", "file", ".", "write", "(", "\",\"", ")", "\n", "", "v", "=", "kvs", ".", "get", "(", "k", ")", "\n", "if", "v", "is", "not", "None", ":", "\n", "                ", "self", ".", "file", ".", "write", "(", "str", "(", "v", ")", ")", "\n", "", "", "self", ".", "file", ".", "write", "(", "\"\\n\"", ")", "\n", "self", ".", "file", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.CSVOutputFormat.close": [[146, 148], ["logger.CSVOutputFormat.file.close"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.Logger.close"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "self", ".", "file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.TensorBoardOutputFormat.__init__": [[155, 170], ["os.makedirs", "os.makedirs", "os.makedirs", "os.makedirs", "os.join", "os.join", "pywrap_tensorflow.EventsWriter", "os.abspath", "os.abspath", "compat.as_bytes"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "dir", ",", "exist_ok", "=", "True", ")", "\n", "self", ".", "dir", "=", "dir", "\n", "self", ".", "step", "=", "1", "\n", "prefix", "=", "\"events\"", "\n", "path", "=", "osp", ".", "join", "(", "osp", ".", "abspath", "(", "dir", ")", ",", "prefix", ")", "\n", "import", "tensorflow", "as", "tf", "\n", "from", "tensorflow", ".", "python", "import", "pywrap_tensorflow", "\n", "from", "tensorflow", ".", "core", ".", "util", "import", "event_pb2", "\n", "from", "tensorflow", ".", "python", ".", "util", "import", "compat", "\n", "\n", "self", ".", "tf", "=", "tf", "\n", "self", ".", "event_pb2", "=", "event_pb2", "\n", "self", ".", "pywrap_tensorflow", "=", "pywrap_tensorflow", "\n", "self", ".", "writer", "=", "pywrap_tensorflow", ".", "EventsWriter", "(", "compat", ".", "as_bytes", "(", "path", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.TensorBoardOutputFormat.writekvs": [[171, 184], ["logger.TensorBoardOutputFormat.tf.Summary", "logger.TensorBoardOutputFormat.event_pb2.Event", "logger.TensorBoardOutputFormat.writer.WriteEvent", "logger.TensorBoardOutputFormat.writer.Flush", "logger.TensorBoardOutputFormat.tf.Summary.Value", "float", "time.time", "logger.TensorBoardOutputFormat.writekvs.summary_val"], "methods", ["None"], ["", "def", "writekvs", "(", "self", ",", "kvs", ")", ":", "\n", "        ", "def", "summary_val", "(", "k", ",", "v", ")", ":", "\n", "            ", "kwargs", "=", "{", "\"tag\"", ":", "k", ",", "\"simple_value\"", ":", "float", "(", "v", ")", "}", "\n", "return", "self", ".", "tf", ".", "Summary", ".", "Value", "(", "**", "kwargs", ")", "\n", "\n", "", "summary", "=", "self", ".", "tf", ".", "Summary", "(", "value", "=", "[", "summary_val", "(", "k", ",", "v", ")", "for", "k", ",", "v", "in", "kvs", ".", "items", "(", ")", "]", ")", "\n", "event", "=", "self", ".", "event_pb2", ".", "Event", "(", "wall_time", "=", "time", ".", "time", "(", ")", ",", "summary", "=", "summary", ")", "\n", "event", ".", "step", "=", "(", "\n", "self", ".", "step", "\n", ")", "# is there any reason why you'd want to specify the step?", "\n", "self", ".", "writer", ".", "WriteEvent", "(", "event", ")", "\n", "self", ".", "writer", ".", "Flush", "(", ")", "\n", "self", ".", "step", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.TensorBoardOutputFormat.close": [[185, 189], ["logger.TensorBoardOutputFormat.writer.Close"], "methods", ["None"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "writer", ":", "\n", "            ", "self", ".", "writer", ".", "Close", "(", ")", "\n", "self", ".", "writer", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.Logger.__init__": [[337, 344], ["collections.defaultdict", "collections.defaultdict"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "dir", ",", "output_formats", ",", "comm", "=", "None", ")", ":", "\n", "        ", "self", ".", "name2val", "=", "defaultdict", "(", "float", ")", "# values this iteration", "\n", "self", ".", "name2cnt", "=", "defaultdict", "(", "int", ")", "\n", "self", ".", "level", "=", "INFO", "\n", "self", ".", "dir", "=", "dir", "\n", "self", ".", "output_formats", "=", "output_formats", "\n", "self", ".", "comm", "=", "comm", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.Logger.logkv": [[347, 349], ["None"], "methods", ["None"], ["", "def", "logkv", "(", "self", ",", "key", ",", "val", ")", ":", "\n", "        ", "self", ".", "name2val", "[", "key", "]", "=", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.Logger.logkv_mean": [[350, 354], ["None"], "methods", ["None"], ["", "def", "logkv_mean", "(", "self", ",", "key", ",", "val", ")", ":", "\n", "        ", "oldval", ",", "cnt", "=", "self", ".", "name2val", "[", "key", "]", ",", "self", ".", "name2cnt", "[", "key", "]", "\n", "self", ".", "name2val", "[", "key", "]", "=", "oldval", "*", "cnt", "/", "(", "cnt", "+", "1", ")", "+", "val", "/", "(", "cnt", "+", "1", ")", "\n", "self", ".", "name2cnt", "[", "key", "]", "=", "cnt", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.Logger.dumpkvs": [[355, 375], ["mpi_weighted_mean.copy", "logger.Logger.name2val.clear", "logger.Logger.name2cnt.clear", "logger.mpi_weighted_mean", "isinstance", "fmt.writekvs", "logger.Logger.name2cnt.get", "logger.Logger.name2val.items"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.mpi_weighted_mean", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.TensorBoardOutputFormat.writekvs", "home.repos.pwc.inspect_result.ailon-island_facke.insightface_func.face_detect_crop_single.Face_detect_crop.get"], ["", "def", "dumpkvs", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "comm", "is", "None", ":", "\n", "            ", "d", "=", "self", ".", "name2val", "\n", "", "else", ":", "\n", "            ", "d", "=", "mpi_weighted_mean", "(", "\n", "self", ".", "comm", ",", "\n", "{", "\n", "name", ":", "(", "val", ",", "self", ".", "name2cnt", ".", "get", "(", "name", ",", "1", ")", ")", "\n", "for", "(", "name", ",", "val", ")", "in", "self", ".", "name2val", ".", "items", "(", ")", "\n", "}", ",", "\n", ")", "\n", "if", "self", ".", "comm", ".", "rank", "!=", "0", ":", "\n", "                ", "d", "[", "\"dummy\"", "]", "=", "1", "# so we don't get a warning about empty dict", "\n", "", "", "out", "=", "d", ".", "copy", "(", ")", "# Return the dict for unit testing purposes", "\n", "for", "fmt", "in", "self", ".", "output_formats", ":", "\n", "            ", "if", "isinstance", "(", "fmt", ",", "KVWriter", ")", ":", "\n", "                ", "fmt", ".", "writekvs", "(", "d", ")", "\n", "", "", "self", ".", "name2val", ".", "clear", "(", ")", "\n", "self", ".", "name2cnt", ".", "clear", "(", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.Logger.log": [[376, 379], ["logger.Logger._do_log"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.Logger._do_log"], ["", "def", "log", "(", "self", ",", "*", "args", ",", "level", "=", "INFO", ")", ":", "\n", "        ", "if", "self", ".", "level", "<=", "level", ":", "\n", "            ", "self", ".", "_do_log", "(", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.Logger.set_level": [[382, 384], ["None"], "methods", ["None"], ["", "", "def", "set_level", "(", "self", ",", "level", ")", ":", "\n", "        ", "self", ".", "level", "=", "level", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.Logger.set_comm": [[385, 387], ["None"], "methods", ["None"], ["", "def", "set_comm", "(", "self", ",", "comm", ")", ":", "\n", "        ", "self", ".", "comm", "=", "comm", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.Logger.get_dir": [[388, 390], ["None"], "methods", ["None"], ["", "def", "get_dir", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "dir", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.Logger.close": [[391, 394], ["fmt.close"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.Logger.close"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "for", "fmt", "in", "self", ".", "output_formats", ":", "\n", "            ", "fmt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.Logger._do_log": [[397, 401], ["isinstance", "fmt.writeseq", "map"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.HumanOutputFormat.writeseq"], ["", "", "def", "_do_log", "(", "self", ",", "args", ")", ":", "\n", "        ", "for", "fmt", "in", "self", ".", "output_formats", ":", "\n", "            ", "if", "isinstance", "(", "fmt", ",", "SeqWriter", ")", ":", "\n", "                ", "fmt", ".", "writeseq", "(", "map", "(", "str", ",", "args", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.make_output_format": [[191, 205], ["os.makedirs", "os.makedirs", "logger.HumanOutputFormat", "logger.HumanOutputFormat", "os.join", "logger.JSONOutputFormat", "os.join", "logger.CSVOutputFormat", "os.join", "logger.TensorBoardOutputFormat", "ValueError", "os.join"], "function", ["None"], ["", "", "", "def", "make_output_format", "(", "format", ",", "ev_dir", ",", "log_suffix", "=", "\"\"", ")", ":", "\n", "    ", "os", ".", "makedirs", "(", "ev_dir", ",", "exist_ok", "=", "True", ")", "\n", "if", "format", "==", "\"stdout\"", ":", "\n", "        ", "return", "HumanOutputFormat", "(", "sys", ".", "stdout", ")", "\n", "", "elif", "format", "==", "\"log\"", ":", "\n", "        ", "return", "HumanOutputFormat", "(", "osp", ".", "join", "(", "ev_dir", ",", "\"log%s.txt\"", "%", "log_suffix", ")", ")", "\n", "", "elif", "format", "==", "\"json\"", ":", "\n", "        ", "return", "JSONOutputFormat", "(", "osp", ".", "join", "(", "ev_dir", ",", "\"progress%s.json\"", "%", "log_suffix", ")", ")", "\n", "", "elif", "format", "==", "\"csv\"", ":", "\n", "        ", "return", "CSVOutputFormat", "(", "osp", ".", "join", "(", "ev_dir", ",", "\"progress%s.csv\"", "%", "log_suffix", ")", ")", "\n", "", "elif", "format", "==", "\"tensorboard\"", ":", "\n", "        ", "return", "TensorBoardOutputFormat", "(", "osp", ".", "join", "(", "ev_dir", ",", "\"tb%s\"", "%", "log_suffix", ")", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Unknown format specified: %s\"", "%", "(", "format", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.logkv": [[212, 219], ["get_current().logkv", "logger.get_current"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.logkv", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.get_current"], ["", "", "def", "logkv", "(", "key", ",", "val", ")", ":", "\n", "    ", "\"\"\"\n    Log a value of some diagnostic\n    Call this once for each diagnostic quantity, each iteration\n    If called many times, last value will be used.\n    \"\"\"", "\n", "get_current", "(", ")", ".", "logkv", "(", "key", ",", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.logkv_mean": [[221, 226], ["get_current().logkv_mean", "logger.get_current"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.logkv_mean", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.get_current"], ["", "def", "logkv_mean", "(", "key", ",", "val", ")", ":", "\n", "    ", "\"\"\"\n    The same as logkv(), but if called many times, values averaged.\n    \"\"\"", "\n", "get_current", "(", ")", ".", "logkv_mean", "(", "key", ",", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.logkvs": [[228, 234], ["d.items", "logger.logkv"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.logkv"], ["", "def", "logkvs", "(", "d", ")", ":", "\n", "    ", "\"\"\"\n    Log a dictionary of key-value pairs\n    \"\"\"", "\n", "for", "(", "k", ",", "v", ")", "in", "d", ".", "items", "(", ")", ":", "\n", "        ", "logkv", "(", "k", ",", "v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.dumpkvs": [[236, 241], ["get_current().dumpkvs", "logger.get_current"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.dumpkvs", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.get_current"], ["", "", "def", "dumpkvs", "(", ")", ":", "\n", "    ", "\"\"\"\n    Write all of the diagnostics from the current iteration\n    \"\"\"", "\n", "return", "get_current", "(", ")", ".", "dumpkvs", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.getkvs": [[243, 245], ["logger.get_current"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.get_current"], ["", "def", "getkvs", "(", ")", ":", "\n", "    ", "return", "get_current", "(", ")", ".", "name2val", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log": [[247, 252], ["get_current().log", "logger.get_current"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.get_current"], ["", "def", "log", "(", "*", "args", ",", "level", "=", "INFO", ")", ":", "\n", "    ", "\"\"\"\n    Write the sequence of args, with no separators, to the console and output files (if you've configured an output file).\n    \"\"\"", "\n", "get_current", "(", ")", ".", "log", "(", "*", "args", ",", "level", "=", "level", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.debug": [[254, 256], ["logger.log"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log"], ["", "def", "debug", "(", "*", "args", ")", ":", "\n", "    ", "log", "(", "*", "args", ",", "level", "=", "DEBUG", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.info": [[258, 260], ["logger.log"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log"], ["", "def", "info", "(", "*", "args", ")", ":", "\n", "    ", "log", "(", "*", "args", ",", "level", "=", "INFO", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.warn": [[262, 264], ["logger.log"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log"], ["", "def", "warn", "(", "*", "args", ")", ":", "\n", "    ", "log", "(", "*", "args", ",", "level", "=", "WARN", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.error": [[266, 268], ["logger.log"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log"], ["", "def", "error", "(", "*", "args", ")", ":", "\n", "    ", "log", "(", "*", "args", ",", "level", "=", "ERROR", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.set_level": [[270, 275], ["get_current().set_level", "logger.get_current"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.set_level", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.get_current"], ["", "def", "set_level", "(", "level", ")", ":", "\n", "    ", "\"\"\"\n    Set logging threshold on current logger.\n    \"\"\"", "\n", "get_current", "(", ")", ".", "set_level", "(", "level", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.set_comm": [[277, 279], ["get_current().set_comm", "logger.get_current"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.set_comm", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.get_current"], ["", "def", "set_comm", "(", "comm", ")", ":", "\n", "    ", "get_current", "(", ")", ".", "set_comm", "(", "comm", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.get_dir": [[281, 287], ["get_current().get_dir", "logger.get_current"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.get_dir", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.get_current"], ["", "def", "get_dir", "(", ")", ":", "\n", "    ", "\"\"\"\n    Get directory that log files are being written to.\n    will be None if there is no output directory (i.e., if you didn't call start)\n    \"\"\"", "\n", "return", "get_current", "(", ")", ".", "get_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.profile_kv": [[293, 301], ["time.time", "time.time", "logger.get_current"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.get_current"], ["@", "contextmanager", "\n", "def", "profile_kv", "(", "scopename", ")", ":", "\n", "    ", "logkey", "=", "\"wait_\"", "+", "scopename", "\n", "tstart", "=", "time", ".", "time", "(", ")", "\n", "try", ":", "\n", "        ", "yield", "\n", "", "finally", ":", "\n", "        ", "get_current", "(", ")", ".", "name2val", "[", "logkey", "]", "+=", "time", ".", "time", "(", ")", "-", "tstart", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.profile": [[303, 318], ["logger.profile_kv", "func"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.profile_kv"], ["", "", "def", "profile", "(", "n", ")", ":", "\n", "    ", "\"\"\"\n    Usage:\n    @profile(\"my_func\")\n    def my_func(): code\n    \"\"\"", "\n", "\n", "def", "decorator_with_name", "(", "func", ")", ":", "\n", "        ", "def", "func_wrapper", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "            ", "with", "profile_kv", "(", "n", ")", ":", "\n", "                ", "return", "func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "", "return", "func_wrapper", "\n", "\n", "", "return", "decorator_with_name", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.get_current": [[325, 330], ["logger._configure_default_logger"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger._configure_default_logger"], ["", "def", "get_current", "(", ")", ":", "\n", "    ", "if", "Logger", ".", "CURRENT", "is", "None", ":", "\n", "        ", "_configure_default_logger", "(", ")", "\n", "\n", "", "return", "Logger", ".", "CURRENT", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.get_rank_without_mpi_import": [[403, 410], ["int"], "function", ["None"], ["", "", "", "", "def", "get_rank_without_mpi_import", "(", ")", ":", "\n", "# check environment variables here instead of importing mpi4py", "\n", "# to avoid calling MPI_Init() when this module is imported", "\n", "    ", "for", "varname", "in", "[", "\"PMI_RANK\"", ",", "\"OMPI_COMM_WORLD_RANK\"", "]", ":", "\n", "        ", "if", "varname", "in", "os", ".", "environ", ":", "\n", "            ", "return", "int", "(", "os", ".", "environ", "[", "varname", "]", ")", "\n", "", "", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.mpi_weighted_mean": [[412, 440], ["comm.gather", "collections.defaultdict", "collections.defaultdict", "n2vc.items", "float", "warnings.warn"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.warn"], ["", "def", "mpi_weighted_mean", "(", "comm", ",", "local_name2valcount", ")", ":", "\n", "    ", "\"\"\"\n    Copied from: https://github.com/openai/baselines/blob/ea25b9e8b234e6ee1bca43083f8f3cf974143998/baselines/common/mpi_util.py#L110\n    Perform a weighted average over dicts that are each on a different node\n    Input: local_name2valcount: dict mapping key -> (value, count)\n    Returns: key -> mean\n    \"\"\"", "\n", "all_name2valcount", "=", "comm", ".", "gather", "(", "local_name2valcount", ")", "\n", "if", "comm", ".", "rank", "==", "0", ":", "\n", "        ", "name2sum", "=", "defaultdict", "(", "float", ")", "\n", "name2count", "=", "defaultdict", "(", "float", ")", "\n", "for", "n2vc", "in", "all_name2valcount", ":", "\n", "            ", "for", "(", "name", ",", "(", "val", ",", "count", ")", ")", "in", "n2vc", ".", "items", "(", ")", ":", "\n", "                ", "try", ":", "\n", "                    ", "val", "=", "float", "(", "val", ")", "\n", "", "except", "ValueError", ":", "\n", "                    ", "if", "comm", ".", "rank", "==", "0", ":", "\n", "                        ", "warnings", ".", "warn", "(", "\n", "\"WARNING: tried to compute mean on non-float {}={}\"", ".", "format", "(", "\n", "name", ",", "val", "\n", ")", "\n", ")", "\n", "", "", "else", ":", "\n", "                    ", "name2sum", "[", "name", "]", "+=", "val", "*", "count", "\n", "name2count", "[", "name", "]", "+=", "count", "\n", "", "", "", "return", "{", "name", ":", "name2sum", "[", "name", "]", "/", "name2count", "[", "name", "]", "for", "name", "in", "name2sum", "}", "\n", "", "else", ":", "\n", "        ", "return", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.configure": [[442, 472], ["isinstance", "os.path.expanduser", "os.path.expanduser", "os.makedirs", "os.makedirs", "logger.get_rank_without_mpi_import", "filter", "logger.Logger", "os.getenv", "os.getenv", "os.join", "os.path.expanduser", "os.path.expanduser", "logger.make_output_format", "logger.log", "tempfile.gettempdir", "datetime.datetime.now().strftime", "os.getenv().split", "os.getenv().split", "os.getenv().split", "os.getenv().split", "datetime.datetime.now", "os.getenv", "os.getenv", "os.getenv", "os.getenv"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.get_rank_without_mpi_import", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.make_output_format", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log"], ["", "", "def", "configure", "(", "dir", "=", "None", ",", "format_strs", "=", "None", ",", "comm", "=", "None", ",", "log_suffix", "=", "\"\"", ")", ":", "\n", "    ", "\"\"\"\n    If comm is provided, average all numerical stats across that comm\n    \"\"\"", "\n", "if", "dir", "is", "None", ":", "\n", "        ", "dir", "=", "os", ".", "getenv", "(", "\"OPENAI_LOGDIR\"", ")", "\n", "", "if", "dir", "is", "None", ":", "\n", "        ", "dir", "=", "osp", ".", "join", "(", "\n", "tempfile", ".", "gettempdir", "(", ")", ",", "\n", "datetime", ".", "datetime", ".", "now", "(", ")", ".", "strftime", "(", "\"openai-%Y-%m-%d-%H-%M-%S-%f\"", ")", ",", "\n", ")", "\n", "", "assert", "isinstance", "(", "dir", ",", "str", ")", "\n", "dir", "=", "os", ".", "path", ".", "expanduser", "(", "dir", ")", "\n", "os", ".", "makedirs", "(", "os", ".", "path", ".", "expanduser", "(", "dir", ")", ",", "exist_ok", "=", "True", ")", "\n", "\n", "rank", "=", "get_rank_without_mpi_import", "(", ")", "\n", "if", "rank", ">", "0", ":", "\n", "        ", "log_suffix", "=", "log_suffix", "+", "\"-rank%03i\"", "%", "rank", "\n", "\n", "", "if", "format_strs", "is", "None", ":", "\n", "        ", "if", "rank", "==", "0", ":", "\n", "            ", "format_strs", "=", "os", ".", "getenv", "(", "\"OPENAI_LOG_FORMAT\"", ",", "\"stdout,log,csv\"", ")", ".", "split", "(", "\",\"", ")", "\n", "", "else", ":", "\n", "            ", "format_strs", "=", "os", ".", "getenv", "(", "\"OPENAI_LOG_FORMAT_MPI\"", ",", "\"log\"", ")", ".", "split", "(", "\",\"", ")", "\n", "", "", "format_strs", "=", "filter", "(", "None", ",", "format_strs", ")", "\n", "output_formats", "=", "[", "make_output_format", "(", "f", ",", "dir", ",", "log_suffix", ")", "for", "f", "in", "format_strs", "]", "\n", "\n", "Logger", ".", "CURRENT", "=", "Logger", "(", "dir", "=", "dir", ",", "output_formats", "=", "output_formats", ",", "comm", "=", "comm", ")", "\n", "if", "output_formats", ":", "\n", "        ", "log", "(", "\"Logging to %s\"", "%", "dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger._configure_default_logger": [[474, 477], ["logger.configure"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.configure"], ["", "", "def", "_configure_default_logger", "(", ")", ":", "\n", "    ", "configure", "(", ")", "\n", "Logger", ".", "DEFAULT", "=", "Logger", ".", "CURRENT", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.reset": [[479, 484], ["Logger.CURRENT.close", "logger.log"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.Logger.close", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log"], ["", "def", "reset", "(", ")", ":", "\n", "    ", "if", "Logger", ".", "CURRENT", "is", "not", "Logger", ".", "DEFAULT", ":", "\n", "        ", "Logger", ".", "CURRENT", ".", "close", "(", ")", "\n", "Logger", ".", "CURRENT", "=", "Logger", ".", "DEFAULT", "\n", "log", "(", "\"Reset logger\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.scoped_configure": [[486, 495], ["logger.configure", "Logger.CURRENT.close"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.configure", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.Logger.close"], ["", "", "@", "contextmanager", "\n", "def", "scoped_configure", "(", "dir", "=", "None", ",", "format_strs", "=", "None", ",", "comm", "=", "None", ")", ":", "\n", "    ", "prevlogger", "=", "Logger", ".", "CURRENT", "\n", "configure", "(", "dir", "=", "dir", ",", "format_strs", "=", "format_strs", ",", "comm", "=", "comm", ")", "\n", "try", ":", "\n", "        ", "yield", "\n", "", "finally", ":", "\n", "        ", "Logger", ".", "CURRENT", ".", "close", "(", ")", "\n", "Logger", ".", "CURRENT", "=", "prevlogger", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.SiLU.forward": [[13, 15], ["torch.sigmoid", "torch.sigmoid"], "methods", ["None"], ["    ", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "*", "th", ".", "sigmoid", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.GroupNorm32.forward": [[18, 20], ["super().forward().type", "super().forward", "x.float"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.forward"], ["    ", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "forward", "(", "x", ".", "float", "(", ")", ")", ".", "type", "(", "x", ".", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.CheckpointFunction.forward": [[143, 151], ["list", "list", "torch.no_grad", "torch.no_grad", "ctx.run_function"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "run_function", ",", "length", ",", "*", "args", ")", ":", "\n", "        ", "ctx", ".", "run_function", "=", "run_function", "\n", "ctx", ".", "input_tensors", "=", "list", "(", "args", "[", ":", "length", "]", ")", "\n", "ctx", ".", "input_params", "=", "list", "(", "args", "[", "length", ":", "]", ")", "\n", "with", "th", ".", "no_grad", "(", ")", ":", "\n", "            ", "output_tensors", "=", "ctx", ".", "run_function", "(", "*", "ctx", ".", "input_tensors", ")", "\n", "", "return", "output_tensors", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.CheckpointFunction.backward": [[152, 171], ["torch.autograd.grad", "torch.autograd.grad", "x.detach().requires_grad_", "torch.enable_grad", "torch.enable_grad", "ctx.run_function", "x.view_as", "x.detach"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "*", "output_grads", ")", ":", "\n", "        ", "ctx", ".", "input_tensors", "=", "[", "x", ".", "detach", "(", ")", ".", "requires_grad_", "(", "True", ")", "for", "x", "in", "ctx", ".", "input_tensors", "]", "\n", "with", "th", ".", "enable_grad", "(", ")", ":", "\n", "# Fixes a bug where the first op in run_function modifies the", "\n", "# Tensor storage in place, which is not allowed for detach()'d", "\n", "# Tensors.", "\n", "            ", "shallow_copies", "=", "[", "x", ".", "view_as", "(", "x", ")", "for", "x", "in", "ctx", ".", "input_tensors", "]", "\n", "output_tensors", "=", "ctx", ".", "run_function", "(", "*", "shallow_copies", ")", "\n", "", "input_grads", "=", "th", ".", "autograd", ".", "grad", "(", "\n", "output_tensors", ",", "\n", "ctx", ".", "input_tensors", "+", "ctx", ".", "input_params", ",", "\n", "output_grads", ",", "\n", "allow_unused", "=", "True", ",", "\n", ")", "\n", "del", "ctx", ".", "input_tensors", "\n", "del", "ctx", ".", "input_params", "\n", "del", "output_tensors", "\n", "return", "(", "None", ",", "None", ")", "+", "input_grads", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.conv_nd": [[22, 33], ["ValueError", "torch.Conv1d", "torch.Conv2d", "torch.Conv3d"], "function", ["None"], ["", "", "def", "conv_nd", "(", "dims", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Create a 1D, 2D, or 3D convolution module.\n    \"\"\"", "\n", "if", "dims", "==", "1", ":", "\n", "        ", "return", "nn", ".", "Conv1d", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "elif", "dims", "==", "2", ":", "\n", "        ", "return", "nn", ".", "Conv2d", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "elif", "dims", "==", "3", ":", "\n", "        ", "return", "nn", ".", "Conv3d", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "raise", "ValueError", "(", "f\"unsupported dimensions: {dims}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.linear": [[35, 40], ["torch.Linear"], "function", ["None"], ["", "def", "linear", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Create a linear module.\n    \"\"\"", "\n", "return", "nn", ".", "Linear", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.avg_pool_nd": [[42, 53], ["ValueError", "torch.AvgPool1d", "torch.AvgPool2d", "torch.AvgPool3d"], "function", ["None"], ["", "def", "avg_pool_nd", "(", "dims", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Create a 1D, 2D, or 3D average pooling module.\n    \"\"\"", "\n", "if", "dims", "==", "1", ":", "\n", "        ", "return", "nn", ".", "AvgPool1d", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "elif", "dims", "==", "2", ":", "\n", "        ", "return", "nn", ".", "AvgPool2d", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "elif", "dims", "==", "3", ":", "\n", "        ", "return", "nn", ".", "AvgPool3d", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "raise", "ValueError", "(", "f\"unsupported dimensions: {dims}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.update_ema": [[55, 66], ["zip", "targ.detach().mul_().add_", "targ.detach().mul_", "targ.detach"], "function", ["None"], ["", "def", "update_ema", "(", "target_params", ",", "source_params", ",", "rate", "=", "0.99", ")", ":", "\n", "    ", "\"\"\"\n    Update target parameters to be closer to those of source parameters using\n    an exponential moving average.\n\n    :param target_params: the target parameter sequence.\n    :param source_params: the source parameter sequence.\n    :param rate: the EMA rate (closer to 1 means slower).\n    \"\"\"", "\n", "for", "targ", ",", "src", "in", "zip", "(", "target_params", ",", "source_params", ")", ":", "\n", "        ", "targ", ".", "detach", "(", ")", ".", "mul_", "(", "rate", ")", ".", "add_", "(", "src", ",", "alpha", "=", "1", "-", "rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.zero_module": [[68, 75], ["module.parameters", "p.detach().zero_", "p.detach"], "function", ["None"], ["", "", "def", "zero_module", "(", "module", ")", ":", "\n", "    ", "\"\"\"\n    Zero out the parameters of a module and return it.\n    \"\"\"", "\n", "for", "p", "in", "module", ".", "parameters", "(", ")", ":", "\n", "        ", "p", ".", "detach", "(", ")", ".", "zero_", "(", ")", "\n", "", "return", "module", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.scale_module": [[77, 84], ["module.parameters", "p.detach().mul_", "p.detach"], "function", ["None"], ["", "def", "scale_module", "(", "module", ",", "scale", ")", ":", "\n", "    ", "\"\"\"\n    Scale the parameters of a module and return it.\n    \"\"\"", "\n", "for", "p", "in", "module", ".", "parameters", "(", ")", ":", "\n", "        ", "p", ".", "detach", "(", ")", ".", "mul_", "(", "scale", ")", "\n", "", "return", "module", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.mean_flat": [[86, 91], ["tensor.mean", "list", "range", "len"], "function", ["None"], ["", "def", "mean_flat", "(", "tensor", ")", ":", "\n", "    ", "\"\"\"\n    Take the mean over all non-batch dimensions.\n    \"\"\"", "\n", "return", "tensor", ".", "mean", "(", "dim", "=", "list", "(", "range", "(", "1", ",", "len", "(", "tensor", ".", "shape", ")", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.normalization": [[93, 101], ["nn.GroupNorm32"], "function", ["None"], ["", "def", "normalization", "(", "channels", ")", ":", "\n", "    ", "\"\"\"\n    Make a standard normalization layer.\n\n    :param channels: number of input channels.\n    :return: an nn.Module for normalization.\n    \"\"\"", "\n", "return", "GroupNorm32", "(", "32", ",", "channels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.timestep_embedding": [[103, 122], ["torch.exp().to", "torch.cat", "timesteps[].float", "torch.cat", "torch.exp", "torch.cos", "torch.sin", "torch.zeros_like", "torch.arange", "math.log"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log"], ["", "def", "timestep_embedding", "(", "timesteps", ",", "dim", ",", "max_period", "=", "10000", ")", ":", "\n", "    ", "\"\"\"\n    Create sinusoidal timestep embeddings.\n\n    :param timesteps: a 1-D Tensor of N indices, one per batch element.\n                      These may be fractional.\n    :param dim: the dimension of the output.\n    :param max_period: controls the minimum frequency of the embeddings.\n    :return: an [N x dim] Tensor of positional embeddings.\n    \"\"\"", "\n", "half", "=", "dim", "//", "2", "\n", "freqs", "=", "th", ".", "exp", "(", "\n", "-", "math", ".", "log", "(", "max_period", ")", "*", "th", ".", "arange", "(", "start", "=", "0", ",", "end", "=", "half", ",", "dtype", "=", "th", ".", "float32", ")", "/", "half", "\n", ")", ".", "to", "(", "device", "=", "timesteps", ".", "device", ")", "\n", "args", "=", "timesteps", "[", ":", ",", "None", "]", ".", "float", "(", ")", "*", "freqs", "[", "None", "]", "\n", "embedding", "=", "th", ".", "cat", "(", "[", "th", ".", "cos", "(", "args", ")", ",", "th", ".", "sin", "(", "args", ")", "]", ",", "dim", "=", "-", "1", ")", "\n", "if", "dim", "%", "2", ":", "\n", "        ", "embedding", "=", "th", ".", "cat", "(", "[", "embedding", ",", "th", ".", "zeros_like", "(", "embedding", "[", ":", ",", ":", "1", "]", ")", "]", ",", "dim", "=", "-", "1", ")", "\n", "", "return", "embedding", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.checkpoint": [[124, 140], ["CheckpointFunction.apply", "func", "tuple", "tuple", "len"], "function", ["None"], ["", "def", "checkpoint", "(", "func", ",", "inputs", ",", "params", ",", "flag", ")", ":", "\n", "    ", "\"\"\"\n    Evaluate a function without caching intermediate activations, allowing for\n    reduced memory at the expense of extra compute in the backward pass.\n\n    :param func: the function to evaluate.\n    :param inputs: the argument sequence to pass to `func`.\n    :param params: a sequence of parameters `func` depends on but does not\n                   explicitly take as arguments.\n    :param flag: if False, disable gradient checkpointing.\n    \"\"\"", "\n", "if", "flag", ":", "\n", "        ", "args", "=", "tuple", "(", "inputs", ")", "+", "tuple", "(", "params", ")", "\n", "return", "CheckpointFunction", ".", "apply", "(", "func", ",", "len", "(", "inputs", ")", ",", "*", "args", ")", "\n", "", "else", ":", "\n", "        ", "return", "func", "(", "*", "inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.MixedPrecisionTrainer.__init__": [[149, 172], ["list", "fp16_util.MixedPrecisionTrainer.model.parameters", "fp16_util.get_param_groups_and_shapes", "fp16_util.make_master_params", "fp16_util.MixedPrecisionTrainer.model.convert_to_fp16", "fp16_util.MixedPrecisionTrainer.model.named_parameters"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.get_param_groups_and_shapes", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.make_master_params", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.EncoderUNetModel.convert_to_fp16"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "*", ",", "\n", "model", ",", "\n", "use_fp16", "=", "False", ",", "\n", "fp16_scale_growth", "=", "1e-3", ",", "\n", "initial_lg_loss_scale", "=", "INITIAL_LOG_LOSS_SCALE", ",", "\n", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "use_fp16", "=", "use_fp16", "\n", "self", ".", "fp16_scale_growth", "=", "fp16_scale_growth", "\n", "\n", "self", ".", "model_params", "=", "list", "(", "self", ".", "model", ".", "parameters", "(", ")", ")", "\n", "self", ".", "master_params", "=", "self", ".", "model_params", "\n", "self", ".", "param_groups_and_shapes", "=", "None", "\n", "self", ".", "lg_loss_scale", "=", "initial_lg_loss_scale", "\n", "\n", "if", "self", ".", "use_fp16", ":", "\n", "            ", "self", ".", "param_groups_and_shapes", "=", "get_param_groups_and_shapes", "(", "\n", "self", ".", "model", ".", "named_parameters", "(", ")", "\n", ")", "\n", "self", ".", "master_params", "=", "make_master_params", "(", "self", ".", "param_groups_and_shapes", ")", "\n", "self", ".", "model", ".", "convert_to_fp16", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.MixedPrecisionTrainer.zero_grad": [[173, 175], ["fp16_util.MixedPrecisionTrainer.zero_grad"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.zero_grad"], ["", "", "def", "zero_grad", "(", "self", ")", ":", "\n", "        ", "zero_grad", "(", "self", ".", "model_params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.MixedPrecisionTrainer.backward": [[176, 182], ["loss.backward"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.MixedPrecisionTrainer.backward"], ["", "def", "backward", "(", "self", ",", "loss", ":", "th", ".", "Tensor", ")", ":", "\n", "        ", "if", "self", ".", "use_fp16", ":", "\n", "            ", "loss_scale", "=", "2", "**", "self", ".", "lg_loss_scale", "\n", "(", "loss", "*", "loss_scale", ")", ".", "backward", "(", ")", "\n", "", "else", ":", "\n", "            ", "loss", ".", "backward", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.MixedPrecisionTrainer.optimize": [[183, 188], ["fp16_util.MixedPrecisionTrainer._optimize_fp16", "fp16_util.MixedPrecisionTrainer._optimize_normal"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.MixedPrecisionTrainer._optimize_fp16", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.MixedPrecisionTrainer._optimize_normal"], ["", "", "def", "optimize", "(", "self", ",", "opt", ":", "th", ".", "optim", ".", "Optimizer", ")", ":", "\n", "        ", "if", "self", ".", "use_fp16", ":", "\n", "            ", "return", "self", ".", "_optimize_fp16", "(", "opt", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_optimize_normal", "(", "opt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.MixedPrecisionTrainer._optimize_fp16": [[189, 208], ["logger.logkv_mean", "fp16_util.model_grads_to_master_grads", "fp16_util.MixedPrecisionTrainer._compute_norms", "fp16_util.check_overflow", "logger.logkv_mean", "logger.logkv_mean", "fp16_util.MixedPrecisionTrainer.master_params[].grad.mul_", "opt.step", "fp16_util.zero_master_grads", "fp16_util.master_params_to_model_params", "logger.log", "fp16_util.zero_master_grads"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.logkv_mean", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.model_grads_to_master_grads", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.MixedPrecisionTrainer._compute_norms", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.check_overflow", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.logkv_mean", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.logkv_mean", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.zero_master_grads", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.master_params_to_model_params", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.zero_master_grads"], ["", "", "def", "_optimize_fp16", "(", "self", ",", "opt", ":", "th", ".", "optim", ".", "Optimizer", ")", ":", "\n", "        ", "logger", ".", "logkv_mean", "(", "\"lg_loss_scale\"", ",", "self", ".", "lg_loss_scale", ")", "\n", "model_grads_to_master_grads", "(", "self", ".", "param_groups_and_shapes", ",", "self", ".", "master_params", ")", "\n", "grad_norm", ",", "param_norm", "=", "self", ".", "_compute_norms", "(", "grad_scale", "=", "2", "**", "self", ".", "lg_loss_scale", ")", "\n", "if", "check_overflow", "(", "grad_norm", ")", ":", "\n", "            ", "self", ".", "lg_loss_scale", "-=", "1", "\n", "logger", ".", "log", "(", "f\"Found NaN, decreased lg_loss_scale to {self.lg_loss_scale}\"", ")", "\n", "zero_master_grads", "(", "self", ".", "master_params", ")", "\n", "return", "False", "\n", "\n", "", "logger", ".", "logkv_mean", "(", "\"grad_norm\"", ",", "grad_norm", ")", "\n", "logger", ".", "logkv_mean", "(", "\"param_norm\"", ",", "param_norm", ")", "\n", "\n", "self", ".", "master_params", "[", "0", "]", ".", "grad", ".", "mul_", "(", "1.0", "/", "(", "2", "**", "self", ".", "lg_loss_scale", ")", ")", "\n", "opt", ".", "step", "(", ")", "\n", "zero_master_grads", "(", "self", ".", "master_params", ")", "\n", "master_params_to_model_params", "(", "self", ".", "param_groups_and_shapes", ",", "self", ".", "master_params", ")", "\n", "self", ".", "lg_loss_scale", "+=", "self", ".", "fp16_scale_growth", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.MixedPrecisionTrainer._optimize_normal": [[209, 215], ["fp16_util.MixedPrecisionTrainer._compute_norms", "logger.logkv_mean", "logger.logkv_mean", "opt.step"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.MixedPrecisionTrainer._compute_norms", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.logkv_mean", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.logkv_mean"], ["", "def", "_optimize_normal", "(", "self", ",", "opt", ":", "th", ".", "optim", ".", "Optimizer", ")", ":", "\n", "        ", "grad_norm", ",", "param_norm", "=", "self", ".", "_compute_norms", "(", ")", "\n", "logger", ".", "logkv_mean", "(", "\"grad_norm\"", ",", "grad_norm", ")", "\n", "logger", ".", "logkv_mean", "(", "\"param_norm\"", ",", "param_norm", ")", "\n", "opt", ".", "step", "(", ")", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.MixedPrecisionTrainer._compute_norms": [[216, 225], ["numpy.sqrt", "torch.no_grad", "torch.no_grad", "numpy.sqrt", "torch.norm().item", "torch.norm().item", "torch.norm().item", "torch.norm().item", "torch.norm", "torch.norm", "torch.norm", "torch.norm"], "methods", ["None"], ["", "def", "_compute_norms", "(", "self", ",", "grad_scale", "=", "1.0", ")", ":", "\n", "        ", "grad_norm", "=", "0.0", "\n", "param_norm", "=", "0.0", "\n", "for", "p", "in", "self", ".", "master_params", ":", "\n", "            ", "with", "th", ".", "no_grad", "(", ")", ":", "\n", "                ", "param_norm", "+=", "th", ".", "norm", "(", "p", ",", "p", "=", "2", ",", "dtype", "=", "th", ".", "float32", ")", ".", "item", "(", ")", "**", "2", "\n", "if", "p", ".", "grad", "is", "not", "None", ":", "\n", "                    ", "grad_norm", "+=", "th", ".", "norm", "(", "p", ".", "grad", ",", "p", "=", "2", ",", "dtype", "=", "th", ".", "float32", ")", ".", "item", "(", ")", "**", "2", "\n", "", "", "", "return", "np", ".", "sqrt", "(", "grad_norm", ")", "/", "grad_scale", ",", "np", ".", "sqrt", "(", "param_norm", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.MixedPrecisionTrainer.master_params_to_state_dict": [[226, 229], ["fp16_util.MixedPrecisionTrainer.master_params_to_state_dict"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.master_params_to_state_dict"], ["", "def", "master_params_to_state_dict", "(", "self", ",", "master_params", ")", ":", "\n", "        ", "return", "master_params_to_state_dict", "(", "\n", "self", ".", "model", ",", "self", ".", "param_groups_and_shapes", ",", "master_params", ",", "self", ".", "use_fp16", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.MixedPrecisionTrainer.state_dict_to_master_params": [[231, 233], ["fp16_util.MixedPrecisionTrainer.state_dict_to_master_params"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.state_dict_to_master_params"], ["", "def", "state_dict_to_master_params", "(", "self", ",", "state_dict", ")", ":", "\n", "        ", "return", "state_dict_to_master_params", "(", "self", ".", "model", ",", "state_dict", ",", "self", ".", "use_fp16", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.convert_module_to_f16": [[15, 23], ["isinstance", "l.weight.data.half", "l.bias.data.half"], "function", ["None"], ["def", "convert_module_to_f16", "(", "l", ")", ":", "\n", "    ", "\"\"\"\n    Convert primitive modules to float16.\n    \"\"\"", "\n", "if", "isinstance", "(", "l", ",", "(", "nn", ".", "Conv1d", ",", "nn", ".", "Conv2d", ",", "nn", ".", "Conv3d", ")", ")", ":", "\n", "        ", "l", ".", "weight", ".", "data", "=", "l", ".", "weight", ".", "data", ".", "half", "(", ")", "\n", "if", "l", ".", "bias", "is", "not", "None", ":", "\n", "            ", "l", ".", "bias", ".", "data", "=", "l", ".", "bias", ".", "data", ".", "half", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.convert_module_to_f32": [[25, 33], ["isinstance", "l.weight.data.float", "l.bias.data.float"], "function", ["None"], ["", "", "", "def", "convert_module_to_f32", "(", "l", ")", ":", "\n", "    ", "\"\"\"\n    Convert primitive modules to float32, undoing convert_module_to_f16().\n    \"\"\"", "\n", "if", "isinstance", "(", "l", ",", "(", "nn", ".", "Conv1d", ",", "nn", ".", "Conv2d", ",", "nn", ".", "Conv3d", ")", ")", ":", "\n", "        ", "l", ".", "weight", ".", "data", "=", "l", ".", "weight", ".", "data", ".", "float", "(", ")", "\n", "if", "l", ".", "bias", "is", "not", "None", ":", "\n", "            ", "l", ".", "bias", ".", "data", "=", "l", ".", "bias", ".", "data", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.make_master_params": [[35, 50], ["torch.Parameter", "master_params.append", "torch._utils._flatten_dense_tensors().view", "torch._utils._flatten_dense_tensors", "param.detach().float", "param.detach"], "function", ["None"], ["", "", "", "def", "make_master_params", "(", "param_groups_and_shapes", ")", ":", "\n", "    ", "\"\"\"\n    Copy model parameters into a (differently-shaped) list of full-precision\n    parameters.\n    \"\"\"", "\n", "master_params", "=", "[", "]", "\n", "for", "param_group", ",", "shape", "in", "param_groups_and_shapes", ":", "\n", "        ", "master_param", "=", "nn", ".", "Parameter", "(", "\n", "_flatten_dense_tensors", "(", "\n", "[", "param", ".", "detach", "(", ")", ".", "float", "(", ")", "for", "(", "_", ",", "param", ")", "in", "param_group", "]", "\n", ")", ".", "view", "(", "shape", ")", "\n", ")", "\n", "master_param", ".", "requires_grad", "=", "True", "\n", "master_params", ".", "append", "(", "master_param", ")", "\n", "", "return", "master_params", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.model_grads_to_master_grads": [[52, 63], ["zip", "torch._utils._flatten_dense_tensors().view", "torch._utils._flatten_dense_tensors", "fp16_util.param_grad_or_zeros"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.param_grad_or_zeros"], ["", "def", "model_grads_to_master_grads", "(", "param_groups_and_shapes", ",", "master_params", ")", ":", "\n", "    ", "\"\"\"\n    Copy the gradients from the model parameters into the master parameters\n    from make_master_params().\n    \"\"\"", "\n", "for", "master_param", ",", "(", "param_group", ",", "shape", ")", "in", "zip", "(", "\n", "master_params", ",", "param_groups_and_shapes", "\n", ")", ":", "\n", "        ", "master_param", ".", "grad", "=", "_flatten_dense_tensors", "(", "\n", "[", "param_grad_or_zeros", "(", "param", ")", "for", "(", "_", ",", "param", ")", "in", "param_group", "]", "\n", ")", ".", "view", "(", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.master_params_to_model_params": [[65, 76], ["zip", "zip", "fp16_util.unflatten_master_params", "param.detach().copy_", "master_param.view", "param.detach"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.unflatten_master_params"], ["", "", "def", "master_params_to_model_params", "(", "param_groups_and_shapes", ",", "master_params", ")", ":", "\n", "    ", "\"\"\"\n    Copy the master parameter data back into the model parameters.\n    \"\"\"", "\n", "# Without copying to a list, if a generator is passed, this will", "\n", "# silently not copy any parameters.", "\n", "for", "master_param", ",", "(", "param_group", ",", "_", ")", "in", "zip", "(", "master_params", ",", "param_groups_and_shapes", ")", ":", "\n", "        ", "for", "(", "_", ",", "param", ")", ",", "unflat_master_param", "in", "zip", "(", "\n", "param_group", ",", "unflatten_master_params", "(", "param_group", ",", "master_param", ".", "view", "(", "-", "1", ")", ")", "\n", ")", ":", "\n", "            ", "param", ".", "detach", "(", ")", ".", "copy_", "(", "unflat_master_param", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.unflatten_master_params": [[78, 80], ["torch._utils._unflatten_dense_tensors"], "function", ["None"], ["", "", "", "def", "unflatten_master_params", "(", "param_group", ",", "master_param", ")", ":", "\n", "    ", "return", "_unflatten_dense_tensors", "(", "master_param", ",", "[", "param", "for", "(", "_", ",", "param", ")", "in", "param_group", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.get_param_groups_and_shapes": [[82, 93], ["list"], "function", ["None"], ["", "def", "get_param_groups_and_shapes", "(", "named_model_params", ")", ":", "\n", "    ", "named_model_params", "=", "list", "(", "named_model_params", ")", "\n", "scalar_vector_named_params", "=", "(", "\n", "[", "(", "n", ",", "p", ")", "for", "(", "n", ",", "p", ")", "in", "named_model_params", "if", "p", ".", "ndim", "<=", "1", "]", ",", "\n", "(", "-", "1", ")", ",", "\n", ")", "\n", "matrix_named_params", "=", "(", "\n", "[", "(", "n", ",", "p", ")", "for", "(", "n", ",", "p", ")", "in", "named_model_params", "if", "p", ".", "ndim", ">", "1", "]", ",", "\n", "(", "1", ",", "-", "1", ")", ",", "\n", ")", "\n", "return", "[", "scalar_vector_named_params", ",", "matrix_named_params", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.master_params_to_state_dict": [[95, 114], ["model.state_dict", "zip", "model.state_dict", "enumerate", "zip", "model.named_parameters", "fp16_util.unflatten_master_params", "master_param.view"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.unflatten_master_params"], ["", "def", "master_params_to_state_dict", "(", "\n", "model", ",", "param_groups_and_shapes", ",", "master_params", ",", "use_fp16", "\n", ")", ":", "\n", "    ", "if", "use_fp16", ":", "\n", "        ", "state_dict", "=", "model", ".", "state_dict", "(", ")", "\n", "for", "master_param", ",", "(", "param_group", ",", "_", ")", "in", "zip", "(", "\n", "master_params", ",", "param_groups_and_shapes", "\n", ")", ":", "\n", "            ", "for", "(", "name", ",", "_", ")", ",", "unflat_master_param", "in", "zip", "(", "\n", "param_group", ",", "unflatten_master_params", "(", "param_group", ",", "master_param", ".", "view", "(", "-", "1", ")", ")", "\n", ")", ":", "\n", "                ", "assert", "name", "in", "state_dict", "\n", "state_dict", "[", "name", "]", "=", "unflat_master_param", "\n", "", "", "", "else", ":", "\n", "        ", "state_dict", "=", "model", ".", "state_dict", "(", ")", "\n", "for", "i", ",", "(", "name", ",", "_value", ")", "in", "enumerate", "(", "model", ".", "named_parameters", "(", ")", ")", ":", "\n", "            ", "assert", "name", "in", "state_dict", "\n", "state_dict", "[", "name", "]", "=", "master_params", "[", "i", "]", "\n", "", "", "return", "state_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.state_dict_to_master_params": [[116, 126], ["fp16_util.get_param_groups_and_shapes", "fp16_util.make_master_params", "model.named_parameters", "model.named_parameters"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.get_param_groups_and_shapes", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.make_master_params"], ["", "def", "state_dict_to_master_params", "(", "model", ",", "state_dict", ",", "use_fp16", ")", ":", "\n", "    ", "if", "use_fp16", ":", "\n", "        ", "named_model_params", "=", "[", "\n", "(", "name", ",", "state_dict", "[", "name", "]", ")", "for", "name", ",", "_", "in", "model", ".", "named_parameters", "(", ")", "\n", "]", "\n", "param_groups_and_shapes", "=", "get_param_groups_and_shapes", "(", "named_model_params", ")", "\n", "master_params", "=", "make_master_params", "(", "param_groups_and_shapes", ")", "\n", "", "else", ":", "\n", "        ", "master_params", "=", "[", "state_dict", "[", "name", "]", "for", "name", ",", "_", "in", "model", ".", "named_parameters", "(", ")", "]", "\n", "", "return", "master_params", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.zero_master_grads": [[128, 131], ["None"], "function", ["None"], ["", "def", "zero_master_grads", "(", "master_params", ")", ":", "\n", "    ", "for", "param", "in", "master_params", ":", "\n", "        ", "param", ".", "grad", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.zero_grad": [[133, 139], ["param.grad.detach_", "param.grad.zero_"], "function", ["None"], ["", "", "def", "zero_grad", "(", "model_params", ")", ":", "\n", "    ", "for", "param", "in", "model_params", ":", "\n", "# Taken from https://pytorch.org/docs/stable/_modules/torch/optim/optimizer.html#Optimizer.add_param_group", "\n", "        ", "if", "param", ".", "grad", "is", "not", "None", ":", "\n", "            ", "param", ".", "grad", ".", "detach_", "(", ")", "\n", "param", ".", "grad", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.param_grad_or_zeros": [[141, 146], ["param.grad.data.detach", "torch.zeros_like"], "function", ["None"], ["", "", "", "def", "param_grad_or_zeros", "(", "param", ")", ":", "\n", "    ", "if", "param", ".", "grad", "is", "not", "None", ":", "\n", "        ", "return", "param", ".", "grad", ".", "data", ".", "detach", "(", ")", "\n", "", "else", ":", "\n", "        ", "return", "th", ".", "zeros_like", "(", "param", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.fp16_util.check_overflow": [[235, 237], ["float", "float"], "function", ["None"], ["", "", "def", "check_overflow", "(", "value", ")", ":", "\n", "    ", "return", "(", "value", "==", "float", "(", "\"inf\"", ")", ")", "or", "(", "value", "==", "-", "float", "(", "\"inf\"", ")", ")", "or", "(", "value", "!=", "value", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.resample.ScheduleSampler.weights": [[34, 41], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get a numpy array of weights, one per diffusion step.\n\n        The weights needn't be normalized, but must be positive.\n        \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.resample.ScheduleSampler.sample": [[42, 59], ["resample.ScheduleSampler.weights", "numpy.random.choice", "torch.from_numpy().long().to", "torch.from_numpy().long().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "numpy.sum", "len", "torch.from_numpy().long", "torch.from_numpy().long", "len", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.resample.LossSecondMomentResampler.weights"], ["", "def", "sample", "(", "self", ",", "batch_size", ",", "device", ")", ":", "\n", "        ", "\"\"\"\n        Importance-sample timesteps for a batch.\n\n        :param batch_size: the number of timesteps.\n        :param device: the torch device to save to.\n        :return: a tuple (timesteps, weights):\n                 - timesteps: a tensor of timestep indices.\n                 - weights: a tensor of weights to scale the resulting losses.\n        \"\"\"", "\n", "w", "=", "self", ".", "weights", "(", ")", "\n", "p", "=", "w", "/", "np", ".", "sum", "(", "w", ")", "\n", "indices_np", "=", "np", ".", "random", ".", "choice", "(", "len", "(", "p", ")", ",", "size", "=", "(", "batch_size", ",", ")", ",", "p", "=", "p", ")", "\n", "indices", "=", "th", ".", "from_numpy", "(", "indices_np", ")", ".", "long", "(", ")", ".", "to", "(", "device", ")", "\n", "weights_np", "=", "1", "/", "(", "len", "(", "p", ")", "*", "p", "[", "indices_np", "]", ")", "\n", "weights", "=", "th", ".", "from_numpy", "(", "weights_np", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "return", "indices", ",", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.resample.UniformSampler.__init__": [[62, 65], ["numpy.ones"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "diffusion", ")", ":", "\n", "        ", "self", ".", "diffusion", "=", "diffusion", "\n", "self", ".", "_weights", "=", "np", ".", "ones", "(", "[", "diffusion", ".", "num_timesteps", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.resample.UniformSampler.weights": [[66, 68], ["None"], "methods", ["None"], ["", "def", "weights", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_weights", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.resample.LossAwareSampler.update_with_local_losses": [[71, 105], ["torch.all_gather", "torch.all_gather", "max", "torch.all_gather", "torch.all_gather", "torch.all_gather", "torch.all_gather", "resample.LossAwareSampler.update_with_all_losses", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "x.item", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "x.item", "x.item", "range", "zip", "zip", "torch.get_world_size", "torch.get_world_size", "len", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.resample.LossSecondMomentResampler.update_with_all_losses"], ["    ", "def", "update_with_local_losses", "(", "self", ",", "local_ts", ",", "local_losses", ")", ":", "\n", "        ", "\"\"\"\n        Update the reweighting using losses from a model.\n\n        Call this method from each rank with a batch of timesteps and the\n        corresponding losses for each of those timesteps.\n        This method will perform synchronization to make sure all of the ranks\n        maintain the exact same reweighting.\n\n        :param local_ts: an integer Tensor of timesteps.\n        :param local_losses: a 1D Tensor of losses.\n        \"\"\"", "\n", "batch_sizes", "=", "[", "\n", "th", ".", "tensor", "(", "[", "0", "]", ",", "dtype", "=", "th", ".", "int32", ",", "device", "=", "local_ts", ".", "device", ")", "\n", "for", "_", "in", "range", "(", "dist", ".", "get_world_size", "(", ")", ")", "\n", "]", "\n", "dist", ".", "all_gather", "(", "\n", "batch_sizes", ",", "\n", "th", ".", "tensor", "(", "[", "len", "(", "local_ts", ")", "]", ",", "dtype", "=", "th", ".", "int32", ",", "device", "=", "local_ts", ".", "device", ")", ",", "\n", ")", "\n", "\n", "# Pad all_gather batches to be the maximum batch size.", "\n", "batch_sizes", "=", "[", "x", ".", "item", "(", ")", "for", "x", "in", "batch_sizes", "]", "\n", "max_bs", "=", "max", "(", "batch_sizes", ")", "\n", "\n", "timestep_batches", "=", "[", "th", ".", "zeros", "(", "max_bs", ")", ".", "to", "(", "local_ts", ")", "for", "bs", "in", "batch_sizes", "]", "\n", "loss_batches", "=", "[", "th", ".", "zeros", "(", "max_bs", ")", ".", "to", "(", "local_losses", ")", "for", "bs", "in", "batch_sizes", "]", "\n", "dist", ".", "all_gather", "(", "timestep_batches", ",", "local_ts", ")", "\n", "dist", ".", "all_gather", "(", "loss_batches", ",", "local_losses", ")", "\n", "timesteps", "=", "[", "\n", "x", ".", "item", "(", ")", "for", "y", ",", "bs", "in", "zip", "(", "timestep_batches", ",", "batch_sizes", ")", "for", "x", "in", "y", "[", ":", "bs", "]", "\n", "]", "\n", "losses", "=", "[", "x", ".", "item", "(", ")", "for", "y", ",", "bs", "in", "zip", "(", "loss_batches", ",", "batch_sizes", ")", "for", "x", "in", "y", "[", ":", "bs", "]", "]", "\n", "self", ".", "update_with_all_losses", "(", "timesteps", ",", "losses", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.resample.LossAwareSampler.update_with_all_losses": [[106, 122], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "update_with_all_losses", "(", "self", ",", "ts", ",", "losses", ")", ":", "\n", "        ", "\"\"\"\n        Update the reweighting using losses from a model.\n\n        Sub-classes should override this method to update the reweighting\n        using losses from the model.\n\n        This method directly updates the reweighting without synchronizing\n        between workers. It is called by update_with_local_losses from all\n        ranks with identical arguments. Thus, it should have deterministic\n        behavior to maintain state across workers.\n\n        :param ts: a list of int timesteps.\n        :param losses: a list of float losses, one per timestep.\n        \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.resample.LossSecondMomentResampler.__init__": [[125, 133], ["numpy.zeros", "numpy.zeros"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "diffusion", ",", "history_per_term", "=", "10", ",", "uniform_prob", "=", "0.001", ")", ":", "\n", "        ", "self", ".", "diffusion", "=", "diffusion", "\n", "self", ".", "history_per_term", "=", "history_per_term", "\n", "self", ".", "uniform_prob", "=", "uniform_prob", "\n", "self", ".", "_loss_history", "=", "np", ".", "zeros", "(", "\n", "[", "diffusion", ".", "num_timesteps", ",", "history_per_term", "]", ",", "dtype", "=", "np", ".", "float64", "\n", ")", "\n", "self", ".", "_loss_counts", "=", "np", ".", "zeros", "(", "[", "diffusion", ".", "num_timesteps", "]", ",", "dtype", "=", "np", ".", "int", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.resample.LossSecondMomentResampler.weights": [[134, 142], ["numpy.sqrt", "numpy.sum", "resample.LossSecondMomentResampler._warmed_up", "numpy.ones", "numpy.mean", "len"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.resample.LossSecondMomentResampler._warmed_up"], ["", "def", "weights", "(", "self", ")", ":", "\n", "        ", "if", "not", "self", ".", "_warmed_up", "(", ")", ":", "\n", "            ", "return", "np", ".", "ones", "(", "[", "self", ".", "diffusion", ".", "num_timesteps", "]", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "", "weights", "=", "np", ".", "sqrt", "(", "np", ".", "mean", "(", "self", ".", "_loss_history", "**", "2", ",", "axis", "=", "-", "1", ")", ")", "\n", "weights", "/=", "np", ".", "sum", "(", "weights", ")", "\n", "weights", "*=", "1", "-", "self", ".", "uniform_prob", "\n", "weights", "+=", "self", ".", "uniform_prob", "/", "len", "(", "weights", ")", "\n", "return", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.resample.LossSecondMomentResampler.update_with_all_losses": [[143, 152], ["zip"], "methods", ["None"], ["", "def", "update_with_all_losses", "(", "self", ",", "ts", ",", "losses", ")", ":", "\n", "        ", "for", "t", ",", "loss", "in", "zip", "(", "ts", ",", "losses", ")", ":", "\n", "            ", "if", "self", ".", "_loss_counts", "[", "t", "]", "==", "self", ".", "history_per_term", ":", "\n", "# Shift out the oldest loss term.", "\n", "                ", "self", ".", "_loss_history", "[", "t", ",", ":", "-", "1", "]", "=", "self", ".", "_loss_history", "[", "t", ",", "1", ":", "]", "\n", "self", ".", "_loss_history", "[", "t", ",", "-", "1", "]", "=", "loss", "\n", "", "else", ":", "\n", "                ", "self", ".", "_loss_history", "[", "t", ",", "self", ".", "_loss_counts", "[", "t", "]", "]", "=", "loss", "\n", "self", ".", "_loss_counts", "[", "t", "]", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.resample.LossSecondMomentResampler._warmed_up": [[153, 155], ["None"], "methods", ["None"], ["", "", "", "def", "_warmed_up", "(", "self", ")", ":", "\n", "        ", "return", "(", "self", ".", "_loss_counts", "==", "self", ".", "history_per_term", ")", ".", "all", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.resample.create_named_schedule_sampler": [[8, 21], ["resample.UniformSampler", "resample.LossSecondMomentResampler", "NotImplementedError"], "function", ["None"], ["def", "create_named_schedule_sampler", "(", "name", ",", "diffusion", ")", ":", "\n", "    ", "\"\"\"\n    Create a ScheduleSampler from a library of pre-defined samplers.\n\n    :param name: the name of the sampler.\n    :param diffusion: the diffusion object to sample for.\n    \"\"\"", "\n", "if", "name", "==", "\"uniform\"", ":", "\n", "        ", "return", "UniformSampler", "(", "diffusion", ")", "\n", "", "elif", "name", "==", "\"loss-second-moment\"", ":", "\n", "        ", "return", "LossSecondMomentResampler", "(", "diffusion", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "f\"unknown schedule sampler: {name}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.losses.normal_kl": [[12, 39], ["isinstance", "isinstance", "torch.tensor().to", "torch.exp", "torch.exp", "torch.tensor"], "function", ["None"], ["def", "normal_kl", "(", "mean1", ",", "logvar1", ",", "mean2", ",", "logvar2", ")", ":", "\n", "    ", "\"\"\"\n    Compute the KL divergence between two gaussians.\n\n    Shapes are automatically broadcasted, so batches can be compared to\n    scalars, among other use cases.\n    \"\"\"", "\n", "tensor", "=", "None", "\n", "for", "obj", "in", "(", "mean1", ",", "logvar1", ",", "mean2", ",", "logvar2", ")", ":", "\n", "        ", "if", "isinstance", "(", "obj", ",", "th", ".", "Tensor", ")", ":", "\n", "            ", "tensor", "=", "obj", "\n", "break", "\n", "", "", "assert", "tensor", "is", "not", "None", ",", "\"at least one argument must be a Tensor\"", "\n", "\n", "# Force variances to be Tensors. Broadcasting helps convert scalars to", "\n", "# Tensors, but it does not work for th.exp().", "\n", "logvar1", ",", "logvar2", "=", "[", "\n", "x", "if", "isinstance", "(", "x", ",", "th", ".", "Tensor", ")", "else", "th", ".", "tensor", "(", "x", ")", ".", "to", "(", "tensor", ")", "\n", "for", "x", "in", "(", "logvar1", ",", "logvar2", ")", "\n", "]", "\n", "\n", "return", "0.5", "*", "(", "\n", "-", "1.0", "\n", "+", "logvar2", "\n", "-", "logvar1", "\n", "+", "th", ".", "exp", "(", "logvar1", "-", "logvar2", ")", "\n", "+", "(", "(", "mean1", "-", "mean2", ")", "**", "2", ")", "*", "th", ".", "exp", "(", "-", "logvar2", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.losses.approx_standard_normal_cdf": [[42, 48], ["torch.tanh", "numpy.sqrt", "torch.pow"], "function", ["None"], ["", "def", "approx_standard_normal_cdf", "(", "x", ")", ":", "\n", "    ", "\"\"\"\n    A fast approximation of the cumulative distribution function of the\n    standard normal.\n    \"\"\"", "\n", "return", "0.5", "*", "(", "1.0", "+", "th", ".", "tanh", "(", "np", ".", "sqrt", "(", "2.0", "/", "np", ".", "pi", ")", "*", "(", "x", "+", "0.044715", "*", "th", ".", "pow", "(", "x", ",", "3", ")", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.losses.discretized_gaussian_log_likelihood": [[50, 78], ["torch.exp", "losses.approx_standard_normal_cdf", "losses.approx_standard_normal_cdf", "torch.log", "torch.log", "torch.where", "approx_standard_normal_cdf.clamp", "torch.where", "torch.log", "cdf_delta.clamp"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.losses.approx_standard_normal_cdf", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.losses.approx_standard_normal_cdf", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log"], ["", "def", "discretized_gaussian_log_likelihood", "(", "x", ",", "*", ",", "means", ",", "log_scales", ")", ":", "\n", "    ", "\"\"\"\n    Compute the log-likelihood of a Gaussian distribution discretizing to a\n    given image.\n\n    :param x: the target images. It is assumed that this was uint8 values,\n              rescaled to the range [-1, 1].\n    :param means: the Gaussian mean Tensor.\n    :param log_scales: the Gaussian log stddev Tensor.\n    :return: a tensor like x of log probabilities (in nats).\n    \"\"\"", "\n", "assert", "x", ".", "shape", "==", "means", ".", "shape", "==", "log_scales", ".", "shape", "\n", "centered_x", "=", "x", "-", "means", "\n", "inv_stdv", "=", "th", ".", "exp", "(", "-", "log_scales", ")", "\n", "plus_in", "=", "inv_stdv", "*", "(", "centered_x", "+", "1.0", "/", "255.0", ")", "\n", "cdf_plus", "=", "approx_standard_normal_cdf", "(", "plus_in", ")", "\n", "min_in", "=", "inv_stdv", "*", "(", "centered_x", "-", "1.0", "/", "255.0", ")", "\n", "cdf_min", "=", "approx_standard_normal_cdf", "(", "min_in", ")", "\n", "log_cdf_plus", "=", "th", ".", "log", "(", "cdf_plus", ".", "clamp", "(", "min", "=", "1e-12", ")", ")", "\n", "log_one_minus_cdf_min", "=", "th", ".", "log", "(", "(", "1.0", "-", "cdf_min", ")", ".", "clamp", "(", "min", "=", "1e-12", ")", ")", "\n", "cdf_delta", "=", "cdf_plus", "-", "cdf_min", "\n", "log_probs", "=", "th", ".", "where", "(", "\n", "x", "<", "-", "0.999", ",", "\n", "log_cdf_plus", ",", "\n", "th", ".", "where", "(", "x", ">", "0.999", ",", "log_one_minus_cdf_min", ",", "th", ".", "log", "(", "cdf_delta", ".", "clamp", "(", "min", "=", "1e-12", ")", ")", ")", ",", "\n", ")", "\n", "assert", "log_probs", ".", "shape", "==", "x", ".", "shape", "\n", "return", "log_probs", "\n", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.resnet.BasicBlock.__init__": [[21, 34], ["torch.Module.__init__", "resnet.conv3x3", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "resnet.conv3x3", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__", "home.repos.pwc.inspect_result.ailon-island_facke.models.models.conv3x3", "home.repos.pwc.inspect_result.ailon-island_facke.models.models.conv3x3"], ["    ", "def", "__init__", "(", "self", ",", "in_chan", ",", "out_chan", ",", "stride", "=", "1", ")", ":", "\n", "        ", "super", "(", "BasicBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "conv3x3", "(", "in_chan", ",", "out_chan", ",", "stride", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "out_chan", ")", "\n", "self", ".", "conv2", "=", "conv3x3", "(", "out_chan", ",", "out_chan", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "out_chan", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "downsample", "=", "None", "\n", "if", "in_chan", "!=", "out_chan", "or", "stride", "!=", "1", ":", "\n", "            ", "self", ".", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_chan", ",", "out_chan", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "out_chan", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.resnet.BasicBlock.forward": [[36, 49], ["resnet.BasicBlock.conv1", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "resnet.BasicBlock.conv2", "resnet.BasicBlock.bn2", "resnet.BasicBlock.relu", "resnet.BasicBlock.bn1", "resnet.BasicBlock.downsample"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "residual", "=", "self", ".", "conv1", "(", "x", ")", "\n", "residual", "=", "F", ".", "relu", "(", "self", ".", "bn1", "(", "residual", ")", ")", "\n", "residual", "=", "self", ".", "conv2", "(", "residual", ")", "\n", "residual", "=", "self", ".", "bn2", "(", "residual", ")", "\n", "\n", "shortcut", "=", "x", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "shortcut", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "=", "shortcut", "+", "residual", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.resnet.Resnet18.__init__": [[59, 70], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "resnet.create_layer_basic", "resnet.create_layer_basic", "resnet.create_layer_basic", "resnet.create_layer_basic", "resnet.Resnet18.init_weight"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__", "home.repos.pwc.inspect_result.ailon-island_facke.parsing.resnet.create_layer_basic", "home.repos.pwc.inspect_result.ailon-island_facke.parsing.resnet.create_layer_basic", "home.repos.pwc.inspect_result.ailon-island_facke.parsing.resnet.create_layer_basic", "home.repos.pwc.inspect_result.ailon-island_facke.parsing.resnet.create_layer_basic", "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.BiSeNet.init_weight"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "Resnet18", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "3", ",", "64", ",", "kernel_size", "=", "7", ",", "stride", "=", "2", ",", "padding", "=", "3", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "64", ")", "\n", "self", ".", "maxpool", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "self", ".", "layer1", "=", "create_layer_basic", "(", "64", ",", "64", ",", "bnum", "=", "2", ",", "stride", "=", "1", ")", "\n", "self", ".", "layer2", "=", "create_layer_basic", "(", "64", ",", "128", ",", "bnum", "=", "2", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer3", "=", "create_layer_basic", "(", "128", ",", "256", ",", "bnum", "=", "2", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer4", "=", "create_layer_basic", "(", "256", ",", "512", ",", "bnum", "=", "2", ",", "stride", "=", "2", ")", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.resnet.Resnet18.forward": [[71, 81], ["resnet.Resnet18.conv1", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "resnet.Resnet18.maxpool", "resnet.Resnet18.layer1", "resnet.Resnet18.layer2", "resnet.Resnet18.layer3", "resnet.Resnet18.layer4", "resnet.Resnet18.bn1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "bn1", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "maxpool", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "layer1", "(", "x", ")", "\n", "feat8", "=", "self", ".", "layer2", "(", "x", ")", "# 1/8", "\n", "feat16", "=", "self", ".", "layer3", "(", "feat8", ")", "# 1/16", "\n", "feat32", "=", "self", ".", "layer4", "(", "feat16", ")", "# 1/32", "\n", "return", "feat8", ",", "feat16", ",", "feat32", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.resnet.Resnet18.init_weight": [[82, 89], ["torch.load_url", "torch.load_url", "torch.load_url", "torch.load_url", "resnet.Resnet18.state_dict", "torch.load_url.items", "resnet.Resnet18.load_state_dict", "resnet.Resnet18.update"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.dist_util.load_state_dict"], ["", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "state_dict", "=", "modelzoo", ".", "load_url", "(", "resnet18_url", ")", "\n", "self_state_dict", "=", "self", ".", "state_dict", "(", ")", "\n", "for", "k", ",", "v", "in", "state_dict", ".", "items", "(", ")", ":", "\n", "            ", "if", "'fc'", "in", "k", ":", "continue", "\n", "self_state_dict", ".", "update", "(", "{", "k", ":", "v", "}", ")", "\n", "", "self", ".", "load_state_dict", "(", "self_state_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.resnet.Resnet18.get_params": [[90, 100], ["resnet.Resnet18.named_modules", "isinstance", "wd_params.append", "isinstance", "nowd_params.append", "list", "module.parameters"], "methods", ["None"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "wd_params", ",", "nowd_params", "=", "[", "]", ",", "[", "]", "\n", "for", "name", ",", "module", "in", "self", ".", "named_modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "module", ",", "(", "nn", ".", "Linear", ",", "nn", ".", "Conv2d", ")", ")", ":", "\n", "                ", "wd_params", ".", "append", "(", "module", ".", "weight", ")", "\n", "if", "not", "module", ".", "bias", "is", "None", ":", "\n", "                    ", "nowd_params", ".", "append", "(", "module", ".", "bias", ")", "\n", "", "", "elif", "isinstance", "(", "module", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "nowd_params", "+=", "list", "(", "module", ".", "parameters", "(", ")", ")", "\n", "", "", "return", "wd_params", ",", "nowd_params", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.resnet.conv3x3": [[14, 18], ["torch.Conv2d"], "function", ["None"], ["def", "conv3x3", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ")", ":", "\n", "    ", "\"\"\"3x3 convolution with padding\"\"\"", "\n", "return", "nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.resnet.create_layer_basic": [[51, 56], ["range", "torch.Sequential", "resnet.BasicBlock", "layers.append", "resnet.BasicBlock"], "function", ["None"], ["", "", "def", "create_layer_basic", "(", "in_chan", ",", "out_chan", ",", "bnum", ",", "stride", "=", "1", ")", ":", "\n", "    ", "layers", "=", "[", "BasicBlock", "(", "in_chan", ",", "out_chan", ",", "stride", "=", "stride", ")", "]", "\n", "for", "i", "in", "range", "(", "bnum", "-", "1", ")", ":", "\n", "        ", "layers", ".", "append", "(", "BasicBlock", "(", "out_chan", ",", "out_chan", ",", "stride", "=", "1", ")", ")", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.ConvBNReLU.__init__": [[15, 25], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "model.ConvBNReLU.init_weight"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__", "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.BiSeNet.init_weight"], ["    ", "def", "__init__", "(", "self", ",", "in_chan", ",", "out_chan", ",", "ks", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "ConvBNReLU", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv", "=", "nn", ".", "Conv2d", "(", "in_chan", ",", "\n", "out_chan", ",", "\n", "kernel_size", "=", "ks", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "padding", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "bn", "=", "nn", ".", "BatchNorm2d", "(", "out_chan", ")", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.ConvBNReLU.forward": [[26, 30], ["model.ConvBNReLU.conv", "torch.relu", "torch.relu", "torch.relu", "model.ConvBNReLU.bn"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv", "(", "x", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "bn", "(", "x", ")", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.ConvBNReLU.init_weight": [[31, 36], ["model.ConvBNReLU.children", "isinstance", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["None"], ["", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "for", "ly", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "ly", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.BiSeNetOutput.__init__": [[38, 43], ["torch.Module.__init__", "model.ConvBNReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "model.BiSeNetOutput.init_weight"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__", "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.BiSeNet.init_weight"], ["    ", "def", "__init__", "(", "self", ",", "in_chan", ",", "mid_chan", ",", "n_classes", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "BiSeNetOutput", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv", "=", "ConvBNReLU", "(", "in_chan", ",", "mid_chan", ",", "ks", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_out", "=", "nn", ".", "Conv2d", "(", "mid_chan", ",", "n_classes", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.BiSeNetOutput.forward": [[44, 48], ["model.BiSeNetOutput.conv", "model.BiSeNetOutput.conv_out"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv", "(", "x", ")", "\n", "x", "=", "self", ".", "conv_out", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.BiSeNetOutput.init_weight": [[49, 54], ["model.BiSeNetOutput.children", "isinstance", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["None"], ["", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "for", "ly", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "ly", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.BiSeNetOutput.get_params": [[55, 65], ["model.BiSeNetOutput.named_modules", "isinstance", "isinstance", "wd_params.append", "isinstance", "nowd_params.append", "list", "module.parameters"], "methods", ["None"], ["", "", "", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "wd_params", ",", "nowd_params", "=", "[", "]", ",", "[", "]", "\n", "for", "name", ",", "module", "in", "self", ".", "named_modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "module", ",", "nn", ".", "Linear", ")", "or", "isinstance", "(", "module", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "wd_params", ".", "append", "(", "module", ".", "weight", ")", "\n", "if", "not", "module", ".", "bias", "is", "None", ":", "\n", "                    ", "nowd_params", ".", "append", "(", "module", ".", "bias", ")", "\n", "", "", "elif", "isinstance", "(", "module", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "nowd_params", "+=", "list", "(", "module", ".", "parameters", "(", ")", ")", "\n", "", "", "return", "wd_params", ",", "nowd_params", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.AttentionRefinementModule.__init__": [[68, 75], ["torch.Module.__init__", "model.ConvBNReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Sigmoid", "torch.Sigmoid", "torch.Sigmoid", "model.AttentionRefinementModule.init_weight"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__", "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.BiSeNet.init_weight"], ["    ", "def", "__init__", "(", "self", ",", "in_chan", ",", "out_chan", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "AttentionRefinementModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv", "=", "ConvBNReLU", "(", "in_chan", ",", "out_chan", ",", "ks", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_atten", "=", "nn", ".", "Conv2d", "(", "out_chan", ",", "out_chan", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn_atten", "=", "nn", ".", "BatchNorm2d", "(", "out_chan", ")", "\n", "self", ".", "sigmoid_atten", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.AttentionRefinementModule.forward": [[76, 84], ["model.AttentionRefinementModule.conv", "torch.avg_pool2d", "torch.avg_pool2d", "torch.avg_pool2d", "model.AttentionRefinementModule.conv_atten", "model.AttentionRefinementModule.bn_atten", "model.AttentionRefinementModule.sigmoid_atten", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "model.AttentionRefinementModule.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "feat", "=", "self", ".", "conv", "(", "x", ")", "\n", "atten", "=", "F", ".", "avg_pool2d", "(", "feat", ",", "feat", ".", "size", "(", ")", "[", "2", ":", "]", ")", "\n", "atten", "=", "self", ".", "conv_atten", "(", "atten", ")", "\n", "atten", "=", "self", ".", "bn_atten", "(", "atten", ")", "\n", "atten", "=", "self", ".", "sigmoid_atten", "(", "atten", ")", "\n", "out", "=", "torch", ".", "mul", "(", "feat", ",", "atten", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.AttentionRefinementModule.init_weight": [[85, 90], ["model.AttentionRefinementModule.children", "isinstance", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["None"], ["", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "for", "ly", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "ly", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.ContextPath.__init__": [[93, 103], ["torch.Module.__init__", "resnet.Resnet18", "model.AttentionRefinementModule", "model.AttentionRefinementModule", "model.ConvBNReLU", "model.ConvBNReLU", "model.ConvBNReLU", "model.ContextPath.init_weight"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__", "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.BiSeNet.init_weight"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "ContextPath", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "resnet", "=", "Resnet18", "(", ")", "\n", "self", ".", "arm16", "=", "AttentionRefinementModule", "(", "256", ",", "128", ")", "\n", "self", ".", "arm32", "=", "AttentionRefinementModule", "(", "512", ",", "128", ")", "\n", "self", ".", "conv_head32", "=", "ConvBNReLU", "(", "128", ",", "128", ",", "ks", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_head16", "=", "ConvBNReLU", "(", "128", ",", "128", ",", "ks", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_avg", "=", "ConvBNReLU", "(", "512", ",", "128", ",", "ks", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.ContextPath.forward": [[104, 126], ["model.ContextPath.resnet", "torch.avg_pool2d", "torch.avg_pool2d", "torch.avg_pool2d", "model.ContextPath.conv_avg", "torch.interpolate", "torch.interpolate", "torch.interpolate", "model.ContextPath.arm32", "torch.interpolate", "torch.interpolate", "torch.interpolate", "model.ContextPath.conv_head32", "model.ContextPath.arm16", "torch.interpolate", "torch.interpolate", "torch.interpolate", "model.ContextPath.conv_head16", "x.size", "feat8.size", "feat16.size", "feat32.size", "feat32.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "H0", ",", "W0", "=", "x", ".", "size", "(", ")", "[", "2", ":", "]", "\n", "feat8", ",", "feat16", ",", "feat32", "=", "self", ".", "resnet", "(", "x", ")", "\n", "H8", ",", "W8", "=", "feat8", ".", "size", "(", ")", "[", "2", ":", "]", "\n", "H16", ",", "W16", "=", "feat16", ".", "size", "(", ")", "[", "2", ":", "]", "\n", "H32", ",", "W32", "=", "feat32", ".", "size", "(", ")", "[", "2", ":", "]", "\n", "\n", "avg", "=", "F", ".", "avg_pool2d", "(", "feat32", ",", "feat32", ".", "size", "(", ")", "[", "2", ":", "]", ")", "\n", "avg", "=", "self", ".", "conv_avg", "(", "avg", ")", "\n", "avg_up", "=", "F", ".", "interpolate", "(", "avg", ",", "(", "H32", ",", "W32", ")", ",", "mode", "=", "'nearest'", ")", "\n", "\n", "feat32_arm", "=", "self", ".", "arm32", "(", "feat32", ")", "\n", "feat32_sum", "=", "feat32_arm", "+", "avg_up", "\n", "feat32_up", "=", "F", ".", "interpolate", "(", "feat32_sum", ",", "(", "H16", ",", "W16", ")", ",", "mode", "=", "'nearest'", ")", "\n", "feat32_up", "=", "self", ".", "conv_head32", "(", "feat32_up", ")", "\n", "\n", "feat16_arm", "=", "self", ".", "arm16", "(", "feat16", ")", "\n", "feat16_sum", "=", "feat16_arm", "+", "feat32_up", "\n", "feat16_up", "=", "F", ".", "interpolate", "(", "feat16_sum", ",", "(", "H8", ",", "W8", ")", ",", "mode", "=", "'nearest'", ")", "\n", "feat16_up", "=", "self", ".", "conv_head16", "(", "feat16_up", ")", "\n", "\n", "return", "feat8", ",", "feat16_up", ",", "feat32_up", "# x8, x8, x16", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.ContextPath.init_weight": [[127, 132], ["model.ContextPath.children", "isinstance", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["None"], ["", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "for", "ly", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "ly", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.ContextPath.get_params": [[133, 143], ["model.ContextPath.named_modules", "isinstance", "wd_params.append", "isinstance", "nowd_params.append", "list", "module.parameters"], "methods", ["None"], ["", "", "", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "wd_params", ",", "nowd_params", "=", "[", "]", ",", "[", "]", "\n", "for", "name", ",", "module", "in", "self", ".", "named_modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "module", ",", "(", "nn", ".", "Linear", ",", "nn", ".", "Conv2d", ")", ")", ":", "\n", "                ", "wd_params", ".", "append", "(", "module", ".", "weight", ")", "\n", "if", "not", "module", ".", "bias", "is", "None", ":", "\n", "                    ", "nowd_params", ".", "append", "(", "module", ".", "bias", ")", "\n", "", "", "elif", "isinstance", "(", "module", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "nowd_params", "+=", "list", "(", "module", ".", "parameters", "(", ")", ")", "\n", "", "", "return", "wd_params", ",", "nowd_params", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.SpatialPath.__init__": [[147, 154], ["torch.Module.__init__", "model.ConvBNReLU", "model.ConvBNReLU", "model.ConvBNReLU", "model.ConvBNReLU", "model.SpatialPath.init_weight"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__", "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.BiSeNet.init_weight"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "SpatialPath", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "ConvBNReLU", "(", "3", ",", "64", ",", "ks", "=", "7", ",", "stride", "=", "2", ",", "padding", "=", "3", ")", "\n", "self", ".", "conv2", "=", "ConvBNReLU", "(", "64", ",", "64", ",", "ks", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv3", "=", "ConvBNReLU", "(", "64", ",", "64", ",", "ks", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_out", "=", "ConvBNReLU", "(", "64", ",", "128", ",", "ks", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.SpatialPath.forward": [[155, 161], ["model.SpatialPath.conv1", "model.SpatialPath.conv2", "model.SpatialPath.conv3", "model.SpatialPath.conv_out"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "feat", "=", "self", ".", "conv1", "(", "x", ")", "\n", "feat", "=", "self", ".", "conv2", "(", "feat", ")", "\n", "feat", "=", "self", ".", "conv3", "(", "feat", ")", "\n", "feat", "=", "self", ".", "conv_out", "(", "feat", ")", "\n", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.SpatialPath.init_weight": [[162, 167], ["model.SpatialPath.children", "isinstance", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["None"], ["", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "for", "ly", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "ly", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.SpatialPath.get_params": [[168, 178], ["model.SpatialPath.named_modules", "isinstance", "isinstance", "wd_params.append", "isinstance", "nowd_params.append", "list", "module.parameters"], "methods", ["None"], ["", "", "", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "wd_params", ",", "nowd_params", "=", "[", "]", ",", "[", "]", "\n", "for", "name", ",", "module", "in", "self", ".", "named_modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "module", ",", "nn", ".", "Linear", ")", "or", "isinstance", "(", "module", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "wd_params", ".", "append", "(", "module", ".", "weight", ")", "\n", "if", "not", "module", ".", "bias", "is", "None", ":", "\n", "                    ", "nowd_params", ".", "append", "(", "module", ".", "bias", ")", "\n", "", "", "elif", "isinstance", "(", "module", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "nowd_params", "+=", "list", "(", "module", ".", "parameters", "(", ")", ")", "\n", "", "", "return", "wd_params", ",", "nowd_params", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.FeatureFusionModule.__init__": [[181, 199], ["torch.Module.__init__", "model.ConvBNReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Sigmoid", "torch.Sigmoid", "torch.Sigmoid", "model.FeatureFusionModule.init_weight"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__", "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.BiSeNet.init_weight"], ["    ", "def", "__init__", "(", "self", ",", "in_chan", ",", "out_chan", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "FeatureFusionModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "convblk", "=", "ConvBNReLU", "(", "in_chan", ",", "out_chan", ",", "ks", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "out_chan", ",", "\n", "out_chan", "//", "4", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "out_chan", "//", "4", ",", "\n", "out_chan", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "sigmoid", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.FeatureFusionModule.forward": [[200, 211], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.FeatureFusionModule.convblk", "torch.avg_pool2d", "torch.avg_pool2d", "torch.avg_pool2d", "model.FeatureFusionModule.conv1", "model.FeatureFusionModule.relu", "model.FeatureFusionModule.conv2", "model.FeatureFusionModule.sigmoid", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "model.FeatureFusionModule.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "fsp", ",", "fcp", ")", ":", "\n", "        ", "fcat", "=", "torch", ".", "cat", "(", "[", "fsp", ",", "fcp", "]", ",", "dim", "=", "1", ")", "\n", "feat", "=", "self", ".", "convblk", "(", "fcat", ")", "\n", "atten", "=", "F", ".", "avg_pool2d", "(", "feat", ",", "feat", ".", "size", "(", ")", "[", "2", ":", "]", ")", "\n", "atten", "=", "self", ".", "conv1", "(", "atten", ")", "\n", "atten", "=", "self", ".", "relu", "(", "atten", ")", "\n", "atten", "=", "self", ".", "conv2", "(", "atten", ")", "\n", "atten", "=", "self", ".", "sigmoid", "(", "atten", ")", "\n", "feat_atten", "=", "torch", ".", "mul", "(", "feat", ",", "atten", ")", "\n", "feat_out", "=", "feat_atten", "+", "feat", "\n", "return", "feat_out", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.FeatureFusionModule.init_weight": [[212, 217], ["model.FeatureFusionModule.children", "isinstance", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["None"], ["", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "for", "ly", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "ly", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.FeatureFusionModule.get_params": [[218, 228], ["model.FeatureFusionModule.named_modules", "isinstance", "isinstance", "wd_params.append", "isinstance", "nowd_params.append", "list", "module.parameters"], "methods", ["None"], ["", "", "", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "wd_params", ",", "nowd_params", "=", "[", "]", ",", "[", "]", "\n", "for", "name", ",", "module", "in", "self", ".", "named_modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "module", ",", "nn", ".", "Linear", ")", "or", "isinstance", "(", "module", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "wd_params", ".", "append", "(", "module", ".", "weight", ")", "\n", "if", "not", "module", ".", "bias", "is", "None", ":", "\n", "                    ", "nowd_params", ".", "append", "(", "module", ".", "bias", ")", "\n", "", "", "elif", "isinstance", "(", "module", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "nowd_params", "+=", "list", "(", "module", ".", "parameters", "(", ")", ")", "\n", "", "", "return", "wd_params", ",", "nowd_params", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.BiSeNet.__init__": [[231, 240], ["torch.Module.__init__", "model.ContextPath", "model.FeatureFusionModule", "model.BiSeNetOutput", "model.BiSeNetOutput", "model.BiSeNetOutput", "model.BiSeNet.init_weight"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__", "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.BiSeNet.init_weight"], ["    ", "def", "__init__", "(", "self", ",", "n_classes", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "BiSeNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "cp", "=", "ContextPath", "(", ")", "\n", "## here self.sp is deleted", "\n", "self", ".", "ffm", "=", "FeatureFusionModule", "(", "256", ",", "256", ")", "\n", "self", ".", "conv_out", "=", "BiSeNetOutput", "(", "256", ",", "256", ",", "n_classes", ")", "\n", "self", ".", "conv_out16", "=", "BiSeNetOutput", "(", "128", ",", "64", ",", "n_classes", ")", "\n", "self", ".", "conv_out32", "=", "BiSeNetOutput", "(", "128", ",", "64", ",", "n_classes", ")", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.BiSeNet.forward": [[241, 255], ["model.BiSeNet.cp", "model.BiSeNet.ffm", "model.BiSeNet.conv_out", "model.BiSeNet.conv_out16", "model.BiSeNet.conv_out32", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "x.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "H", ",", "W", "=", "x", ".", "size", "(", ")", "[", "2", ":", "]", "\n", "feat_res8", ",", "feat_cp8", ",", "feat_cp16", "=", "self", ".", "cp", "(", "x", ")", "# here return res3b1 feature", "\n", "feat_sp", "=", "feat_res8", "# use res3b1 feature to replace spatial path feature", "\n", "feat_fuse", "=", "self", ".", "ffm", "(", "feat_sp", ",", "feat_cp8", ")", "\n", "\n", "feat_out", "=", "self", ".", "conv_out", "(", "feat_fuse", ")", "\n", "feat_out16", "=", "self", ".", "conv_out16", "(", "feat_cp8", ")", "\n", "feat_out32", "=", "self", ".", "conv_out32", "(", "feat_cp16", ")", "\n", "\n", "feat_out", "=", "F", ".", "interpolate", "(", "feat_out", ",", "(", "H", ",", "W", ")", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "True", ")", "\n", "feat_out16", "=", "F", ".", "interpolate", "(", "feat_out16", ",", "(", "H", ",", "W", ")", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "True", ")", "\n", "feat_out32", "=", "F", ".", "interpolate", "(", "feat_out32", ",", "(", "H", ",", "W", ")", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "True", ")", "\n", "return", "feat_out", ",", "feat_out16", ",", "feat_out32", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.BiSeNet.init_weight": [[256, 261], ["model.BiSeNet.children", "isinstance", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["None"], ["", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "for", "ly", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "ly", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.BiSeNet.get_params": [[262, 273], ["model.BiSeNet.named_children", "child.get_params", "isinstance", "isinstance"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.parsing.model.BiSeNet.get_params"], ["", "", "", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "wd_params", ",", "nowd_params", ",", "lr_mul_wd_params", ",", "lr_mul_nowd_params", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "name", ",", "child", "in", "self", ".", "named_children", "(", ")", ":", "\n", "            ", "child_wd_params", ",", "child_nowd_params", "=", "child", ".", "get_params", "(", ")", "\n", "if", "isinstance", "(", "child", ",", "FeatureFusionModule", ")", "or", "isinstance", "(", "child", ",", "BiSeNetOutput", ")", ":", "\n", "                ", "lr_mul_wd_params", "+=", "child_wd_params", "\n", "lr_mul_nowd_params", "+=", "child_nowd_params", "\n", "", "else", ":", "\n", "                ", "wd_params", "+=", "child_wd_params", "\n", "nowd_params", "+=", "child_nowd_params", "\n", "", "", "return", "wd_params", ",", "nowd_params", ",", "lr_mul_wd_params", ",", "lr_mul_nowd_params", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.insightface_func.face_detect_crop_multi.Face_detect_crop.__init__": [[31, 49], ["os.path.expanduser", "os.path.expanduser", "os.path.expanduser", "os.path.expanduser", "glob.glob", "sorted", "os.join", "os.join", "insightface.model_zoo.model_zoo.get_model", "onnx_file.find", "print", "print"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "name", ",", "root", "=", "'~/.insightface_func/models'", ")", ":", "\n", "        ", "self", ".", "models", "=", "{", "}", "\n", "root", "=", "os", ".", "path", ".", "expanduser", "(", "root", ")", "\n", "onnx_files", "=", "glob", ".", "glob", "(", "osp", ".", "join", "(", "root", ",", "name", ",", "'*.onnx'", ")", ")", "\n", "onnx_files", "=", "sorted", "(", "onnx_files", ")", "\n", "for", "onnx_file", "in", "onnx_files", ":", "\n", "            ", "if", "onnx_file", ".", "find", "(", "'_selfgen_'", ")", ">", "0", ":", "\n", "#print('ignore:', onnx_file)", "\n", "                ", "continue", "\n", "", "model", "=", "model_zoo", ".", "get_model", "(", "onnx_file", ")", "\n", "if", "model", ".", "taskname", "not", "in", "self", ".", "models", ":", "\n", "                ", "print", "(", "'find model:'", ",", "onnx_file", ",", "model", ".", "taskname", ")", "\n", "self", ".", "models", "[", "model", ".", "taskname", "]", "=", "model", "\n", "", "else", ":", "\n", "                ", "print", "(", "'duplicated model task type, ignore:'", ",", "onnx_file", ",", "model", ".", "taskname", ")", "\n", "del", "model", "\n", "", "", "assert", "'detection'", "in", "self", ".", "models", "\n", "self", ".", "det_model", "=", "self", ".", "models", "[", "'detection'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.insightface_func.face_detect_crop_multi.Face_detect_crop.prepare": [[51, 62], ["print", "face_detect_crop_multi.Face_detect_crop.models.items", "model.prepare", "model.prepare"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.insightface_func.face_detect_crop_single.Face_detect_crop.prepare", "home.repos.pwc.inspect_result.ailon-island_facke.insightface_func.face_detect_crop_single.Face_detect_crop.prepare"], ["", "def", "prepare", "(", "self", ",", "ctx_id", ",", "det_thresh", "=", "0.5", ",", "det_size", "=", "(", "640", ",", "640", ")", ",", "mode", "=", "'None'", ")", ":", "\n", "        ", "self", ".", "det_thresh", "=", "det_thresh", "\n", "self", ".", "mode", "=", "mode", "\n", "assert", "det_size", "is", "not", "None", "\n", "print", "(", "'set det-size:'", ",", "det_size", ")", "\n", "self", ".", "det_size", "=", "det_size", "\n", "for", "taskname", ",", "model", "in", "self", ".", "models", ".", "items", "(", ")", ":", "\n", "            ", "if", "taskname", "==", "'detection'", ":", "\n", "                ", "model", ".", "prepare", "(", "ctx_id", ",", "input_size", "=", "det_size", ")", "\n", "", "else", ":", "\n", "                ", "model", ".", "prepare", "(", "ctx_id", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.insightface_func.face_detect_crop_multi.Face_detect_crop.get": [[63, 101], ["face_detect_crop_multi.Face_detect_crop.det_model.detect", "range", "insightface_func.utils.face_align_ffhqandnewarc.estimate_norm", "cv2.warpAffine", "align_img_list.append", "M_list.append"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.utils.face_align_ffhqandnewarc.estimate_norm"], ["", "", "", "def", "get", "(", "self", ",", "img", ",", "crop_size", ",", "max_num", "=", "0", ")", ":", "\n", "        ", "bboxes", ",", "kpss", "=", "self", ".", "det_model", ".", "detect", "(", "img", ",", "\n", "threshold", "=", "self", ".", "det_thresh", ",", "\n", "max_num", "=", "max_num", ",", "\n", "metric", "=", "'default'", ")", "\n", "if", "bboxes", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "            ", "return", "None", "\n", "", "ret", "=", "[", "]", "\n", "# for i in range(bboxes.shape[0]):", "\n", "#     bbox = bboxes[i, 0:4]", "\n", "#     det_score = bboxes[i, 4]", "\n", "#     kps = None", "\n", "#     if kpss is not None:", "\n", "#         kps = kpss[i]", "\n", "#     M, _ = face_align.estimate_norm(kps, crop_size, mode ='None') ", "\n", "#     align_img = cv2.warpAffine(img, M, (crop_size, crop_size), borderValue=0.0)", "\n", "align_img_list", "=", "[", "]", "\n", "M_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "bboxes", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "kps", "=", "None", "\n", "if", "kpss", "is", "not", "None", ":", "\n", "                ", "kps", "=", "kpss", "[", "i", "]", "\n", "", "M", ",", "_", "=", "face_align", ".", "estimate_norm", "(", "kps", ",", "crop_size", ",", "mode", "=", "self", ".", "mode", ")", "\n", "align_img", "=", "cv2", ".", "warpAffine", "(", "img", ",", "M", ",", "(", "crop_size", ",", "crop_size", ")", ",", "borderValue", "=", "0.0", ")", "\n", "align_img_list", ".", "append", "(", "align_img", ")", "\n", "M_list", ".", "append", "(", "M", ")", "\n", "\n", "# det_score = bboxes[..., 4]", "\n", "\n", "# best_index = np.argmax(det_score)", "\n", "\n", "# kps = None", "\n", "# if kpss is not None:", "\n", "#     kps = kpss[best_index]", "\n", "# M, _ = face_align.estimate_norm(kps, crop_size, mode ='None') ", "\n", "# align_img = cv2.warpAffine(img, M, (crop_size, crop_size), borderValue=0.0)", "\n", "\n", "", "return", "align_img_list", ",", "M_list", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.insightface_func.face_detect_crop_single.Face_detect_crop.__init__": [[31, 49], ["os.path.expanduser", "os.path.expanduser", "os.path.expanduser", "os.path.expanduser", "glob.glob", "sorted", "os.join", "os.join", "insightface.model_zoo.model_zoo.get_model", "onnx_file.find", "print", "print"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "name", ",", "root", "=", "'~/.insightface_func/models'", ")", ":", "\n", "        ", "self", ".", "models", "=", "{", "}", "\n", "root", "=", "os", ".", "path", ".", "expanduser", "(", "root", ")", "\n", "onnx_files", "=", "glob", ".", "glob", "(", "osp", ".", "join", "(", "root", ",", "name", ",", "'*.onnx'", ")", ")", "\n", "onnx_files", "=", "sorted", "(", "onnx_files", ")", "\n", "for", "onnx_file", "in", "onnx_files", ":", "\n", "            ", "if", "onnx_file", ".", "find", "(", "'_selfgen_'", ")", ">", "0", ":", "\n", "#print('ignore:', onnx_file)", "\n", "                ", "continue", "\n", "", "model", "=", "model_zoo", ".", "get_model", "(", "onnx_file", ")", "\n", "if", "model", ".", "taskname", "not", "in", "self", ".", "models", ":", "\n", "                ", "print", "(", "'find model:'", ",", "onnx_file", ",", "model", ".", "taskname", ")", "\n", "self", ".", "models", "[", "model", ".", "taskname", "]", "=", "model", "\n", "", "else", ":", "\n", "                ", "print", "(", "'duplicated model task type, ignore:'", ",", "onnx_file", ",", "model", ".", "taskname", ")", "\n", "del", "model", "\n", "", "", "assert", "'detection'", "in", "self", ".", "models", "\n", "self", ".", "det_model", "=", "self", ".", "models", "[", "'detection'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.insightface_func.face_detect_crop_single.Face_detect_crop.prepare": [[51, 62], ["print", "face_detect_crop_single.Face_detect_crop.models.items", "model.prepare", "model.prepare"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.insightface_func.face_detect_crop_single.Face_detect_crop.prepare", "home.repos.pwc.inspect_result.ailon-island_facke.insightface_func.face_detect_crop_single.Face_detect_crop.prepare"], ["", "def", "prepare", "(", "self", ",", "ctx_id", ",", "det_thresh", "=", "0.5", ",", "det_size", "=", "(", "640", ",", "640", ")", ",", "mode", "=", "'None'", ")", ":", "\n", "        ", "self", ".", "det_thresh", "=", "det_thresh", "\n", "self", ".", "mode", "=", "mode", "\n", "assert", "det_size", "is", "not", "None", "\n", "print", "(", "'set det-size:'", ",", "det_size", ")", "\n", "self", ".", "det_size", "=", "det_size", "\n", "for", "taskname", ",", "model", "in", "self", ".", "models", ".", "items", "(", ")", ":", "\n", "            ", "if", "taskname", "==", "'detection'", ":", "\n", "                ", "model", ".", "prepare", "(", "ctx_id", ",", "input_size", "=", "det_size", ")", "\n", "", "else", ":", "\n", "                ", "model", ".", "prepare", "(", "ctx_id", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.insightface_func.face_detect_crop_single.Face_detect_crop.get": [[63, 98], ["face_detect_crop_single.Face_detect_crop.det_model.detect", "numpy.argmax", "insightface_func.utils.face_align_ffhqandnewarc.estimate_norm", "cv2.warpAffine"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.utils.face_align_ffhqandnewarc.estimate_norm"], ["", "", "", "def", "get", "(", "self", ",", "img", ",", "crop_size", ",", "max_num", "=", "0", ")", ":", "\n", "        ", "bboxes", ",", "kpss", "=", "self", ".", "det_model", ".", "detect", "(", "img", ",", "\n", "threshold", "=", "self", ".", "det_thresh", ",", "\n", "max_num", "=", "max_num", ",", "\n", "metric", "=", "'default'", ")", "\n", "if", "bboxes", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "            ", "return", "None", "\n", "# ret = []", "\n", "# for i in range(bboxes.shape[0]):", "\n", "#     bbox = bboxes[i, 0:4]", "\n", "#     det_score = bboxes[i, 4]", "\n", "#     kps = None", "\n", "#     if kpss is not None:", "\n", "#         kps = kpss[i]", "\n", "#     M, _ = face_align.estimate_norm(kps, crop_size, mode ='None') ", "\n", "#     align_img = cv2.warpAffine(img, M, (crop_size, crop_size), borderValue=0.0)", "\n", "# for i in range(bboxes.shape[0]):", "\n", "#     kps = None", "\n", "#     if kpss is not None:", "\n", "#         kps = kpss[i]", "\n", "#     M, _ = face_align.estimate_norm(kps, crop_size, mode ='None') ", "\n", "#     align_img = cv2.warpAffine(img, M, (crop_size, crop_size), borderValue=0.0)", "\n", "\n", "", "det_score", "=", "bboxes", "[", "...", ",", "4", "]", "\n", "\n", "# select the face with the hightest detection score", "\n", "best_index", "=", "np", ".", "argmax", "(", "det_score", ")", "\n", "\n", "kps", "=", "None", "\n", "if", "kpss", "is", "not", "None", ":", "\n", "            ", "kps", "=", "kpss", "[", "best_index", "]", "\n", "", "M", ",", "_", "=", "face_align", ".", "estimate_norm", "(", "kps", ",", "crop_size", ",", "mode", "=", "self", ".", "mode", ")", "\n", "align_img", "=", "cv2", ".", "warpAffine", "(", "img", ",", "M", ",", "(", "crop_size", ",", "crop_size", ")", ",", "borderValue", "=", "0.0", ")", "\n", "\n", "return", "[", "align_img", "]", ",", "[", "M", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.models.models.SEBlock.__init__": [[37, 45], ["torch.nn.Module.__init__", "torch.nn.AdaptiveAvgPool2d", "torch.nn.AdaptiveAvgPool2d", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.PReLU", "torch.nn.PReLU", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Sigmoid", "torch.nn.Sigmoid"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["    ", "def", "__init__", "(", "self", ",", "channel", ",", "reduction", "=", "16", ")", ":", "\n", "        ", "super", "(", "SEBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "avg_pool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "1", ")", "\n", "self", ".", "fc", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "channel", ",", "channel", "//", "reduction", ")", ",", "\n", "nn", ".", "PReLU", "(", ")", ",", "\n", "nn", ".", "Linear", "(", "channel", "//", "reduction", ",", "channel", ")", ",", "\n", "nn", ".", "Sigmoid", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.models.models.SEBlock.forward": [[47, 52], ["x.size", "models.SEBlock.avg_pool().view", "models.SEBlock.fc().view", "models.SEBlock.avg_pool", "models.SEBlock.fc"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "b", ",", "c", ",", "_", ",", "_", "=", "x", ".", "size", "(", ")", "\n", "y", "=", "self", ".", "avg_pool", "(", "x", ")", ".", "view", "(", "b", ",", "c", ")", "\n", "y", "=", "self", ".", "fc", "(", "y", ")", ".", "view", "(", "b", ",", "c", ",", "1", ",", "1", ")", "\n", "return", "x", "*", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.models.models.IRBlock.__init__": [[57, 70], ["torch.nn.Module.__init__", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "models.conv3x3", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.PReLU", "torch.nn.PReLU", "models.conv3x3", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "models.SEBlock"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__", "home.repos.pwc.inspect_result.ailon-island_facke.models.models.conv3x3", "home.repos.pwc.inspect_result.ailon-island_facke.models.models.conv3x3"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", "=", "1", ",", "downsample", "=", "None", ",", "use_se", "=", "True", ")", ":", "\n", "        ", "super", "(", "IRBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "bn0", "=", "nn", ".", "BatchNorm2d", "(", "inplanes", ")", "\n", "self", ".", "conv1", "=", "conv3x3", "(", "inplanes", ",", "inplanes", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "inplanes", ")", "\n", "self", ".", "prelu", "=", "nn", ".", "PReLU", "(", ")", "\n", "self", ".", "conv2", "=", "conv3x3", "(", "inplanes", ",", "planes", ",", "stride", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "downsample", "=", "downsample", "\n", "self", ".", "stride", "=", "stride", "\n", "self", ".", "use_se", "=", "use_se", "\n", "if", "self", ".", "use_se", ":", "\n", "            ", "self", ".", "se", "=", "SEBlock", "(", "planes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.models.models.IRBlock.forward": [[71, 90], ["models.IRBlock.bn0", "models.IRBlock.conv1", "models.IRBlock.bn1", "models.IRBlock.prelu", "models.IRBlock.conv2", "models.IRBlock.bn2", "models.IRBlock.prelu", "models.IRBlock.se", "models.IRBlock.downsample"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "residual", "=", "x", "\n", "out", "=", "self", ".", "bn0", "(", "x", ")", "\n", "out", "=", "self", ".", "conv1", "(", "out", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "prelu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "if", "self", ".", "use_se", ":", "\n", "            ", "out", "=", "self", ".", "se", "(", "out", ")", "\n", "\n", "", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "residual", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "residual", "\n", "out", "=", "self", ".", "prelu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.models.models.ResNet.__init__": [[94, 120], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.PReLU", "torch.nn.PReLU", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "models.ResNet._make_layer", "models.ResNet._make_layer", "models.ResNet._make_layer", "models.ResNet._make_layer", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.BatchNorm1d", "torch.nn.BatchNorm1d", "models.ResNet.modules", "isinstance", "torch.nn.init.xavier_normal_", "torch.nn.init.xavier_normal_", "isinstance", "isinstance", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "isinstance", "torch.nn.init.xavier_normal_", "torch.nn.init.xavier_normal_", "torch.nn.init.constant_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__", "home.repos.pwc.inspect_result.ailon-island_facke.models.models.sphere._make_layer", "home.repos.pwc.inspect_result.ailon-island_facke.models.models.sphere._make_layer", "home.repos.pwc.inspect_result.ailon-island_facke.models.models.sphere._make_layer", "home.repos.pwc.inspect_result.ailon-island_facke.models.models.sphere._make_layer"], ["    ", "def", "__init__", "(", "self", ",", "block", ",", "layers", ",", "use_se", "=", "True", ")", ":", "\n", "        ", "self", ".", "inplanes", "=", "64", "\n", "self", ".", "use_se", "=", "use_se", "\n", "super", "(", "ResNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "3", ",", "64", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "64", ")", "\n", "self", ".", "prelu", "=", "nn", ".", "PReLU", "(", ")", "\n", "self", ".", "maxpool", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "block", ",", "64", ",", "layers", "[", "0", "]", ")", "\n", "self", ".", "layer2", "=", "self", ".", "_make_layer", "(", "block", ",", "128", ",", "layers", "[", "1", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer3", "=", "self", ".", "_make_layer", "(", "block", ",", "256", ",", "layers", "[", "2", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer4", "=", "self", ".", "_make_layer", "(", "block", ",", "512", ",", "layers", "[", "3", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "512", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", ")", "\n", "self", ".", "fc", "=", "nn", ".", "Linear", "(", "512", "*", "7", "*", "7", ",", "512", ")", "\n", "self", ".", "bn3", "=", "nn", ".", "BatchNorm1d", "(", "512", ")", "\n", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "xavier_normal_", "(", "m", ".", "weight", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", "or", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm1d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "weight", ",", "1", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                ", "nn", ".", "init", ".", "xavier_normal_", "(", "m", ".", "weight", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.models.models.ResNet._make_layer": [[121, 137], ["layers.append", "range", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "block", "layers.append", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "block"], "methods", ["None"], ["", "", "", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "blocks", ",", "stride", "=", "1", ")", ":", "\n", "        ", "downsample", "=", "None", "\n", "if", "stride", "!=", "1", "or", "self", ".", "inplanes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "            ", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "self", ".", "inplanes", ",", "planes", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "planes", "*", "block", ".", "expansion", ")", ",", "\n", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "stride", ",", "downsample", ",", "use_se", "=", "self", ".", "use_se", ")", ")", "\n", "self", ".", "inplanes", "=", "planes", "\n", "for", "i", "in", "range", "(", "1", ",", "blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "use_se", "=", "self", ".", "use_se", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.models.models.ResNet.forward": [[138, 156], ["models.ResNet.conv1", "models.ResNet.bn1", "models.ResNet.prelu", "models.ResNet.maxpool", "models.ResNet.layer1", "models.ResNet.layer2", "models.ResNet.layer3", "models.ResNet.layer4", "models.ResNet.bn2", "models.ResNet.dropout", "models.ResNet.view", "models.ResNet.fc", "models.ResNet.bn3", "models.ResNet.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1", "(", "x", ")", "\n", "x", "=", "self", ".", "prelu", "(", "x", ")", "\n", "x", "=", "self", ".", "maxpool", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "layer1", "(", "x", ")", "\n", "x", "=", "self", ".", "layer2", "(", "x", ")", "\n", "x", "=", "self", ".", "layer3", "(", "x", ")", "\n", "x", "=", "self", ".", "layer4", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "bn2", "(", "x", ")", "\n", "x", "=", "self", ".", "dropout", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "x", "=", "self", ".", "fc", "(", "x", ")", "\n", "x", "=", "self", ".", "bn3", "(", "x", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.models.models.ArcMarginModel.__init__": [[159, 173], ["torch.nn.Module.__init__", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "math.cos", "math.sin", "math.cos", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "math.sin"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["    ", "def", "__init__", "(", "self", ",", "args", ")", ":", "\n", "        ", "super", "(", "ArcMarginModel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "weight", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "num_classes", ",", "args", ".", "emb_size", ")", ")", "\n", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "weight", ")", "\n", "\n", "self", ".", "easy_margin", "=", "args", ".", "easy_margin", "\n", "self", ".", "m", "=", "args", ".", "margin_m", "\n", "self", ".", "s", "=", "args", ".", "margin_s", "\n", "\n", "self", ".", "cos_m", "=", "math", ".", "cos", "(", "self", ".", "m", ")", "\n", "self", ".", "sin_m", "=", "math", ".", "sin", "(", "self", ".", "m", ")", "\n", "self", ".", "th", "=", "math", ".", "cos", "(", "math", ".", "pi", "-", "self", ".", "m", ")", "\n", "self", ".", "mm", "=", "math", ".", "sin", "(", "math", ".", "pi", "-", "self", ".", "m", ")", "*", "self", ".", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.models.models.ArcMarginModel.forward": [[174, 189], ["torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.linear", "torch.linear", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros.scatter_", "torch.zeros.scatter_", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.linear.size", "label.view().long", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "label.view"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.linear", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.linear"], ["", "def", "forward", "(", "self", ",", "input", ",", "label", ")", ":", "\n", "        ", "x", "=", "F", ".", "normalize", "(", "input", ")", "\n", "W", "=", "F", ".", "normalize", "(", "self", ".", "weight", ")", "\n", "cosine", "=", "F", ".", "linear", "(", "x", ",", "W", ")", "\n", "sine", "=", "torch", ".", "sqrt", "(", "1.0", "-", "torch", ".", "pow", "(", "cosine", ",", "2", ")", ")", "\n", "phi", "=", "cosine", "*", "self", ".", "cos_m", "-", "sine", "*", "self", ".", "sin_m", "# cos(theta + m)", "\n", "if", "self", ".", "easy_margin", ":", "\n", "            ", "phi", "=", "torch", ".", "where", "(", "cosine", ">", "0", ",", "phi", ",", "cosine", ")", "\n", "", "else", ":", "\n", "            ", "phi", "=", "torch", ".", "where", "(", "cosine", ">", "self", ".", "th", ",", "phi", ",", "cosine", "-", "self", ".", "mm", ")", "\n", "", "one_hot", "=", "torch", ".", "zeros", "(", "cosine", ".", "size", "(", ")", ",", "device", "=", "device", ")", "\n", "one_hot", ".", "scatter_", "(", "1", ",", "label", ".", "view", "(", "-", "1", ",", "1", ")", ".", "long", "(", ")", ",", "1", ")", "\n", "output", "=", "(", "one_hot", "*", "phi", ")", "+", "(", "(", "1.0", "-", "one_hot", ")", "*", "cosine", ")", "\n", "output", "*=", "self", ".", "s", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.models.models.Block.__init__": [[199, 205], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.PReLU", "torch.nn.PReLU", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.PReLU", "torch.nn.PReLU"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["    ", "def", "__init__", "(", "self", ",", "planes", ")", ":", "\n", "        ", "super", "(", "Block", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "prelu1", "=", "nn", ".", "PReLU", "(", "planes", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "prelu2", "=", "nn", ".", "PReLU", "(", "planes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.models.models.Block.forward": [[206, 208], ["models.Block.prelu2", "models.Block.conv2", "models.Block.prelu1", "models.Block.conv1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "+", "self", ".", "prelu2", "(", "self", ".", "conv2", "(", "self", ".", "prelu1", "(", "self", ".", "conv1", "(", "x", ")", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.models.models.sphere.__init__": [[211, 238], ["torch.nn.Module.__init__", "models.sphere._make_layer", "models.sphere._make_layer", "models.sphere._make_layer", "models.sphere._make_layer", "torch.nn.Linear", "torch.nn.Linear", "models.sphere.modules", "ValueError", "isinstance", "isinstance", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.normal_", "torch.nn.init.normal_", "str"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__", "home.repos.pwc.inspect_result.ailon-island_facke.models.models.sphere._make_layer", "home.repos.pwc.inspect_result.ailon-island_facke.models.models.sphere._make_layer", "home.repos.pwc.inspect_result.ailon-island_facke.models.models.sphere._make_layer", "home.repos.pwc.inspect_result.ailon-island_facke.models.models.sphere._make_layer"], ["    ", "def", "__init__", "(", "self", ",", "type", "=", "20", ",", "is_gray", "=", "False", ")", ":", "\n", "        ", "super", "(", "sphere", ",", "self", ")", ".", "__init__", "(", ")", "\n", "block", "=", "Block", "\n", "if", "type", "is", "20", ":", "\n", "            ", "layers", "=", "[", "1", ",", "2", ",", "4", ",", "1", "]", "\n", "", "elif", "type", "is", "64", ":", "\n", "            ", "layers", "=", "[", "3", ",", "7", ",", "16", ",", "3", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'sphere'", "+", "str", "(", "type", ")", "+", "\" IS NOT SUPPORTED! (sphere20 or sphere64)\"", ")", "\n", "", "filter_list", "=", "[", "3", ",", "64", ",", "128", ",", "256", ",", "512", "]", "\n", "if", "is_gray", ":", "\n", "            ", "filter_list", "[", "0", "]", "=", "1", "\n", "\n", "", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "block", ",", "filter_list", "[", "0", "]", ",", "filter_list", "[", "1", "]", ",", "layers", "[", "0", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer2", "=", "self", ".", "_make_layer", "(", "block", ",", "filter_list", "[", "1", "]", ",", "filter_list", "[", "2", "]", ",", "layers", "[", "1", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer3", "=", "self", ".", "_make_layer", "(", "block", ",", "filter_list", "[", "2", "]", ",", "filter_list", "[", "3", "]", ",", "layers", "[", "2", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer4", "=", "self", ".", "_make_layer", "(", "block", ",", "filter_list", "[", "3", "]", ",", "filter_list", "[", "4", "]", ",", "layers", "[", "3", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "fc", "=", "nn", ".", "Linear", "(", "512", "*", "7", "*", "6", ",", "512", ")", "\n", "\n", "# Weight initialization", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", "or", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                ", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "nn", ".", "init", ".", "xavier_uniform_", "(", "m", ".", "weight", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0.0", ")", "\n", "", "else", ":", "\n", "                    ", "nn", ".", "init", ".", "normal_", "(", "m", ".", "weight", ",", "0", ",", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.models.models.sphere._make_layer": [[240, 248], ["layers.append", "layers.append", "range", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.PReLU", "torch.nn.PReLU", "layers.append", "block"], "methods", ["None"], ["", "", "", "", "def", "_make_layer", "(", "self", ",", "block", ",", "inplanes", ",", "planes", ",", "blocks", ",", "stride", ")", ":", "\n", "        ", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "nn", ".", "Conv2d", "(", "inplanes", ",", "planes", ",", "3", ",", "stride", ",", "1", ")", ")", "\n", "layers", ".", "append", "(", "nn", ".", "PReLU", "(", "planes", ")", ")", "\n", "for", "i", "in", "range", "(", "blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "planes", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.models.models.sphere.forward": [[249, 259], ["models.sphere.layer1", "models.sphere.layer2", "models.sphere.layer3", "models.sphere.layer4", "models.sphere.view", "models.sphere.fc", "models.sphere.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "layer1", "(", "x", ")", "\n", "x", "=", "self", ".", "layer2", "(", "x", ")", "\n", "x", "=", "self", ".", "layer3", "(", "x", ")", "\n", "x", "=", "self", ".", "layer4", "(", "x", ")", "\n", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "x", "=", "self", ".", "fc", "(", "x", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.models.models.sphere.save": [[260, 263], ["open", "torch.save", "torch.save", "torch.save", "torch.save", "models.sphere.state_dict"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.save", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.save", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.save", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.save"], ["", "def", "save", "(", "self", ",", "file_path", ")", ":", "\n", "        ", "with", "open", "(", "file_path", ",", "'wb'", ")", "as", "f", ":", "\n", "            ", "torch", ".", "save", "(", "self", ".", "state_dict", "(", ")", ",", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.models.models.create_model": [[8, 24], ["ILVR.init", "SimSwapGAN", "len", "torch.nn.DataParallel", "CVAE", "ILVR"], "function", ["home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.init"], ["def", "create_model", "(", "opt", ")", ":", "\n", "    ", "if", "opt", ".", "model", "==", "'SimSwap'", ":", "\n", "        ", "from", ".", "SimSwap", ".", "model", "import", "SimSwapGAN", "\n", "model", "=", "SimSwapGAN", "(", ")", "\n", "", "elif", "opt", ".", "model", "==", "'CVAE'", ":", "\n", "        ", "from", ".", "CVAE", ".", "model", "import", "CVAE", "\n", "model", "=", "CVAE", "(", ")", "\n", "", "elif", "opt", ".", "model", "==", "'ILVR'", ":", "\n", "        ", "from", "models", ".", "ILVR", ".", "model", "import", "ILVR", "\n", "model", "=", "ILVR", "(", ")", "\n", "\n", "", "model", ".", "init", "(", "opt", ")", "\n", "\n", "if", "opt", ".", "isTrain", "and", "len", "(", "opt", ".", "gpu_ids", ")", ":", "\n", "        ", "model", "=", "nn", ".", "DataParallel", "(", "model", ")", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.models.models.conv3x3": [[31, 35], ["torch.nn.Conv2d"], "function", ["None"], ["", "def", "conv3x3", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ")", ":", "\n", "    ", "\"\"\"3x3 convolution with padding\"\"\"", "\n", "return", "nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.__init__": [[12, 14], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "ModelBase", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.init": [[16, 22], ["os.path.join"], "methods", ["None"], ["", "def", "init", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "opt", "=", "opt", "\n", "self", ".", "gpu_ids", "=", "opt", ".", "gpu_ids", "\n", "self", ".", "isTrain", "=", "opt", ".", "isTrain", "\n", "self", ".", "Tensor", "=", "torch", ".", "cuda", ".", "FloatTensor", "if", "self", ".", "gpu_ids", "else", "torch", ".", "Tensor", "\n", "self", ".", "save_dir", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "checkpoints_dir", ",", "opt", ".", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.forward": [[24, 26], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.save_net": [[28, 36], ["os.path.join", "utils.utils.utils.mkdirs", "os.path.join", "torch.save", "net.cpu().state_dict", "len", "torch.cuda.is_available", "net.cuda", "net.cpu"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.mkdirs", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.save"], ["", "def", "save_net", "(", "self", ",", "net", ",", "net_name", ",", "epoch_label", ",", "gpu_ids", ")", ":", "\n", "        ", "save_dir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "net_name", ")", "\n", "utils", ".", "mkdirs", "(", "save_dir", ")", "\n", "save_path", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "epoch_label", "+", "\".pth\"", ")", "\n", "\n", "torch", ".", "save", "(", "net", ".", "cpu", "(", ")", ".", "state_dict", "(", ")", ",", "save_path", ")", "\n", "if", "len", "(", "gpu_ids", ")", "and", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "net", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.load_net": [[38, 47], ["os.path.join", "os.path.isfile", "print", "net.load_state_dict", "torch.load"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.dist_util.load_state_dict", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.load"], ["", "", "def", "load_net", "(", "self", ",", "net", ",", "net_name", ",", "epoch_label", ",", "gpu_ids", ",", "save_dir", "=", "''", ")", ":", "\n", "        ", "if", "not", "save_dir", ":", "\n", "            ", "save_dir", "=", "self", ".", "save_dir", "\n", "", "save_path", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "net_name", ",", "epoch_label", "+", "'.pth'", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "save_path", ")", ":", "\n", "            ", "print", "(", "'{} does not exist!'", ".", "format", "(", "save_path", ")", ")", "\n", "", "else", ":", "\n", "            ", "net", ".", "load_state_dict", "(", "torch", ".", "load", "(", "save_path", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.SimSwap.networks.InstanceNorm.__init__": [[10, 17], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["    ", "def", "__init__", "(", "self", ",", "epsilon", "=", "1e-8", ")", ":", "\n", "        ", "\"\"\"\n            @notice: avoid in-place ops.\n            https://discuss.pytorch.org/t/encounter-the-runtimeerror-one-of-the-variables-needed-for-gradient-computation-has-been-modified-by-an-inplace-operation/836/3\n        \"\"\"", "\n", "super", "(", "InstanceNorm", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.SimSwap.networks.InstanceNorm.forward": [[18, 23], ["torch.mul", "torch.rsqrt", "torch.mean", "torch.mean"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "x", "-", "torch", ".", "mean", "(", "x", ",", "(", "2", ",", "3", ")", ",", "True", ")", "\n", "tmp", "=", "torch", ".", "mul", "(", "x", ",", "x", ")", "# or x ** 2", "\n", "tmp", "=", "torch", ".", "rsqrt", "(", "torch", ".", "mean", "(", "tmp", ",", "(", "2", ",", "3", ")", ",", "True", ")", "+", "self", ".", "epsilon", ")", "\n", "return", "x", "*", "tmp", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.SimSwap.networks.AdaIn.__init__": [[27, 31], ["torch.nn.Module.__init__", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["    ", "def", "__init__", "(", "self", ",", "latent_size", ",", "dim", ")", ":", "\n", "        ", "super", "(", "AdaIn", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "latent_size", ",", "dim", "*", "2", ")", "# one for mean and another for var", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.SimSwap.networks.AdaIn.forward": [[33, 39], ["networks.AdaIn.linear", "ID_style.view.view.view", "x.size"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.linear"], ["", "def", "forward", "(", "self", ",", "x", ",", "latent_ID", ")", ":", "\n", "        ", "ID_style", "=", "self", ".", "linear", "(", "latent_ID", ")", "\n", "ID_style", "=", "ID_style", ".", "view", "(", "-", "1", ",", "2", ",", "x", ".", "size", "(", "1", ")", ",", "1", ",", "1", ")", "\n", "\n", "x", "=", "x", "*", "(", "ID_style", "[", ":", ",", "0", "]", "*", "1", "+", "1.", ")", "+", "ID_style", "[", ":", ",", "1", "]", "*", "1", "# why *1 ?", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.SimSwap.networks.IDBlock.__init__": [[43, 65], ["torch.nn.ReLU", "torch.nn.Module.__init__", "torch.nn.Sequential", "networks.AdaIn", "torch.nn.Sequential", "networks.AdaIn", "torch.nn.Conv2d", "networks.InstanceNorm", "torch.nn.Conv2d", "networks.InstanceNorm", "torch.nn.ReflectionPad2d", "torch.nn.ReflectionPad2d", "torch.nn.ReplicationPad2d", "torch.nn.ZeroPad2d", "torch.nn.ReplicationPad2d", "torch.nn.ZeroPad2d"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dim", ",", "latent_size", ",", "padding_mode", ",", "activation", "=", "nn", ".", "ReLU", "(", "True", ")", ")", ":", "\n", "        ", "super", "(", "IDBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "ReflectionPad2d", "(", "padding", "=", "1", ")", "if", "padding_mode", "==", "'reflect'", "else", "\n", "nn", ".", "ReplicationPad2d", "(", "padding", "=", "1", ")", "if", "padding_mode", "==", "'replicate'", "else", "\n", "nn", ".", "ZeroPad2d", "(", "padding", "=", "1", ")", ",", "# padding_mode == 'zero'", "\n", "nn", ".", "Conv2d", "(", "in_channels", "=", "dim", ",", "out_channels", "=", "dim", ",", "kernel_size", "=", "3", ")", ",", "\n", "InstanceNorm", "(", ")", "\n", ")", "\n", "self", ".", "adain1", "=", "AdaIn", "(", "latent_size", ",", "dim", ")", "\n", "\n", "self", ".", "act", "=", "activation", "\n", "\n", "self", ".", "conv2", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "ReflectionPad2d", "(", "padding", "=", "1", ")", "if", "padding_mode", "==", "'reflect'", "else", "\n", "nn", ".", "ReplicationPad2d", "(", "padding", "=", "1", ")", "if", "padding_mode", "==", "'replicate'", "else", "\n", "nn", ".", "ZeroPad2d", "(", "padding", "=", "1", ")", ",", "# padding_mode == 'zero'", "\n", "nn", ".", "Conv2d", "(", "in_channels", "=", "dim", ",", "out_channels", "=", "dim", ",", "kernel_size", "=", "3", ")", ",", "\n", "InstanceNorm", "(", ")", "\n", ")", "\n", "self", ".", "adain2", "=", "AdaIn", "(", "latent_size", ",", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.SimSwap.networks.IDBlock.forward": [[67, 75], ["networks.IDBlock.conv1", "networks.IDBlock.adain1", "networks.IDBlock.act", "networks.IDBlock.conv2", "networks.IDBlock.adain2"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "latent_id", ")", ":", "\n", "        ", "y", "=", "self", ".", "conv1", "(", "x", ")", "\n", "y", "=", "self", ".", "adain1", "(", "y", ",", "latent_id", ")", "\n", "y", "=", "self", ".", "act", "(", "y", ")", "\n", "y", "=", "self", ".", "conv2", "(", "y", ")", "\n", "y", "=", "self", ".", "adain2", "(", "y", ",", "latent_id", ")", "\n", "y", "=", "x", "+", "y", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.SimSwap.networks.Generator.__init__": [[79, 146], ["torch.nn.ReLU", "torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "range", "torch.nn.Sequential", "torch.nn.Upsample", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Conv2d", "norm", "torch.nn.Conv2d", "norm", "torch.nn.Conv2d", "norm", "torch.nn.Conv2d", "norm", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "norm", "torch.nn.Tanh", "torch.nn.ReflectionPad2d", "networks.IDBlock", "torch.nn.ReflectionPad2d", "torch.nn.ReplicationPad2d", "torch.nn.ZeroPad2d", "torch.nn.ReplicationPad2d", "torch.nn.ZeroPad2d"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "latent_size", ",", "num_ID_blocks", "=", "9", ",", "\n", "norm", "=", "nn", ".", "BatchNorm2d", ",", "\n", "padding_mode", "=", "'reflect'", ",", "activation", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", ":", "\n", "        ", "super", "(", "Generator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# first convolution", "\n", "self", ".", "conv1", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "ReflectionPad2d", "(", "padding", "=", "3", ")", "if", "padding_mode", "==", "'reflect'", "else", "\n", "nn", ".", "ReplicationPad2d", "(", "padding", "=", "3", ")", "if", "padding_mode", "==", "'replicate'", "else", "\n", "nn", ".", "ZeroPad2d", "(", "padding", "=", "3", ")", ",", "# padding_mode == 'zero'", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", "=", "64", ",", "kernel_size", "=", "7", ")", ",", "\n", "norm", "(", "num_features", "=", "64", ")", ",", "\n", "activation", "\n", ")", "\n", "\n", "# downsampling", "\n", "self", ".", "down1", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", "=", "64", ",", "out_channels", "=", "128", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", ",", "\n", "norm", "(", "num_features", "=", "128", ")", ",", "\n", "activation", "\n", ")", "\n", "self", ".", "down2", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", "=", "128", ",", "out_channels", "=", "256", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", ",", "\n", "norm", "(", "num_features", "=", "256", ")", ",", "\n", "activation", "\n", ")", "\n", "self", ".", "down3", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", "=", "256", ",", "out_channels", "=", "512", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", ",", "\n", "norm", "(", "num_features", "=", "512", ")", ",", "\n", "activation", "\n", ")", "\n", "\n", "# ID-blocks", "\n", "ID_blocks", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_ID_blocks", ")", ":", "\n", "            ", "ID_blocks", "+=", "[", "IDBlock", "(", "512", ",", "latent_size", ",", "padding_mode", ",", "activation", ")", "]", "\n", "", "self", ".", "ID_blocks", "=", "nn", ".", "Sequential", "(", "*", "ID_blocks", ")", "\n", "\n", "upsample", "=", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", ",", "mode", "=", "'bilinear'", ")", "\n", "# upsampling", "\n", "self", ".", "up1", "=", "nn", ".", "Sequential", "(", "\n", "upsample", ",", "\n", "nn", ".", "Conv2d", "(", "512", ",", "256", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "256", ")", ",", "\n", "activation", "\n", ")", "\n", "self", ".", "up2", "=", "nn", ".", "Sequential", "(", "\n", "upsample", ",", "\n", "nn", ".", "Conv2d", "(", "256", ",", "128", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "128", ")", ",", "\n", "activation", "\n", ")", "\n", "self", ".", "up3", "=", "nn", ".", "Sequential", "(", "\n", "upsample", ",", "\n", "nn", ".", "Conv2d", "(", "128", ",", "64", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "64", ")", ",", "\n", "activation", "\n", ")", "\n", "\n", "# last convolution", "\n", "self", ".", "conv2", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "ReflectionPad2d", "(", "padding", "=", "3", ")", "if", "padding_mode", "==", "'reflect'", "else", "\n", "nn", ".", "ReplicationPad2d", "(", "padding", "=", "3", ")", "if", "padding_mode", "==", "'replicate'", "else", "\n", "nn", ".", "ZeroPad2d", "(", "padding", "=", "3", ")", ",", "# padding_mode == 'zero'", "\n", "nn", ".", "Conv2d", "(", "64", ",", "out_channels", ",", "kernel_size", "=", "7", ")", ",", "\n", "norm", "(", "num_features", "=", "out_channels", ")", ",", "\n", "nn", ".", "Tanh", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.SimSwap.networks.Generator.forward": [[149, 168], ["networks.Generator.conv1", "networks.Generator.down1", "networks.Generator.down2", "networks.Generator.down3", "networks.Generator.up1", "networks.Generator.up2", "networks.Generator.up3", "networks.Generator.conv2", "ID_block"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "latent_id", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "down1", "(", "x", ")", "\n", "x", "=", "self", ".", "down2", "(", "x", ")", "\n", "x", "=", "self", ".", "down3", "(", "x", ")", "\n", "\n", "for", "ID_block", "in", "self", ".", "ID_blocks", ":", "\n", "            ", "x", "=", "ID_block", "(", "x", ",", "latent_id", ")", "\n", "\n", "", "x", "=", "self", ".", "up1", "(", "x", ")", "\n", "x", "=", "self", ".", "up2", "(", "x", ")", "\n", "x", "=", "self", ".", "up3", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "\n", "x", "=", "(", "x", "+", "1", ")", "/", "2", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.SimSwap.networks.Discriminator.__init__": [[172, 212], ["torch.nn.LeakyReLU", "torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.Conv2d", "norm", "torch.nn.Conv2d", "norm", "torch.nn.Conv2d", "norm", "torch.nn.Conv2d", "norm", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.Sigmoid", "torch.nn.Conv2d"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "norm", "=", "nn", ".", "BatchNorm2d", ",", "activation", "=", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", ",", "use_sigmoid", "=", "False", ")", ":", "\n", "        ", "super", "(", "Discriminator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "kernel_size", "=", "4", "\n", "padding", "=", "1", "\n", "\n", "self", ".", "down1", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "64", ",", "kernel_size", "=", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "padding", ")", ",", "\n", "activation", "\n", ")", "\n", "self", ".", "down2", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "64", ",", "128", ",", "kernel_size", "=", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "padding", ")", ",", "\n", "norm", "(", "128", ")", ",", "\n", "activation", "\n", ")", "\n", "self", ".", "down3", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "128", ",", "256", ",", "kernel_size", "=", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "padding", ")", ",", "\n", "norm", "(", "256", ")", ",", "\n", "activation", "\n", ")", "\n", "self", ".", "down4", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "256", ",", "512", ",", "kernel_size", "=", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "padding", ")", ",", "\n", "norm", "(", "512", ")", ",", "\n", "activation", "\n", ")", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "512", ",", "512", ",", "kernel_size", "=", "kernel_size", ",", "stride", "=", "1", ",", "padding", "=", "padding", ")", ",", "\n", "norm", "(", "512", ")", ",", "\n", "activation", "\n", ")", "\n", "\n", "if", "use_sigmoid", ":", "\n", "            ", "self", ".", "conv2", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "512", ",", "1", ",", "kernel_size", "=", "kernel_size", ",", "stride", "=", "1", ",", "padding", "=", "padding", ")", ",", "\n", "nn", ".", "Sigmoid", "(", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "conv2", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "512", ",", "1", ",", "kernel_size", "=", "kernel_size", ",", "stride", "=", "1", ",", "padding", "=", "padding", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.SimSwap.networks.Discriminator.forward": [[215, 233], ["networks.Discriminator.down1", "networks.Discriminator.down2", "networks.Discriminator.down3", "networks.Discriminator.down4", "networks.Discriminator.conv1", "networks.Discriminator.conv2"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "[", "]", "\n", "\n", "x", "=", "self", ".", "down1", "(", "x", ")", "\n", "out", "+=", "[", "x", "]", "\n", "x", "=", "self", ".", "down2", "(", "x", ")", "\n", "out", "+=", "[", "x", "]", "\n", "x", "=", "self", ".", "down3", "(", "x", ")", "\n", "out", "+=", "[", "x", "]", "\n", "x", "=", "self", ".", "down4", "(", "x", ")", "\n", "out", "+=", "[", "x", "]", "\n", "\n", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "+=", "[", "x", "]", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "out", "+=", "[", "x", "]", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.SimSwap.model.SimSwapGAN.__init__": [[17, 19], ["model_base.ModelBase.__init__"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["self", ".", "conv", "=", "nn", ".", "Conv2d", "(", "in_chan", ",", "\n", "out_chan", ",", "\n", "kernel_size", "=", "ks", ",", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.SimSwap.model.SimSwapGAN.init": [[20, 90], ["model_base.ModelBase.init", "torch.device", "torch.device", "torch.device", "torch.device", "networks.Generator", "model.SimSwapGAN.G.to", "utils.IDExtract.IDExtractor", "model.SimSwapGAN.ID_extract.eval", "torch.nn.AvgPool2d", "torch.nn.AvgPool2d", "networks.Discriminator", "model.SimSwapGAN.D1.to", "networks.Discriminator", "model.SimSwapGAN.D2.to", "utils.loss.IDLoss", "torch.nn.L1Loss", "torch.nn.L1Loss", "utils.loss.GANLoss", "utils.loss.GPLoss", "list", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "print", "model.SimSwapGAN.load_net", "model.SimSwapGAN.load_net", "model.SimSwapGAN.load_net", "model.SimSwapGAN.load_net", "utils.loss.FMLoss", "model.SimSwapGAN.G.parameters", "list", "list", "print", "model.SimSwapGAN.D1.parameters", "model.SimSwapGAN.D2.parameters"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.init", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.load_net", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.load_net", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.load_net", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.load_net"], ["stride", "=", "stride", ",", "\n", "padding", "=", "padding", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "bn", "=", "nn", ".", "BatchNorm2d", "(", "out_chan", ")", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv", "(", "x", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "bn", "(", "x", ")", ")", "\n", "return", "x", "\n", "\n", "", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "for", "ly", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "ly", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n", "", "", "", "", "class", "BiSeNetOutput", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "in_chan", ",", "mid_chan", ",", "n_classes", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "BiSeNetOutput", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv", "=", "ConvBNReLU", "(", "in_chan", ",", "mid_chan", ",", "ks", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_out", "=", "nn", ".", "Conv2d", "(", "mid_chan", ",", "n_classes", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv", "(", "x", ")", "\n", "x", "=", "self", ".", "conv_out", "(", "x", ")", "\n", "return", "x", "\n", "\n", "", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "for", "ly", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "ly", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n", "", "", "", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "wd_params", ",", "nowd_params", "=", "[", "]", ",", "[", "]", "\n", "for", "name", ",", "module", "in", "self", ".", "named_modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "module", ",", "nn", ".", "Linear", ")", "or", "isinstance", "(", "module", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "wd_params", ".", "append", "(", "module", ".", "weight", ")", "\n", "if", "not", "module", ".", "bias", "is", "None", ":", "\n", "                    ", "nowd_params", ".", "append", "(", "module", ".", "bias", ")", "\n", "", "", "elif", "isinstance", "(", "module", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "nowd_params", "+=", "list", "(", "module", ".", "parameters", "(", ")", ")", "\n", "", "", "return", "wd_params", ",", "nowd_params", "\n", "\n", "\n", "", "", "class", "AttentionRefinementModule", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "in_chan", ",", "out_chan", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "AttentionRefinementModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv", "=", "ConvBNReLU", "(", "in_chan", ",", "out_chan", ",", "ks", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_atten", "=", "nn", ".", "Conv2d", "(", "out_chan", ",", "out_chan", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn_atten", "=", "nn", ".", "BatchNorm2d", "(", "out_chan", ")", "\n", "self", ".", "sigmoid_atten", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "feat", "=", "self", ".", "conv", "(", "x", ")", "\n", "atten", "=", "F", ".", "avg_pool2d", "(", "feat", ",", "feat", ".", "size", "(", ")", "[", "2", ":", "]", ")", "\n", "atten", "=", "self", ".", "conv_atten", "(", "atten", ")", "\n", "atten", "=", "self", ".", "bn_atten", "(", "atten", ")", "\n", "atten", "=", "self", ".", "sigmoid_atten", "(", "atten", ")", "\n", "out", "=", "torch", ".", "mul", "(", "feat", ",", "atten", ")", "\n", "return", "out", "\n", "\n", "", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "for", "ly", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "ly", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.SimSwap.model.SimSwapGAN.forward": [[93, 159], ["model.SimSwapGAN.G.forward", "model.SimSwapGAN.ID_extract.INnorm", "model.SimSwapGAN.downsample", "model.SimSwapGAN.downsample", "model.SimSwapGAN.D1.forward", "model.SimSwapGAN.D2.forward", "model.SimSwapGAN.GANloss", "model.SimSwapGAN.D1.forward", "model.SimSwapGAN.D2.forward", "model.SimSwapGAN.GANloss", "model.SimSwapGAN.GPloss", "model.SimSwapGAN.GPloss", "model.SimSwapGAN.D1.forward", "model.SimSwapGAN.D2.forward", "model.SimSwapGAN.GANloss", "model.SimSwapGAN.ID_extract", "model.SimSwapGAN.IDloss", "model.SimSwapGAN.Recloss", "model.SimSwapGAN.detach", "model.SimSwapGAN.detach", "model.SimSwapGAN.detach", "model.SimSwapGAN.detach", "model.SimSwapGAN.FMloss", "model.SimSwapGAN.detach", "model.SimSwapGAN.detach", "model.SimSwapGAN.detach", "model.SimSwapGAN.detach", "model.SimSwapGAN.detach", "model.SimSwapGAN.detach", "model.SimSwapGAN.detach", "model.SimSwapGAN.detach"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.forward", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.forward", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.forward", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.forward", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.forward", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.forward", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.forward"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "ContextPath", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "resnet", "=", "Resnet18", "(", ")", "\n", "self", ".", "arm16", "=", "AttentionRefinementModule", "(", "256", ",", "128", ")", "\n", "self", ".", "arm32", "=", "AttentionRefinementModule", "(", "512", ",", "128", ")", "\n", "self", ".", "conv_head32", "=", "ConvBNReLU", "(", "128", ",", "128", ",", "ks", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_head16", "=", "ConvBNReLU", "(", "128", ",", "128", ",", "ks", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_avg", "=", "ConvBNReLU", "(", "512", ",", "128", ",", "ks", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "H0", ",", "W0", "=", "x", ".", "size", "(", ")", "[", "2", ":", "]", "\n", "feat8", ",", "feat16", ",", "feat32", "=", "self", ".", "resnet", "(", "x", ")", "\n", "H8", ",", "W8", "=", "feat8", ".", "size", "(", ")", "[", "2", ":", "]", "\n", "H16", ",", "W16", "=", "feat16", ".", "size", "(", ")", "[", "2", ":", "]", "\n", "H32", ",", "W32", "=", "feat32", ".", "size", "(", ")", "[", "2", ":", "]", "\n", "\n", "avg", "=", "F", ".", "avg_pool2d", "(", "feat32", ",", "feat32", ".", "size", "(", ")", "[", "2", ":", "]", ")", "\n", "avg", "=", "self", ".", "conv_avg", "(", "avg", ")", "\n", "avg_up", "=", "F", ".", "interpolate", "(", "avg", ",", "(", "H32", ",", "W32", ")", ",", "mode", "=", "'nearest'", ")", "\n", "\n", "feat32_arm", "=", "self", ".", "arm32", "(", "feat32", ")", "\n", "feat32_sum", "=", "feat32_arm", "+", "avg_up", "\n", "feat32_up", "=", "F", ".", "interpolate", "(", "feat32_sum", ",", "(", "H16", ",", "W16", ")", ",", "mode", "=", "'nearest'", ")", "\n", "feat32_up", "=", "self", ".", "conv_head32", "(", "feat32_up", ")", "\n", "\n", "feat16_arm", "=", "self", ".", "arm16", "(", "feat16", ")", "\n", "feat16_sum", "=", "feat16_arm", "+", "feat32_up", "\n", "feat16_up", "=", "F", ".", "interpolate", "(", "feat16_sum", ",", "(", "H8", ",", "W8", ")", ",", "mode", "=", "'nearest'", ")", "\n", "feat16_up", "=", "self", ".", "conv_head16", "(", "feat16_up", ")", "\n", "\n", "return", "feat8", ",", "feat16_up", ",", "feat32_up", "# x8, x8, x16", "\n", "\n", "", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "for", "ly", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "ly", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n", "", "", "", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "wd_params", ",", "nowd_params", "=", "[", "]", ",", "[", "]", "\n", "for", "name", ",", "module", "in", "self", ".", "named_modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "module", ",", "(", "nn", ".", "Linear", ",", "nn", ".", "Conv2d", ")", ")", ":", "\n", "                ", "wd_params", ".", "append", "(", "module", ".", "weight", ")", "\n", "if", "not", "module", ".", "bias", "is", "None", ":", "\n", "                    ", "nowd_params", ".", "append", "(", "module", ".", "bias", ")", "\n", "", "", "elif", "isinstance", "(", "module", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "nowd_params", "+=", "list", "(", "module", ".", "parameters", "(", ")", ")", "\n", "", "", "return", "wd_params", ",", "nowd_params", "\n", "\n", "\n", "### This is not used, since I replace this with the resnet feature with the same size", "\n", "", "", "class", "SpatialPath", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "SpatialPath", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "ConvBNReLU", "(", "3", ",", "64", ",", "ks", "=", "7", ",", "stride", "=", "2", ",", "padding", "=", "3", ")", "\n", "self", ".", "conv2", "=", "ConvBNReLU", "(", "64", ",", "64", ",", "ks", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv3", "=", "ConvBNReLU", "(", "64", ",", "64", ",", "ks", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_out", "=", "ConvBNReLU", "(", "64", ",", "128", ",", "ks", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "feat", "=", "self", ".", "conv1", "(", "x", ")", "\n", "feat", "=", "self", ".", "conv2", "(", "feat", ")", "\n", "feat", "=", "self", ".", "conv3", "(", "feat", ")", "\n", "feat", "=", "self", ".", "conv_out", "(", "feat", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.SimSwap.model.SimSwapGAN.save": [[162, 166], ["model.SimSwapGAN.save_net", "model.SimSwapGAN.save_net", "model.SimSwapGAN.save_net"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.save_net", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.save_net", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.save_net"], ["", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "for", "ly", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "ly", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.SimSwap.model.SimSwapGAN.load": [[168, 173], ["model.SimSwapGAN.load_net", "model.SimSwapGAN.load_net", "model.SimSwapGAN.load_net"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.load_net", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.load_net", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.load_net"], ["", "", "", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "wd_params", ",", "nowd_params", "=", "[", "]", ",", "[", "]", "\n", "for", "name", ",", "module", "in", "self", ".", "named_modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "module", ",", "nn", ".", "Linear", ")", "or", "isinstance", "(", "module", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "wd_params", ".", "append", "(", "module", ".", "weight", ")", "\n", "if", "not", "module", ".", "bias", "is", "None", ":", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.SimSwap.model.SimSwapGAN.unlock_G": [[175, 178], ["list", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "model.SimSwapGAN.G.parameters"], "methods", ["None"], ["", "", "elif", "isinstance", "(", "module", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "nowd_params", "+=", "list", "(", "module", ".", "parameters", "(", ")", ")", "\n", "", "", "return", "wd_params", ",", "nowd_params", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.SimSwap.model.SimSwapGAN.update_lr": [[180, 190], ["None"], "methods", ["None"], ["", "", "class", "FeatureFusionModule", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "in_chan", ",", "out_chan", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "FeatureFusionModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "convblk", "=", "ConvBNReLU", "(", "in_chan", ",", "out_chan", ",", "ks", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "out_chan", ",", "\n", "out_chan", "//", "4", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "out_chan", "//", "4", ",", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.networks.InstanceNorm.__init__": [[8, 15], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["###############################################################################", "\n", "class", "InstanceNorm", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "epsilon", "=", "1e-8", ")", ":", "\n", "        ", "\"\"\"\n            @notice: avoid in-place ops.\n            https://discuss.pytorch.org/t/encounter-the-runtimeerror-one-of-the-variables-needed-for-gradient-computation-has-been-modified-by-an-inplace-operation/836/3\n        \"\"\"", "\n", "super", "(", "InstanceNorm", ",", "self", ")", ".", "__init__", "(", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.networks.InstanceNorm.forward": [[16, 21], ["torch.mul", "torch.rsqrt", "torch.mean", "torch.mean"], "methods", ["None"], ["self", ".", "epsilon", "=", "epsilon", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "x", "-", "torch", ".", "mean", "(", "x", ",", "(", "2", ",", "3", ")", ",", "True", ")", "\n", "tmp", "=", "torch", ".", "mul", "(", "x", ",", "x", ")", "# or x ** 2", "\n", "tmp", "=", "torch", ".", "rsqrt", "(", "torch", ".", "mean", "(", "tmp", ",", "(", "2", ",", "3", ")", ",", "True", ")", "+", "self", ".", "epsilon", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.networks.AdaIn.__init__": [[23, 27], ["torch.nn.Module.__init__", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["\n", "\n", "\n", "", "", "class", "AdaIn", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "latent_size", ",", "dim", ")", ":", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.networks.AdaIn.forward": [[29, 35], ["networks.AdaIn.linear", "ID_style.view.view.view", "x.size"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.nn.linear"], ["\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "latent_size", ",", "dim", "*", "2", ")", "# one for mean and another for var", "\n", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ",", "latent_ID", ")", ":", "\n", "        ", "ID_style", "=", "self", ".", "linear", "(", "latent_ID", ")", "\n", "ID_style", "=", "ID_style", ".", "view", "(", "-", "1", ",", "2", ",", "x", ".", "size", "(", "1", ")", ",", "1", ",", "1", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.networks.IDBlock.__init__": [[37, 59], ["torch.nn.ReLU", "torch.nn.Module.__init__", "torch.nn.Sequential", "networks.AdaIn", "torch.nn.Sequential", "networks.AdaIn", "torch.nn.Conv2d", "networks.InstanceNorm", "torch.nn.Conv2d", "networks.InstanceNorm", "torch.nn.ReflectionPad2d", "torch.nn.ReflectionPad2d", "torch.nn.ReplicationPad2d", "torch.nn.ZeroPad2d", "torch.nn.ReplicationPad2d", "torch.nn.ZeroPad2d"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["x", "=", "x", "*", "(", "ID_style", "[", ":", ",", "0", "]", "*", "1", "+", "1.", ")", "+", "ID_style", "[", ":", ",", "1", "]", "*", "1", "# why *1 ?", "\n", "return", "x", "\n", "\n", "\n", "\n", "", "", "class", "IDBlock", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "dim", ",", "latent_size", ",", "padding_mode", ",", "activation", "=", "nn", ".", "ReLU", "(", "True", ")", ")", ":", "\n", "        ", "super", "(", "IDBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "ReflectionPad2d", "(", "padding", "=", "1", ")", "if", "padding_mode", "==", "'reflect'", "else", "\n", "nn", ".", "ReplicationPad2d", "(", "padding", "=", "1", ")", "if", "padding_mode", "==", "'replicate'", "else", "\n", "nn", ".", "ZeroPad2d", "(", "padding", "=", "1", ")", ",", "# padding_mode == 'zero'", "\n", "nn", ".", "Conv2d", "(", "in_channels", "=", "dim", ",", "out_channels", "=", "dim", ",", "kernel_size", "=", "3", ")", ",", "\n", "InstanceNorm", "(", ")", "\n", ")", "\n", "self", ".", "adain1", "=", "AdaIn", "(", "latent_size", ",", "dim", ")", "\n", "\n", "self", ".", "act", "=", "activation", "\n", "\n", "self", ".", "conv2", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "ReflectionPad2d", "(", "padding", "=", "1", ")", "if", "padding_mode", "==", "'reflect'", "else", "\n", "nn", ".", "ReplicationPad2d", "(", "padding", "=", "1", ")", "if", "padding_mode", "==", "'replicate'", "else", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.networks.IDBlock.forward": [[61, 74], ["networks.IDBlock.conv1", "networks.IDBlock.adain1", "networks.IDBlock.act", "networks.IDBlock.conv2", "networks.IDBlock.adain2"], "methods", ["None"], ["nn", ".", "Conv2d", "(", "in_channels", "=", "dim", ",", "out_channels", "=", "dim", ",", "kernel_size", "=", "3", ")", ",", "\n", "InstanceNorm", "(", ")", "\n", ")", "\n", "self", ".", "adain2", "=", "AdaIn", "(", "latent_size", ",", "dim", ")", "\n", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ",", "latent_id", ")", ":", "\n", "        ", "y", "=", "self", ".", "conv1", "(", "x", ")", "\n", "y", "=", "self", ".", "adain1", "(", "y", ",", "latent_id", ")", "\n", "y", "=", "self", ".", "act", "(", "y", ")", "\n", "y", "=", "self", ".", "conv2", "(", "y", ")", "\n", "y", "=", "self", ".", "adain2", "(", "y", ",", "latent_id", ")", "\n", "y", "=", "x", "+", "y", "\n", "return", "y", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.networks.Encoder.__init__": [[76, 117], ["torch.nn.ReLU", "torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Conv2d", "norm", "torch.nn.Conv2d", "norm", "torch.nn.Conv2d", "norm", "torch.nn.Conv2d", "norm", "torch.nn.Conv2d", "norm", "torch.nn.Conv2d", "norm", "torch.nn.ReflectionPad2d", "torch.nn.ReplicationPad2d", "torch.nn.ZeroPad2d"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["\n", "\n", "", "", "class", "Generator", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "latent_size", ",", "num_ID_blocks", "=", "9", ",", "\n", "norm", "=", "nn", ".", "BatchNorm2d", ",", "\n", "padding_mode", "=", "'reflect'", ",", "activation", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", ":", "\n", "        ", "super", "(", "Generator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# first convolution", "\n", "self", ".", "conv1", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "ReflectionPad2d", "(", "padding", "=", "3", ")", "if", "padding_mode", "==", "'reflect'", "else", "\n", "nn", ".", "ReplicationPad2d", "(", "padding", "=", "3", ")", "if", "padding_mode", "==", "'replicate'", "else", "\n", "nn", ".", "ZeroPad2d", "(", "padding", "=", "3", ")", ",", "# padding_mode == 'zero'", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", "=", "64", ",", "kernel_size", "=", "7", ")", ",", "\n", "norm", "(", "num_features", "=", "64", ")", ",", "\n", "activation", "\n", ")", "\n", "\n", "# downsampling", "\n", "self", ".", "down1", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", "=", "64", ",", "out_channels", "=", "128", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", ",", "\n", "norm", "(", "num_features", "=", "128", ")", ",", "\n", "activation", "\n", ")", "\n", "self", ".", "down2", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", "=", "128", ",", "out_channels", "=", "256", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", ",", "\n", "norm", "(", "num_features", "=", "256", ")", ",", "\n", "activation", "\n", ")", "\n", "self", ".", "down3", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", "=", "256", ",", "out_channels", "=", "512", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", ",", "\n", "norm", "(", "num_features", "=", "512", ")", ",", "\n", "activation", "\n", ")", "\n", "\n", "# ID-blocks", "\n", "ID_blocks", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_ID_blocks", ")", ":", "\n", "            ", "ID_blocks", "+=", "[", "IDBlock", "(", "512", ",", "latent_size", ",", "padding_mode", ",", "activation", ")", "]", "\n", "", "self", ".", "ID_blocks", "=", "nn", ".", "Sequential", "(", "*", "ID_blocks", ")", "\n", "\n", "upsample", "=", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", ",", "mode", "=", "'bilinear'", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.networks.Encoder.forward": [[118, 132], ["networks.Encoder.conv1", "networks.Encoder.down1", "networks.Encoder.down2", "networks.Encoder.down3", "networks.Encoder.mu", "networks.Encoder.log_var"], "methods", ["None"], ["# upsampling", "\n", "self", ".", "up1", "=", "nn", ".", "Sequential", "(", "\n", "upsample", ",", "\n", "nn", ".", "Conv2d", "(", "512", ",", "256", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "256", ")", ",", "\n", "activation", "\n", ")", "\n", "self", ".", "up2", "=", "nn", ".", "Sequential", "(", "\n", "upsample", ",", "\n", "nn", ".", "Conv2d", "(", "256", ",", "128", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "128", ")", ",", "\n", "activation", "\n", ")", "\n", "self", ".", "up3", "=", "nn", ".", "Sequential", "(", "\n", "upsample", ",", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.networks.Decoder.__init__": [[134, 165], ["torch.nn.ReLU", "torch.nn.Module.__init__", "torch.nn.Upsample", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Tanh", "torch.nn.ReflectionPad2d", "torch.nn.ReplicationPad2d", "torch.nn.ZeroPad2d"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["nn", ".", "BatchNorm2d", "(", "64", ")", ",", "\n", "activation", "\n", ")", "\n", "\n", "# last convolution", "\n", "self", ".", "conv2", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "ReflectionPad2d", "(", "padding", "=", "3", ")", "if", "padding_mode", "==", "'reflect'", "else", "\n", "nn", ".", "ReplicationPad2d", "(", "padding", "=", "3", ")", "if", "padding_mode", "==", "'replicate'", "else", "\n", "nn", ".", "ZeroPad2d", "(", "padding", "=", "3", ")", ",", "# padding_mode == 'zero'", "\n", "nn", ".", "Conv2d", "(", "64", ",", "out_channels", ",", "kernel_size", "=", "7", ")", ",", "\n", "norm", "(", "num_features", "=", "out_channels", ")", ",", "\n", "nn", ".", "Tanh", "(", ")", "\n", ")", "\n", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ",", "latent_id", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "down1", "(", "x", ")", "\n", "x", "=", "self", ".", "down2", "(", "x", ")", "\n", "x", "=", "self", ".", "down3", "(", "x", ")", "\n", "\n", "for", "ID_block", "in", "self", ".", "ID_blocks", ":", "\n", "            ", "x", "=", "ID_block", "(", "x", ",", "latent_id", ")", "\n", "\n", "", "x", "=", "self", ".", "up1", "(", "x", ")", "\n", "x", "=", "self", ".", "up2", "(", "x", ")", "\n", "x", "=", "self", ".", "up3", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "\n", "x", "=", "(", "x", "+", "1", ")", "/", "2", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.networks.Decoder.forward": [[166, 174], ["networks.Decoder.up1", "networks.Decoder.up2", "networks.Decoder.up3", "networks.Decoder.conv2"], "methods", ["None"], ["\n", "return", "x", "\n", "\n", "\n", "\n", "", "", "class", "Discriminator", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "norm", "=", "nn", ".", "BatchNorm2d", ",", "activation", "=", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", ",", "use_sigmoid", "=", "False", ")", ":", "\n", "        ", "super", "(", "Discriminator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.networks.Merge_Image.__init__": [[191, 198], ["torch.nn.ReLU", "torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.Linear", "torch.nn.BatchNorm1d"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], [")", "\n", "self", ".", "down4", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "256", ",", "512", ",", "kernel_size", "=", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "padding", ")", ",", "\n", "norm", "(", "512", ")", ",", "\n", "activation", "\n", ")", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Sequential", "(", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.networks.Merge_Image.forward": [[201, 208], ["networks.Merge_Image.emb", "y.view.view.view", "torch.cat"], "methods", ["None"], ["activation", "\n", ")", "\n", "\n", "if", "use_sigmoid", ":", "\n", "            ", "self", ".", "conv2", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "512", ",", "1", ",", "kernel_size", "=", "kernel_size", ",", "stride", "=", "1", ",", "padding", "=", "padding", ")", ",", "\n", "nn", ".", "Sigmoid", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.networks.Merge_Distribution.__init__": [[210, 217], ["torch.nn.ReLU", "torch.nn.Module.__init__", "range", "torch.nn.Sequential", "networks.IDBlock"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["            ", "self", ".", "conv2", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "512", ",", "1", ",", "kernel_size", "=", "kernel_size", ",", "stride", "=", "1", ",", "padding", "=", "padding", ")", "\n", ")", "\n", "\n", "\n", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.networks.Merge_Distribution.forward": [[218, 222], ["ID_block"], "methods", ["None"], ["x", "=", "self", ".", "down1", "(", "x", ")", "\n", "out", "+=", "[", "x", "]", "\n", "x", "=", "self", ".", "down2", "(", "x", ")", "\n", "out", "+=", "[", "x", "]", "\n", "x", "=", "self", ".", "down3", "(", "x", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.networks.Generator.__init__": [[225, 303], ["torch.nn.ReLU", "torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "range", "torch.nn.Sequential", "torch.nn.Upsample", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Conv2d", "norm", "torch.nn.Conv2d", "norm", "torch.nn.Conv2d", "norm", "torch.nn.Conv2d", "norm", "torch.nn.Conv2d", "norm", "torch.nn.Conv2d", "norm", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "norm", "torch.nn.Tanh", "torch.nn.ReflectionPad2d", "networks.IDBlock", "torch.nn.ReflectionPad2d", "torch.nn.ReplicationPad2d", "torch.nn.ZeroPad2d", "torch.nn.ReplicationPad2d", "torch.nn.ZeroPad2d"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["out", "+=", "[", "x", "]", "\n", "\n", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "+=", "[", "x", "]", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "out", "+=", "[", "x", "]", "\n", "\n", "return", "out", "\n", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.networks.Generator.forward": [[306, 325], ["networks.Generator.conv1", "networks.Generator.down1", "networks.Generator.down2", "networks.Generator.down3", "networks.Generator.up1", "networks.Generator.up2", "networks.Generator.up3", "networks.Generator.conv2", "ID_block"], "methods", ["None"], []], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.networks.Discriminator.__init__": [[328, 368], ["torch.nn.LeakyReLU", "torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.Conv2d", "norm", "torch.nn.Conv2d", "norm", "torch.nn.Conv2d", "norm", "torch.nn.Conv2d", "norm", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.Sigmoid", "torch.nn.Conv2d"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], []], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.networks.Discriminator.forward": [[371, 389], ["networks.Discriminator.down1", "networks.Discriminator.down2", "networks.Discriminator.down3", "networks.Discriminator.down4", "networks.Discriminator.conv1", "networks.Discriminator.conv2"], "methods", ["None"], []], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.model.CVAE.__init__": [[20, 22], ["model_base.ModelBase.__init__"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["stride", "=", "stride", ",", "\n", "padding", "=", "padding", ",", "\n", "bias", "=", "False", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.model.CVAE.init": [[23, 109], ["model_base.ModelBase.init", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torchvision.transforms.Normalize", "networks.Merge_Image", "model.CVAE.M1.to", "networks.Encoder", "model.CVAE.E.to", "networks.Merge_Distribution", "model.CVAE.M2.to", "networks.Decoder", "model.CVAE.D.to", "torch.nn.AvgPool2d", "torch.nn.AvgPool2d", "networks.Discriminator", "model.CVAE.D1.to", "networks.Discriminator", "model.CVAE.D2.to", "utils.IDExtract.IDExtractor", "model.CVAE.ID_extract.eval", "torch.nn.L1Loss", "torch.nn.L1Loss", "utils.loss.KLLoss", "utils.loss.IDLoss", "utils.loss.GANLoss", "utils.loss.GPLoss", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "print", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "model.CVAE.load_net", "model.CVAE.load_net", "model.CVAE.load_net", "model.CVAE.load_net", "list", "list", "list", "print", "list", "model.CVAE.D.parameters", "model.CVAE.D1.parameters", "model.CVAE.D2.parameters", "list", "list", "model.CVAE.M2.parameters", "model.CVAE.M1.parameters", "model.CVAE.E.parameters"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.init", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.load_net", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.load_net", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.load_net", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.load_net"], ["self", ".", "bn", "=", "nn", ".", "BatchNorm2d", "(", "out_chan", ")", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv", "(", "x", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "bn", "(", "x", ")", ")", "\n", "return", "x", "\n", "\n", "", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "for", "ly", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "ly", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n", "", "", "", "", "class", "BiSeNetOutput", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "in_chan", ",", "mid_chan", ",", "n_classes", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "BiSeNetOutput", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv", "=", "ConvBNReLU", "(", "in_chan", ",", "mid_chan", ",", "ks", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_out", "=", "nn", ".", "Conv2d", "(", "mid_chan", ",", "n_classes", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv", "(", "x", ")", "\n", "x", "=", "self", ".", "conv_out", "(", "x", ")", "\n", "return", "x", "\n", "\n", "", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "for", "ly", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "ly", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n", "", "", "", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "wd_params", ",", "nowd_params", "=", "[", "]", ",", "[", "]", "\n", "for", "name", ",", "module", "in", "self", ".", "named_modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "module", ",", "nn", ".", "Linear", ")", "or", "isinstance", "(", "module", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "wd_params", ".", "append", "(", "module", ".", "weight", ")", "\n", "if", "not", "module", ".", "bias", "is", "None", ":", "\n", "                    ", "nowd_params", ".", "append", "(", "module", ".", "bias", ")", "\n", "", "", "elif", "isinstance", "(", "module", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "nowd_params", "+=", "list", "(", "module", ".", "parameters", "(", ")", ")", "\n", "", "", "return", "wd_params", ",", "nowd_params", "\n", "\n", "\n", "", "", "class", "AttentionRefinementModule", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "in_chan", ",", "out_chan", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "AttentionRefinementModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv", "=", "ConvBNReLU", "(", "in_chan", ",", "out_chan", ",", "ks", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_atten", "=", "nn", ".", "Conv2d", "(", "out_chan", ",", "out_chan", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn_atten", "=", "nn", ".", "BatchNorm2d", "(", "out_chan", ")", "\n", "self", ".", "sigmoid_atten", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "feat", "=", "self", ".", "conv", "(", "x", ")", "\n", "atten", "=", "F", ".", "avg_pool2d", "(", "feat", ",", "feat", ".", "size", "(", ")", "[", "2", ":", "]", ")", "\n", "atten", "=", "self", ".", "conv_atten", "(", "atten", ")", "\n", "atten", "=", "self", ".", "bn_atten", "(", "atten", ")", "\n", "atten", "=", "self", ".", "sigmoid_atten", "(", "atten", ")", "\n", "out", "=", "torch", ".", "mul", "(", "feat", ",", "atten", ")", "\n", "return", "out", "\n", "\n", "", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "for", "ly", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "ly", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n", "\n", "", "", "", "", "class", "ContextPath", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "ContextPath", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "resnet", "=", "Resnet18", "(", ")", "\n", "self", ".", "arm16", "=", "AttentionRefinementModule", "(", "256", ",", "128", ")", "\n", "self", ".", "arm32", "=", "AttentionRefinementModule", "(", "512", ",", "128", ")", "\n", "self", ".", "conv_head32", "=", "ConvBNReLU", "(", "128", ",", "128", ",", "ks", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_head16", "=", "ConvBNReLU", "(", "128", ",", "128", ",", "ks", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_avg", "=", "ConvBNReLU", "(", "512", ",", "128", ",", "ks", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "H0", ",", "W0", "=", "x", ".", "size", "(", ")", "[", "2", ":", "]", "\n", "feat8", ",", "feat16", ",", "feat32", "=", "self", ".", "resnet", "(", "x", ")", "\n", "H8", ",", "W8", "=", "feat8", ".", "size", "(", ")", "[", "2", ":", "]", "\n", "H16", ",", "W16", "=", "feat16", ".", "size", "(", ")", "[", "2", ":", "]", "\n", "H32", ",", "W32", "=", "feat32", ".", "size", "(", ")", "[", "2", ":", "]", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.model.CVAE.reparameterize": [[115, 119], ["torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like"], "methods", ["None"], ["feat32_arm", "=", "self", ".", "arm32", "(", "feat32", ")", "\n", "feat32_sum", "=", "feat32_arm", "+", "avg_up", "\n", "feat32_up", "=", "F", ".", "interpolate", "(", "feat32_sum", ",", "(", "H16", ",", "W16", ")", ",", "mode", "=", "'nearest'", ")", "\n", "feat32_up", "=", "self", ".", "conv_head32", "(", "feat32_up", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.model.CVAE.forward": [[120, 193], ["model.CVAE.M1", "model.CVAE.E", "model.CVAE.reparameterize", "model.CVAE.M2", "model.CVAE.D", "model.CVAE.INnorm", "model.CVAE.ID_extract", "model.CVAE.IDloss", "model.CVAE.Recloss", "model.CVAE.KLloss", "model.CVAE.downsample", "model.CVAE.downsample", "model.CVAE.D1", "model.CVAE.D2", "model.CVAE.GANloss", "model.CVAE.D1", "model.CVAE.D2", "model.CVAE.GANloss", "model.CVAE.GPloss", "model.CVAE.GPloss", "model.CVAE.D1.forward", "model.CVAE.D2.forward", "model.CVAE.GANloss", "model.CVAE.detach", "model.CVAE.detach", "model.CVAE.detach", "model.CVAE.detach", "model.CVAE.detach", "model.CVAE.detach", "model.CVAE.detach", "model.CVAE.detach", "model.CVAE.detach", "model.CVAE.detach", "model.CVAE.detach"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.CVAE.model.CVAE.reparameterize", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.forward", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.forward"], ["feat16_arm", "=", "self", ".", "arm16", "(", "feat16", ")", "\n", "feat16_sum", "=", "feat16_arm", "+", "feat32_up", "\n", "feat16_up", "=", "F", ".", "interpolate", "(", "feat16_sum", ",", "(", "H8", ",", "W8", ")", ",", "mode", "=", "'nearest'", ")", "\n", "feat16_up", "=", "self", ".", "conv_head16", "(", "feat16_up", ")", "\n", "\n", "return", "feat8", ",", "feat16_up", ",", "feat32_up", "# x8, x8, x16", "\n", "\n", "", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "for", "ly", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "ly", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n", "", "", "", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "wd_params", ",", "nowd_params", "=", "[", "]", ",", "[", "]", "\n", "for", "name", ",", "module", "in", "self", ".", "named_modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "module", ",", "(", "nn", ".", "Linear", ",", "nn", ".", "Conv2d", ")", ")", ":", "\n", "                ", "wd_params", ".", "append", "(", "module", ".", "weight", ")", "\n", "if", "not", "module", ".", "bias", "is", "None", ":", "\n", "                    ", "nowd_params", ".", "append", "(", "module", ".", "bias", ")", "\n", "", "", "elif", "isinstance", "(", "module", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "nowd_params", "+=", "list", "(", "module", ".", "parameters", "(", ")", ")", "\n", "", "", "return", "wd_params", ",", "nowd_params", "\n", "\n", "\n", "### This is not used, since I replace this with the resnet feature with the same size", "\n", "", "", "class", "SpatialPath", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "SpatialPath", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "ConvBNReLU", "(", "3", ",", "64", ",", "ks", "=", "7", ",", "stride", "=", "2", ",", "padding", "=", "3", ")", "\n", "self", ".", "conv2", "=", "ConvBNReLU", "(", "64", ",", "64", ",", "ks", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv3", "=", "ConvBNReLU", "(", "64", ",", "64", ",", "ks", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_out", "=", "ConvBNReLU", "(", "64", ",", "128", ",", "ks", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "feat", "=", "self", ".", "conv1", "(", "x", ")", "\n", "feat", "=", "self", ".", "conv2", "(", "feat", ")", "\n", "feat", "=", "self", ".", "conv3", "(", "feat", ")", "\n", "feat", "=", "self", ".", "conv_out", "(", "feat", ")", "\n", "return", "feat", "\n", "\n", "", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "for", "ly", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "ly", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n", "", "", "", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "wd_params", ",", "nowd_params", "=", "[", "]", ",", "[", "]", "\n", "for", "name", ",", "module", "in", "self", ".", "named_modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "module", ",", "nn", ".", "Linear", ")", "or", "isinstance", "(", "module", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "wd_params", ".", "append", "(", "module", ".", "weight", ")", "\n", "if", "not", "module", ".", "bias", "is", "None", ":", "\n", "                    ", "nowd_params", ".", "append", "(", "module", ".", "bias", ")", "\n", "", "", "elif", "isinstance", "(", "module", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "nowd_params", "+=", "list", "(", "module", ".", "parameters", "(", ")", ")", "\n", "", "", "return", "wd_params", ",", "nowd_params", "\n", "\n", "\n", "", "", "class", "FeatureFusionModule", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "in_chan", ",", "out_chan", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "FeatureFusionModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "convblk", "=", "ConvBNReLU", "(", "in_chan", ",", "out_chan", ",", "ks", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "out_chan", ",", "\n", "out_chan", "//", "4", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "out_chan", "//", "4", ",", "\n", "out_chan", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.model.CVAE.save": [[202, 211], ["model.CVAE.save_net", "model.CVAE.save_net", "model.CVAE.save_net", "model.CVAE.save_net", "model.CVAE.save_net", "model.CVAE.save_net"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.save_net", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.save_net", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.save_net", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.save_net", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.save_net", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.save_net"], ["feat", "=", "self", ".", "convblk", "(", "fcat", ")", "\n", "atten", "=", "F", ".", "avg_pool2d", "(", "feat", ",", "feat", ".", "size", "(", ")", "[", "2", ":", "]", ")", "\n", "atten", "=", "self", ".", "conv1", "(", "atten", ")", "\n", "atten", "=", "self", ".", "relu", "(", "atten", ")", "\n", "atten", "=", "self", ".", "conv2", "(", "atten", ")", "\n", "atten", "=", "self", ".", "sigmoid", "(", "atten", ")", "\n", "feat_atten", "=", "torch", ".", "mul", "(", "feat", ",", "atten", ")", "\n", "feat_out", "=", "feat_atten", "+", "feat", "\n", "return", "feat_out", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.model.CVAE.load": [[214, 223], ["model.CVAE.load_net", "model.CVAE.load_net", "model.CVAE.load_net", "model.CVAE.load_net", "model.CVAE.load_net", "model.CVAE.load_net"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.load_net", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.load_net", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.load_net", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.load_net", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.load_net", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.load_net"], ["            ", "if", "isinstance", "(", "ly", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n", "", "", "", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "wd_params", ",", "nowd_params", "=", "[", "]", ",", "[", "]", "\n", "for", "name", ",", "module", "in", "self", ".", "named_modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "module", ",", "nn", ".", "Linear", ")", "or", "isinstance", "(", "module", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "wd_params", ".", "append", "(", "module", ".", "weight", ")", "\n", "if", "not", "module", ".", "bias", "is", "None", ":", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.CVAE.model.CVAE.update_lr": [[226, 234], ["None"], "methods", ["None"], ["                ", "nowd_params", "+=", "list", "(", "module", ".", "parameters", "(", ")", ")", "\n", "", "", "return", "wd_params", ",", "nowd_params", "\n", "\n", "\n", "", "", "class", "BiSeNet", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "n_classes", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "BiSeNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "cp", "=", "ContextPath", "(", ")", "\n", "## here self.sp is deleted", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.__init__": [[30, 32], ["model_base.ModelBase.__init__"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["\n", "", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "for", "ly", "in", "self", ".", "children", "(", ")", ":", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.init": [[34, 85], ["model_base.ModelBase.init", "torch.device", "utils.guided_diffusion.script_util.create_model_and_diffusion", "model.ILVR.load", "model.ILVR.model.to", "model.ILVR.model.eval", "math.log().is_integer", "utils.resizer.Resizer().to", "utils.resizer.Resizer().to", "print", "model.ILVR.model.convert_to_fp16", "int", "int", "utils.guided_diffusion.resample.create_named_schedule_sampler", "list", "torch.optim.AdamW", "utils.guided_diffusion.script_util.args_to_dict", "math.log", "utils.resizer.Resizer", "next", "utils.resizer.Resizer", "next", "isinstance", "model.ILVR.model.parameters", "copy.deepcopy", "utils.guided_diffusion.script_util.model_and_diffusion_defaults().keys", "model.ILVR.model.parameters", "model.ILVR.model.parameters", "float", "range", "opt.ema_rate.split", "len", "utils.guided_diffusion.script_util.model_and_diffusion_defaults"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.init", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.create_model_and_diffusion", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.load", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.unet.EncoderUNetModel.convert_to_fp16", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.resample.create_named_schedule_sampler", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.args_to_dict", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.logger.log", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.script_util.model_and_diffusion_defaults"], ["                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n", "", "", "", "", "class", "BiSeNetOutput", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "in_chan", ",", "mid_chan", ",", "n_classes", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "BiSeNetOutput", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv", "=", "ConvBNReLU", "(", "in_chan", ",", "mid_chan", ",", "ks", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_out", "=", "nn", ".", "Conv2d", "(", "mid_chan", ",", "n_classes", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv", "(", "x", ")", "\n", "x", "=", "self", ".", "conv_out", "(", "x", ")", "\n", "return", "x", "\n", "\n", "", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "for", "ly", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "ly", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n", "", "", "", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "wd_params", ",", "nowd_params", "=", "[", "]", ",", "[", "]", "\n", "for", "name", ",", "module", "in", "self", ".", "named_modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "module", ",", "nn", ".", "Linear", ")", "or", "isinstance", "(", "module", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "wd_params", ".", "append", "(", "module", ".", "weight", ")", "\n", "if", "not", "module", ".", "bias", "is", "None", ":", "\n", "                    ", "nowd_params", ".", "append", "(", "module", ".", "bias", ")", "\n", "", "", "elif", "isinstance", "(", "module", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "nowd_params", "+=", "list", "(", "module", ".", "parameters", "(", ")", ")", "\n", "", "", "return", "wd_params", ",", "nowd_params", "\n", "\n", "\n", "", "", "class", "AttentionRefinementModule", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "in_chan", ",", "out_chan", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "AttentionRefinementModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv", "=", "ConvBNReLU", "(", "in_chan", ",", "out_chan", ",", "ks", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_atten", "=", "nn", ".", "Conv2d", "(", "out_chan", ",", "out_chan", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn_atten", "=", "nn", ".", "BatchNorm2d", "(", "out_chan", ")", "\n", "self", ".", "sigmoid_atten", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "feat", "=", "self", ".", "conv", "(", "x", ")", "\n", "atten", "=", "F", ".", "avg_pool2d", "(", "feat", ",", "feat", ".", "size", "(", ")", "[", "2", ":", "]", ")", "\n", "atten", "=", "self", ".", "conv_atten", "(", "atten", ")", "\n", "atten", "=", "self", ".", "bn_atten", "(", "atten", ")", "\n", "atten", "=", "self", ".", "sigmoid_atten", "(", "atten", ")", "\n", "out", "=", "torch", ".", "mul", "(", "feat", ",", "atten", ")", "\n", "return", "out", "\n", "\n", "", "def", "init_weight", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.swap": [[88, 116], ["torch.randn_like", "diffusion.q_sample", "diffusion.p_sample_loop", "torch.tensor", "int"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.q_sample", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.gaussian_diffusion.GaussianDiffusion.p_sample_loop"], ["                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n", "\n", "", "", "", "", "class", "ContextPath", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "ContextPath", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "resnet", "=", "Resnet18", "(", ")", "\n", "self", ".", "arm16", "=", "AttentionRefinementModule", "(", "256", ",", "128", ")", "\n", "self", ".", "arm32", "=", "AttentionRefinementModule", "(", "512", ",", "128", ")", "\n", "self", ".", "conv_head32", "=", "ConvBNReLU", "(", "128", ",", "128", ",", "ks", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_head16", "=", "ConvBNReLU", "(", "128", ",", "128", ",", "ks", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_avg", "=", "ConvBNReLU", "(", "512", ",", "128", ",", "ks", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "H0", ",", "W0", "=", "x", ".", "size", "(", ")", "[", "2", ":", "]", "\n", "feat8", ",", "feat16", ",", "feat32", "=", "self", ".", "resnet", "(", "x", ")", "\n", "H8", ",", "W8", "=", "feat8", ".", "size", "(", ")", "[", "2", ":", "]", "\n", "H16", ",", "W16", "=", "feat16", ".", "size", "(", ")", "[", "2", ":", "]", "\n", "H32", ",", "W32", "=", "feat32", ".", "size", "(", ")", "[", "2", ":", "]", "\n", "\n", "avg", "=", "F", ".", "avg_pool2d", "(", "feat32", ",", "feat32", ".", "size", "(", ")", "[", "2", ":", "]", ")", "\n", "avg", "=", "self", ".", "conv_avg", "(", "avg", ")", "\n", "avg_up", "=", "F", ".", "interpolate", "(", "avg", ",", "(", "H32", ",", "W32", ")", ",", "mode", "=", "'nearest'", ")", "\n", "\n", "feat32_arm", "=", "self", ".", "arm32", "(", "feat32", ")", "\n", "feat32_sum", "=", "feat32_arm", "+", "avg_up", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.forward": [[118, 157], ["model.ILVR.schedule_sampler.sample", "model.ILVR.diffusion.training_losses", "isinstance", "model.ILVR.schedule_sampler.update_with_local_losses", "v.to", "losses[].detach", "model.ILVR.items", "cond.items"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.resample.ScheduleSampler.sample", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.respace.SpacedDiffusion.training_losses", "home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.resample.LossAwareSampler.update_with_local_losses"], ["feat32_up", "=", "self", ".", "conv_head32", "(", "feat32_up", ")", "\n", "\n", "feat16_arm", "=", "self", ".", "arm16", "(", "feat16", ")", "\n", "feat16_sum", "=", "feat16_arm", "+", "feat32_up", "\n", "feat16_up", "=", "F", ".", "interpolate", "(", "feat16_sum", ",", "(", "H8", ",", "W8", ")", ",", "mode", "=", "'nearest'", ")", "\n", "feat16_up", "=", "self", ".", "conv_head16", "(", "feat16_up", ")", "\n", "\n", "return", "feat8", ",", "feat16_up", ",", "feat32_up", "# x8, x8, x16", "\n", "\n", "", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "for", "ly", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "ly", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n", "", "", "", "def", "get_params", "(", "self", ")", ":", "\n", "        ", "wd_params", ",", "nowd_params", "=", "[", "]", ",", "[", "]", "\n", "for", "name", ",", "module", "in", "self", ".", "named_modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "module", ",", "(", "nn", ".", "Linear", ",", "nn", ".", "Conv2d", ")", ")", ":", "\n", "                ", "wd_params", ".", "append", "(", "module", ".", "weight", ")", "\n", "if", "not", "module", ".", "bias", "is", "None", ":", "\n", "                    ", "nowd_params", ".", "append", "(", "module", ".", "bias", ")", "\n", "", "", "elif", "isinstance", "(", "module", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "nowd_params", "+=", "list", "(", "module", ".", "parameters", "(", ")", ")", "\n", "", "", "return", "wd_params", ",", "nowd_params", "\n", "\n", "\n", "### This is not used, since I replace this with the resnet feature with the same size", "\n", "", "", "class", "SpatialPath", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "SpatialPath", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "ConvBNReLU", "(", "3", ",", "64", ",", "ks", "=", "7", ",", "stride", "=", "2", ",", "padding", "=", "3", ")", "\n", "self", ".", "conv2", "=", "ConvBNReLU", "(", "64", ",", "64", ",", "ks", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv3", "=", "ConvBNReLU", "(", "64", ",", "64", ",", "ks", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv_out", "=", "ConvBNReLU", "(", "64", ",", "128", ",", "ks", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "self", ".", "init_weight", "(", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "feat", "=", "self", ".", "conv1", "(", "x", ")", "\n", "feat", "=", "self", ".", "conv2", "(", "feat", ")", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.save": [[159, 161], ["model.ILVR.save_net"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.save_net"], ["feat", "=", "self", ".", "conv_out", "(", "feat", ")", "\n", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.load": [[163, 168], ["model.ILVR.model.load_state_dict", "model.ILVR.load_net", "torch.load"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.guided_diffusion.dist_util.load_state_dict", "home.repos.pwc.inspect_result.ailon-island_facke.models.model_base.ModelBase.load_net", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.load"], ["        ", "for", "ly", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "ly", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "ly", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "not", "ly", ".", "bias", "is", "None", ":", "nn", ".", "init", ".", "constant_", "(", "ly", ".", "bias", ",", "0", ")", "\n", "\n", "", "", "", "def", "get_params", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.update_ema": [[170, 173], ["zip", "utils.guided_diffusion.nn.update_ema", "list", "model.ILVR.model.parameters"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.update_ema"], ["for", "name", ",", "module", "in", "self", ".", "named_modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "module", ",", "nn", ".", "Linear", ")", "or", "isinstance", "(", "module", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "wd_params", ".", "append", "(", "module", ".", "weight", ")", "\n", "if", "not", "module", ".", "bias", "is", "None", ":", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.data.VGGface2HQ.VGGFace2HQDataset.__init__": [[13, 35], ["os.path.join", "os.path.join", "torchvision.datasets.ImageFolder", "len", "numpy.zeros", "numpy.array", "numpy.concatenate", "random.seed", "numpy.array", "numpy.array", "numpy.argwhere().reshape", "len", "numpy.argwhere"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "opt", ",", "isTrain", "=", "True", ",", "transform", "=", "None", ",", "is_same_ID", "=", "True", ",", "auto_same_ID", "=", "True", ",", "random_seed", "=", "1234", ")", ":", "#isTrain=True, data_dir='datasets\\\\VGGface2_HQ', is_same_ID=True, transform=None):", "\n", "#print('Dataset initiated!')", "\n", "        ", "self", ".", "opt", "=", "opt", "\n", "set", "=", "'train'", "if", "isTrain", "else", "'test'", "\n", "self", ".", "data_dir", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "dataroot", ",", "set", ")", "\n", "img_dir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "data_dir", ",", "'images'", ")", "\n", "self", ".", "dataset", "=", "datasets", ".", "ImageFolder", "(", "img_dir", ")", "\n", "self", ".", "toggle_interval", "=", "opt", ".", "batchSize", "*", "(", "opt", ".", "nThreads", "%", "2", ")", "\n", "self", ".", "transform", "=", "transform", "\n", "self", ".", "is_same_ID", "=", "is_same_ID", "\n", "self", ".", "auto_same_ID", "=", "auto_same_ID", "\n", "self", ".", "intra_ID_random", "=", "not", "opt", ".", "no_intra_ID_random", "\n", "self", ".", "sample_cnt", "=", "0", "\n", "self", ".", "num_classes", "=", "len", "(", "self", ".", "dataset", ".", "classes", ")", "\n", "self", ".", "label_ranges", "=", "np", ".", "zeros", "(", "self", ".", "num_classes", "+", "1", ")", "\n", "self", ".", "dataset", ".", "targets", "=", "np", ".", "array", "(", "self", ".", "dataset", ".", "targets", ")", "\n", "self", ".", "label_ranges", "=", "np", ".", "concatenate", "(", "[", "np", ".", "array", "(", "[", "0", "]", ")", ",", "\n", "np", ".", "argwhere", "(", "self", ".", "dataset", ".", "targets", "[", "1", ":", "]", "!=", "self", ".", "dataset", ".", "targets", "[", ":", "-", "1", "]", ")", ".", "reshape", "(", "-", "1", ")", "+", "1", ",", "\n", "np", ".", "array", "(", "[", "len", "(", "self", ".", "dataset", ".", "imgs", ")", "]", ")", "]", ")", "\n", "self", ".", "ID_extract", "=", "None", "\n", "\n", "random", ".", "seed", "(", "random_seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.data.VGGface2HQ.VGGFace2HQDataset.toggle_is_same_ID": [[37, 39], ["None"], "methods", ["None"], ["", "def", "toggle_is_same_ID", "(", "self", ")", ":", "\n", "        ", "self", ".", "is_same_ID", "=", "not", "self", ".", "is_same_ID", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.data.VGGface2HQ.VGGFace2HQDataset.__len__": [[41, 43], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.data.VGGface2HQ.VGGFace2HQDataset.__getitem__": [[45, 89], ["VGGface2HQ.VGGFace2HQDataset.get_latent", "random.randint", "random.randint", "VGGface2HQ.VGGFace2HQDataset.transform", "VGGface2HQ.VGGFace2HQDataset.get_latent", "random.randint", "VGGface2HQ.VGGFace2HQDataset.transform", "VGGface2HQ.VGGFace2HQDataset.toggle_is_same_ID", "len"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.data.VGGface2HQ.VGGFace2HQDataset.get_latent", "home.repos.pwc.inspect_result.ailon-island_facke.utils.face_align_ffhqandnewarc.transform", "home.repos.pwc.inspect_result.ailon-island_facke.data.VGGface2HQ.VGGFace2HQDataset.get_latent", "home.repos.pwc.inspect_result.ailon-island_facke.utils.face_align_ffhqandnewarc.transform", "home.repos.pwc.inspect_result.ailon-island_facke.data.VGGface2HQ.VGGFace2HQDataset.toggle_is_same_ID"], ["", "def", "__getitem__", "(", "self", ",", "idx_source", ")", ":", "\n", "# get source image", "\n", "        ", "img_source", "=", "self", ".", "dataset", "[", "idx_source", "]", "[", "0", "]", "\n", "\n", "# get index of target image", "\n", "same_outputs", "=", "False", "\n", "label_source", "=", "self", ".", "dataset", ".", "targets", "[", "idx_source", "]", "\n", "if", "self", ".", "is_same_ID", ":", "\n", "# pick target image from the same ID", "\n", "            ", "if", "self", ".", "intra_ID_random", ":", "\n", "                ", "idx_target", "=", "random", ".", "randint", "(", "self", ".", "label_ranges", "[", "label_source", "]", ",", "self", ".", "label_ranges", "[", "label_source", "+", "1", "]", "-", "2", ")", "\n", "idx_target", "=", "idx_target", "+", "1", "if", "idx_target", ">=", "idx_source", "else", "idx_target", "\n", "", "else", ":", "\n", "                ", "same_outputs", "=", "True", "\n", "", "", "else", ":", "\n", "# pick target image from a different ID", "\n", "            ", "label_target", "=", "random", ".", "randint", "(", "0", ",", "len", "(", "self", ".", "dataset", ".", "classes", ")", "-", "2", ")", "\n", "label_target", "=", "label_target", "+", "1", "if", "label_target", ">=", "label_source", "else", "label_target", "\n", "idx_target", "=", "random", ".", "randint", "(", "self", ".", "label_ranges", "[", "label_target", "]", ",", "self", ".", "label_ranges", "[", "label_target", "+", "1", "]", "-", "1", ")", "\n", "\n", "# process source image", "\n", "", "latent_id_source", "=", "self", ".", "get_latent", "(", "idx_source", ")", "\n", "if", "self", ".", "transform", "is", "not", "None", ":", "\n", "            ", "img_source", "=", "self", ".", "transform", "(", "img_source", ")", "\n", "\n", "# get and process target image", "\n", "", "if", "same_outputs", ":", "\n", "            ", "img_target", "=", "img_source", "\n", "latent_id_target", "=", "latent_id_source", "\n", "", "else", ":", "\n", "            ", "img_target", "=", "self", ".", "dataset", "[", "idx_target", "]", "[", "0", "]", "\n", "latent_id_target", "=", "self", ".", "get_latent", "(", "idx_target", ")", "\n", "if", "self", ".", "transform", "is", "not", "None", ":", "\n", "                ", "img_target", "=", "self", ".", "transform", "(", "img_target", ")", "\n", "\n", "# toggle the same ID flag", "\n", "", "", "is_same_ID", "=", "self", ".", "is_same_ID", "\n", "if", "self", ".", "auto_same_ID", ":", "\n", "            ", "self", ".", "sample_cnt", "+=", "1", ";", "\n", "if", "self", ".", "sample_cnt", "==", "self", ".", "toggle_interval", ":", "\n", "                ", "self", ".", "toggle_is_same_ID", "(", ")", "\n", "self", ".", "sample_cnt", "=", "0", "\n", "\n", "", "", "return", "(", "img_source", ",", "img_target", ")", ",", "(", "latent_id_source", ",", "latent_id_target", ")", ",", "is_same_ID", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.data.VGGface2HQ.VGGFace2HQDataset.get_latent": [[91, 111], ["os.path.join", "utils.utils.utils.mkdirs", "os.path.join", "utils.utils.utils.mkdirs", "os.path.join", "numpy.load", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "os.path.exists", "VGGface2HQ.VGGFace2HQDataset.generate_latent", "print", "VGGface2HQ.VGGFace2HQDataset.generate_latent", "str"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.mkdirs", "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.mkdirs", "home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.load", "home.repos.pwc.inspect_result.ailon-island_facke.data.VGGface2HQ.VGGFace2HQDataset.generate_latent", "home.repos.pwc.inspect_result.ailon-island_facke.data.VGGface2HQ.VGGFace2HQDataset.generate_latent"], ["", "def", "get_latent", "(", "self", ",", "idx", ")", ":", "\n", "        ", "img", ",", "label", "=", "self", ".", "dataset", "[", "idx", "]", "\n", "latent_ID_dir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "data_dir", ",", "'latent-ID'", ")", "\n", "utils", ".", "mkdirs", "(", "latent_ID_dir", ")", "\n", "class_name", "=", "self", ".", "dataset", ".", "classes", "[", "label", "]", "\n", "save_class_dir", "=", "os", ".", "path", ".", "join", "(", "latent_ID_dir", ",", "class_name", ")", "\n", "utils", ".", "mkdirs", "(", "save_class_dir", ")", "\n", "save_pth", "=", "os", ".", "path", ".", "join", "(", "save_class_dir", ",", "str", "(", "idx", ")", "+", "'.npy'", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "save_pth", ")", ":", "\n", "            ", "self", ".", "generate_latent", "(", "img", ",", "save_pth", ")", "\n", "\n", "", "latent_ID", "=", "np", ".", "load", "(", "save_pth", ")", "\n", "if", "(", "latent_ID", ".", "shape", "!=", "(", "512", ",", ")", ")", ":", "\n", "            ", "print", "(", "latent_ID", ".", "shape", ")", "\n", "self", ".", "generate_latent", "(", "img", ",", "save_pth", ")", "\n", "#latent_ID = latent_ID / np.linalg.norm(latent_ID)", "\n", "", "latent_ID", "=", "torch", ".", "from_numpy", "(", "latent_ID", ")", "\n", "\n", "return", "latent_ID", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.data.VGGface2HQ.VGGFace2HQDataset.generate_latent": [[113, 128], ["utils.utils.IDExtract.IDExtractor", "VGGface2HQ.VGGFace2HQDataset.ID_extract.eval", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "img.to.to.view", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "VGGface2HQ.VGGFace2HQDataset.ID_extract.INnorm", "VGGface2HQ.VGGFace2HQDataset.ID_extract().cpu().numpy", "latent_ID.reshape.reshape.reshape", "numpy.save", "torchvision.transforms.ToTensor", "img.to.to.to", "img.to.to.to", "VGGface2HQ.VGGFace2HQDataset.ID_extract().cpu", "VGGface2HQ.VGGFace2HQDataset.ID_extract"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.ILVR.model.ILVR.save"], ["", "def", "generate_latent", "(", "self", ",", "img", ",", "save_pth", ")", ":", "\n", "        ", "if", "self", ".", "ID_extract", "is", "None", ":", "\n", "            ", "self", ".", "ID_extract", "=", "IDExtractor", "(", "self", ".", "opt", ")", "\n", "self", ".", "ID_extract", ".", "eval", "(", ")", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "img", "=", "transforms", ".", "ToTensor", "(", ")", "(", "img", ")", "\n", "img", "=", "img", ".", "view", "(", "-", "1", ",", "img", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "1", "]", ",", "img", ".", "shape", "[", "2", "]", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "                ", "img", "=", "img", ".", "to", "(", "'cuda'", ")", "\n", "", "else", ":", "\n", "                ", "img", "=", "img", ".", "to", "(", "\"cpu\"", ")", "\n", "", "img", "=", "self", ".", "ID_extract", ".", "INnorm", "(", "img", ")", "\n", "latent_ID", "=", "self", ".", "ID_extract", "(", "img", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "latent_ID", "=", "latent_ID", ".", "reshape", "(", "-", "1", ")", "\n", "np", ".", "save", "(", "save_pth", ",", "latent_ID", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.data.VGGface2HQ.VGGFace2HQDataset.set_worker": [[130, 132], ["None"], "methods", ["None"], ["", "", "def", "set_worker", "(", "self", ",", "worker_id", ")", ":", "\n", "        ", "self", ".", "is_same_ID", "=", "(", "worker_id", "+", "self", ".", "is_same_ID", ")", "%", "2", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.data.VGGface2HQ.ComposedLoader.__init__": [[137, 143], ["super().__init__", "iter", "iter"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__"], ["    ", "def", "__init__", "(", "self", ",", "loader1", ",", "loader2", ")", ":", "\n", "        ", "super", "(", "ComposedLoader", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "loaders", "=", "[", "loader1", ",", "loader2", "]", "\n", "self", ".", "iters", "=", "[", "iter", "(", "loader1", ")", ",", "iter", "(", "loader2", ")", "]", "\n", "self", ".", "current_iter_id", "=", "1", "\n", "self", ".", "batch_size", "=", "self", ".", "loaders", "[", "0", "]", ".", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.data.VGGface2HQ.ComposedLoader.__iter__": [[145, 147], ["None"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.data.VGGface2HQ.ComposedLoader.__next__": [[149, 153], ["next"], "methods", ["None"], ["", "def", "__next__", "(", "self", ")", ":", "\n", "        ", "self", ".", "current_iter_id", "=", "1", "-", "self", ".", "current_iter_id", "\n", "\n", "return", "next", "(", "self", ".", "iters", "[", "self", ".", "current_iter_id", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.data.VGGface2HQ.ComposedLoader.__len__": [[155, 157], ["len", "len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "loaders", "[", "0", "]", ")", "+", "len", "(", "self", ".", "loaders", "[", "1", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.data.dataset_base.DatasetBase.__init__": [[6, 10], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "data_dir", ",", "transform", "=", "None", ",", "target_transform", "=", "None", ")", ":", "\n", "        ", "self", ".", "img_dir", "=", "data_dir", "\n", "self", ".", "transform", "=", "transform", "\n", "self", ".", "target_transform", "=", "target_transform", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.data.dataset_base.DatasetBase.__len__": [[12, 14], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.data.dataset_base.DatasetBase.__getitem__": [[16, 18], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "pass", "", "", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.options.test_options.TestOptions.initialize": [[16, 55], ["base_options.BaseOptions.initialize", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "test_options.TestOptions.parser.add_argument", "float"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.initialize"], ["    ", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "BaseOptions", ".", "initialize", "(", "self", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--ntest'", ",", "type", "=", "int", ",", "default", "=", "float", "(", "\"100\"", ")", ",", "help", "=", "'# of test examples.'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--results_dir'", ",", "type", "=", "str", ",", "default", "=", "'./results/'", ",", "help", "=", "'saves results here.'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--aspect_ratio'", ",", "type", "=", "float", ",", "default", "=", "1.0", ",", "help", "=", "'aspect ratio of result images'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--phase'", ",", "type", "=", "str", ",", "default", "=", "'test'", ",", "help", "=", "'train, val, test, etc'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--epoch_label'", ",", "type", "=", "str", ",", "default", "=", "'latest'", ",", "help", "=", "'which epoch to load? set to latest to use latest cached model'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--how_many'", ",", "type", "=", "int", ",", "default", "=", "50", ",", "help", "=", "'how many test images to run'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--cluster_path'", ",", "type", "=", "str", ",", "default", "=", "'features_clustered_010.npy'", ",", "help", "=", "'the path for clustered results of encoded features'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--use_encoded_image'", ",", "action", "=", "'store_true'", ",", "help", "=", "'if specified, encode the real image to get the feature map'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "\"--export_onnx\"", ",", "type", "=", "str", ",", "help", "=", "\"export ONNX model to a given file\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "\"--engine\"", ",", "type", "=", "str", ",", "help", "=", "\"run serialized TRT engine\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "\"--onnx\"", ",", "type", "=", "str", ",", "help", "=", "\"run ONNX model via TRT\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "\"--Arc_path\"", ",", "type", "=", "str", ",", "default", "=", "'utils/Arcface/arcface_checkpoint.tar'", ",", "help", "=", "\"run ONNX model via TRT\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "\"--Cos_path\"", ",", "type", "=", "str", ",", "default", "=", "'utils/Cosface/cosface_checkpoint.pth'", ",", "help", "=", "\"CosFace model checkpoint\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "\"--pic_a_path\"", ",", "type", "=", "str", ",", "default", "=", "'./crop_224/gdg.jpg'", ",", "help", "=", "\"Person who provides identity information\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "\"--pic_b_path\"", ",", "type", "=", "str", ",", "default", "=", "'./crop_224/zrf.jpg'", ",", "help", "=", "\"Person who provides information other than their identity\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "\"--pic_specific_path\"", ",", "type", "=", "str", ",", "default", "=", "'./crop_224/zrf.jpg'", ",", "help", "=", "\"The specific person to be swapped\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "\"--multisepcific_dir\"", ",", "type", "=", "str", ",", "default", "=", "'./demo_file/multispecific'", ",", "help", "=", "\"Dir for multi specific\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "\"--video_path\"", ",", "type", "=", "str", ",", "default", "=", "'./demo_file/multi_people_1080p.mp4'", ",", "help", "=", "\"path for the video to swap\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "\"--temp_path\"", ",", "type", "=", "str", ",", "default", "=", "'./temp_results'", ",", "help", "=", "\"path to save temporarily images\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "\"--output_path\"", ",", "type", "=", "str", ",", "default", "=", "'./output/'", ",", "help", "=", "\"results path\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "\"--source_path\"", ",", "type", "=", "str", ",", "default", "=", "'./input/source'", ",", "help", "=", "\"source image path\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "\"--target_path\"", ",", "type", "=", "str", ",", "default", "=", "'./input/target'", ",", "help", "=", "\"target image path\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--id_thres'", ",", "type", "=", "float", ",", "default", "=", "0.03", ",", "help", "=", "'how many test images to run'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--no_simswaplogo'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Remove the watermark'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--use_mask'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Use mask for better result'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--crop_size'", ",", "type", "=", "int", ",", "default", "=", "224", ",", "help", "=", "'Crop of size of input image'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--finetuned'", ",", "action", "=", "'store_true'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--benchmark_coarse'", ",", "type", "=", "int", ",", "default", "=", "4000", ",", "help", "=", "'samples to run in coarse benchmark'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--benchmark_fine'", ",", "type", "=", "int", ",", "default", "=", "20000", ",", "help", "=", "'samples to run in fine benchmark'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--benchmark_skip'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "'samples to run in fine benchmark'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--num_to_swap'", ",", "type", "=", "int", ",", "default", "=", "8", ",", "help", "=", "'# of images to get swapped'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--swap_title'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "help", "=", "'title of current swap'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--input_format'", ",", "type", "=", "str", ",", "default", "=", "'jpg'", ",", "help", "=", "'format of input images for swapping'", ")", "\n", "\n", "\n", "\n", "self", ".", "isTrain", "=", "False", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.options.train_options.TrainOptions.initialize": [[8, 58], ["base_options.BaseOptions.initialize", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument", "train_options.TrainOptions.parser.add_argument"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.initialize"], ["    ", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "BaseOptions", ".", "initialize", "(", "self", ")", "\n", "# for displays", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--display_freq'", ",", "type", "=", "int", ",", "default", "=", "10000", ",", "help", "=", "'frequency of showing training results on screen'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--display_freq_test'", ",", "type", "=", "int", ",", "default", "=", "10000", ",", "help", "=", "'frequency of showing testing results on screen'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--print_freq'", ",", "type", "=", "int", ",", "default", "=", "800", ",", "help", "=", "'frequency of showing training results on console'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--save_latest_freq'", ",", "type", "=", "int", ",", "default", "=", "10000", ",", "help", "=", "'frequency of saving the latest results'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--save_epoch_freq'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "'frequency of saving checkpoints at the end of epochs'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--no_html'", ",", "action", "=", "'store_true'", ",", "help", "=", "'do not save intermediate training results to [opt.checkpoints_dir]/[opt.name]/web/'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--debug'", ",", "action", "=", "'store_true'", ",", "help", "=", "'only do one epoch and displays at each iteration'", ")", "\n", "\n", "# for training", "\n", "self", ".", "parser", ".", "add_argument", "(", "\"--memory_check\"", ",", "action", "=", "'store_true'", ",", "help", "=", "'check for unexpected memory increase batch by batch'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "\"--ID_check\"", ",", "action", "=", "'store_true'", ",", "help", "=", "'check if the dataloader generates images with correct ID'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "\"--Arc_path\"", ",", "type", "=", "str", ",", "default", "=", "'utils/Arcface/arcface_checkpoint.tar'", ",", "help", "=", "\"run ONNX model via TRT\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--continue_train'", ",", "action", "=", "'store_true'", ",", "help", "=", "'continue training: load the latest model'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--load_pretrain'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "help", "=", "'load the pretrained model from the specified location'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--epoch_label'", ",", "type", "=", "str", ",", "default", "=", "'latest'", ",", "help", "=", "'which epoch to load? set to latest to use latest cached model'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--phase'", ",", "type", "=", "str", ",", "default", "=", "'train'", ",", "help", "=", "'train, val, test, etc'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--niter'", ",", "type", "=", "int", ",", "default", "=", "2", ",", "help", "=", "'# of iter at starting learning rate'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--niter_decay'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "help", "=", "'# of iter to linearly decay learning rate to zero'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--beta1'", ",", "type", "=", "float", ",", "default", "=", "0.0", ",", "help", "=", "'momentum term of adam'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--lr'", ",", "type", "=", "float", ",", "default", "=", "0.0004", ",", "help", "=", "'initial learning rate for adam'", ")", "\n", "\n", "# for discriminators        ", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--num_D'", ",", "type", "=", "int", ",", "default", "=", "2", ",", "help", "=", "'number of discriminators to use'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--n_layers_D'", ",", "type", "=", "int", ",", "default", "=", "4", ",", "help", "=", "'only used if which_model_netD==n_layers'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--ndf'", ",", "type", "=", "int", ",", "default", "=", "64", ",", "help", "=", "'# of discrim filters in first conv layer'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--lambda_FM'", ",", "type", "=", "float", ",", "default", "=", "10.0", ",", "help", "=", "'weight for feature matching loss'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--lambda_id'", ",", "type", "=", "float", ",", "default", "=", "30.0", ",", "help", "=", "'weight for id loss'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--lambda_rec'", ",", "type", "=", "float", ",", "default", "=", "10.0", ",", "help", "=", "'weight for reconstruction loss'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--lambda_rec_swap'", ",", "type", "=", "float", ",", "default", "=", "8.0", ",", "help", "=", "'weight for reconstruction loss in CVAE while swapping'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--lambda_GP'", ",", "type", "=", "float", ",", "default", "=", "1E-5", ",", "help", "=", "'weight for gradient penalty loss'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--lambda_KL'", ",", "type", "=", "float", ",", "default", "=", "0.00025", ",", "help", "=", "'weight for KL loss in CVAE'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--lambda_KL_out'", ",", "type", "=", "float", ",", "default", "=", "10.0", ",", "help", "=", "'outside weight for KL loss in CVAE-GAN'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--feat_mode'", ",", "type", "=", "str", ",", "default", "=", "'w'", ",", "help", "=", "'the variant of feature matching to use, default weak'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--no_ganFeat_loss'", ",", "action", "=", "'store_true'", ",", "help", "=", "'if specified, do *not* use discriminator feature matching loss'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--no_vgg_loss'", ",", "action", "=", "'store_true'", ",", "help", "=", "'if specified, do *not* use VGG feature matching loss'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--gan_mode'", ",", "type", "=", "str", ",", "default", "=", "'hinge'", ",", "help", "=", "'(ls|original|hinge)'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--pool_size'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "help", "=", "'the size of image buffer that stores previously generated images'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--times_G'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'time of training generator before traning discriminator'", ")", "\n", "\n", "# for ILVR", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--ema_rate'", ",", "type", "=", "str", ",", "default", "=", "\"0.9999\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--schedule_sampler'", ",", "type", "=", "str", ",", "default", "=", "\"uniform\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--weight_decay'", ",", "type", "=", "float", ",", "default", "=", "0.0", ")", "\n", "\n", "\n", "self", ".", "isTrain", "=", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.__init__": [[18, 21], ["argparse.ArgumentParser"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "self", ".", "initialized", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.initialize": [[22, 109], ["base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "base_options.BaseOptions.parser.add_argument", "float"], "methods", ["None"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "# experiment specifics", "\n", "        ", "self", ".", "parser", ".", "add_argument", "(", "'--name'", ",", "type", "=", "str", ",", "default", "=", "'SimSwap'", ",", "help", "=", "'name of the experiment. It decides where to store samples and models'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--gpu_ids'", ",", "type", "=", "str", ",", "default", "=", "'0'", ",", "help", "=", "'gpu ids: e.g. 0  0,1,2, 0,2. use -1 for CPU'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--checkpoints_dir'", ",", "type", "=", "str", ",", "default", "=", "'./checkpoints'", ",", "help", "=", "'models are saved here'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--model'", ",", "type", "=", "str", ",", "default", "=", "'SimSwap'", ",", "help", "=", "'which model to use'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--norm'", ",", "type", "=", "str", ",", "default", "=", "'batch'", ",", "help", "=", "'instance normalization or batch normalization'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--use_dropout'", ",", "action", "=", "'store_true'", ",", "help", "=", "'use dropout for the generator'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--data_type'", ",", "default", "=", "32", ",", "type", "=", "int", ",", "choices", "=", "[", "8", ",", "16", ",", "32", "]", ",", "help", "=", "\"Supported data type i.e. 8, 16, 32 bit\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--verbose'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "help", "=", "'toggles verbose'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--fp16'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "help", "=", "'train with AMP'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--local_rank'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "help", "=", "'local rank for distributed training'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--isTrain'", ",", "type", "=", "bool", ",", "default", "=", "True", ",", "help", "=", "'local rank for distributed training'", ")", "\n", "\n", "# input/output sizes       ", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--batchSize'", ",", "type", "=", "int", ",", "default", "=", "2", ",", "help", "=", "'input batch size'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--loadSize'", ",", "type", "=", "int", ",", "default", "=", "1024", ",", "help", "=", "'scale images to this size'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--fineSize'", ",", "type", "=", "int", ",", "default", "=", "512", ",", "help", "=", "'then crop to this size'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--label_nc'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "help", "=", "'# of input label channels'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--input_nc'", ",", "type", "=", "int", ",", "default", "=", "3", ",", "help", "=", "'# of input image channels'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--output_nc'", ",", "type", "=", "int", ",", "default", "=", "3", ",", "help", "=", "'# of output image channels'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--no_intra_ID_random'", ",", "action", "=", "'store_true'", ",", "help", "=", "'whether to randomly pick two images when training batch with same ID'", ")", "\n", "\n", "# for setting inputs", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--dataroot'", ",", "type", "=", "str", ",", "default", "=", "'./datasets/VGGface2_HQ/'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--resize_or_crop'", ",", "type", "=", "str", ",", "default", "=", "'scale_width'", ",", "help", "=", "'scaling and cropping of images at load time [resize_and_crop|crop|scale_width|scale_width_and_crop]'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--serial_batches'", ",", "action", "=", "'store_true'", ",", "help", "=", "'if true, takes images in order to make batches, otherwise takes them randomly'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--no_flip'", ",", "action", "=", "'store_true'", ",", "help", "=", "'if specified, do not flip the images for data argumentation'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--nThreads'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'# threads for loading data'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--max_dataset_size'", ",", "type", "=", "int", ",", "default", "=", "float", "(", "\"inf\"", ")", ",", "help", "=", "'Maximum number of samples allowed per dataset. If the dataset directory contains more than max_dataset_size, only a subset is loaded.'", ")", "\n", "\n", "# for displays", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--display_winsize'", ",", "type", "=", "int", ",", "default", "=", "512", ",", "help", "=", "'display window size'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--tf_log'", ",", "action", "=", "'store_true'", ",", "help", "=", "'if specified, use tensorboard logging. Requires tensorflow installed'", ")", "\n", "\n", "# for generator", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--netG'", ",", "type", "=", "str", ",", "default", "=", "'global'", ",", "help", "=", "'selects model to use for netG'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--latent_size'", ",", "type", "=", "int", ",", "default", "=", "512", ",", "help", "=", "'latent size of Adain layer'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--ngf'", ",", "type", "=", "int", ",", "default", "=", "64", ",", "help", "=", "'# of gen filters in first conv layer'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--n_downsample_global'", ",", "type", "=", "int", ",", "default", "=", "3", ",", "help", "=", "'number of downsampling layers in netG'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--n_blocks_global'", ",", "type", "=", "int", ",", "default", "=", "6", ",", "help", "=", "'number of residual blocks in the global generator network'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--n_blocks_local'", ",", "type", "=", "int", ",", "default", "=", "3", ",", "help", "=", "'number of residual blocks in the local enhancer network'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--n_local_enhancers'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "'number of local enhancers to use'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--niter_fix_global'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "help", "=", "'number of epochs that we only train the outmost local enhancer'", ")", "\n", "\n", "# for instance-wise features", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--no_instance'", ",", "action", "=", "'store_true'", ",", "help", "=", "'if specified, do *not* add instance map as input'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--instance_feat'", ",", "action", "=", "'store_true'", ",", "help", "=", "'if specified, add encoded instance features as input'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--label_feat'", ",", "action", "=", "'store_true'", ",", "help", "=", "'if specified, add encoded label features as input'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--feat_num'", ",", "type", "=", "int", ",", "default", "=", "3", ",", "help", "=", "'vector length for encoded features'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--load_features'", ",", "action", "=", "'store_true'", ",", "help", "=", "'if specified, load precomputed feature maps'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--n_downsample_E'", ",", "type", "=", "int", ",", "default", "=", "4", ",", "help", "=", "'# of downsampling layers in encoder'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--nef'", ",", "type", "=", "int", ",", "default", "=", "16", ",", "help", "=", "'# of encoder filters in the first conv layer'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--n_clusters'", ",", "type", "=", "int", ",", "default", "=", "10", ",", "help", "=", "'number of clusters for features'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--image_size'", ",", "type", "=", "int", ",", "default", "=", "224", ",", "help", "=", "'number of clusters for features'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--norm_G'", ",", "type", "=", "str", ",", "default", "=", "'spectralspadesyncbatch3x3'", ",", "help", "=", "'instance normalization or batch normalization'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--semantic_nc'", ",", "type", "=", "int", ",", "default", "=", "3", ",", "help", "=", "'number of clusters for features'", ")", "\n", "self", ".", "initialized", "=", "True", "\n", "\n", "# for ILVR", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--noise_schedule'", ",", "type", "=", "str", ",", "default", "=", "'linear'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--DDPM_pth'", ",", "type", "=", "str", ",", "default", "=", "'utils/guided_diffusion/models/ffhq_10m.pt'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--channel_mult'", ",", "type", "=", "str", ",", "default", "=", "\"\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--attention_resolutions'", ",", "type", "=", "str", ",", "default", "=", "\"16\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--timestep_respacing'", ",", "type", "=", "str", ",", "default", "=", "\"100\"", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--class_cond'", ",", "action", "=", "'store_true'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--use_checkpoint'", ",", "action", "=", "'store_true'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--use_ddim'", ",", "action", "=", "'store_true'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--use_kl'", ",", "action", "=", "'store_true'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--predict_xstart'", ",", "action", "=", "'store_true'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--rescale_timesteps'", ",", "action", "=", "'store_true'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--rescale_learned_sigmas'", ",", "action", "=", "'store_true'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--save_latents'", ",", "action", "=", "'store_true'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--learn_sigma'", ",", "action", "=", "'store_true'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--resblock_updown'", ",", "action", "=", "'store_true'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--use_scale_shift_norm'", ",", "action", "=", "'store_true'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--use_new_attention_order'", ",", "action", "=", "'store_true'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--clip_denoised'", ",", "action", "=", "'store_true'", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--down_N'", ",", "type", "=", "int", ",", "default", "=", "32", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--diffusion_steps'", ",", "type", "=", "int", ",", "default", "=", "1000", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--dropout'", ",", "type", "=", "float", ",", "default", "=", "0.0", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--num_channels'", ",", "type", "=", "int", ",", "default", "=", "128", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--num_heads'", ",", "type", "=", "int", ",", "default", "=", "128", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--num_heads_upsample'", ",", "type", "=", "int", ",", "default", "=", "-", "1", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--num_head_channels'", ",", "type", "=", "int", ",", "default", "=", "64", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--num_res_blocks'", ",", "type", "=", "int", ",", "default", "=", "1", ")", "\n", "self", ".", "parser", ".", "add_argument", "(", "'--range_t'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.parse": [[111, 164], ["base_options.BaseOptions.parser.parse_args", "base_options.BaseOptions.opt.gpu_ids.split", "vars", "print", "sorted", "print", "base_options.BaseOptions.initialize", "int", "base_options.lcm", "base_options.lcm", "base_options.lcm", "base_options.lcm", "vars.items", "print", "os.path.join", "utils.utils.utils.mkdirs", "base_options.BaseOptions.opt.gpu_ids.append", "os.path.join", "float", "open", "base_options.BaseOptions.opt_file.write", "sorted", "base_options.BaseOptions.opt_file.write", "str", "str", "vars.items", "base_options.BaseOptions.opt_file.write", "str", "str"], "methods", ["home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.BaseOptions.initialize", "home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.lcm", "home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.lcm", "home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.lcm", "home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.lcm", "home.repos.pwc.inspect_result.ailon-island_facke.utils.utils.mkdirs"], ["", "def", "parse", "(", "self", ",", "save", "=", "True", ")", ":", "\n", "        ", "if", "not", "self", ".", "initialized", ":", "\n", "            ", "self", ".", "initialize", "(", ")", "\n", "", "self", ".", "opt", "=", "self", ".", "parser", ".", "parse_args", "(", ")", "\n", "self", ".", "opt", ".", "isTrain", "=", "self", ".", "isTrain", "# train or test", "\n", "\n", "str_ids", "=", "self", ".", "opt", ".", "gpu_ids", ".", "split", "(", "','", ")", "\n", "self", ".", "opt", ".", "gpu_ids", "=", "[", "]", "\n", "for", "str_id", "in", "str_ids", ":", "\n", "            ", "id", "=", "int", "(", "str_id", ")", "\n", "if", "id", ">=", "0", ":", "\n", "                ", "self", ".", "opt", ".", "gpu_ids", ".", "append", "(", "id", ")", "\n", "\n", "# set gpu ids", "\n", "# if len(self.opt.gpu_ids) > 0:", "\n", "#     torch.cuda.set_device(self.opt.gpu_ids[0])", "\n", "", "", "if", "self", ".", "isTrain", ":", "\n", "            ", "self", ".", "opt", ".", "print_freq", "=", "lcm", "(", "self", ".", "opt", ".", "print_freq", ",", "self", ".", "opt", ".", "batchSize", ")", "\n", "self", ".", "opt", ".", "display_freq", "=", "lcm", "(", "self", ".", "opt", ".", "display_freq", ",", "self", ".", "opt", ".", "batchSize", ")", "\n", "self", ".", "opt", ".", "save_latest_freq", "=", "lcm", "(", "self", ".", "opt", ".", "save_latest_freq", ",", "self", ".", "opt", ".", "batchSize", ")", "\n", "self", ".", "opt", ".", "display_freq_test", "=", "lcm", "(", "self", ".", "opt", ".", "display_freq_test", ",", "self", ".", "opt", ".", "batchSize", ")", "\n", "\n", "if", "self", ".", "opt", ".", "debug", ":", "\n", "                ", "self", ".", "opt", ".", "display_freq", "=", "1000", "\n", "self", ".", "opt", ".", "print_freq", "=", "1", "\n", "self", ".", "opt", ".", "display_freq_test", "=", "1", "\n", "self", ".", "opt", ".", "niter", "=", "1", "\n", "self", ".", "opt", ".", "niter_decay", "=", "1", "\n", "self", ".", "opt", ".", "batchSize", "=", "8", "\n", "if", "self", ".", "opt", ".", "max_dataset_size", "==", "float", "(", "\"inf\"", ")", ":", "\n", "                    ", "self", ".", "opt", ".", "max_dataset_size", "=", "5000", "\n", "", "self", ".", "opt", ".", "name", "=", "'debug'", "\n", "self", ".", "opt", ".", "verbose", "=", "True", "\n", "\n", "", "", "args", "=", "vars", "(", "self", ".", "opt", ")", "\n", "\n", "print", "(", "'------------ self.options -------------'", ")", "\n", "for", "k", ",", "v", "in", "sorted", "(", "args", ".", "items", "(", ")", ")", ":", "\n", "            ", "print", "(", "'%s: %s'", "%", "(", "str", "(", "k", ")", ",", "str", "(", "v", ")", ")", ")", "\n", "", "print", "(", "'-------------- End ----------------'", ")", "\n", "\n", "# save to the disk", "\n", "if", "self", ".", "opt", ".", "isTrain", ":", "\n", "            ", "expr_dir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "opt", ".", "checkpoints_dir", ",", "self", ".", "opt", ".", "name", ")", "\n", "utils", ".", "mkdirs", "(", "expr_dir", ")", "\n", "if", "save", "and", "not", "self", ".", "opt", ".", "continue_train", ":", "\n", "                ", "file_name", "=", "os", ".", "path", ".", "join", "(", "expr_dir", ",", "'opt.txt'", ")", "\n", "with", "open", "(", "file_name", ",", "'wt'", ")", "as", "self", ".", "opt_file", ":", "\n", "                    ", "self", ".", "opt_file", ".", "write", "(", "'------------ self.options -------------\\n'", ")", "\n", "for", "k", ",", "v", "in", "sorted", "(", "args", ".", "items", "(", ")", ")", ":", "\n", "                        ", "self", ".", "opt_file", ".", "write", "(", "'%s: %s\\n'", "%", "(", "str", "(", "k", ")", ",", "str", "(", "v", ")", ")", ")", "\n", "", "self", ".", "opt_file", ".", "write", "(", "'-------------- End ----------------\\n'", ")", "\n", "", "", "", "return", "self", ".", "opt", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ailon-island_facke.options.base_options.lcm": [[13, 14], ["abs", "math.gcd"], "function", ["None"], ["def", "lcm", "(", "a", ",", "b", ")", ":", "return", "abs", "(", "a", "*", "b", ")", "/", "math", ".", "gcd", "(", "a", ",", "b", ")", "if", "a", "and", "b", "else", "0", "\n", "\n"]]}