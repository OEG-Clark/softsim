{"home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute.load_annotated_tables": [[13, 20], ["open", "f.readlines", "json.loads", "l.replace"], "function", ["None"], ["def", "load_annotated_tables", "(", "file", ")", ":", "\n", "    ", "tables", "=", "{", "}", "\n", "with", "open", "(", "file", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "for", "l", "in", "f", ".", "readlines", "(", ")", ":", "\n", "            ", "raw", "=", "json", ".", "loads", "(", "l", ".", "replace", "(", "\"`\"", ",", "\"\\'\"", ")", ")", "\n", "tables", "[", "raw", "[", "\"id\"", "]", "]", "=", "raw", "\n", "", "", "return", "tables", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute.load_queries": [[21, 34], ["open", "f.readlines", "range", "len", "queries.append"], "function", ["None"], ["", "def", "load_queries", "(", "file", ")", ":", "\n", "\t", "queries", "=", "[", "]", "\n", "with", "open", "(", "file", ",", "\"r\"", ")", "as", "f", ":", "\n", "\t\t", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "lines", ")", ")", ":", "\n", "\t\t\t", "if", "i", "%", "4", "==", "0", ":", "\n", "\t\t\t\t", "h", "=", "lines", "[", "i", "]", "\n", "", "if", "i", "%", "4", "==", "1", ":", "\n", "\t\t\t\t", "y", "=", "lines", "[", "i", "]", "\n", "", "if", "i", "%", "4", "==", "2", ":", "\n", "\t\t\t\t", "p", "=", "lines", "[", "i", "]", "\n", "queries", ".", "append", "(", "(", "y", ",", "p", ",", "h", ")", ")", "\n", "", "", "", "return", "queries", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute.simple_parser": [[35, 58], ["q.strip().split", "range", "cond.append", "q.strip", "len", "print", "sys.exit"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print"], ["", "def", "simple_parser", "(", "q", ")", ":", "\n", "\n", "\t", "q_list", "=", "q", ".", "strip", "(", ")", ".", "split", "(", ")", "\n", "cond", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "3", ",", "len", "(", "q_list", ")", "-", "1", ",", "3", ")", ":", "\n", "\t\t", "l", "=", "q_list", "[", "i", "]", "\n", "op", "=", "q_list", "[", "i", "+", "1", "]", "\n", "r", "=", "q_list", "[", "i", "+", "2", "]", "\n", "cond", ".", "append", "(", "(", "l", ",", "op", ",", "r", ")", ")", "\n", "\n", "if", "op", "not", "in", "[", "\"=\"", ",", "\"<\"", ",", "\">\"", ",", "\"<>\"", ",", "\">=\"", ",", "\"<=\"", "]", ":", "\n", "\t\t\t", "print", "(", "op", ")", "\n", "sys", ".", "exit", "(", "-", "1", ")", "\n", "\n", "", "", "q", "=", "{", "\n", "\"table\"", ":", "q_list", "[", "0", "]", ",", "\n", "\"aggr\"", ":", "q_list", "[", "1", "]", ",", "\n", "\"selcol\"", ":", "q_list", "[", "2", "]", ",", "\n", "\"cond\"", ":", "cond", "\n", "}", "\n", "\n", "return", "q", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute.cond_check": [[59, 82], ["execute.normalized", "execute.normalized", "execute.try_equal", "execute.to_float", "execute.to_float", "execute.to_float", "execute.to_float", "print", "sys.exit", "execute.to_float", "execute.to_float", "execute.to_float", "execute.to_float"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.normalized", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.normalized", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.try_equal", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float"], ["", "def", "cond_check", "(", "row", ",", "conds", ")", ":", "\n", "\n", "\t", "check", "=", "True", "\n", "\n", "for", "cond", "in", "conds", ":", "\n", "\t\t", "lval", "=", "normalized", "(", "row", "[", "cond", "[", "0", "]", "]", ")", "\n", "rval", "=", "normalized", "(", "cond", "[", "2", "]", ")", "\n", "\n", "if", "cond", "[", "1", "]", "==", "\"=\"", ":", "\n", "\t\t\t", "check", "=", "check", "and", "try_equal", "(", "lval", ",", "rval", ")", "\n", "", "elif", "cond", "[", "1", "]", "==", "\"<\"", ":", "\n", "\t\t\t", "check", "=", "check", "and", "to_float", "(", "lval", ")", "<=", "to_float", "(", "rval", ")", "\n", "", "elif", "cond", "[", "1", "]", "==", "\">\"", ":", "\n", "\t\t\t", "check", "=", "check", "and", "to_float", "(", "lval", ")", ">=", "to_float", "(", "rval", ")", "\n", "", "elif", "cond", "[", "1", "]", "==", "\"<=\"", ":", "\n", "\t\t\t", "check", "=", "check", "and", "to_float", "(", "lval", ")", "<=", "to_float", "(", "rval", ")", "\n", "", "elif", "cond", "[", "1", "]", "==", "\">=\"", ":", "\n", "\t\t\t", "check", "=", "check", "and", "to_float", "(", "lval", ")", ">=", "to_float", "(", "rval", ")", "\n", "", "else", ":", "\n", "\t\t\t", "print", "(", "cond", ")", "\n", "sys", ".", "exit", "(", "-", "1", ")", "\n", "\n", "", "", "return", "check", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute.normalized": [[83, 86], ["v.replace().replace().replace", "re.sub().decode().strip", "v.replace().replace", "re.sub().decode", "v.replace", "re.sub"], "function", ["None"], ["", "def", "normalized", "(", "v", ")", ":", "\n", "\t", "x", "=", "v", ".", "replace", "(", "\"(\"", ",", "\"-lrb-\"", ")", ".", "replace", "(", "\")\"", ",", "\"-rrb-\"", ")", ".", "replace", "(", "\"`\"", ",", "\"\\'\"", ")", "\n", "return", "re", ".", "sub", "(", "r'[^\\x00-\\x7F]+'", ",", "''", ",", "x", ")", ".", "decode", "(", "'utf-8'", ",", "'ignore'", ")", ".", "strip", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute.to_float": [[87, 89], ["float", "v.replace"], "function", ["None"], ["", "def", "to_float", "(", "v", ")", ":", "\n", "\t", "return", "float", "(", "v", ".", "replace", "(", "\",\"", ",", "\"\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute.try_equal": [[90, 101], ["execute.to_float", "execute.to_float"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float"], ["", "def", "try_equal", "(", "v1", ",", "v2", ")", ":", "\n", "\t", "if", "v1", "==", "v2", ":", "\n", "\t\t", "return", "True", "\n", "", "try", ":", "\n", "\t\t", "v1", "=", "to_float", "(", "v1", ")", "\n", "v2", "=", "to_float", "(", "v2", ")", "\n", "return", "v1", "==", "v2", "\n", "", "except", ":", "\n", "\t\t", "pass", "\n", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute.execute": [[102, 132], ["range", "len", "len", "execute.cond_check", "execute.normalized", "len", "execute.normalized", "execute.normalized", "sum", "len", "sum", "max", "execute.to_float", "execute.to_float", "min", "execute.to_float", "execute.to_float"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.cond_check", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.normalized", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.normalized", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.normalized", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float"], ["", "def", "execute", "(", "table", ",", "q", ")", ":", "\n", "\n", "\t", "header", "=", "table", "[", "\"header\"", "]", "\n", "header_to_index", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "len", "(", "header", ")", ")", ":", "\n", "\t\t", "header_to_index", "[", "normalized", "(", "header", "[", "i", "]", ")", "]", "=", "i", "\n", "\n", "", "conds", "=", "[", "(", "header_to_index", "[", "normalized", "(", "c", "[", "0", "]", ")", "]", ",", "c", "[", "1", "]", ",", "c", "[", "2", "]", ")", "for", "c", "in", "q", "[", "\"cond\"", "]", "]", "\n", "\n", "filtered_row", "=", "[", "r", "for", "r", "in", "table", "[", "\"content\"", "]", "if", "cond_check", "(", "r", ",", "conds", ")", "]", "\n", "\n", "if", "len", "(", "filtered_row", ")", "==", "0", ":", "\n", "\t\t", "return", "None", "\n", "\n", "", "sel_index", "=", "header_to_index", "[", "normalized", "(", "q", "[", "\"selcol\"", "]", ")", "]", "\n", "\n", "selected_val", "=", "[", "r", "[", "sel_index", "]", "for", "r", "in", "filtered_row", "]", "\n", "\n", "if", "q", "[", "\"aggr\"", "]", "==", "\"select\"", ":", "\n", "\t\t", "return", "selected_val", "[", "0", "]", "\n", "", "elif", "q", "[", "\"aggr\"", "]", "==", "\"count\"", ":", "\n", "\t\t", "return", "len", "(", "selected_val", ")", "\n", "", "elif", "q", "[", "\"aggr\"", "]", "==", "\"avg\"", ":", "\n", "\t\t", "return", "sum", "(", "[", "to_float", "(", "v", ")", "for", "v", "in", "selected_val", "]", ")", "/", "len", "(", "selected_val", ")", "\n", "", "elif", "q", "[", "\"aggr\"", "]", "==", "\"sum\"", ":", "\n", "\t\t", "return", "sum", "(", "[", "to_float", "(", "v", ")", "for", "v", "in", "selected_val", "]", ")", "\n", "", "elif", "q", "[", "\"aggr\"", "]", "==", "\"max\"", ":", "\n", "\t\t", "return", "max", "(", "[", "to_float", "(", "v", ")", "for", "v", "in", "selected_val", "]", ")", "\n", "", "elif", "q", "[", "\"aggr\"", "]", "==", "\"min\"", ":", "\n", "\t\t", "return", "min", "(", "[", "to_float", "(", "v", ")", "for", "v", "in", "selected_val", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute.main": [[134, 206], ["execute.load_annotated_tables", "execute.load_queries", "print", "print", "print", "print", "print", "print", "os.path.join", "open", "raw_q1.strip", "raw_q2.strip", "execute.simple_parser", "execute.simple_parser", "execute.execute", "f.write", "f.write", "f.write", "f.write", "execute.execute", "all_wrong_ones.append", "all_wrong_ones.append", "execute.execute"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare.load_annotated_tables", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.load_queries", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.simple_parser", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.simple_parser", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.execute", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.execute", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.execute"], ["", "", "def", "main", "(", ")", ":", "\n", "\n", "\t", "all_wrong_ones", "=", "[", "]", "\n", "\n", "# load tables and queries", "\n", "tables", "=", "load_annotated_tables", "(", "os", ".", "path", ".", "join", "(", "db_folder", ",", "db_file", ")", ")", "\n", "queries", "=", "load_queries", "(", "result_file", ")", "\n", "\n", "lf_equal", "=", "0.", "\n", "ex_equal", "=", "0.", "\n", "total_num", "=", "402.", "\n", "\n", "wrong_a", "=", "0", "\n", "wrong_b", "=", "0", "\n", "wrong_c", "=", "0", "\n", "wrong_d", "=", "0", "\n", "wrong_e", "=", "0", "\n", "\n", "for", "raw_q1", ",", "raw_q2", ",", "h", "in", "queries", ":", "\n", "\t\t", "total_num", "+=", "1", "\n", "\n", "if", "raw_q1", ".", "strip", "(", ")", "==", "raw_q2", ".", "strip", "(", ")", ":", "\n", "\t\t\t", "lf_equal", "+=", "1", "\n", "#                else:", "\n", "#                    print(int(total_num), raw_q1.strip(), raw_q2.strip())", "\n", "\n", "# compare execution equivalence", "\n", "", "try", ":", "\n", "\t\t\t", "q1", "=", "simple_parser", "(", "raw_q1", ")", "\n", "q2", "=", "simple_parser", "(", "raw_q2", ")", "\n", "", "except", ":", "\n", "\t\t\t", "wrong_b", "+=", "1", "\n", "continue", "\n", "\n", "", "if", "q1", "[", "\"table\"", "]", "!=", "q2", "[", "\"table\"", "]", ":", "\n", "\t\t\t", "continue", "\n", "\n", "", "table", "=", "tables", "[", "q1", "[", "\"table\"", "]", "]", "\n", "\n", "try", ":", "\n", "\t\t\t", "try", ":", "\n", "\t\t\t\t", "v1", "=", "execute", "(", "table", ",", "q1", ")", "\n", "", "except", ":", "\n", "\t\t\t\t", "wrong_e", "+=", "1", "\n", "v1", "=", "execute", "(", "table", ",", "q1", ")", "\n", "", "if", "v1", "==", "None", ":", "\n", "\t\t\t\t", "wrong_c", "+=", "1", "\n", "", "v2", "=", "execute", "(", "table", ",", "q2", ")", "\n", "if", "v1", "!=", "None", "and", "v1", "==", "v2", ":", "\n", "\t\t\t\t", "ex_equal", "+=", "1", "\n", "", "else", ":", "\n", "\t\t\t\t", "all_wrong_ones", ".", "append", "(", "(", "raw_q1", ",", "raw_q2", ",", "h", ")", ")", "\n", "", "if", "v2", "==", "None", ":", "\n", "\t\t\t\t", "wrong_d", "+=", "1", "\n", "", "", "except", ":", "\n", "\t\t\t", "all_wrong_ones", ".", "append", "(", "(", "raw_q1", ",", "raw_q2", ",", "h", ")", ")", "\n", "wrong_a", "+=", "1", "\n", "\n", "", "", "print", "(", "\"#Q2 (predition) result is wrong: {}\"", ".", "format", "(", "wrong_a", "-", "wrong_e", "+", "wrong_d", ")", ")", "\n", "print", "(", "\"#Q1 or Q2 fail to parse: {}\"", ".", "format", "(", "wrong_b", ")", ")", "\n", "print", "(", "\"#Q1 (ground truth) exec to None: {}\"", ".", "format", "(", "wrong_c", ")", ")", "\n", "print", "(", "\"#Q1 (ground truth) failed to execute: {}\"", ".", "format", "(", "wrong_e", ")", ")", "\n", "\n", "print", "(", "'Logical Form Accuracy: {}'", ".", "format", "(", "lf_equal", "/", "total_num", ")", ")", "\n", "print", "(", "'Execute Accuracy: {}'", ".", "format", "(", "ex_equal", "/", "total_num", ")", ")", "\n", "\n", "with", "open", "(", "\"tmp_wrong_queries.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "\t\t", "for", "p", "in", "all_wrong_ones", ":", "\n", "\t\t\t", "f", ".", "write", "(", "p", "[", "2", "]", ")", "\n", "f", ".", "write", "(", "p", "[", "0", "]", ")", "\n", "f", ".", "write", "(", "p", "[", "1", "]", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.load_annotated_tables": [[13, 20], ["open", "f.readlines", "json.loads", "l.replace"], "function", ["None"], ["def", "load_annotated_tables", "(", "file", ")", ":", "\n", "    ", "tables", "=", "{", "}", "\n", "with", "open", "(", "file", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "for", "l", "in", "f", ".", "readlines", "(", ")", ":", "\n", "            ", "raw", "=", "json", ".", "loads", "(", "l", ".", "replace", "(", "\"`\"", ",", "\"\\'\"", ")", ")", "\n", "tables", "[", "raw", "[", "\"id\"", "]", "]", "=", "raw", "\n", "", "", "return", "tables", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.load_queries": [[21, 34], ["open", "f.readlines", "range", "len", "queries.append"], "function", ["None"], ["", "def", "load_queries", "(", "file", ")", ":", "\n", "\t", "queries", "=", "[", "]", "\n", "with", "open", "(", "file", ",", "\"r\"", ")", "as", "f", ":", "\n", "\t\t", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "lines", ")", ")", ":", "\n", "\t\t\t", "if", "i", "%", "4", "==", "0", ":", "\n", "\t\t\t\t", "h", "=", "lines", "[", "i", "]", "\n", "", "if", "i", "%", "4", "==", "1", ":", "\n", "\t\t\t\t", "y", "=", "lines", "[", "i", "]", "\n", "", "if", "i", "%", "4", "==", "2", ":", "\n", "\t\t\t\t", "p", "=", "lines", "[", "i", "]", "\n", "queries", ".", "append", "(", "(", "y", ",", "p", ",", "h", ")", ")", "\n", "", "", "", "return", "queries", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.simple_parser": [[35, 58], ["q.strip().split", "range", "cond.append", "q.strip", "len", "print", "sys.exit"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print"], ["", "def", "simple_parser", "(", "q", ")", ":", "\n", "\n", "\t", "q_list", "=", "q", ".", "strip", "(", ")", ".", "split", "(", ")", "\n", "cond", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "3", ",", "len", "(", "q_list", ")", "-", "1", ",", "3", ")", ":", "\n", "\t\t", "l", "=", "q_list", "[", "i", "]", "\n", "op", "=", "q_list", "[", "i", "+", "1", "]", "\n", "r", "=", "q_list", "[", "i", "+", "2", "]", "\n", "cond", ".", "append", "(", "(", "l", ",", "op", ",", "r", ")", ")", "\n", "\n", "if", "op", "not", "in", "[", "\"=\"", ",", "\"<\"", ",", "\">\"", ",", "\"<>\"", ",", "\">=\"", ",", "\"<=\"", "]", ":", "\n", "\t\t\t", "print", "(", "op", ")", "\n", "sys", ".", "exit", "(", "-", "1", ")", "\n", "\n", "", "", "q", "=", "{", "\n", "\"table\"", ":", "q_list", "[", "0", "]", ",", "\n", "\"aggr\"", ":", "q_list", "[", "1", "]", ",", "\n", "\"selcol\"", ":", "q_list", "[", "2", "]", ",", "\n", "\"cond\"", ":", "cond", "\n", "}", "\n", "\n", "return", "q", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.cond_check": [[59, 82], ["execute_dev.normalized", "execute_dev.normalized", "execute_dev.try_equal", "execute_dev.to_float", "execute_dev.to_float", "execute_dev.to_float", "execute_dev.to_float", "print", "sys.exit", "execute_dev.to_float", "execute_dev.to_float", "execute_dev.to_float", "execute_dev.to_float"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.normalized", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.normalized", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.try_equal", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float"], ["", "def", "cond_check", "(", "row", ",", "conds", ")", ":", "\n", "\n", "\t", "check", "=", "True", "\n", "\n", "for", "cond", "in", "conds", ":", "\n", "\t\t", "lval", "=", "normalized", "(", "row", "[", "cond", "[", "0", "]", "]", ")", "\n", "rval", "=", "normalized", "(", "cond", "[", "2", "]", ")", "\n", "\n", "if", "cond", "[", "1", "]", "==", "\"=\"", ":", "\n", "\t\t\t", "check", "=", "check", "and", "try_equal", "(", "lval", ",", "rval", ")", "\n", "", "elif", "cond", "[", "1", "]", "==", "\"<\"", ":", "\n", "\t\t\t", "check", "=", "check", "and", "to_float", "(", "lval", ")", "<=", "to_float", "(", "rval", ")", "\n", "", "elif", "cond", "[", "1", "]", "==", "\">\"", ":", "\n", "\t\t\t", "check", "=", "check", "and", "to_float", "(", "lval", ")", ">=", "to_float", "(", "rval", ")", "\n", "", "elif", "cond", "[", "1", "]", "==", "\"<=\"", ":", "\n", "\t\t\t", "check", "=", "check", "and", "to_float", "(", "lval", ")", "<=", "to_float", "(", "rval", ")", "\n", "", "elif", "cond", "[", "1", "]", "==", "\">=\"", ":", "\n", "\t\t\t", "check", "=", "check", "and", "to_float", "(", "lval", ")", ">=", "to_float", "(", "rval", ")", "\n", "", "else", ":", "\n", "\t\t\t", "print", "(", "cond", ")", "\n", "sys", ".", "exit", "(", "-", "1", ")", "\n", "\n", "", "", "return", "check", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.normalized": [[83, 86], ["v.replace().replace().replace", "re.sub().decode().strip", "v.replace().replace", "re.sub().decode", "v.replace", "re.sub"], "function", ["None"], ["", "def", "normalized", "(", "v", ")", ":", "\n", "\t", "x", "=", "v", ".", "replace", "(", "\"(\"", ",", "\"-lrb-\"", ")", ".", "replace", "(", "\")\"", ",", "\"-rrb-\"", ")", ".", "replace", "(", "\"`\"", ",", "\"\\'\"", ")", "\n", "return", "re", ".", "sub", "(", "r'[^\\x00-\\x7F]+'", ",", "''", ",", "x", ")", ".", "decode", "(", "'utf-8'", ",", "'ignore'", ")", ".", "strip", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float": [[87, 89], ["float", "v.replace"], "function", ["None"], ["", "def", "to_float", "(", "v", ")", ":", "\n", "\t", "return", "float", "(", "v", ".", "replace", "(", "\",\"", ",", "\"\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.try_equal": [[90, 101], ["execute_dev.to_float", "execute_dev.to_float"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float"], ["", "def", "try_equal", "(", "v1", ",", "v2", ")", ":", "\n", "\t", "if", "v1", "==", "v2", ":", "\n", "\t\t", "return", "True", "\n", "", "try", ":", "\n", "\t\t", "v1", "=", "to_float", "(", "v1", ")", "\n", "v2", "=", "to_float", "(", "v2", ")", "\n", "return", "v1", "==", "v2", "\n", "", "except", ":", "\n", "\t\t", "pass", "\n", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.execute": [[102, 132], ["range", "len", "len", "execute_dev.cond_check", "execute_dev.normalized", "len", "execute_dev.normalized", "execute_dev.normalized", "sum", "len", "sum", "max", "execute_dev.to_float", "execute_dev.to_float", "min", "execute_dev.to_float", "execute_dev.to_float"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.cond_check", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.normalized", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.normalized", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.normalized", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float"], ["", "def", "execute", "(", "table", ",", "q", ")", ":", "\n", "\n", "\t", "header", "=", "table", "[", "\"header\"", "]", "\n", "header_to_index", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "len", "(", "header", ")", ")", ":", "\n", "\t\t", "header_to_index", "[", "normalized", "(", "header", "[", "i", "]", ")", "]", "=", "i", "\n", "\n", "", "conds", "=", "[", "(", "header_to_index", "[", "normalized", "(", "c", "[", "0", "]", ")", "]", ",", "c", "[", "1", "]", ",", "c", "[", "2", "]", ")", "for", "c", "in", "q", "[", "\"cond\"", "]", "]", "\n", "\n", "filtered_row", "=", "[", "r", "for", "r", "in", "table", "[", "\"content\"", "]", "if", "cond_check", "(", "r", ",", "conds", ")", "]", "\n", "\n", "if", "len", "(", "filtered_row", ")", "==", "0", ":", "\n", "\t\t", "return", "None", "\n", "\n", "", "sel_index", "=", "header_to_index", "[", "normalized", "(", "q", "[", "\"selcol\"", "]", ")", "]", "\n", "\n", "selected_val", "=", "[", "r", "[", "sel_index", "]", "for", "r", "in", "filtered_row", "]", "\n", "\n", "if", "q", "[", "\"aggr\"", "]", "==", "\"select\"", ":", "\n", "\t\t", "return", "selected_val", "[", "0", "]", "\n", "", "elif", "q", "[", "\"aggr\"", "]", "==", "\"count\"", ":", "\n", "\t\t", "return", "len", "(", "selected_val", ")", "\n", "", "elif", "q", "[", "\"aggr\"", "]", "==", "\"avg\"", ":", "\n", "\t\t", "return", "sum", "(", "[", "to_float", "(", "v", ")", "for", "v", "in", "selected_val", "]", ")", "/", "len", "(", "selected_val", ")", "\n", "", "elif", "q", "[", "\"aggr\"", "]", "==", "\"sum\"", ":", "\n", "\t\t", "return", "sum", "(", "[", "to_float", "(", "v", ")", "for", "v", "in", "selected_val", "]", ")", "\n", "", "elif", "q", "[", "\"aggr\"", "]", "==", "\"max\"", ":", "\n", "\t\t", "return", "max", "(", "[", "to_float", "(", "v", ")", "for", "v", "in", "selected_val", "]", ")", "\n", "", "elif", "q", "[", "\"aggr\"", "]", "==", "\"min\"", ":", "\n", "\t\t", "return", "min", "(", "[", "to_float", "(", "v", ")", "for", "v", "in", "selected_val", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.main": [[134, 204], ["execute_dev.load_annotated_tables", "execute_dev.load_queries", "print", "print", "print", "print", "print", "print", "os.path.join", "open", "raw_q1.strip", "raw_q2.strip", "execute_dev.simple_parser", "execute_dev.simple_parser", "execute_dev.execute", "f.write", "f.write", "f.write", "f.write", "execute_dev.execute", "all_wrong_ones.append", "all_wrong_ones.append", "execute_dev.execute"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare.load_annotated_tables", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.load_queries", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.simple_parser", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.simple_parser", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.execute", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.execute", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.execute"], ["", "", "def", "main", "(", ")", ":", "\n", "\n", "\t", "all_wrong_ones", "=", "[", "]", "\n", "\n", "# load tables and queries", "\n", "tables", "=", "load_annotated_tables", "(", "os", ".", "path", ".", "join", "(", "db_folder", ",", "db_file", ")", ")", "\n", "queries", "=", "load_queries", "(", "result_file", ")", "\n", "\n", "lf_equal", "=", "0.", "\n", "ex_equal", "=", "0.", "\n", "total_num", "=", "217.", "\n", "\n", "wrong_a", "=", "0", "\n", "wrong_b", "=", "0", "\n", "wrong_c", "=", "0", "\n", "wrong_d", "=", "0", "\n", "wrong_e", "=", "0", "\n", "\n", "for", "raw_q1", ",", "raw_q2", ",", "h", "in", "queries", ":", "\n", "\t\t", "total_num", "+=", "1", "\n", "\n", "if", "raw_q1", ".", "strip", "(", ")", "==", "raw_q2", ".", "strip", "(", ")", ":", "\n", "\t\t\t", "lf_equal", "+=", "1", "\n", "\n", "# compare execution equivalence", "\n", "", "try", ":", "\n", "\t\t\t", "q1", "=", "simple_parser", "(", "raw_q1", ")", "\n", "q2", "=", "simple_parser", "(", "raw_q2", ")", "\n", "", "except", ":", "\n", "\t\t\t", "wrong_b", "+=", "1", "\n", "continue", "\n", "\n", "", "if", "q1", "[", "\"table\"", "]", "!=", "q2", "[", "\"table\"", "]", ":", "\n", "\t\t\t", "continue", "\n", "\n", "", "table", "=", "tables", "[", "q1", "[", "\"table\"", "]", "]", "\n", "\n", "try", ":", "\n", "\t\t\t", "try", ":", "\n", "\t\t\t\t", "v1", "=", "execute", "(", "table", ",", "q1", ")", "\n", "", "except", ":", "\n", "\t\t\t\t", "wrong_e", "+=", "1", "\n", "v1", "=", "execute", "(", "table", ",", "q1", ")", "\n", "", "if", "v1", "==", "None", ":", "\n", "\t\t\t\t", "wrong_c", "+=", "1", "\n", "", "v2", "=", "execute", "(", "table", ",", "q2", ")", "\n", "if", "v1", "!=", "None", "and", "v1", "==", "v2", ":", "\n", "\t\t\t\t", "ex_equal", "+=", "1", "\n", "", "else", ":", "\n", "\t\t\t\t", "all_wrong_ones", ".", "append", "(", "(", "raw_q1", ",", "raw_q2", ",", "h", ")", ")", "\n", "", "if", "v2", "==", "None", ":", "\n", "\t\t\t\t", "wrong_d", "+=", "1", "\n", "", "", "except", ":", "\n", "\t\t\t", "all_wrong_ones", ".", "append", "(", "(", "raw_q1", ",", "raw_q2", ",", "h", ")", ")", "\n", "wrong_a", "+=", "1", "\n", "\n", "", "", "print", "(", "\"#Q2 (predition) result is wrong: {}\"", ".", "format", "(", "wrong_a", "-", "wrong_e", "+", "wrong_d", ")", ")", "\n", "print", "(", "\"#Q1 or Q2 fail to parse: {}\"", ".", "format", "(", "wrong_b", ")", ")", "\n", "print", "(", "\"#Q1 (ground truth) exec to None: {}\"", ".", "format", "(", "wrong_c", ")", ")", "\n", "print", "(", "\"#Q1 (ground truth) failed to execute: {}\"", ".", "format", "(", "wrong_e", ")", ")", "\n", "\n", "print", "(", "'Logical Form Accuracy: {}'", ".", "format", "(", "lf_equal", "/", "total_num", ")", ")", "\n", "print", "(", "'Execute Accuracy: {}'", ".", "format", "(", "ex_equal", "/", "total_num", ")", ")", "\n", "\n", "with", "open", "(", "\"tmp_wrong_queries.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "\t\t", "for", "p", "in", "all_wrong_ones", ":", "\n", "\t\t\t", "f", ".", "write", "(", "p", "[", "2", "]", ")", "\n", "f", ".", "write", "(", "p", "[", "0", "]", ")", "\n", "f", ".", "write", "(", "p", "[", "1", "]", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.__init__": [[18, 21], ["open"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "log_file", ")", ":", "\n", "        ", "self", ".", "terminal", "=", "sys", ".", "stdout", "\n", "self", ".", "log", "=", "open", "(", "log_file", ",", "\"a\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write": [[22, 25], ["run.Logger.terminal.write", "run.Logger.log.write"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write"], ["", "def", "write", "(", "self", ",", "message", ")", ":", "\n", "        ", "self", ".", "terminal", ".", "write", "(", "message", ")", "\n", "self", ".", "log", ".", "write", "(", "message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.flush": [[26, 31], ["None"], "methods", ["None"], ["", "def", "flush", "(", "self", ")", ":", "\n", "#this flush method is needed for python 3 compatibility.", "\n", "#this handles the flush command by doing nothing.", "\n", "#you might want to specify some extra behavior here.", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.rnn.static_rnn": [[11, 46], ["tensorflow.variable_scope", "len", "range", "tensorflow.shape", "cell.zero_state", "cell", "outs.append", "all_states.append"], "function", ["None"], ["def", "static_rnn", "(", "cell", ",", "inputs", ",", "init_state", "=", "None", ",", "dtype", "=", "tf", ".", "float32", ",", "keep_all_states", "=", "False", ",", "\n", "scope", "=", "None", ")", ":", "\n", "    ", "\"\"\" The basic rnn encoder\n        Args:\n            cell: a RNN cell\n            inputs: inputs to the rnn, of shape [(batch_size, hidden_size)], length equals to rnn length\n            init_state: the inital state of the RNN, if not specified, the init_state would be all zero, of shape cell.state.get_shape()\n        Returns:\n            outs: the list of output emits from the network, of shape [(batch_size, hidden_size)], length equals to rnn length\n            state: the last state of the rnn\n    \"\"\"", "\n", "with", "tf", ".", "variable_scope", "(", "scope", "or", "\"static_rnn\"", ")", "as", "scope", ":", "\n", "\n", "        ", "batch_size", "=", "tf", ".", "shape", "(", "inputs", "[", "0", "]", ")", "[", "0", "]", "\n", "\n", "if", "init_state", "is", "None", ":", "\n", "            ", "init_state", "=", "cell", ".", "zero_state", "(", "batch_size", ",", "dtype", ")", "\n", "\n", "", "step_num", "=", "len", "(", "inputs", ")", "\n", "\n", "outs", "=", "[", "]", "\n", "if", "keep_all_states", ":", "\n", "            ", "all_states", "=", "[", "]", "\n", "\n", "", "state", "=", "init_state", "\n", "for", "i", "in", "range", "(", "step_num", ")", ":", "\n", "            ", "(", "output", ",", "state", ")", "=", "cell", "(", "inputs", "[", "i", "]", ",", "state", ")", "\n", "outs", ".", "append", "(", "output", ")", "\n", "if", "keep_all_states", ":", "\n", "                ", "all_states", ".", "append", "(", "state", ")", "\n", "\n", "", "", "", "if", "keep_all_states", ":", "\n", "        ", "return", "outs", ",", "all_states", "\n", "", "else", ":", "\n", "        ", "return", "outs", ",", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.rnn.dynamic_rnn": [[48, 89], ["tensorflow.variable_scope", "len", "range", "tensorflow.shape", "cell.zero_state", "cell", "isinstance", "tensorflow.where", "outs.append", "rnn.f_apply_lstm_state", "isinstance", "tensorflow.zeros", "all_states.append", "rnn.f_apply_multirnn_lstm_state", "tensorflow.shape", "tensorflow.where", "tensorflow.where"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.rnn.f_apply_lstm_state", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.rnn.f_apply_multirnn_lstm_state"], ["", "", "def", "dynamic_rnn", "(", "cell", ",", "inputs", ",", "masks", ",", "\n", "init_state", "=", "None", ",", "keep_all_states", "=", "False", ",", "\n", "dtype", "=", "tf", ".", "float32", ",", "scope", "=", "None", ")", ":", "\n", "    ", "\"\"\" Dynamic rnn that supports state forwarding when paddings are included in the input \"\"\"", "\n", "with", "tf", ".", "variable_scope", "(", "scope", "or", "\"dynamic_rnn\"", ")", "as", "scope", ":", "\n", "\n", "        ", "batch_size", "=", "tf", ".", "shape", "(", "inputs", "[", "0", "]", ")", "[", "0", "]", "\n", "\n", "if", "init_state", "is", "None", ":", "\n", "            ", "init_state", "=", "cell", ".", "zero_state", "(", "batch_size", ",", "dtype", ")", "\n", "\n", "", "step_num", "=", "len", "(", "inputs", ")", "\n", "\n", "outs", "=", "[", "]", "\n", "\n", "if", "keep_all_states", ":", "\n", "            ", "all_states", "=", "[", "]", "\n", "\n", "", "state", "=", "init_state", "\n", "for", "i", "in", "range", "(", "step_num", ")", ":", "\n", "\n", "            ", "(", "output", ",", "new_state", ")", "=", "cell", "(", "inputs", "[", "i", "]", ",", "state", ")", "\n", "\n", "# copy through the old state the current input is a padding token", "\n", "if", "isinstance", "(", "cell", ",", "tf", ".", "contrib", ".", "rnn", ".", "LSTMCell", ")", ":", "\n", "                ", "state", "=", "f_apply_lstm_state", "(", "new_state", ",", "state", ",", "lambda", "s1", ",", "s2", ":", "tf", ".", "where", "(", "masks", "[", "i", "]", ",", "s1", ",", "s2", ")", ")", "\n", "", "elif", "isinstance", "(", "cell", ",", "tf", ".", "contrib", ".", "rnn", ".", "MultiRNNCell", ")", ":", "\n", "                ", "state", "=", "f_apply_multirnn_lstm_state", "(", "new_state", ",", "state", ",", "lambda", "s1", ",", "s2", ":", "tf", ".", "where", "(", "masks", "[", "i", "]", ",", "s1", ",", "s2", ")", ")", "\n", "\n", "# emit zero output is the current token is ", "\n", "", "output", "=", "tf", ".", "where", "(", "masks", "[", "i", "]", ",", "output", ",", "tf", ".", "zeros", "(", "tf", ".", "shape", "(", "output", ")", ",", "dtype", ")", ")", "\n", "\n", "outs", ".", "append", "(", "output", ")", "\n", "\n", "if", "keep_all_states", ":", "\n", "                ", "all_states", ".", "append", "(", "state", ")", "\n", "\n", "", "", "", "if", "keep_all_states", ":", "\n", "        ", "return", "outs", ",", "all_states", "\n", "", "else", ":", "\n", "        ", "return", "outs", ",", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.rnn.bidirectional_dynamic_rnn": [[91, 125], ["tensorflow.concat", "tensorflow.variable_scope", "tensorflow.variable_scope", "rnn.dynamic_rnn", "tensorflow.variable_scope", "rnn.dynamic_rnn"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.rnn.dynamic_rnn", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.rnn.dynamic_rnn"], ["", "", "def", "bidirectional_dynamic_rnn", "(", "fw_cell", ",", "bw_cell", ",", "inputs", ",", "masks", ",", "\n", "init_fw_state", "=", "None", ",", "keep_all_states", "=", "False", ",", "\n", "dtype", "=", "tf", ".", "float32", ",", "scope", "=", "None", ")", ":", "\n", "    ", "\"\"\" The bidirectional rnn\n        Args:\n            fw_cell: a RNN cell\n            bw_cell: another RNN cell for the backward pass\n            inputs: inputs to the rnn, of shape [(batch_size, hidden_size)], length equals to rnn length\n            init_state: the inital state of the RNN, if not specified, the init_state would be all zero, of shape cell.state.get_shape()\n        Returns:\n            outs: the list of output emits from the network, of shape [(batch_size, hidden_size * 2)], length equals to rnn length\n            fw_state: the last state of the fw rnn\n            bw_state: the last state of the backward rnn\n    \"\"\"", "\n", "with", "tf", ".", "variable_scope", "(", "scope", "or", "\"bidirectional_rnn_encoder\"", ")", ":", "\n", "\n", "        ", "with", "tf", ".", "variable_scope", "(", "\"fw\"", ")", "as", "fw_scope", ":", "\n", "            ", "fw_outs", ",", "fw_state", "=", "dynamic_rnn", "(", "fw_cell", ",", "inputs", ",", "masks", ",", "\n", "init_state", "=", "init_fw_state", ",", "keep_all_states", "=", "keep_all_states", ",", "\n", "dtype", "=", "dtype", ",", "scope", "=", "fw_scope", ")", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "\"bw\"", ")", "as", "bw_scope", ":", "\n", "# reverse the input to the backward encoder", "\n", "            ", "reversed_inputs", "=", "inputs", "[", ":", ":", "-", "1", "]", "\n", "reversed_masks", "=", "masks", "[", ":", ":", "-", "1", "]", "\n", "init_bw_state", "=", "fw_state", "if", "not", "keep_all_states", "else", "fw_state", "[", "-", "1", "]", "\n", "bw_outs", ",", "bw_state", "=", "dynamic_rnn", "(", "bw_cell", ",", "reversed_inputs", ",", "reversed_masks", ",", "\n", "init_state", "=", "init_bw_state", ",", "keep_all_states", "=", "keep_all_states", ",", "\n", "dtype", "=", "dtype", ",", "scope", "=", "bw_scope", ")", "\n", "\n", "", "", "reversed_bw_outs", "=", "bw_outs", "[", ":", ":", "-", "1", "]", "\n", "outs", "=", "tf", ".", "concat", "(", "[", "fw_outs", ",", "reversed_bw_outs", "]", ",", "-", "1", ")", "\n", "\n", "return", "outs", ",", "fw_state", ",", "bw_state", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.rnn.bidirectional_static_rnn": [[127, 163], ["tensorflow.concat", "tensorflow.variable_scope", "tensorflow.variable_scope", "rnn.static_rnn", "tensorflow.variable_scope", "rnn.static_rnn"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.rnn.static_rnn", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.rnn.static_rnn"], ["", "def", "bidirectional_static_rnn", "(", "fw_cell", ",", "bw_cell", ",", "inputs", ",", "masks", ",", "\n", "init_fw_state", "=", "None", ",", "keep_all_states", "=", "False", ",", "\n", "dtype", "=", "tf", ".", "float32", ",", "scope", "=", "None", ")", ":", "\n", "    ", "\"\"\" The bidirectional rnn\n        Args:\n            fw_cell: a RNN cell\n            bw_cell: another RNN cell for the backward pass\n            inputs: inputs to the rnn, of shape [(batch_size, hidden_size)], length equals to rnn length\n            init_state: the inital state of the RNN, if not specified, the init_state would be all zero, of shape cell.state.get_shape()\n        Returns:\n            outs: the list of output emits from the network, of shape [(batch_size, hidden_size * 2)], length equals to rnn length\n            fw_state: the last state of the fw rnn\n            bw_state: the last state of the backward rnn\n    \"\"\"", "\n", "with", "tf", ".", "variable_scope", "(", "scope", "or", "\"bidirectional_rnn_encoder\"", ")", ":", "\n", "\n", "        ", "with", "tf", ".", "variable_scope", "(", "\"fw\"", ")", "as", "fw_scope", ":", "\n", "            ", "fw_outs", ",", "fw_state", "=", "static_rnn", "(", "fw_cell", ",", "inputs", ",", "\n", "init_state", "=", "init_fw_state", ",", "\n", "dtype", "=", "dtype", ",", "scope", "=", "fw_scope", ",", "\n", "keep_all_states", "=", "keep_all_states", ")", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "\"bw\"", ")", "as", "bw_scope", ":", "\n", "# reverse the input to the backward encoder", "\n", "            ", "reversed_inputs", "=", "inputs", "[", ":", ":", "-", "1", "]", "\n", "reversed_masks", "=", "masks", "[", ":", ":", "-", "1", "]", "\n", "init_bw_state", "=", "fw_state", "if", "not", "keep_all_states", "else", "fw_state", "[", "-", "1", "]", "\n", "bw_outs", ",", "bw_state", "=", "static_rnn", "(", "bw_cell", ",", "reversed_inputs", ",", "\n", "init_state", "=", "init_bw_state", ",", "\n", "dtype", "=", "dtype", ",", "scope", "=", "bw_scope", ",", "\n", "keep_all_states", "=", "keep_all_states", ")", "\n", "\n", "", "", "reversed_bw_outs", "=", "bw_outs", "[", ":", ":", "-", "1", "]", "\n", "outs", "=", "tf", ".", "concat", "(", "[", "fw_outs", ",", "reversed_bw_outs", "]", ",", "-", "1", ")", "\n", "\n", "return", "outs", ",", "fw_state", ",", "bw_state", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.rnn.f_apply_multirnn_lstm_state": [[165, 180], ["range", "tuple", "len", "new_state.append", "rnn.f_apply_lstm_state"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.rnn.f_apply_lstm_state"], ["", "def", "f_apply_multirnn_lstm_state", "(", "state1", ",", "state2", ",", "f", ")", ":", "\n", "    ", "\"\"\" Given two multirnn lstm states, merge them into a new state of the same shape, merged by concatation and then projection\n        Args:\n            state1: the first state to mergem, of shape (s1, s2, s3, ...), \n                    each s is of shape LSTMStateTuple(c,h), h,c are of shape (batch_size, hidden_size)\n            state2: the second state to merge, shape same as the first\n            w: the projection weight, of shape (hidden_size * 2, hidden_size)\n            b: the projection bias, of shape (hidden_size,)\n        Returns:\n            the merged states\n    \"\"\"", "\n", "new_state", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "state1", ")", ")", ":", "\n", "        ", "new_state", ".", "append", "(", "f_apply_lstm_state", "(", "state1", "[", "i", "]", ",", "state2", "[", "i", "]", ",", "f", ")", ")", "\n", "", "return", "tuple", "(", "new_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.rnn.f_apply_lstm_state": [[182, 192], ["tensorflow.python.ops.rnn_cell_impl.LSTMStateTuple", "f", "f"], "function", ["None"], ["", "def", "f_apply_lstm_state", "(", "state1", ",", "state2", ",", "f", ")", ":", "\n", "    ", "\"\"\" merge two lstm states into one of the same shape as either or them, merged by concatation and then projection\n        Args:\n            state1, state2: two states to be merged, of shape LSTMStateTuple(c,h), h,c are of shape (batch_size, hidden_size)\n            w: the projection weight, of shape (hidden_size * 2, hidden_size)\n            b: the projection bias, of shape (hidden_size,)\n        Returns:\n            the merged state, of shape (batch_size, hidden_size)\n    \"\"\"", "\n", "return", "rnn_cell_impl", ".", "LSTMStateTuple", "(", "f", "(", "state1", ".", "c", ",", "state2", ".", "c", ")", ",", "f", "(", "state1", ".", "h", ",", "state2", ".", "h", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.rnn.merge_multirnn_lstm_state": [[194, 209], ["range", "tuple", "len", "new_state.append", "rnn.merge_lstm_states"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.rnn.merge_lstm_states"], ["", "def", "merge_multirnn_lstm_state", "(", "states", ",", "w", ",", "b", ")", ":", "\n", "    ", "\"\"\" Given two multirnn lstm states, merge them into a new state of the same shape, merged by concatation and then projection\n        Args:\n            state1: the first state to mergem, of shape (s1, s2, s3, ...), \n                    each s is of shape LSTMStateTuple(c,h), h,c are of shape (batch_size, hidden_size)\n            state2: the second state to merge, shape same as the first\n            w: the projection weight, of shape (hidden_size * 2, hidden_size)\n            b: the projection bias, of shape (hidden_size,)\n        Returns:\n            the merged states\n    \"\"\"", "\n", "new_state", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "states", "[", "0", "]", ")", ")", ":", "\n", "        ", "new_state", ".", "append", "(", "merge_lstm_states", "(", "[", "s", "[", "i", "]", "for", "s", "in", "states", "]", ",", "w", ",", "b", ")", ")", "\n", "", "return", "tuple", "(", "new_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.rnn.merge_lstm_states": [[211, 223], ["tensorflow.add", "tensorflow.add", "tensorflow.python.ops.rnn_cell_impl.LSTMStateTuple", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.concat", "tensorflow.concat"], "function", ["None"], ["", "def", "merge_lstm_states", "(", "states", ",", "w", ",", "b", ")", ":", "\n", "    ", "\"\"\" merge two lstm states into one of the same shape as either or them, merged by concatation and then projection\n        Args:\n            state1, state2: two states to be merged, of shape LSTMStateTuple(c,h), h,c are of shape (batch_size, hidden_size)\n            w: the projection weight, of shape (hidden_size * k, hidden_size)\n            b: the projection bias, of shape (hidden_size,)\n        Returns:\n            the merged state, of shape (batch_size, hidden_size)\n    \"\"\"", "\n", "new_c", "=", "tf", ".", "add", "(", "tf", ".", "matmul", "(", "tf", ".", "concat", "(", "[", "x", ".", "c", "for", "x", "in", "states", "]", ",", "-", "1", ")", ",", "w", ")", ",", "b", ")", "\n", "new_h", "=", "tf", ".", "add", "(", "tf", ".", "matmul", "(", "tf", ".", "concat", "(", "[", "x", ".", "h", "for", "x", "in", "states", "]", ",", "-", "1", ")", ",", "w", ")", ",", "b", ")", "\n", "return", "rnn_cell_impl", ".", "LSTMStateTuple", "(", "new_c", ",", "new_h", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.learn.train_model": [[13, 163], ["os.path.join", "graph.as_default", "tensorflow.train.Saver", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "tensorflow.placeholder", "tensorflow.train.AdagradOptimizer", "tf.train.AdagradOptimizer.compute_gradients", "zip", "tf.train.AdagradOptimizer.apply_gradients", "print", "tensorflow.clip_by_global_norm", "zip", "print", "zip", "tensorflow.Session", "session.as_default", "session.run", "int", "range", "tensorflow.pow", "open", "open.write", "open.write", "tensorflow.global_variables_initializer", "numpy.ceil", "print", "print", "range", "print", "print", "print", "grads_tmp.append", "grads_tmp.append", "min", "session.run", "tr_token_accuracies.append", "tr_sentence_accuracies.append", "tr_losses.append", "learn.test_model", "open.write", "open.write", "numpy.mean", "tensorflow.to_float", "len", "float", "len", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "tf.train.Saver.save", "tensorflow.sqrt", "tensorflow.random_normal", "os.path.join", "tensorflow.shape"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.learn_meta.test_model", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float"], ["def", "train_model", "(", "graph", ",", "var_dict", ",", "train_data", ",", "max_epoch", ",", "hyper_param", ",", "\n", "output_dir", ",", "test_data", "=", "None", ",", "ex_printer", "=", "None", ",", "session", "=", "None", ")", ":", "\n", "    ", "\"\"\" train a model with provided data \"\"\"", "\n", "learning_rate", "=", "hyper_param", "[", "\"learning_rate\"", "]", "\n", "batch_size", "=", "hyper_param", "[", "\"batch_size\"", "]", "\n", "log_file", "=", "os", ".", "path", ".", "join", "(", "output_dir", ",", "\"train.log\"", ")", "if", "output_dir", "is", "not", "None", "else", "None", "\n", "\n", "with", "graph", ".", "as_default", "(", ")", ":", "\n", "# the saver to keep model", "\n", "        ", "saver", "=", "tf", ".", "train", ".", "Saver", "(", ")", "\n", "last_best_accuracy", "=", "0.", "\n", "\n", "# place holders for the model", "\n", "train_inputs", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_inputs\"", "]", ")", "\n", "train_outputs", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_outputs\"", "]", ")", "\n", "\n", "seq2seq_feed_previous", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"seq2seq_feed_previous\"", "]", ")", "\n", "input_mask", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_input_mask\"", "]", ")", "\n", "output_mask", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_output_mask\"", "]", ")", "\n", "type_masks", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"type_masks\"", "]", ")", "\n", "\n", "# operaters needed for testing", "\n", "token_accuracy", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"token_accuracy\"", "]", ")", "\n", "sentence_accuracy", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"sentence_accuracy\"", "]", ")", "\n", "total_loss", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"total_loss\"", "]", ")", "\n", "\n", "global_step", "=", "tf", ".", "placeholder", "(", "tf", ".", "int32", ",", "name", "=", "\"global_step\"", ")", "\n", "\n", "optimizer", "=", "tf", ".", "train", ".", "AdagradOptimizer", "(", "learning_rate", "=", "learning_rate", ")", "\n", "\n", "# gradient processing", "\n", "grad_clip_norm", "=", "hyper_param", "[", "\"gradient_clip_norm\"", "]", "if", "\"gradient_clip_norm\"", "in", "hyper_param", "else", "None", "\n", "grad_noise", "=", "hyper_param", "[", "\"gradient_noise\"", "]", "if", "\"gradient_noise\"", "in", "hyper_param", "else", "None", "\n", "grad_noise_gamma", "=", "hyper_param", "[", "\"gradient_noise_gamma\"", "]", "if", "\"gradient_noise_gamma\"", "in", "hyper_param", "else", "None", "\n", "\n", "grads_and_vars", "=", "optimizer", ".", "compute_gradients", "(", "total_loss", ")", "\n", "(", "grads", ",", "variables", ")", "=", "zip", "(", "*", "grads_and_vars", ")", "\n", "\n", "if", "grad_clip_norm", ":", "\n", "            ", "print", "(", "\"clipping norm: {}\"", ".", "format", "(", "grad_clip_norm", ")", ")", "\n", "capped_grads", ",", "_", "=", "tf", ".", "clip_by_global_norm", "(", "grads", ",", "grad_clip_norm", ")", "\n", "grads_and_vars", "=", "zip", "(", "capped_grads", ",", "variables", ")", "\n", "\n", "", "if", "grad_noise", ":", "\n", "            ", "if", "grad_noise_gamma", ":", "\n", "                ", "grad_noise", "/=", "tf", ".", "pow", "(", "1.0", "+", "tf", ".", "to_float", "(", "global_step", ")", ",", "grad_noise_gamma", ")", "\n", "", "grads_tmp", "=", "[", "]", "\n", "for", "g", "in", "grads", ":", "\n", "                ", "if", "g", "is", "not", "None", ":", "\n", "                    ", "noisy_grad", "=", "g", "+", "tf", ".", "sqrt", "(", "grad_noise", ")", "*", "tf", ".", "random_normal", "(", "tf", ".", "shape", "(", "g", ")", ")", "\n", "grads_tmp", ".", "append", "(", "noisy_grad", ")", "\n", "", "else", ":", "\n", "                    ", "grads_tmp", ".", "append", "(", "g", ")", "\n", "", "", "print", "(", "\"noise added\"", ")", "\n", "grads_and_vars", "=", "zip", "(", "grads_tmp", ",", "variables", ")", "\n", "\n", "", "train_step", "=", "optimizer", ".", "apply_gradients", "(", "grads_and_vars", ")", "\n", "\n", "session", "=", "tf", ".", "Session", "(", ")", "if", "session", "is", "None", "else", "session", "\n", "\n", "with", "session", ".", "as_default", "(", ")", ":", "\n", "            ", "if", "log_file", "is", "not", "None", ":", "\n", "# initialize the logfile", "\n", "                ", "output_log", "=", "open", "(", "log_file", ",", "\"w\"", ")", "\n", "log_header", "=", "\"tr_tok_acc, test_tok_acc, tr_sen_acc, test_sen_acc, tr_loss, test_loss\"", "\n", "if", "test_data", "is", "None", ":", "\n", "                    ", "log_header", "=", "\"tr_tok_acc, tr_sen_acc, tr_loss\"", "\n", "", "output_log", ".", "write", "(", "log_header", ")", "\n", "output_log", ".", "write", "(", "\"\\n\"", ")", "\n", "\n", "", "session", ".", "run", "(", "tf", ".", "global_variables_initializer", "(", ")", ")", "\n", "\n", "nbatches", "=", "int", "(", "np", ".", "ceil", "(", "len", "(", "train_data", ".", "Xs", ")", "/", "float", "(", "batch_size", ")", ")", ")", "\n", "\n", "for", "n", "in", "range", "(", "max_epoch", ")", ":", "\n", "                ", "print", "(", "\"================ epoch %d ==================\"", "%", "n", ")", "\n", "print", "(", "\"PROGRESS: 00.00%\"", ")", "\n", "\n", "tr_token_accuracies", "=", "[", "]", "\n", "tr_sentence_accuracies", "=", "[", "]", "\n", "tr_losses", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "nbatches", ")", ":", "\n", "\n", "                    ", "left", "=", "i", "*", "batch_size", "\n", "right", "=", "min", "(", "(", "i", "+", "1", ")", "*", "batch_size", ",", "len", "(", "train_data", ".", "Xs", ")", ")", "\n", "\n", "Xt", "=", "train_data", ".", "Xs", "[", "left", ":", "right", "]", "\n", "Yt", "=", "train_data", ".", "Ys", "[", "left", ":", "right", "]", "\n", "XMasks", "=", "train_data", ".", "XMasks", "[", "left", ":", "right", "]", "\n", "YMasks", "=", "train_data", ".", "YMasks", "[", "left", ":", "right", "]", "\n", "ty_masks", "=", "train_data", ".", "type_masks", "[", ":", ",", "left", ":", "right", ",", ":", "]", "\n", "\n", "#### HERE feed prvious set to true to make it work #####", "\n", "training_result", "=", "session", ".", "run", "(", "[", "token_accuracy", ",", "\n", "sentence_accuracy", ",", "\n", "total_loss", ",", "\n", "train_step", "]", ",", "\n", "feed_dict", "=", "{", "train_inputs", ":", "Xt", ",", "train_outputs", ":", "Yt", ",", "\n", "input_mask", ":", "XMasks", ",", "output_mask", ":", "YMasks", ",", "\n", "type_masks", ":", "ty_masks", ",", "\n", "seq2seq_feed_previous", ":", "False", ",", "\n", "global_step", ":", "n", "}", ")", "\n", "\n", "tr_token_accuracies", ".", "append", "(", "training_result", "[", "0", "]", ")", "\n", "tr_sentence_accuracies", ".", "append", "(", "training_result", "[", "1", "]", ")", "\n", "tr_losses", ".", "append", "(", "training_result", "[", "2", "]", ")", "\n", "\n", "", "print", "(", "\"training_loss = {:.5f}\"", ".", "format", "(", "np", ".", "mean", "(", "tr_losses", ")", ")", ")", "\n", "print", "(", "\"train_token_accuracy = {:.5f}\"", ".", "format", "(", "np", ".", "mean", "(", "tr_token_accuracies", ")", ")", ")", "\n", "print", "(", "\"train_sentence_accuracy = {:.5f}\"", ".", "format", "(", "np", ".", "mean", "(", "tr_sentence_accuracies", ")", ")", ")", "\n", "\n", "if", "test_data", "is", "not", "None", ":", "\n", "                    ", "test_result", "=", "test_model", "(", "graph", ",", "var_dict", ",", "session", ",", "test_data", ",", "batch_size", ",", "\n", "ex_printer", "=", "ex_printer", "if", "(", "n", "%", "30", "==", "0", "or", "n", "==", "max_epoch", "-", "1", ")", "else", "None", ")", "\n", "\n", "test_token_accuracy", "=", "test_result", "[", "0", "]", "\n", "test_sentence_accuracy", "=", "test_result", "[", "1", "]", "\n", "test_loss", "=", "test_result", "[", "2", "]", "\n", "\n", "log_str", "=", "\"{}, {}, {}, {}, {}, {}\"", ".", "format", "(", "\n", "np", ".", "mean", "(", "tr_token_accuracies", ")", ",", "test_token_accuracy", ",", "\n", "np", ".", "mean", "(", "tr_sentence_accuracies", ")", ",", "test_sentence_accuracy", ",", "\n", "np", ".", "mean", "(", "tr_losses", ")", ",", "test_loss", ")", "\n", "", "else", ":", "\n", "                    ", "log_str", "=", "\"{}, {}, {}\"", ".", "format", "(", "np", ".", "mean", "(", "tr_token_accuracies", ")", ",", "\n", "np", ".", "mean", "(", "tr_sentence_accuracies", ")", ",", "\n", "np", ".", "mean", "(", "tr_losses", ")", ")", "\n", "\n", "\n", "", "if", "output_dir", ":", "\n", "                    ", "if", "test_data", "is", "not", "None", ":", "\n", "                        ", "current_seq_acc", "=", "test_sentence_accuracy", "\n", "", "else", ":", "\n", "                        ", "current_seq_acc", "=", "np", ".", "mean", "(", "tr_sentence_accuracies", ")", "\n", "\n", "", "if", "current_seq_acc", ">", "last_best_accuracy", ":", "\n", "                        ", "last_best_accuracy", "=", "current_seq_acc", "\n", "# add global step so that we can keep multiple models around", "\n", "saver", ".", "save", "(", "session", ",", "os", ".", "path", ".", "join", "(", "output_dir", ",", "\"table_nl_prog\"", ")", ",", "global_step", "=", "n", ")", "\n", "\n", "", "", "if", "log_file", "is", "not", "None", ":", "\n", "# write corresponding data to log", "\n", "                    ", "output_log", ".", "write", "(", "log_str", ")", "\n", "output_log", ".", "write", "(", "\"\\n\"", ")", "\n", "\n", "", "if", "np", ".", "mean", "(", "tr_losses", ")", "<", "0.05", ":", "\n", "                    ", "break", "\n", "\n", "", "", "", "", "return", "session", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.learn.test_model": [[165, 267], ["graph.as_default", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "numpy.mean", "numpy.mean", "numpy.mean", "session.as_default", "print", "int", "range", "numpy.ceil", "open", "min", "print", "print", "print", "print", "print", "print", "len", "session.run", "test_tok_acc.append", "test_seq_acc.append", "test_loss.append", "session.run", "ex_printer.print", "ex_printer.print", "len", "float", "ex_printer.print", "ex_printer.print", "open.write", "open.write", "open.write", "open.write", "open.write", "open.write", "open.write", "numpy.mean", "numpy.mean", "numpy.mean", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write"], ["", "def", "test_model", "(", "graph", ",", "var_dict", ",", "session", ",", "test_data", ",", "batch_size", ",", "ex_printer", "=", "None", ",", "log_file", "=", "None", ")", ":", "\n", "    ", "with", "graph", ".", "as_default", "(", ")", ":", "\n", "# place holders for the model", "\n", "        ", "train_inputs", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_inputs\"", "]", ")", "\n", "train_outputs", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_outputs\"", "]", ")", "\n", "\n", "seq2seq_feed_previous", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"seq2seq_feed_previous\"", "]", ")", "\n", "input_mask", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_input_mask\"", "]", ")", "\n", "output_mask", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_output_mask\"", "]", ")", "\n", "type_masks", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"type_masks\"", "]", ")", "\n", "\n", "# operaters needed for testing", "\n", "token_accuracy", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"token_accuracy\"", "]", ")", "\n", "sentence_accuracy", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"sentence_accuracy\"", "]", ")", "\n", "total_loss", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"total_loss\"", "]", ")", "\n", "predicted_labels", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"predicted_labels\"", "]", ")", "\n", "\n", "with", "session", ".", "as_default", "(", ")", ":", "\n", "            ", "print", "(", "\"PROGRESS: 00.00%\"", ")", "\n", "# adding this so that we can include the last one as well", "\n", "nbatches", "=", "int", "(", "np", ".", "ceil", "(", "len", "(", "test_data", ".", "Xs", ")", "/", "float", "(", "batch_size", ")", ")", ")", "\n", "\n", "test_tok_acc", "=", "[", "]", "\n", "test_seq_acc", "=", "[", "]", "\n", "test_loss", "=", "[", "]", "\n", "\n", "if", "log_file", "is", "not", "None", ":", "\n", "# initialize the logfile", "\n", "                ", "pred_log_f", "=", "open", "(", "log_file", ",", "\"w\"", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "nbatches", ")", ":", "\n", "                ", "left", "=", "i", "*", "batch_size", "\n", "right", "=", "min", "(", "(", "i", "+", "1", ")", "*", "batch_size", ",", "len", "(", "test_data", ".", "Xs", ")", ")", "\n", "\n", "Xtest", "=", "test_data", ".", "Xs", "[", "left", ":", "right", "]", "\n", "XMasks", "=", "test_data", ".", "XMasks", "[", "left", ":", "right", "]", "\n", "\n", "ty_masks", "=", "test_data", ".", "type_masks", "[", ":", ",", "left", ":", "right", ",", ":", "]", "\n", "\n", "# in some cases we don't have the access to the test data", "\n", "if", "test_data", ".", "Ys", "is", "not", "None", "and", "test_data", ".", "YMasks", "is", "not", "None", ":", "\n", "\n", "                    ", "Ytest", "=", "test_data", ".", "Ys", "[", "left", ":", "right", "]", "\n", "YMasks", "=", "test_data", ".", "YMasks", "[", "left", ":", "right", "]", "\n", "\n", "#### HERE feed prvious set to true to make it work #####", "\n", "result", "=", "session", ".", "run", "(", "[", "token_accuracy", ",", "\n", "sentence_accuracy", ",", "\n", "total_loss", ",", "\n", "predicted_labels", "]", ",", "\n", "feed_dict", "=", "{", "train_inputs", ":", "Xtest", ",", "\n", "train_outputs", ":", "Ytest", ",", "\n", "input_mask", ":", "XMasks", ",", "\n", "output_mask", ":", "YMasks", ",", "\n", "type_masks", ":", "ty_masks", ",", "\n", "seq2seq_feed_previous", ":", "True", "}", ")", "\n", "\n", "test_tok_acc", ".", "append", "(", "result", "[", "0", "]", ")", "\n", "test_seq_acc", ".", "append", "(", "result", "[", "1", "]", ")", "\n", "test_loss", ".", "append", "(", "result", "[", "2", "]", ")", "\n", "predictions", "=", "result", "[", "3", "]", "\n", "\n", "", "else", ":", "\n", "                    ", "result", "=", "session", ".", "run", "(", "[", "predicted_labels", "]", ",", "\n", "feed_dict", "=", "{", "train_inputs", ":", "Xtest", ",", "\n", "input_mask", ":", "XMasks", ",", "\n", "type_masks", ":", "ty_masks", ",", "\n", "seq2seq_feed_previous", ":", "True", "}", ")", "\n", "predictions", "=", "result", "[", "0", "]", "\n", "\n", "\n", "", "if", "ex_printer", "is", "not", "None", "and", "log_file", "is", "not", "None", ":", "\n", "\n", "                    ", "if", "test_data", ".", "Ys", "is", "not", "None", ":", "\n", "                        ", "outs", "=", "ex_printer", ".", "print", "(", "Xtest", ",", "Ytest", ",", "predictions", ",", "k", "=", "999999", ")", "\n", "", "else", ":", "\n", "                        ", "outs", "=", "ex_printer", ".", "print", "(", "Xtest", ",", "None", ",", "predictions", ",", "k", "=", "999999", ")", "\n", "\n", "", "for", "e", "in", "outs", ":", "\n", "                        ", "pred_log_f", ".", "write", "(", "str", "(", "e", "[", "0", "]", ")", ")", "\n", "pred_log_f", ".", "write", "(", "\"\\n\"", ")", "\n", "pred_log_f", ".", "write", "(", "str", "(", "e", "[", "1", "]", ")", ")", "\n", "pred_log_f", ".", "write", "(", "\"\\n\"", ")", "\n", "pred_log_f", ".", "write", "(", "str", "(", "e", "[", "2", "]", ")", ")", "\n", "pred_log_f", ".", "write", "(", "\"\\n\"", ")", "\n", "pred_log_f", ".", "write", "(", "\"\\n\"", ")", "\n", "\n", "", "", "", "if", "test_loss", ":", "\n", "                ", "print", "(", "\"test_loss = {:.5f}\"", ".", "format", "(", "np", ".", "mean", "(", "test_loss", ")", ")", ")", "\n", "print", "(", "\"test_token_accuracy = {:.5f}\"", ".", "format", "(", "np", ".", "mean", "(", "test_tok_acc", ")", ")", ")", "\n", "print", "(", "\"test_sentence_accuracy = {:.5f}\"", ".", "format", "(", "np", ".", "mean", "(", "test_seq_acc", ")", ")", ")", "\n", "\n", "", "if", "ex_printer", "is", "not", "None", ":", "\n", "                ", "print", "(", "\"\"", ")", "\n", "print", "(", "\"[[Test Examples]]\"", ")", "\n", "if", "test_data", ".", "Ys", "is", "not", "None", ":", "\n", "                    ", "outs", "=", "ex_printer", ".", "print", "(", "Xtest", ",", "Ytest", ",", "predictions", ",", "k", "=", "5", ")", "\n", "", "else", ":", "\n", "                    ", "outs", "=", "ex_printer", ".", "print", "(", "Xtest", ",", "None", ",", "predictions", ",", "k", "=", "5", ")", "\n", "", "print", "(", "\"\"", ")", "\n", "\n", "", "", "", "return", "np", ".", "mean", "(", "test_tok_acc", ")", ",", "np", ".", "mean", "(", "test_seq_acc", ")", ",", "np", ".", "mean", "(", "test_loss", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.learn.load_model": [[270, 287], ["os.path.dirname", "os.path.basename", "print", "tensorflow.Session", "tensorflow.train.import_meta_graph", "tensorflow.get_default_graph", "print", "tf.train.import_meta_graph.restore", "print", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print"], ["", "def", "load_model", "(", "model_file", ")", ":", "\n", "    ", "model_dir", "=", "os", ".", "path", ".", "dirname", "(", "model_file", ")", "\n", "model_name", "=", "os", ".", "path", ".", "basename", "(", "model_file", ")", "\n", "\n", "print", "(", "\"[OK] Start loading graph from {} ...\"", ".", "format", "(", "model_file", ")", ")", "\n", "\n", "session", "=", "tf", ".", "Session", "(", ")", "\n", "saver", "=", "tf", ".", "train", ".", "import_meta_graph", "(", "os", ".", "path", ".", "join", "(", "model_dir", ",", "model_name", "+", "\".meta\"", ")", ")", "\n", "graph", "=", "tf", ".", "get_default_graph", "(", ")", "\n", "\n", "print", "(", "\"[OK] Successfully load the graph.\"", ")", "\n", "\n", "saver", ".", "restore", "(", "session", ",", "os", ".", "path", ".", "join", "(", "model_dir", ",", "model_name", ")", ")", "\n", "\n", "print", "(", "\"[OK] Successfully load variable weights.\"", ")", "\n", "\n", "return", "graph", ",", "session", "\n", "", ""]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net.DecoderType.__init__": [[102, 108], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "ty", ",", "mask_name", "=", "None", ",", "mask_fn", "=", "None", ")", ":", "\n", "        ", "\"\"\" Create a decoder type object, dec_ty defines whether to point or project, \n            type defines which parts of attention states should be ignored (in decoding phase)\"\"\"", "\n", "self", ".", "ty", "=", "ty", "\n", "self", ".", "mask_name", "=", "mask_name", "\n", "self", ".", "mask_fn", "=", "mask_fn", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net.DecoderType.__str__": [[109, 111], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "\"{}:{}\"", ".", "format", "(", "self", ".", "ty", ",", "self", ".", "mask_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net.DecoderType.from_regex": [[112, 139], ["len", "pointer_net.DecoderType", "pointer_net.DecoderType", "len", "result.append"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "from_regex", "(", "s", ",", "abbrv_dict", "=", "None", ",", "maxlen", "=", "1000", ")", ":", "\n", "        ", "if", "abbrv_dict", "is", "None", ":", "\n", "            ", "abbrv_dict", "=", "{", "\n", "\"w\"", ":", "DecoderType", "(", "DecoderType", ".", "Projector", ")", ",", "\n", "\"p\"", ":", "DecoderType", "(", "DecoderType", ".", "Pointer", ")", "\n", "}", "\n", "\n", "", "result", "=", "[", "]", "\n", "i", "=", "0", "\n", "lb", "=", "-", "1", "\n", "\n", "while", "len", "(", "result", ")", "<", "maxlen", ":", "\n", "            ", "if", "i", "==", "len", "(", "s", ")", ":", "\n", "                ", "break", "\n", "", "if", "s", "[", "i", "]", "==", "\"(\"", ":", "\n", "                ", "lb", "=", "i", "\n", "", "elif", "s", "[", "i", "]", "==", "\")\"", ":", "\n", "                ", "pass", "\n", "", "elif", "s", "[", "i", "]", "==", "\"*\"", ":", "\n", "                ", "i", "=", "lb", "\n", "", "else", ":", "\n", "# it is supposed to be a symbol in the decoder", "\n", "                ", "result", ".", "append", "(", "abbrv_dict", "[", "s", "[", "i", "]", "]", ")", "\n", "", "i", "+=", "1", "\n", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net.__linear": [[30, 92], ["tensorflow.python.ops.variable_scope.get_variable_scope", "ValueError", "tensorflow.python.util.nest.is_sequence", "a.get_shape", "tensorflow.python.ops.variable_scope.variable_scope", "tensorflow.python.ops.nn_ops.bias_add", "tensorflow.python.util.nest.is_sequence", "ValueError", "ValueError", "tensorflow.python.ops.variable_scope.get_variable", "len", "tensorflow.python.ops.math_ops.matmul", "tensorflow.python.ops.math_ops.matmul", "tensorflow.python.ops.variable_scope.variable_scope", "inner_scope.set_partitioner", "tensorflow.python.ops.array_ops.concat", "tensorflow.python.ops.init_ops.constant_initializer", "tensorflow.python.ops.variable_scope.get_variable"], "function", ["None"], ["def", "__linear", "(", "args", ",", "\n", "output_size", ",", "\n", "bias", ",", "\n", "bias_initializer", "=", "None", ",", "\n", "kernel_initializer", "=", "None", ",", "weights", "=", "None", ",", "biases", "=", "None", ")", ":", "\n", "  ", "\"\"\"Linear map: sum_i(args[i] * W[i]), where W[i] is a variable.\n  Args:\n    args: a 2D Tensor or a list of 2D, batch x n, Tensors.\n    output_size: int, second dimension of W[i].\n    bias: boolean, whether to add a bias term or not.\n    bias_initializer: starting value to initialize the bias\n      (default is all zeros).\n    kernel_initializer: starting value to initialize the weight.\n  Returns:\n    A 2D Tensor with shape [batch x output_size] equal to\n    sum_i(args[i] * W[i]), where W[i]s are newly created matrices.\n  Raises:\n    ValueError: if some of the arguments has unspecified or wrong shape.\n  \"\"\"", "\n", "if", "args", "is", "None", "or", "(", "nest", ".", "is_sequence", "(", "args", ")", "and", "not", "args", ")", ":", "\n", "    ", "raise", "ValueError", "(", "\"`args` must be specified\"", ")", "\n", "", "if", "not", "nest", ".", "is_sequence", "(", "args", ")", ":", "\n", "    ", "args", "=", "[", "args", "]", "\n", "\n", "# Calculate the total size of arguments on dimension 1.", "\n", "", "total_arg_size", "=", "0", "\n", "shapes", "=", "[", "a", ".", "get_shape", "(", ")", "for", "a", "in", "args", "]", "\n", "for", "shape", "in", "shapes", ":", "\n", "    ", "if", "shape", ".", "ndims", "!=", "2", ":", "\n", "      ", "raise", "ValueError", "(", "\"linear is expecting 2D arguments: %s\"", "%", "shapes", ")", "\n", "", "if", "shape", "[", "1", "]", ".", "value", "is", "None", ":", "\n", "      ", "raise", "ValueError", "(", "\"linear expects shape[1] to be provided for shape %s, \"", "\n", "\"but saw %s\"", "%", "(", "shape", ",", "shape", "[", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "      ", "total_arg_size", "+=", "shape", "[", "1", "]", ".", "value", "\n", "\n", "", "", "dtype", "=", "[", "a", ".", "dtype", "for", "a", "in", "args", "]", "[", "0", "]", "\n", "\n", "# Now the computation.", "\n", "scope", "=", "variable_scope", ".", "get_variable_scope", "(", ")", "\n", "with", "variable_scope", ".", "variable_scope", "(", "scope", ")", "as", "outer_scope", ":", "\n", "    ", "if", "weights", "is", "None", ":", "\n", "        ", "weights", "=", "variable_scope", ".", "get_variable", "(", "\n", "_WEIGHTS_VARIABLE_NAME", ",", "[", "total_arg_size", ",", "output_size", "]", ",", "\n", "dtype", "=", "dtype", ",", "\n", "initializer", "=", "kernel_initializer", ")", "\n", "", "if", "len", "(", "args", ")", "==", "1", ":", "\n", "      ", "res", "=", "math_ops", ".", "matmul", "(", "args", "[", "0", "]", ",", "weights", ")", "\n", "", "else", ":", "\n", "      ", "res", "=", "math_ops", ".", "matmul", "(", "array_ops", ".", "concat", "(", "args", ",", "1", ")", ",", "weights", ")", "\n", "", "if", "not", "bias", ":", "\n", "      ", "return", "res", "\n", "", "with", "variable_scope", ".", "variable_scope", "(", "outer_scope", ")", "as", "inner_scope", ":", "\n", "      ", "inner_scope", ".", "set_partitioner", "(", "None", ")", "\n", "if", "bias_initializer", "is", "None", ":", "\n", "        ", "bias_initializer", "=", "init_ops", ".", "constant_initializer", "(", "0.0", ",", "dtype", "=", "dtype", ")", "\n", "", "if", "biases", "is", "None", ":", "\n", "          ", "biases", "=", "variable_scope", ".", "get_variable", "(", "\n", "_BIAS_VARIABLE_NAME", ",", "[", "output_size", "]", ",", "\n", "dtype", "=", "dtype", ",", "\n", "initializer", "=", "bias_initializer", ")", "\n", "", "", "return", "nn_ops", ".", "bias_add", "(", "res", ",", "biases", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net.pointer_network_decoder": [[141, 251], ["tensorflow.python.ops.variable_scope.variable_scope", "tensorflow.tile", "tensorflow.tile", "tensorflow.tile", "len", "tensorflow.zeros", "range", "tensorflow.shape", "attention_states.get_shape", "decoder_inputs[].get_shape", "attention_states.get_shape", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.expand_dims", "cell", "tensorflow.transpose", "tensorflow.matmul", "tensorflow.nn.softmax", "tensorflow.reduce_sum", "outs.append", "tensorflow.expand_dims", "loop_function", "tensorflow.python.ops.variable_scope.get_variable_scope().reuse_variables", "tensorflow.python.ops.variable_scope.variable_scope", "pointer_net.__linear", "tensorflow.stack", "tensorflow.tanh", "tensorflow.multiply", "tensorflow.python.ops.variable_scope.variable_scope", "pointer_net.__linear", "tensorflow.squeeze", "tensorflow.random_normal_initializer", "tensorflow.random_normal_initializer", "Exception", "tensorflow.python.ops.variable_scope.get_variable_scope", "tensorflow.matmul", "tensorflow.matmul", "range"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net.__linear", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net.__linear"], ["", "", "def", "pointer_network_decoder", "(", "cell", ",", "\n", "decoder_type", ",", "# specification of the cell", "\n", "decoder_inputs", ",", "\n", "init_state", ",", "\n", "attention_states", ",", "\n", "num_decoder_symbols", ",", "\n", "loop_function", "=", "None", ",", "\n", "dtype", "=", "tf", ".", "float32", ",", "\n", "scope", "=", "None", ",", "weights", "=", "None", ")", ":", "\n", "    ", "\"\"\" A decoder with attention mechemnism\n        Arguments:\n            cell: a RNN cell\n            decoder_inputs: inputs to the decoder, of shape [(batch_size, embedding_size)], \n                            the list length is same as the size of the decoder\n            init_state: the initial hidden state for the decoder, of shape (hidden_size, ) \n            attention_states: states from the encoder that the attention header should look at, \n                             of shape (batch_size, encoder_length, hidden_size), where encoder_length is the size of encoder\n            num_decoder_symbols: the number of symbols in the decoder vocabulary\n            loop_function: used to deal with the problem of feed_previous, if the loop_function is None (training time), \n                           the input to the t-th cell will be decoder_inputs[t], otherwise the input will be the output of (t-1)-th cell\n        Returns:\n            A tuple of form (outs, state): \n                outs is a list, whose length is same as the decoder size\n                state is a tensor produced by the last unit of the decoder\n    \"\"\"", "\n", "\n", "with", "variable_scope", ".", "variable_scope", "(", "scope", "or", "\"pointer_network_decoder\"", ")", "as", "scope", ":", "\n", "        ", "batch_size", "=", "tf", ".", "shape", "(", "attention_states", ")", "[", "0", "]", "\n", "encoder_length", "=", "attention_states", ".", "get_shape", "(", ")", "[", "1", "]", "\n", "\n", "input_size", "=", "decoder_inputs", "[", "0", "]", ".", "get_shape", "(", ")", "[", "1", "]", "\n", "\n", "hidden_size", "=", "cell", ".", "output_size", "# size of the hidden state", "\n", "attn_size", "=", "attention_states", ".", "get_shape", "(", ")", "[", "2", "]", "# size of the attention vector", "\n", "\n", "if", "weights", "is", "not", "None", ":", "\n", "            ", "W1", "=", "weights", "[", "'decoder_W1'", "]", "\n", "W2", "=", "weights", "[", "'decoder_W2'", "]", "\n", "v", "=", "weights", "[", "'decoder_v'", "]", "\n", "Wout", "=", "weights", "[", "'decoder_Wout'", "]", "if", "'decoder_Wout'", "in", "weights", "else", "None", "\n", "Bout", "=", "weights", "[", "'decoder_Bout'", "]", "if", "'decoder_Bout'", "in", "weights", "else", "None", "\n", "Win", "=", "weights", "[", "'decoder_Win'", "]", "if", "'decoder_Win'", "in", "weights", "else", "None", "\n", "Bin", "=", "weights", "[", "'decoder_Bin'", "]", "if", "'decoder_Bin'", "in", "weights", "else", "None", "\n", "", "else", ":", "\n", "# weights for attention: W1 is the weight for input hidden states, W2 is the weight for current output", "\n", "# the second dimension is the size of the engery function for attentions", "\n", "            ", "W1", "=", "tf", ".", "get_variable", "(", "\"W1\"", ",", "[", "attn_size", ",", "hidden_size", "]", ",", "initializer", "=", "tf", ".", "random_normal_initializer", "(", ")", ")", "\n", "W2", "=", "tf", ".", "get_variable", "(", "\"W2\"", ",", "[", "hidden_size", ",", "hidden_size", "]", ",", "initializer", "=", "tf", ".", "random_normal_initializer", "(", ")", ")", "\n", "v", "=", "tf", ".", "get_variable", "(", "\"v\"", ",", "[", "hidden_size", "]", ")", "\n", "Wout", ",", "Bout", ",", "Win", ",", "Bin", "=", "None", ",", "None", ",", "None", ",", "None", "\n", "\n", "# copy W1, W2, v for batch_size times so that we can use mat multiply later", "\n", "", "copied_W1", "=", "tf", ".", "tile", "(", "tf", ".", "expand_dims", "(", "W1", ",", "0", ")", ",", "[", "batch_size", ",", "1", ",", "1", "]", ")", "\n", "copied_W2", "=", "tf", ".", "tile", "(", "tf", ".", "expand_dims", "(", "W2", ",", "0", ")", ",", "[", "batch_size", ",", "1", ",", "1", "]", ")", "\n", "copied_v", "=", "tf", ".", "tile", "(", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "v", ",", "-", "1", ")", ",", "0", ")", ",", "[", "batch_size", ",", "1", ",", "1", "]", ")", "\n", "\n", "step_num", "=", "len", "(", "decoder_inputs", ")", "\n", "\n", "outs", "=", "[", "]", "\n", "prev", "=", "None", "\n", "\n", "# the initial attention value", "\n", "attn", "=", "tf", ".", "zeros", "(", "shape", "=", "[", "batch_size", ",", "attn_size", "]", ",", "dtype", "=", "dtype", ")", "\n", "\n", "state", "=", "init_state", "\n", "for", "i", "in", "range", "(", "step_num", ")", ":", "\n", "\n", "            ", "inp", "=", "decoder_inputs", "[", "i", "]", "\n", "if", "loop_function", "is", "not", "None", "and", "prev", "is", "not", "None", ":", "\n", "# indicate the type of prev", "\n", "                ", "inp", "=", "loop_function", "(", "prev", ",", "decoder_type", "[", "i", "-", "1", "]", ")", "\n", "\n", "", "if", "i", ">", "0", ":", "\n", "                ", "variable_scope", ".", "get_variable_scope", "(", ")", ".", "reuse_variables", "(", ")", "\n", "\n", "", "with", "variable_scope", ".", "variable_scope", "(", "\"input_linear\"", ")", ":", "\n", "                ", "inp", "=", "__linear", "(", "[", "inp", "]", "+", "[", "attn", "]", ",", "input_size", ",", "True", ",", "weights", "=", "Win", ",", "biases", "=", "Bin", ")", "\n", "\n", "", "(", "output", ",", "state", ")", "=", "cell", "(", "inp", ",", "state", ")", "\n", "\n", "tiled_out", "=", "tf", ".", "transpose", "(", "tf", ".", "stack", "(", "[", "output", "for", "x", "in", "range", "(", "encoder_length", ")", "]", ")", ",", "[", "1", ",", "0", ",", "2", "]", ")", "\n", "\n", "## corresponding formula: u = tanh(h * W1 + d * W2) * v", "\n", "## we use copied W1 and W2 because we want to element-wisely perform matrix multiplication", "\n", "u", "=", "tf", ".", "matmul", "(", "tf", ".", "tanh", "(", "tf", ".", "matmul", "(", "attention_states", ",", "copied_W1", ")", "+", "tf", ".", "matmul", "(", "tiled_out", ",", "copied_W2", ")", ")", ",", "copied_v", ")", "\n", "\n", "## corresponding formula: a = softmax(u) ", "\n", "a", "=", "tf", ".", "nn", ".", "softmax", "(", "u", ",", "1", ")", "\n", "\n", "# perform a point-wise multiply and then perform a summation over the dimension to get the proper distribution", "\n", "attn", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "multiply", "(", "attention_states", ",", "a", ")", ",", "1", ")", "\n", "\n", "with", "variable_scope", ".", "variable_scope", "(", "\"output_linear\"", ")", ":", "\n", "# this makes the dimension of the output variable ", "\n", "                ", "new_out", "=", "__linear", "(", "[", "output", "]", "+", "[", "attn", "]", ",", "num_decoder_symbols", ",", "True", ",", "weights", "=", "Wout", ",", "biases", "=", "Bout", ")", "\n", "\n", "# output of the current decoder depends on the cell type", "\n", "", "if", "decoder_type", "[", "i", "]", ".", "ty", "is", "DecoderType", ".", "Pointer", ":", "\n", "                ", "new_out", "=", "tf", ".", "squeeze", "(", "u", ",", "axis", "=", "-", "1", ")", "\n", "", "elif", "decoder_type", "[", "i", "]", ".", "ty", "is", "DecoderType", ".", "Projector", ":", "\n", "# project to the dimension of decoder symbol for later decoding", "\n", "                ", "pass", "\n", "", "else", ":", "\n", "                ", "raise", "Exception", "(", "'not a expected type'", ")", "\n", "\n", "", "outs", ".", "append", "(", "new_out", ")", "\n", "if", "loop_function", "is", "not", "None", ":", "\n", "                ", "prev", "=", "new_out", "\n", "\n", "", "", "", "return", "outs", ",", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net.pointer_network": [[253, 368], ["tensorflow.python.ops.variable_scope.variable_scope", "model.rnn.merge_multirnn_lstm_state", "tensorflow.transpose", "tensorflow.cond", "scope.set_dtype", "model.rnn.bidirectional_static_rnn", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.stack", "tensorflow.logical_not", "len", "tensorflow.variable_scope", "pointer_net.pointer_network_decoder", "pointer_net.pointer_network._decoder_func"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.rnn.merge_multirnn_lstm_state", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.rnn.bidirectional_static_rnn", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net.pointer_network_decoder"], ["", "def", "pointer_network", "(", "enc_embeds", ",", "\n", "dec_embeds", ",", "\n", "fw_enc_cell", ",", "\n", "bw_enc_cell", ",", "\n", "dec_cell", ",", "\n", "decoder_type", ",", "# specification of the cell", "\n", "num_decoder_symbols", ",", "\n", "encoder_masks", ",", "\n", "feed_prev", "=", "None", ",", "\n", "loop_function", "=", "None", ",", "\n", "multi_encoders", "=", "None", ",", "\n", "encoder_merge_method", "=", "\"sequential\"", ",", "# ", "\n", "dtype", "=", "None", ",", "\n", "scope", "=", "None", ",", "weights", "=", "None", ")", ":", "\n", "    ", "\"\"\" Create a pointer netowrk\n        Args:\n            enc_embeds: encoder inputs to the pointer network, of shape (batch_size, embedding_size)\n            dec_embeds: decoder inputs to the pointer network, of shape (batch_size, embedding_size)\n            cell: the template for encoder decoder cells\n            decoder_type: types for decoder cells\n            num_decoder_symbols: the number of decoder symbols (this is used to deal with projection in feeding)\n            encoder_masks: the masks that mask out encoder padding symbols, \n                           if it is None, the network is a simple static pointer network, otherwise dynamically\n            feed_prev: a boolean tensor determining whether to feed forward in the decoding process\n            loop_function: the feed_forward function\n            multi_encoders: whether multiple encoders will be used, and how to combine information from them\n            encoder_merge_method: \n                    0: merge as a full sequence encoding\n                    1: encoding as multiple sequences, the second is initialized by the first bw state\n                No matter which state is chosen, the pointer net output is always a sequence\n        Returns:\n            outs from the pointer net, types corresponding to decoder_types\n    \"\"\"", "\n", "\n", "with", "variable_scope", ".", "variable_scope", "(", "scope", "or", "\"pointer_network\"", ")", "as", "scope", ":", "\n", "        ", "if", "dtype", "is", "not", "None", ":", "\n", "            ", "scope", ".", "set_dtype", "(", "dtype", ")", "\n", "", "else", ":", "\n", "            ", "dtype", "=", "scope", ".", "dtype", "\n", "\n", "", "if", "multi_encoders", "is", "None", ":", "\n", "            ", "enc_outs", ",", "enc_fw_state", ",", "enc_bw_state", "=", "bidirectional_static_rnn", "(", "fw_enc_cell", ",", "bw_enc_cell", ",", "enc_embeds", ",", "dtype", "=", "dtype", ")", "\n", "all_states", "=", "[", "enc_fw_state", ",", "enc_bw_state", "]", "\n", "\n", "", "elif", "encoder_merge_method", "==", "\"parallel\"", ":", "\n", "            ", "enc_outs", "=", "[", "None", "]", "*", "len", "(", "enc_embeds", ")", "\n", "all_states", "=", "[", "]", "\n", "\n", "for", "l", "in", "multi_encoders", "[", "\"segments\"", "]", ":", "\n", "                ", "if", "all_states", ":", "\n", "                    ", "last_fw_state", "=", "all_states", "[", "-", "2", "]", "\n", "last_bw_state", "=", "all_states", "[", "-", "1", "]", "\n", "new_init_state", "=", "last_bw_state", "\n", "", "else", ":", "\n", "                    ", "new_init_state", "=", "None", "\n", "\n", "", "enc_embeds_seg", "=", "[", "enc_embeds", "[", "i", "]", "for", "i", "in", "l", "]", "\n", "encoder_masks_seg", "=", "[", "encoder_masks", "[", "i", "]", "for", "i", "in", "l", "]", "\n", "\n", "enc_outs_seg", ",", "enc_fw_state_seg", ",", "enc_bw_state_seg", "=", "bidirectional_static_rnn", "(", "fw_enc_cell", ",", "bw_enc_cell", ",", "enc_embeds_seg", ",", "\n", "init_fw_state", "=", "new_init_state", ",", "dtype", "=", "dtype", ")", "\n", "\n", "for", "i", "in", "range", "(", "int", "(", "enc_outs_seg", ".", "get_shape", "(", ")", "[", "0", "]", ")", ")", ":", "\n", "                    ", "enc_outs", "[", "l", "[", "i", "]", "]", "=", "enc_outs_seg", "[", "i", "]", "\n", "\n", "", "all_states", ".", "append", "(", "enc_fw_state_seg", ")", "\n", "all_states", ".", "append", "(", "enc_bw_state_seg", ")", "\n", "\n", "", "", "elif", "encoder_merge_method", "==", "\"sequential\"", ":", "\n", "            ", "combined_l", "=", "[", "]", "\n", "for", "l", "in", "multi_encoders", "[", "\"segments\"", "]", ":", "\n", "                ", "combined_l", ".", "extend", "(", "l", ")", "\n", "\n", "", "enc_embeds_seg", "=", "[", "enc_embeds", "[", "i", "]", "for", "i", "in", "combined_l", "]", "\n", "encoder_masks_seg", "=", "[", "encoder_masks", "[", "i", "]", "for", "i", "in", "combined_l", "]", "\n", "\n", "enc_outs", ",", "enc_fw_states_seg", ",", "enc_bw_states_seg", "=", "bidirectional_static_rnn", "(", "fw_enc_cell", ",", "bw_enc_cell", ",", "enc_embeds_seg", ",", "encoder_masks_seg", ",", "keep_all_states", "=", "True", ",", "dtype", "=", "dtype", ")", "\n", "\n", "all_states", "=", "[", "]", "\n", "starting_index", "=", "0", "\n", "\n", "for", "l", "in", "multi_encoders", "[", "\"segments\"", "]", ":", "\n", "                ", "all_states", ".", "append", "(", "enc_fw_states_seg", "[", "starting_index", "+", "len", "(", "l", ")", "-", "1", "]", ")", "\n", "all_states", ".", "append", "(", "enc_bw_states_seg", "[", "starting_index", "+", "len", "(", "l", ")", "-", "1", "]", ")", "\n", "starting_index", "=", "starting_index", "+", "len", "(", "l", ")", "\n", "", "", "else", ":", "\n", "            ", "print", "(", "\"[Error] Encoder merge method is not speicified.\"", ")", "\n", "sys", ".", "exit", "(", "-", "1", ")", "\n", "\n", "", "state_size", "=", "(", "fw_enc_cell", ".", "output_size", "+", "bw_enc_cell", ".", "output_size", ")", "*", "(", "1", "if", "multi_encoders", "is", "None", "else", "len", "(", "multi_encoders", "[", "\"segments\"", "]", ")", ")", "\n", "if", "weights", "is", "not", "None", ":", "\n", "            ", "w_combine", "=", "weights", "[", "'encoder_w_combine'", "]", "\n", "b_combine", "=", "weights", "[", "'encoder_b_combine'", "]", "\n", "", "else", ":", "\n", "            ", "w_combine", "=", "tf", ".", "get_variable", "(", "\"w_combine\"", ",", "initializer", "=", "tf", ".", "random_normal", "(", "[", "state_size", ",", "dec_cell", ".", "output_size", "]", ")", ")", "\n", "b_combine", "=", "tf", ".", "get_variable", "(", "\"b_combine\"", ",", "initializer", "=", "tf", ".", "random_normal", "(", "[", "dec_cell", ".", "output_size", "]", ")", ")", "\n", "\n", "", "combined_state", "=", "merge_multirnn_lstm_state", "(", "all_states", ",", "w_combine", ",", "b_combine", ")", "\n", "\n", "# prepare the encoder outs for attention.", "\n", "attention_states", "=", "tf", ".", "transpose", "(", "tf", ".", "stack", "(", "enc_outs", ")", ",", "perm", "=", "[", "1", ",", "0", ",", "2", "]", ")", "\n", "\n", "def", "_decoder_func", "(", "feed_flag", ",", "reuse_flag", ")", ":", "\n", "# whether to reuse the decoder is determined by the flags", "\n", "            ", "with", "tf", ".", "variable_scope", "(", "\"attn_decoder\"", ",", "reuse", "=", "reuse_flag", ")", "as", "scope", ":", "\n", "                ", "return", "pointer_network_decoder", "(", "dec_cell", ",", "decoder_type", ",", "dec_embeds", ",", "combined_state", ",", "attention_states", ",", "\n", "num_decoder_symbols", ",", "loop_function", "=", "loop_function", "if", "feed_flag", "else", "None", ",", "dtype", "=", "dtype", ",", "scope", "=", "scope", ",", "\n", "weights", "=", "weights", ")", "\n", "\n", "# we use the backward state as the input to the decoder, since we want the decoder carry for information about the task", "\n", "", "", "dec_outs", ",", "dec_state", "=", "tf", ".", "cond", "(", "tf", ".", "logical_not", "(", "feed_prev", ")", ",", "\n", "lambda", ":", "_decoder_func", "(", "False", ",", "False", ")", ",", "\n", "lambda", ":", "_decoder_func", "(", "True", ",", "True", ")", ")", "\n", "\n", "", "return", "dec_outs", "\n", "", ""]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.learn_meta.train_model": [[13, 185], ["os.path.join", "graph.as_default", "tensorflow.train.Saver", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "tensorflow.placeholder", "tensorflow.train.AdagradOptimizer", "tf.train.AdagradOptimizer.compute_gradients", "zip", "tf.train.AdagradOptimizer.apply_gradients", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "print", "tensorflow.clip_by_global_norm", "zip", "print", "zip", "tensorflow.Session", "session.as_default", "session.run", "int", "range", "tensorflow.pow", "open", "open.write", "open.write", "tensorflow.global_variables_initializer", "numpy.ceil", "print", "print", "range", "print", "print", "print", "grads_tmp.append", "grads_tmp.append", "min", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "session.run", "tr_token_accuracies.append", "tr_sentence_accuracies.append", "tr_losses.append", "learn_meta.test_model", "open.write", "open.write", "numpy.mean", "tensorflow.to_float", "len", "float", "len", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "tf.train.Saver.save", "tensorflow.sqrt", "tensorflow.random_normal", "os.path.join", "tensorflow.shape", "range", "range", "range", "range", "range"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.learn_meta.test_model", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.execute_dev.to_float"], ["def", "train_model", "(", "graph", ",", "var_dict", ",", "train_data", ",", "max_epoch", ",", "hyper_param", ",", "\n", "output_dir", ",", "test_data", "=", "None", ",", "ex_printer", "=", "None", ",", "session", "=", "None", ",", "\n", "train_support_data", "=", "None", ",", "dev_support_data", "=", "None", ")", ":", "\n", "    ", "\"\"\" train a model with provided data \"\"\"", "\n", "learning_rate", "=", "hyper_param", "[", "\"learning_rate\"", "]", "\n", "batch_size", "=", "hyper_param", "[", "\"batch_size\"", "]", "\n", "log_file", "=", "os", ".", "path", ".", "join", "(", "output_dir", ",", "\"train.log\"", ")", "if", "output_dir", "is", "not", "None", "else", "None", "\n", "\n", "with", "graph", ".", "as_default", "(", ")", ":", "\n", "# the saver to keep model", "\n", "        ", "saver", "=", "tf", ".", "train", ".", "Saver", "(", ")", "\n", "last_best_accuracy", "=", "0.", "\n", "\n", "# place holders for the model", "\n", "train_inputs", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_inputs\"", "]", ")", "\n", "train_outputs", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_outputs\"", "]", ")", "\n", "\n", "seq2seq_feed_previous", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"seq2seq_feed_previous\"", "]", ")", "\n", "input_mask", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_input_mask\"", "]", ")", "\n", "output_mask", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_output_mask\"", "]", ")", "\n", "type_masks", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"type_masks\"", "]", ")", "\n", "\n", "if", "'train_inputs_2'", "in", "var_dict", ":", "\n", "            ", "train_inputs_2", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_inputs_2\"", "]", ")", "\n", "train_outputs_2", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_outputs_2\"", "]", ")", "\n", "\n", "seq2seq_feed_previous_2", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"seq2seq_feed_previous_2\"", "]", ")", "\n", "input_mask_2", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_input_mask_2\"", "]", ")", "\n", "output_mask_2", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_output_mask_2\"", "]", ")", "\n", "type_masks_2", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"type_masks_2\"", "]", ")", "\n", "\n", "\n", "", "input_switch", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"input_switch\"", "]", ")", "if", "'input_switch'", "in", "var_dict", "else", "None", "\n", "\n", "# operaters needed for testing", "\n", "token_accuracy", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"token_accuracy\"", "]", ")", "\n", "sentence_accuracy", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"sentence_accuracy\"", "]", ")", "\n", "total_loss", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"total_loss\"", "]", ")", "\n", "\n", "global_step", "=", "tf", ".", "placeholder", "(", "tf", ".", "int32", ",", "name", "=", "\"global_step\"", ")", "\n", "optimizer", "=", "tf", ".", "train", ".", "AdagradOptimizer", "(", "learning_rate", "=", "learning_rate", ")", "\n", "\n", "# gradient processing", "\n", "grad_clip_norm", "=", "hyper_param", "[", "\"gradient_clip_norm\"", "]", "if", "\"gradient_clip_norm\"", "in", "hyper_param", "else", "None", "\n", "grad_noise", "=", "hyper_param", "[", "\"gradient_noise\"", "]", "if", "\"gradient_noise\"", "in", "hyper_param", "else", "None", "\n", "grad_noise_gamma", "=", "hyper_param", "[", "\"gradient_noise_gamma\"", "]", "if", "\"gradient_noise_gamma\"", "in", "hyper_param", "else", "None", "\n", "\n", "grads_and_vars", "=", "optimizer", ".", "compute_gradients", "(", "total_loss", ")", "\n", "(", "grads", ",", "variables", ")", "=", "zip", "(", "*", "grads_and_vars", ")", "\n", "\n", "if", "grad_clip_norm", ":", "\n", "            ", "print", "(", "\"clipping norm: {}\"", ".", "format", "(", "grad_clip_norm", ")", ")", "\n", "capped_grads", ",", "_", "=", "tf", ".", "clip_by_global_norm", "(", "grads", ",", "grad_clip_norm", ")", "\n", "grads_and_vars", "=", "zip", "(", "capped_grads", ",", "variables", ")", "\n", "\n", "", "if", "grad_noise", ":", "\n", "            ", "if", "grad_noise_gamma", ":", "\n", "                ", "grad_noise", "/=", "tf", ".", "pow", "(", "1.0", "+", "tf", ".", "to_float", "(", "global_step", ")", ",", "grad_noise_gamma", ")", "\n", "", "grads_tmp", "=", "[", "]", "\n", "for", "g", "in", "grads", ":", "\n", "                ", "if", "g", "is", "not", "None", ":", "\n", "                    ", "noisy_grad", "=", "g", "+", "tf", ".", "sqrt", "(", "grad_noise", ")", "*", "tf", ".", "random_normal", "(", "tf", ".", "shape", "(", "g", ")", ")", "\n", "grads_tmp", ".", "append", "(", "noisy_grad", ")", "\n", "", "else", ":", "\n", "                    ", "grads_tmp", ".", "append", "(", "g", ")", "\n", "", "", "print", "(", "\"noise added\"", ")", "\n", "grads_and_vars", "=", "zip", "(", "grads_tmp", ",", "variables", ")", "\n", "\n", "", "train_step", "=", "optimizer", ".", "apply_gradients", "(", "grads_and_vars", ")", "\n", "\n", "session", "=", "tf", ".", "Session", "(", ")", "if", "session", "is", "None", "else", "session", "\n", "\n", "with", "session", ".", "as_default", "(", ")", ":", "\n", "            ", "if", "log_file", "is", "not", "None", ":", "\n", "# initialize the logfile", "\n", "                ", "output_log", "=", "open", "(", "log_file", ",", "\"w\"", ")", "\n", "log_header", "=", "\"tr_tok_acc, test_tok_acc, tr_sen_acc, test_sen_acc, tr_loss, test_loss\"", "\n", "if", "test_data", "is", "None", ":", "\n", "                    ", "log_header", "=", "\"tr_tok_acc, tr_sen_acc, tr_loss\"", "\n", "", "output_log", ".", "write", "(", "log_header", ")", "\n", "output_log", ".", "write", "(", "\"\\n\"", ")", "\n", "\n", "", "session", ".", "run", "(", "tf", ".", "global_variables_initializer", "(", ")", ")", "\n", "nbatches", "=", "int", "(", "np", ".", "ceil", "(", "len", "(", "train_data", ".", "Xs", ")", "/", "float", "(", "batch_size", ")", ")", ")", "\n", "num_meta_example", "=", "hyper_param", "[", "\"num_meta_example\"", "]", "\n", "\n", "for", "n", "in", "range", "(", "max_epoch", ")", ":", "\n", "                ", "print", "(", "\"================ epoch %d ==================\"", "%", "n", ")", "\n", "print", "(", "\"PROGRESS: 00.00%\"", ")", "\n", "\n", "tr_token_accuracies", "=", "[", "]", "\n", "tr_sentence_accuracies", "=", "[", "]", "\n", "tr_losses", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "nbatches", ")", ":", "\n", "                    ", "left", "=", "i", "*", "batch_size", "\n", "right", "=", "min", "(", "(", "i", "+", "1", ")", "*", "batch_size", ",", "len", "(", "train_data", ".", "Xs", ")", ")", "\n", "\n", "Xt", "=", "train_data", ".", "Xs", "[", "left", ":", "right", "]", "\n", "Yt", "=", "train_data", ".", "Ys", "[", "left", ":", "right", "]", "\n", "XMasks", "=", "train_data", ".", "XMasks", "[", "left", ":", "right", "]", "\n", "YMasks", "=", "train_data", ".", "YMasks", "[", "left", ":", "right", "]", "\n", "ty_masks", "=", "train_data", ".", "type_masks", "[", ":", ",", "left", ":", "right", ",", ":", "]", "\n", "\n", "Xt_support", "=", "np", ".", "concatenate", "(", "[", "train_support_data", "[", "isupport", "]", ".", "Xs", "[", "left", ":", "right", "]", "for", "isupport", "in", "range", "(", "num_meta_example", ")", "]", ")", "\n", "Yt_support", "=", "np", ".", "concatenate", "(", "[", "train_support_data", "[", "isupport", "]", ".", "Ys", "[", "left", ":", "right", "]", "for", "isupport", "in", "\n", "range", "(", "num_meta_example", ")", "]", ")", "\n", "XMasks_support", "=", "np", ".", "concatenate", "(", "[", "train_support_data", "[", "isupport", "]", ".", "XMasks", "[", "left", ":", "right", "]", "for", "isupport", "in", "\n", "range", "(", "num_meta_example", ")", "]", ")", "\n", "YMasks_support", "=", "np", ".", "concatenate", "(", "[", "train_support_data", "[", "isupport", "]", ".", "YMasks", "[", "left", ":", "right", "]", "for", "isupport", "in", "\n", "range", "(", "num_meta_example", ")", "]", ")", "\n", "ty_masks_support", "=", "np", ".", "concatenate", "(", "[", "train_support_data", "[", "isupport", "]", ".", "type_masks", "[", ":", ",", "left", ":", "right", ",", ":", "]", "for", "isupport", "in", "range", "(", "num_meta_example", ")", "]", ",", "axis", "=", "1", ")", "\n", "\n", "training_result", "=", "session", ".", "run", "(", "[", "token_accuracy", ",", "\n", "sentence_accuracy", ",", "\n", "total_loss", ",", "\n", "train_step", "]", ",", "\n", "feed_dict", "=", "{", "train_inputs", ":", "Xt_support", ",", "train_inputs_2", ":", "Xt", ",", "\n", "train_outputs", ":", "Yt_support", ",", "train_outputs_2", ":", "Yt", ",", "\n", "input_mask", ":", "XMasks_support", ",", "input_mask_2", ":", "XMasks", ",", "\n", "output_mask", ":", "YMasks_support", ",", "output_mask_2", ":", "YMasks", ",", "\n", "type_masks", ":", "ty_masks_support", ",", "type_masks_2", ":", "ty_masks", ",", "\n", "seq2seq_feed_previous", ":", "False", ",", "seq2seq_feed_previous_2", ":", "False", ",", "\n", "global_step", ":", "n", ",", "\n", "input_switch", ":", "True", "}", ")", "\n", "\n", "tr_token_accuracies", ".", "append", "(", "training_result", "[", "0", "]", ")", "\n", "tr_sentence_accuracies", ".", "append", "(", "training_result", "[", "1", "]", ")", "\n", "tr_losses", ".", "append", "(", "training_result", "[", "2", "]", ")", "\n", "\n", "", "print", "(", "\"training_loss = {:.5f}\"", ".", "format", "(", "np", ".", "mean", "(", "tr_losses", ")", ")", ")", "\n", "print", "(", "\"train_token_accuracy = {:.5f}\"", ".", "format", "(", "np", ".", "mean", "(", "tr_token_accuracies", ")", ")", ")", "\n", "print", "(", "\"train_sentence_accuracy = {:.5f}\"", ".", "format", "(", "np", ".", "mean", "(", "tr_sentence_accuracies", ")", ")", ")", "\n", "\n", "if", "test_data", "is", "not", "None", ":", "\n", "                    ", "test_result", "=", "test_model", "(", "graph", ",", "var_dict", ",", "session", ",", "test_data", ",", "batch_size", ",", "\n", "ex_printer", "=", "ex_printer", "if", "(", "n", "%", "30", "==", "0", "or", "n", "==", "max_epoch", "-", "1", ")", "else", "None", ",", "\n", "test_support_data", "=", "dev_support_data", "[", ":", "num_meta_example", "]", ")", "\n", "\n", "test_token_accuracy", "=", "test_result", "[", "0", "]", "\n", "test_sentence_accuracy", "=", "test_result", "[", "1", "]", "\n", "test_loss", "=", "test_result", "[", "2", "]", "\n", "\n", "log_str", "=", "\"{}, {}, {}, {}, {}, {}\"", ".", "format", "(", "\n", "np", ".", "mean", "(", "tr_token_accuracies", ")", ",", "test_token_accuracy", ",", "\n", "np", ".", "mean", "(", "tr_sentence_accuracies", ")", ",", "test_sentence_accuracy", ",", "\n", "np", ".", "mean", "(", "tr_losses", ")", ",", "test_loss", ")", "\n", "", "else", ":", "\n", "                    ", "log_str", "=", "\"{}, {}, {}\"", ".", "format", "(", "np", ".", "mean", "(", "tr_token_accuracies", ")", ",", "\n", "np", ".", "mean", "(", "tr_sentence_accuracies", ")", ",", "\n", "np", ".", "mean", "(", "tr_losses", ")", ")", "\n", "\n", "", "if", "output_dir", ":", "\n", "                    ", "if", "test_data", "is", "not", "None", ":", "\n", "                        ", "current_seq_acc", "=", "test_sentence_accuracy", "\n", "", "else", ":", "\n", "                        ", "current_seq_acc", "=", "np", ".", "mean", "(", "tr_sentence_accuracies", ")", "\n", "\n", "", "if", "current_seq_acc", ">", "last_best_accuracy", ":", "\n", "                        ", "last_best_accuracy", "=", "current_seq_acc", "\n", "# add global step so that we can keep multiple models around", "\n", "saver", ".", "save", "(", "session", ",", "os", ".", "path", ".", "join", "(", "output_dir", ",", "\"table_nl_prog\"", ")", ",", "global_step", "=", "n", ")", "\n", "\n", "", "", "if", "log_file", "is", "not", "None", ":", "\n", "# write corresponding data to log", "\n", "                    ", "output_log", ".", "write", "(", "log_str", ")", "\n", "output_log", ".", "write", "(", "\"\\n\"", ")", "\n", "\n", "", "if", "np", ".", "mean", "(", "tr_losses", ")", "<", "0.05", ":", "\n", "                    ", "break", "\n", "\n", "", "", "", "", "return", "session", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.learn_meta.test_model": [[187, 313], ["graph.as_default", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "graph.get_tensor_by_name", "numpy.mean", "numpy.mean", "numpy.mean", "graph.get_tensor_by_name", "len", "session.as_default", "print", "int", "range", "numpy.ceil", "open", "min", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "print", "print", "print", "print", "print", "print", "len", "numpy.concatenate", "numpy.concatenate", "session.run", "test_tok_acc.append", "test_seq_acc.append", "test_loss.append", "session.run", "ex_printer.print", "ex_printer.print", "len", "float", "ex_printer.print", "ex_printer.print", "open.write", "open.write", "open.write", "open.write", "open.write", "open.write", "open.write", "numpy.mean", "numpy.mean", "numpy.mean", "range", "range", "range", "str", "str", "str", "range", "range"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write"], ["", "def", "test_model", "(", "graph", ",", "var_dict", ",", "session", ",", "test_data", ",", "batch_size", ",", "ex_printer", "=", "None", ",", "log_file", "=", "None", ",", "\n", "test_support_data", "=", "None", ")", ":", "\n", "    ", "with", "graph", ".", "as_default", "(", ")", ":", "\n", "# place holders for the model", "\n", "        ", "train_inputs", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_inputs\"", "]", ")", "\n", "train_outputs", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_outputs\"", "]", ")", "\n", "\n", "seq2seq_feed_previous", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"seq2seq_feed_previous\"", "]", ")", "\n", "input_mask", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_input_mask\"", "]", ")", "\n", "output_mask", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_output_mask\"", "]", ")", "\n", "\n", "train_inputs_2", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_inputs_2\"", "]", ")", "\n", "train_outputs_2", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_outputs_2\"", "]", ")", "\n", "\n", "seq2seq_feed_previous_2", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"seq2seq_feed_previous_2\"", "]", ")", "\n", "input_mask_2", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_input_mask_2\"", "]", ")", "\n", "output_mask_2", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"train_output_mask_2\"", "]", ")", "\n", "input_switch", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"input_switch\"", "]", ")", "if", "'input_switch'", "in", "var_dict", "else", "None", "\n", "type_masks", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"type_masks\"", "]", ")", "\n", "type_masks_2", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"type_masks_2\"", "]", ")", "\n", "\n", "# operaters needed for testing", "\n", "token_accuracy", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"token_accuracy\"", "]", ")", "\n", "sentence_accuracy", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"sentence_accuracy\"", "]", ")", "\n", "total_loss", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"total_loss\"", "]", ")", "\n", "predicted_labels", "=", "graph", ".", "get_tensor_by_name", "(", "var_dict", "[", "\"predicted_labels\"", "]", ")", "\n", "\n", "num_meta_example", "=", "len", "(", "test_support_data", ")", "if", "test_support_data", "else", "0", "\n", "\n", "with", "session", ".", "as_default", "(", ")", ":", "\n", "            ", "print", "(", "\"PROGRESS: 00.00%\"", ")", "\n", "# adding this so that we can include the last one as well", "\n", "nbatches", "=", "int", "(", "np", ".", "ceil", "(", "len", "(", "test_data", ".", "Xs", ")", "/", "float", "(", "batch_size", ")", ")", ")", "\n", "\n", "test_tok_acc", "=", "[", "]", "\n", "test_seq_acc", "=", "[", "]", "\n", "test_loss", "=", "[", "]", "\n", "\n", "if", "log_file", "is", "not", "None", ":", "\n", "# initialize the logfile", "\n", "                ", "pred_log_f", "=", "open", "(", "log_file", ",", "\"w\"", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "nbatches", ")", ":", "\n", "                ", "left", "=", "i", "*", "batch_size", "\n", "right", "=", "min", "(", "(", "i", "+", "1", ")", "*", "batch_size", ",", "len", "(", "test_data", ".", "Xs", ")", ")", "\n", "\n", "Xtest", "=", "test_data", ".", "Xs", "[", "left", ":", "right", "]", "\n", "XMasks", "=", "test_data", ".", "XMasks", "[", "left", ":", "right", "]", "\n", "ty_masks", "=", "test_data", ".", "type_masks", "[", ":", ",", "left", ":", "right", ",", ":", "]", "\n", "\n", "Xtest_support", "=", "np", ".", "concatenate", "(", "\n", "[", "test_support_data", "[", "isupport", "]", ".", "Xs", "[", "left", ":", "right", "]", "for", "isupport", "in", "\n", "range", "(", "num_meta_example", ")", "]", ")", "\n", "XMasks_support", "=", "np", ".", "concatenate", "(", "\n", "[", "test_support_data", "[", "isupport", "]", ".", "XMasks", "[", "left", ":", "right", "]", "for", "isupport", "in", "\n", "range", "(", "num_meta_example", ")", "]", ")", "\n", "ty_masks_support", "=", "np", ".", "concatenate", "(", "\n", "[", "test_support_data", "[", "isupport", "]", ".", "type_masks", "[", ":", ",", "left", ":", "right", ",", ":", "]", "for", "isupport", "in", "\n", "range", "(", "num_meta_example", ")", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# in some cases we don't have the access to the test data", "\n", "if", "test_data", ".", "Ys", "is", "not", "None", "and", "test_data", ".", "YMasks", "is", "not", "None", ":", "\n", "                    ", "Ytest", "=", "test_data", ".", "Ys", "[", "left", ":", "right", "]", "\n", "YMasks", "=", "test_data", ".", "YMasks", "[", "left", ":", "right", "]", "\n", "\n", "Ytest_support", "=", "np", ".", "concatenate", "(", "\n", "[", "test_support_data", "[", "isupport", "]", ".", "Ys", "[", "left", ":", "right", "]", "for", "isupport", "in", "\n", "range", "(", "num_meta_example", ")", "]", ")", "\n", "YMasks_support", "=", "np", ".", "concatenate", "(", "\n", "[", "test_support_data", "[", "isupport", "]", ".", "YMasks", "[", "left", ":", "right", "]", "for", "isupport", "in", "range", "(", "num_meta_example", ")", "]", ")", "\n", "\n", "#### HERE feed prvious set to true to make it work #####", "\n", "result", "=", "session", ".", "run", "(", "[", "token_accuracy", ",", "\n", "sentence_accuracy", ",", "\n", "total_loss", ",", "\n", "predicted_labels", "]", ",", "\n", "feed_dict", "=", "{", "train_inputs", ":", "Xtest_support", ",", "train_inputs_2", ":", "Xtest", ",", "\n", "train_outputs", ":", "Ytest_support", ",", "train_outputs_2", ":", "Ytest", ",", "\n", "input_mask", ":", "XMasks_support", ",", "input_mask_2", ":", "XMasks", ",", "\n", "output_mask", ":", "YMasks_support", ",", "output_mask_2", ":", "YMasks", ",", "\n", "type_masks", ":", "ty_masks_support", ",", "type_masks_2", ":", "ty_masks", ",", "\n", "seq2seq_feed_previous", ":", "True", ",", "\n", "seq2seq_feed_previous_2", ":", "True", ",", "\n", "input_switch", ":", "True", "}", ")", "\n", "test_tok_acc", ".", "append", "(", "result", "[", "0", "]", ")", "\n", "test_seq_acc", ".", "append", "(", "result", "[", "1", "]", ")", "\n", "test_loss", ".", "append", "(", "result", "[", "2", "]", ")", "\n", "predictions", "=", "result", "[", "3", "]", "\n", "", "else", ":", "\n", "                    ", "result", "=", "session", ".", "run", "(", "[", "predicted_labels", "]", ",", "\n", "feed_dict", "=", "{", "train_inputs", ":", "Xtest", ",", "\n", "input_mask", ":", "XMasks", ",", "\n", "type_masks", ":", "ty_masks", ",", "\n", "seq2seq_feed_previous", ":", "True", "}", ")", "\n", "predictions", "=", "result", "[", "0", "]", "\n", "\n", "", "if", "ex_printer", "is", "not", "None", "and", "log_file", "is", "not", "None", ":", "\n", "\n", "                    ", "if", "test_data", ".", "Ys", "is", "not", "None", ":", "\n", "                        ", "outs", "=", "ex_printer", ".", "print", "(", "Xtest", ",", "Ytest", ",", "predictions", ",", "k", "=", "999999", ")", "\n", "", "else", ":", "\n", "                        ", "outs", "=", "ex_printer", ".", "print", "(", "Xtest", ",", "None", ",", "predictions", ",", "k", "=", "999999", ")", "\n", "\n", "", "for", "e", "in", "outs", ":", "\n", "                        ", "pred_log_f", ".", "write", "(", "str", "(", "e", "[", "0", "]", ")", ")", "\n", "pred_log_f", ".", "write", "(", "\"\\n\"", ")", "\n", "pred_log_f", ".", "write", "(", "str", "(", "e", "[", "1", "]", ")", ")", "\n", "pred_log_f", ".", "write", "(", "\"\\n\"", ")", "\n", "pred_log_f", ".", "write", "(", "str", "(", "e", "[", "2", "]", ")", ")", "\n", "pred_log_f", ".", "write", "(", "\"\\n\"", ")", "\n", "pred_log_f", ".", "write", "(", "\"\\n\"", ")", "\n", "\n", "", "", "", "if", "test_loss", ":", "\n", "                ", "print", "(", "\"test_loss = {:.5f}\"", ".", "format", "(", "np", ".", "mean", "(", "test_loss", ")", ")", ")", "\n", "print", "(", "\"test_token_accuracy = {:.5f}\"", ".", "format", "(", "np", ".", "mean", "(", "test_tok_acc", ")", ")", ")", "\n", "print", "(", "\"test_sentence_accuracy = {:.5f}\"", ".", "format", "(", "np", ".", "mean", "(", "test_seq_acc", ")", ")", ")", "\n", "\n", "", "if", "ex_printer", "is", "not", "None", ":", "\n", "                ", "print", "(", "\"\"", ")", "\n", "print", "(", "\"[[Test Examples]]\"", ")", "\n", "if", "test_data", ".", "Ys", "is", "not", "None", ":", "\n", "                    ", "outs", "=", "ex_printer", ".", "print", "(", "Xtest", ",", "Ytest", ",", "predictions", ",", "k", "=", "5", ")", "\n", "", "else", ":", "\n", "                    ", "outs", "=", "ex_printer", ".", "print", "(", "Xtest", ",", "None", ",", "predictions", ",", "k", "=", "5", ")", "\n", "", "print", "(", "\"\"", ")", "\n", "", "", "", "return", "np", ".", "mean", "(", "test_tok_acc", ")", ",", "np", ".", "mean", "(", "test_seq_acc", ")", ",", "np", ".", "mean", "(", "test_loss", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.learn_meta.load_model": [[316, 333], ["os.path.dirname", "os.path.basename", "print", "tensorflow.Session", "tensorflow.train.import_meta_graph", "tensorflow.get_default_graph", "print", "tf.train.import_meta_graph.restore", "print", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print"], ["", "def", "load_model", "(", "model_file", ")", ":", "\n", "    ", "model_dir", "=", "os", ".", "path", ".", "dirname", "(", "model_file", ")", "\n", "model_name", "=", "os", ".", "path", ".", "basename", "(", "model_file", ")", "\n", "\n", "print", "(", "\"[OK] Start loading graph from {} ...\"", ".", "format", "(", "model_file", ")", ")", "\n", "\n", "session", "=", "tf", ".", "Session", "(", ")", "\n", "saver", "=", "tf", ".", "train", ".", "import_meta_graph", "(", "os", ".", "path", ".", "join", "(", "model_dir", ",", "model_name", "+", "\".meta\"", ")", ")", "\n", "graph", "=", "tf", ".", "get_default_graph", "(", ")", "\n", "\n", "print", "(", "\"[OK] Successfully load the graph.\"", ")", "\n", "\n", "saver", ".", "restore", "(", "session", ",", "os", ".", "path", ".", "join", "(", "model_dir", ",", "model_name", ")", ")", "\n", "\n", "print", "(", "\"[OK] Successfully load variable weights.\"", ")", "\n", "\n", "return", "graph", ",", "session", "\n", "", ""]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_graph.build_graph": [[22, 232], ["pnet_vocab.get_all", "tf.Graph", "tf.Graph.as_default", "tf.variable_scope", "tf.placeholder", "tf.placeholder", "tf.placeholder", "tf.placeholder", "tf.placeholder", "tf.placeholder", "tf.contrib.rnn.MultiRNNCell", "tf.contrib.rnn.MultiRNNCell", "tf.contrib.rnn.MultiRNNCell", "tf.transpose", "tf.get_variable", "print", "tf.unstack", "pointer_network", "split_by_type", "split_by_type", "tf.transpose", "pointer_net_graph.build_graph._process_outs"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetVocab.get_all", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net.pointer_network", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.split_by_type", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.split_by_type"], ["def", "build_graph", "(", "decoder_type", ",", "explicit_pointer", ",", "value_based_loss", ",", "\n", "hyper_param", ",", "pnet_vocab", ",", "pretrained_enc_embedding", "=", "None", ",", "\n", "multi_encoders", "=", "None", ",", "old_graph", "=", "None", ",", "scope", "=", "None", ")", ":", "\n", "    ", "\"\"\" Build a graph \"\"\"", "\n", "# hyper parameter", "\n", "embedding_size", "=", "hyper_param", "[", "\"embedding_size\"", "]", "\n", "#batch_size = hyper_param[\"batch_size\"] # fixed batch size when building graph", "\n", "batch_size", "=", "None", "# mutable batch size data", "\n", "n_hidden", "=", "hyper_param", "[", "\"n_hidden\"", "]", "\n", "num_layers", "=", "hyper_param", "[", "\"num_layers\"", "]", "\n", "learning_rate", "=", "hyper_param", "[", "\"learning_rate\"", "]", "\n", "dropout_keep_prob", "=", "hyper_param", "[", "\"dropout_keep_prob\"", "]", "\n", "encoder_merge_method", "=", "hyper_param", "[", "\"encoder_merge_method\"", "]", "\n", "\n", "input_vocab", ",", "output_vocab", ",", "X_maxlen", ",", "Y_maxlen", "=", "pnet_vocab", ".", "get_all", "(", ")", "\n", "\n", "graph", "=", "tf", ".", "Graph", "(", ")", "\n", "\n", "# scope should only be used after graph is defined", "\n", "with", "graph", ".", "as_default", "(", ")", ",", "tf", ".", "variable_scope", "(", "scope", "or", "\"graph\"", ")", "as", "scope", ":", "\n", "        ", "train_inputs", "=", "tf", ".", "placeholder", "(", "tf", ".", "int32", ",", "[", "batch_size", ",", "X_maxlen", "]", ",", "name", "=", "\"train_inputs\"", ")", "\n", "# the mask for identifying padding tokens from the sentence", "\n", "train_input_mask", "=", "tf", ".", "placeholder", "(", "tf", ".", "bool", ",", "[", "batch_size", ",", "X_maxlen", "]", ",", "name", "=", "\"train_input_mask\"", ")", "\n", "train_outputs", "=", "tf", ".", "placeholder", "(", "tf", ".", "int32", ",", "[", "batch_size", ",", "Y_maxlen", "]", ",", "name", "=", "\"train_outputs\"", ")", "\n", "train_output_mask", "=", "tf", ".", "placeholder", "(", "tf", ".", "bool", ",", "[", "batch_size", ",", "Y_maxlen", "]", ",", "name", "=", "\"train_output_mask\"", ")", "\n", "type_masks", "=", "tf", ".", "placeholder", "(", "tf", ".", "bool", ",", "[", "2", ",", "batch_size", ",", "X_maxlen", "]", ",", "name", "=", "\"type_masks\"", ")", "\n", "\n", "batch_size", "=", "tf", ".", "shape", "(", "train_inputs", ")", "[", "0", "]", "\n", "\n", "seq2seq_feed_previous", "=", "tf", ".", "placeholder", "(", "tf", ".", "bool", ",", "name", "=", "\"seq2seq_feed_previous\"", ")", "\n", "\n", "if", "pretrained_enc_embedding", "is", "not", "None", ":", "\n", "            ", "enc_embedding", "=", "tf", ".", "get_variable", "(", "\"enc_embedding\"", ",", "\n", "shape", "=", "[", "input_vocab", ".", "size", ",", "embedding_size", "]", ",", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "pretrained_enc_embedding", ")", ",", "\n", "trainable", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "enc_embedding", "=", "tf", ".", "get_variable", "(", "\"enc_embedding\"", ",", "\n", "initializer", "=", "tf", ".", "random_uniform", "(", "[", "input_vocab", ".", "size", ",", "embedding_size", "]", ",", "-", "1.0", ",", "1", ")", ")", "\n", "\n", "", "fw_enc_cell", "=", "tf", ".", "contrib", ".", "rnn", ".", "MultiRNNCell", "(", "[", "tf", ".", "contrib", ".", "rnn", ".", "LSTMCell", "(", "n_hidden", ")", "for", "_", "in", "range", "(", "num_layers", ")", "]", ")", "\n", "bw_enc_cell", "=", "tf", ".", "contrib", ".", "rnn", ".", "MultiRNNCell", "(", "[", "tf", ".", "contrib", ".", "rnn", ".", "LSTMCell", "(", "n_hidden", ")", "for", "_", "in", "range", "(", "num_layers", ")", "]", ")", "\n", "dec_cell", "=", "tf", ".", "contrib", ".", "rnn", ".", "MultiRNNCell", "(", "[", "tf", ".", "contrib", ".", "rnn", ".", "LSTMCell", "(", "n_hidden", ")", "for", "_", "in", "range", "(", "num_layers", ")", "]", ")", "\n", "\n", "if", "dropout_keep_prob", "<", "1", ":", "\n", "            ", "t_dropout_keep_prob", "=", "tf", ".", "cond", "(", "seq2seq_feed_previous", ",", "lambda", ":", "1.", ",", "lambda", ":", "dropout_keep_prob", ")", "\n", "# the cell used in the model", "\n", "fw_enc_cell", "=", "tf", ".", "contrib", ".", "rnn", ".", "DropoutWrapper", "(", "fw_enc_cell", ",", "output_keep_prob", "=", "t_dropout_keep_prob", ")", "\n", "bw_enc_cell", "=", "tf", ".", "contrib", ".", "rnn", ".", "DropoutWrapper", "(", "bw_enc_cell", ",", "output_keep_prob", "=", "t_dropout_keep_prob", ")", "\n", "dec_cell", "=", "tf", ".", "contrib", ".", "rnn", ".", "DropoutWrapper", "(", "dec_cell", ",", "output_keep_prob", "=", "t_dropout_keep_prob", ")", "\n", "\n", "", "encoder_inputs", "=", "[", "train_inputs", "[", ":", ",", "k", "]", "for", "k", "in", "range", "(", "0", ",", "X_maxlen", ")", "]", "\n", "\n", "# the first token for decoder inputs is always the <GO> token and the last one from train outputs is not needed", "\n", "decoder_inputs", "=", "(", "[", "tf", ".", "fill", "(", "[", "batch_size", "]", ",", "output_vocab", ".", "word_to_index", "(", "Vocabulary", ".", "GO_TOK", ")", ")", "]", "\n", "+", "[", "train_outputs", "[", ":", ",", "k", "]", "for", "k", "in", "range", "(", "0", ",", "Y_maxlen", ")", "]", "[", "0", ":", "-", "1", "]", ")", "\n", "\n", "# embed a raw vector into a 32 value vector", "\n", "enc_embeds", "=", "[", "tf", ".", "nn", ".", "embedding_lookup", "(", "enc_embedding", ",", "enc_input", ")", "for", "enc_input", "in", "encoder_inputs", "]", "\n", "stacked_enc_embeds", "=", "tf", ".", "transpose", "(", "tf", ".", "stack", "(", "enc_embeds", ")", ",", "[", "1", ",", "2", ",", "0", "]", ")", "\n", "\n", "# embed a raw vector into a 32 value vector", "\n", "dec_embedding", "=", "tf", ".", "get_variable", "(", "\"dec_embedding\"", ",", "initializer", "=", "tf", ".", "random_uniform", "(", "[", "output_vocab", ".", "size", ",", "embedding_size", "]", ",", "-", "1.0", ",", "1", ")", ")", "\n", "# perform lookup based on types of the last decoder cell, note that <GO> symol is always looked up by embedding ", "\n", "dec_embeds", "=", "[", "tf", ".", "nn", ".", "embedding_lookup", "(", "dec_embedding", ",", "x", ")", "if", "i", "==", "0", "or", "decoder_type", "[", "i", "-", "1", "]", ".", "ty", "is", "DecoderType", ".", "Projector", "\n", "else", "tf", ".", "squeeze", "(", "tf", ".", "matmul", "(", "stacked_enc_embeds", ",", "\n", "tf", ".", "expand_dims", "(", "tf", ".", "one_hot", "(", "x", ",", "stacked_enc_embeds", ".", "get_shape", "(", ")", "[", "-", "1", "]", ")", ",", "-", "1", ")", ")", ",", "-", "1", ")", "\n", "for", "i", ",", "x", "in", "enumerate", "(", "decoder_inputs", ")", "]", "\n", "\n", "print", "(", "\"Loss function is {}\"", ".", "format", "(", "value_based_loss", ")", ")", "\n", "\n", "reshaped_input_mask", "=", "tf", ".", "unstack", "(", "tf", ".", "transpose", "(", "train_input_mask", ",", "[", "1", ",", "0", "]", ")", ")", "\n", "\n", "def", "feed_prev_func", "(", "prev", ",", "current_decoder_type", ")", ":", "\n", "# the feeding function", "\n", "            ", "if", "current_decoder_type", ".", "ty", "is", "DecoderType", ".", "Projector", ":", "\n", "# in this case prev is the output vector repr", "\n", "                ", "prev_symbol", "=", "math_ops", ".", "argmax", "(", "prev", ",", "1", ")", "\n", "emb_prev", "=", "tf", ".", "nn", ".", "embedding_lookup", "(", "dec_embedding", ",", "prev_symbol", ")", "\n", "", "elif", "current_decoder_type", ".", "ty", "is", "DecoderType", ".", "Pointer", ":", "\n", "# in this case prev is the energy function for pointers ", "\n", "\n", "                ", "logits_n_inputs", "=", "tf", ".", "concat", "(", "[", "tf", ".", "expand_dims", "(", "prev", ",", "-", "2", ")", ",", "\n", "tf", ".", "cast", "(", "tf", ".", "expand_dims", "(", "train_inputs", ",", "-", "2", ")", ",", "tf", ".", "float32", ")", "]", ",", "\n", "-", "2", ")", "\n", "\n", "if", "value_based_loss", "==", "\"sum_vloss\"", ":", "\n", "                    ", "transferred_distrib", "=", "tf", ".", "map_fn", "(", "lambda", "x", ":", "tf", ".", "unsorted_segment_sum", "(", "x", "[", "0", "]", ",", "tf", ".", "cast", "(", "x", "[", "1", "]", ",", "tf", ".", "int32", ")", ",", "input_vocab", ".", "size", ")", ",", "logits_n_inputs", ")", "\n", "", "elif", "value_based_loss", "==", "\"max_vloss\"", "or", "value_based_loss", "==", "\"ploss\"", ":", "\n", "                    ", "transferred_distrib", "=", "tf", ".", "map_fn", "(", "lambda", "x", ":", "tf", ".", "unsorted_segment_max", "(", "x", "[", "0", "]", ",", "tf", ".", "cast", "(", "x", "[", "1", "]", ",", "tf", ".", "int32", ")", ",", "input_vocab", ".", "size", ")", ",", "logits_n_inputs", ")", "\n", "\n", "", "emb_prev", "=", "tf", ".", "nn", ".", "embedding_lookup", "(", "enc_embedding", ",", "tf", ".", "argmax", "(", "transferred_distrib", ",", "-", "1", ")", ")", "\n", "return", "emb_prev", "\n", "", "else", ":", "\n", "                ", "raise", "Exception", "(", "'not a expected type'", ")", "\n", "\n", "", "return", "emb_prev", "\n", "\n", "", "outs", "=", "pointer_network", "(", "enc_embeds", ",", "dec_embeds", ",", "\n", "fw_enc_cell", ",", "bw_enc_cell", ",", "dec_cell", ",", "\n", "decoder_type", ",", "output_vocab", ".", "size", ",", "\n", "encoder_masks", "=", "reshaped_input_mask", ",", "\n", "feed_prev", "=", "seq2seq_feed_previous", ",", "\n", "loop_function", "=", "feed_prev_func", ",", "\n", "multi_encoders", "=", "multi_encoders", ",", "\n", "encoder_merge_method", "=", "encoder_merge_method", ")", "\n", "\n", "\n", "# split train outs into train outs for projection and train outs for pointer", "\n", "# and concretize pointer in the tensor into labels", "\n", "pointer_train_outs", ",", "proj_train_outs", "=", "split_by_type", "(", "train_outputs", ",", "decoder_type", ",", "axis", "=", "1", ")", "\n", "pointer_out_mask", ",", "proj_out_mask", "=", "split_by_type", "(", "train_output_mask", ",", "decoder_type", ",", "axis", "=", "1", ")", "\n", "pntr_dec_types", "=", "[", "x", "for", "x", "in", "decoder_type", "if", "x", ".", "ty", "==", "DecoderType", ".", "Pointer", "]", "\n", "\n", "def", "_process_outs", "(", "outs", ",", "target_type", ")", ":", "\n", "            ", "\"\"\" reshape outs into shape (batch_size, type_num, X_maxlen) for the purpose of computing \"\"\"", "\n", "cnt", "=", "len", "(", "[", "i", "for", "i", "in", "range", "(", "len", "(", "outs", ")", ")", "if", "decoder_type", "[", "i", "]", ".", "ty", "is", "target_type", "]", ")", "\n", "if", "cnt", "==", "0", ":", "\n", "                ", "target_outs", "=", "tf", ".", "reshape", "(", "[", "]", ",", "[", "batch_size", ",", "cnt", ",", "X_maxlen", "]", ")", "\n", "", "else", ":", "\n", "                ", "trimed_outs", "=", "[", "outs", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "outs", ")", ")", "if", "decoder_type", "[", "i", "]", ".", "ty", "is", "target_type", "]", "\n", "# outputs from the seq2seq model is already logits", "\n", "target_outs", "=", "trimed_outs", "\n", "", "return", "target_outs", "\n", "\n", "\n", "", "proj_outs", "=", "tf", ".", "transpose", "(", "_process_outs", "(", "outs", ",", "DecoderType", ".", "Projector", ")", ",", "perm", "=", "[", "1", ",", "0", ",", "2", "]", ")", "\n", "\n", "pointer_outs", "=", "_process_outs", "(", "outs", ",", "DecoderType", ".", "Pointer", ")", "\n", "pointer_outs", "=", "[", "pointer_outs", "[", "i", "]", "*", "tf", ".", "cast", "(", "type_masks", "[", "pntr_dec_types", "[", "i", "]", ".", "mask_name", "]", ",", "tf", ".", "float32", ")", "for", "i", "in", "range", "(", "len", "(", "pntr_dec_types", ")", ")", "]", "\n", "pointer_outs", "=", "tf", ".", "transpose", "(", "pointer_outs", ",", "perm", "=", "[", "1", ",", "0", ",", "2", "]", ")", "\n", "\n", "# predictions made by the neural network", "\n", "pointer_predictions", "=", "tf", ".", "nn", ".", "softmax", "(", "pointer_outs", ")", "\n", "\n", "proj_predictions", "=", "tf", ".", "nn", ".", "softmax", "(", "proj_outs", ")", "\n", "\n", "# labels predicted from the result (sharpen), get encoder symbols from the ", "\n", "proj_predicted_labels", "=", "tf", ".", "cast", "(", "tf", ".", "argmax", "(", "proj_predictions", ",", "axis", "=", "-", "1", ")", ",", "tf", ".", "int32", ")", "\n", "\n", "# prepare data for energy transfer", "\n", "copied_train_inputs", "=", "tf", ".", "transpose", "(", "tf", ".", "stack", "(", "[", "train_inputs", "for", "x", "in", "range", "(", "int", "(", "pointer_train_outs", ".", "get_shape", "(", ")", "[", "-", "1", "]", ")", ")", "]", ")", ",", "[", "1", ",", "0", ",", "2", "]", ")", "\n", "merged_logits_inputs", "=", "tf", ".", "concat", "(", "[", "tf", ".", "expand_dims", "(", "pointer_predictions", ",", "-", "2", ")", ",", "\n", "tf", ".", "cast", "(", "tf", ".", "expand_dims", "(", "copied_train_inputs", ",", "-", "2", ")", ",", "tf", ".", "float32", ")", "]", ",", "\n", "-", "2", ")", "\n", "\n", "# transfer distribution over pointer to distribution over encoder symbols", "\n", "if", "value_based_loss", "==", "\"sum_vloss\"", ":", "\n", "            ", "distrib_over_encoder_symbols", "=", "tf", ".", "map_fn", "(", "lambda", "y", ":", "tf", ".", "map_fn", "(", "lambda", "x", ":", "tf", ".", "unsorted_segment_sum", "(", "x", "[", "0", "]", ",", "tf", ".", "cast", "(", "x", "[", "1", "]", ",", "tf", ".", "int32", ")", ",", "input_vocab", ".", "size", ")", ",", "y", ")", ",", "\n", "merged_logits_inputs", ")", "\n", "", "elif", "value_based_loss", "==", "\"max_vloss\"", "or", "value_based_loss", "==", "\"ploss\"", ":", "\n", "            ", "distrib_over_encoder_symbols", "=", "tf", ".", "map_fn", "(", "lambda", "y", ":", "tf", ".", "map_fn", "(", "lambda", "x", ":", "tf", ".", "unsorted_segment_max", "(", "x", "[", "0", "]", ",", "tf", ".", "cast", "(", "x", "[", "1", "]", ",", "tf", ".", "int32", ")", ",", "input_vocab", ".", "size", ")", ",", "y", ")", ",", "\n", "merged_logits_inputs", ")", "\n", "\n", "", "labels_by_pointers", "=", "tf", ".", "cast", "(", "tf", ".", "argmax", "(", "distrib_over_encoder_symbols", ",", "axis", "=", "-", "1", ")", ",", "tf", ".", "int32", ")", "\n", "\n", "predicted_labels", "=", "assemble_by_type", "(", "labels_by_pointers", ",", "proj_predicted_labels", ",", "decoder_type", ",", "axis", "=", "1", ")", "\n", "\n", "if", "explicit_pointer", ":", "\n", "            ", "pointer_predicted_labels", "=", "tf", ".", "cast", "(", "tf", ".", "argmax", "(", "pointer_predictions", ",", "axis", "=", "-", "1", ")", ",", "tf", ".", "int32", ")", "\n", "# compute accuracy with pointers, since pointers are explicitly provided in the dataset", "\n", "token_accuracy", ",", "sentence_accuracy", "=", "compute_accuracy", "(", "pointer_predicted_labels", ",", "pointer_train_outs", ",", "\n", "proj_predicted_labels", ",", "proj_train_outs", ",", "\n", "pointer_out_mask", ",", "proj_out_mask", ")", "\n", "", "else", ":", "\n", "# compute accuracy with concrete labels instead of pointers ", "\n", "# (computing based on labels is better since we only care about the final result)", "\n", "            ", "token_accuracy", ",", "sentence_accuracy", "=", "compute_accuracy", "(", "labels_by_pointers", ",", "\n", "pointer_to_label", "(", "pointer_train_outs", ",", "train_inputs", ")", ",", "\n", "proj_predicted_labels", ",", "proj_train_outs", ",", "\n", "pointer_out_mask", ",", "proj_out_mask", ")", "\n", "\n", "", "token_accuracy", "=", "tf", ".", "identity", "(", "token_accuracy", ",", "name", "=", "\"token_accuracy\"", ")", "\n", "sentence_accuracy", "=", "tf", ".", "identity", "(", "sentence_accuracy", ",", "name", "=", "\"sentence_accuracy\"", ")", "\n", "predicted_labels", "=", "tf", ".", "identity", "(", "predicted_labels", ",", "name", "=", "\"predicted_labels\"", ")", "\n", "\n", "# the loss function", "\n", "if", "value_based_loss", "==", "\"sum_vloss\"", "or", "value_based_loss", "==", "\"max_vloss\"", ":", "\n", "# loss based on probability of ", "\n", "            ", "one_hot_train_out", "=", "tf", ".", "one_hot", "(", "pointer_to_label", "(", "pointer_train_outs", ",", "train_inputs", ")", ",", "input_vocab", ".", "size", ",", "axis", "=", "-", "1", ")", "\n", "# this clip is used to handle nan problem in calculation", "\n", "pntr_losses", "=", "-", "tf", ".", "reduce_sum", "(", "one_hot_train_out", "*", "tf", ".", "log", "(", "tf", ".", "clip_by_value", "(", "distrib_over_encoder_symbols", ",", "1e-10", ",", "1.0", ")", ")", ",", "-", "1", ")", "\n", "", "elif", "value_based_loss", "==", "\"ploss\"", ":", "\n", "            ", "pntr_losses", "=", "tf", ".", "nn", ".", "sparse_softmax_cross_entropy_with_logits", "(", "labels", "=", "pointer_train_outs", ",", "logits", "=", "pointer_outs", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"Loss function ({}) can not be recognized, exiting...\"", ".", "format", "(", "value_based_loss", ")", ")", "\n", "sys", ".", "exit", "(", "-", "1", ")", "\n", "\n", "# TODO: add a mask to remove losses from padding symbols", "\n", "", "proj_losses", "=", "tf", ".", "nn", ".", "sparse_softmax_cross_entropy_with_logits", "(", "labels", "=", "proj_train_outs", ",", "logits", "=", "proj_outs", ")", "\n", "\n", "# the loss hould be normalized by the total number of unmasked cells", "\n", "total_loss", "=", "tf", ".", "add", "(", "tf", ".", "reduce_sum", "(", "tf", ".", "multiply", "(", "pntr_losses", ",", "tf", ".", "cast", "(", "pointer_out_mask", ",", "tf", ".", "float32", ")", ")", ")", ",", "\n", "tf", ".", "reduce_sum", "(", "tf", ".", "multiply", "(", "proj_losses", ",", "tf", ".", "cast", "(", "proj_out_mask", ",", "tf", ".", "float32", ")", ")", ")", ",", "\n", "name", "=", "\"total_loss\"", ")", "\n", "\n", "var_dict", "=", "{", "\n", "\"train_inputs\"", ":", "train_inputs", ".", "name", ",", "\n", "\"train_outputs\"", ":", "train_outputs", ".", "name", ",", "\n", "\"train_input_mask\"", ":", "train_input_mask", ".", "name", ",", "\n", "\"train_output_mask\"", ":", "train_output_mask", ".", "name", ",", "\n", "\"seq2seq_feed_previous\"", ":", "seq2seq_feed_previous", ".", "name", ",", "\n", "\"token_accuracy\"", ":", "token_accuracy", ".", "name", ",", "\n", "\"sentence_accuracy\"", ":", "sentence_accuracy", ".", "name", ",", "\n", "\"predicted_labels\"", ":", "predicted_labels", ".", "name", ",", "\n", "\"total_loss\"", ":", "total_loss", ".", "name", ",", "\n", "\"type_masks\"", ":", "type_masks", ".", "name", "\n", "}", "\n", "\n", "", "return", "graph", ",", "var_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.__init__": [[10, 17], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\" initialize an empty vocab \"\"\"", "\n", "self", ".", "vocab", "=", "[", "]", "\n", "self", ".", "size", "=", "0", "\n", "self", ".", "word_index", "=", "{", "}", "\n", "self", ".", "index_word", "=", "{", "}", "\n", "self", ".", "use_unk", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.word_to_index": [[18, 23], ["print"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print"], ["", "def", "word_to_index", "(", "self", ",", "word", ")", ":", "\n", "        ", "if", "(", "self", ".", "use_unk", "and", "word", "not", "in", "self", ".", "word_index", ")", ":", "\n", "            ", "print", "(", "\"[Warning] Word {} is not found in the vocabulary, <UNK> is used as a substitute.\"", ".", "format", "(", "word", ")", ")", "\n", "return", "self", ".", "word_index", "[", "Vocabulary", ".", "UNK_TOK", "]", "\n", "", "return", "self", ".", "word_index", "[", "word", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.index_to_word": [[24, 26], ["None"], "methods", ["None"], ["", "def", "index_to_word", "(", "self", ",", "index", ")", ":", "\n", "        ", "return", "self", ".", "index_word", "[", "index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.build_from_words": [[27, 48], ["util.Vocabulary", "sorted", "len", "enumerate", "Vocabulary.vocab.append", "Vocabulary.vocab.append"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "build_from_words", "(", "words", ",", "use_go_tok", "=", "False", ",", "use_unk", "=", "False", ")", ":", "\n", "        ", "\"\"\" build vocabulary from all words we want to include \"\"\"", "\n", "vocab", "=", "Vocabulary", "(", ")", "\n", "\n", "vocab", ".", "vocab", "=", "[", "Vocabulary", ".", "END_TOK", "]", "\n", "if", "use_go_tok", ":", "\n", "            ", "vocab", ".", "vocab", ".", "append", "(", "Vocabulary", ".", "GO_TOK", ")", "\n", "", "if", "use_unk", ":", "\n", "            ", "vocab", ".", "use_unk", "=", "True", "\n", "vocab", ".", "vocab", ".", "append", "(", "Vocabulary", ".", "UNK_TOK", ")", "\n", "\n", "", "vocab", ".", "vocab", "+=", "sorted", "(", "words", ")", "\n", "vocab", ".", "size", "=", "len", "(", "vocab", ".", "vocab", ")", "\n", "\n", "# build index", "\n", "for", "(", "i", ",", "v", ")", "in", "enumerate", "(", "vocab", ".", "vocab", ")", ":", "\n", "            ", "vocab", ".", "word_index", "[", "v", "]", "=", "i", "\n", "vocab", ".", "index_word", "[", "i", "]", "=", "v", "\n", "\n", "", "return", "vocab", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.build_from_sentences": [[49, 73], ["util.Vocabulary.build_from_words"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.build_from_words"], ["", "@", "staticmethod", "\n", "def", "build_from_sentences", "(", "sentences", ",", "use_go_tok", "=", "False", ",", "use_unk", "=", "False", ",", "frequency_cap", "=", "-", "1", ")", ":", "\n", "        ", "\"\"\" Build vocabulary from a sentence list\n            Args:\n                sentences <list(str)>: the list of sentences, each sentence is a list of wors\n                use_go_tok: whether <GO> tok will be included\n                use_unk: whether <UNK> symbol will be used\n                frequency_cap: words appear less frequent than frequency_cap \n                               will not be included in the vocabulary\n            Returns:\n                a Vocabulary object build from the sentences\n        \"\"\"", "\n", "used_words", "=", "{", "}", "\n", "\n", "for", "sentence", "in", "sentences", ":", "\n", "            ", "for", "s", "in", "sentence", ":", "\n", "                ", "if", "s", "in", "used_words", ":", "\n", "                    ", "used_words", "[", "s", "]", "+=", "1", "\n", "", "else", ":", "\n", "                    ", "used_words", "[", "s", "]", "=", "1", "\n", "\n", "", "", "", "words", "=", "[", "s", "for", "s", "in", "used_words", "if", "used_words", "[", "s", "]", ">", "frequency_cap", "]", "\n", "\n", "return", "Vocabulary", ".", "build_from_words", "(", "words", ",", "use_go_tok", ",", "use_unk", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.sequence_to_vec": [[74, 76], ["util.Vocabulary.word_to_index"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.word_to_index"], ["", "def", "sequence_to_vec", "(", "self", ",", "sentence", ")", ":", "\n", "        ", "return", "[", "self", ".", "word_to_index", "(", "s", ")", "for", "s", "in", "sentence", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.vec_to_sequence": [[77, 79], ["None"], "methods", ["None"], ["", "def", "vec_to_sequence", "(", "self", ",", "indvec", ")", ":", "\n", "        ", "return", "[", "self", ".", "index_word", "[", "ind", "]", "for", "ind", "in", "indvec", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.GloVeEmbeddings.__init__": [[85, 106], ["open", "f.readlines", "line.split", "numpy.array", "print", "len", "len", "float"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print"], ["    ", "def", "__init__", "(", "self", ",", "emb_file", ",", "d_emb", "=", "-", "1", ",", "default", "=", "\"zero\"", ")", ":", "\n", "        ", "self", ".", "embeddings", "=", "{", "}", "\n", "self", ".", "d_emb", "=", "d_emb", "\n", "self", ".", "default", "=", "default", "\n", "\n", "full_emb_size", "=", "-", "1", "\n", "with", "open", "(", "emb_file", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ".", "readlines", "(", ")", ":", "\n", "                ", "l", "=", "line", ".", "split", "(", ")", "\n", "# the word is in the beginning of the list", "\n", "word", "=", "l", "[", "0", "]", "\n", "if", "self", ".", "d_emb", "==", "-", "1", ":", "\n", "                    ", "self", ".", "d_emb", "=", "len", "(", "l", ")", "-", "1", "\n", "", "if", "full_emb_size", "==", "-", "1", ":", "\n", "                    ", "full_emb_size", "=", "len", "(", "l", ")", "-", "1", "\n", "# only get d_emb size vector from the embedding", "\n", "", "vec", "=", "np", ".", "array", "(", "[", "float", "(", "x", ")", "for", "x", "in", "l", "[", "-", "self", ".", "d_emb", ":", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "embeddings", "[", "word", "]", "=", "vec", "\n", "", "if", "self", ".", "d_emb", "!=", "full_emb_size", ":", "\n", "                ", "print", "(", "\"[Warning] Full embedding size is {}, larger than specified embedding size {}.\"", "\n", ".", "format", "(", "full_emb_size", ",", "self", ".", "d_emb", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.GloVeEmbeddings.emb": [[107, 119], ["get_default", "random.uniform", "range"], "methods", ["None"], ["", "", "", "def", "emb", "(", "self", ",", "word", ")", ":", "\n", "        ", "\"\"\" embed a word using the GloVe embedding\"\"\"", "\n", "get_default", "=", "{", "\n", "'none'", ":", "lambda", ":", "None", ",", "\n", "'zero'", ":", "lambda", ":", "0.", ",", "\n", "'random'", ":", "lambda", ":", "random", ".", "uniform", "(", "-", "0.1", ",", "0.1", ")", ",", "\n", "}", "[", "self", ".", "default", "]", "\n", "if", "word", "in", "self", ".", "embeddings", ":", "\n", "            ", "g", "=", "self", ".", "embeddings", "[", "word", "]", "\n", "", "else", ":", "\n", "            ", "g", "=", "None", "\n", "", "return", "[", "get_default", "(", ")", "for", "i", "in", "range", "(", "self", ".", "d_emb", ")", "]", "if", "g", "is", "None", "else", "g", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.JmtEmbeddings.__init__": [[131, 150], ["open", "f.readlines", "line.split", "numpy.array", "print", "len", "len", "float"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print"], ["    ", "def", "__init__", "(", "self", ",", "emb_file", ",", "d_emb", "=", "-", "1", ")", ":", "\n", "        ", "self", ".", "embeddings", "=", "{", "}", "\n", "self", ".", "d_emb", "=", "d_emb", "\n", "full_emb_size", "=", "-", "1", "\n", "\n", "with", "open", "(", "emb_file", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ".", "readlines", "(", ")", ":", "\n", "                ", "l", "=", "line", ".", "split", "(", ")", "\n", "ngram", "=", "l", "[", "0", "]", "\n", "if", "self", ".", "d_emb", "==", "-", "1", ":", "\n", "                    ", "self", ".", "d_emb", "=", "len", "(", "l", ")", "-", "1", "\n", "", "if", "full_emb_size", "==", "-", "1", ":", "\n", "                    ", "full_emb_size", "=", "len", "(", "l", ")", "-", "1", "\n", "", "vec", "=", "np", ".", "array", "(", "[", "float", "(", "x", ")", "for", "x", "in", "l", "[", "-", "self", ".", "d_emb", ":", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "embeddings", "[", "ngram", "]", "=", "vec", "\n", "\n", "", "if", "self", ".", "d_emb", "!=", "full_emb_size", ":", "\n", "                ", "print", "(", "\"[Warning] Full embedding size is {}, larger than specified embedding size {}.\"", "\n", ".", "format", "(", "full_emb_size", ",", "self", ".", "d_emb", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.JmtEmbeddings.emb": [[151, 165], ["numpy.zeros", "numpy.zeros.tolist", "util.ngrams", "list", "sum", "len", "numpy.array", "match.values"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.ngrams"], ["", "", "", "def", "emb", "(", "self", ",", "word", ")", ":", "\n", "        ", "\"\"\" embedding a word using n-gram \"\"\"", "\n", "chars", "=", "[", "'#BEGIN#'", "]", "+", "list", "(", "word", ")", "+", "[", "'#END#'", "]", "\n", "embs", "=", "np", ".", "zeros", "(", "self", ".", "d_emb", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "match", "=", "{", "}", "\n", "for", "i", "in", "[", "2", ",", "3", ",", "4", "]", ":", "\n", "            ", "grams", "=", "ngrams", "(", "chars", ",", "i", ")", "\n", "for", "g", "in", "grams", ":", "\n", "                ", "g", "=", "'{}gram-{}'", ".", "format", "(", "i", ",", "''", ".", "join", "(", "g", ")", ")", "\n", "if", "g", "in", "self", ".", "embeddings", ":", "\n", "                    ", "match", "[", "g", "]", "=", "np", ".", "array", "(", "self", ".", "embeddings", "[", "g", "]", ",", "np", ".", "float32", ")", "\n", "", "", "", "if", "match", ":", "\n", "            ", "embs", "=", "sum", "(", "match", ".", "values", "(", ")", ")", "/", "len", "(", "match", ")", "\n", "", "return", "embs", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.ngrams": [[121, 127], ["range", "len"], "function", ["None"], ["", "", "def", "ngrams", "(", "sentence", ",", "n", ")", ":", "\n", "    ", "\"\"\"\n    Returns:\n        list: a list of lists of words corresponding to the ngrams in the sentence.\n    \"\"\"", "\n", "return", "[", "sentence", "[", "i", ":", "i", "+", "n", "]", "for", "i", "in", "range", "(", "len", "(", "sentence", ")", "-", "n", "+", "1", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetVocab.__init__": [[13, 21], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "input_vocab", ",", "output_vocab", ",", "X_maxlen", ",", "Y_maxlen", ",", "X_seg_maxlen", ")", ":", "\n", "    ", "self", ".", "input_vocab", "=", "input_vocab", "\n", "self", ".", "output_vocab", "=", "output_vocab", "\n", "self", ".", "X_maxlen", "=", "X_maxlen", "\n", "self", ".", "Y_maxlen", "=", "Y_maxlen", "\n", "\n", "# the maximum length for different parts of the query", "\n", "self", ".", "X_seg_maxlen", "=", "X_seg_maxlen", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetVocab.get_stats": [[22, 28], ["None"], "methods", ["None"], ["", "def", "get_stats", "(", "self", ")", ":", "\n", "    ", "return", "{", "\n", "\"input_vocab_size\"", ":", "self", ".", "input_vocab", ".", "size", ",", "\n", "\"output_vocab_size\"", ":", "self", ".", "output_vocab", ".", "size", ",", "\n", "\"X_maxlen\"", ":", "self", ".", "X_maxlen", ",", "\n", "\"Y_maxlen\"", ":", "self", ".", "Y_maxlen", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetVocab.build_from_dataset": [[30, 63], ["model.util.Vocabulary.build_from_sentences", "model.util.Vocabulary.build_from_sentences", "len", "len", "pointer_net_helper.PnetVocab", "len", "len", "enumerate"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.build_from_sentences", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.build_from_sentences"], ["", "@", "staticmethod", "\n", "def", "build_from_dataset", "(", "dataset", ",", "decoder_type", ",", "frequency_cap", "=", "-", "1", ")", ":", "\n", "    ", "\"\"\" build a vocabulary out of the provided dataset \"\"\"", "\n", "input_vocab", "=", "Vocabulary", ".", "build_from_sentences", "(", "[", "entry", "[", "\"in\"", "]", "for", "entry", "in", "dataset", "]", ",", "\n", "use_unk", "=", "False", ",", "\n", "frequency_cap", "=", "frequency_cap", ")", "\n", "# the one below only considers words in the projectors", "\n", "output_vocab", "=", "Vocabulary", ".", "build_from_sentences", "(", "[", "[", "v", "for", "i", ",", "v", "in", "enumerate", "(", "entry", "[", "\"out\"", "]", ")", "\n", "if", "decoder_type", "[", "i", "]", ".", "ty", "==", "DecoderType", ".", "Projector", "]", "for", "entry", "in", "\n", "dataset", "]", ",", "\n", "use_go_tok", "=", "True", ")", "\n", "\n", "X_maxlen", "=", "len", "(", "dataset", "[", "0", "]", "[", "\"in\"", "]", ")", "\n", "Y_maxlen", "=", "len", "(", "dataset", "[", "0", "]", "[", "\"out\"", "]", ")", "\n", "output_length_fixed", "=", "True", "\n", "\n", "for", "entry", "in", "dataset", ":", "\n", "      ", "input_len", "=", "len", "(", "entry", "[", "\"in\"", "]", ")", "\n", "if", "X_maxlen", "<", "input_len", ":", "\n", "        ", "X_maxlen", "=", "input_len", "\n", "\n", "", "output_len", "=", "len", "(", "entry", "[", "\"out\"", "]", ")", "\n", "if", "Y_maxlen", "!=", "output_len", ":", "\n", "        ", "output_length_fixed", "=", "False", "\n", "", "if", "Y_maxlen", "<", "output_len", ":", "\n", "        ", "Y_maxlen", "=", "output_len", "\n", "\n", "# if output length every input / output will be enhanced with a end-token", "\n", "", "", "if", "not", "output_length_fixed", ":", "\n", "      ", "X_maxlen", "=", "X_maxlen", "+", "1", "\n", "Y_maxlen", "=", "Y_maxlen", "+", "1", "\n", "\n", "", "return", "PnetVocab", "(", "input_vocab", ",", "output_vocab", ",", "X_maxlen", ",", "Y_maxlen", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetVocab.get_all": [[64, 67], ["None"], "methods", ["None"], ["", "def", "get_all", "(", "self", ")", ":", "\n", "    ", "\"\"\" get all specs from the vocab \"\"\"", "\n", "return", "self", ".", "input_vocab", ",", "self", ".", "output_vocab", ",", "self", ".", "X_maxlen", ",", "self", ".", "Y_maxlen", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetVocab.prepare_input_data_only": [[68, 81], ["np.zeros", "range", "len", "range", "range", "len", "len", "input_vocab.word_to_index", "len", "input_vocab.word_to_index"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.word_to_index", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.word_to_index"], ["", "def", "prepare_input_data_only", "(", "self", ",", "dataset", ")", ":", "\n", "    ", "\"\"\" build a vocabulary out of the provided dataset \"\"\"", "\n", "input_vocab", "=", "self", ".", "input_vocab", "\n", "X_maxlen", "=", "self", ".", "X_maxlen", "\n", "\n", "Xs", "=", "np", ".", "zeros", "(", "(", "len", "(", "dataset", ")", ",", "X_maxlen", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "dataset", ")", ")", ":", "\n", "      ", "for", "j", "in", "range", "(", "len", "(", "dataset", "[", "i", "]", "[", "\"in\"", "]", ")", ")", ":", "\n", "        ", "Xs", "[", "i", "]", "[", "j", "]", "=", "input_vocab", ".", "word_to_index", "(", "dataset", "[", "i", "]", "[", "\"in\"", "]", "[", "j", "]", ")", "\n", "", "for", "j", "in", "range", "(", "len", "(", "dataset", "[", "i", "]", "[", "\"in\"", "]", ")", ",", "X_maxlen", ")", ":", "\n", "        ", "Xs", "[", "i", "]", "[", "j", "]", "=", "input_vocab", ".", "word_to_index", "(", "Vocabulary", ".", "END_TOK", ")", "\n", "\n", "", "", "return", "Xs", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetVocab.prepare_pointer_data": [[82, 158], ["pointer_net_helper.PnetVocab.get_all", "np.zeros", "np.zeros", "np.zeros", "np.zeros", "np.zeros", "range", "len", "range", "range", "len", "len", "len", "len", "len", "len", "len", "input_vocab.word_to_index", "len", "input_vocab.word_to_index", "range", "range", "input_vocab.word_to_index", "len", "len", "output_vocab.word_to_index", "output_vocab.word_to_index", "len", "len", "[].index", "int"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetVocab.get_all", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.word_to_index", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.word_to_index", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.word_to_index", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.word_to_index", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.word_to_index"], ["", "def", "prepare_pointer_data", "(", "self", ",", "dataset", ",", "decoder_type", ",", "explicit_pointer", ")", ":", "\n", "    ", "\"\"\" Prepare training input output and mask for the task, decoder type specifies the type of the decoder\n            Args:\n                dataset: the dataset used for training and testing, each entry is a dict containing entry[\"in\"] and entry[\"out\"]\n                decoder_type: types of decoders (pointer/projector)\n                explicit_pointer: whether pointers are explicited represented in the output sequences.\n                    If not, we need to manually convert values to pointers, by looking up values in the output in the input\n            Returns:\n                prepare data together with some of their arguments\n        \"\"\"", "\n", "input_vocab", ",", "output_vocab", ",", "X_maxlen", ",", "Y_maxlen", "=", "self", ".", "get_all", "(", ")", "\n", "\n", "Xs", "=", "np", ".", "zeros", "(", "(", "len", "(", "dataset", ")", ",", "X_maxlen", ")", ")", "\n", "Ys", "=", "np", ".", "zeros", "(", "(", "len", "(", "dataset", ")", ",", "Y_maxlen", ")", ")", "\n", "XMasks", "=", "np", ".", "zeros", "(", "(", "len", "(", "dataset", ")", ",", "X_maxlen", ")", ",", "dtype", "=", "bool", ")", "\n", "YMasks", "=", "np", ".", "zeros", "(", "(", "len", "(", "dataset", ")", ",", "Y_maxlen", ")", ",", "dtype", "=", "bool", ")", "\n", "\n", "mask_functions", "=", "{", "}", "\n", "for", "dec_ty", "in", "decoder_type", ":", "\n", "      ", "if", "dec_ty", ".", "mask_name", "is", "not", "None", "and", "dec_ty", ".", "mask_name", "not", "in", "mask_functions", ":", "\n", "        ", "mask_functions", "[", "dec_ty", ".", "mask_name", "]", "=", "dec_ty", ".", "mask_fn", "\n", "\n", "", "", "type_masks", "=", "np", ".", "zeros", "(", "(", "len", "(", "mask_functions", ")", ",", "len", "(", "dataset", ")", ",", "X_maxlen", ")", ",", "dtype", "=", "bool", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "dataset", ")", ")", ":", "\n", "\n", "      ", "for", "j", "in", "range", "(", "len", "(", "dataset", "[", "i", "]", "[", "\"in\"", "]", ")", ")", ":", "\n", "        ", "Xs", "[", "i", "]", "[", "j", "]", "=", "input_vocab", ".", "word_to_index", "(", "dataset", "[", "i", "]", "[", "\"in\"", "]", "[", "j", "]", ")", "\n", "# in some cases pads are included in the input sequence,", "\n", "# we should mask them explicitly as padding tokens", "\n", "if", "Xs", "[", "i", "]", "[", "j", "]", "!=", "input_vocab", ".", "word_to_index", "(", "Vocabulary", ".", "END_TOK", ")", ":", "\n", "          ", "XMasks", "[", "i", "]", "[", "j", "]", "=", "True", "\n", "", "else", ":", "\n", "          ", "XMasks", "[", "i", "]", "[", "j", "]", "=", "False", "\n", "\n", "# padding: rest of the input are filled with special token", "\n", "", "", "for", "j", "in", "range", "(", "len", "(", "dataset", "[", "i", "]", "[", "\"in\"", "]", ")", ",", "X_maxlen", ")", ":", "\n", "        ", "Xs", "[", "i", "]", "[", "j", "]", "=", "input_vocab", ".", "word_to_index", "(", "Vocabulary", ".", "END_TOK", ")", "\n", "XMasks", "[", "i", "]", "[", "j", "]", "=", "False", "\n", "\n", "# setup type masks", "\n", "", "for", "k", "in", "mask_functions", ":", "\n", "        ", "type_masks", "[", "k", "]", "[", "i", "]", "=", "mask_functions", "[", "k", "]", "(", "Xs", "[", "i", "]", ")", "\n", "\n", "", "if", "\"out\"", "in", "dataset", "[", "i", "]", ":", "\n", "# note that input to cell j is the output from cell j-1", "\n", "        ", "for", "j", "in", "range", "(", "0", ",", "len", "(", "dataset", "[", "i", "]", "[", "\"out\"", "]", ")", ")", ":", "\n", "          ", "if", "decoder_type", "[", "j", "]", ".", "ty", "==", "DecoderType", ".", "Projector", ":", "\n", "            ", "Ys", "[", "i", "]", "[", "j", "]", "=", "output_vocab", ".", "word_to_index", "(", "dataset", "[", "i", "]", "[", "\"out\"", "]", "[", "j", "]", ")", "\n", "", "elif", "decoder_type", "[", "j", "]", ".", "ty", "==", "DecoderType", ".", "Pointer", ":", "\n", "            ", "if", "not", "explicit_pointer", ":", "\n", "# if pointers are not explicitly presented in the sequence, we need to manually lookup pointers", "\n", "# print(dataset[i][\"in\"])", "\n", "# print(dataset[i][\"out\"])", "\n", "# print(\"\")", "\n", "              ", "Ys", "[", "i", "]", "[", "j", "]", "=", "dataset", "[", "i", "]", "[", "\"in\"", "]", ".", "index", "(", "dataset", "[", "i", "]", "[", "\"out\"", "]", "[", "j", "]", ")", "\n", "", "else", ":", "\n", "              ", "Ys", "[", "i", "]", "[", "j", "]", "=", "int", "(", "dataset", "[", "i", "]", "[", "\"out\"", "]", "[", "j", "]", ")", "\n", "", "", "YMasks", "[", "i", "]", "[", "j", "]", "=", "True", "\n", "\n", "# padding: rest of the input are filled with special token", "\n", "", "for", "j", "in", "range", "(", "len", "(", "dataset", "[", "i", "]", "[", "\"out\"", "]", ")", ",", "Y_maxlen", ")", ":", "\n", "          ", "if", "decoder_type", "[", "j", "]", ".", "ty", "==", "DecoderType", ".", "Projector", ":", "\n", "            ", "Ys", "[", "i", "]", "[", "j", "]", "=", "output_vocab", ".", "word_to_index", "(", "Vocabulary", ".", "END_TOK", ")", "\n", "", "elif", "decoder_type", "[", "j", "]", ".", "ty", "==", "DecoderType", ".", "Pointer", ":", "\n", "            ", "Ys", "[", "i", "]", "[", "j", "]", "=", "len", "(", "dataset", "[", "i", "]", "[", "\"in\"", "]", ")", "# points to the ending of the input token", "\n", "\n", "", "if", "j", "==", "len", "(", "dataset", "[", "i", "]", "[", "\"out\"", "]", ")", ":", "\n", "            ", "YMasks", "[", "i", "]", "[", "j", "]", "=", "True", "\n", "", "else", ":", "\n", "            ", "YMasks", "[", "i", "]", "[", "j", "]", "=", "False", "\n", "", "", "", "else", ":", "\n", "        ", "Ys", "=", "None", "\n", "YMasks", "=", "None", "\n", "\n", "", "", "return", "Xs", ",", "Ys", ",", "XMasks", ",", "YMasks", ",", "type_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.__init__": [[162, 166], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "decoder_type", ",", "pnet_vocab", ")", ":", "\n", "    ", "\"\"\" create a printer instance based on decoder_type and pnet_vocab \"\"\"", "\n", "self", ".", "decoder_type", "=", "decoder_type", "\n", "self", ".", "pnet_vocab", "=", "pnet_vocab", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.output_seq_to_sentence": [[167, 175], ["output_vocab.index_to_word", "enumerate", "int", "int"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.index_to_word"], ["", "@", "staticmethod", "\n", "def", "output_seq_to_sentence", "(", "output_vec", ",", "output_vocab", ",", "decoded_input", ",", "decoder_type", ")", ":", "\n", "    ", "\"\"\" Given a sequence of indices, print its represented sentence (according to decoder type)\n        \"\"\"", "\n", "return", "[", "output_vocab", ".", "index_to_word", "(", "int", "(", "x", ")", ")", "\n", "if", "decoder_type", "[", "i", "]", ".", "ty", "==", "DecoderType", ".", "Projector", "\n", "else", "decoded_input", "[", "int", "(", "x", ")", "]", "\n", "for", "i", ",", "x", "in", "enumerate", "(", "output_vec", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.output_seq_to_sentence_by_input_vocab": [[176, 184], ["output_vocab.index_to_word", "input_vocab.index_to_word", "enumerate", "int", "int"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.index_to_word", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.index_to_word"], ["", "@", "staticmethod", "\n", "def", "output_seq_to_sentence_by_input_vocab", "(", "output_vec", ",", "output_vocab", ",", "input_vocab", ",", "decoder_type", ")", ":", "\n", "    ", "\"\"\" Given a sequence of indices, print its represented sentence (according to decoder type)\n        \"\"\"", "\n", "return", "[", "output_vocab", ".", "index_to_word", "(", "int", "(", "x", ")", ")", "\n", "if", "decoder_type", "[", "i", "]", ".", "ty", "==", "DecoderType", ".", "Projector", "\n", "else", "input_vocab", ".", "index_to_word", "(", "int", "(", "x", ")", ")", "\n", "for", "i", ",", "x", "in", "enumerate", "(", "output_vec", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.remove_end_suffix": [[185, 194], ["result.append", "result.append"], "methods", ["None"], ["", "def", "remove_end_suffix", "(", "self", ",", "sentence", ")", ":", "\n", "    ", "result", "=", "[", "]", "\n", "for", "x", "in", "sentence", ":", "\n", "      ", "if", "x", "==", "Vocabulary", ".", "END_TOK", ":", "\n", "        ", "result", ".", "append", "(", "x", ")", "\n", "break", "\n", "", "else", ":", "\n", "        ", "result", ".", "append", "(", "x", ")", "\n", "", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print": [[195, 234], ["range", "min", "pointer_net_helper.PnetExPrinter.pnet_vocab.input_vocab.vec_to_sequence", "pointer_net_helper.PnetExPrinter.print"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.vec_to_sequence", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print"], ["", "def", "print", "(", "self", ",", "Xs", ",", "Ys", ",", "predictions", ",", "k", "=", "5", ")", ":", "\n", "    ", "def", "_remove_padding", "(", "sentence", ",", "cut_off", "=", "True", ")", ":", "\n", "      ", "result", "=", "[", "]", "\n", "for", "x", "in", "sentence", ":", "\n", "        ", "if", "Vocabulary", ".", "END_TOK", "in", "x", ":", "\n", "          ", "if", "cut_off", ":", "\n", "            ", "result", ".", "append", "(", "x", ")", "\n", "break", "\n", "", "else", ":", "\n", "            ", "result", ".", "append", "(", "\"\"", ")", "\n", "continue", "\n", "", "", "else", ":", "\n", "          ", "result", ".", "append", "(", "x", ")", "\n", "", "", "return", "result", "\n", "\n", "", "outputs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "min", "(", "k", ",", "len", "(", "Xs", ")", ")", ")", ":", "\n", "\n", "      ", "ap", "=", "self", ".", "pnet_vocab", ".", "input_vocab", ".", "vec_to_sequence", "(", "Xs", "[", "i", "]", ")", "\n", "x_out", "=", "\" \"", ".", "join", "(", "_remove_padding", "(", "ap", ",", "cut_off", "=", "False", ")", ")", "\n", "\n", "print", "(", "\"X = \"", ",", "x_out", ")", "\n", "\n", "if", "Ys", "is", "not", "None", ":", "\n", "# Ys is not always available", "\n", "        ", "bp", "=", "PnetExPrinter", ".", "output_seq_to_sentence", "(", "Ys", "[", "i", "]", ",", "self", ".", "pnet_vocab", ".", "output_vocab", ",", "ap", ",", "self", ".", "decoder_type", ")", "\n", "y_out", "=", "\" \"", ".", "join", "(", "_remove_padding", "(", "bp", ")", ")", "\n", "print", "(", "\"Y = \"", ",", "y_out", ")", "\n", "", "else", ":", "\n", "        ", "y_out", "=", "None", "\n", "\n", "", "cp", "=", "PnetExPrinter", ".", "output_seq_to_sentence_by_input_vocab", "(", "predictions", "[", "i", "]", ",", "self", ".", "pnet_vocab", ".", "output_vocab", ",", "\n", "self", ".", "pnet_vocab", ".", "input_vocab", ",", "self", ".", "decoder_type", ")", "\n", "p_out", "=", "\" \"", ".", "join", "(", "_remove_padding", "(", "cp", ")", ")", "\n", "\n", "print", "(", "\"P = \"", ",", "p_out", ")", "\n", "outputs", ".", "append", "(", "(", "x_out", ",", "y_out", ",", "p_out", ")", ")", "\n", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.assemble_by_type": [[236, 259], ["int", "int", "range", "tf.gather", "tf.concat", "pointer_tensor.get_shape", "proj_tensor.get_shape", "gather_indices.append", "gather_indices.append"], "function", ["None"], ["", "", "def", "assemble_by_type", "(", "pointer_tensor", ",", "proj_tensor", ",", "decoder_type", ",", "axis", ")", ":", "\n", "  ", "\"\"\" merge decoding result by type, (proj/pointer)\n        Args:\n            pointer_tensor of shape (batch_size, pointer_len, V)\n            proj_tensor of shape (batch_size, proj_len, V)\n        Returns:\n            combined tensor (batch_size, proj_len + pointer_len, V)\n    \"\"\"", "\n", "pointer_len", "=", "int", "(", "pointer_tensor", ".", "get_shape", "(", ")", "[", "axis", "]", ")", "\n", "proj_len", "=", "int", "(", "proj_tensor", ".", "get_shape", "(", ")", "[", "axis", "]", ")", "\n", "\n", "gather_indices", "=", "[", "]", "\n", "pointer_next", "=", "0", "\n", "proj_next", "=", "0", "\n", "for", "i", "in", "range", "(", "pointer_len", "+", "proj_len", ")", ":", "\n", "    ", "if", "decoder_type", "[", "i", "]", ".", "ty", "==", "DecoderType", ".", "Pointer", ":", "\n", "      ", "gather_indices", ".", "append", "(", "pointer_next", ")", "\n", "pointer_next", "+=", "1", "\n", "", "elif", "decoder_type", "[", "i", "]", ".", "ty", "==", "DecoderType", ".", "Projector", ":", "\n", "      ", "gather_indices", ".", "append", "(", "proj_next", "+", "pointer_len", ")", "\n", "proj_next", "+=", "1", "\n", "\n", "", "", "return", "tf", ".", "gather", "(", "tf", ".", "concat", "(", "[", "pointer_tensor", ",", "proj_tensor", "]", ",", "axis", ")", ",", "gather_indices", ",", "axis", "=", "axis", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.split_by_type": [[261, 279], ["tf.cast", "tf.cast", "merged_tensor.get_shape", "tf.gather", "tf.gather", "range", "range"], "function", ["None"], ["", "def", "split_by_type", "(", "merged_tensor", ",", "decoder_type", ",", "axis", ")", ":", "\n", "  ", "\"\"\" Split train_outs data according to decoder type (proj/pointer)\n        Args:\n            (batch_size, proj_len + pointer_len, V)\n        Returns:\n            pointer_tensor of shape (batch_size, pointer_len, V)\n            proj_tensor of shape (batch_size, proj_len, V)\n    \"\"\"", "\n", "seq_length", "=", "merged_tensor", ".", "get_shape", "(", ")", "[", "axis", "]", "\n", "\n", "pointer_indices", "=", "[", "i", "for", "i", "in", "range", "(", "seq_length", ")", "if", "decoder_type", "[", "i", "]", ".", "ty", "is", "DecoderType", ".", "Pointer", "]", "\n", "proj_indices", "=", "[", "i", "for", "i", "in", "range", "(", "seq_length", ")", "if", "decoder_type", "[", "i", "]", ".", "ty", "is", "DecoderType", ".", "Projector", "]", "\n", "\n", "# casts are used to deal with the case of empty indice list", "\n", "pointer_indices", "=", "tf", ".", "cast", "(", "pointer_indices", ",", "tf", ".", "int32", ")", "\n", "proj_indices", "=", "tf", ".", "cast", "(", "proj_indices", ",", "tf", ".", "int32", ")", "\n", "\n", "return", "tf", ".", "gather", "(", "merged_tensor", ",", "pointer_indices", ",", "axis", "=", "axis", ")", ",", "tf", ".", "gather", "(", "merged_tensor", ",", "proj_indices", ",", "axis", "=", "axis", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.pointer_to_label": [[281, 293], ["tf.cast", "tf.squeeze", "tf.one_hot", "tf.matmul", "tf.expand_dims", "inputs.get_shape"], "function", ["None"], ["", "def", "pointer_to_label", "(", "pointers", ",", "inputs", ")", ":", "\n", "  ", "\"\"\" Given a list of pointers, lookup pointers in given inputs\n        Args:\n            pointers: pointers, each pointer points a location in the input, of shape (batch_size, pointer_len)\n            inputs: inputs sequence that the pointer points to, of shape (batch_size, input_len)\n        Returns:\n            The lookup result for pointers, i.e., dereference every pointer base on the inputs\n    \"\"\"", "\n", "onehot_pntr_repr", "=", "tf", ".", "cast", "(", "tf", ".", "one_hot", "(", "pointers", ",", "inputs", ".", "get_shape", "(", ")", "[", "-", "1", "]", ")", ",", "\n", "tf", ".", "int32", ")", "# of shape (batch_size, output_len, input_len)", "\n", "labels", "=", "tf", ".", "squeeze", "(", "tf", ".", "matmul", "(", "onehot_pntr_repr", ",", "tf", ".", "expand_dims", "(", "inputs", ",", "-", "1", ")", ")", ",", "-", "1", ")", "\n", "return", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.compute_accuracy": [[295, 319], ["pointer_net_helper.compute_accuracy._prepare_compute_accuracy"], "function", ["None"], ["", "def", "compute_accuracy", "(", "pntr_pred_label", ",", "pntr_train_label", ",", "proj_pred_label", ",", "proj_train_label", ",", "pntr_mask", ",", "proj_mask", ")", ":", "\n", "  ", "\"\"\" Calculate accuracy with the help of mask\n    \"\"\"", "\n", "def", "_prepare_compute_accuracy", "(", "pred_label", ",", "train_label", ",", "mask", ")", ":", "\n", "    ", "reversed_mask", "=", "tf", ".", "logical_not", "(", "mask", ")", "\n", "label_eq", "=", "tf", ".", "equal", "(", "pred_label", ",", "train_label", ")", "\n", "\n", "# a list that indicates whether a unmasked token is corrected predicted or not,", "\n", "# to calculate accuracy, perform a reduce over it", "\n", "pre_token_accuracy", "=", "tf", ".", "boolean_mask", "(", "label_eq", ",", "mask", ")", "\n", "pre_seq_accuracy", "=", "tf", ".", "reduce_all", "(", "tf", ".", "logical_or", "(", "label_eq", ",", "reversed_mask", ")", ",", "-", "1", ")", "\n", "\n", "return", "pre_token_accuracy", ",", "pre_seq_accuracy", "\n", "\n", "", "pntr_pre_token_accuracy", ",", "pntr_pre_seq_accuracy", "=", "_prepare_compute_accuracy", "(", "pntr_pred_label", ",", "pntr_train_label", ",", "\n", "pntr_mask", ")", "\n", "proj_pre_token_accuracy", ",", "proj_pre_seq_accuracy", "=", "_prepare_compute_accuracy", "(", "proj_pred_label", ",", "proj_train_label", ",", "\n", "proj_mask", ")", "\n", "\n", "token_accuracy", "=", "tf", ".", "reduce_mean", "(", "\n", "tf", ".", "cast", "(", "tf", ".", "concat", "(", "[", "pntr_pre_token_accuracy", ",", "proj_pre_token_accuracy", "]", ",", "axis", "=", "-", "1", ")", ",", "tf", ".", "float32", ")", ")", "\n", "seq_accuracy", "=", "tf", ".", "reduce_mean", "(", "tf", ".", "cast", "(", "tf", ".", "logical_and", "(", "pntr_pre_seq_accuracy", ",", "proj_pre_seq_accuracy", ")", ",", "tf", ".", "float32", ")", ")", "\n", "\n", "return", "token_accuracy", ",", "seq_accuracy", "", "", ""]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_graph_meta.construct_weights": [[30, 61], ["tf.get_variable", "tf.get_variable", "tf.get_variable", "tf.get_variable", "tf.get_variable", "tf.get_variable", "tf.get_variable", "tf.get_variable", "tf.get_variable", "tf.get_variable", "tf.get_variable", "tf.get_variable", "tf.random_uniform", "tf.constant_initializer", "tf.random_uniform"], "function", ["None"], ["def", "construct_weights", "(", "pretrained_enc_embedding", ",", "input_vocab", ",", "output_vocab", ",", "embedding_size", ",", "n_hidden", ")", ":", "\n", "  ", "weights", "=", "{", "}", "\n", "if", "pretrained_enc_embedding", "is", "not", "None", ":", "\n", "      ", "enc_embedding", "=", "tf", ".", "get_variable", "(", "\"enc_embedding\"", ",", "\n", "shape", "=", "[", "input_vocab", ".", "size", ",", "embedding_size", "]", ",", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "pretrained_enc_embedding", ")", ",", "\n", "trainable", "=", "False", ")", "\n", "", "else", ":", "\n", "    ", "enc_embedding", "=", "tf", ".", "get_variable", "(", "\"enc_embedding\"", ",", "\n", "initializer", "=", "tf", ".", "random_uniform", "(", "\n", "[", "input_vocab", ".", "size", ",", "embedding_size", "]", ",", "-", "1.0", ",", "1", ")", ")", "\n", "# embed a raw vector into a 32 value vector", "\n", "", "dec_embedding", "=", "tf", ".", "get_variable", "(", "\"dec_embedding\"", ",", "initializer", "=", "tf", ".", "random_uniform", "(", "\n", "[", "output_vocab", ".", "size", ",", "embedding_size", "]", ",", "-", "1.0", ",", "1", ")", ")", "\n", "\n", "weights", "[", "'enc_embedding'", "]", "=", "enc_embedding", "\n", "weights", "[", "'dec_embedding'", "]", "=", "dec_embedding", "\n", "\n", "weights", "[", "'decoder_W1'", "]", "=", "tf", ".", "get_variable", "(", "'W1'", ",", "shape", "=", "[", "n_hidden", "*", "2", ",", "n_hidden", "]", ")", "\n", "weights", "[", "'decoder_W2'", "]", "=", "tf", ".", "get_variable", "(", "'W2'", ",", "shape", "=", "[", "n_hidden", ",", "n_hidden", "]", ")", "\n", "weights", "[", "'decoder_Win'", "]", "=", "tf", ".", "get_variable", "(", "'Win'", ",", "shape", "=", "[", "4", "*", "n_hidden", ",", "n_hidden", "]", ")", "\n", "weights", "[", "'decoder_Wout'", "]", "=", "tf", ".", "get_variable", "(", "'Wout'", ",", "shape", "=", "[", "3", "*", "n_hidden", ",", "output_vocab", ".", "size", "]", ")", "\n", "weights", "[", "'decoder_Bin'", "]", "=", "tf", ".", "get_variable", "(", "'Bin'", ",", "shape", "=", "[", "n_hidden", "]", ")", "\n", "weights", "[", "'decoder_Bout'", "]", "=", "tf", ".", "get_variable", "(", "'Bout'", ",", "shape", "=", "[", "output_vocab", ".", "size", "]", ")", "\n", "\n", "weights", "[", "'decoder_v'", "]", "=", "tf", ".", "get_variable", "(", "'v'", ",", "shape", "=", "[", "n_hidden", "]", ")", "\n", "weights", "[", "'encoder_w_combine'", "]", "=", "tf", ".", "get_variable", "(", "'w_combine'", ",", "shape", "=", "[", "n_hidden", "*", "4", ",", "n_hidden", "]", ")", "\n", "weights", "[", "'encoder_b_combine'", "]", "=", "tf", ".", "get_variable", "(", "'b_combine'", ",", "shape", "=", "[", "n_hidden", "]", ")", "\n", "\n", "\n", "return", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_graph_meta.forward": [[63, 235], ["tf.variable_scope", "pnet_vocab.get_all", "tf.contrib.rnn.MultiRNNCell", "tf.contrib.rnn.MultiRNNCell", "tf.contrib.rnn.MultiRNNCell", "tf.transpose", "tf.unstack", "pointer_network", "split_by_type", "split_by_type", "tf.transpose", "pointer_net_graph_meta.forward._process_outs"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetVocab.get_all", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net.pointer_network", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.split_by_type", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.split_by_type"], ["", "def", "forward", "(", "inp", ",", "weights", ",", "decoder_type", ",", "explicit_pointer", ",", "value_based_loss", ",", "\n", "hyper_param", ",", "pnet_vocab", ",", "pretrained_enc_embedding", "=", "None", ",", "\n", "multi_encoders", "=", "None", ",", "old_graph", "=", "None", ",", "scope", "=", "None", ",", "reuse", "=", "False", ")", ":", "\n", "  ", "with", "tf", ".", "variable_scope", "(", "scope", "or", "'forward'", ",", "reuse", "=", "reuse", ")", ":", "\n", "    ", "train_inputs", ",", "train_input_mask", ",", "train_outputs", ",", "train_output_mask", ",", "seq2seq_feed_previous", ",", "type_masks", "=", "inp", "\n", "enc_embedding", ",", "dec_embedding", "=", "weights", "[", "'enc_embedding'", "]", ",", "weights", "[", "'dec_embedding'", "]", "\n", "\n", "batch_size", "=", "None", "\n", "n_hidden", "=", "hyper_param", "[", "\"n_hidden\"", "]", "\n", "num_layers", "=", "hyper_param", "[", "\"num_layers\"", "]", "\n", "dropout_keep_prob", "=", "hyper_param", "[", "\"dropout_keep_prob\"", "]", "\n", "encoder_merge_method", "=", "hyper_param", "[", "\"encoder_merge_method\"", "]", "\n", "input_vocab", ",", "output_vocab", ",", "X_maxlen", ",", "Y_maxlen", "=", "pnet_vocab", ".", "get_all", "(", ")", "\n", "\n", "fw_enc_cell", "=", "tf", ".", "contrib", ".", "rnn", ".", "MultiRNNCell", "(", "\n", "[", "tf", ".", "contrib", ".", "rnn", ".", "LSTMCell", "(", "n_hidden", ")", "for", "_", "in", "range", "(", "num_layers", ")", "]", ")", "\n", "bw_enc_cell", "=", "tf", ".", "contrib", ".", "rnn", ".", "MultiRNNCell", "(", "\n", "[", "tf", ".", "contrib", ".", "rnn", ".", "LSTMCell", "(", "n_hidden", ")", "for", "_", "in", "range", "(", "num_layers", ")", "]", ")", "\n", "dec_cell", "=", "tf", ".", "contrib", ".", "rnn", ".", "MultiRNNCell", "(", "\n", "[", "tf", ".", "contrib", ".", "rnn", ".", "LSTMCell", "(", "n_hidden", ")", "for", "_", "in", "range", "(", "num_layers", ")", "]", ")", "\n", "\n", "if", "dropout_keep_prob", "<", "1", ":", "\n", "        ", "t_dropout_keep_prob", "=", "tf", ".", "cond", "(", "seq2seq_feed_previous", ",", "lambda", ":", "1.", ",", "lambda", ":", "dropout_keep_prob", ")", "\n", "# the cell used in the model", "\n", "fw_enc_cell", "=", "tf", ".", "contrib", ".", "rnn", ".", "DropoutWrapper", "(", "fw_enc_cell", ",", "output_keep_prob", "=", "t_dropout_keep_prob", ")", "\n", "bw_enc_cell", "=", "tf", ".", "contrib", ".", "rnn", ".", "DropoutWrapper", "(", "bw_enc_cell", ",", "output_keep_prob", "=", "t_dropout_keep_prob", ")", "\n", "dec_cell", "=", "tf", ".", "contrib", ".", "rnn", ".", "DropoutWrapper", "(", "dec_cell", ",", "output_keep_prob", "=", "t_dropout_keep_prob", ")", "\n", "\n", "", "encoder_inputs", "=", "[", "train_inputs", "[", ":", ",", "k", "]", "for", "k", "in", "range", "(", "0", ",", "X_maxlen", ")", "]", "\n", "# the first token for decoder inputs is always the <GO> token and the last one from train", "\n", "# outputs is not needed", "\n", "batch_size", "=", "tf", ".", "shape", "(", "train_inputs", ")", "[", "0", "]", "\n", "decoder_inputs", "=", "(", "[", "tf", ".", "fill", "(", "[", "batch_size", "]", ",", "output_vocab", ".", "word_to_index", "(", "Vocabulary", ".", "GO_TOK", ")", ")", "]", "\n", "+", "[", "train_outputs", "[", ":", ",", "k", "]", "for", "k", "in", "range", "(", "0", ",", "Y_maxlen", ")", "]", "[", "0", ":", "-", "1", "]", ")", "\n", "\n", "# embed a raw vector into a 32 value vector", "\n", "enc_embeds", "=", "[", "tf", ".", "nn", ".", "embedding_lookup", "(", "enc_embedding", ",", "enc_input", ")", "for", "enc_input", "in", "encoder_inputs", "]", "\n", "stacked_enc_embeds", "=", "tf", ".", "transpose", "(", "tf", ".", "stack", "(", "enc_embeds", ")", ",", "[", "1", ",", "2", ",", "0", "]", ")", "\n", "\n", "# embed a raw vector into a 32 value vector", "\n", "# dec_embedding = tf.get_variable(\"dec_embedding\", initializer=tf.random_uniform(", "\n", "#   [output_vocab.size, embedding_size], -1.0, 1))", "\n", "# perform lookup based on types of the last decoder cell, note that <GO> symol is always", "\n", "# looked up by embedding", "\n", "dec_embeds", "=", "[", "tf", ".", "nn", ".", "embedding_lookup", "(", "dec_embedding", ",", "x", ")", "if", "i", "==", "0", "or", "decoder_type", "[", "\n", "i", "-", "1", "]", ".", "ty", "is", "\n", "DecoderType", ".", "Projector", "\n", "else", "tf", ".", "squeeze", "(", "tf", ".", "matmul", "(", "stacked_enc_embeds", ",", "\n", "tf", ".", "expand_dims", "(", "tf", ".", "one_hot", "(", "x", ",", "stacked_enc_embeds", ".", "get_shape", "(", ")", "[", "-", "1", "]", ")", ",", "-", "1", ")", ")", ",", "-", "1", ")", "\n", "for", "i", ",", "x", "in", "enumerate", "(", "decoder_inputs", ")", "]", "\n", "\n", "reshaped_input_mask", "=", "tf", ".", "unstack", "(", "tf", ".", "transpose", "(", "train_input_mask", ",", "[", "1", ",", "0", "]", ")", ")", "\n", "\n", "def", "feed_prev_func", "(", "prev", ",", "current_decoder_type", ")", ":", "\n", "# the feeding function", "\n", "      ", "if", "current_decoder_type", ".", "ty", "is", "DecoderType", ".", "Projector", ":", "\n", "# in this case prev is the output vector repr", "\n", "        ", "prev_symbol", "=", "math_ops", ".", "argmax", "(", "prev", ",", "1", ")", "\n", "emb_prev", "=", "tf", ".", "nn", ".", "embedding_lookup", "(", "dec_embedding", ",", "prev_symbol", ")", "\n", "", "elif", "current_decoder_type", ".", "ty", "is", "DecoderType", ".", "Pointer", ":", "\n", "# in this case prev is the energy function for pointers", "\n", "        ", "logits_n_inputs", "=", "tf", ".", "concat", "(", "[", "tf", ".", "expand_dims", "(", "prev", ",", "-", "2", ")", ",", "\n", "tf", ".", "cast", "(", "tf", ".", "expand_dims", "(", "train_inputs", ",", "-", "2", ")", ",", "tf", ".", "float32", ")", "]", ",", "-", "2", ")", "\n", "\n", "if", "value_based_loss", "==", "\"sum_vloss\"", ":", "\n", "            ", "transferred_distrib", "=", "tf", ".", "map_fn", "(", "lambda", "x", ":", "tf", ".", "unsorted_segment_sum", "(", "x", "[", "0", "]", ",", "tf", ".", "cast", "(", "x", "[", "1", "]", ",", "tf", ".", "int32", ")", ",", "input_vocab", ".", "size", ")", ",", "logits_n_inputs", ")", "\n", "", "elif", "value_based_loss", "==", "\"max_vloss\"", "or", "value_based_loss", "==", "\"ploss\"", ":", "\n", "            ", "transferred_distrib", "=", "tf", ".", "map_fn", "(", "lambda", "x", ":", "tf", ".", "unsorted_segment_max", "(", "x", "[", "0", "]", ",", "tf", ".", "cast", "(", "x", "[", "1", "]", ",", "tf", ".", "int32", ")", ",", "input_vocab", ".", "size", ")", ",", "logits_n_inputs", ")", "\n", "\n", "", "emb_prev", "=", "tf", ".", "nn", ".", "embedding_lookup", "(", "enc_embedding", ",", "tf", ".", "argmax", "(", "transferred_distrib", ",", "-", "1", ")", ")", "\n", "\n", "return", "emb_prev", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "'not a expected type'", ")", "\n", "\n", "", "return", "emb_prev", "\n", "\n", "", "outs", "=", "pointer_network", "(", "enc_embeds", ",", "dec_embeds", ",", "\n", "fw_enc_cell", ",", "bw_enc_cell", ",", "dec_cell", ",", "\n", "decoder_type", ",", "output_vocab", ".", "size", ",", "\n", "encoder_masks", "=", "reshaped_input_mask", ",", "\n", "feed_prev", "=", "seq2seq_feed_previous", ",", "\n", "loop_function", "=", "feed_prev_func", ",", "\n", "multi_encoders", "=", "multi_encoders", ",", "\n", "encoder_merge_method", "=", "encoder_merge_method", ",", "weights", "=", "weights", ")", "\n", "\n", "# split train outs into train outs for projection and train outs for pointer", "\n", "# and concretize pointer in the tensor into labels", "\n", "pointer_train_outs", ",", "proj_train_outs", "=", "split_by_type", "(", "train_outputs", ",", "decoder_type", ",", "axis", "=", "1", ")", "\n", "pointer_out_mask", ",", "proj_out_mask", "=", "split_by_type", "(", "train_output_mask", ",", "decoder_type", ",", "axis", "=", "1", ")", "\n", "pntr_dec_types", "=", "[", "x", "for", "x", "in", "decoder_type", "if", "x", ".", "ty", "==", "DecoderType", ".", "Pointer", "]", "\n", "\n", "def", "_process_outs", "(", "outs", ",", "target_type", ")", ":", "\n", "      ", "\"\"\" reshape outs into shape (batch_size, type_num, X_maxlen) for the purpose of computing \"\"\"", "\n", "cnt", "=", "len", "(", "[", "i", "for", "i", "in", "range", "(", "len", "(", "outs", ")", ")", "if", "decoder_type", "[", "i", "]", ".", "ty", "is", "target_type", "]", ")", "\n", "if", "cnt", "==", "0", ":", "\n", "        ", "target_outs", "=", "tf", ".", "reshape", "(", "[", "]", ",", "[", "batch_size", ",", "cnt", ",", "X_maxlen", "]", ")", "\n", "", "else", ":", "\n", "# outputs from the seq2seq model is already logits", "\n", "        ", "trimed_outs", "=", "[", "outs", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "outs", ")", ")", "if", "decoder_type", "[", "i", "]", ".", "ty", "is", "target_type", "]", "\n", "target_outs", "=", "trimed_outs", "\n", "", "return", "target_outs", "\n", "\n", "", "proj_outs", "=", "tf", ".", "transpose", "(", "_process_outs", "(", "outs", ",", "DecoderType", ".", "Projector", ")", ",", "perm", "=", "[", "1", ",", "0", ",", "2", "]", ")", "\n", "pointer_outs", "=", "_process_outs", "(", "outs", ",", "DecoderType", ".", "Pointer", ")", "\n", "pointer_outs", "=", "[", "pointer_outs", "[", "i", "]", "*", "tf", ".", "cast", "(", "type_masks", "[", "pntr_dec_types", "[", "i", "]", ".", "mask_name", "]", ",", "tf", ".", "float32", ")", "for", "i", "in", "\n", "range", "(", "len", "(", "pntr_dec_types", ")", ")", "]", "\n", "pointer_outs", "=", "tf", ".", "transpose", "(", "pointer_outs", ",", "perm", "=", "[", "1", ",", "0", ",", "2", "]", ")", "\n", "\n", "# predictions made by the neural network", "\n", "pointer_predictions", "=", "tf", ".", "nn", ".", "softmax", "(", "pointer_outs", ")", "\n", "proj_predictions", "=", "tf", ".", "nn", ".", "softmax", "(", "proj_outs", ")", "\n", "\n", "# labels predicted from the result (sharpen), get encoder symbols from the", "\n", "proj_predicted_labels", "=", "tf", ".", "cast", "(", "tf", ".", "argmax", "(", "proj_predictions", ",", "axis", "=", "-", "1", ")", ",", "tf", ".", "int32", ")", "\n", "\n", "#### the one below returns the pointer location in the input,", "\n", "####  the one above returns the token id for valued being pointed to", "\n", "\n", "# prepare data for energy transfer", "\n", "copied_train_inputs", "=", "tf", ".", "transpose", "(", "\n", "tf", ".", "stack", "(", "[", "train_inputs", "for", "x", "in", "range", "(", "int", "(", "pointer_train_outs", ".", "get_shape", "(", ")", "[", "-", "1", "]", ")", ")", "]", ")", ",", "[", "1", ",", "0", ",", "2", "]", ")", "\n", "merged_logits_inputs", "=", "tf", ".", "concat", "(", "[", "tf", ".", "expand_dims", "(", "pointer_predictions", ",", "-", "2", ")", ",", "\n", "tf", ".", "cast", "(", "tf", ".", "expand_dims", "(", "copied_train_inputs", ",", "-", "2", ")", ",", "tf", ".", "float32", ")", "]", ",", "\n", "-", "2", ")", "\n", "# transfer distribution over pointer to distribution over encoder symbols", "\n", "if", "value_based_loss", "==", "\"sum_vloss\"", ":", "\n", "        ", "distrib_over_encoder_symbols", "=", "tf", ".", "map_fn", "(", "lambda", "y", ":", "tf", ".", "map_fn", "(", "lambda", "x", ":", "tf", ".", "unsorted_segment_sum", "(", "x", "[", "0", "]", ",", "tf", ".", "cast", "(", "x", "[", "1", "]", ",", "tf", ".", "int32", ")", ",", "input_vocab", ".", "size", ")", ",", "y", ")", ",", "\n", "merged_logits_inputs", ")", "\n", "", "elif", "value_based_loss", "==", "\"max_vloss\"", "or", "value_based_loss", "==", "\"ploss\"", ":", "\n", "        ", "distrib_over_encoder_symbols", "=", "tf", ".", "map_fn", "(", "lambda", "y", ":", "tf", ".", "map_fn", "(", "lambda", "x", ":", "tf", ".", "unsorted_segment_max", "(", "x", "[", "0", "]", ",", "tf", ".", "cast", "(", "x", "[", "1", "]", ",", "tf", ".", "int32", ")", ",", "input_vocab", ".", "size", ")", ",", "y", ")", ",", "\n", "merged_logits_inputs", ")", "\n", "\n", "", "labels_by_pointers", "=", "tf", ".", "cast", "(", "tf", ".", "argmax", "(", "distrib_over_encoder_symbols", ",", "axis", "=", "-", "1", ")", ",", "tf", ".", "int32", ")", "\n", "\n", "predicted_labels", "=", "assemble_by_type", "(", "labels_by_pointers", ",", "proj_predicted_labels", ",", "decoder_type", ",", "\n", "axis", "=", "1", ")", "\n", "\n", "if", "explicit_pointer", ":", "\n", "      ", "pointer_predicted_labels", "=", "tf", ".", "cast", "(", "tf", ".", "argmax", "(", "pointer_predictions", ",", "axis", "=", "-", "1", ")", ",", "tf", ".", "int32", ")", "\n", "# compute accuracy with pointers, since pointers are explicitly provided in the dataset", "\n", "token_accuracy", ",", "sentence_accuracy", "=", "compute_accuracy", "(", "pointer_predicted_labels", ",", "\n", "pointer_train_outs", ",", "\n", "proj_predicted_labels", ",", "proj_train_outs", ",", "\n", "pointer_out_mask", ",", "proj_out_mask", ")", "\n", "", "else", ":", "\n", "# compute accuracy with concrete labels instead of pointers", "\n", "# (computing based on labels is better since we only care about the final result)", "\n", "      ", "token_accuracy", ",", "sentence_accuracy", "=", "compute_accuracy", "(", "labels_by_pointers", ",", "\n", "pointer_to_label", "(", "pointer_train_outs", ",", "\n", "train_inputs", ")", ",", "\n", "proj_predicted_labels", ",", "proj_train_outs", ",", "\n", "pointer_out_mask", ",", "proj_out_mask", ")", "\n", "\n", "# the loss function", "\n", "", "if", "value_based_loss", "==", "\"sum_vloss\"", "or", "value_based_loss", "==", "\"max_vloss\"", ":", "\n", "# loss based on probability of ", "\n", "        ", "one_hot_train_out", "=", "tf", ".", "one_hot", "(", "pointer_to_label", "(", "pointer_train_outs", ",", "train_inputs", ")", ",", "input_vocab", ".", "size", ",", "axis", "=", "-", "1", ")", "\n", "# this clip is used to handle nan problem in calculation", "\n", "pntr_losses", "=", "-", "tf", ".", "reduce_sum", "(", "one_hot_train_out", "*", "tf", ".", "log", "(", "tf", ".", "clip_by_value", "(", "distrib_over_encoder_symbols", ",", "1e-10", ",", "1.0", ")", ")", ",", "-", "1", ")", "\n", "", "elif", "value_based_loss", "==", "\"ploss\"", ":", "\n", "        ", "pntr_losses", "=", "tf", ".", "nn", ".", "softmax_cross_entropy_with_logits", "(", "labels", "=", "tf", ".", "one_hot", "(", "pointer_train_outs", ",", "tf", ".", "shape", "(", "pointer_outs", ")", "[", "2", "]", ")", ",", "logits", "=", "pointer_outs", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "\"Loss function ({}) can not be recognized, exiting...\"", ".", "format", "(", "value_based_loss", ")", ")", "\n", "sys", ".", "exit", "(", "-", "1", ")", "\n", "\n", "", "proj_losses", "=", "tf", ".", "nn", ".", "softmax_cross_entropy_with_logits", "(", "labels", "=", "tf", ".", "one_hot", "(", "proj_train_outs", ",", "output_vocab", ".", "size", ")", ",", "\n", "logits", "=", "proj_outs", ")", "\n", "total_loss", "=", "tf", ".", "add", "(", "tf", ".", "reduce_sum", "(", "tf", ".", "multiply", "(", "pntr_losses", ",", "tf", ".", "cast", "(", "pointer_out_mask", ",", "tf", ".", "float32", ")", ")", ")", ",", "\n", "tf", ".", "reduce_sum", "(", "tf", ".", "multiply", "(", "proj_losses", ",", "tf", ".", "cast", "(", "proj_out_mask", ",", "tf", ".", "float32", ")", ")", ")", ",", "\n", "name", "=", "\"total_loss\"", ")", "\n", "return", "total_loss", ",", "token_accuracy", ",", "sentence_accuracy", ",", "predicted_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_graph_meta.build_graph": [[238, 345], ["pnet_vocab.get_all", "tf.Graph", "tf.Graph.as_default", "tf.variable_scope", "pointer_net_graph_meta.construct_weights", "tf.placeholder", "tf.placeholder", "tf.placeholder", "tf.placeholder", "tf.placeholder", "tf.placeholder", "tf.placeholder", "tf.placeholder", "tf.placeholder", "tf.placeholder", "tf.placeholder", "tf.placeholder", "tf.placeholder", "pointer_net_graph_meta.forward", "tf.gradients", "dict", "pointer_net_graph_meta.forward", "tf.identity", "tf.identity", "tf.identity", "tf.identity", "list", "zip", "dict", "dict", "construct_weights.values", "tf.stop_gradient", "construct_weights.keys", "zip", "zip", "construct_weights.keys", "construct_weights.keys", "tf.cond", "construct_weights.keys", "tf.scatter_sub", "construct_weights.keys"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetVocab.get_all", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_graph_meta.construct_weights", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_graph_meta.forward", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_graph_meta.forward"], ["", "", "def", "build_graph", "(", "decoder_type", ",", "explicit_pointer", ",", "value_based_loss", ",", "\n", "hyper_param", ",", "pnet_vocab", ",", "pretrained_enc_embedding", "=", "None", ",", "\n", "multi_encoders", "=", "None", ",", "old_graph", "=", "None", ",", "scope", "=", "None", ",", "input_switch", "=", "False", ")", ":", "\n", "  ", "\"\"\" Build a graph \"\"\"", "\n", "# hyper parameter", "\n", "embedding_size", "=", "hyper_param", "[", "\"embedding_size\"", "]", "\n", "batch_size", "=", "None", "\n", "learning_rate", "=", "hyper_param", "[", "\"meta_learning_rate\"", "]", "\n", "n_hidden", "=", "hyper_param", "[", "\"n_hidden\"", "]", "\n", "stop_grad", "=", "True", "\n", "\n", "\n", "input_vocab", ",", "output_vocab", ",", "X_maxlen", ",", "Y_maxlen", "=", "pnet_vocab", ".", "get_all", "(", ")", "\n", "\n", "graph", "=", "tf", ".", "Graph", "(", ")", "\n", "\n", "# scope should only be used after graph is defined", "\n", "with", "graph", ".", "as_default", "(", ")", ",", "tf", ".", "variable_scope", "(", "scope", "or", "\"graph\"", ")", "as", "scope", ":", "\n", "    ", "weights", "=", "construct_weights", "(", "pretrained_enc_embedding", ",", "input_vocab", "=", "input_vocab", ",", "\n", "output_vocab", "=", "output_vocab", ",", "embedding_size", "=", "embedding_size", ",", "n_hidden", "=", "n_hidden", ")", "\n", "\n", "# Input (Put reference set)", "\n", "train_inputs", "=", "tf", ".", "placeholder", "(", "tf", ".", "int32", ",", "[", "batch_size", ",", "X_maxlen", "]", ",", "name", "=", "\"train_inputs\"", ")", "\n", "# the mask for identifying padding tokens from the sentence", "\n", "train_input_mask", "=", "tf", ".", "placeholder", "(", "tf", ".", "bool", ",", "[", "batch_size", ",", "X_maxlen", "]", ",", "name", "=", "\"train_input_mask\"", ")", "\n", "train_outputs", "=", "tf", ".", "placeholder", "(", "tf", ".", "int32", ",", "[", "batch_size", ",", "Y_maxlen", "]", ",", "name", "=", "\"train_outputs\"", ")", "\n", "\n", "train_output_mask", "=", "tf", ".", "placeholder", "(", "tf", ".", "bool", ",", "[", "batch_size", ",", "Y_maxlen", "]", ",", "name", "=", "\"train_output_mask\"", ")", "\n", "type_masks", "=", "tf", ".", "placeholder", "(", "tf", ".", "bool", ",", "[", "2", ",", "batch_size", ",", "X_maxlen", "]", ",", "name", "=", "\"type_masks\"", ")", "\n", "\n", "seq2seq_feed_previous", "=", "tf", ".", "placeholder", "(", "tf", ".", "bool", ",", "name", "=", "\"seq2seq_feed_previous\"", ")", "\n", "\n", "# Input2 (Put test example of meta learning task)", "\n", "train_inputs_2", "=", "tf", ".", "placeholder", "(", "tf", ".", "int32", ",", "[", "batch_size", ",", "X_maxlen", "]", ",", "name", "=", "\"train_inputs_2\"", ")", "\n", "# the mask for identifying padding tokens from the sentence", "\n", "train_input_mask_2", "=", "tf", ".", "placeholder", "(", "tf", ".", "bool", ",", "[", "batch_size", ",", "X_maxlen", "]", ",", "name", "=", "\"train_input_mask_2\"", ")", "\n", "train_outputs_2", "=", "tf", ".", "placeholder", "(", "tf", ".", "int32", ",", "[", "batch_size", ",", "Y_maxlen", "]", ",", "name", "=", "\"train_outputs_2\"", ")", "\n", "\n", "train_output_mask_2", "=", "tf", ".", "placeholder", "(", "tf", ".", "bool", ",", "[", "batch_size", ",", "Y_maxlen", "]", ",", "\n", "name", "=", "\"train_output_mask_2\"", ")", "\n", "type_masks_2", "=", "tf", ".", "placeholder", "(", "tf", ".", "bool", ",", "[", "2", ",", "batch_size", ",", "X_maxlen", "]", ",", "name", "=", "\"type_masks_2\"", ")", "\n", "\n", "seq2seq_feed_previous_2", "=", "tf", ".", "placeholder", "(", "tf", ".", "bool", ",", "name", "=", "\"seq2seq_feed_previous_2\"", ")", "\n", "\n", "input_switch", "=", "tf", ".", "placeholder", "(", "tf", ".", "bool", ",", "name", "=", "\"input_switch\"", ")", "# true: use fast weights, false: use weights", "\n", "\n", "inp", "=", "train_inputs", ",", "train_input_mask", ",", "train_outputs", ",", "train_output_mask", ",", "seq2seq_feed_previous", ",", "type_masks", "\n", "inp_2", "=", "train_inputs_2", ",", "train_input_mask_2", ",", "train_outputs_2", ",", "train_output_mask_2", ",", "seq2seq_feed_previous_2", ",", "type_masks_2", "\n", "\n", "total_loss", ",", "_", ",", "_", ",", "_", "=", "forward", "(", "inp", ",", "weights", ",", "decoder_type", ",", "explicit_pointer", ",", "value_based_loss", ",", "\n", "hyper_param", ",", "pnet_vocab", ",", "pretrained_enc_embedding", ",", "\n", "multi_encoders", ",", "old_graph", ",", "scope", ",", "reuse", "=", "False", ")", "\n", "\n", "\n", "grads", "=", "tf", ".", "gradients", "(", "total_loss", ",", "list", "(", "weights", ".", "values", "(", ")", ")", ")", "\n", "if", "stop_grad", ":", "\n", "      ", "grads", "=", "[", "tf", ".", "stop_gradient", "(", "grad", ")", "for", "grad", "in", "grads", "]", "\n", "", "gradients", "=", "dict", "(", "zip", "(", "weights", ".", "keys", "(", ")", ",", "grads", ")", ")", "\n", "\n", "\n", "if", "stop_grad", ":", "\n", "      ", "fast_weights", "=", "dict", "(", "zip", "(", "weights", ".", "keys", "(", ")", ",", "\n", "[", "tf", ".", "cond", "(", "input_switch", ",", "lambda", ":", "weights", "[", "key", "]", "-", "learning_rate", "*", "gradients", "[", "key", "]", ",", "lambda", ":", "weights", "[", "key", "]", ")", "for", "key", "in", "weights", ".", "keys", "(", ")", "]", ")", ")", "\n", "", "else", ":", "\n", "      ", "fast_weights", "=", "dict", "(", "zip", "(", "weights", ".", "keys", "(", ")", ",", "\n", "[", "tf", ".", "scatter_sub", "(", "weights", "[", "key", "]", ",", "gradients", "[", "key", "]", ".", "indices", ",", "learning_rate", "*", "gradients", "[", "key", "]", ".", "values", ")", "if", "'embedding'", "in", "key", "\n", "else", "weights", "[", "key", "]", "-", "learning_rate", "*", "gradients", "[", "key", "]", "\n", "for", "key", "in", "weights", ".", "keys", "(", ")", "]", ")", ")", "\n", "\n", "", "total_loss_2", ",", "token_accuracy", ",", "sentence_accuracy", ",", "predicted_labels", "=", "forward", "(", "inp_2", ",", "fast_weights", ",", "\n", "decoder_type", ",", "\n", "explicit_pointer", ",", "\n", "value_based_loss", ",", "\n", "hyper_param", ",", "\n", "pnet_vocab", ",", "\n", "pretrained_enc_embedding", ",", "\n", "multi_encoders", ",", "\n", "old_graph", ",", "scope", ",", "\n", "reuse", "=", "True", ")", "\n", "token_accuracy", "=", "tf", ".", "identity", "(", "token_accuracy", ",", "name", "=", "\"token_accuracy\"", ")", "\n", "sentence_accuracy", "=", "tf", ".", "identity", "(", "sentence_accuracy", ",", "name", "=", "\"sentence_accuracy\"", ")", "\n", "predicted_labels", "=", "tf", ".", "identity", "(", "predicted_labels", ",", "name", "=", "\"predicted_labels\"", ")", "\n", "total_loss_2", "=", "tf", ".", "identity", "(", "total_loss_2", ",", "name", "=", "\"total_loss\"", ")", "\n", "\n", "\n", "var_dict", "=", "{", "\n", "\"train_inputs\"", ":", "train_inputs", ".", "name", ",", "\n", "\"train_outputs\"", ":", "train_outputs", ".", "name", ",", "\n", "\"train_input_mask\"", ":", "train_input_mask", ".", "name", ",", "\n", "\"train_output_mask\"", ":", "train_output_mask", ".", "name", ",", "\n", "\"seq2seq_feed_previous\"", ":", "seq2seq_feed_previous", ".", "name", ",", "\n", "\"train_inputs_2\"", ":", "train_inputs_2", ".", "name", ",", "\n", "\"train_outputs_2\"", ":", "train_outputs_2", ".", "name", ",", "\n", "\"train_input_mask_2\"", ":", "train_input_mask_2", ".", "name", ",", "\n", "\"train_output_mask_2\"", ":", "train_output_mask_2", ".", "name", ",", "\n", "\"seq2seq_feed_previous_2\"", ":", "seq2seq_feed_previous_2", ".", "name", ",", "\n", "\"token_accuracy\"", ":", "token_accuracy", ".", "name", ",", "\n", "\"sentence_accuracy\"", ":", "sentence_accuracy", ".", "name", ",", "\n", "\"predicted_labels\"", ":", "predicted_labels", ".", "name", ",", "\n", "\"total_loss\"", ":", "total_loss_2", ".", "name", ",", "\n", "\"type_masks\"", ":", "type_masks", ".", "name", ",", "\n", "\"type_masks_2\"", ":", "type_masks_2", ".", "name", ",", "\n", "'input_switch'", ":", "input_switch", ".", "name", "\n", "}", "\n", "\n", "", "return", "graph", ",", "var_dict", "\n", "", ""]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog_meta.NL2Prog_meta.__init__": [[44, 158], ["print", "print", "print", "model.pointer_net.DecoderType.from_regex", "model.pointer_net_helper.PnetVocab", "pprint.pprint.pprint", "model.pointer_net_helper.PnetExPrinter", "app.util.read_dataset", "_cut", "len", "app.util.read_dataset", "app.util.read_dataset", "len", "max", "max", "max", "numpy.array", "numpy.array", "model.pointer_net.DecoderType", "model.pointer_net.DecoderType", "model.pointer_net.DecoderType", "nl2prog_meta.concat_in1_in2", "model.util.Vocabulary.build_from_sentences", "model.util.Vocabulary.build_from_sentences", "model.util.Vocabulary.build_from_sentences", "model.util.Vocabulary.build_from_sentences", "model.pointer_net_helper.PnetVocab.get_stats", "_cut", "app.util.read_dataset", "_cut", "_cut", "int", "_cut", "_cut", "map", "map", "map", "_cut", "_cut", "app.util.read_dataset", "_cut", "app.util.read_dataset", "min", "len", "len", "len", "len", "range", "range", "range", "len", "range", "range", "len", "len"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net.DecoderType.from_regex", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.read_dataset", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.read_dataset", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.read_dataset", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.concat_in1_in2", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.build_from_sentences", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.build_from_sentences", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.build_from_sentences", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.build_from_sentences", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetVocab.get_stats", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.read_dataset", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.read_dataset", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.read_dataset"], ["def", "__init__", "(", "self", ",", "train_file", ",", "dev_file", ",", "test_file", ",", "settings", ",", "train_support_file", "=", "None", ",", "\n", "dev_support_file", "=", "None", ",", "test_support_file", "=", "None", ")", ":", "\n", "        ", "\"\"\" prepare memlookup task \"\"\"", "\n", "decoder_regex", "=", "settings", "[", "\"decoder_regex\"", "]", "\n", "explicit_pointer", "=", "settings", "[", "\"explicit_pointer\"", "]", "\n", "value_based_loss", "=", "settings", "[", "\"value_based_loss\"", "]", "\n", "num_data_used", "=", "settings", "[", "\"num_data_used\"", "]", "\n", "test_only", "=", "settings", "[", "\"test_only\"", "]", "\n", "train_support_dataset", ",", "dev_support_dataset", ",", "test_support_dataset", "=", "None", ",", "None", ",", "None", "\n", "\n", "_cut", "=", "lambda", "s", ":", "s", "[", ":", "min", "(", "len", "(", "s", ")", ",", "num_data_used", ")", "]", "if", "num_data_used", "is", "not", "None", "else", "s", "\n", "\n", "# prepare training and dev data", "\n", "if", "train_support_file", ":", "\n", "            ", "train_dataset", ",", "train_support_dataset", "=", "app", ".", "util", ".", "read_dataset", "(", "train_file", ",", "support_file_list", "=", "train_support_file", ",", "input_num", "=", "2", ")", "\n", "train_dataset", ",", "train_support_dataset", "=", "_cut", "(", "train_dataset", ")", ",", "[", "_cut", "(", "i", ")", "for", "i", "in", "train_support_dataset", "]", "\n", "", "else", ":", "\n", "            ", "train_dataset", "=", "_cut", "(", "app", ".", "util", ".", "read_dataset", "(", "train_file", ",", "input_num", "=", "2", ")", ")", "\n", "", "print", "(", "len", "(", "train_dataset", ")", ")", "\n", "\n", "if", "dev_support_file", ":", "\n", "            ", "dev_dataset", ",", "dev_support_dataset", "=", "app", ".", "util", ".", "read_dataset", "(", "dev_file", ",", "support_file_list", "=", "dev_support_file", ",", "input_num", "=", "2", ")", "\n", "dev_dataset", ",", "dev_support_dataset", "=", "_cut", "(", "dev_dataset", ")", ",", "[", "_cut", "(", "i", ")", "for", "i", "in", "\n", "dev_support_dataset", "]", "\n", "", "else", ":", "\n", "            ", "if", "dev_file", "!=", "train_file", ":", "\n", "                ", "dev_dataset", "=", "_cut", "(", "app", ".", "util", ".", "read_dataset", "(", "dev_file", ",", "input_num", "=", "2", ")", ")", "\n", "", "else", ":", "\n", "                ", "split_index", "=", "int", "(", "0.8", "*", "len", "(", "train_dataset", ")", ")", "\n", "dev_dataset", "=", "train_dataset", "[", "split_index", "+", "1", ":", "]", "\n", "train_dataset", "=", "train_dataset", "[", ":", "split_index", "]", "\n", "\n", "", "", "if", "test_support_file", ":", "\n", "            ", "test_dataset", ",", "test_support_dataset", "=", "app", ".", "util", ".", "read_dataset", "(", "test_file", ",", "support_file_list", "=", "test_support_file", ",", "\n", "input_num", "=", "2", ")", "\n", "test_dataset", ",", "test_support_dataset", "=", "_cut", "(", "test_dataset", ")", ",", "[", "_cut", "(", "i", ")", "for", "i", "in", "\n", "test_support_dataset", "]", "\n", "", "else", ":", "\n", "            ", "if", "test_file", "!=", "train_file", "and", "test_file", "!=", "dev_file", ":", "\n", "                ", "test_dataset", "=", "_cut", "(", "app", ".", "util", ".", "read_dataset", "(", "test_file", ",", "input_num", "=", "2", ")", ")", "\n", "", "else", ":", "\n", "                ", "test_dataset", "=", "[", "e", "for", "e", "in", "dev_dataset", "]", "\n", "test_support_dataset", "=", "[", "e", "for", "e", "in", "dev_support_dataset", "]", "if", "dev_support_dataset", "else", "None", "\n", "\n", "", "", "print", "(", "len", "(", "train_dataset", ")", ")", "\n", "\n", "all_dataset", "=", "train_dataset", "+", "dev_dataset", "+", "test_dataset", "\n", "if", "train_support_dataset", "and", "dev_support_dataset", "and", "test_support_dataset", ":", "\n", "            ", "for", "i", "in", "train_support_dataset", "+", "dev_support_dataset", "+", "test_support_dataset", ":", "\n", "                ", "all_dataset", "+=", "i", "\n", "\n", "", "", "if", "settings", "[", "\"X1_maxlen\"", "]", "and", "settings", "[", "\"X2_maxlen\"", "]", "and", "settings", "[", "\"Y_maxlen\"", "]", ":", "\n", "            ", "X1_maxlen", "=", "settings", "[", "\"X1_maxlen\"", "]", "\n", "X2_maxlen", "=", "settings", "[", "\"X2_maxlen\"", "]", "\n", "Y_maxlen", "=", "settings", "[", "\"Y_maxlen\"", "]", "\n", "", "else", ":", "\n", "            ", "X1_maxlen", "=", "max", "(", "map", "(", "lambda", "x", ":", "len", "(", "x", "[", "\"in1\"", "]", ")", ",", "all_dataset", ")", ")", "\n", "X2_maxlen", "=", "max", "(", "map", "(", "lambda", "x", ":", "len", "(", "x", "[", "\"in2\"", "]", ")", ",", "all_dataset", ")", ")", "\n", "Y_maxlen", "=", "max", "(", "map", "(", "lambda", "x", ":", "len", "(", "x", "[", "\"out\"", "]", ")", ",", "all_dataset", ")", ")", "\n", "\n", "# add 1 to enable the language to deal with pointing to the end", "\n", "", "X_maxlen", "=", "X1_maxlen", "+", "X2_maxlen", "+", "1", "\n", "\n", "print", "(", "\"[XY] X1_maxlen = {}, X2_maxlen = {}, X_maxlen = {}, Y_maxlen = {}\"", ".", "format", "(", "X1_maxlen", ",", "X2_maxlen", ",", "X_maxlen", ",", "Y_maxlen", ")", ")", "\n", "\n", "col_pntr_mask_fn", "=", "lambda", "X", ":", "np", ".", "array", "(", "\n", "[", "True", "if", "(", "x", "in", "X", "[", ":", "X1_maxlen", "]", "or", "x", "==", "X", "[", "-", "1", "]", ")", "else", "False", "for", "x", "in", "X", "]", ")", "\n", "const_pntr_mask_fn", "=", "lambda", "X", ":", "np", ".", "array", "(", "[", "True", "if", "i", ">=", "X1_maxlen", "else", "False", "for", "i", "in", "range", "(", "X_maxlen", ")", "]", ")", "\n", "\n", "abbrv_dict", "=", "{", "\n", "\"w\"", ":", "DecoderType", "(", "DecoderType", ".", "Projector", ")", ",", "\n", "\"p\"", ":", "DecoderType", "(", "DecoderType", ".", "Pointer", ",", "0", ",", "col_pntr_mask_fn", ")", ",", "# col_pntr_mask_fn),", "\n", "\"q\"", ":", "DecoderType", "(", "DecoderType", ".", "Pointer", ",", "1", ",", "const_pntr_mask_fn", ")", "\n", "}", "\n", "\n", "self", ".", "decoder_type", "=", "DecoderType", ".", "from_regex", "(", "decoder_regex", ",", "abbrv_dict", "=", "abbrv_dict", ",", "maxlen", "=", "Y_maxlen", ")", "\n", "\n", "for", "entry", "in", "all_dataset", ":", "\n", "            ", "entry", "[", "\"in\"", "]", "=", "concat_in1_in2", "(", "entry", "[", "\"in1\"", "]", ",", "entry", "[", "\"in2\"", "]", ",", "X1_maxlen", ",", "X2_maxlen", ")", "\n", "\n", "# get all used words as vocab", "\n", "", "if", "test_only", ":", "\n", "            ", "input_vocab", "=", "Vocabulary", ".", "build_from_sentences", "(", "[", "entry", "[", "\"in\"", "]", "for", "entry", "in", "all_dataset", "]", ")", "\n", "# we have a bug not yet fixed....", "\n", "output_vocab", "=", "Vocabulary", ".", "build_from_sentences", "(", "[", "[", "entry", "[", "\"out\"", "]", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "entry", "[", "\"out\"", "]", ")", ")", "\n", "if", "self", ".", "decoder_type", "[", "i", "]", ".", "ty", "==", "DecoderType", ".", "Projector", "]", "\n", "for", "entry", "in", "all_dataset", "]", ",", "use_go_tok", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "input_vocab", "=", "Vocabulary", ".", "build_from_sentences", "(", "[", "entry", "[", "\"in\"", "]", "for", "entry", "in", "all_dataset", "]", ")", "\n", "output_vocab", "=", "Vocabulary", ".", "build_from_sentences", "(", "[", "[", "entry", "[", "\"out\"", "]", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "entry", "[", "\"out\"", "]", ")", ")", "\n", "if", "self", ".", "decoder_type", "[", "i", "]", ".", "ty", "==", "DecoderType", ".", "Projector", "]", "\n", "for", "entry", "in", "all_dataset", "]", ",", "use_go_tok", "=", "True", ")", "\n", "\n", "", "pnet_vocab", "=", "PnetVocab", "(", "input_vocab", ",", "output_vocab", ",", "X_maxlen", ",", "Y_maxlen", ",", "[", "X1_maxlen", ",", "X2_maxlen", "]", ")", "\n", "pprint", "(", "pnet_vocab", ".", "get_stats", "(", ")", ")", "\n", "\n", "# build vocabulary", "\n", "self", ".", "pnet_vocab", "=", "pnet_vocab", "\n", "self", ".", "ex_printer", "=", "pnet_helper", ".", "PnetExPrinter", "(", "self", ".", "decoder_type", ",", "self", ".", "pnet_vocab", ")", "\n", "\n", "self", ".", "train_dataset", "=", "train_dataset", "\n", "self", ".", "dev_dataset", "=", "dev_dataset", "\n", "self", ".", "test_dataset", "=", "test_dataset", "\n", "self", ".", "train_support_dataset", "=", "train_support_dataset", "\n", "self", ".", "dev_support_dataset", "=", "dev_support_dataset", "\n", "self", ".", "test_support_dataset", "=", "test_support_dataset", "\n", "self", ".", "explicit_pointer", "=", "explicit_pointer", "\n", "self", ".", "value_based_loss", "=", "value_based_loss", "\n", "self", ".", "multi_encoders", "=", "{", "\n", "\"merge_method\"", ":", "\"sequential\"", ",", "\n", "\"segments\"", ":", "[", "[", "i", "for", "i", "in", "range", "(", "0", ",", "X1_maxlen", ")", "]", ",", "\n", "[", "i", "for", "i", "in", "range", "(", "X1_maxlen", ",", "X_maxlen", ")", "]", "]", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog_meta.NL2Prog_meta.train": [[161, 185], ["print", "model.pointer_net_graph_meta.build_graph", "print", "nl2prog_meta.to_xydata", "nl2prog_meta.to_xydata", "model.learn_meta.train_model", "print", "nl2prog_meta.to_xydata", "nl2prog_meta.to_xydata"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_graph_meta.build_graph", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.to_xydata", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.to_xydata", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.learn_meta.train_model", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.to_xydata", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.to_xydata"], ["", "def", "train", "(", "self", ",", "hyper_param", ",", "max_epoch", ",", "output_dir", "=", "None", ",", "pretrained_emb", "=", "None", ")", ":", "\n", "        ", "print", "(", "\"[OK] Start building graph ...\"", ")", "\n", "graph", ",", "var_dict", "=", "pnet_graph", ".", "build_graph", "(", "self", ".", "decoder_type", ",", "self", ".", "explicit_pointer", ",", "\n", "self", ".", "value_based_loss", ",", "hyper_param", ",", "self", ".", "pnet_vocab", ",", "\n", "pretrained_enc_embedding", "=", "pretrained_emb", ",", "\n", "multi_encoders", "=", "self", ".", "multi_encoders", ")", "\n", "\n", "print", "(", "\"[OK] Successfully build the graph.\"", ")", "\n", "\n", "train_xydata", "=", "to_xydata", "(", "self", ".", "train_dataset", ",", "self", ".", "pnet_vocab", ",", "self", ".", "explicit_pointer", ",", "self", ".", "decoder_type", ")", "\n", "dev_xydata", "=", "to_xydata", "(", "self", ".", "dev_dataset", ",", "self", ".", "pnet_vocab", ",", "self", ".", "explicit_pointer", ",", "self", ".", "decoder_type", ")", "\n", "\n", "train_support_xydata", ",", "dev_support_xydata", "=", "None", ",", "None", "\n", "if", "self", ".", "train_support_dataset", "and", "self", ".", "dev_support_dataset", ":", "\n", "            ", "train_support_xydata", "=", "[", "to_xydata", "(", "_data", ",", "self", ".", "pnet_vocab", ",", "self", ".", "explicit_pointer", ",", "self", ".", "decoder_type", ")", "for", "_data", "in", "self", ".", "train_support_dataset", "]", "\n", "dev_support_xydata", "=", "[", "to_xydata", "(", "_data", ",", "self", ".", "pnet_vocab", ",", "self", ".", "explicit_pointer", ",", "self", ".", "decoder_type", ")", "\n", "for", "_data", "in", "self", ".", "dev_support_dataset", "]", "\n", "\n", "", "session", "=", "learn", ".", "train_model", "(", "graph", ",", "var_dict", ",", "train_xydata", ",", "max_epoch", ",", "hyper_param", ",", "\n", "output_dir", ",", "test_data", "=", "dev_xydata", ",", "ex_printer", "=", "self", ".", "ex_printer", ",", "\n", "train_support_data", "=", "train_support_xydata", ",", "dev_support_data", "=", "dev_support_xydata", ")", "\n", "\n", "print", "(", "\"[OK] Training finished.\"", ")", "\n", "return", "graph", ",", "session", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog_meta.NL2Prog_meta.test": [[187, 202], ["nl2prog_meta.to_xydata", "model.learn_meta.test_model", "print", "os.path.join", "nl2prog_meta.to_xydata"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.to_xydata", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.learn_meta.test_model", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.to_xydata"], ["", "def", "test", "(", "self", ",", "graph", ",", "session", ",", "hyper_param", ",", "output_dir", "=", "None", ")", ":", "\n", "#pprint([n.name for n in graph.get_operations()])", "\n", "        ", "test_xydata", "=", "to_xydata", "(", "self", ".", "test_dataset", ",", "self", ".", "pnet_vocab", ",", "self", ".", "explicit_pointer", ",", "self", ".", "decoder_type", ")", "\n", "test_support_xydata", "=", "None", "\n", "if", "self", ".", "test_support_dataset", ":", "\n", "            ", "test_support_xydata", "=", "[", "to_xydata", "(", "_data", ",", "self", ".", "pnet_vocab", ",", "self", ".", "explicit_pointer", ",", "self", ".", "decoder_type", ")", "\n", "for", "_data", "in", "self", ".", "test_support_dataset", "]", "\n", "\n", "# use the default dict", "\n", "", "var_dict", "=", "pnet_graph", ".", "default_var_dict", "\n", "\n", "log_file", "=", "os", ".", "path", ".", "join", "(", "output_dir", ",", "\"test_top_1.log\"", ")", "if", "output_dir", "else", "None", "\n", "learn", ".", "test_model", "(", "graph", ",", "var_dict", ",", "session", ",", "test_xydata", ",", "hyper_param", "[", "\"batch_size\"", "]", ",", "\n", "self", ".", "ex_printer", ",", "log_file", "=", "log_file", ",", "test_support_data", "=", "test_support_xydata", "[", ":", "hyper_param", "[", "'num_meta_example'", "]", "]", ")", "\n", "print", "(", "\"[OK] Test finished.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog_meta.NL2Prog_meta.test_new": [[203, 223], ["nl2prog_meta.NL2Prog_meta.test", "graph.as_default", "graph.get_tensor_by_name", "int", "tensorflow.constant", "print", "tensorflow.assign", "session.run", "tensorflow.pad", "graph.get_tensor_by_name.get_shape"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.NL2Prog.test", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print"], ["", "def", "test_new", "(", "self", ",", "graph", ",", "session", ",", "hyper_param", ",", "pretrained_emb", ",", "output_dir", "=", "None", ")", ":", "\n", "# we need to re build embedding in this case", "\n", "        ", "with", "graph", ".", "as_default", "(", ")", ":", "\n", "            ", "embedding_tensor", "=", "graph", ".", "get_tensor_by_name", "(", "\"graph/enc_embedding:0\"", ")", "\n", "original_vocab_size", "=", "int", "(", "embedding_tensor", ".", "get_shape", "(", ")", "[", "0", "]", ")", "\n", "\n", "vocab_size", "=", "self", ".", "pnet_vocab", ".", "input_vocab", ".", "size", "\n", "emb_size", "=", "hyper_param", "[", "\"embedding_size\"", "]", "\n", "\n", "# pad the new embedding as the same size as the original emb tensor", "\n", "new_enc_emb", "=", "tf", ".", "constant", "(", "pretrained_emb", ",", "name", "=", "\"new_enc_emb\"", ",", "shape", "=", "[", "vocab_size", ",", "emb_size", "]", ")", "\n", "if", "original_vocab_size", ">", "vocab_size", ":", "\n", "                ", "new_enc_emb", "=", "tf", ".", "pad", "(", "new_enc_emb", ",", "[", "[", "0", ",", "original_vocab_size", "-", "vocab_size", "]", ",", "[", "0", ",", "0", "]", "]", ")", "\n", "\n", "", "print", "(", "new_enc_emb", ")", "\n", "\n", "re_assign_emb", "=", "tf", ".", "assign", "(", "embedding_tensor", ",", "new_enc_emb", ")", "\n", "session", ".", "run", "(", "re_assign_emb", ")", "\n", "\n", "", "self", ".", "test", "(", "graph", ",", "session", ",", "hyper_param", ",", "output_dir", "=", "output_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog_meta.NL2Prog_meta.run_wikisql": [[225, 328], ["app.util.find_file", "app.util.find_file", "app.util.find_file", "app.util.find_file", "app.util.find_file", "print", "print", "print", "pprint.pprint.pprint", "print", "print", "nl2prog_meta.NL2Prog_meta", "app.util.find_file", "app.util.find_file", "app.util.find_file", "min", "numpy.zeros", "nl2prog_meta.NL2Prog_meta.train", "nl2prog_meta.NL2Prog_meta.test", "model.learn_meta.load_model", "nl2prog_meta.NL2Prog_meta.test_new", "print", "config[].split", "config[].split", "config[].split", "len", "model.util.JmtEmbeddings", "model.util.GloVeEmbeddings", "model.util.JmtEmbeddings.emb", "range", "w.replace().replace().replace().replace().replace().replace.replace().replace().replace().replace().replace().replace.replace().replace().replace().replace().replace().replace", "w.replace().replace().replace().replace().replace().replace.replace().replace().replace().replace().replace().replace.split", "len", "model.util.GloVeEmbeddings.emb", "numpy.array().any", "numpy.mean", "range", "w.replace().replace().replace().replace().replace().replace.replace().replace().replace().replace().replace().replace.replace().replace().replace().replace().replace", "v_list.append", "len", "numpy.array", "w.replace().replace().replace().replace().replace().replace.replace().replace().replace().replace().replace().replace.replace().replace().replace().replace", "w.replace().replace().replace().replace().replace().replace.replace().replace().replace().replace().replace().replace.replace().replace().replace", "w.replace().replace().replace().replace().replace().replace.replace().replace().replace().replace().replace().replace.replace().replace", "w.replace().replace().replace().replace().replace().replace.replace().replace().replace().replace().replace().replace.replace"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.find_file", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.find_file", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.find_file", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.find_file", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.find_file", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.find_file", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.find_file", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.find_file", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.NL2Prog.train", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.NL2Prog.test", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.learn_meta.load_model", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.NL2Prog.test_new", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.JmtEmbeddings.emb", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.JmtEmbeddings.emb"], ["", "@", "staticmethod", "\n", "def", "run_wikisql", "(", "input_dir", ",", "output_dir", ",", "config", ",", "trained_model", "=", "None", ")", ":", "\n", "        ", "\"\"\" if trained_model is specified, we will perform a model testing \"\"\"", "\n", "train_file", "=", "app", ".", "util", ".", "find_file", "(", "input_dir", ",", "config", "[", "\"train_file\"", "]", ")", "\n", "dev_file", "=", "app", ".", "util", ".", "find_file", "(", "input_dir", ",", "config", "[", "\"dev_file\"", "]", ")", "\n", "test_file", "=", "app", ".", "util", ".", "find_file", "(", "input_dir", ",", "config", "[", "\"test_file\"", "]", ")", "\n", "\n", "train_support_file", "=", "[", "app", ".", "util", ".", "find_file", "(", "input_dir", ",", "file", ")", "for", "file", "in", "config", "[", "\"train_support_file\"", "]", ".", "split", "(", "','", ")", "]", "\n", "dev_support_file", "=", "[", "app", ".", "util", ".", "find_file", "(", "input_dir", ",", "file", ")", "for", "file", "in", "config", "[", "\"dev_support_file\"", "]", ".", "split", "(", "','", ")", "]", "\n", "test_support_file", "=", "[", "app", ".", "util", ".", "find_file", "(", "input_dir", ",", "file", ")", "for", "file", "in", "config", "[", "\"test_support_file\"", "]", ".", "split", "(", "','", ")", "]", "\n", "\n", "jmt_embedding_file", "=", "app", ".", "util", ".", "find_file", "(", "input_dir", ",", "config", "[", "\"jmt_embedding_file\"", "]", ")", "\n", "glove_embedding_file", "=", "app", ".", "util", ".", "find_file", "(", "input_dir", ",", "config", "[", "\"glove_embedding_file\"", "]", ")", "\n", "\n", "hyper_param", "=", "config", "[", "\"hyper_param\"", "]", "\n", "max_epoch", "=", "hyper_param", "[", "\"max_epoch\"", "]", "\n", "hyper_param", "[", "'num_meta_example'", "]", "=", "min", "(", "hyper_param", "[", "'num_meta_example'", "]", ",", "len", "(", "train_support_file", ")", ")", "if", "'num_meta_example'", "in", "hyper_param", "else", "0", "\n", "\n", "print", "(", "\"|>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\"", ")", "\n", "print", "(", "\"|>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\"", ")", "\n", "print", "(", "\"[Config]\"", ")", "\n", "pprint", "(", "config", ")", "\n", "print", "(", "\"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<|\"", ")", "\n", "print", "(", "\"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<|\"", ")", "\n", "\n", "settings", "=", "{", "\n", "\"decoder_regex\"", ":", "config", "[", "\"decoder_regex\"", "]", ",", "\n", "\"explicit_pointer\"", ":", "config", "[", "\"explicit_pointer\"", "]", ",", "\n", "\"value_based_loss\"", ":", "config", "[", "\"value_based_loss\"", "]", ",", "\n", "\"num_data_used\"", ":", "hyper_param", "[", "\"num_data_used\"", "]", ",", "\n", "\"test_only\"", ":", "False", "if", "trained_model", "is", "None", "else", "True", ",", "\n", "\n", "\"X1_maxlen\"", ":", "hyper_param", "[", "\"X1_maxlen\"", "]", ",", "\n", "\"X2_maxlen\"", ":", "hyper_param", "[", "\"X2_maxlen\"", "]", ",", "\n", "\"Y_maxlen\"", ":", "hyper_param", "[", "\"Y_maxlen\"", "]", "\n", "}", "\n", "\n", "task", "=", "NL2Prog_meta", "(", "train_file", "=", "train_file", ",", "\n", "dev_file", "=", "dev_file", ",", "\n", "test_file", "=", "test_file", ",", "\n", "settings", "=", "settings", ",", "\n", "train_support_file", "=", "train_support_file", ",", "\n", "dev_support_file", "=", "dev_support_file", ",", "\n", "test_support_file", "=", "test_support_file", ")", "\n", "\n", "pretrained_emb", "=", "None", "\n", "\n", "if", "jmt_embedding_file", "and", "glove_embedding_file", ":", "\n", "            ", "input_vocab", "=", "task", ".", "pnet_vocab", ".", "input_vocab", "\n", "pretrained_emb", "=", "np", ".", "zeros", "(", "[", "input_vocab", ".", "size", ",", "hyper_param", "[", "\"embedding_size\"", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "jmt_dim", "=", "hyper_param", "[", "\"jmt_embedding_size\"", "]", "\n", "glove_dim", "=", "hyper_param", "[", "\"glove_embedding_size\"", "]", "\n", "\n", "if", "jmt_dim", ">", "0", ":", "\n", "                ", "full_jmt_embeddings", "=", "JmtEmbeddings", "(", "jmt_embedding_file", ",", "d_emb", "=", "jmt_dim", ")", "\n", "\n", "", "if", "glove_dim", ">", "0", ":", "\n", "                ", "full_glove_embeddings", "=", "GloVeEmbeddings", "(", "glove_embedding_file", ",", "d_emb", "=", "glove_dim", ")", "\n", "\n", "", "for", "i", "in", "input_vocab", ".", "index_word", ":", "\n", "                ", "w", "=", "input_vocab", ".", "index_word", "[", "i", "]", "\n", "v1", "=", "full_jmt_embeddings", ".", "emb", "(", "w", ")", "\n", "\n", "if", "jmt_dim", ">", "0", ":", "\n", "# jmt part", "\n", "                    ", "for", "j", "in", "range", "(", "len", "(", "v1", ")", ")", ":", "\n", "                        ", "pretrained_emb", "[", "i", "]", "[", "j", "]", "=", "v1", "[", "j", "]", "\n", "\n", "", "", "if", "glove_dim", ">", "0", ":", "\n", "# glove part", "\n", "                    ", "v_list", "=", "[", "]", "\n", "w", "=", "(", "w", ".", "replace", "(", "\"(\"", ",", "\"^\"", ")", ".", "replace", "(", "\")\"", ",", "\"^\"", ")", ".", "replace", "(", "\",\"", ",", "\"^\"", ")", "\n", ".", "replace", "(", "\".\"", ",", "\"^\"", ")", ".", "replace", "(", "\"\\'\"", ",", "\"^\"", ")", ".", "replace", "(", "\"/\"", ",", "\"^\"", ")", ")", "\n", "\n", "for", "x", "in", "w", ".", "split", "(", "\"^\"", ")", ":", "\n", "                        ", "if", "x", "==", "\"\"", ":", "\n", "                            ", "continue", "\n", "", "v_x", "=", "full_glove_embeddings", ".", "emb", "(", "x", ")", "\n", "if", "np", ".", "array", "(", "v_x", ")", ".", "any", "(", ")", ":", "\n", "                            ", "v_list", ".", "append", "(", "v_x", ")", "\n", "\n", "", "", "if", "v_list", ":", "\n", "                        ", "v2", "=", "np", ".", "mean", "(", "v_list", ",", "axis", "=", "0", ")", "\n", "for", "j", "in", "range", "(", "len", "(", "v2", ")", ")", ":", "\n", "                            ", "pretrained_emb", "[", "i", "]", "[", "j", "+", "jmt_dim", "]", "=", "v2", "[", "j", "]", "\n", "\n", "", "", "", "", "", "if", "trained_model", "is", "None", ":", "\n", "# in this case we want to train a new model", "\n", "            ", "graph", ",", "session", "=", "task", ".", "train", "(", "hyper_param", "=", "hyper_param", ",", "\n", "max_epoch", "=", "max_epoch", ",", "\n", "output_dir", "=", "output_dir", ",", "\n", "pretrained_emb", "=", "pretrained_emb", ")", "\n", "\n", "task", ".", "test", "(", "graph", ",", "session", ",", "hyper_param", ",", "output_dir", "=", "output_dir", ")", "\n", "\n", "", "else", ":", "\n", "# in this case we want to test a trained model", "\n", "            ", "graph", ",", "session", "=", "learn", ".", "load_model", "(", "trained_model", ")", "\n", "\n", "task", ".", "test_new", "(", "graph", ",", "session", ",", "hyper_param", ",", "pretrained_emb", ",", "output_dir", "=", "output_dir", ")", "\n", "\n", "print", "(", "\"[OK] Start building testing graph ...\"", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog_meta.to_xydata": [[22, 25], ["model.learn_meta.XYData", "pnet_vocab.prepare_pointer_data"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetVocab.prepare_pointer_data"], ["def", "to_xydata", "(", "dataset", ",", "pnet_vocab", ",", "explicit_pointer", ",", "decoder_type", ")", ":", "\n", "# prepare xy data from a dataset", "\n", "    ", "return", "learn", ".", "XYData", "(", "*", "pnet_vocab", ".", "prepare_pointer_data", "(", "dataset", ",", "decoder_type", ",", "explicit_pointer", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog_meta.concat_in1_in2": [[26, 40], ["range", "range", "range", "range", "len", "result.append", "len", "result.append", "len", "result.append", "len", "result.append"], "function", ["None"], ["", "def", "concat_in1_in2", "(", "input1", ",", "input2", ",", "X1_maxlen", ",", "X2_maxlen", ")", ":", "\n", "    ", "\"\"\" input1 and input2 are both lists of tokens, \n        we concatenate them into a single input list X \"\"\"", "\n", "result", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "input1", ")", ")", ":", "\n", "        ", "result", ".", "append", "(", "input1", "[", "i", "]", ")", "\n", "", "for", "i", "in", "range", "(", "len", "(", "input1", ")", ",", "X1_maxlen", ")", ":", "\n", "        ", "result", ".", "append", "(", "Vocabulary", ".", "END_TOK", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "len", "(", "input2", ")", ")", ":", "\n", "        ", "result", ".", "append", "(", "input2", "[", "i", "]", ")", "\n", "", "for", "i", "in", "range", "(", "len", "(", "input2", ")", ",", "X2_maxlen", ")", ":", "\n", "        ", "result", ".", "append", "(", "Vocabulary", ".", "END_TOK", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util._read_dataset": [[3, 28], ["open", "f.readlines", "range", "len", "raw_lines[].strip().split", "dataset.append", "raw_lines[].strip().split", "raw_lines[].strip().split", "raw_lines[].strip().split", "raw_lines[].strip", "raw_lines[].strip", "raw_lines[].strip", "raw_lines[].strip"], "function", ["None"], ["class", "Vocabulary", "(", "object", ")", ":", "\n", "\n", "    ", "GO_TOK", "=", "\"<GO>\"", "\n", "END_TOK", "=", "\"<END>\"", "\n", "\n", "UNK_TOK", "=", "\"<UNK>\"", "\n", "\n", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\" initialize an empty vocab \"\"\"", "\n", "self", ".", "vocab", "=", "[", "]", "\n", "self", ".", "size", "=", "0", "\n", "self", ".", "word_index", "=", "{", "}", "\n", "self", ".", "index_word", "=", "{", "}", "\n", "self", ".", "use_unk", "=", "False", "\n", "\n", "", "def", "word_to_index", "(", "self", ",", "word", ")", ":", "\n", "        ", "if", "(", "self", ".", "use_unk", "and", "word", "not", "in", "self", ".", "word_index", ")", ":", "\n", "            ", "print", "(", "\"[Warning] Word {} is not found in the vocabulary, <UNK> is used as a substitute.\"", ".", "format", "(", "word", ")", ")", "\n", "return", "self", ".", "word_index", "[", "Vocabulary", ".", "UNK_TOK", "]", "\n", "", "return", "self", ".", "word_index", "[", "word", "]", "\n", "\n", "", "def", "index_to_word", "(", "self", ",", "index", ")", ":", "\n", "        ", "return", "self", ".", "index_word", "[", "index", "]", "\n", "\n", "", "@", "staticmethod", "\n", "def", "build_from_words", "(", "words", ",", "use_go_tok", "=", "False", ",", "use_unk", "=", "False", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.read_dataset": [[29, 42], ["util._read_dataset", "util._read_dataset"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util._read_dataset", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util._read_dataset"], ["        ", "\"\"\" build vocabulary from all words we want to include \"\"\"", "\n", "vocab", "=", "Vocabulary", "(", ")", "\n", "\n", "vocab", ".", "vocab", "=", "[", "Vocabulary", ".", "END_TOK", "]", "\n", "if", "use_go_tok", ":", "\n", "            ", "vocab", ".", "vocab", ".", "append", "(", "Vocabulary", ".", "GO_TOK", ")", "\n", "", "if", "use_unk", ":", "\n", "            ", "vocab", ".", "use_unk", "=", "True", "\n", "vocab", ".", "vocab", ".", "append", "(", "Vocabulary", ".", "UNK_TOK", ")", "\n", "\n", "", "vocab", ".", "vocab", "+=", "sorted", "(", "words", ")", "\n", "vocab", ".", "size", "=", "len", "(", "vocab", ".", "vocab", ")", "\n", "\n", "# build index", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.find_file": [[44, 59], ["os.walk", "len", "len", "print", "print", "candidates.append", "os.path.join"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print"], ["            ", "vocab", ".", "word_index", "[", "v", "]", "=", "i", "\n", "vocab", ".", "index_word", "[", "i", "]", "=", "v", "\n", "\n", "", "return", "vocab", "\n", "\n", "", "@", "staticmethod", "\n", "def", "build_from_sentences", "(", "sentences", ",", "use_go_tok", "=", "False", ",", "use_unk", "=", "False", ",", "frequency_cap", "=", "-", "1", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.NL2Prog.__init__": [[47, 146], ["_cut", "print", "print", "print", "model.pointer_net.DecoderType.from_regex", "model.pointer_net_helper.PnetVocab", "pprint.pprint.pprint", "model.pointer_net_helper.PnetExPrinter", "app.util.read_dataset", "len", "len", "max", "max", "max", "numpy.array", "numpy.array", "numpy.array", "model.pointer_net.DecoderType", "model.pointer_net.DecoderType", "model.pointer_net.DecoderType", "nl2prog.concat_in1_in2", "model.util.Vocabulary.build_from_sentences", "model.util.Vocabulary.build_from_sentences", "model.util.Vocabulary.build_from_sentences", "model.util.Vocabulary.build_from_sentences", "model.pointer_net_helper.PnetVocab.get_stats", "_cut", "int", "_cut", "map", "map", "map", "app.util.read_dataset", "app.util.read_dataset", "min", "len", "len", "len", "len", "range", "range", "range", "range", "len", "range", "range", "len", "len"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net.DecoderType.from_regex", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.read_dataset", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.concat_in1_in2", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.build_from_sentences", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.build_from_sentences", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.build_from_sentences", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.Vocabulary.build_from_sentences", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetVocab.get_stats", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.read_dataset", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.read_dataset"], ["def", "__init__", "(", "self", ",", "train_file", ",", "dev_file", ",", "test_file", ",", "settings", ")", ":", "\n", "        ", "\"\"\" prepare memlookup task \"\"\"", "\n", "decoder_regex", "=", "settings", "[", "\"decoder_regex\"", "]", "\n", "explicit_pointer", "=", "settings", "[", "\"explicit_pointer\"", "]", "\n", "value_based_loss", "=", "settings", "[", "\"value_based_loss\"", "]", "\n", "num_data_used", "=", "settings", "[", "\"num_data_used\"", "]", "\n", "test_only", "=", "settings", "[", "\"test_only\"", "]", "\n", "\n", "_cut", "=", "lambda", "s", ":", "s", "[", ":", "min", "(", "len", "(", "s", ")", ",", "num_data_used", ")", "]", "if", "num_data_used", "is", "not", "None", "else", "s", "\n", "\n", "# prepare training and dev data", "\n", "train_dataset", "=", "_cut", "(", "app", ".", "util", ".", "read_dataset", "(", "train_file", ",", "input_num", "=", "2", ")", ")", "\n", "\n", "print", "(", "len", "(", "train_dataset", ")", ")", "\n", "\n", "if", "train_file", "==", "dev_file", "==", "test_file", ":", "# evluation mode", "\n", "                ", "dev_dataset", "=", "[", "e", "for", "e", "in", "train_dataset", "]", "\n", "test_dataset", "=", "[", "e", "for", "e", "in", "dev_dataset", "]", "\n", "", "else", ":", "\n", "            ", "if", "dev_file", "!=", "train_file", ":", "\n", "                ", "dev_dataset", "=", "_cut", "(", "app", ".", "util", ".", "read_dataset", "(", "dev_file", ",", "input_num", "=", "2", ")", ")", "\n", "", "else", ":", "\n", "                ", "split_index", "=", "int", "(", "0.8", "*", "len", "(", "train_dataset", ")", ")", "\n", "dev_dataset", "=", "train_dataset", "[", "split_index", "+", "1", ":", "]", "\n", "train_dataset", "=", "train_dataset", "[", ":", "split_index", "]", "\n", "\n", "", "if", "test_file", "!=", "train_file", "and", "test_file", "!=", "dev_file", ":", "\n", "                ", "test_dataset", "=", "_cut", "(", "app", ".", "util", ".", "read_dataset", "(", "test_file", ",", "input_num", "=", "2", ")", ")", "\n", "", "else", ":", "\n", "                ", "test_dataset", "=", "[", "e", "for", "e", "in", "dev_dataset", "]", "\n", "\n", "", "", "print", "(", "len", "(", "train_dataset", ")", ")", "\n", "\n", "all_dataset", "=", "train_dataset", "+", "dev_dataset", "+", "test_dataset", "\n", "\n", "if", "settings", "[", "\"X1_maxlen\"", "]", "and", "settings", "[", "\"X2_maxlen\"", "]", "and", "settings", "[", "\"Y_maxlen\"", "]", ":", "\n", "            ", "X1_maxlen", "=", "settings", "[", "\"X1_maxlen\"", "]", "\n", "X2_maxlen", "=", "settings", "[", "\"X2_maxlen\"", "]", "\n", "Y_maxlen", "=", "settings", "[", "\"Y_maxlen\"", "]", "\n", "", "else", ":", "\n", "            ", "X1_maxlen", "=", "max", "(", "map", "(", "lambda", "x", ":", "len", "(", "x", "[", "\"in1\"", "]", ")", ",", "all_dataset", ")", ")", "\n", "X2_maxlen", "=", "max", "(", "map", "(", "lambda", "x", ":", "len", "(", "x", "[", "\"in2\"", "]", ")", ",", "all_dataset", ")", ")", "\n", "Y_maxlen", "=", "max", "(", "map", "(", "lambda", "x", ":", "len", "(", "x", "[", "\"out\"", "]", ")", ",", "all_dataset", ")", ")", "\n", "\n", "# add 1 to enable the language to deal with pointing to the end", "\n", "", "X_maxlen", "=", "X1_maxlen", "+", "X2_maxlen", "+", "1", "\n", "\n", "print", "(", "\"[XY] X1_maxlen = {}, X2_maxlen = {}, X_maxlen = {}, Y_maxlen = {}\"", ".", "format", "(", "X1_maxlen", ",", "X2_maxlen", ",", "X_maxlen", ",", "Y_maxlen", ")", ")", "\n", "\n", "col_pntr_mask_fn", "=", "lambda", "X", ":", "np", ".", "array", "(", "[", "True", "if", "(", "x", "in", "X", "[", ":", "X1_maxlen", "]", "or", "x", "==", "X", "[", "-", "1", "]", ")", "else", "False", "for", "x", "in", "X", "]", ")", "\n", "const_pntr_mask_fn", "=", "lambda", "X", ":", "np", ".", "array", "(", "[", "True", "if", "i", ">=", "X1_maxlen", "else", "False", "for", "i", "in", "range", "(", "X_maxlen", ")", "]", ")", "\n", "\n", "true_mask_fn", "=", "lambda", "X", ":", "np", ".", "array", "(", "[", "True", "for", "i", "in", "range", "(", "X_maxlen", ")", "]", ")", "\n", "\n", "abbrv_dict", "=", "{", "\n", "\"w\"", ":", "DecoderType", "(", "DecoderType", ".", "Projector", ")", ",", "\n", "\"p\"", ":", "DecoderType", "(", "DecoderType", ".", "Pointer", ",", "0", ",", "col_pntr_mask_fn", ")", ",", "#col_pntr_mask_fn),", "\n", "\"q\"", ":", "DecoderType", "(", "DecoderType", ".", "Pointer", ",", "1", ",", "const_pntr_mask_fn", ")", "\n", "}", "\n", "\n", "self", ".", "decoder_type", "=", "DecoderType", ".", "from_regex", "(", "decoder_regex", ",", "abbrv_dict", "=", "abbrv_dict", ",", "maxlen", "=", "Y_maxlen", ")", "\n", "\n", "for", "entry", "in", "all_dataset", ":", "\n", "            ", "entry", "[", "\"in\"", "]", "=", "concat_in1_in2", "(", "entry", "[", "\"in1\"", "]", ",", "entry", "[", "\"in2\"", "]", ",", "X1_maxlen", ",", "X2_maxlen", ")", "\n", "\n", "# get all used words as vocab", "\n", "", "if", "test_only", ":", "\n", "            ", "input_vocab", "=", "Vocabulary", ".", "build_from_sentences", "(", "[", "entry", "[", "\"in\"", "]", "for", "entry", "in", "test_dataset", "]", ")", "\n", "# we have a bug not yet fixed....", "\n", "output_vocab", "=", "Vocabulary", ".", "build_from_sentences", "(", "[", "[", "entry", "[", "\"out\"", "]", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "entry", "[", "\"out\"", "]", ")", ")", "\n", "if", "self", ".", "decoder_type", "[", "i", "]", ".", "ty", "==", "DecoderType", ".", "Projector", "]", "\n", "for", "entry", "in", "all_dataset", "]", ",", "use_go_tok", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "input_vocab", "=", "Vocabulary", ".", "build_from_sentences", "(", "[", "entry", "[", "\"in\"", "]", "for", "entry", "in", "all_dataset", "]", ")", "\n", "output_vocab", "=", "Vocabulary", ".", "build_from_sentences", "(", "[", "[", "entry", "[", "\"out\"", "]", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "entry", "[", "\"out\"", "]", ")", ")", "\n", "if", "self", ".", "decoder_type", "[", "i", "]", ".", "ty", "==", "DecoderType", ".", "Projector", "]", "\n", "for", "entry", "in", "all_dataset", "]", ",", "use_go_tok", "=", "True", ")", "\n", "\n", "\n", "", "pnet_vocab", "=", "PnetVocab", "(", "input_vocab", ",", "output_vocab", ",", "X_maxlen", ",", "Y_maxlen", ",", "[", "X1_maxlen", ",", "X2_maxlen", "]", ")", "\n", "\n", "pprint", "(", "pnet_vocab", ".", "get_stats", "(", ")", ")", "\n", "\n", "# build vocabulary", "\n", "self", ".", "pnet_vocab", "=", "pnet_vocab", "\n", "\n", "self", ".", "ex_printer", "=", "pnet_helper", ".", "PnetExPrinter", "(", "self", ".", "decoder_type", ",", "self", ".", "pnet_vocab", ")", "\n", "\n", "self", ".", "train_dataset", "=", "train_dataset", "\n", "self", ".", "dev_dataset", "=", "dev_dataset", "\n", "self", ".", "test_dataset", "=", "test_dataset", "\n", "\n", "self", ".", "explicit_pointer", "=", "explicit_pointer", "\n", "self", ".", "value_based_loss", "=", "value_based_loss", "\n", "\n", "self", ".", "multi_encoders", "=", "{", "\n", "\"merge_method\"", ":", "\"sequential\"", ",", "\n", "\"segments\"", ":", "[", "[", "i", "for", "i", "in", "range", "(", "0", ",", "X1_maxlen", ")", "]", ",", "\n", "[", "i", "for", "i", "in", "range", "(", "X1_maxlen", ",", "X_maxlen", ")", "]", "]", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.NL2Prog.train": [[149, 168], ["print", "model.pointer_net_graph.build_graph", "print", "nl2prog.to_xydata", "nl2prog.to_xydata", "model.learn.train_model", "print"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_graph_meta.build_graph", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.to_xydata", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.to_xydata", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.learn_meta.train_model", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print"], ["", "def", "train", "(", "self", ",", "hyper_param", ",", "max_epoch", ",", "output_dir", "=", "None", ",", "pretrained_emb", "=", "None", ")", ":", "\n", "        ", "print", "(", "\"[OK] Start building graph ...\"", ")", "\n", "\n", "graph", ",", "var_dict", "=", "pnet_graph", ".", "build_graph", "(", "self", ".", "decoder_type", ",", "self", ".", "explicit_pointer", ",", "\n", "self", ".", "value_based_loss", ",", "hyper_param", ",", "self", ".", "pnet_vocab", ",", "\n", "pretrained_enc_embedding", "=", "pretrained_emb", ",", "\n", "multi_encoders", "=", "self", ".", "multi_encoders", ")", "\n", "\n", "print", "(", "\"[OK] Successfully build the graph.\"", ")", "\n", "\n", "train_xydata", "=", "to_xydata", "(", "self", ".", "train_dataset", ",", "self", ".", "pnet_vocab", ",", "self", ".", "explicit_pointer", ",", "self", ".", "decoder_type", ")", "\n", "dev_xydata", "=", "to_xydata", "(", "self", ".", "dev_dataset", ",", "self", ".", "pnet_vocab", ",", "self", ".", "explicit_pointer", ",", "self", ".", "decoder_type", ")", "\n", "\n", "session", "=", "learn", ".", "train_model", "(", "graph", ",", "var_dict", ",", "train_xydata", ",", "max_epoch", ",", "hyper_param", ",", "\n", "output_dir", ",", "test_data", "=", "dev_xydata", ",", "ex_printer", "=", "self", ".", "ex_printer", ")", "\n", "\n", "print", "(", "\"[OK] Training finished.\"", ")", "\n", "\n", "return", "graph", ",", "session", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.NL2Prog.test": [[170, 181], ["nl2prog.to_xydata", "model.learn.test_model", "print", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.to_xydata", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.learn_meta.test_model", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print"], ["", "def", "test", "(", "self", ",", "graph", ",", "session", ",", "hyper_param", ",", "output_dir", "=", "None", ")", ":", "\n", "#pprint([n.name for n in graph.get_operations()])", "\n", "        ", "test_xydata", "=", "to_xydata", "(", "self", ".", "test_dataset", ",", "self", ".", "pnet_vocab", ",", "self", ".", "explicit_pointer", ",", "self", ".", "decoder_type", ")", "\n", "# use the default dict", "\n", "var_dict", "=", "pnet_graph", ".", "default_var_dict", "\n", "\n", "log_file", "=", "os", ".", "path", ".", "join", "(", "output_dir", ",", "\"test_top_1.log\"", ")", "if", "output_dir", "else", "None", "\n", "learn", ".", "test_model", "(", "graph", ",", "var_dict", ",", "session", ",", "test_xydata", ",", "hyper_param", "[", "\"batch_size\"", "]", ",", "\n", "self", ".", "ex_printer", ",", "log_file", "=", "log_file", ")", "\n", "\n", "print", "(", "\"[OK] Test finished.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.NL2Prog.test_new": [[182, 203], ["nl2prog.NL2Prog.test", "graph.as_default", "graph.get_tensor_by_name", "int", "tensorflow.constant", "print", "tensorflow.assign", "session.run", "tensorflow.pad", "graph.get_tensor_by_name.get_shape"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.NL2Prog.test", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print"], ["", "def", "test_new", "(", "self", ",", "graph", ",", "session", ",", "hyper_param", ",", "pretrained_emb", ",", "output_dir", "=", "None", ")", ":", "\n", "# we need to re build embedding in this case", "\n", "        ", "with", "graph", ".", "as_default", "(", ")", ":", "\n", "            ", "embedding_tensor", "=", "graph", ".", "get_tensor_by_name", "(", "\"graph/enc_embedding:0\"", ")", "\n", "\n", "original_vocab_size", "=", "int", "(", "embedding_tensor", ".", "get_shape", "(", ")", "[", "0", "]", ")", "\n", "\n", "vocab_size", "=", "self", ".", "pnet_vocab", ".", "input_vocab", ".", "size", "\n", "emb_size", "=", "hyper_param", "[", "\"embedding_size\"", "]", "\n", "\n", "# pad the new embedding as the same size as the original emb tensor", "\n", "new_enc_emb", "=", "tf", ".", "constant", "(", "pretrained_emb", ",", "name", "=", "\"new_enc_emb\"", ",", "shape", "=", "[", "vocab_size", ",", "emb_size", "]", ")", "\n", "if", "original_vocab_size", ">", "vocab_size", ":", "\n", "                ", "new_enc_emb", "=", "tf", ".", "pad", "(", "new_enc_emb", ",", "[", "[", "0", ",", "original_vocab_size", "-", "vocab_size", "]", ",", "[", "0", ",", "0", "]", "]", ")", "\n", "\n", "", "print", "(", "new_enc_emb", ")", "\n", "\n", "re_assign_emb", "=", "tf", ".", "assign", "(", "embedding_tensor", ",", "new_enc_emb", ")", "\n", "session", ".", "run", "(", "re_assign_emb", ")", "\n", "\n", "", "self", ".", "test", "(", "graph", ",", "session", ",", "hyper_param", ",", "output_dir", "=", "output_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.NL2Prog.run_wikisql": [[205, 301], ["app.util.find_file", "app.util.find_file", "app.util.find_file", "app.util.find_file", "app.util.find_file", "print", "print", "print", "pprint.pprint.pprint", "print", "print", "nl2prog.NL2Prog", "numpy.zeros", "nl2prog.NL2Prog.train", "nl2prog.NL2Prog.test", "model.learn.load_model", "nl2prog.NL2Prog.test_new", "print", "model.util.JmtEmbeddings", "model.util.GloVeEmbeddings", "model.util.JmtEmbeddings.emb", "range", "w.replace().replace().replace().replace().replace().replace.replace().replace().replace().replace().replace().replace.replace().replace().replace().replace().replace().replace", "w.replace().replace().replace().replace().replace().replace.replace().replace().replace().replace().replace().replace.split", "len", "model.util.GloVeEmbeddings.emb", "numpy.array().any", "numpy.mean", "range", "w.replace().replace().replace().replace().replace().replace.replace().replace().replace().replace().replace().replace.replace().replace().replace().replace().replace", "v_list.append", "len", "numpy.array", "w.replace().replace().replace().replace().replace().replace.replace().replace().replace().replace().replace().replace.replace().replace().replace().replace", "w.replace().replace().replace().replace().replace().replace.replace().replace().replace().replace().replace().replace.replace().replace().replace", "w.replace().replace().replace().replace().replace().replace.replace().replace().replace().replace().replace().replace.replace().replace", "w.replace().replace().replace().replace().replace().replace.replace().replace().replace().replace().replace().replace.replace"], "methods", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.find_file", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.find_file", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.find_file", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.find_file", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.util.find_file", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.NL2Prog.train", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.NL2Prog.test", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.learn_meta.load_model", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.NL2Prog.test_new", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.JmtEmbeddings.emb", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.util.JmtEmbeddings.emb"], ["", "@", "staticmethod", "\n", "def", "run_wikisql", "(", "input_dir", ",", "output_dir", ",", "config", ",", "trained_model", "=", "None", ")", ":", "\n", "        ", "\"\"\" if trained_model is specified, we will perform a model testing \"\"\"", "\n", "train_file", "=", "app", ".", "util", ".", "find_file", "(", "input_dir", ",", "config", "[", "\"train_file\"", "]", ")", "\n", "dev_file", "=", "app", ".", "util", ".", "find_file", "(", "input_dir", ",", "config", "[", "\"dev_file\"", "]", ")", "\n", "test_file", "=", "app", ".", "util", ".", "find_file", "(", "input_dir", ",", "config", "[", "\"test_file\"", "]", ")", "\n", "\n", "jmt_embedding_file", "=", "app", ".", "util", ".", "find_file", "(", "input_dir", ",", "config", "[", "\"jmt_embedding_file\"", "]", ")", "\n", "glove_embedding_file", "=", "app", ".", "util", ".", "find_file", "(", "input_dir", ",", "config", "[", "\"glove_embedding_file\"", "]", ")", "\n", "\n", "hyper_param", "=", "config", "[", "\"hyper_param\"", "]", "\n", "max_epoch", "=", "hyper_param", "[", "\"max_epoch\"", "]", "\n", "num_data_used", "=", "hyper_param", "[", "\"num_data_used\"", "]", "\n", "\n", "print", "(", "\"|>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\"", ")", "\n", "print", "(", "\"|>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\"", ")", "\n", "print", "(", "\"[Config]\"", ")", "\n", "pprint", "(", "config", ")", "\n", "print", "(", "\"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<|\"", ")", "\n", "print", "(", "\"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<|\"", ")", "\n", "\n", "settings", "=", "{", "\n", "\"decoder_regex\"", ":", "config", "[", "\"decoder_regex\"", "]", ",", "\n", "\"explicit_pointer\"", ":", "config", "[", "\"explicit_pointer\"", "]", ",", "\n", "\"value_based_loss\"", ":", "config", "[", "\"value_based_loss\"", "]", ",", "\n", "\"num_data_used\"", ":", "hyper_param", "[", "\"num_data_used\"", "]", ",", "\n", "\"test_only\"", ":", "False", "if", "trained_model", "is", "None", "else", "True", ",", "\n", "\n", "\"X1_maxlen\"", ":", "hyper_param", "[", "\"X1_maxlen\"", "]", ",", "\n", "\"X2_maxlen\"", ":", "hyper_param", "[", "\"X2_maxlen\"", "]", ",", "\n", "\"Y_maxlen\"", ":", "hyper_param", "[", "\"Y_maxlen\"", "]", "\n", "}", "\n", "\n", "task", "=", "NL2Prog", "(", "train_file", "=", "train_file", ",", "\n", "dev_file", "=", "dev_file", ",", "\n", "test_file", "=", "test_file", ",", "\n", "settings", "=", "settings", ")", "\n", "\n", "pretrained_emb", "=", "None", "\n", "\n", "if", "jmt_embedding_file", "and", "glove_embedding_file", ":", "\n", "            ", "input_vocab", "=", "task", ".", "pnet_vocab", ".", "input_vocab", "\n", "pretrained_emb", "=", "np", ".", "zeros", "(", "[", "input_vocab", ".", "size", ",", "hyper_param", "[", "\"embedding_size\"", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "jmt_dim", "=", "hyper_param", "[", "\"jmt_embedding_size\"", "]", "\n", "glove_dim", "=", "hyper_param", "[", "\"glove_embedding_size\"", "]", "\n", "\n", "if", "jmt_dim", ">", "0", ":", "\n", "                ", "full_jmt_embeddings", "=", "JmtEmbeddings", "(", "jmt_embedding_file", ",", "d_emb", "=", "jmt_dim", ")", "\n", "\n", "", "if", "glove_dim", ">", "0", ":", "\n", "                ", "full_glove_embeddings", "=", "GloVeEmbeddings", "(", "glove_embedding_file", ",", "d_emb", "=", "glove_dim", ")", "\n", "\n", "", "for", "i", "in", "input_vocab", ".", "index_word", ":", "\n", "                ", "w", "=", "input_vocab", ".", "index_word", "[", "i", "]", "\n", "v1", "=", "full_jmt_embeddings", ".", "emb", "(", "w", ")", "\n", "\n", "if", "jmt_dim", ">", "0", ":", "\n", "# jmt part", "\n", "                    ", "for", "j", "in", "range", "(", "len", "(", "v1", ")", ")", ":", "\n", "                        ", "pretrained_emb", "[", "i", "]", "[", "j", "]", "=", "v1", "[", "j", "]", "\n", "\n", "", "", "if", "glove_dim", ">", "0", ":", "\n", "# glove part", "\n", "                    ", "v_list", "=", "[", "]", "\n", "w", "=", "(", "w", ".", "replace", "(", "\"(\"", ",", "\"^\"", ")", ".", "replace", "(", "\")\"", ",", "\"^\"", ")", ".", "replace", "(", "\",\"", ",", "\"^\"", ")", "\n", ".", "replace", "(", "\".\"", ",", "\"^\"", ")", ".", "replace", "(", "\"\\'\"", ",", "\"^\"", ")", ".", "replace", "(", "\"/\"", ",", "\"^\"", ")", ")", "\n", "\n", "for", "x", "in", "w", ".", "split", "(", "\"^\"", ")", ":", "\n", "                        ", "if", "x", "==", "\"\"", ":", "\n", "                            ", "continue", "\n", "", "v_x", "=", "full_glove_embeddings", ".", "emb", "(", "x", ")", "\n", "if", "np", ".", "array", "(", "v_x", ")", ".", "any", "(", ")", ":", "\n", "                            ", "v_list", ".", "append", "(", "v_x", ")", "\n", "\n", "", "", "if", "v_list", ":", "\n", "                        ", "v2", "=", "np", ".", "mean", "(", "v_list", ",", "axis", "=", "0", ")", "\n", "for", "j", "in", "range", "(", "len", "(", "v2", ")", ")", ":", "\n", "                            ", "pretrained_emb", "[", "i", "]", "[", "j", "+", "jmt_dim", "]", "=", "v2", "[", "j", "]", "\n", "\n", "", "", "", "", "", "if", "trained_model", "is", "None", ":", "\n", "# in this case we want to train a new model", "\n", "            ", "graph", ",", "session", "=", "task", ".", "train", "(", "hyper_param", "=", "hyper_param", ",", "\n", "max_epoch", "=", "max_epoch", ",", "\n", "output_dir", "=", "output_dir", ",", "\n", "pretrained_emb", "=", "pretrained_emb", ")", "\n", "\n", "task", ".", "test", "(", "graph", ",", "session", ",", "hyper_param", ",", "output_dir", "=", "output_dir", ")", "\n", "\n", "", "else", ":", "\n", "# in this case we want to test a trained model", "\n", "            ", "graph", ",", "session", "=", "learn", ".", "load_model", "(", "trained_model", ")", "\n", "\n", "task", ".", "test_new", "(", "graph", ",", "session", ",", "hyper_param", ",", "pretrained_emb", ",", "output_dir", "=", "output_dir", ")", "\n", "\n", "print", "(", "\"[OK] Start building testing graph ...\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.to_xydata": [[24, 27], ["model.learn.XYData", "pnet_vocab.prepare_pointer_data"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetVocab.prepare_pointer_data"], ["def", "to_xydata", "(", "dataset", ",", "pnet_vocab", ",", "explicit_pointer", ",", "decoder_type", ")", ":", "\n", "# prepare xy data from a dataset", "\n", "    ", "return", "learn", ".", "XYData", "(", "*", "pnet_vocab", ".", "prepare_pointer_data", "(", "dataset", ",", "decoder_type", ",", "explicit_pointer", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.app.nl2prog.concat_in1_in2": [[28, 42], ["range", "range", "range", "range", "len", "result.append", "len", "result.append", "len", "result.append", "len", "result.append"], "function", ["None"], ["", "def", "concat_in1_in2", "(", "input1", ",", "input2", ",", "X1_maxlen", ",", "X2_maxlen", ")", ":", "\n", "    ", "\"\"\" input1 and input2 are both lists of tokens, \n        we concatenate them into a single input list X \"\"\"", "\n", "result", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "input1", ")", ")", ":", "\n", "        ", "result", ".", "append", "(", "input1", "[", "i", "]", ")", "\n", "", "for", "i", "in", "range", "(", "len", "(", "input1", ")", ",", "X1_maxlen", ")", ":", "\n", "        ", "result", ".", "append", "(", "Vocabulary", ".", "END_TOK", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "len", "(", "input2", ")", ")", ":", "\n", "        ", "result", ".", "append", "(", "input2", "[", "i", "]", ")", "\n", "", "for", "i", "in", "range", "(", "len", "(", "input2", ")", ",", "X2_maxlen", ")", ":", "\n", "        ", "result", ".", "append", "(", "Vocabulary", ".", "END_TOK", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.annotate.annotate": [[17, 33], ["stanza.nlp.corenlp.CoreNLPClient.annotate", "stanza.nlp.corenlp.CoreNLPClient", "words.append", "gloss.append", "after.append", "w.lower"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.annotate.annotate"], ["def", "annotate", "(", "sentence", ",", "lower", "=", "True", ")", ":", "\n", "    ", "global", "client", "\n", "if", "client", "is", "None", ":", "\n", "        ", "client", "=", "CoreNLPClient", "(", "default_annotators", "=", "'ssplit,tokenize'", ".", "split", "(", "','", ")", ")", "\n", "", "words", ",", "gloss", ",", "after", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "s", "in", "client", ".", "annotate", "(", "sentence", ")", ":", "\n", "        ", "for", "t", "in", "s", ":", "\n", "            ", "words", ".", "append", "(", "t", ".", "word", ")", "\n", "gloss", ".", "append", "(", "t", ".", "originalText", ")", "\n", "after", ".", "append", "(", "t", ".", "after", ")", "\n", "", "", "if", "lower", ":", "\n", "        ", "words", "=", "[", "w", ".", "lower", "(", ")", "for", "w", "in", "words", "]", "\n", "", "return", "{", "\n", "'gloss'", ":", "gloss", ",", "\n", "'words'", ":", "words", ",", "\n", "'after'", ":", "after", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.annotate.annotate_example": [[36, 66], ["annotate.annotate", "copy.deepcopy", "annotate.annotate", "annotate.annotate", "annotate.annotate", "annotate.annotate", "annotate.annotate", "str", "lib.common.detokenize"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.annotate.annotate", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.annotate.annotate", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.annotate.annotate", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.annotate.annotate", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.annotate.annotate", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.annotate.annotate"], ["", "def", "annotate_example", "(", "example", ",", "table", ")", ":", "\n", "    ", "ann", "=", "{", "'table_id'", ":", "example", "[", "'table_id'", "]", "}", "\n", "ann", "[", "'question'", "]", "=", "annotate", "(", "example", "[", "'question'", "]", ")", "\n", "ann", "[", "'table'", "]", "=", "{", "\n", "'header'", ":", "[", "annotate", "(", "h", ")", "for", "h", "in", "table", "[", "'header'", "]", "]", ",", "\n", "}", "\n", "ann", "[", "'query'", "]", "=", "sql", "=", "copy", ".", "deepcopy", "(", "example", "[", "'sql'", "]", ")", "\n", "for", "c", "in", "ann", "[", "'query'", "]", "[", "'conds'", "]", ":", "\n", "        ", "c", "[", "-", "1", "]", "=", "annotate", "(", "str", "(", "c", "[", "-", "1", "]", ")", ")", "\n", "\n", "", "q1", "=", "'SYMSELECT SYMAGG {} SYMCOL {}'", ".", "format", "(", "Query", ".", "agg_ops", "[", "sql", "[", "'agg'", "]", "]", ",", "table", "[", "'header'", "]", "[", "sql", "[", "'sel'", "]", "]", ")", "\n", "q2", "=", "[", "'SYMCOL {} SYMOP {} SYMCOND {}'", ".", "format", "(", "table", "[", "'header'", "]", "[", "col", "]", ",", "Query", ".", "cond_ops", "[", "op", "]", ",", "detokenize", "(", "cond", ")", ")", "for", "col", ",", "op", ",", "cond", "in", "sql", "[", "'conds'", "]", "]", "\n", "if", "q2", ":", "\n", "        ", "q2", "=", "'SYMWHERE '", "+", "' SYMAND '", ".", "join", "(", "q2", ")", "+", "' SYMEND'", "\n", "", "else", ":", "\n", "        ", "q2", "=", "'SYMEND'", "\n", "", "inp", "=", "'SYMSYMS {syms} SYMAGGOPS {aggops} SYMCONDOPS {condops} SYMTABLE {table} SYMQUESTION {question} SYMEND'", ".", "format", "(", "\n", "syms", "=", "' '", ".", "join", "(", "[", "'SYM'", "+", "s", "for", "s", "in", "Query", ".", "syms", "]", ")", ",", "\n", "table", "=", "' '", ".", "join", "(", "[", "'SYMCOL '", "+", "s", "for", "s", "in", "table", "[", "'header'", "]", "]", ")", ",", "\n", "question", "=", "example", "[", "'question'", "]", ",", "\n", "aggops", "=", "' '", ".", "join", "(", "[", "s", "for", "s", "in", "Query", ".", "agg_ops", "]", ")", ",", "\n", "condops", "=", "' '", ".", "join", "(", "[", "s", "for", "s", "in", "Query", ".", "cond_ops", "]", ")", ",", "\n", ")", "\n", "ann", "[", "'seq_input'", "]", "=", "annotate", "(", "inp", ")", "\n", "out", "=", "'{q1} {q2}'", ".", "format", "(", "q1", "=", "q1", ",", "q2", "=", "q2", ")", "if", "q2", "else", "q1", "\n", "ann", "[", "'seq_output'", "]", "=", "annotate", "(", "out", ")", "\n", "ann", "[", "'where_output'", "]", "=", "annotate", "(", "q2", ")", "\n", "assert", "'symend'", "in", "ann", "[", "'seq_output'", "]", "[", "'words'", "]", "\n", "assert", "'symend'", "in", "ann", "[", "'where_output'", "]", "[", "'words'", "]", "\n", "return", "ann", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.annotate.is_valid_example": [[68, 86], ["set", "set", "all", "lib.common.detokenize().lower", "len", "len", "set", "print", "lib.common.detokenize", "print"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print"], ["", "def", "is_valid_example", "(", "e", ")", ":", "\n", "    ", "if", "not", "all", "(", "[", "h", "[", "'words'", "]", "for", "h", "in", "e", "[", "'table'", "]", "[", "'header'", "]", "]", ")", ":", "\n", "        ", "return", "False", "\n", "", "headers", "=", "[", "detokenize", "(", "h", ")", ".", "lower", "(", ")", "for", "h", "in", "e", "[", "'table'", "]", "[", "'header'", "]", "]", "\n", "if", "len", "(", "headers", ")", "!=", "len", "(", "set", "(", "headers", ")", ")", ":", "\n", "        ", "return", "False", "\n", "", "input_vocab", "=", "set", "(", "e", "[", "'seq_input'", "]", "[", "'words'", "]", ")", "\n", "for", "w", "in", "e", "[", "'seq_output'", "]", "[", "'words'", "]", ":", "\n", "        ", "if", "w", "not", "in", "input_vocab", ":", "\n", "            ", "print", "(", "'query word \"{}\" is not in input vocabulary.\\n{}'", ".", "format", "(", "w", ",", "e", "[", "'seq_input'", "]", "[", "'words'", "]", ")", ")", "\n", "return", "False", "\n", "", "", "input_vocab", "=", "set", "(", "e", "[", "'question'", "]", "[", "'words'", "]", ")", "\n", "for", "col", ",", "op", ",", "cond", "in", "e", "[", "'query'", "]", "[", "'conds'", "]", ":", "\n", "        ", "for", "w", "in", "cond", "[", "'words'", "]", ":", "\n", "            ", "if", "w", "not", "in", "input_vocab", ":", "\n", "                ", "print", "(", "'cond word \"{}\" is not in input vocabulary.\\n{}'", ".", "format", "(", "w", ",", "e", "[", "'question'", "]", "[", "'words'", "]", ")", ")", "\n", "return", "False", "\n", "", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.annotate.process_tables": [[88, 116], ["range", "open", "tqdm.tqdm", "len", "ujson.loads", "open", "lib.common.count_lines", "tables.append", "fo.write", "print", "annotate.process_tables._join_words"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print"], ["", "def", "process_tables", "(", "ftable", ",", "fout", "=", "None", ")", ":", "\n", "\n", "# join words together", "\n", "    ", "def", "_join_words", "(", "entry", ")", ":", "\n", "        ", "result", "=", "\"\"", "\n", "for", "i", "in", "range", "(", "len", "(", "entry", "[", "\"words\"", "]", ")", ")", ":", "\n", "            ", "result", "+=", "entry", "[", "\"words\"", "]", "[", "i", "]", "+", "(", "entry", "[", "\"after\"", "]", "[", "i", "]", "if", "entry", "[", "\"after\"", "]", "[", "i", "]", "is", "not", "\" \"", "else", "\"^\"", ")", "\n", "", "return", "result", "\n", "\n", "", "tables", "=", "[", "]", "\n", "with", "open", "(", "ftable", ")", "as", "ft", ":", "\n", "        ", "for", "line", "in", "tqdm", "(", "ft", ",", "total", "=", "count_lines", "(", "ftable", ")", ")", ":", "\n", "            ", "raw_table", "=", "json", ".", "loads", "(", "line", ")", "\n", "try", ":", "\n", "                ", "table", "=", "{", "\n", "\"id\"", ":", "raw_table", "[", "\"id\"", "]", ",", "\n", "\"header\"", ":", "[", "_join_words", "(", "annotate", "(", "h", ")", ")", "for", "h", "in", "raw_table", "[", "\"header\"", "]", "]", ",", "\n", "\"content\"", ":", "[", "[", "_join_words", "(", "annotate", "(", "str", "(", "tok", ")", ")", ")", "for", "tok", "in", "l", "]", "for", "l", "in", "raw_table", "[", "\"rows\"", "]", "]", "\n", "}", "\n", "tables", ".", "append", "(", "table", ")", "\n", "", "except", ":", "\n", "                ", "print", "(", "line", ")", "\n", "break", "\n", "\n", "", "", "", "if", "fout", "is", "not", "None", ":", "\n", "        ", "with", "open", "(", "fout", ",", "\"w+\"", ")", "as", "fo", ":", "\n", "            ", "for", "table", "in", "tables", ":", "\n", "                ", "fo", ".", "write", "(", "json", ".", "dumps", "(", "table", ")", "+", "\"\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.annotate.process_examples": [[118, 145], ["print", "open", "open", "open", "print", "tqdm.tqdm", "print", "tqdm.tqdm", "print", "ujson.loads", "ujson.loads", "annotate.annotate_example", "lib.query.Query.from_tokenized_dict", "lib.query.Query.from_sequence", "fo.write", "lib.common.count_lines", "lib.common.count_lines", "annotate.is_valid_example", "print", "Exception", "Query.from_tokenized_dict.lower", "Query.from_sequence.lower", "Exception", "str", "str", "ujson.dumps"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.annotate.annotate_example", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.annotate.is_valid_example", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print"], ["", "", "", "", "def", "process_examples", "(", "fexample", ",", "ftable", ",", "fout", ")", ":", "\n", "    ", "print", "(", "'annotating {}'", ".", "format", "(", "fexample", ")", ")", "\n", "with", "open", "(", "fexample", ")", "as", "fs", ",", "open", "(", "ftable", ")", "as", "ft", ",", "open", "(", "fout", ",", "'wt'", ")", "as", "fo", ":", "\n", "        ", "print", "(", "'loading tables'", ")", "\n", "tables", "=", "{", "}", "\n", "for", "line", "in", "tqdm", "(", "ft", ",", "total", "=", "count_lines", "(", "ftable", ")", ")", ":", "\n", "            ", "d", "=", "json", ".", "loads", "(", "line", ")", "\n", "tables", "[", "d", "[", "'id'", "]", "]", "=", "d", "\n", "", "print", "(", "'loading examples'", ")", "\n", "n_written", "=", "0", "\n", "for", "line", "in", "tqdm", "(", "fs", ",", "total", "=", "count_lines", "(", "fexample", ")", ")", ":", "\n", "            ", "d", "=", "json", ".", "loads", "(", "line", ")", "\n", "a", "=", "annotate_example", "(", "d", ",", "tables", "[", "d", "[", "'table_id'", "]", "]", ")", "\n", "if", "not", "is_valid_example", "(", "a", ")", ":", "\n", "                ", "print", "(", "str", "(", "a", ")", ")", "\n", "continue", "\n", "raise", "Exception", "(", "str", "(", "a", ")", ")", "\n", "\n", "", "gold", "=", "Query", ".", "from_tokenized_dict", "(", "a", "[", "'query'", "]", ")", "\n", "reconstruct", "=", "Query", ".", "from_sequence", "(", "a", "[", "'seq_output'", "]", ",", "a", "[", "'table'", "]", ",", "lowercase", "=", "True", ")", "\n", "if", "gold", ".", "lower", "(", ")", "!=", "reconstruct", ".", "lower", "(", ")", ":", "\n", "                ", "raise", "Exception", "(", "'Expected:\\n{}\\nGot:\\n{}'", ".", "format", "(", "gold", ",", "reconstruct", ")", ")", "\n", "", "fo", ".", "write", "(", "json", ".", "dumps", "(", "a", ")", "+", "'\\n'", ")", "\n", "#print(a)", "\n", "#break", "\n", "n_written", "+=", "1", "\n", "", "print", "(", "'wrote {} examples'", ".", "format", "(", "n_written", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.relevance.load_file": [[12, 26], ["open", "enumerate", "line.rstrip.rstrip", "data.append"], "function", ["None"], ["def", "load_file", "(", "filename", ")", ":", "\n", "  ", "data", "=", "[", "]", "\n", "with", "open", "(", "filename", ")", "as", "f", ":", "\n", "    ", "for", "idx", ",", "line", "in", "enumerate", "(", "f", ")", ":", "\n", "      ", "line", "=", "line", ".", "rstrip", "(", ")", "\n", "if", "idx", "%", "4", "==", "0", ":", "\n", "        ", "col_name", "=", "line", "\n", "", "elif", "idx", "%", "4", "==", "1", ":", "\n", "        ", "question", "=", "line", "\n", "", "elif", "idx", "%", "4", "==", "2", ":", "\n", "        ", "sql", "=", "line", "\n", "", "elif", "idx", "%", "4", "==", "3", ":", "\n", "        ", "data", ".", "append", "(", "(", "col_name", ",", "question", ",", "sql", ")", ")", "\n", "", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.relevance.question_classifier": [[28, 49], ["set", "dict", "numpy.array", "sklearn.pipeline.Pipeline", "sklearn.pipeline.Pipeline.fit", "sklearn.pipeline.Pipeline.predict", "print", "i[].split", "numpy.mean", "enumerate", "enumerate", "sklearn.feature_extraction.text.CountVectorizer", "sklearn.feature_extraction.text.TfidfTransformer", "sklearn.svm.LinearSVC"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print"], ["", "", "def", "question_classifier", "(", "data", ")", ":", "\n", "  ", "questions", "=", "[", "i", "[", "1", "]", "for", "i", "in", "data", "]", "\n", "sql_type", "=", "[", "i", "[", "2", "]", ".", "split", "(", "' '", ")", "[", "1", "]", "for", "i", "in", "data", "]", "\n", "sql_type_set", "=", "set", "(", "sql_type", ")", "\n", "sql_classes", "=", "dict", "(", "[", "(", "type", ",", "i", ")", "for", "i", ",", "type", "in", "enumerate", "(", "sql_type_set", ")", "]", ")", "\n", "\n", "target", "=", "np", ".", "array", "(", "[", "sql_classes", "[", "i", "]", "for", "i", "in", "sql_type", "]", ")", "\n", "sql_type_to_indices", "=", "{", "}", "\n", "for", "type", "in", "sql_type_set", ":", "\n", "    ", "sql_type_to_indices", "[", "type", "]", "=", "[", "idx", "for", "idx", ",", "i", "in", "enumerate", "(", "sql_type", ")", "if", "i", "==", "type", "]", "\n", "\n", "# Build classifier", "\n", "# TODO better ones ", "\n", "", "text_clf", "=", "Pipeline", "(", "[", "(", "'vect'", ",", "CountVectorizer", "(", ")", ")", ",", "\n", "(", "'tfidf'", ",", "TfidfTransformer", "(", ")", ")", ",", "\n", "(", "'clf'", ",", "svm", ".", "LinearSVC", "(", ")", ")", "]", ")", "\n", "text_clf", ".", "fit", "(", "questions", ",", "target", ")", "\n", "predicted", "=", "text_clf", ".", "predict", "(", "questions", ")", "\n", "print", "(", "'Training Acc.: %f'", "%", "(", "np", ".", "mean", "(", "predicted", "==", "target", ")", ")", ")", "\n", "\n", "return", "sql_type_to_indices", ",", "text_clf", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.relevance.find_support_sets_rank": [[51, 108], ["dict", "dict", "enumerate", "numpy.array", "ref_clf.predict", "print", "enumerate", "len", "ref_table_id_to_index_dict[].append", "ref_clf.predict.tolist", "set", "dict", "len", "range", "random.shuffle", "random.shuffle", "random.shuffle", "support_idx.append", "print", "i[].split", "i[].split", "i[].split", "i[].split", "numpy.mean", "set.remove", "questions[].split", "max", "min", "list", "random.shuffle", "random.choice", "range", "min", "max", "set.intersection", "sorted", "sorted", "list", "range", "min", "set", "abs", "dict.items", "dict.items", "len", "range", "max", "operator.itemgetter", "operator.itemgetter", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print"], ["", "def", "find_support_sets_rank", "(", "data", ",", "ref_data", ",", "ref_clf", ",", "ref_sql_type_to_indices", ")", ":", "\n", "# Rank similarity based on similar len of questions, same table, same type", "\n", "  ", "questions", "=", "[", "i", "[", "1", "]", "for", "i", "in", "data", "]", "\n", "ref_question_lens", "=", "[", "len", "(", "i", "[", "1", "]", ".", "split", "(", "' '", ")", ")", "for", "i", "in", "ref_data", "]", "\n", "ref_question_len_idx_dict", "=", "dict", "(", "(", "qlen", ",", "[", "i", "for", "i", "in", "range", "(", "len", "(", "ref_question_lens", ")", ")", "\n", "if", "ref_question_lens", "[", "i", "]", "==", "qlen", "]", ")", "for", "qlen", "in", "\n", "range", "(", "min", "(", "ref_question_lens", ")", ",", "max", "(", "ref_question_lens", ")", "+", "1", ")", ")", "\n", "\n", "table_ids", "=", "[", "i", "[", "0", "]", ".", "split", "(", "' '", ")", "[", "0", "]", "for", "i", "in", "data", "]", "\n", "ref_tables_ids", "=", "[", "i", "[", "0", "]", ".", "split", "(", "' '", ")", "[", "0", "]", "for", "i", "in", "ref_data", "]", "\n", "ref_table_id_to_index_dict", "=", "dict", "(", "[", "(", "table_id", ",", "[", "]", ")", "for", "table_id", "in", "ref_tables_ids", "]", ")", "\n", "for", "i", ",", "table_id", "in", "enumerate", "(", "ref_tables_ids", ")", ":", "\n", "    ", "ref_table_id_to_index_dict", "[", "table_id", "]", ".", "append", "(", "i", ")", "\n", "\n", "", "sql_type", "=", "[", "i", "[", "2", "]", ".", "split", "(", "' '", ")", "[", "1", "]", "for", "i", "in", "data", "]", "\n", "sql_classes", "=", "{", "'count'", ":", "0", ",", "'min'", ":", "1", ",", "'max'", ":", "2", ",", "'sum'", ":", "3", ",", "'avg'", ":", "4", ",", "'select'", ":", "5", "}", "\n", "sql_classes_ids", "=", "{", "0", ":", "'count'", ",", "1", ":", "'min'", ",", "2", ":", "'max'", ",", "3", ":", "'sum'", ",", "4", ":", "'avg'", ",", "5", ":", "'select'", "}", "\n", "target", "=", "np", ".", "array", "(", "[", "sql_classes", "[", "i", "]", "for", "i", "in", "sql_type", "]", ")", "\n", "\n", "predicted", "=", "ref_clf", ".", "predict", "(", "questions", ")", "\n", "print", "(", "'Acc.: %f'", "%", "(", "np", ".", "mean", "(", "predicted", "==", "target", ")", ")", ")", "\n", "\n", "# Output related indices", "\n", "support_idx", "=", "[", "]", "\n", "num_choice", "=", "5", "\n", "for", "idx", ",", "pred", "in", "enumerate", "(", "predicted", ".", "tolist", "(", ")", ")", ":", "\n", "    ", "candidate_set", "=", "set", "(", "ref_sql_type_to_indices", "[", "sql_classes_ids", "[", "pred", "]", "]", ")", "\n", "if", "data", "==", "ref_data", "and", "idx", "in", "candidate_set", ":", "## ignore itself", "\n", "      ", "candidate_set", ".", "remove", "(", "idx", ")", "\n", "", "id_to_score_dict", "=", "dict", "(", "[", "(", "i", ",", "0", ")", "for", "i", "in", "candidate_set", "]", ")", "\n", "\n", "question_len", "=", "len", "(", "questions", "[", "idx", "]", ".", "split", "(", "' '", ")", ")", "\n", "# similiar len (+-2) +=1", "\n", "for", "ilen", "in", "range", "(", "max", "(", "question_len", "-", "4", ",", "min", "(", "ref_question_lens", ")", ")", ",", "min", "(", "max", "(", "ref_question_lens", ")", ",", "question_len", "+", "5", ")", ")", ":", "\n", "      ", "ref_idx_list", "=", "list", "(", "candidate_set", ".", "intersection", "(", "set", "(", "ref_question_len_idx_dict", "[", "ilen", "]", ")", ")", ")", "\n", "random", ".", "shuffle", "(", "ref_idx_list", ")", "\n", "for", "ref_idx", "in", "ref_idx_list", ":", "\n", "          ", "if", "abs", "(", "ilen", "-", "question_len", ")", "<=", "2", ":", "\n", "            ", "id_to_score_dict", "[", "ref_idx", "]", "+=", "0.5", "\n", "\n", "# top scores ones + random selected ones", "\n", "", "", "", "_top_candidates", "=", "[", "i", "[", "0", "]", "for", "i", "in", "sorted", "(", "id_to_score_dict", ".", "items", "(", ")", ",", "key", "=", "operator", ".", "itemgetter", "(", "1", ")", ",", "reverse", "=", "True", ")", "if", "i", "[", "1", "]", ">=", "1.5", "]", "\n", "random", ".", "shuffle", "(", "_top_candidates", ")", "\n", "_top_candidates", "=", "_top_candidates", "[", ":", "num_choice", "]", "\n", "\n", "_mid_candidates", "=", "[", "i", "[", "0", "]", "for", "i", "in", "sorted", "(", "id_to_score_dict", ".", "items", "(", ")", ",", "key", "=", "operator", ".", "itemgetter", "(", "1", ")", ",", "\n", "reverse", "=", "True", ")", "if", "i", "[", "1", "]", ">", "0", "and", "i", "[", "1", "]", "<", "1.5", "]", "\n", "random", ".", "shuffle", "(", "_mid_candidates", ")", "\n", "_mid_candidates", "=", "_mid_candidates", "[", ":", "num_choice", "-", "len", "(", "_top_candidates", ")", "]", "\n", "\n", "_random_candidate", "=", "[", "random", ".", "choice", "(", "list", "(", "candidate_set", ")", ")", "for", "_", "in", "range", "(", "num_choice", "-", "len", "(", "_top_candidates", ")", "-", "len", "(", "_mid_candidates", ")", ")", "]", "\n", "random", ".", "shuffle", "(", "_random_candidate", ")", "\n", "\n", "support_idx", ".", "append", "(", "_top_candidates", "+", "_mid_candidates", "+", "_random_candidate", ")", "\n", "print", "(", "idx", ",", "table_ids", "[", "idx", "]", ",", "support_idx", "[", "-", "1", "]", ")", "\n", "\n", "", "return", "support_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.relevance.print_support_set": [[110, 117], ["len", "range", "open", "f.write"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.None.run.Logger.write"], ["", "def", "print_support_set", "(", "support_idx", ",", "data", ",", "filename", ")", ":", "\n", "  ", "num_choice", "=", "len", "(", "support_idx", "[", "0", "]", ")", "\n", "for", "i", "in", "range", "(", "num_choice", ")", ":", "\n", "    ", "with", "open", "(", "filename", "+", "'_%d'", "%", "i", ",", "'w'", ")", "as", "f", ":", "\n", "      ", "for", "support", "in", "support_idx", ":", "\n", "        ", "col_name", ",", "question", ",", "sql", "=", "data", "[", "support", "[", "i", "]", "]", "\n", "f", ".", "write", "(", "'%s\\n%s\\n%s\\n\\n'", "%", "(", "col_name", ",", "question", ",", "sql", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare.prepare_data": [[9, 15], ["open", "open", "qf.readlines", "json.loads", "print"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print"], ["def", "prepare_data", "(", "question_file", ",", "table_file", ")", ":", "\n", "    ", "with", "open", "(", "question_file", ",", "\"r\"", ")", "as", "qf", ",", "open", "(", "table_file", ")", "as", "tf", ":", "\n", "        ", "for", "l", "in", "qf", ".", "readlines", "(", ")", ":", "\n", "            ", "question", "=", "json", ".", "loads", "(", "l", ")", "\n", "print", "(", "question", ")", "\n", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare.strip_brackets": [[16, 18], ["s.replace().replace", "s.replace"], "function", ["None"], ["", "", "", "def", "strip_brackets", "(", "s", ")", ":", "\n", "    ", "return", "s", ".", "replace", "(", "\"-lrb-\"", ",", "\"(\"", ")", ".", "replace", "(", "\"-rrb-\"", ",", "\")\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare.load_annotated_tables": [[19, 26], ["open", "f.readlines", "json.loads", "l.replace"], "function", ["None"], ["", "def", "load_annotated_tables", "(", "file", ")", ":", "\n", "    ", "tables", "=", "{", "}", "\n", "with", "open", "(", "file", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "for", "l", "in", "f", ".", "readlines", "(", ")", ":", "\n", "            ", "raw", "=", "json", ".", "loads", "(", "l", ".", "replace", "(", "\"`\"", ",", "\"\\'\"", ")", ")", "\n", "tables", "[", "raw", "[", "\"id\"", "]", "]", "=", "raw", "\n", "", "", "return", "tables", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare.is_number": [[27, 33], ["float"], "function", ["None"], ["", "def", "is_number", "(", "s", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "float", "(", "s", ")", "\n", "return", "True", "\n", "", "except", "ValueError", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare.normalize_const_to_table_entry": [[34, 54], ["prepare.is_number", "prepare.overlap_score", "v.split", "prepare.overlap_score", "v.split", "v.split", "v.split", "v.split"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.is_number", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.overlap_score", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.overlap_score"], ["", "", "def", "normalize_const_to_table_entry", "(", "val", ",", "head_to_values", ",", "exact_match", "=", "False", ")", ":", "\n", "# l_const is a constant represented in list form ", "\n", "    ", "if", "is_number", "(", "\"\"", ".", "join", "(", "val", ")", ")", ":", "\n", "# no need to normalize", "\n", "        ", "return", "val", "\n", "\n", "", "best_score", "=", "0", "\n", "best_match", "=", "None", "\n", "for", "h", "in", "head_to_values", ":", "\n", "        ", "for", "v", "in", "head_to_values", "[", "h", "]", ":", "\n", "            ", "if", "not", "exact_match", "and", "overlap_score", "(", "v", ".", "split", "(", "\"^\"", ")", ",", "val", ")", ">", "best_score", ":", "\n", "                ", "best_score", "=", "overlap_score", "(", "v", ".", "split", "(", "\"^\"", ")", ",", "val", ")", "\n", "best_match", "=", "v", "\n", "\n", "", "if", "\"\"", ".", "join", "(", "val", ")", "==", "v", "or", "\"\"", ".", "join", "(", "val", ")", "==", "\"\"", ".", "join", "(", "v", ".", "split", "(", "\"^\"", ")", ")", "or", "\"\"", ".", "join", "(", "val", ")", ".", "replace", "(", "\"`\"", ",", "\"\\'\"", ")", "==", "\"\"", ".", "join", "(", "v", ".", "split", "(", "\"^\"", ")", ")", ":", "\n", "# they match exactly but with wrong noise", "\n", "                ", "best_score", "=", "999", "\n", "best_match", "=", "v", ".", "split", "(", "\"^\"", ")", "\n", "\n", "", "", "", "return", "best_match", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare.find_best_match": [[55, 63], ["prepare.overlap_score", "prepare.overlap_score", "v.split", "v.split"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.overlap_score", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.overlap_score"], ["", "def", "find_best_match", "(", "val", ",", "lst", ")", ":", "\n", "    ", "best_score", "=", "0", "\n", "best_match", "=", "None", "\n", "for", "v", "in", "lst", ":", "\n", "        ", "if", "overlap_score", "(", "v", ".", "split", "(", ")", ",", "val", ")", ">", "best_score", ":", "\n", "            ", "best_score", "=", "overlap_score", "(", "v", ".", "split", "(", ")", ",", "val", ")", "\n", "best_match", "=", "v", "\n", "", "", "return", "best_match", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare.is_permutation": [[64, 98], ["len", "len", "v.replace.replace"], "function", ["None"], ["", "def", "is_permutation", "(", "l1", ",", "l2", ",", "ignore", "=", "[", "\",\"", "]", ")", ":", "\n", "\n", "    ", "if", "l1", "[", "0", "]", "in", "ignore", "or", "l2", "[", "0", "]", "in", "ignore", ":", "\n", "        ", "return", "False", "\n", "\n", "", "l1_bag", "=", "{", "}", "\n", "for", "v", "in", "l1", ":", "\n", "        ", "if", "v", "in", "ignore", ":", "\n", "            ", "continue", "\n", "", "if", "not", "v", "in", "l1_bag", ":", "\n", "            ", "l1_bag", "[", "v", "]", "=", "0", "\n", "", "l1_bag", "[", "v", "]", "+=", "1", "\n", "", "l2_bag", "=", "{", "}", "\n", "\n", "for", "v", "in", "l2", ":", "\n", "        ", "if", "v", "in", "ignore", ":", "\n", "            ", "continue", "\n", "", "for", "i", "in", "ignore", ":", "\n", "            ", "if", "i", "in", "v", ":", "\n", "                ", "v", "=", "v", ".", "replace", "(", "\",\"", ",", "\"\"", ")", "\n", "", "", "if", "not", "v", "in", "l2_bag", ":", "\n", "            ", "l2_bag", "[", "v", "]", "=", "0", "\n", "", "l2_bag", "[", "v", "]", "+=", "1", "\n", "\n", "", "if", "len", "(", "l1_bag", ")", "!=", "len", "(", "l2_bag", ")", ":", "\n", "        ", "return", "False", "\n", "\n", "", "for", "v", "in", "l1_bag", ":", "\n", "        ", "if", "v", "not", "in", "l2_bag", ":", "\n", "            ", "return", "False", "\n", "", "if", "l2_bag", "[", "v", "]", "!=", "l1_bag", "[", "v", "]", ":", "\n", "            ", "return", "False", "\n", "\n", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare.load_annotated_data": [[99, 324], ["print", "print", "print", "open", "f.readlines", "len", "print", "print", "print", "print", "json.loads", "used_cols.append", "range", "prepare.normalize_const_to_table_entry", "used_cols.append", "all_preds.append", "print", "print", "print", "print", "excluded_cases.append", "len", "range", "select.index", "current_pred.append", "q.replace.split", "prepare.strip_brackets", "prepare.strip_brackets", "prepare.strip_brackets", "len", "head_to_values[].append", "a.index", "a.index", "a.index", "select.index", "prepare.find_best_match", "predicates.append", "q.replace.split", "q.replace.replace", "q.replace.split", "range", "q.replace.split", "q.replace.replace", "k.split", "q.replace.split", "range", "len", "select.index", "pred_toks.index", "prepare.find_best_match", "pred_toks.index", "pred_toks.index", "q.replace.split", "len", "range", "q.replace.replace", "q.replace.split", "range", "len", "range", "q.replace.replace", "q.replace.replace", "q.replace.index", "pred_toks.index", "pred_toks.index", "len", "len", "len", "len", "prepare.overlap_score", "v.replace", "const_dict[].replace", "related_header.append", "len", "q.replace.index", "prepare.is_permutation", "q.replace.replace", "select.index", "pred_toks.index", "k.replace().split", "len", "prepare.edit_distance", "pred_toks.index", "k.replace().replace", "k.replace", "k.replace"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.normalize_const_to_table_entry", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare.strip_brackets", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare.strip_brackets", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare.strip_brackets", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.find_best_match", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.find_best_match", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.overlap_score", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.is_permutation", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare.edit_distance"], ["", "def", "load_annotated_data", "(", "file", ",", "tables", "=", "None", ",", "process_level", "=", "2", ")", ":", "\n", "    ", "\"\"\" load annotated examples from the datafile \"\"\"", "\n", "result", "=", "[", "]", "\n", "valid_cnt", "=", "0", "\n", "excluded_cases", "=", "[", "]", "\n", "error_cases", "=", "[", "]", "\n", "wrong", "=", "0", "\n", "\n", "with", "open", "(", "file", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "for", "l", "in", "f", ".", "readlines", "(", ")", ":", "\n", "            ", "raw", "=", "json", ".", "loads", "(", "l", ")", "\n", "\n", "head_dict", "=", "{", "}", "\n", "for", "h", "in", "raw", "[", "\"table\"", "]", "[", "\"header\"", "]", ":", "\n", "                ", "h_str", "=", "\"\"", "\n", "for", "i", "in", "range", "(", "len", "(", "h", "[", "\"words\"", "]", ")", ")", ":", "\n", "                    ", "h_str", "+=", "h", "[", "\"words\"", "]", "[", "i", "]", "+", "(", "h", "[", "\"after\"", "]", "[", "i", "]", "if", "h", "[", "\"after\"", "]", "[", "i", "]", "is", "not", "\" \"", "else", "\"^\"", ")", "\n", "", "head_dict", "[", "\" \"", ".", "join", "(", "h", "[", "\"words\"", "]", ")", "]", "=", "h_str", "\n", "\n", "", "header", "=", "\" \"", ".", "join", "(", "[", "head_dict", "[", "k", "]", "for", "k", "in", "head_dict", "]", ")", "\n", "\n", "# maintain mappings from table header to its values, used to manually set up head names", "\n", "if", "tables", ":", "\n", "                ", "head_to_values", "=", "{", "}", "\n", "for", "row", "in", "tables", "[", "raw", "[", "\"table_id\"", "]", "]", "[", "\"content\"", "]", ":", "\n", "                    ", "for", "i", "in", "range", "(", "len", "(", "row", ")", ")", ":", "\n", "                        ", "if", "tables", "[", "raw", "[", "\"table_id\"", "]", "]", "[", "\"header\"", "]", "[", "i", "]", "not", "in", "head_to_values", ":", "\n", "                            ", "head_to_values", "[", "tables", "[", "raw", "[", "\"table_id\"", "]", "]", "[", "\"header\"", "]", "[", "i", "]", "]", "=", "[", "]", "\n", "", "head_to_values", "[", "tables", "[", "raw", "[", "\"table_id\"", "]", "]", "[", "\"header\"", "]", "[", "i", "]", "]", ".", "append", "(", "row", "[", "i", "]", ")", "\n", "\n", "", "", "", "q", "=", "raw", "[", "\"seq_input\"", "]", "[", "\"words\"", "]", "[", "26", ":", "]", "\n", "q", "=", "\" \"", ".", "join", "(", "q", "[", "q", ".", "index", "(", "\"symquestion\"", ")", "+", "1", ":", "q", ".", "index", "(", "\"symend\"", ")", "]", ")", ".", "replace", "(", "\"`\"", ",", "\"\\'\"", ")", "\n", "raw_q", "=", "q", "\n", "\n", "a", "=", "raw", "[", "\"seq_output\"", "]", "[", "\"words\"", "]", "\n", "select", "=", "a", "[", "a", ".", "index", "(", "\"symselect\"", ")", "+", "1", ":", "a", ".", "index", "(", "\"symwhere\"", ")", "if", "\"symwhere\"", "in", "a", "else", "a", ".", "index", "(", "\"symend\"", ")", "]", "\n", "agg", "=", "select", "[", "select", ".", "index", "(", "\"symagg\"", ")", "+", "1", ":", "select", ".", "index", "(", "\"symcol\"", ")", "]", "\n", "\n", "sel_raw", "=", "\" \"", ".", "join", "(", "select", "[", "select", ".", "index", "(", "\"symcol\"", ")", "+", "1", ":", "]", ")", "\n", "\n", "if", "sel_raw", "in", "head_dict", ":", "\n", "                ", "select_col", "=", "head_dict", "[", "sel_raw", "]", "\n", "", "else", ":", "\n", "                ", "select_col", "=", "head_dict", "[", "find_best_match", "(", "select", "[", "select", ".", "index", "(", "\"symcol\"", ")", "+", "1", ":", "]", ",", "[", "h", "for", "h", "in", "head_dict", "]", ")", "]", "\n", "\n", "", "where", "=", "raw", "[", "\"where_output\"", "]", "[", "\"words\"", "]", "# a[a.index(\"symwhere\") + 1 : a.index(\"symend\")]", "\n", "predicates", "=", "[", "]", "\n", "current_pred", "=", "None", "\n", "for", "tok", "in", "where", ":", "\n", "                ", "if", "tok", "==", "\"symwhere\"", ":", "\n", "                    ", "continue", "\n", "", "if", "tok", "==", "\"symcol\"", ":", "\n", "                    ", "current_pred", "=", "[", "]", "\n", "", "if", "tok", "in", "[", "\"symend\"", ",", "\"symand\"", "]", ":", "\n", "                    ", "if", "current_pred", ":", "\n", "                        ", "predicates", ".", "append", "(", "current_pred", ")", "\n", "", "", "else", ":", "\n", "                    ", "current_pred", ".", "append", "(", "tok", ")", "\n", "\n", "", "", "const_dict", "=", "{", "}", "\n", "used_cols", "=", "[", "]", "\n", "\n", "all_preds", "=", "[", "]", "\n", "for", "pred_toks", "in", "predicates", ":", "\n", "\n", "                ", "raw_col", "=", "\" \"", ".", "join", "(", "pred_toks", "[", "pred_toks", ".", "index", "(", "\"symcol\"", ")", "+", "1", ":", "pred_toks", ".", "index", "(", "\"symop\"", ")", "]", ")", "\n", "if", "raw_col", "not", "in", "head_dict", ":", "\n", "                    ", "col", "=", "head_dict", "[", "find_best_match", "(", "pred_toks", "[", "pred_toks", ".", "index", "(", "\"symcol\"", ")", "+", "1", ":", "pred_toks", ".", "index", "(", "\"symop\"", ")", "]", ",", "[", "h", "for", "h", "in", "head_dict", "]", ")", "]", "\n", "", "else", ":", "\n", "                    ", "col", "=", "head_dict", "[", "raw_col", "]", "\n", "\n", "", "op", "=", "pred_toks", "[", "pred_toks", ".", "index", "(", "\"symop\"", ")", "+", "1", ":", "pred_toks", ".", "index", "(", "\"symcond\"", ")", "]", "[", "0", "]", "\n", "val", "=", "pred_toks", "[", "pred_toks", ".", "index", "(", "\"symcond\"", ")", "+", "1", ":", "]", "\n", "\n", "normalized_val", "=", "normalize_const_to_table_entry", "(", "val", ",", "head_to_values", ")", "\n", "\n", "if", "normalized_val", "==", "None", ":", "\n", "                    ", "wrong", "+=", "1", "\n", "", "else", ":", "\n", "                    ", "val", "=", "normalized_val", "\n", "\n", "", "const_dict", "[", "\" \"", ".", "join", "(", "val", ")", "]", "=", "\"^\"", ".", "join", "(", "val", ")", "\n", "\n", "pred", "=", "col", "+", "\" \"", "+", "op", "+", "\" \"", "+", "\"^\"", ".", "join", "(", "val", ")", "\n", "\n", "used_cols", ".", "append", "(", "col", ")", "\n", "all_preds", ".", "append", "(", "pred", ")", "\n", "\n", "", "used_cols", ".", "append", "(", "select_col", ")", "\n", "\n", "pred_str", "=", "\" \"", ".", "join", "(", "all_preds", ")", "\n", "output_str", "=", "(", "agg", "[", "0", "]", "if", "agg", "else", "\"select\"", ")", "+", "\" \"", "+", "select_col", "+", "\" \"", "+", "pred_str", "\n", "\n", "if", "process_level", ">=", "1", ":", "\n", "\n", "# replace unconsecutive phrases into a concatated phase ", "\n", "#   that allows pointer to points pointed to", "\n", "# e.g. date time --> date^time if date^time is a constant in the table", "\n", "# replace the highest score term based on overlapping", "\n", "                ", "for", "k", "in", "const_dict", ":", "\n", "\n", "                    ", "if", "k", "in", "q", ".", "split", "(", ")", ":", "\n", "                        ", "q", "=", "q", ".", "replace", "(", "k", ",", "const_dict", "[", "k", "]", ")", "\n", "", "else", ":", "\n", "                        ", "if", "const_dict", "[", "k", "]", "in", "q", ".", "split", "(", ")", ":", "\n", "                            ", "continue", "\n", "\n", "", "q_list", "=", "q", ".", "split", "(", ")", "\n", "\n", "max_score", "=", "0", "\n", "to_subst", "=", "None", "\n", "for", "i", "in", "range", "(", "len", "(", "q_list", ")", ")", ":", "\n", "                            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "q_list", ")", ")", ":", "\n", "\n", "                                ", "if", "max_score", "<", "9999", "and", "\"\"", ".", "join", "(", "q_list", "[", "i", ":", "j", "+", "1", "]", ")", "==", "\"\"", ".", "join", "(", "k", ".", "replace", "(", "\"^\"", ",", "\"\"", ")", ".", "replace", "(", "\" \"", ",", "\"\"", ")", ")", ":", "\n", "                                    ", "to_subst", "=", "\" \"", ".", "join", "(", "q_list", "[", "i", ":", "j", "+", "1", "]", ")", "\n", "max_score", "=", "9999", "\n", "\n", "", "if", "max_score", "==", "0", "and", "is_permutation", "(", "q_list", "[", "i", ":", "j", "+", "1", "]", ",", "k", ".", "replace", "(", "\"^\"", ",", "\" \"", ")", ".", "split", "(", ")", ")", ":", "\n", "                                    ", "to_subst", "=", "\" \"", ".", "join", "(", "q_list", "[", "i", ":", "j", "+", "1", "]", ")", "\n", "max_score", "=", "8888", "\n", "\n", "", "", "", "if", "to_subst", ":", "\n", "                            ", "q", "=", "q", ".", "replace", "(", "to_subst", ",", "const_dict", "[", "k", "]", ")", "\n", "\n", "", "", "", "", "if", "process_level", ">=", "1", ":", "\n", "\n", "# replace unconsecutive phrases into a concatated phase thta can be directly pointed to", "\n", "# e.g. date time --> date^time if date^time is a header name", "\n", "# only replace when it is full match since this is header (not mandatary)", "\n", "\n", "                ", "for", "k", "in", "head_dict", ":", "\n", "\n", "                    ", "if", "k", "in", "q", ".", "split", "(", ")", ":", "\n", "                        ", "q", "=", "q", ".", "replace", "(", "k", ",", "head_dict", "[", "k", "]", ")", "\n", "", "else", ":", "\n", "\n", "                        ", "if", "head_dict", "[", "k", "]", "in", "q", ".", "split", "(", ")", ":", "\n", "                            ", "continue", "\n", "\n", "", "k_list", "=", "k", ".", "split", "(", ")", "\n", "q_list", "=", "q", ".", "split", "(", ")", "\n", "\n", "# deal with cases with plural cases, ", "\n", "# this is only used on processing level 2 or above", "\n", "if", "process_level", ">=", "2", "and", "len", "(", "k_list", ")", "==", "1", ":", "\n", "                            ", "for", "i", "in", "range", "(", "len", "(", "q_list", ")", ")", ":", "\n", "                                ", "if", "len", "(", "k_list", "[", "0", "]", ")", ">", "2", "and", "edit_distance", "(", "q_list", "[", "i", "]", ",", "k_list", "[", "0", "]", ")", "==", "1", ":", "\n", "                                    ", "q", "=", "q", ".", "replace", "(", "q_list", "[", "i", "]", ",", "head_dict", "[", "k", "]", ")", "\n", "", "", "continue", "\n", "\n", "", "best_match", "=", "None", "\n", "best_match_score", "=", "-", "1", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "q_list", ")", ")", ":", "\n", "                            ", "for", "j", "in", "range", "(", "i", ",", "len", "(", "q_list", ")", ")", ":", "\n", "                                ", "score_ij", "=", "overlap_score", "(", "q_list", "[", "i", ":", "j", "+", "1", "]", ",", "k_list", ")", "\n", "\n", "if", "score_ij", ">", "best_match_score", ":", "\n", "                                    ", "best_match", "=", "\" \"", ".", "join", "(", "q_list", "[", "i", ":", "j", "+", "1", "]", ")", "\n", "best_match_score", "=", "score_ij", "\n", "\n", "", "", "", "if", "best_match_score", ">=", "0.5", ":", "\n", "                            ", "q", "=", "q", ".", "replace", "(", "best_match", ",", "head_dict", "[", "k", "]", ")", "\n", "\n", "", "", "", "", "if", "process_level", ">=", "2", "and", "tables", "and", "USE_COLUMN_ANNOTATION", ":", "\n", "                ", "\"\"\" \n                Process questions so that constants appearing in the table \n                have their column names associated with them\n                \"\"\"", "\n", "for", "k", "in", "const_dict", ":", "\n", "                    ", "related_header", "=", "[", "]", "\n", "\n", "for", "h", "in", "head_to_values", ":", "\n", "                        ", "for", "v", "in", "head_to_values", "[", "h", "]", ":", "\n", "                            ", "if", "v", ".", "replace", "(", "\"^\"", ",", "\"\"", ")", "==", "const_dict", "[", "k", "]", ".", "replace", "(", "\"^\"", ",", "\"\"", ")", ":", "\n", "                                ", "related_header", ".", "append", "(", "h", ")", "\n", "break", "\n", "\n", "", "", "", "if", "len", "(", "related_header", ")", "==", "0", ":", "\n", "                        ", "pass", "\n", "", "elif", "len", "(", "related_header", ")", "==", "1", "and", "related_header", "[", "0", "]", "not", "in", "q", ":", "\n", "                        ", "q", "=", "q", ".", "replace", "(", "\" \"", "+", "const_dict", "[", "k", "]", "+", "\" \"", ",", "\" \"", "+", "related_header", "[", "0", "]", "+", "\" \"", "+", "const_dict", "[", "k", "]", "+", "\" \"", ")", "\n", "", "else", ":", "\n", "                        ", "none_in_list", "=", "True", "\n", "for", "h", "in", "related_header", ":", "\n", "                            ", "if", "h", "in", "q", ":", "\n", "                                ", "none_in_list", "=", "False", "\n", "", "", "if", "none_in_list", ":", "\n", "                            ", "pass", "\n", "\n", "", "", "", "", "valid", "=", "True", "\n", "for", "k", "in", "const_dict", ":", "\n", "                ", "if", "const_dict", "[", "k", "]", "not", "in", "q", ".", "split", "(", ")", ":", "\n", "                    ", "valid", "=", "False", "\n", "#for c in used_cols:", "\n", "#    if c not in q.split():", "\n", "#        valid = False", "\n", "\n", "", "", "if", "valid", ":", "\n", "                ", "valid_cnt", "+=", "1", "\n", "print", "(", "strip_brackets", "(", "raw", "[", "\"table_id\"", "]", "+", "\" \"", "+", "header", ")", ")", "\n", "print", "(", "strip_brackets", "(", "q", ")", ")", "\n", "print", "(", "strip_brackets", "(", "raw", "[", "\"table_id\"", "]", "+", "\" \"", "+", "output_str", ")", ")", "\n", "print", "(", "\"\"", ")", "\n", "", "else", ":", "\n", "#print(\"-->\")", "\n", "#print(raw_q)", "\n", "#print(q)", "\n", "#print(output_str)", "\n", "#print(\"\")", "\n", "#print(used_cols)", "\n", "#print([const_dict[k] for k in const_dict])", "\n", "#pprint(head_dict)", "\n", "#print(\"\")", "\n", "                ", "excluded_cases", ".", "append", "(", "(", "raw", "[", "\"table_id\"", "]", "+", "\" \"", "+", "header", ",", "q", ",", "raw", "[", "\"table_id\"", "]", "+", "\" \"", "+", "output_str", ")", ")", "\n", "\n", "", "", "", "print", "(", "\"dudulu\"", ")", "\n", "print", "(", "len", "(", "excluded_cases", ")", ")", "\n", "print", "(", "valid_cnt", ")", "\n", "for", "e", "in", "excluded_cases", ":", "\n", "        ", "print", "(", "e", "[", "0", "]", ")", "\n", "print", "(", "e", "[", "1", "]", ")", "\n", "print", "(", "e", "[", "2", "]", ")", "\n", "print", "(", "\"\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare.is_subseq": [[326, 336], ["functools.reduce", "functools.reduce", "range", "len", "x.split", "x.split", "len"], "function", ["None"], ["", "", "def", "is_subseq", "(", "l1", ",", "l2", ")", ":", "\n", "    ", "l1", "=", "reduce", "(", "(", "lambda", "x", ",", "y", ":", "x", "+", "y", ")", ",", "[", "x", ".", "split", "(", "\".\"", ")", "for", "x", "in", "l1", "]", ")", "\n", "l2", "=", "reduce", "(", "(", "lambda", "x", ",", "y", ":", "x", "+", "y", ")", ",", "[", "x", ".", "split", "(", "\".\"", ")", "for", "x", "in", "l2", "]", ")", "\n", "i", "=", "0", "\n", "for", "j", "in", "range", "(", "len", "(", "l2", ")", ")", ":", "\n", "        ", "if", "l2", "[", "j", "]", "==", "l1", "[", "i", "]", ":", "\n", "            ", "i", "+=", "1", "\n", "", "if", "i", ">=", "len", "(", "l1", ")", ":", "\n", "            ", "return", "True", "\n", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare.overlap_score": [[338, 346], ["functools.reduce", "functools.reduce", "float", "float", "x.split", "x.split", "len", "len"], "function", ["None"], ["", "def", "overlap_score", "(", "l1", ",", "l2", ")", ":", "\n", "    ", "overlap_cnt", "=", "0", "\n", "l1", "=", "reduce", "(", "(", "lambda", "x", ",", "y", ":", "x", "+", "y", ")", ",", "[", "x", ".", "split", "(", "\".\"", ")", "for", "x", "in", "l1", "]", ")", "\n", "l2", "=", "reduce", "(", "(", "lambda", "x", ",", "y", ":", "x", "+", "y", ")", ",", "[", "x", ".", "split", "(", "\".\"", ")", "for", "x", "in", "l2", "]", ")", "\n", "for", "t", "in", "l2", ":", "\n", "        ", "if", "t", "in", "l1", ":", "\n", "            ", "overlap_cnt", "+=", "1", "\n", "", "", "return", "float", "(", "overlap_cnt", ")", "/", "float", "(", "len", "(", "l1", ")", "+", "len", "(", "l2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare.edit_distance": [[348, 359], ["range", "range", "range", "len", "len", "range", "min"], "function", ["None"], ["", "def", "edit_distance", "(", "s1", ",", "s2", ")", ":", "\n", "    ", "m", "=", "len", "(", "s1", ")", "+", "1", "\n", "n", "=", "len", "(", "s2", ")", "+", "1", "\n", "tbl", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "m", ")", ":", "tbl", "[", "i", ",", "0", "]", "=", "i", "\n", "for", "j", "in", "range", "(", "n", ")", ":", "tbl", "[", "0", ",", "j", "]", "=", "j", "\n", "for", "i", "in", "range", "(", "1", ",", "m", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "            ", "cost", "=", "0", "if", "s1", "[", "i", "-", "1", "]", "==", "s2", "[", "j", "-", "1", "]", "else", "1", "\n", "tbl", "[", "i", ",", "j", "]", "=", "min", "(", "tbl", "[", "i", ",", "j", "-", "1", "]", "+", "1", ",", "tbl", "[", "i", "-", "1", ",", "j", "]", "+", "1", ",", "tbl", "[", "i", "-", "1", ",", "j", "-", "1", "]", "+", "cost", ")", "\n", "", "", "return", "tbl", "[", "i", ",", "j", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.is_number": [[13, 19], ["float"], "function", ["None"], ["def", "is_number", "(", "s", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "float", "(", "s", ")", "\n", "return", "True", "\n", "", "except", "ValueError", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.normalize_case": [[21, 24], ["s.replace().lower.replace().lower", "s.replace().lower.replace"], "function", ["None"], ["", "", "def", "normalize_case", "(", "s", ")", ":", "\n", "    ", "s", "=", "s", ".", "replace", "(", "\"`\"", ",", "\"\\'\"", ")", ".", "lower", "(", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.normalize_phrase": [[26, 28], ["s.split"], "function", ["None"], ["", "def", "normalize_phrase", "(", "s", ")", ":", "\n", "    ", "return", "\"^\"", ".", "join", "(", "s", ".", "split", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.load_tables": [[30, 46], ["open", "f.readlines", "prepare_v2.normalize_case", "json.loads", "range", "prepare_v2.normalize_phrase", "len", "prepare_v2.normalize_phrase", "enumerate", "prepare_v2.is_number"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.normalize_case", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.normalize_phrase", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.normalize_phrase", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.is_number"], ["", "def", "load_tables", "(", "file", ")", ":", "\n", "    ", "tables", "=", "{", "}", "\n", "with", "open", "(", "file", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "for", "l", "in", "f", ".", "readlines", "(", ")", ":", "\n", "            ", "l", "=", "normalize_case", "(", "l", ")", "\n", "raw", "=", "json", ".", "loads", "(", "l", ")", "\n", "\n", "raw", "[", "'header'", "]", "=", "[", "normalize_phrase", "(", "h", ")", "for", "h", "in", "raw", "[", "\"header\"", "]", "]", "\n", "types", "=", "raw", "[", "'types'", "]", "\n", "rows", "=", "raw", "[", "'rows'", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "rows", ")", ")", ":", "\n", "                ", "rows", "[", "i", "]", "=", "[", "normalize_phrase", "(", "t", ")", "if", "not", "is_number", "(", "t", ")", "else", "t", "for", "j", ",", "t", "in", "enumerate", "(", "rows", "[", "i", "]", ")", "]", "\n", "\n", "", "tables", "[", "raw", "[", "\"id\"", "]", "]", "=", "raw", "\n", "\n", "", "", "return", "tables", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.load_data": [[48, 180], ["print", "open", "f.readlines", "print", "prepare_v2.normalize_case", "json.loads", "entry[].strip", "prepare_v2.identify_phrases", "enumerate", "prepare_v2.identify_phrases", "enumerate", "dataset.append", "len", "len", "all_consts.append", "sql_components.extend", "all_headers.append", "print", "print", "print", "print", "print", "print", "prepare_v2.is_number", "prepare_v2.normalize_phrase", "prepare_v2.normalize_const_to_table_entry", "all_consts.append", "dataset.append", "len", "processed_q.replace.split", "missed_const.append", "dataset.append", "print", "print", "print", "print", "print", "str", "processed_q.replace.replace", "related_header.append", "len"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.normalize_case", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.identify_phrases", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.identify_phrases", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.is_number", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.normalize_phrase", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.normalize_const_to_table_entry", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.model.pointer_net_helper.PnetExPrinter.print"], ["", "def", "load_data", "(", "file", ",", "orig_tables", ",", "annotated_tables", ",", "add_wrong_entry", "=", "False", ")", ":", "\n", "    ", "dataset", "=", "[", "]", "\n", "normalized_orig_dataset", "=", "[", "]", "\n", "\n", "with", "open", "(", "file", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "print", "(", "\"num_entry in {} : {}\"", ".", "format", "(", "file", ",", "len", "(", "lines", ")", ")", ")", "\n", "for", "l", "in", "lines", ":", "\n", "            ", "l", "=", "normalize_case", "(", "l", ")", "\n", "entry", "=", "json", ".", "loads", "(", "l", ")", "\n", "\n", "table_id", "=", "entry", "[", "\"table_id\"", "]", "\n", "\n", "orig_table", "=", "orig_tables", "[", "table_id", "]", "\n", "annotated_table", "=", "annotated_tables", "[", "table_id", "]", "\n", "\n", "orig_q", "=", "entry", "[", "\"question\"", "]", ".", "strip", "(", ")", "\n", "annotated_q", "=", "entry", "[", "\"annotated_question\"", "]", "\n", "\n", "sql_components", "=", "[", "table_id", ",", "\n", "agg_ops", "[", "entry", "[", "\"sql\"", "]", "[", "\"agg\"", "]", "]", ",", "\n", "orig_table", "[", "'header'", "]", "[", "entry", "[", "\"sql\"", "]", "[", "\"sel\"", "]", "]", "]", "\n", "\n", "# each element is a pair of (annotated_const, orig_const)", "\n", "# we want to match with the annotated one and replace with the orig one", "\n", "all_consts", "=", "[", "]", "\n", "\n", "flag_query_wrong", "=", "False", "\n", "flag_nl_missing_const", "=", "False", "\n", "\n", "# processing query", "\n", "for", "cond", "in", "entry", "[", "'sql'", "]", "[", "'annotated_conds'", "]", ":", "\n", "                ", "col", "=", "orig_table", "[", "'header'", "]", "[", "cond", "[", "0", "]", "]", "\n", "op", "=", "cond_ops", "[", "cond", "[", "1", "]", "]", "\n", "\n", "if", "not", "is_number", "(", "cond", "[", "2", "]", ")", ":", "\n", "\n", "                    ", "const", "=", "normalize_phrase", "(", "cond", "[", "2", "]", ")", "\n", "const", "=", "normalize_const_to_table_entry", "(", "const", ",", "orig_table", ",", "\n", "annotated_table", ")", "\n", "\n", "all_consts", ".", "append", "(", "(", "cond", "[", "2", "]", ",", "const", ")", ")", "\n", "if", "const", "is", "None", ":", "\n", "# encounter error", "\n", "# the constant in the query does not appear", "\n", "# in anywhere in the table", "\n", "                        ", "print", "(", "\"<<<\"", ")", "\n", "print", "(", "cond", "[", "2", "]", ")", "\n", "print", "(", "const", ")", "\n", "print", "(", "l", ")", "\n", "print", "(", "\">>>\"", ")", "\n", "flag_query_wrong", "=", "True", "\n", "", "", "else", ":", "\n", "# it's a number, so its normalized form is also a number", "\n", "                    ", "const", "=", "cond", "[", "2", "]", "\n", "\n", "", "all_consts", ".", "append", "(", "(", "cond", "[", "2", "]", ",", "const", ")", ")", "\n", "sql_components", ".", "extend", "(", "[", "col", ",", "op", ",", "str", "(", "const", ")", "]", ")", "\n", "\n", "", "if", "flag_query_wrong", ":", "\n", "                ", "if", "add_wrong_entry", ":", "\n", "# add a placeholder for wrong query", "\n", "                    ", "dataset", ".", "append", "(", "(", "table_id", "+", "\" \"", "+", "\" \"", ".", "join", "(", "orig_table", "[", "\"header\"", "]", ")", "+", "\" <ERR>\"", ",", "processed_q", ",", "\"<ERR>\"", ")", ")", "\n", "# we are not adding them into the dataset", "\n", "", "continue", "\n", "\n", "# processing question", "\n", "", "processed_q", "=", "identify_phrases", "(", "annotated_q", ",", "all_consts", ")", "\n", "\n", "all_headers", "=", "[", "]", "\n", "for", "i", ",", "annotated_h", "in", "enumerate", "(", "annotated_table", "[", "\"header\"", "]", ")", ":", "\n", "                ", "orig_h", "=", "orig_table", "[", "\"header\"", "]", "[", "i", "]", "\n", "all_headers", ".", "append", "(", "(", "annotated_h", ",", "orig_h", ")", ")", "\n", "\n", "", "processed_q", "=", "identify_phrases", "(", "processed_q", ",", "all_headers", ",", "False", ")", "\n", "\n", "# annotate column name", "\n", "head_to_values", "=", "{", "}", "\n", "for", "i", ",", "h", "in", "enumerate", "(", "orig_table", "[", "\"header\"", "]", ")", ":", "\n", "                ", "vals", "=", "[", "r", "[", "i", "]", "for", "r", "in", "orig_table", "[", "\"rows\"", "]", "]", "\n", "head_to_values", "[", "h", "]", "=", "vals", "\n", "\n", "", "for", "p", "in", "all_consts", ":", "\n", "                ", "related_header", "=", "[", "]", "\n", "for", "h", "in", "head_to_values", ":", "\n", "                    ", "for", "v", "in", "head_to_values", "[", "h", "]", ":", "\n", "                        ", "if", "v", "==", "p", "[", "1", "]", ":", "\n", "                            ", "related_header", ".", "append", "(", "h", ")", "\n", "break", "\n", "\n", "", "", "", "if", "len", "(", "related_header", ")", "==", "0", ":", "\n", "                    ", "pass", "\n", "", "elif", "len", "(", "related_header", ")", "==", "1", "and", "related_header", "[", "0", "]", "not", "in", "processed_q", ":", "\n", "                    ", "processed_q", "=", "processed_q", ".", "replace", "(", "\" \"", "+", "p", "[", "1", "]", "+", "\" \"", ",", "\" \"", "+", "related_header", "[", "0", "]", "+", "\" \"", "+", "p", "[", "1", "]", "+", "\" \"", ")", "\n", "", "else", ":", "\n", "                    ", "none_in_list", "=", "True", "\n", "for", "h", "in", "related_header", ":", "\n", "                        ", "if", "h", "in", "processed_q", ":", "\n", "                            ", "none_in_list", "=", "False", "\n", "", "", "if", "none_in_list", ":", "\n", "                        ", "pass", "\n", "\n", "# check if there is any missing constants", "\n", "", "", "", "miss_const", "=", "False", "\n", "missed_const", "=", "[", "]", "\n", "for", "p", "in", "all_consts", ":", "\n", "                ", "if", "p", "[", "1", "]", "not", "in", "processed_q", ".", "split", "(", ")", ":", "\n", "                    ", "miss_const", "=", "True", "\n", "missed_const", ".", "append", "(", "(", "p", "[", "0", "]", ",", "p", "[", "1", "]", ")", ")", "\n", "\n", "", "", "if", "miss_const", ":", "\n", "                ", "print", "(", "\"# [Warning] the following question will be discarded \"", "\n", "+", "\" due to not containing question contants.\"", ")", "\n", "print", "(", "sql_components", ")", "\n", "print", "(", "missed_const", ")", "\n", "print", "(", "annotated_q", ")", "\n", "print", "(", "processed_q", ")", "\n", "print", "(", "\"\"", ")", "\n", "# we are not adding them into the dataset", "\n", "\n", "if", "add_wrong_entry", ":", "\n", "# add a placeholder for wrong query", "\n", "                    ", "dataset", ".", "append", "(", "(", "table_id", "+", "\" \"", "+", "\" \"", ".", "join", "(", "orig_table", "[", "\"header\"", "]", ")", "+", "\" <ERR>\"", ",", "\n", "processed_q", ",", "\"<ERR>\"", ")", ")", "\n", "", "continue", "\n", "\n", "", "sql", "=", "\" \"", ".", "join", "(", "sql_components", ")", "\n", "\n", "dataset", ".", "append", "(", "(", "table_id", "+", "\" \"", "+", "\" \"", ".", "join", "(", "orig_table", "[", "\"header\"", "]", ")", ",", "processed_q", ",", "sql", ")", ")", "\n", "\n", "", "", "print", "(", "\"# dataset size: {}\"", ".", "format", "(", "len", "(", "dataset", ")", ")", ")", "\n", "return", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.normal_equal": [[182, 191], ["s1.replace().replace().replace", "s2.replace().replace().replace", "s1.replace().replace", "s2.replace().replace", "s1.replace", "s2.replace"], "function", ["None"], ["", "def", "normal_equal", "(", "tokens1", ",", "tokens2", ")", ":", "\n", "# equivalence between strings without considering", "\n", "    ", "s1", "=", "\"\"", ".", "join", "(", "tokens1", ")", ".", "replace", "(", "\"^\"", ",", "\"\"", ")", ".", "replace", "(", "\"\\xa0\"", ",", "\"\"", ")", "\n", "s2", "=", "\"\"", ".", "join", "(", "tokens2", ")", ".", "replace", "(", "\"^\"", ",", "\"\"", ")", ".", "replace", "(", "\"\\xa0\"", ",", "\"\"", ")", "\n", "\n", "ss1", "=", "s1", ".", "replace", "(", "\"\u2014\"", ",", "\"-\"", ")", ".", "replace", "(", "\"\u2013\"", ",", "\"-\"", ")", ".", "replace", "(", "\"--\"", ",", "\"-\"", ")", "\n", "ss2", "=", "s2", ".", "replace", "(", "\"\u2014\"", ",", "\"-\"", ")", ".", "replace", "(", "\"\u2013\"", ",", "\"-\"", ")", ".", "replace", "(", "\"--\"", ",", "\"-\"", ")", "\n", "\n", "return", "ss1", "==", "ss2", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.identify_phrases": [[192, 233], ["q.replace.lower().replace", "annotated_v.lower.lower", "q.replace.lower", "q.replace.split", "q.replace.replace", "q.replace.split", "annotated_v.lower.split", "orig_v.split", "q.replace.split", "range", "len", "range", "q.replace.replace", "len", "prepare_v2.overlap_score", "prepare_v2.is_permutation", "prepare_v2.normal_equal", "prepare_v2.normal_equal"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.overlap_score", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.is_permutation", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.normal_equal", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.normal_equal"], ["", "def", "identify_phrases", "(", "q", ",", "candidates", ",", "consider_permutation", "=", "True", ")", ":", "\n", "# processing question using candidates tokens", "\n", "    ", "q", "=", "q", ".", "lower", "(", ")", ".", "replace", "(", "\"\\xa0\"", ",", "\" \"", ")", "\n", "for", "annotated_v", ",", "orig_v", "in", "candidates", ":", "\n", "# just in case...", "\n", "        ", "annotated_v", "=", "annotated_v", ".", "lower", "(", ")", "\n", "\n", "if", "annotated_v", "in", "q", ".", "split", "(", ")", ":", "\n", "            ", "q", "=", "q", ".", "replace", "(", "annotated_v", ",", "orig_v", ")", "\n", "", "elif", "orig_v", "in", "q", ".", "split", "(", ")", ":", "\n", "            ", "continue", "\n", "", "else", ":", "\n", "            ", "v_list", "=", "annotated_v", ".", "split", "(", ")", "\n", "orig_v_list", "=", "orig_v", ".", "split", "(", "\"^\"", ")", "\n", "\n", "q_list", "=", "q", ".", "split", "(", ")", "\n", "\n", "best_match", "=", "None", "\n", "best_match_score", "=", "-", "1", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "q_list", ")", ")", ":", "\n", "                ", "for", "j", "in", "range", "(", "i", ",", "len", "(", "q_list", ")", ")", ":", "\n", "                    ", "score_ij", "=", "overlap_score", "(", "q_list", "[", "i", ":", "j", "+", "1", "]", ",", "v_list", ")", "\n", "\n", "if", "score_ij", ">", "best_match_score", ":", "\n", "                        ", "best_match", "=", "\" \"", ".", "join", "(", "q_list", "[", "i", ":", "j", "+", "1", "]", ")", "\n", "best_match_score", "=", "score_ij", "\n", "\n", "", "if", "(", "best_match_score", "<", "9999", "and", "(", "normal_equal", "(", "q_list", "[", "i", ":", "j", "+", "1", "]", ",", "v_list", ")", "\n", "or", "normal_equal", "(", "q_list", "[", "i", ":", "j", "+", "1", "]", ",", "orig_v_list", ")", ")", ")", ":", "\n", "                        ", "best_match", "=", "\" \"", ".", "join", "(", "q_list", "[", "i", ":", "j", "+", "1", "]", ")", "\n", "best_match_score", "=", "9999", "\n", "\n", "", "if", "(", "consider_permutation", "and", "best_match_score", "<=", "8888", "\n", "and", "is_permutation", "(", "q_list", "[", "i", ":", "j", "+", "1", "]", ",", "v_list", ")", ")", ":", "\n", "                        ", "best_match", "=", "\" \"", ".", "join", "(", "q_list", "[", "i", ":", "j", "+", "1", "]", ")", "\n", "max_score", "=", "8888", "\n", "\n", "", "", "", "if", "best_match_score", ">=", "0.5", ":", "\n", "                ", "q", "=", "q", ".", "replace", "(", "best_match", ",", "orig_v", ")", "\n", "", "", "", "return", "q", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.normalize_const_to_table_entry": [[235, 264], ["prepare_v2.is_number", "val.lower.lower", "val.lower.split", "range", "len", "range", "len", "str().lower", "str().lower", "str().lower.split", "str", "str"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.is_number"], ["", "def", "normalize_const_to_table_entry", "(", "val", ",", "orig_table", ",", "annotated_table", ")", ":", "\n", "# l_const is a constant represented in list form ", "\n", "# find a table entry to normalize the value val ", "\n", "# (orig_table is the original unprocessed table and annotated in the one after process)", "\n", "    ", "if", "is_number", "(", "val", ")", ":", "\n", "# no need to normalize", "\n", "        ", "return", "val", "\n", "\n", "", "val", "=", "val", ".", "lower", "(", ")", "\n", "val_split", "=", "val", ".", "split", "(", "\"^\"", ")", "\n", "best_match", "=", "None", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "orig_table", "[", "\"rows\"", "]", ")", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "len", "(", "orig_table", "[", "\"rows\"", "]", "[", "i", "]", ")", ")", ":", "\n", "\n", "            ", "orig_v", "=", "str", "(", "orig_table", "[", "\"rows\"", "]", "[", "i", "]", "[", "j", "]", ")", ".", "lower", "(", ")", "\n", "annotated_v", "=", "str", "(", "annotated_table", "[", "\"rows\"", "]", "[", "i", "]", "[", "j", "]", ")", ".", "lower", "(", ")", "\n", "\n", "v_split", "=", "annotated_v", ".", "split", "(", "\"^\"", ")", "\n", "\n", "if", "val", "==", "annotated_v", "or", "val", "==", "orig_v", ":", "\n", "                ", "return", "orig_v", "\n", "\n", "", "if", "\"\"", ".", "join", "(", "val_split", ")", "==", "\"\"", ".", "join", "(", "v_split", ")", ":", "\n", "# they match exactly but with wrong noise", "\n", "# we have not yet find the exact value", "\n", "                ", "best_match", "=", "orig_v", "\n", "\n", "", "", "", "return", "best_match", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.find_best_match": [[266, 275], ["prepare_v2.overlap_score", "prepare_v2.overlap_score", "v.split", "v.split"], "function", ["home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.overlap_score", "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.overlap_score"], ["", "def", "find_best_match", "(", "val", ",", "lst", ")", ":", "\n", "# find the best matching sequence of the token in lst for the string val", "\n", "    ", "best_score", "=", "0", "\n", "best_match", "=", "None", "\n", "for", "v", "in", "lst", ":", "\n", "        ", "if", "overlap_score", "(", "v", ".", "split", "(", ")", ",", "val", ")", ">", "best_score", ":", "\n", "            ", "best_score", "=", "overlap_score", "(", "v", ".", "split", "(", ")", ",", "val", ")", "\n", "best_match", "=", "v", "\n", "", "", "return", "best_match", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.is_permutation": [[277, 311], ["len", "len", "v.replace.replace"], "function", ["None"], ["", "def", "is_permutation", "(", "l1", ",", "l2", ",", "ignore", "=", "[", "\",\"", "]", ")", ":", "\n", "# check if l1 is a permutation of l2", "\n", "    ", "if", "l1", "[", "0", "]", "in", "ignore", "or", "l2", "[", "0", "]", "in", "ignore", ":", "\n", "        ", "return", "False", "\n", "\n", "", "l1_bag", "=", "{", "}", "\n", "for", "v", "in", "l1", ":", "\n", "        ", "if", "v", "in", "ignore", ":", "\n", "            ", "continue", "\n", "", "if", "not", "v", "in", "l1_bag", ":", "\n", "            ", "l1_bag", "[", "v", "]", "=", "0", "\n", "", "l1_bag", "[", "v", "]", "+=", "1", "\n", "", "l2_bag", "=", "{", "}", "\n", "\n", "for", "v", "in", "l2", ":", "\n", "        ", "if", "v", "in", "ignore", ":", "\n", "            ", "continue", "\n", "", "for", "i", "in", "ignore", ":", "\n", "            ", "if", "i", "in", "v", ":", "\n", "                ", "v", "=", "v", ".", "replace", "(", "\",\"", ",", "\"\"", ")", "\n", "", "", "if", "not", "v", "in", "l2_bag", ":", "\n", "            ", "l2_bag", "[", "v", "]", "=", "0", "\n", "", "l2_bag", "[", "v", "]", "+=", "1", "\n", "\n", "", "if", "len", "(", "l1_bag", ")", "!=", "len", "(", "l2_bag", ")", ":", "\n", "        ", "return", "False", "\n", "\n", "", "for", "v", "in", "l1_bag", ":", "\n", "        ", "if", "v", "not", "in", "l2_bag", ":", "\n", "            ", "return", "False", "\n", "", "if", "l2_bag", "[", "v", "]", "!=", "l1_bag", "[", "v", "]", ":", "\n", "            ", "return", "False", "\n", "\n", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.is_subseq": [[312, 322], ["functools.reduce", "functools.reduce", "range", "len", "x.split", "x.split", "len"], "function", ["None"], ["", "def", "is_subseq", "(", "l1", ",", "l2", ")", ":", "\n", "    ", "l1", "=", "reduce", "(", "(", "lambda", "x", ",", "y", ":", "x", "+", "y", ")", ",", "[", "x", ".", "split", "(", "\".\"", ")", "for", "x", "in", "l1", "]", ")", "\n", "l2", "=", "reduce", "(", "(", "lambda", "x", ",", "y", ":", "x", "+", "y", ")", ",", "[", "x", ".", "split", "(", "\".\"", ")", "for", "x", "in", "l2", "]", ")", "\n", "i", "=", "0", "\n", "for", "j", "in", "range", "(", "len", "(", "l2", ")", ")", ":", "\n", "        ", "if", "l2", "[", "j", "]", "==", "l1", "[", "i", "]", ":", "\n", "            ", "i", "+=", "1", "\n", "", "if", "i", ">=", "len", "(", "l1", ")", ":", "\n", "            ", "return", "True", "\n", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Microsoft_PointerSQL.scripts.prepare_v2.overlap_score": [[323, 331], ["functools.reduce", "functools.reduce", "float", "float", "x.split", "x.split", "len", "len"], "function", ["None"], ["", "def", "overlap_score", "(", "l1", ",", "l2", ")", ":", "\n", "    ", "overlap_cnt", "=", "0", "\n", "l1", "=", "reduce", "(", "(", "lambda", "x", ",", "y", ":", "x", "+", "y", ")", ",", "[", "x", ".", "split", "(", "\".\"", ")", "for", "x", "in", "l1", "]", ")", "\n", "l2", "=", "reduce", "(", "(", "lambda", "x", ",", "y", ":", "x", "+", "y", ")", ",", "[", "x", ".", "split", "(", "\".\"", ")", "for", "x", "in", "l2", "]", ")", "\n", "for", "t", "in", "l2", ":", "\n", "        ", "if", "t", "in", "l1", ":", "\n", "            ", "overlap_cnt", "+=", "1", "\n", "", "", "return", "float", "(", "overlap_cnt", ")", "/", "float", "(", "len", "(", "l1", ")", "+", "len", "(", "l2", ")", ")", "\n", "\n"]]}