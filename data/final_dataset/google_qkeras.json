{"home.repos.pwc.inspect_result.google_qkeras.experimental.network_bn.QDenseModel": [[58, 100], ["tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "tensorflow.keras.models.Model.summary", "tensorflow.keras.models.Model.compile", "qkeras.QActivation", "tensorflow.keras.layers.Conv2D", "tensorflow.keras.layers.BatchNormalization", "qkeras.QActivation", "tensorflow.keras.layers.Conv2D", "tensorflow.keras.layers.BatchNormalization", "qkeras.QActivation", "tensorflow.keras.layers.Conv2D", "tensorflow.keras.layers.BatchNormalization", "qkeras.QActivation", "tensorflow.keras.layers.Flatten", "qkeras.QDense", "tensorflow.keras.layers.Activation", "tensorflow.keras.models.Model.load_weights", "qkeras.quantized_bits", "qkeras.quantized_bits"], "function", ["None"], ["def", "QDenseModel", "(", "weights_f", ",", "load_weights", "=", "False", ")", ":", "\n", "  ", "\"\"\"Construct QDenseModel.\"\"\"", "\n", "\n", "x", "=", "x_in", "=", "Input", "(", "(", "28", ",", "28", ",", "1", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(2)\"", ",", "name", "=", "\"act_i\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "Conv2D", "(", "32", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "name", "=", "\"conv2d_0_m\"", ")", "(", "x", ")", "\n", "x", "=", "BatchNormalization", "(", "name", "=", "\"bn0\"", ")", "(", "x", ")", "\n", "#x = QConv2D(32, (3, 3), strides=(2, 2),", "\n", "#            kernel_quantizer=quantized_bits(4,0,1),", "\n", "#            bias_quantizer=quantized_bits(4,0,1),", "\n", "#            name=\"conv2d_0_m\")(x)", "\n", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(2)\"", ",", "name", "=", "\"act0_m\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "Conv2D", "(", "64", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "name", "=", "\"conv2d_1_m\"", ")", "(", "x", ")", "\n", "x", "=", "BatchNormalization", "(", "name", "=", "\"bn1\"", ")", "(", "x", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(2)\"", ",", "name", "=", "\"act1_m\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "Conv2D", "(", "64", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "name", "=", "\"conv2d_2_m\"", ")", "(", "x", ")", "\n", "x", "=", "BatchNormalization", "(", "name", "=", "\"bn2\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(2)\"", ",", "name", "=", "\"act2_m\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "Flatten", "(", "name", "=", "\"flatten\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "QDense", "(", "\n", "NB_CLASSES", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"dense2\"", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "\"softmax\"", ",", "name", "=", "\"softmax\"", ")", "(", "x", ")", "\n", "\n", "model", "=", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "model", ".", "summary", "(", ")", "\n", "model", ".", "compile", "(", "loss", "=", "\"categorical_crossentropy\"", ",", "\n", "optimizer", "=", "OPTIMIZER", ",", "metrics", "=", "[", "\"accuracy\"", "]", ")", "\n", "\n", "if", "load_weights", "and", "weights_f", ":", "\n", "    ", "model", ".", "load_weights", "(", "weights_f", ")", "\n", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.experimental.network_bn.UseNetwork": [[102, 148], ["network_bn.QDenseModel", "tensorflow.keras.datasets.mnist.load_data", "x_train_.astype.reshape", "x_test_.astype.reshape", "x_train_.astype.astype", "x_test_.astype.astype", "print", "print", "tensorflow.keras.utils.to_categorical", "tensorflow.keras.utils.to_categorical", "QDenseModel.evaluate", "print", "print", "QDenseModel.fit", "QDenseModel.save_weights"], "function", ["home.repos.pwc.inspect_result.google_qkeras.examples.example_qdense.QDenseModel", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit"], ["", "def", "UseNetwork", "(", "weights_f", ",", "load_weights", "=", "False", ")", ":", "\n", "  ", "\"\"\"Use DenseModel.\n\n  Args:\n    weights_f: weight file location.\n    load_weights: load weights when it is True.\n  \"\"\"", "\n", "model", "=", "QDenseModel", "(", "weights_f", ",", "load_weights", ")", "\n", "\n", "batch_size", "=", "BATCH_SIZE", "\n", "(", "x_train_", ",", "y_train_", ")", ",", "(", "x_test_", ",", "y_test_", ")", "=", "mnist", ".", "load_data", "(", ")", "\n", "\n", "x_train_", "=", "x_train_", ".", "reshape", "(", "60000", ",", "28", ",", "28", ",", "1", ")", "\n", "x_test_", "=", "x_test_", ".", "reshape", "(", "10000", ",", "28", ",", "28", ",", "1", ")", "\n", "x_train_", "=", "x_train_", ".", "astype", "(", "\"float32\"", ")", "\n", "x_test_", "=", "x_test_", ".", "astype", "(", "\"float32\"", ")", "\n", "\n", "x_train_", "/=", "256.", "\n", "x_test_", "/=", "256.", "\n", "\n", "# x_train_ = 2*x_train_ - 1.0", "\n", "# x_test_ = 2*x_test_ - 1.0", "\n", "\n", "print", "(", "x_train_", ".", "shape", "[", "0", "]", ",", "\"train samples\"", ")", "\n", "print", "(", "x_test_", ".", "shape", "[", "0", "]", ",", "\"test samples\"", ")", "\n", "\n", "y_train_", "=", "to_categorical", "(", "y_train_", ",", "NB_CLASSES", ")", "\n", "y_test_", "=", "to_categorical", "(", "y_test_", ",", "NB_CLASSES", ")", "\n", "\n", "if", "not", "load_weights", ":", "\n", "    ", "model", ".", "fit", "(", "\n", "x_train_", ",", "\n", "y_train_", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "epochs", "=", "NB_EPOCH", ",", "\n", "verbose", "=", "VERBOSE", ",", "\n", "validation_split", "=", "VALIDATION_SPLIT", ")", "\n", "\n", "if", "weights_f", ":", "\n", "      ", "model", ".", "save_weights", "(", "weights_f", ")", "\n", "\n", "", "", "score", "=", "model", ".", "evaluate", "(", "x_test_", ",", "y_test_", ",", "verbose", "=", "False", ")", "\n", "print", "(", "\"Test score:\"", ",", "score", "[", "0", "]", ")", "\n", "print", "(", "\"Test accuracy:\"", ",", "score", "[", "1", "]", ")", "\n", "\n", "return", "model", ",", "x_train_", ",", "x_test_", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.experimental.network_bn.ParserArgs": [[150, 183], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["", "def", "ParserArgs", "(", ")", ":", "\n", "  ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-o\"", ",", "\"--logic_optimize\"", ",", "default", "=", "False", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"optimize network.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-l\"", ",", "\"--load_weight\"", ",", "default", "=", "False", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"load weights directly from file.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-w\"", ",", "\"--weight_file\"", ",", "default", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "\"--output_group\"", ",", "type", "=", "int", ",", "default", "=", "1", ")", "\n", "parser", ".", "add_argument", "(", "\"--kernel\"", ",", "default", "=", "None", ",", "type", "=", "int", ",", "\n", "help", "=", "\"kernel if more complex layer\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--strides\"", ",", "default", "=", "None", ",", "type", "=", "int", ",", "\n", "help", "=", "\"stride if more complex layer\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--padding\"", ",", "default", "=", "None", ",", "\n", "help", "=", "\"padding if more complex layer\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--conv_sample\"", ",", "default", "=", "None", ",", "type", "=", "int", ",", "\n", "help", "=", "\"number of samples within image for conv layer\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--sample\"", ",", "default", "=", "None", ",", "\n", "help", "=", "\"number of training samples\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--use_pla\"", ",", "default", "=", "False", ",", "\n", "action", "=", "\"store_true\"", ",", "help", "=", "\"use pla table format\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--binary\"", ",", "default", "=", "False", ",", "\n", "action", "=", "\"store_true\"", ",", "help", "=", "\"use binary inputs\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--i_name\"", ",", "default", "=", "None", ",", "\n", "help", "=", "\"input layer name\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--o_name\"", ",", "default", "=", "None", ",", "\n", "help", "=", "\"output layer name\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--run_abc\"", ",", "default", "=", "False", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--run_rf\"", ",", "default", "=", "False", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--n_trees\"", ",", "default", "=", "3", ",", "type", "=", "int", ")", "\n", "a", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "a", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.experimental.network_c.QDenseModel": [[62, 104], ["tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "tensorflow.keras.models.Model.summary", "tensorflow.keras.models.Model.compile", "qkeras.QActivation", "tensorflow.keras.layers.Conv2D", "tensorflow.keras.layers.BatchNormalization", "qkeras.QActivation", "tensorflow.keras.layers.Conv2D", "tensorflow.keras.layers.BatchNormalization", "qkeras.QActivation", "tensorflow.keras.layers.Conv2D", "tensorflow.keras.layers.BatchNormalization", "qkeras.QActivation", "tensorflow.keras.layers.Flatten", "qkeras.QDense", "tensorflow.keras.layers.Activation", "tensorflow.keras.models.Model.load_weights", "qkeras.quantized_bits", "qkeras.quantized_bits"], "function", ["None"], ["def", "QDenseModel", "(", "weights_f", ",", "load_weights", "=", "False", ")", ":", "\n", "  ", "\"\"\"Construct QDenseModel.\"\"\"", "\n", "\n", "x", "=", "x_in", "=", "Input", "(", "(", "28", ",", "28", ",", "1", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(2)\"", ",", "name", "=", "\"act_i\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "Conv2D", "(", "32", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "name", "=", "\"conv2d_0_m\"", ")", "(", "x", ")", "\n", "x", "=", "BatchNormalization", "(", "name", "=", "\"bn0\"", ")", "(", "x", ")", "\n", "#x = QConv2D(32, (3, 3), strides=(2, 2),", "\n", "#            kernel_quantizer=quantized_bits(4,0,1),", "\n", "#            bias_quantizer=quantized_bits(4,0,1),", "\n", "#            name=\"conv2d_0_m\")(x)", "\n", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(2)\"", ",", "name", "=", "\"act0_m\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "Conv2D", "(", "64", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "name", "=", "\"conv2d_1_m\"", ")", "(", "x", ")", "\n", "x", "=", "BatchNormalization", "(", "name", "=", "\"bn1\"", ")", "(", "x", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(2)\"", ",", "name", "=", "\"act1_m\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "Conv2D", "(", "64", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "name", "=", "\"conv2d_2_m\"", ")", "(", "x", ")", "\n", "x", "=", "BatchNormalization", "(", "name", "=", "\"bn2\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(2)\"", ",", "name", "=", "\"act2_m\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "Flatten", "(", "name", "=", "\"flatten\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "QDense", "(", "\n", "NB_CLASSES", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"dense2\"", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "\"softmax\"", ",", "name", "=", "\"softmax\"", ")", "(", "x", ")", "\n", "\n", "model", "=", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "model", ".", "summary", "(", ")", "\n", "model", ".", "compile", "(", "loss", "=", "\"categorical_crossentropy\"", ",", "\n", "optimizer", "=", "OPTIMIZER", ",", "metrics", "=", "[", "\"accuracy\"", "]", ")", "\n", "\n", "if", "load_weights", "and", "weights_f", ":", "\n", "    ", "model", ".", "load_weights", "(", "weights_f", ")", "\n", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.experimental.network_c.UseNetwork": [[106, 152], ["network_c.QDenseModel", "tensorflow.keras.datasets.mnist.load_data", "x_train_.astype.reshape", "x_test_.astype.reshape", "x_train_.astype.astype", "x_test_.astype.astype", "print", "print", "tensorflow.keras.utils.to_categorical", "tensorflow.keras.utils.to_categorical", "QDenseModel.evaluate", "print", "print", "QDenseModel.fit", "QDenseModel.save_weights"], "function", ["home.repos.pwc.inspect_result.google_qkeras.examples.example_qdense.QDenseModel", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit"], ["", "def", "UseNetwork", "(", "weights_f", ",", "load_weights", "=", "False", ")", ":", "\n", "  ", "\"\"\"Use DenseModel.\n\n  Args:\n    weights_f: weight file location.\n    load_weights: load weights when it is True.\n  \"\"\"", "\n", "model", "=", "QDenseModel", "(", "weights_f", ",", "load_weights", ")", "\n", "\n", "batch_size", "=", "BATCH_SIZE", "\n", "(", "x_train_", ",", "y_train_", ")", ",", "(", "x_test_", ",", "y_test_", ")", "=", "mnist", ".", "load_data", "(", ")", "\n", "\n", "x_train_", "=", "x_train_", ".", "reshape", "(", "60000", ",", "28", ",", "28", ",", "1", ")", "\n", "x_test_", "=", "x_test_", ".", "reshape", "(", "10000", ",", "28", ",", "28", ",", "1", ")", "\n", "x_train_", "=", "x_train_", ".", "astype", "(", "\"float32\"", ")", "\n", "x_test_", "=", "x_test_", ".", "astype", "(", "\"float32\"", ")", "\n", "\n", "x_train_", "/=", "256.", "\n", "x_test_", "/=", "256.", "\n", "\n", "# x_train_ = 2*x_train_ - 1.0", "\n", "# x_test_ = 2*x_test_ - 1.0", "\n", "\n", "print", "(", "x_train_", ".", "shape", "[", "0", "]", ",", "\"train samples\"", ")", "\n", "print", "(", "x_test_", ".", "shape", "[", "0", "]", ",", "\"test samples\"", ")", "\n", "\n", "y_train_", "=", "to_categorical", "(", "y_train_", ",", "NB_CLASSES", ")", "\n", "y_test_", "=", "to_categorical", "(", "y_test_", ",", "NB_CLASSES", ")", "\n", "\n", "if", "not", "load_weights", ":", "\n", "    ", "model", ".", "fit", "(", "\n", "x_train_", ",", "\n", "y_train_", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "epochs", "=", "NB_EPOCH", ",", "\n", "verbose", "=", "VERBOSE", ",", "\n", "validation_split", "=", "VALIDATION_SPLIT", ")", "\n", "\n", "if", "weights_f", ":", "\n", "      ", "model", ".", "save_weights", "(", "weights_f", ")", "\n", "\n", "", "", "score", "=", "model", ".", "evaluate", "(", "x_test_", ",", "y_test_", ",", "verbose", "=", "False", ")", "\n", "print", "(", "\"Test score:\"", ",", "score", "[", "0", "]", ")", "\n", "print", "(", "\"Test accuracy:\"", ",", "score", "[", "1", "]", ")", "\n", "\n", "return", "model", ",", "x_train_", ",", "x_test_", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.experimental.cmnist.QConv2DModel": [[60, 96], ["tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "tensorflow.keras.models.Model.summary", "tensorflow.keras.models.Model.compile", "qkeras.QActivation", "tensorflow.keras.layers.Conv2D", "tensorflow.keras.layers.BatchNormalization", "qkeras.QActivation", "tensorflow.keras.layers.Conv2D", "tensorflow.keras.layers.BatchNormalization", "qkeras.QActivation", "tensorflow.keras.layers.Conv2D", "tensorflow.keras.layers.BatchNormalization", "qkeras.QActivation", "tensorflow.keras.layers.Flatten", "qkeras.QDense", "tensorflow.keras.layers.Activation", "tensorflow.keras.models.Model.load_weights", "qkeras.quantized_bits", "qkeras.quantized_bits"], "function", ["None"], ["def", "QConv2DModel", "(", "weights_f", ",", "load_weights", "=", "False", ")", ":", "\n", "  ", "\"\"\"Construct QConv2DModel.\"\"\"", "\n", "\n", "x", "=", "x_in", "=", "Input", "(", "(", "28", ",", "28", ",", "1", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(2)\"", ",", "name", "=", "\"act_i\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "Conv2D", "(", "32", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "name", "=", "\"conv2d_0_m\"", ")", "(", "x", ")", "\n", "x", "=", "BatchNormalization", "(", "name", "=", "\"bn0\"", ")", "(", "x", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(2)\"", ",", "name", "=", "\"act0_m\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "Conv2D", "(", "64", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "name", "=", "\"conv2d_1_m\"", ")", "(", "x", ")", "\n", "x", "=", "BatchNormalization", "(", "name", "=", "\"bn1\"", ")", "(", "x", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(2)\"", ",", "name", "=", "\"act1_m\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "Conv2D", "(", "64", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "name", "=", "\"conv2d_2_m\"", ")", "(", "x", ")", "\n", "x", "=", "BatchNormalization", "(", "name", "=", "\"bn2\"", ")", "(", "x", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(2)\"", ",", "name", "=", "\"act2_m\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "Flatten", "(", "name", "=", "\"flatten\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "QDense", "(", "\n", "NB_CLASSES", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"dense2\"", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "\"softmax\"", ",", "name", "=", "\"softmax\"", ")", "(", "x", ")", "\n", "\n", "model", "=", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "model", ".", "summary", "(", ")", "\n", "model", ".", "compile", "(", "loss", "=", "\"categorical_crossentropy\"", ",", "\n", "optimizer", "=", "OPTIMIZER", ",", "metrics", "=", "[", "\"accuracy\"", "]", ")", "\n", "\n", "if", "load_weights", "and", "weights_f", ":", "\n", "    ", "model", ".", "load_weights", "(", "weights_f", ")", "\n", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.experimental.cmnist.UseNetwork": [[98, 141], ["cmnist.QConv2DModel", "tensorflow.keras.datasets.mnist.load_data", "x_train.astype.reshape", "x_test.astype.reshape", "x_train.astype.astype", "x_test.astype.astype", "print", "print", "tensorflow.keras.utils.to_categorical", "tensorflow.keras.utils.to_categorical", "QConv2DModel.evaluate", "print", "print", "QConv2DModel.fit", "QConv2DModel.save_weights"], "function", ["home.repos.pwc.inspect_result.google_qkeras.experimental.cmnist.QConv2DModel", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit"], ["", "def", "UseNetwork", "(", "weights_f", ",", "load_weights", "=", "False", ")", ":", "\n", "  ", "\"\"\"Use DenseModel.\n\n  Args:\n    weights_f: weight file location.\n    load_weights: load weights when it is True.\n  \"\"\"", "\n", "model", "=", "QConv2DModel", "(", "weights_f", ",", "load_weights", ")", "\n", "\n", "batch_size", "=", "BATCH_SIZE", "\n", "(", "x_train", ",", "y_train", ")", ",", "(", "x_test", ",", "y_test", ")", "=", "mnist", ".", "load_data", "(", ")", "\n", "\n", "x_train", "=", "x_train", ".", "reshape", "(", "60000", ",", "28", ",", "28", ",", "1", ")", "\n", "x_test", "=", "x_test", ".", "reshape", "(", "10000", ",", "28", ",", "28", ",", "1", ")", "\n", "x_train", "=", "x_train", ".", "astype", "(", "\"float32\"", ")", "\n", "x_test", "=", "x_test", ".", "astype", "(", "\"float32\"", ")", "\n", "\n", "x_train", "/=", "256.", "\n", "x_test", "/=", "256.", "\n", "\n", "print", "(", "x_train", ".", "shape", "[", "0", "]", ",", "\"train samples\"", ")", "\n", "print", "(", "x_test", ".", "shape", "[", "0", "]", ",", "\"test samples\"", ")", "\n", "\n", "y_train", "=", "to_categorical", "(", "y_train", ",", "NB_CLASSES", ")", "\n", "y_test", "=", "to_categorical", "(", "y_test", ",", "NB_CLASSES", ")", "\n", "\n", "if", "not", "load_weights", ":", "\n", "    ", "model", ".", "fit", "(", "\n", "x_train", ",", "\n", "y_train", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "epochs", "=", "NB_EPOCH", ",", "\n", "verbose", "=", "VERBOSE", ",", "\n", "validation_split", "=", "VALIDATION_SPLIT", ")", "\n", "\n", "if", "weights_f", ":", "\n", "      ", "model", ".", "save_weights", "(", "weights_f", ")", "\n", "\n", "", "", "score", "=", "model", ".", "evaluate", "(", "x_test", ",", "y_test", ",", "verbose", "=", "False", ")", "\n", "print", "(", "\"Test score:\"", ",", "score", "[", "0", "]", ")", "\n", "print", "(", "\"Test accuracy:\"", ",", "score", "[", "1", "]", ")", "\n", "\n", "return", "model", ",", "x_train", ",", "x_test", "\n", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.experimental.network.QDenseModel": [[60, 89], ["tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "tensorflow.keras.models.Model.summary", "tensorflow.keras.models.Model.compile", "qkeras.QActivation", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.BatchNormalization", "qkeras.QActivation", "tensorflow.keras.layers.Flatten", "qkeras.QDense", "tensorflow.keras.layers.Activation", "tensorflow.keras.models.Model.load_weights", "qkeras.quantized_bits", "qkeras.quantized_bits"], "function", ["None"], ["def", "QDenseModel", "(", "weights_f", ",", "load_weights", "=", "False", ")", ":", "\n", "  ", "\"\"\"Construct QDenseModel.\"\"\"", "\n", "\n", "x", "=", "x_in", "=", "Input", "(", "(", "28", "*", "28", ",", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(2)\"", ",", "name", "=", "\"act_i\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "Dense", "(", "100", ",", "name", "=", "\"d0\"", ")", "(", "x", ")", "\n", "x", "=", "BatchNormalization", "(", "name", "=", "\"bn0\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(2)\"", ",", "name", "=", "\"act0_m\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "Flatten", "(", "name", "=", "\"flatten\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "QDense", "(", "\n", "NB_CLASSES", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"dense2\"", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "\"softmax\"", ",", "name", "=", "\"softmax\"", ")", "(", "x", ")", "\n", "\n", "model", "=", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "model", ".", "summary", "(", ")", "\n", "model", ".", "compile", "(", "loss", "=", "\"categorical_crossentropy\"", ",", "\n", "optimizer", "=", "OPTIMIZER", ",", "metrics", "=", "[", "\"accuracy\"", "]", ")", "\n", "\n", "if", "load_weights", "and", "weights_f", ":", "\n", "    ", "model", ".", "load_weights", "(", "weights_f", ")", "\n", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.experimental.network.UseNetwork": [[91, 137], ["network.QDenseModel", "tensorflow.keras.datasets.mnist.load_data", "x_train_.astype.reshape", "x_test_.astype.reshape", "x_train_.astype.astype", "x_test_.astype.astype", "print", "print", "tensorflow.keras.utils.to_categorical", "tensorflow.keras.utils.to_categorical", "QDenseModel.evaluate", "print", "print", "QDenseModel.fit", "QDenseModel.save_weights"], "function", ["home.repos.pwc.inspect_result.google_qkeras.examples.example_qdense.QDenseModel", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit"], ["", "def", "UseNetwork", "(", "weights_f", ",", "load_weights", "=", "False", ")", ":", "\n", "  ", "\"\"\"Use DenseModel.\n\n  Args:\n    weights_f: weight file location.\n    load_weights: load weights when it is True.\n  \"\"\"", "\n", "model", "=", "QDenseModel", "(", "weights_f", ",", "load_weights", ")", "\n", "\n", "batch_size", "=", "BATCH_SIZE", "\n", "(", "x_train_", ",", "y_train_", ")", ",", "(", "x_test_", ",", "y_test_", ")", "=", "mnist", ".", "load_data", "(", ")", "\n", "\n", "x_train_", "=", "x_train_", ".", "reshape", "(", "60000", ",", "28", "*", "28", ")", "\n", "x_test_", "=", "x_test_", ".", "reshape", "(", "10000", ",", "28", "*", "28", ")", "\n", "x_train_", "=", "x_train_", ".", "astype", "(", "\"float32\"", ")", "\n", "x_test_", "=", "x_test_", ".", "astype", "(", "\"float32\"", ")", "\n", "\n", "x_train_", "/=", "256.", "\n", "x_test_", "/=", "256.", "\n", "\n", "# x_train_ = 2*x_train_ - 1.0", "\n", "# x_test_ = 2*x_test_ - 1.0", "\n", "\n", "print", "(", "x_train_", ".", "shape", "[", "0", "]", ",", "\"train samples\"", ")", "\n", "print", "(", "x_test_", ".", "shape", "[", "0", "]", ",", "\"test samples\"", ")", "\n", "\n", "y_train_", "=", "to_categorical", "(", "y_train_", ",", "NB_CLASSES", ")", "\n", "y_test_", "=", "to_categorical", "(", "y_test_", ",", "NB_CLASSES", ")", "\n", "\n", "if", "not", "load_weights", ":", "\n", "    ", "model", ".", "fit", "(", "\n", "x_train_", ",", "\n", "y_train_", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "epochs", "=", "NB_EPOCH", ",", "\n", "verbose", "=", "VERBOSE", ",", "\n", "validation_split", "=", "VALIDATION_SPLIT", ")", "\n", "\n", "if", "weights_f", ":", "\n", "      ", "model", ".", "save_weights", "(", "weights_f", ")", "\n", "\n", "", "", "score", "=", "model", ".", "evaluate", "(", "x_test_", ",", "y_test_", ",", "verbose", "=", "False", ")", "\n", "print", "(", "\"Test score:\"", ",", "score", "[", "0", "]", ")", "\n", "print", "(", "\"Test accuracy:\"", ",", "score", "[", "1", "]", ")", "\n", "\n", "return", "model", ",", "x_train_", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.experimental.run.GetQuantizedType": [[37, 42], ["mode.split", "int"], "function", ["None"], ["def", "GetQuantizedType", "(", "mode", ")", ":", "\n", "  ", "values", "=", "mode", ".", "split", "(", "\",\"", ")", "\n", "values", "=", "[", "int", "(", "v", ")", "for", "v", "in", "values", "]", "\n", "\n", "return", "values", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.experimental.rf2hw.error": [[46, 48], ["print", "numpy.sum().astype", "numpy.sum"], "function", ["None"], ["def", "error", "(", "y", ",", "p", ")", ":", "\n", "  ", "print", "(", "\"acc: \"", ",", "100", "*", "np", ".", "sum", "(", "y", "==", "p", ")", ".", "astype", "(", "np", ".", "float32", ")", "/", "y", ".", "shape", "[", "0", "]", ")", "\n", "#print(\"acc: \", 100*(np.sum(np.abs(y-p)).astype(np.float32)/y.shape[0]))", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.experimental.rf2hw.ParseArguments": [[51, 81], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["", "def", "ParseArguments", "(", ")", ":", "\n", "  ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"--train\"", ",", "default", "=", "False", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"train network\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--synthesize\"", ",", "default", "=", "False", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"synthesize random tree\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--with_tb\"", ",", "default", "=", "False", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"with testbench\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--use_classifier\"", ",", "default", "=", "False", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"use classifier instead of regressor\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--max_depth\"", ",", "default", "=", "None", ",", "\n", "help", "=", "\"maximum depth of tree\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--max_bits\"", ",", "default", "=", "1", ",", "type", "=", "int", ",", "\n", "help", "=", "\"maximum number of bits\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--n_features\"", ",", "default", "=", "None", ",", "\n", "help", "=", "\"number of features to use per random tree\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--n_trees\"", ",", "default", "=", "1", ",", "type", "=", "int", ",", "\n", "help", "=", "\"number of random trees\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--sample_size\"", ",", "default", "=", "None", ",", "\n", "help", "=", "\"sample size of table for random tree\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--rf_bin\"", ",", "default", "=", "\"rb.bin\"", ",", "\n", "help", "=", "\"name of random forest binary file\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--cc\"", ",", "default", "=", "False", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"table\"", ",", "help", "=", "\"table file in pla or csv format\"", ")", "\n", "a", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "a", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.experimental.args.ParserArgs": [[24, 98], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "ParserArgs", "(", ")", ":", "\n", "  ", "\"\"\"Args Parser.\"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"--debug\"", ",", "default", "=", "False", ",", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"set debug mode\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--print_debug\"", ",", "default", "=", "False", ",", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"print debug information\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--model\"", ",", "default", "=", "\"\"", ",", "\n", "help", "=", "\"which model to run (dmnist, cmnist)\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"-o\"", ",", "\"--logic_optimize\"", ",", "default", "=", "False", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"optimize network.\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"-l\"", ",", "\"--load_weight\"", ",", "default", "=", "False", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"load weights directly from file.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-w\"", ",", "\"--weight_file\"", ",", "default", "=", "None", ",", "\n", "help", "=", "\"name of weights file\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--output_group\"", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "\"number of outputs to group together\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--kernel\"", ",", "default", "=", "None", ",", "type", "=", "int", ",", "\n", "help", "=", "\"kernel if more complex layer\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--strides\"", ",", "default", "=", "None", ",", "type", "=", "int", ",", "\n", "help", "=", "\"stride if more complex layer\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--padding\"", ",", "default", "=", "None", ",", "\n", "help", "=", "\"padding if more complex layer\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--conv_sample\"", ",", "default", "=", "None", ",", "type", "=", "int", ",", "\n", "help", "=", "\"number of samples within image for conv layer\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--sample\"", ",", "default", "=", "None", ",", "\n", "help", "=", "\"number of training samples\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--use_pla\"", ",", "default", "=", "False", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"use pla table format\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--binary\"", ",", "default", "=", "False", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"use binary inputs\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--i_name\"", ",", "default", "=", "None", ",", "\n", "help", "=", "\"input layer name\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--o_name\"", ",", "default", "=", "None", ",", "\n", "help", "=", "\"output layer name\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--qi\"", ",", "default", "=", "\"2,0,0\"", ",", "\n", "help", "=", "\"quantized input type\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--qo\"", ",", "default", "=", "\"2,0,0\"", ",", "\n", "help", "=", "\"quantized output type\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--run_abc\"", ",", "default", "=", "False", ",", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"use abc to optimize logic\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--espresso_flags\"", ",", "default", "=", "\"-Dexpand\"", ",", "\n", "help", "=", "\"flags to be passed to espresso\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--abc_flags\"", ",", "default", "=", "\"\"", ",", "\n", "help", "=", "\"flags to be passed to abc\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--run_rf\"", ",", "default", "=", "False", ",", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"use ranform forest to optimize logic\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--n_trees\"", ",", "default", "=", "3", ",", "type", "=", "int", ",", "\n", "help", "=", "\"number of trees to optimize\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--max_bits\"", ",", "default", "=", "1", ",", "type", "=", "int", ",", "\n", "help", "=", "\"maximum number of bits for random forest\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--is_regressor\"", ",", "default", "=", "False", ",", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"use regressor instead of classifier\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--n_features\"", ",", "default", "=", "None", ",", "\n", "help", "=", "\"number of features for random forest\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--max_depth\"", ",", "default", "=", "None", ",", "\n", "help", "=", "\"maximum depth of random tree\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--sample_size\"", ",", "default", "=", "None", ",", "\n", "help", "=", "\"sample size of table for random tree\"", ")", "\n", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.experimental.dmnist.QDenseModel": [[62, 96], ["tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "tensorflow.keras.models.Model.summary", "tensorflow.keras.models.Model.compile", "qkeras.QActivation", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.BatchNormalization", "qkeras.QActivation", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.BatchNormalization", "qkeras.QActivation", "tensorflow.keras.layers.Flatten", "qkeras.QDense", "tensorflow.keras.layers.Activation", "tensorflow.keras.models.Model.load_weights", "qkeras.quantized_bits", "qkeras.quantized_bits"], "function", ["None"], ["def", "QDenseModel", "(", "weights_f", ",", "load_weights", "=", "False", ")", ":", "\n", "  ", "\"\"\"Construct QDenseModel.\"\"\"", "\n", "\n", "x", "=", "x_in", "=", "Input", "(", "(", "28", "*", "28", ",", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(2)\"", ",", "name", "=", "\"act_i\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "Dense", "(", "300", ",", "name", "=", "\"d0\"", ")", "(", "x", ")", "\n", "x", "=", "BatchNormalization", "(", "name", "=", "\"bn0\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(2)\"", ",", "name", "=", "\"act0_m\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "Dense", "(", "100", ",", "name", "=", "\"d1\"", ")", "(", "x", ")", "\n", "x", "=", "BatchNormalization", "(", "name", "=", "\"bn0\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(2)\"", ",", "name", "=", "\"act0_m\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "Flatten", "(", "name", "=", "\"flatten\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "QDense", "(", "\n", "NB_CLASSES", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"dense2\"", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "\"softmax\"", ",", "name", "=", "\"softmax\"", ")", "(", "x", ")", "\n", "\n", "model", "=", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "model", ".", "summary", "(", ")", "\n", "model", ".", "compile", "(", "loss", "=", "\"categorical_crossentropy\"", ",", "\n", "optimizer", "=", "OPTIMIZER", ",", "metrics", "=", "[", "\"accuracy\"", "]", ")", "\n", "\n", "if", "load_weights", "and", "weights_f", ":", "\n", "    ", "model", ".", "load_weights", "(", "weights_f", ")", "\n", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.experimental.dmnist.UseNetwork": [[98, 141], ["dmnist.QDenseModel", "tensorflow.keras.datasets.mnist.load_data", "x_train.astype.reshape", "x_test.astype.reshape", "x_train.astype.astype", "x_test.astype.astype", "print", "print", "tensorflow.keras.utils.to_categorical", "tensorflow.keras.utils.to_categorical", "QDenseModel.evaluate", "print", "print", "QDenseModel.fit", "QDenseModel.save_weights"], "function", ["home.repos.pwc.inspect_result.google_qkeras.examples.example_qdense.QDenseModel", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit"], ["", "def", "UseNetwork", "(", "weights_f", ",", "load_weights", "=", "False", ")", ":", "\n", "  ", "\"\"\"Use DenseModel.\n\n  Args:\n    weights_f: weight file location.\n    load_weights: load weights when it is True.\n  \"\"\"", "\n", "model", "=", "QDenseModel", "(", "weights_f", ",", "load_weights", ")", "\n", "\n", "batch_size", "=", "BATCH_SIZE", "\n", "(", "x_train", ",", "y_train", ")", ",", "(", "x_test", ",", "y_test", ")", "=", "mnist", ".", "load_data", "(", ")", "\n", "\n", "x_train", "=", "x_train", ".", "reshape", "(", "60000", ",", "28", "*", "28", ")", "\n", "x_test", "=", "x_test", ".", "reshape", "(", "10000", ",", "28", "*", "28", ")", "\n", "x_train", "=", "x_train", ".", "astype", "(", "\"float32\"", ")", "\n", "x_test", "=", "x_test", ".", "astype", "(", "\"float32\"", ")", "\n", "\n", "x_train", "/=", "256.", "\n", "x_test", "/=", "256.", "\n", "\n", "print", "(", "x_train", ".", "shape", "[", "0", "]", ",", "\"train samples\"", ")", "\n", "print", "(", "x_test", ".", "shape", "[", "0", "]", ",", "\"test samples\"", ")", "\n", "\n", "y_train", "=", "to_categorical", "(", "y_train_", ",", "NB_CLASSES", ")", "\n", "y_test", "=", "to_categorical", "(", "y_test_", ",", "NB_CLASSES", ")", "\n", "\n", "if", "not", "load_weights", ":", "\n", "    ", "model", ".", "fit", "(", "\n", "x_train", ",", "\n", "y_train", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "epochs", "=", "NB_EPOCH", ",", "\n", "verbose", "=", "VERBOSE", ",", "\n", "validation_split", "=", "VALIDATION_SPLIT", ")", "\n", "\n", "if", "weights_f", ":", "\n", "      ", "model", ".", "save_weights", "(", "weights_f", ")", "\n", "\n", "", "", "score", "=", "model", ".", "evaluate", "(", "x_test", ",", "y_test", ",", "verbose", "=", "False", ")", "\n", "print", "(", "\"Test score:\"", ",", "score", "[", "0", "]", ")", "\n", "print", "(", "\"Test accuracy:\"", ",", "score", "[", "1", "]", ")", "\n", "\n", "return", "model", ",", "x_train", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.compress.Compressor.__init__": [[26, 29], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "hash_only_input", "=", "False", ")", ":", "\n", "    ", "self", ".", "n_dict", "=", "{", "}", "\n", "self", ".", "hash_only_input", "=", "hash_only_input", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.compress.Compressor.add_entry": [[30, 43], ["compress.Compressor.n_dict.get", "hash", "hash", "compress.Compressor.n_dict[].union", "set"], "methods", ["None"], ["", "def", "add_entry", "(", "self", ",", "table_in", ",", "table_out", "=", "\"\"", ")", ":", "\n", "    ", "\"\"\"Adds entry (table_in, table_out) to the set.\"\"\"", "\n", "line", "=", "(", "table_in", ",", "table_out", ")", "\n", "\n", "if", "self", ".", "hash_only_input", ":", "\n", "      ", "h_line", "=", "hash", "(", "table_in", ")", "\n", "", "else", ":", "\n", "      ", "h_line", "=", "hash", "(", "line", ")", "\n", "\n", "", "if", "self", ".", "n_dict", ".", "get", "(", "h_line", ",", "None", ")", ":", "\n", "      ", "self", ".", "n_dict", "[", "h_line", "]", "=", "self", ".", "n_dict", "[", "h_line", "]", ".", "union", "(", "[", "line", "]", ")", "\n", "", "else", ":", "\n", "      ", "self", ".", "n_dict", "[", "h_line", "]", "=", "set", "(", "[", "line", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.compress.Compressor.has_entry": [[44, 64], ["hash", "hash", "compress.Compressor.n_dict.get"], "methods", ["None"], ["", "", "def", "has_entry", "(", "self", ",", "table_in", ",", "table_out", "=", "\"\"", ")", ":", "\n", "    ", "\"\"\"Checks if table_in is already stored in the set.\"\"\"", "\n", "\n", "line", "=", "(", "table_in", ",", "table_out", ")", "\n", "\n", "if", "self", ".", "hash_only_input", ":", "\n", "      ", "h_line", "=", "hash", "(", "table_in", ")", "\n", "", "else", ":", "\n", "      ", "h_line", "=", "hash", "(", "line", ")", "\n", "\n", "", "if", "not", "self", ".", "n_dict", ".", "get", "(", "h_line", ",", "None", ")", ":", "\n", "      ", "return", "None", "\n", "\n", "", "set_h_line", "=", "self", ".", "n_dict", "[", "h_line", "]", "\n", "\n", "for", "(", "ti", ",", "to", ")", "in", "set_h_line", ":", "\n", "      ", "if", "table_in", "==", "ti", ":", "\n", "        ", "return", "to", "\n", "\n", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.compress.Compressor.__call__": [[65, 69], ["None"], "methods", ["None"], ["", "def", "__call__", "(", "self", ")", ":", "\n", "    ", "for", "key", "in", "self", ".", "n_dict", ":", "\n", "      ", "for", "line", "in", "self", ".", "n_dict", "[", "key", "]", ":", "\n", "        ", "yield", "line", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.dense.parallel_index_table": [[37, 110], ["print", "compress.Compressor", "range", "print", "[].flatten", "[].flatten", "table_ins.append", "table_ous.append", "compress.Compressor.add_entry", "compress.Compressor.has_entry", "len", "str", "str", "str", "print", "print", "print", "print", "print"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.lo.compress.Compressor.add_entry", "home.repos.pwc.inspect_result.google_qkeras.lo.compress.Compressor.has_entry"], ["def", "parallel_index_table", "(", "\n", "p", ",", "ni", ",", "size", ",", "i_dict", ",", "o_dict", ",", "generate_pla", ")", ":", "\n", "  ", "\"\"\"Processes the table in parallel and use espresso to optimize it.\"\"\"", "\n", "\n", "print", "(", "\"... indexing table from {} to {} ({} => {})\"", ".", "format", "(", "\n", "ni", ",", "ni", "+", "size", ",", "p", "[", "0", "]", ".", "shape", ",", "p", "[", "1", "]", ".", "shape", ")", ")", "\n", "\n", "table_ins", "=", "[", "]", "\n", "table_ous", "=", "[", "]", "\n", "\n", "table_set", "=", "Compressor", "(", "hash_only_input", "=", "True", ")", "\n", "\n", "if", "DEBUG", ":", "\n", "    ", "table_set_line", "=", "{", "}", "\n", "\n", "", "for", "n", "in", "range", "(", "size", ")", ":", "\n", "\n", "    ", "i_values", "=", "p", "[", "0", "]", "[", "n", "]", ".", "flatten", "(", ")", "\n", "o_values", "=", "p", "[", "1", "]", "[", "n", "]", ".", "flatten", "(", ")", "\n", "\n", "# if we generate a pla entry, we care about a list of", "\n", "# bits. Otherwise, we care about a list of floating point", "\n", "# values.", "\n", "\n", "table_i", "=", "\"\"", ".", "join", "(", "[", "i_dict", "[", "v", "]", "for", "v", "in", "i_values", "]", ")", "\n", "table_o", "=", "\"\"", ".", "join", "(", "[", "o_dict", "[", "v", "]", "for", "v", "in", "o_values", "]", ")", "\n", "\n", "if", "generate_pla", ":", "\n", "      ", "table_s", "=", "\"\"", ".", "join", "(", "[", "str", "(", "v", ")", "for", "v", "in", "table_i", "]", ")", "\n", "bit_str", "=", "table_s", "\n", "", "else", ":", "\n", "      ", "table_s", "=", "\",\"", ".", "join", "(", "[", "str", "(", "v", ")", "for", "v", "in", "table_i", "]", ")", "\n", "table_i", "=", "table_s", "\n", "bit_str", "=", "\"\"", ".", "join", "(", "str", "(", "i_dict", "[", "v", "]", ")", "for", "v", "in", "i_values", ")", "\n", "", "is_table_zero", "=", "bit_str", "!=", "\"0\"", "*", "len", "(", "bit_str", ")", "\n", "\n", "if", "table_set", ".", "has_entry", "(", "table_s", ")", "and", "not", "is_table_zero", ":", "\n", "\n", "# if table is already stored, we do not store it again.", "\n", "# from time to time, we may want to check if we have found", "\n", "# diverging output values.", "\n", "\n", "      ", "if", "DEBUG", ":", "\n", "\n", "        ", "(", "table_o_old", ",", "old_n", ")", "=", "table_set_line", "[", "table_s", "]", "\n", "\n", "if", "table_o", "!=", "table_o_old", ":", "\n", "          ", "print", "(", "\"contradicting outputs n={} old_n={} out_p={} out={}\"", ".", "format", "(", "\n", "n", ",", "old_n", ",", "table_o_old", ",", "table_o", ")", ")", "\n", "print", "(", "\" I:\"", ",", "table_s", ")", "\n", "print", "(", "\" I:\"", ",", "i_values", ")", "\n", "print", "(", "\"<<<\"", ",", "table_o_old", ")", "\n", "print", "(", "\">>>\"", ",", "table_o", ")", "\n", "return", "(", "None", ",", "None", ")", "\n", "\n", "", "", "continue", "\n", "\n", "# these are unique table entries", "\n", "\n", "", "table_ins", ".", "append", "(", "table_i", ")", "\n", "table_ous", ".", "append", "(", "table_o", ")", "\n", "\n", "# we store this information in order to be able to debug", "\n", "# and discard information.", "\n", "\n", "table_set", ".", "add_entry", "(", "table_s", ")", "\n", "\n", "if", "DEBUG", ":", "\n", "      ", "table_set_line", "[", "table_s", "]", "=", "(", "table_o", ",", "n", ")", "\n", "\n", "", "", "print", "(", "\"... indexing table from {} to {} completed\"", ".", "format", "(", "ni", ",", "ni", "+", "size", ")", ")", "\n", "\n", "return", "(", "table_ins", ",", "table_ous", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.dense.parallel_compress_output_table": [[112, 154], ["open", "open.write", "compress.Compressor", "range", "compress.Compressor.", "open.close", "len", "range", "open.write", "open.write", "compress.Compressor.add_entry", "compress.Compressor.add_entry", "str", "str", "bin", "len"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.lo.compress.Compressor.add_entry", "home.repos.pwc.inspect_result.google_qkeras.lo.compress.Compressor.add_entry"], ["", "def", "parallel_compress_output_table", "(", "\n", "filename", ",", "header", ",", "table_ins", ",", "table_ous", ",", "output_group", ",", "generate_pla", ",", "\n", "n_bits_og", ",", "o", ",", "o_bits", ")", ":", "\n", "  ", "\"\"\"Processes in parallel compression of table and writes it to a disk.\"\"\"", "\n", "\n", "f", "=", "open", "(", "filename", ",", "\"w\"", ")", "\n", "\n", "f", ".", "write", "(", "\"\"", ".", "join", "(", "header", ")", ")", "\n", "\n", "c", "=", "Compressor", "(", ")", "\n", "\n", "for", "n", "in", "range", "(", "len", "(", "table_ins", ")", ")", ":", "\n", "    ", "for", "og", "in", "range", "(", "output_group", ")", ":", "\n", "\n", "      ", "if", "output_group", ">", "1", ":", "\n", "        ", "if", "generate_pla", ":", "\n", "          ", "if", "OG_IS_SYMBOLIC", ":", "\n", "            ", "og_l", "=", "[", "\"0\"", "]", "*", "n_bits_og", "\n", "og_l", "[", "n_bits_og", "-", "1", "-", "og", "]", "=", "\"1\"", "\n", "og_b", "=", "\"\"", ".", "join", "(", "og_l", ")", "\n", "table_i_suffix", "=", "\" \"", "+", "og_b", "\n", "", "else", ":", "\n", "            ", "og_b", "=", "bin", "(", "og", ")", "[", "2", ":", "]", "\n", "table_i_suffix", "=", "\" \"", "+", "\"0\"", "*", "(", "n_bits_og", "-", "len", "(", "og_b", ")", ")", "+", "og_b", "\n", "", "", "else", ":", "\n", "          ", "table_i_suffix", "=", "\",\"", "+", "str", "(", "og", ")", "\n", "", "", "else", ":", "\n", "        ", "table_i_suffix", "=", "\"\"", "\n", "", "table_i", "=", "table_ins", "[", "n", "]", "+", "table_i_suffix", "\n", "table_o", "=", "table_ous", "[", "n", "]", "[", "(", "o", "+", "og", ")", "*", "o_bits", ":", "(", "o", "+", "og", "+", "1", ")", "*", "o_bits", "]", "\n", "\n", "if", "generate_pla", ":", "\n", "        ", "c", ".", "add_entry", "(", "table_i", "+", "\" \"", "+", "table_o", ")", "\n", "", "else", ":", "\n", "        ", "c", ".", "add_entry", "(", "table_i", "+", "\",\"", "+", "str", "(", "table_o", "[", "0", "]", ")", ")", "\n", "\n", "", "", "", "for", "line", "in", "c", "(", ")", ":", "\n", "    ", "f", ".", "write", "(", "\"{}\\n\"", ".", "format", "(", "line", "[", "0", "]", ")", ")", "\n", "\n", "", "if", "generate_pla", ":", "\n", "    ", "f", ".", "write", "(", "\".e\\n\"", ")", "\n", "", "f", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.dense.optimize_dense_logic": [[156, 361], ["model.get_layer", "model.get_layer", "min", "numpy.array", "numpy.random.shuffle", "tensorflow.keras.models.Model", "tensorflow.keras.models.Model.predict", "print", "range", "print", "print", "print", "multiprocessing.Pool", "range", "mp.Pool.close", "mp.Pool.join", "sum", "sum", "len", "len", "print", "min", "multiprocessing.Pool", "range", "mp.Pool.close", "mp.Pool.join", "range", "isinstance", "len", "len", "len", "print", "numpy.min", "numpy.max", "shutil.rmtree", "os.makedirs", "multiprocessing.cpu_count", "mp.Pool.apply_async", "results.append", "pool.apply_async.get", "files.append", "mp.Pool.apply_async", "six.next", "six.next", "numpy.min", "numpy.max", "len", "int", "multiprocessing.cpu_count", "header.append", "header.append", "header.append", "header.append", "range", "range", "header.append", "six.itervalues", "six.itervalues", "numpy.ceil", "header.append", "range", "i_names.append", "numpy.log2", "i_names.append", "str", "range", "str"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "optimize_dense_logic", "(", "\n", "model", ",", "i_name", ",", "o_name", ",", "x_train", ",", "i_dict", ",", "o_dict", ",", "\n", "output_group", "=", "1", ",", "samples", "=", "2000", ",", "\n", "generate_pla", "=", "True", ",", "prefix", "=", "\"\"", ")", ":", "\n", "\n", "  ", "\"\"\"Generates table for logic synthesis for dense or flattened layer.\n\n  Generates table in either espresso format or csv format to be optimized\n  for logic synthesis.\n\n  Arguments:\n    model: Keras model\n    i_name: name of convolutional layer (input to this layer must be\n      quantized).\n    o_name: name of quantized output layer.\n    x_train: training set to be used to dump table.\n    i_dict: dictionary of floating point values to encoding for inputs.\n    o_dict: dictionary of floating point values to encoding for outputs.\n    output_group: by default, we compute one PE per channel output. The user\n      can override that by specifying how many output channels should be\n      bundled into the same PE.\n    samples: how many images from x_train should be sampled when generating the\n      tables.\n    generate_pla: if true, we generate table in pla format. Otherwise, we\n      generate a csv file.\n    prefix: prefix name to create a directory.\n  Returns:\n    list of files generated.\n  \"\"\"", "\n", "\n", "i_layer", "=", "model", ".", "get_layer", "(", "i_name", ")", "\n", "o_layer", "=", "model", ".", "get_layer", "(", "o_name", ")", "\n", "\n", "# resample inputs", "\n", "\n", "skip", "=", "min", "(", "2000", ",", "samples", ")", "\n", "\n", "indexes", "=", "np", ".", "array", "(", "range", "(", "x_train", ".", "shape", "[", "0", "]", ")", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "indexes", ")", "\n", "\n", "x_train", "=", "x_train", "[", "indexes", "[", ":", "samples", "]", "]", "\n", "\n", "outputs", "=", "[", "]", "\n", "\n", "x", "=", "i_layer", ".", "input", "\n", "y", "=", "o_layer", ".", "output", "\n", "\n", "if", "not", "isinstance", "(", "x", ",", "list", ")", ":", "\n", "    ", "x", "=", "[", "x", "]", "\n", "\n", "", "outputs", "=", "x", "+", "[", "y", "]", "\n", "\n", "mo", "=", "Model", "(", "inputs", "=", "model", ".", "inputs", ",", "outputs", "=", "outputs", ")", "\n", "p", "=", "mo", ".", "predict", "(", "x_train", ")", "\n", "\n", "# in csv mode, each entry has \"1\" value, for PLA,", "\n", "# we encode the floating point into multiple bits.", "\n", "\n", "if", "not", "generate_pla", ":", "\n", "    ", "i_bits", "=", "1", "\n", "# i_dict = {v:v for v in i_dict.keys()}", "\n", "", "else", ":", "\n", "    ", "i_bits", "=", "len", "(", "six", ".", "next", "(", "six", ".", "itervalues", "(", "i_dict", ")", ")", ")", "\n", "\n", "", "if", "not", "generate_pla", ":", "\n", "    ", "o_bits", "=", "1", "\n", "# o_dict = {v:v for v in o_dict.keys()}", "\n", "", "else", ":", "\n", "    ", "o_bits", "=", "len", "(", "six", ".", "next", "(", "six", ".", "itervalues", "(", "o_dict", ")", ")", ")", "\n", "\n", "", "print", "(", "\"inputs:\"", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "x", ")", ")", ":", "\n", "    ", "print", "(", "i", ",", "np", ".", "min", "(", "p", "[", "i", "]", ")", ",", "np", ".", "max", "(", "p", "[", "i", "]", ")", ")", "\n", "", "print", "(", "\"outputs:\"", ")", "\n", "print", "(", "0", ",", "np", ".", "min", "(", "p", "[", "-", "1", "]", ")", ",", "np", ".", "max", "(", "p", "[", "-", "1", "]", ")", ")", "\n", "\n", "o_size", "=", "y", ".", "shape", "[", "-", "1", "]", "\n", "i_size", "=", "p", "[", "0", "]", ".", "shape", "[", "-", "1", "]", "\n", "\n", "if", "generate_pla", ":", "\n", "    ", "suffix", "=", "\"pla\"", "\n", "", "else", ":", "\n", "    ", "suffix", "=", "\"csv\"", "\n", "\n", "", "prefix", "=", "prefix", "+", "\"/\"", "if", "prefix", "else", "\"\"", "\n", "\n", "# lets try to remove the directory and create a new one", "\n", "\n", "try", ":", "\n", "    ", "shutil", ".", "rmtree", "(", "prefix", "+", "i_layer", ".", "name", "+", "\".\"", "+", "suffix", ")", "\n", "", "except", "OSError", ":", "\n", "    ", "pass", "\n", "\n", "", "try", ":", "\n", "    ", "os", ".", "makedirs", "(", "prefix", "+", "i_layer", ".", "name", "+", "\".\"", "+", "suffix", ")", "\n", "", "except", "OSError", ":", "\n", "    ", "pass", "\n", "\n", "", "print", "(", "\"...indexing inputs\"", ")", "\n", "\n", "# for each image in sampled x_train", "\n", "\n", "# on Intel processors, mp.cpu_count() returns number of threads", "\n", "\n", "number_of_processes", "=", "mp", ".", "cpu_count", "(", ")", "//", "2", "\n", "pool", "=", "mp", ".", "Pool", "(", "number_of_processes", ")", "\n", "\n", "results", "=", "[", "]", "\n", "\n", "for", "n", "in", "range", "(", "0", ",", "x_train", ".", "shape", "[", "0", "]", ",", "skip", ")", ":", "\n", "\n", "    ", "res", "=", "pool", ".", "apply_async", "(", "\n", "parallel_index_table", ",", "\n", "args", "=", "(", "(", "p", "[", "0", "]", "[", "n", ":", "n", "+", "skip", "]", ",", "p", "[", "1", "]", "[", "n", ":", "n", "+", "skip", "]", ")", ",", "n", ",", "skip", ",", "i_dict", ",", "o_dict", ",", "\n", "generate_pla", ")", ")", "\n", "results", ".", "append", "(", "res", ")", "\n", "\n", "", "pool", ".", "close", "(", ")", "\n", "pool", ".", "join", "(", ")", "\n", "\n", "all_pools", "=", "[", "res", ".", "get", "(", "timeout", "=", "1", ")", "for", "res", "in", "results", "]", "\n", "\n", "table_ins", "=", "sum", "(", "[", "ap", "[", "0", "]", "for", "ap", "in", "all_pools", "]", ",", "[", "]", ")", "\n", "table_ous", "=", "sum", "(", "[", "ap", "[", "1", "]", "for", "ap", "in", "all_pools", "]", ",", "[", "]", ")", "\n", "\n", "# input and output size", "\n", "\n", "ni", "=", "len", "(", "table_ins", "[", "0", "]", ")", "\n", "no", "=", "len", "(", "table_ous", "[", "0", "]", ")", "\n", "\n", "print", "(", "\"... generating tables {} outputs, {} entries\"", ".", "format", "(", "\n", "o_size", ",", "len", "(", "table_ins", ")", ")", ")", "\n", "\n", "# this step should be very fast", "\n", "\n", "files", "=", "[", "]", "\n", "\n", "if", "OG_IS_SYMBOLIC", ":", "\n", "    ", "if", "output_group", ">", "1", ":", "\n", "      ", "n_bits_og", "=", "output_group", "\n", "", "else", ":", "\n", "      ", "n_bits_og", "=", "1", "\n", "", "", "else", ":", "\n", "    ", "if", "output_group", "==", "2", ":", "\n", "      ", "n_bits_og", "=", "1", "\n", "", "else", ":", "\n", "      ", "n_bits_og", "=", "int", "(", "np", ".", "ceil", "(", "np", ".", "log2", "(", "output_group", ")", ")", ")", "\n", "\n", "# sometimes linux get very grumpy with too many files opened.", "\n", "# let's limit to 20.", "\n", "\n", "", "", "number_of_processes", "=", "min", "(", "20", ",", "mp", ".", "cpu_count", "(", ")", "//", "2", ")", "\n", "pool", "=", "mp", ".", "Pool", "(", "number_of_processes", ")", "\n", "\n", "for", "o", "in", "range", "(", "0", ",", "o_size", ",", "output_group", ")", ":", "\n", "\n", "    ", "filename", "=", "\"{}{}.{}/{}_{}.raw.{}\"", ".", "format", "(", "\n", "prefix", ",", "i_name", ",", "suffix", ",", "i_name", ",", "o", ",", "suffix", ")", "\n", "\n", "files", ".", "append", "(", "filename", ")", "\n", "\n", "header", "=", "[", "]", "\n", "\n", "if", "generate_pla", ":", "\n", "      ", "header", ".", "append", "(", "\".i {}\\n\"", ".", "format", "(", "ni", "+", "n_bits_og", ")", ")", "\n", "header", ".", "append", "(", "\".o {}\\n\"", ".", "format", "(", "no", "//", "o_size", ")", ")", "\n", "header", ".", "append", "(", "\".type fr\\n\"", ")", "\n", "\n", "if", "OG_IS_SYMBOLIC", "and", "output_group", ">", "1", ":", "\n", "        ", "header", ".", "append", "(", "\".mv {} {} {} {}\\n\"", ".", "format", "(", "\n", "3", ",", "ni", ",", "n_bits_og", ",", "no", "//", "o_size", ")", ")", "\n", "\n", "# let's generate some labels", "\n", "\n", "", "header", ".", "append", "(", "\".ob \"", "+", "\" \"", ".", "join", "(", "[", "\n", "\"o_\"", "+", "str", "(", "o", ")", "+", "\"_\"", "+", "str", "(", "o_bits", "-", "1", "-", "v", ")", "\n", "for", "v", "in", "range", "(", "o_bits", ")", "]", ")", "+", "\"\\n\"", ")", "\n", "\n", "i_names", "=", "[", "]", "\n", "\n", "# name is i_<features>_bit", "\n", "\n", "assert", "ni", "==", "(", "i_size", "*", "i_bits", ")", "\n", "\n", "for", "feature", "in", "range", "(", "i_size", ")", ":", "\n", "        ", "for", "bit", "in", "range", "(", "i_bits", ")", ":", "\n", "          ", "i_names", ".", "append", "(", "\"i_{}_{}\"", ".", "format", "(", "\n", "feature", ",", "(", "i_bits", "-", "1", "-", "bit", ")", ")", ")", "\n", "\n", "# if we are grouping multiple channels, these will be the inputs", "\n", "\n", "", "", "for", "c", "in", "range", "(", "n_bits_og", ")", ":", "\n", "        ", "i_names", ".", "append", "(", "\"og_{}\"", ".", "format", "(", "n_bits_og", "-", "1", "-", "c", ")", ")", "\n", "\n", "", "header", ".", "append", "(", "\".ilb \"", "+", "\" \"", ".", "join", "(", "i_names", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "pool", ".", "apply_async", "(", "\n", "parallel_compress_output_table", ",", "\n", "args", "=", "(", "(", "filename", ",", "header", ",", "table_ins", ",", "table_ous", ",", "output_group", ",", "\n", "generate_pla", ",", "n_bits_og", ",", "o", ",", "o_bits", ")", ")", ")", "\n", "\n", "", "pool", ".", "close", "(", ")", "\n", "pool", ".", "join", "(", ")", "\n", "\n", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.conv2d.parallel_index_table": [[37, 132], ["print", "compress.Compressor", "range", "print", "[].flatten", "table_ins.append", "table_ous.append", "compress.Compressor.add_entry", "compress.Compressor.has_entry", "len", "str", "str", "print", "print", "print", "print", "print"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.lo.compress.Compressor.add_entry", "home.repos.pwc.inspect_result.google_qkeras.lo.compress.Compressor.has_entry"], ["def", "parallel_index_table", "(", "\n", "p", ",", "ni", ",", "size", ",", "idx_height", ",", "idx_width", ",", "i_dict", ",", "o_dict", ",", "\n", "kernel", ",", "strides", ",", "padding", ",", "generate_pla", ")", ":", "\n", "  ", "\"\"\"Processes the table in parallel and use espresso to optimize it.\"\"\"", "\n", "\n", "print", "(", "\"... indexing table from {} to {} ({} => {})\"", ".", "format", "(", "\n", "ni", ",", "ni", "+", "size", ",", "p", "[", "0", "]", ".", "shape", ",", "p", "[", "1", "]", ".", "shape", ")", ")", "\n", "\n", "table_ins", "=", "[", "]", "\n", "table_ous", "=", "[", "]", "\n", "\n", "table_set", "=", "Compressor", "(", "hash_only_input", "=", "True", ")", "\n", "\n", "if", "DEBUG", ":", "\n", "    ", "table_set_line", "=", "{", "}", "\n", "\n", "", "for", "n", "in", "range", "(", "size", ")", ":", "\n", "\n", "# we need to traverse the outputs to compute the input coordinates", "\n", "\n", "    ", "for", "ho", "in", "idx_height", ":", "\n", "      ", "min_hi", "=", "strides", "[", "0", "]", "*", "ho", "-", "2", "*", "padding", "[", "0", "]", "\n", "max_hi", "=", "strides", "[", "0", "]", "*", "ho", "-", "2", "*", "padding", "[", "0", "]", "+", "kernel", "[", "0", "]", "\n", "\n", "if", "min_hi", "<", "0", "or", "max_hi", ">", "p", "[", "0", "]", ".", "shape", "[", "0", "]", ":", "\n", "        ", "continue", "\n", "\n", "", "for", "wo", "in", "idx_width", ":", "\n", "        ", "min_wi", "=", "strides", "[", "1", "]", "*", "wo", "-", "2", "*", "padding", "[", "1", "]", "\n", "max_wi", "=", "strides", "[", "1", "]", "*", "wo", "-", "2", "*", "padding", "[", "1", "]", "+", "kernel", "[", "1", "]", "\n", "\n", "if", "min_wi", "<", "0", "or", "max_wi", ">", "p", "[", "0", "]", ".", "shape", "[", "1", "]", ":", "\n", "          ", "continue", "\n", "\n", "", "i_values", "=", "p", "[", "0", "]", "[", "n", ",", "min_hi", ":", "max_hi", ",", "min_wi", ":", "max_wi", "]", ".", "flatten", "(", ")", "\n", "\n", "# o_values has dimension (1, 1, C_O)", "\n", "\n", "o_values", "=", "p", "[", "1", "]", "[", "n", ",", "ho", ",", "wo", "]", "\n", "\n", "# if we generate a pla entry, we care about a list of", "\n", "# bits. Otherwise, we care about a list of floating point", "\n", "# values.", "\n", "\n", "table_i", "=", "\"\"", ".", "join", "(", "[", "i_dict", "[", "v", "]", "for", "v", "in", "i_values", "]", ")", "\n", "table_o", "=", "\"\"", ".", "join", "(", "[", "o_dict", "[", "v", "]", "for", "v", "in", "o_values", "]", ")", "\n", "\n", "if", "generate_pla", ":", "\n", "          ", "table_s", "=", "\"\"", ".", "join", "(", "[", "str", "(", "v", ")", "for", "v", "in", "table_i", "]", ")", "\n", "bit_str", "=", "table_s", "\n", "", "else", ":", "\n", "          ", "table_s", "=", "\",\"", ".", "join", "(", "[", "str", "(", "v", ")", "for", "v", "in", "table_i", "]", ")", "\n", "table_i", "=", "table_s", "\n", "bit_str", "=", "\"\"", ".", "join", "(", "i_dict", "[", "v", "]", "for", "v", "in", "i_values", ")", "\n", "", "is_table_zero", "=", "bit_str", "!=", "\"0\"", "*", "len", "(", "bit_str", ")", "\n", "\n", "if", "table_set", ".", "has_entry", "(", "table_s", ")", "and", "not", "is_table_zero", ":", "\n", "\n", "# if table is already stored, we do not store it again.", "\n", "# from time to time, we may want to check if we have found", "\n", "# diverging output values.", "\n", "\n", "          ", "if", "DEBUG", ":", "\n", "\n", "            ", "(", "table_o_old", ",", "(", "old_n", ",", "old_ho", ",", "old_wo", ")", ")", "=", "table_set_line", "[", "table_s", "]", "\n", "\n", "if", "table_o", "!=", "table_o_old", ":", "\n", "              ", "print", "(", "\n", "\"contradicting outputs n={} old_n={} out_p={} out={}\"", ".", "format", "(", "\n", "(", "n", ",", "ho", ",", "wo", ")", ",", "(", "old_n", ",", "old_ho", ",", "old_wo", ")", ",", "table_o_old", ",", "\n", "table_o", ")", ")", "\n", "print", "(", "\" I:\"", ",", "table_s", ")", "\n", "print", "(", "\" I:\"", ",", "i_values", ")", "\n", "print", "(", "\"<<<\"", ",", "table_o_old", ")", "\n", "print", "(", "\">>>\"", ",", "table_o", ")", "\n", "return", "(", "None", ",", "None", ")", "\n", "\n", "", "", "continue", "\n", "\n", "# these are unique table entries", "\n", "\n", "", "table_ins", ".", "append", "(", "table_i", ")", "\n", "table_ous", ".", "append", "(", "table_o", ")", "\n", "\n", "# we store this information in order to be able to debug", "\n", "# and discard information.", "\n", "\n", "table_set", ".", "add_entry", "(", "table_s", ")", "\n", "\n", "if", "DEBUG", ":", "\n", "          ", "table_set_line", "[", "table_s", "]", "=", "(", "table_o", ",", "(", "n", ",", "ho", ",", "wo", ")", ")", "\n", "\n", "", "", "", "", "print", "(", "\"... indexing table from {} to {} completed\"", ".", "format", "(", "ni", ",", "ni", "+", "size", ")", ")", "\n", "\n", "return", "(", "table_ins", ",", "table_ous", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.conv2d.parallel_compress_output_table": [[134, 179], ["open", "open.write", "compress.Compressor", "range", "compress.Compressor.", "open.close", "print", "len", "range", "open.write", "open.write", "compress.Compressor.add_entry", "compress.Compressor.add_entry", "str", "str", "bin", "len"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.lo.compress.Compressor.add_entry", "home.repos.pwc.inspect_result.google_qkeras.lo.compress.Compressor.add_entry"], ["", "def", "parallel_compress_output_table", "(", "\n", "filename", ",", "header", ",", "table_ins", ",", "table_ous", ",", "output_group", ",", "generate_pla", ",", "\n", "n_bits_og", ",", "o", ",", "o_bits", ")", ":", "\n", "  ", "\"\"\"Processes in parallel compression of table and writes it to a disk.\"\"\"", "\n", "\n", "f", "=", "open", "(", "filename", ",", "\"w\"", ")", "\n", "\n", "f", ".", "write", "(", "\"\"", ".", "join", "(", "header", ")", ")", "\n", "\n", "c", "=", "Compressor", "(", ")", "\n", "\n", "for", "n", "in", "range", "(", "len", "(", "table_ins", ")", ")", ":", "\n", "    ", "for", "og", "in", "range", "(", "output_group", ")", ":", "\n", "\n", "      ", "if", "output_group", ">", "1", ":", "\n", "        ", "if", "generate_pla", ":", "\n", "          ", "if", "OG_IS_SYMBOLIC", ":", "\n", "            ", "og_l", "=", "[", "\"0\"", "]", "*", "n_bits_og", "\n", "og_l", "[", "n_bits_og", "-", "1", "-", "og", "]", "=", "\"1\"", "\n", "og_b", "=", "\"\"", ".", "join", "(", "og_l", ")", "\n", "table_i_suffix", "=", "\" \"", "+", "og_b", "\n", "", "else", ":", "\n", "            ", "og_b", "=", "bin", "(", "og", ")", "[", "2", ":", "]", "\n", "table_i_suffix", "=", "\" \"", "+", "\"0\"", "*", "(", "n_bits_og", "-", "len", "(", "og_b", ")", ")", "+", "og_b", "\n", "", "", "else", ":", "\n", "          ", "table_i_suffix", "=", "\",\"", "+", "str", "(", "og", ")", "\n", "", "", "else", ":", "\n", "        ", "table_i_suffix", "=", "\"\"", "\n", "", "table_i", "=", "table_ins", "[", "n", "]", "+", "table_i_suffix", "\n", "table_o", "=", "table_ous", "[", "n", "]", "[", "(", "o", "+", "og", ")", "*", "o_bits", ":", "(", "o", "+", "og", "+", "1", ")", "*", "o_bits", "]", "\n", "\n", "if", "generate_pla", ":", "\n", "        ", "c", ".", "add_entry", "(", "table_i", "+", "\" \"", "+", "table_o", ")", "\n", "", "else", ":", "\n", "        ", "c", ".", "add_entry", "(", "table_i", "+", "\",\"", "+", "str", "(", "table_o", "[", "0", "]", ")", ")", "\n", "\n", "", "", "", "for", "line", "in", "c", "(", ")", ":", "\n", "    ", "f", ".", "write", "(", "\"{}\\n\"", ".", "format", "(", "line", "[", "0", "]", ")", ")", "\n", "\n", "", "if", "generate_pla", ":", "\n", "    ", "f", ".", "write", "(", "\".e\\n\"", ")", "\n", "\n", "", "f", ".", "close", "(", ")", "\n", "\n", "print", "(", "\"... file {} generated\"", ".", "format", "(", "filename", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.conv2d.optimize_conv2d_logic": [[181, 471], ["model.get_layer", "model.get_layer", "utils.get_padding_value", "utils.get_padding_value", "min", "numpy.array", "numpy.random.shuffle", "tensorflow.keras.models.Model", "tensorflow.keras.models.Model.predict", "print", "range", "print", "print", "list", "list", "print", "multiprocessing.Pool", "range", "mp.Pool.close", "mp.Pool.join", "sum", "sum", "len", "len", "print", "min", "multiprocessing.Pool", "range", "mp.Pool.close", "mp.Pool.join", "range", "isinstance", "len", "len", "numpy.random.choice", "numpy.random.choice", "range", "range", "len", "print", "numpy.min", "numpy.max", "shutil.rmtree", "os.makedirs", "multiprocessing.cpu_count", "mp.Pool.apply_async", "results.append", "pool.apply_async.get", "files.append", "mp.Pool.apply_async", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "six.next", "six.next", "int", "int", "numpy.min", "numpy.max", "len", "int", "multiprocessing.cpu_count", "header.append", "header.append", "header.append", "header.append", "range", "range", "header.append", "six.itervalues", "six.itervalues", "numpy.round", "numpy.round", "numpy.ceil", "header.append", "range", "i_names.append", "numpy.sqrt", "numpy.sqrt", "numpy.log2", "range", "range", "i_names.append", "str", "range", "str"], "function", ["home.repos.pwc.inspect_result.google_qkeras.lo.utils.get_padding_value", "home.repos.pwc.inspect_result.google_qkeras.lo.utils.get_padding_value", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "optimize_conv2d_logic", "(", "\n", "model", ",", "i_name", ",", "o_name", ",", "x_train", ",", "\n", "i_dict", "=", "None", ",", "o_dict", "=", "None", ",", "\n", "kernel", "=", "None", ",", "strides", "=", "None", ",", "padding", "=", "None", ",", "\n", "output_group", "=", "1", ",", "samples", "=", "2000", ",", "\n", "randomize", "=", "None", ",", "generate_pla", "=", "True", ",", "prefix", "=", "\"\"", ")", ":", "\n", "  ", "\"\"\"Generates table for logic synthesis for conv2d or conv2d-like shape.\n\n  Generates table in either espresso format or csv format to be optimized\n  for logic synthesis. The parameters kernel, strides and padding usually\n  do not require any values, unless we want to embed maxpooling layer or\n  multiple convolutional layers between i_name and o_name. In that case,\n  we require the user to compute the proper kernel, strides, and padding\n  that will correspond to the combined layer, as Keras and tensorflow do not\n  provide a way to compute the receptive field between two layers.\n\n  Arguments:\n    model: Keras model\n    i_name: name of convolutional layer (input to this layer must be\n      quantized).\n    o_name: name of quantized output layer.\n    x_train: training set to be used to dump table.\n    i_dict: dictionary of floating point values to encoding for inputs.\n    o_dict: dictionary of floating point values to encoding for outputs.\n    kernel: kernel size, to be specified if we want to override convolution\n      kernel.\n    strides: strides, to be specified if we want to override first convolution\n      strides.\n    padding: padding, to be specified if we want to override first convolution\n      padding.\n    output_group: by default, we compute one PE per channel output. The user\n      can override that by specifying how many output channels should be\n      bundled into the same PE.\n    samples: how many images from x_train should be sampled when generating the\n      tables.\n    randomize: if specified, it should be the number of coordinates within the\n      same image we will use to derive the convolution table.\n    generate_pla: if true, we generate table in pla format. Otherwise, we\n      generate a csv file.\n    prefix: prefix name to create directory.\n\n  Returns:\n    list of files generated.\n  \"\"\"", "\n", "\n", "# if no i_dict or no o_dict, we do not know how to encode, so we generate", "\n", "# csv file.", "\n", "\n", "if", "not", "i_dict", "or", "not", "o_dict", ":", "\n", "    ", "generate_pla", "=", "False", "\n", "\n", "# extract layer from i_name and o_name", "\n", "\n", "", "i_layer", "=", "model", ".", "get_layer", "(", "i_name", ")", "\n", "o_layer", "=", "model", ".", "get_layer", "(", "o_name", ")", "\n", "\n", "# if kernel is not specified, use the kernel size from i_layer", "\n", "\n", "if", "not", "kernel", ":", "\n", "    ", "kernel", "=", "i_layer", ".", "kernel_size", "\n", "\n", "# if strides is not specified, use the strides from i_layer", "\n", "\n", "", "if", "not", "strides", ":", "\n", "    ", "strides", "=", "i_layer", ".", "strides", "\n", "\n", "# if padding is not specified, use the padding from i_layer", "\n", "\n", "", "if", "not", "padding", ":", "\n", "    ", "padding", "=", "i_layer", ".", "padding", "\n", "\n", "# for conv2d, we want a list for kernel, strides and padding", "\n", "\n", "", "if", "not", "isinstance", "(", "kernel", ",", "list", ")", "and", "not", "isinstance", "(", "kernel", ",", "tuple", ")", ":", "\n", "    ", "kernel", "=", "[", "kernel", ",", "kernel", "]", "\n", "\n", "", "if", "not", "isinstance", "(", "strides", ",", "list", ")", "and", "not", "isinstance", "(", "strides", ",", "tuple", ")", ":", "\n", "    ", "strides", "=", "[", "strides", ",", "strides", "]", "\n", "\n", "", "if", "not", "isinstance", "(", "padding", ",", "list", ")", "and", "not", "isinstance", "(", "padding", ",", "tuple", ")", ":", "\n", "    ", "padding", "=", "[", "padding", ",", "padding", "]", "\n", "\n", "# compute the padding value", "\n", "\n", "", "padding", "[", "0", "]", "=", "get_padding_value", "(", "padding", "[", "0", "]", ",", "kernel", "[", "0", "]", ")", "\n", "padding", "[", "1", "]", "=", "get_padding_value", "(", "padding", "[", "1", "]", ",", "kernel", "[", "1", "]", ")", "\n", "\n", "# resample inputs", "\n", "\n", "skip", "=", "min", "(", "2000", ",", "samples", ")", "\n", "\n", "indexes", "=", "np", ".", "array", "(", "range", "(", "x_train", ".", "shape", "[", "0", "]", ")", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "indexes", ")", "\n", "x_train", "=", "x_train", "[", "indexes", "[", ":", "samples", "]", "]", "\n", "\n", "# we want to create a smaller model that from inputs generate", "\n", "# i_layer.output + o_layer.output tensors, so that we can predict", "\n", "# its values.", "\n", "\n", "outputs", "=", "[", "]", "\n", "\n", "x", "=", "i_layer", ".", "input", "\n", "y", "=", "o_layer", ".", "output", "\n", "\n", "if", "not", "isinstance", "(", "x", ",", "list", ")", ":", "\n", "    ", "x", "=", "[", "x", "]", "\n", "\n", "", "outputs", "=", "x", "+", "[", "y", "]", "\n", "\n", "mo", "=", "Model", "(", "inputs", "=", "model", ".", "inputs", ",", "outputs", "=", "outputs", ")", "\n", "p", "=", "mo", ".", "predict", "(", "x_train", ")", "\n", "\n", "# in csv mode, each entry has \"1\" value, for PLA,", "\n", "# we encode the floating point into multiple bits.", "\n", "\n", "if", "not", "generate_pla", ":", "\n", "    ", "i_bits", "=", "1", "\n", "# i_dict = {v:v for v in i_dict.keys()}", "\n", "", "else", ":", "\n", "    ", "i_bits", "=", "len", "(", "six", ".", "next", "(", "six", ".", "itervalues", "(", "i_dict", ")", ")", ")", "\n", "\n", "", "if", "not", "generate_pla", ":", "\n", "    ", "o_bits", "=", "1", "\n", "# o_dict = {v:v for v in o_dict.keys()}", "\n", "", "else", ":", "\n", "    ", "o_bits", "=", "len", "(", "six", ".", "next", "(", "six", ".", "itervalues", "(", "o_dict", ")", ")", ")", "\n", "\n", "# if randomize is specified, we will sample sqrt(randomize)", "\n", "# from each image, as the conv2d performs the filter everywhere", "\n", "# in the image. Because the same image may contain a lot of", "\n", "# reduntant information, we may want to restrict the number of", "\n", "# samples.", "\n", "\n", "", "if", "randomize", ":", "\n", "    ", "idx_height", "=", "np", ".", "random", ".", "choice", "(", "\n", "p", "[", "-", "1", "]", ".", "shape", "[", "1", "]", ",", "\n", "int", "(", "np", ".", "round", "(", "np", ".", "sqrt", "(", "randomize", ")", ")", ")", ")", "\n", "\n", "idx_width", "=", "np", ".", "random", ".", "choice", "(", "\n", "p", "[", "-", "1", "]", ".", "shape", "[", "2", "]", ",", "\n", "int", "(", "np", ".", "round", "(", "np", ".", "sqrt", "(", "randomize", ")", ")", ")", ")", "\n", "", "else", ":", "\n", "    ", "idx_height", "=", "range", "(", "p", "[", "-", "1", "]", ".", "shape", "[", "1", "]", ")", "\n", "idx_width", "=", "range", "(", "p", "[", "-", "1", "]", ".", "shape", "[", "2", "]", ")", "\n", "\n", "# this is just to inspect that the inputs and outputs are really quantized.", "\n", "\n", "", "print", "(", "\"inputs:\"", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "x", ")", ")", ":", "\n", "    ", "print", "(", "i", ",", "np", ".", "min", "(", "p", "[", "i", "]", ")", ",", "np", ".", "max", "(", "p", "[", "i", "]", ")", ")", "\n", "", "print", "(", "\"outputs:\"", ")", "\n", "print", "(", "np", ".", "min", "(", "p", "[", "-", "1", "]", ")", ",", "np", ".", "max", "(", "p", "[", "-", "1", "]", ")", ")", "\n", "\n", "# i_size and o_size are the channel sizes of the inputs and outputs", "\n", "\n", "o_size", "=", "y", ".", "shape", "[", "-", "1", "]", "\n", "i_size", "=", "p", "[", "0", "]", ".", "shape", "[", "-", "1", "]", "\n", "\n", "if", "generate_pla", ":", "\n", "    ", "suffix", "=", "\"pla\"", "\n", "", "else", ":", "\n", "    ", "suffix", "=", "\"csv\"", "\n", "\n", "", "prefix", "=", "prefix", "+", "\"/\"", "if", "prefix", "else", "\"\"", "\n", "\n", "# lets try to remove the directory and create a new one", "\n", "\n", "try", ":", "\n", "    ", "shutil", ".", "rmtree", "(", "prefix", "+", "i_layer", ".", "name", "+", "\".\"", "+", "suffix", ")", "\n", "", "except", "OSError", ":", "\n", "    ", "pass", "\n", "\n", "", "try", ":", "\n", "    ", "os", ".", "makedirs", "(", "prefix", "+", "i_layer", ".", "name", "+", "\".\"", "+", "suffix", ")", "\n", "", "except", "OSError", ":", "\n", "    ", "pass", "\n", "\n", "", "table_ins", "=", "list", "(", ")", "\n", "table_ous", "=", "list", "(", ")", "\n", "\n", "print", "(", "\"...indexing inputs\"", ")", "\n", "\n", "# for each image in sampled x_train", "\n", "\n", "# on Intel processors, mp.cpu_count() returns number of threads", "\n", "\n", "number_of_processes", "=", "mp", ".", "cpu_count", "(", ")", "//", "2", "\n", "pool", "=", "mp", ".", "Pool", "(", "number_of_processes", ")", "\n", "\n", "results", "=", "[", "]", "\n", "\n", "for", "n", "in", "range", "(", "0", ",", "x_train", ".", "shape", "[", "0", "]", ",", "skip", ")", ":", "\n", "\n", "    ", "res", "=", "pool", ".", "apply_async", "(", "\n", "parallel_index_table", ",", "\n", "args", "=", "(", "(", "p", "[", "0", "]", "[", "n", ":", "n", "+", "skip", "]", ",", "p", "[", "1", "]", "[", "n", ":", "n", "+", "skip", "]", ")", ",", "n", ",", "skip", ",", "idx_height", ",", "\n", "idx_width", ",", "i_dict", ",", "o_dict", ",", "kernel", ",", "strides", ",", "padding", ",", "\n", "generate_pla", ")", ")", "\n", "results", ".", "append", "(", "res", ")", "\n", "\n", "", "pool", ".", "close", "(", ")", "\n", "pool", ".", "join", "(", ")", "\n", "\n", "all_pools", "=", "[", "res", ".", "get", "(", "timeout", "=", "1", ")", "for", "res", "in", "results", "]", "\n", "\n", "table_ins", "=", "sum", "(", "[", "ap", "[", "0", "]", "for", "ap", "in", "all_pools", "]", ",", "[", "]", ")", "\n", "table_ous", "=", "sum", "(", "[", "ap", "[", "1", "]", "for", "ap", "in", "all_pools", "]", ",", "[", "]", ")", "\n", "\n", "# input and output size", "\n", "\n", "ni", "=", "len", "(", "table_ins", "[", "0", "]", ")", "\n", "no", "=", "len", "(", "table_ous", "[", "0", "]", ")", "\n", "\n", "print", "(", "\"... generating tables {} outputs, {} entries\"", ".", "format", "(", "\n", "o_size", ",", "len", "(", "table_ins", ")", ")", ")", "\n", "\n", "# this step should be very fast", "\n", "\n", "files", "=", "[", "]", "\n", "\n", "if", "OG_IS_SYMBOLIC", ":", "\n", "    ", "if", "output_group", ">", "1", ":", "\n", "      ", "n_bits_og", "=", "output_group", "\n", "", "else", ":", "\n", "      ", "n_bits_og", "=", "1", "\n", "", "", "else", ":", "\n", "    ", "if", "output_group", "==", "2", ":", "\n", "      ", "n_bits_og", "=", "1", "\n", "", "else", ":", "\n", "      ", "n_bits_og", "=", "int", "(", "np", ".", "ceil", "(", "np", ".", "log2", "(", "output_group", ")", ")", ")", "\n", "\n", "# sometimes linux get very grumpy with too many files opened.", "\n", "# let's limit to 20.", "\n", "\n", "", "", "number_of_processes", "=", "min", "(", "20", ",", "mp", ".", "cpu_count", "(", ")", "//", "2", ")", "\n", "pool", "=", "mp", ".", "Pool", "(", "number_of_processes", ")", "\n", "\n", "for", "o", "in", "range", "(", "0", ",", "o_size", ",", "output_group", ")", ":", "\n", "\n", "    ", "filename", "=", "\"{}{}.{}/{}_{}.raw.{}\"", ".", "format", "(", "\n", "prefix", ",", "i_name", ",", "suffix", ",", "i_name", ",", "o", ",", "suffix", ")", "\n", "\n", "files", ".", "append", "(", "filename", ")", "\n", "\n", "header", "=", "[", "]", "\n", "\n", "if", "generate_pla", ":", "\n", "      ", "header", ".", "append", "(", "\".i {}\\n\"", ".", "format", "(", "ni", "+", "n_bits_og", ")", ")", "\n", "header", ".", "append", "(", "\".o {}\\n\"", ".", "format", "(", "no", "//", "o_size", ")", ")", "\n", "header", ".", "append", "(", "\".type fr\\n\"", ")", "\n", "\n", "if", "OG_IS_SYMBOLIC", "and", "output_group", ">", "1", ":", "\n", "        ", "header", ".", "append", "(", "\".mv {} {} {} {}\\n\"", ".", "format", "(", "\n", "3", ",", "ni", ",", "n_bits_og", ",", "no", "//", "o_size", ")", ")", "\n", "\n", "# let's generate some labels", "\n", "\n", "", "header", ".", "append", "(", "\".ob \"", "+", "\" \"", ".", "join", "(", "[", "\n", "\"o_\"", "+", "str", "(", "o", ")", "+", "\"_\"", "+", "str", "(", "o_bits", "-", "1", "-", "v", ")", "\n", "for", "v", "in", "range", "(", "o_bits", ")", "]", ")", "+", "\"\\n\"", ")", "\n", "\n", "i_names", "=", "[", "]", "\n", "\n", "# name is i_<channel>_<kernel_row>_<kernel_col>_bit", "\n", "\n", "assert", "ni", "==", "(", "i_size", "*", "kernel", "[", "0", "]", "*", "kernel", "[", "1", "]", "*", "i_bits", ")", "\n", "\n", "for", "channel", "in", "range", "(", "i_size", ")", ":", "\n", "        ", "for", "row", "in", "range", "(", "kernel", "[", "0", "]", ")", ":", "\n", "          ", "for", "col", "in", "range", "(", "kernel", "[", "1", "]", ")", ":", "\n", "            ", "for", "bit", "in", "range", "(", "i_bits", ")", ":", "\n", "              ", "i_names", ".", "append", "(", "\"i_{}_{}_{}_{}\"", ".", "format", "(", "\n", "channel", ",", "row", ",", "col", ",", "(", "i_bits", "-", "1", "-", "bit", ")", ")", ")", "\n", "\n", "# if we are grouping multiple channels, these will be the inputs", "\n", "\n", "", "", "", "", "for", "c", "in", "range", "(", "n_bits_og", ")", ":", "\n", "        ", "i_names", ".", "append", "(", "\"og_{}\"", ".", "format", "(", "n_bits_og", "-", "1", "-", "c", ")", ")", "\n", "\n", "", "header", ".", "append", "(", "\".ilb \"", "+", "\" \"", ".", "join", "(", "i_names", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "pool", ".", "apply_async", "(", "\n", "parallel_compress_output_table", ",", "\n", "args", "=", "(", "(", "filename", ",", "header", ",", "table_ins", ",", "table_ous", ",", "output_group", ",", "\n", "generate_pla", ",", "n_bits_og", ",", "o", ",", "o_bits", ")", ")", ")", "\n", "\n", "", "pool", ".", "close", "(", ")", "\n", "pool", ".", "join", "(", ")", "\n", "\n", "return", "files", "\n", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.lo.generate_rf_code.gen_random_tree_regressor": [[30, 192], ["numpy.copy", "numpy.zeros", "stack.pop", "hex", "generate_rf_code.gen_random_tree_regressor.round_value_to_int"], "function", ["None"], ["def", "gen_random_tree_regressor", "(", "\n", "tree", ",", "code", ",", "bits", ",", "o_bits", ",", "o_decimal_digits", ",", "o_is_neg", ",", "bdd", ",", "offset", ",", "is_cc", "=", "True", ")", ":", "\n", "  ", "\"\"\"Generates HLS friendly C++ code for random tree regressor.\n\n  Generates HLS friendly C++ code for Catapult.\n\n  Arguments:\n    tree: decision tree regressor from SkLearn.\n    code: list of code lines to be append to.\n    bits: list containing number of bits for each of the inputs.\n    o_bits: number of bits for output.\n    o_decimal_digits: number of decimal digits (right of the decimal point\n        of o_bits for approximation of regressor in RandomTreeRegressor.\n    o_is_neg: True or 1 if output can be negative.\n    bdd: we actually try to cache entries (i,v,n1,n0) entries so that if\n        they appear again, we reuse previously computed nodes.\n    offset: each variable created in this function call is incremented by\n        offset.\n    is_cc: if True, generates C++, else Verilog.\n\n  Returns:\n    Tuple containing last variable name and current number of variables.\n\n  \"\"\"", "\n", "\n", "# extract information from tree", "\n", "\n", "n_nodes", "=", "tree", ".", "node_count", "\n", "children_left", "=", "tree", ".", "children_left", "\n", "children_right", "=", "tree", ".", "children_right", "\n", "feature", "=", "tree", ".", "feature", "\n", "threshold", "=", "tree", ".", "threshold", "\n", "values", "=", "np", ".", "copy", "(", "tree", ".", "value", ")", "\n", "\n", "o_suffix", "=", "\"\"", "\n", "if", "DEBUG", ":", "\n", "    ", "o_type", "=", "\"float\"", "\n", "", "elif", "is_cc", ":", "\n", "    ", "o_type", "=", "\"ac_fixed<{},{},{}>\"", ".", "format", "(", "\n", "o_bits", "+", "o_decimal_digits", ",", "\n", "o_bits", "+", "o_is_neg", ",", "\n", "o_is_neg", ")", "\n", "", "else", ":", "\n", "    ", "o_sign", "=", "\" signed\"", "if", "o_is_neg", "else", "\"\"", "\n", "if", "o_bits", "+", "o_decimal_digits", ">", "1", ":", "\n", "      ", "o_suffix", "=", "\"[{}:0]\"", ".", "format", "(", "o_bits", "+", "o_decimal_digits", "-", "1", ")", "\n", "", "o_type", "=", "\"wire\"", "+", "o_sign", "+", "\" \"", "+", "o_suffix", "\n", "\n", "\n", "", "def", "round_digits", "(", "x", ",", "decimal_digits", ")", ":", "\n", "    ", "\"\"\"Rounds to decimal_digits to the right of the decimal point.\"\"\"", "\n", "\n", "if", "DEBUG", ":", "\n", "      ", "return", "x", "\n", "", "factor", "=", "(", "1", "<<", "decimal_digits", ")", "*", "1.0", "\n", "x", "=", "x", "*", "factor", "\n", "return", "np", ".", "round", "(", "x", ")", "/", "factor", "\n", "\n", "", "is_leaves", "=", "np", ".", "zeros", "(", "shape", "=", "n_nodes", ",", "dtype", "=", "bool", ")", "\n", "\n", "stack", "=", "[", "(", "0", ",", "-", "1", ")", "]", "\n", "\n", "while", "stack", ":", "\n", "    ", "node_id", ",", "parent_depth", "=", "stack", ".", "pop", "(", ")", "\n", "\n", "if", "children_left", "[", "node_id", "]", "!=", "children_right", "[", "node_id", "]", ":", "\n", "      ", "stack", ".", "append", "(", "(", "children_left", "[", "node_id", "]", ",", "parent_depth", "+", "1", ")", ")", "\n", "stack", ".", "append", "(", "(", "children_right", "[", "node_id", "]", ",", "parent_depth", "+", "1", ")", ")", "\n", "", "else", ":", "\n", "      ", "is_leaves", "[", "node_id", "]", "=", "True", "\n", "values", "[", "node_id", "]", "=", "round_digits", "(", "tree", ".", "value", "[", "node_id", "]", ",", "o_decimal_digits", ")", "\n", "if", "(", "\n", "values", "[", "node_id", "]", ".", "flatten", "(", ")", "[", "0", "]", "!=", "tree", ".", "value", "[", "node_id", "]", ".", "flatten", "(", ")", "[", "0", "]", "and", "\n", "DEBUG", "\n", ")", ":", "\n", "        ", "print", "(", "node_id", ",", "values", "[", "node_id", "]", ".", "flatten", "(", ")", "[", "0", "]", ",", "\n", "tree", ".", "value", "[", "node_id", "]", ".", "flatten", "(", ")", "[", "0", "]", ")", "\n", "\n", "", "", "", "v_name", "=", "{", "}", "\n", "n_vars", "=", "offset", "\n", "\n", "bdd", "=", "{", "}", "\n", "\n", "def", "round_value_to_int", "(", "x", ")", ":", "\n", "    ", "v", "=", "hex", "(", "int", "(", "np", ".", "round", "(", "x", "*", "(", "1", "<<", "(", "o_decimal_digits", ")", ")", ")", ")", ")", "\n", "if", "is_cc", ":", "\n", "      ", "if", "DEBUG", ":", "\n", "        ", "return", "str", "(", "x", ")", "\n", "", "else", ":", "\n", "        ", "return", "x", "\n", "#v + \" /* {} */\".format(x)", "\n", "", "", "else", ":", "\n", "      ", "return", "(", "\n", "str", "(", "o_bits", "+", "o_decimal_digits", ")", "+", "\"'h\"", "+", "v", "[", "2", ":", "]", "+", "\" /* {} */\"", ".", "format", "(", "x", ")", "\n", ")", "\n", "\n", "", "", "if", "is_leaves", "[", "0", "]", ":", "\n", "    ", "v_name", "[", "0", "]", "=", "round_value_to_int", "(", "values", "[", "0", "]", ".", "flatten", "(", ")", "[", "0", "]", ")", "\n", "code", ".", "append", "(", "\"  {} n_{} = {};\"", ".", "format", "(", "o_type", ",", "n_vars", ",", "v_name", "[", "0", "]", ")", ")", "\n", "last_var", "=", "\"n_{}\"", ".", "format", "(", "n_vars", ")", "\n", "n_vars", "+=", "1", "\n", "", "else", ":", "\n", "    ", "for", "i", "in", "range", "(", "n_nodes", "-", "1", ",", "-", "1", ",", "-", "1", ")", ":", "\n", "      ", "if", "is_leaves", "[", "i", "]", ":", "\n", "        ", "continue", "\n", "\n", "", "if", "v_name", ".", "get", "(", "children_left", "[", "i", "]", ",", "None", ")", "is", "not", "None", ":", "\n", "        ", "n1", "=", "v_name", "[", "children_left", "[", "i", "]", "]", "\n", "", "elif", "is_leaves", "[", "children_left", "[", "i", "]", "]", ":", "\n", "        ", "n1", "=", "round_value_to_int", "(", "values", "[", "children_left", "[", "i", "]", "]", ".", "flatten", "(", ")", "[", "0", "]", ")", "\n", "v_name", "[", "children_left", "[", "i", "]", "]", "=", "n1", "\n", "", "else", ":", "\n", "        ", "n1", "=", "\"n_\"", "+", "str", "(", "n_vars", ")", "\n", "n_vars", "+=", "1", "\n", "v_name", "[", "children_left", "[", "i", "]", "]", "=", "n1", "\n", "raise", "ValueError", "(", "(", "children_left", "[", "i", "]", ",", "n1", ",", "is_leaves", "[", "children_left", "[", "i", "]", "]", ")", ")", "\n", "\n", "", "if", "v_name", ".", "get", "(", "children_right", "[", "i", "]", ",", "None", ")", "is", "not", "None", ":", "\n", "        ", "n0", "=", "v_name", "[", "children_right", "[", "i", "]", "]", "\n", "", "elif", "is_leaves", "[", "children_right", "[", "i", "]", "]", ":", "\n", "        ", "n0", "=", "round_value_to_int", "(", "values", "[", "children_right", "[", "i", "]", "]", ".", "flatten", "(", ")", "[", "0", "]", ")", "\n", "v_name", "[", "children_right", "[", "i", "]", "]", "=", "n0", "\n", "", "else", ":", "\n", "        ", "n0", "=", "\"n_\"", "+", "str", "(", "n_vars", ")", "\n", "n_vars", "+=", "1", "\n", "v_name", "[", "children_right", "[", "i", "]", "]", "=", "n0", "\n", "raise", "ValueError", "(", "(", "children_right", "[", "i", "]", ",", "n0", ",", "is_leaves", "[", "children_right", "[", "i", "]", "]", ")", ")", "\n", "\n", "", "if", "v_name", ".", "get", "(", "i", ",", "None", ")", "is", "not", "None", ":", "\n", "        ", "n", "=", "v_name", "[", "i", "]", "\n", "last_var", "=", "v_name", "[", "i", "]", "\n", "", "elif", "bdd", ".", "get", "(", "(", "feature", "[", "i", "]", ",", "threshold", "[", "i", "]", ",", "n1", ",", "n0", ")", ",", "None", ")", "is", "not", "None", ":", "\n", "        ", "n", "=", "bdd", "[", "(", "feature", "[", "i", "]", ",", "threshold", "[", "i", "]", ",", "n1", ",", "n0", ")", "]", "\n", "v_name", "[", "i", "]", "=", "n", "\n", "last_var", "=", "n", "\n", "", "elif", "n1", "==", "n0", ":", "\n", "# store intermediate results so that we can build a dag, not a tree", "\n", "        ", "bdd", "[", "(", "feature", "[", "i", "]", ",", "threshold", "[", "i", "]", ",", "n1", ",", "n0", ")", "]", "=", "n1", "\n", "v_name", "[", "i", "]", "=", "n1", "\n", "last_var", "=", "n1", "\n", "", "else", ":", "\n", "        ", "n", "=", "\"n_\"", "+", "str", "(", "n_vars", ")", "\n", "n_vars", "+=", "1", "\n", "v_name", "[", "i", "]", "=", "n", "\n", "# store intermediate results so that we can build a dag, not a tree", "\n", "bdd", "[", "(", "feature", "[", "i", "]", ",", "threshold", "[", "i", "]", ",", "n1", ",", "n0", ")", "]", "=", "n", "\n", "t", "=", "int", "(", "threshold", "[", "i", "]", ")", "\n", "if", "bits", "[", "feature", "[", "i", "]", "]", "==", "1", ":", "\n", "          ", "if", "t", "==", "0", ":", "\n", "            ", "n1", ",", "n0", "=", "n0", ",", "n1", "\n", "", "code", ".", "append", "(", "\n", "\"  {} {} = (i_{}) ? {} : {}; // x_{} {}\"", ".", "format", "(", "\n", "o_type", ",", "v_name", "[", "i", "]", ",", "feature", "[", "i", "]", ",", "n1", ",", "n0", ",", "i", ",", "\n", "threshold", "[", "i", "]", ")", ")", "\n", "", "else", ":", "\n", "          ", "code", ".", "append", "(", "\n", "\"  {} {} = (i_{} <= {}) ? {} : {}; // x_{} {}\"", ".", "format", "(", "\n", "o_type", ",", "v_name", "[", "i", "]", ",", "feature", "[", "i", "]", ",", "t", ",", "n1", ",", "n0", ",", "i", ",", "\n", "threshold", "[", "i", "]", ")", ")", "\n", "", "last_var", "=", "v_name", "[", "i", "]", "\n", "\n", "", "", "", "return", "(", "last_var", ",", "n_vars", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.generate_rf_code.entry_to_hex": [[194, 205], ["numpy.array", "hex", "numpy.power", "numpy.sum", "range", "len", "str"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "entry_to_hex", "(", "entry", ",", "max_value", ",", "size", ",", "is_cc", ")", ":", "\n", "  ", "\"\"\"Converts class instance to hexa number.\"\"\"", "\n", "\n", "e_vector", "=", "[", "np", ".", "power", "(", "max_value", "+", "1", ",", "i", ")", "for", "i", "in", "range", "(", "len", "(", "entry", ")", "-", "1", ",", "-", "1", ",", "-", "1", ")", "]", "\n", "entry", "=", "np", ".", "array", "(", "entry", ")", "\n", "v", "=", "hex", "(", "np", ".", "sum", "(", "entry", "*", "e_vector", ")", ")", "\n", "\n", "if", "is_cc", ":", "\n", "    ", "return", "v", "\n", "", "else", ":", "\n", "    ", "return", "str", "(", "size", ")", "+", "\"'h\"", "+", "v", "[", "2", ":", "]", "+", "\" /* {} */\"", ".", "format", "(", "entry", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.generate_rf_code.gen_random_tree_classifier": [[207, 432], ["numpy.zeros", "len", "int", "tree.value[].flatten", "numpy.ceil", "stack.pop", "int", "code.append", "range", "code.append", "numpy.log2", "stack.append", "stack.append", "tree.value[].flatten().astype", "numpy.max", "numpy.min", "tuple", "numpy.ceil", "code.append", "range", "code.append", "code.append", "code.append", "code.append", "code.append", "range", "code.append", "code.append", "code.append", "code.append", "numpy.sum", "numpy.round", "tree.value[].flatten", "list", "values_rom.get", "len", "rom_l.append", "generate_rf_code.entry_to_hex", "numpy.log2", "str", "v_name.get", "v_name.get", "v_name.get", "len", "code.append", "len", "code.append", "tree.value[].flatten", "tree.value[].flatten.astype", "print", "len", "ValueError", "ValueError", "bdd.get", "generate_rf_code.entry_to_hex", "str", "str", "str", "str", "int", "len", "len", "generate_rf_code.entry_to_hex", "str", "code.append", "code.append", "str", "str"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.lo.generate_rf_code.entry_to_hex", "home.repos.pwc.inspect_result.google_qkeras.lo.generate_rf_code.entry_to_hex", "home.repos.pwc.inspect_result.google_qkeras.lo.generate_rf_code.entry_to_hex"], ["", "", "def", "gen_random_tree_classifier", "(", "\n", "tree", ",", "code", ",", "bits", ",", "bdd", ",", "max_value", ",", "values_rom", ",", "offset", ",", "is_cc", "=", "True", ")", ":", "\n", "  ", "\"\"\"Generates C++ or Verilog friendly code for random tree classifier.\n\n  Generates HLS Catapult friendly code or RTL in Verilog for random tree\n  classifier from SkLearn.\n\n  Arguments:\n    tree: RandomTreeClassifier from sklearn.\n    code: list of strings containing code generated.\n    bits: list containing number of bits for each of the inputs.\n    bdd: we actually try to cache entries (i,v,n1,n0) entries so that if\n        they appear again, we reuse previously computed nodes.\n    max_value: random tree classifiers returns vector of classes with the\n        number of instances found in the terminal leaf node. This variable\n        specifies a clipping factor for each class type so that we have\n        a bounded problem to synthesize.\n    values_rom: to save space in classifier, we store class values in\n        values_rom.\n    offset: each variable created in this function call is incremented by\n        offset.\n    is_cc: if True, generates C++ code; otherwise, Verilog.\n\n  Returns:\n    Tuple containing last variable name and current number of variables.\n  \"\"\"", "\n", "\n", "# extract information from tree", "\n", "\n", "n_nodes", "=", "tree", ".", "node_count", "\n", "children_left", "=", "tree", ".", "children_left", "\n", "children_right", "=", "tree", ".", "children_right", "\n", "feature", "=", "tree", ".", "feature", "\n", "threshold", "=", "tree", ".", "threshold", "\n", "\n", "values", "=", "{", "}", "\n", "\n", "is_leaves", "=", "np", ".", "zeros", "(", "shape", "=", "n_nodes", ",", "dtype", "=", "bool", ")", "\n", "\n", "stack", "=", "[", "(", "0", ",", "-", "1", ")", "]", "\n", "\n", "rom_l", "=", "[", "]", "\n", "\n", "use_rom", "=", "max_value", ">=", "7", "\n", "\n", "n_classes", "=", "len", "(", "tree", ".", "value", "[", "0", "]", ".", "flatten", "(", ")", ")", "\n", "\n", "max_bits", "=", "int", "(", "np", ".", "ceil", "(", "np", ".", "log2", "(", "max_value", "+", "1", ")", ")", ")", "\n", "\n", "while", "stack", ":", "\n", "    ", "node_id", ",", "parent_depth", "=", "stack", ".", "pop", "(", ")", "\n", "\n", "if", "children_left", "[", "node_id", "]", "!=", "children_right", "[", "node_id", "]", ":", "\n", "      ", "stack", ".", "append", "(", "(", "children_left", "[", "node_id", "]", ",", "parent_depth", "+", "1", ")", ")", "\n", "stack", ".", "append", "(", "(", "children_right", "[", "node_id", "]", ",", "parent_depth", "+", "1", ")", ")", "\n", "", "else", ":", "\n", "# is leaf node", "\n", "      ", "is_leaves", "[", "node_id", "]", "=", "True", "\n", "# get tree node output", "\n", "p_input_tuple", "=", "tree", ".", "value", "[", "node_id", "]", ".", "flatten", "(", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "max_input_value", "=", "np", ".", "max", "(", "p_input_tuple", ")", "\n", "min_input_value", "=", "np", ".", "min", "(", "p_input_tuple", ")", "\n", "# if max_value == 1, only keep top ones", "\n", "if", "max_value", "==", "1", ":", "\n", "        ", "input_tuple", "=", "(", "p_input_tuple", "==", "max_input_value", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "tree", ".", "value", "[", "node_id", "]", "=", "(", "tree", ".", "value", "[", "node_id", "]", "==", "max_input_value", ")", ".", "astype", "(", "\n", "tree", ".", "value", "[", "node_id", "]", ".", "dtype", ")", "\n", "", "else", ":", "# if max_value <= 3:", "\n", "# SKLearn classifier computes probability for each entry instead of", "\n", "# suming them all. We should do the same.", "\n", "        ", "max_input_value", "=", "np", ".", "sum", "(", "p_input_tuple", ")", "\n", "min_input_value", "=", "0", "\n", "# Just update tree.value to number so that we can compare accuracy of", "\n", "# quantization later.", "\n", "tree", ".", "value", "[", "node_id", "]", "=", "np", ".", "round", "(", "\n", "max_value", "*", "\n", "(", "tree", ".", "value", "[", "node_id", "]", "-", "min_input_value", ")", "/", "\n", "(", "max_input_value", "-", "min_input_value", ")", ")", "\n", "input_tuple", "=", "tree", ".", "value", "[", "node_id", "]", ".", "flatten", "(", ")", "\n", "", "input_tuple", "=", "tuple", "(", "list", "(", "input_tuple", ".", "astype", "(", "np", ".", "int32", ")", ")", ")", "\n", "\n", "# stores values in rom - we will use rom to store values if use_rom is", "\n", "# true.", "\n", "if", "values_rom", ".", "get", "(", "input_tuple", ",", "None", ")", "is", "None", ":", "\n", "        ", "values_rom", "[", "input_tuple", "]", "=", "len", "(", "values_rom", ")", "\n", "rom_l", ".", "append", "(", "input_tuple", ")", "\n", "if", "DEBUG", ":", "\n", "          ", "print", "(", "values_rom", "[", "input_tuple", "]", ",", "input_tuple", ")", "\n", "\n", "", "", "if", "use_rom", ":", "\n", "        ", "values", "[", "node_id", "]", "=", "values_rom", "[", "input_tuple", "]", "\n", "", "else", ":", "\n", "        ", "values", "[", "node_id", "]", "=", "entry_to_hex", "(", "\n", "input_tuple", ",", "max_value", ",", "max_bits", "*", "n_classes", ",", "is_cc", ")", "\n", "\n", "# t_bits: entry type", "\n", "# l_bits: table line type", "\n", "", "", "", "if", "use_rom", ":", "\n", "    ", "t_bits", "=", "int", "(", "np", ".", "ceil", "(", "np", ".", "log2", "(", "len", "(", "values_rom", ")", ")", ")", ")", "\n", "l_bits", "=", "max_bits", "*", "n_classes", "\n", "", "else", ":", "\n", "    ", "t_bits", "=", "max_bits", "*", "n_classes", "\n", "\n", "# we only store the index here, as we read from a rom", "\n", "", "if", "is_cc", ":", "\n", "    ", "if", "DEBUG", ":", "\n", "      ", "t_type", "=", "\"int\"", "\n", "", "else", ":", "\n", "      ", "t_type", "=", "\"ac_int<{},false>\"", ".", "format", "(", "t_bits", ")", "\n", "", "", "else", ":", "\n", "    ", "t_type", "=", "\"wire [{}:0]\"", ".", "format", "(", "t_bits", "-", "1", ")", "\n", "\n", "", "v_name", "=", "{", "}", "\n", "n_vars", "=", "offset", "\n", "\n", "bdd", "=", "{", "}", "\n", "\n", "if", "is_leaves", "[", "0", "]", ":", "\n", "    ", "v_name", "[", "0", "]", "=", "t_type", "+", "\"(\"", "+", "str", "(", "values", "[", "0", "]", ")", "+", "\")\"", "\n", "code", ".", "append", "(", "\"  {} n_{} = {};\"", ".", "format", "(", "\n", "t_type", ",", "n_vars", ",", "values", "[", "0", "]", ")", ")", "\n", "last_var", "=", "\"n_{}\"", ".", "format", "(", "n_vars", ")", "\n", "n_vars", "+=", "1", "\n", "", "else", ":", "\n", "    ", "for", "i", "in", "range", "(", "n_nodes", "-", "1", ",", "-", "1", ",", "-", "1", ")", ":", "\n", "      ", "if", "is_leaves", "[", "i", "]", ":", "\n", "        ", "continue", "\n", "\n", "", "if", "v_name", ".", "get", "(", "children_left", "[", "i", "]", ",", "None", ")", "is", "not", "None", ":", "\n", "        ", "n1", "=", "v_name", "[", "children_left", "[", "i", "]", "]", "\n", "", "elif", "is_leaves", "[", "children_left", "[", "i", "]", "]", ":", "\n", "        ", "if", "is_cc", ":", "\n", "          ", "n1", "=", "t_type", "+", "\"(\"", "+", "str", "(", "values", "[", "children_left", "[", "i", "]", "]", ")", "+", "\")\"", "\n", "", "else", ":", "\n", "          ", "n1", "=", "str", "(", "values", "[", "children_left", "[", "i", "]", "]", ")", "\n", "", "v_name", "[", "children_left", "[", "i", "]", "]", "=", "n1", "\n", "", "else", ":", "\n", "        ", "n1", "=", "\"n_\"", "+", "str", "(", "n_vars", ")", "\n", "n_vars", "+=", "1", "\n", "v_name", "[", "children_left", "[", "i", "]", "]", "=", "n1", "\n", "raise", "ValueError", "(", "(", "children_left", "[", "i", "]", ",", "n1", ",", "is_leaves", "[", "children_left", "[", "i", "]", "]", ")", ")", "\n", "\n", "", "if", "v_name", ".", "get", "(", "children_right", "[", "i", "]", ",", "None", ")", "is", "not", "None", ":", "\n", "        ", "n0", "=", "v_name", "[", "children_right", "[", "i", "]", "]", "\n", "", "elif", "is_leaves", "[", "children_right", "[", "i", "]", "]", ":", "\n", "        ", "if", "is_cc", ":", "\n", "          ", "n0", "=", "t_type", "+", "\"(\"", "+", "str", "(", "values", "[", "children_right", "[", "i", "]", "]", ")", "+", "\")\"", "\n", "", "else", ":", "\n", "          ", "n0", "=", "str", "(", "values", "[", "children_right", "[", "i", "]", "]", ")", "\n", "", "v_name", "[", "children_right", "[", "i", "]", "]", "=", "n0", "\n", "", "else", ":", "\n", "        ", "n0", "=", "\"n_\"", "+", "str", "(", "n_vars", ")", "\n", "n_vars", "+=", "1", "\n", "v_name", "[", "children_right", "[", "i", "]", "]", "=", "n0", "\n", "raise", "ValueError", "(", "(", "children_right", "[", "i", "]", ",", "n0", ",", "is_leaves", "[", "children_right", "[", "i", "]", "]", ")", ")", "\n", "\n", "", "if", "v_name", ".", "get", "(", "i", ",", "None", ")", "is", "not", "None", ":", "\n", "        ", "n", "=", "v_name", "[", "i", "]", "\n", "last_var", "=", "v_name", "[", "i", "]", "\n", "", "elif", "bdd", ".", "get", "(", "(", "feature", "[", "i", "]", ",", "threshold", "[", "i", "]", ",", "n1", ",", "n0", ")", ",", "None", ")", "is", "not", "None", ":", "\n", "        ", "n", "=", "bdd", "[", "(", "feature", "[", "i", "]", ",", "threshold", "[", "i", "]", ",", "n1", ",", "n0", ")", "]", "\n", "v_name", "[", "i", "]", "=", "n", "\n", "last_var", "=", "n", "\n", "", "elif", "n1", "==", "n0", ":", "\n", "# store intermediate results so that we can build a dag, not a tree", "\n", "        ", "bdd", "[", "(", "feature", "[", "i", "]", ",", "threshold", "[", "i", "]", ",", "n1", ",", "n0", ")", "]", "=", "n1", "\n", "v_name", "[", "i", "]", "=", "n1", "\n", "last_var", "=", "n1", "\n", "", "else", ":", "\n", "        ", "n", "=", "\"n_\"", "+", "str", "(", "n_vars", ")", "\n", "n_vars", "+=", "1", "\n", "v_name", "[", "i", "]", "=", "n", "\n", "# store intermediate results so that we can build a dag, not a tree", "\n", "bdd", "[", "(", "feature", "[", "i", "]", ",", "threshold", "[", "i", "]", ",", "n1", ",", "n0", ")", "]", "=", "n", "\n", "t", "=", "int", "(", "threshold", "[", "i", "]", ")", "\n", "if", "bits", "[", "feature", "[", "i", "]", "]", "==", "1", ":", "\n", "          ", "if", "t", "==", "0", ":", "\n", "            ", "n1", ",", "n0", "=", "n0", ",", "n1", "\n", "", "code", ".", "append", "(", "\n", "\"  {} {} = (i_{}) ? {} : {}; // x_{} {}\"", ".", "format", "(", "\n", "t_type", ",", "v_name", "[", "i", "]", ",", "feature", "[", "i", "]", ",", "n1", ",", "n0", ",", "i", ",", "\n", "threshold", "[", "i", "]", ")", ")", "\n", "", "else", ":", "\n", "          ", "code", ".", "append", "(", "\n", "\"  {} {} = (i_{} <= {}) ? {} : {}; // x_{} {}\"", ".", "format", "(", "\n", "t_type", ",", "v_name", "[", "i", "]", ",", "feature", "[", "i", "]", ",", "t", ",", "n1", ",", "n0", ",", "i", ",", "\n", "threshold", "[", "i", "]", ")", ")", "\n", "", "last_var", "=", "v_name", "[", "i", "]", "\n", "\n", "", "", "", "if", "use_rom", ":", "\n", "    ", "if", "is_cc", ":", "\n", "      ", "if", "DEBUG", ":", "\n", "        ", "l_type", "=", "\"int\"", "\n", "", "else", ":", "\n", "        ", "l_type", "=", "\"ac_int<{},false>\"", ".", "format", "(", "l_bits", ")", "\n", "\n", "", "code", ".", "append", "(", "\"  {} {}_rom[{}]\"", ".", "format", "(", "l_type", ",", "last_var", ",", "len", "(", "values_rom", ")", ")", "+", "\n", "\" {\"", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "values_rom", ")", ")", ":", "\n", "        ", "code_s", "=", "\"    \"", "+", "entry_to_hex", "(", "rom_l", "[", "i", "]", ",", "max_value", ",", "l_bits", ",", "is_cc", ")", "\n", "if", "i", "<", "len", "(", "values_rom", ")", "-", "1", ":", "\n", "          ", "code_s", "=", "code_s", "+", "\",\"", "\n", "", "code", ".", "append", "(", "code_s", ")", "\n", "", "code", ".", "append", "(", "\"  };\"", ")", "\n", "\n", "", "else", ":", "\n", "      ", "l_type", "=", "\"wire [{}:0]\"", ".", "format", "(", "l_bits", "-", "1", ")", "\n", "code", ".", "append", "(", "\"  function [{}:0] {}_rom;\"", ".", "format", "(", "l_bits", "-", "1", ",", "last_var", ")", ")", "\n", "code", ".", "append", "(", "\"  input [{}:0] address;\"", ".", "format", "(", "t_bits", "-", "1", ")", ")", "\n", "code", ".", "append", "(", "\"  begin\"", ")", "\n", "code", ".", "append", "(", "\"    case (address)\"", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "values_rom", ")", ")", ":", "\n", "        ", "code", ".", "append", "(", "\"    {}'d{}: {}_rom = {};\"", ".", "format", "(", "\n", "l_bits", ",", "i", ",", "last_var", ",", "entry_to_hex", "(", "rom_l", "[", "i", "]", ",", "max_value", ",", "l_bits", ",", "is_cc", ")", ")", ")", "\n", "", "code", ".", "append", "(", "\"    default: {}_rom = 0;\"", ".", "format", "(", "last_var", ")", ")", "\n", "code", ".", "append", "(", "\"    endcase\"", ")", "\n", "code", ".", "append", "(", "\"  end\"", ")", "\n", "code", ".", "append", "(", "\"  endfunction\"", ")", "\n", "\n", "", "code", ".", "append", "(", "\"  {} v_{} = {}_rom[{}];\"", ".", "format", "(", "\n", "l_type", ",", "last_var", ",", "last_var", ",", "last_var", ")", ")", "\n", "\n", "last_var", "=", "\"v_\"", "+", "last_var", "\n", "\n", "", "return", "last_var", ",", "n_vars", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.generate_rf_code.gen_random_forest": [[434, 719], ["int", "range", "numpy.sum", "range", "os.environ.get", "len", "code.append", "o_list.append", "int", "int", "int", "generate_rf_code.gen_random_tree_regressor", "generate_rf_code.gen_random_tree_classifier", "header.append", "int", "header.append", "numpy.ceil", "numpy.ceil", "len", "footer.append", "footer.append", "footer.append", "int", "int", "footer.append", "footer.append", "footer.append", "footer.append", "footer.append", "int", "int", "range", "footer.append", "footer.append", "footer.append", "footer.append", "footer.append", "footer.append", "range", "footer.append", "footer.append", "footer.append", "os.environ.get", "header.append", "numpy.ceil", "header.append", "numpy.log2", "numpy.sum", "header.append", "header.append", "header.append", "numpy.log2", "footer.append", "footer.append", "numpy.ceil", "numpy.ceil", "range", "range", "footer.append", "footer.append", "footer.append", "numpy.ceil", "numpy.ceil", "footer.append", "footer.append", "footer.append", "numpy.log2", "len", "header.append", "header.append", "len", "len", "numpy.log2", "numpy.log2", "debug_print.append", "numpy.log2", "numpy.log2", "code_term.append", "numpy.sum", "len", "numpy.sum", "len", "footer.append", "footer.append", "len", "hex", "str", "range"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.lo.generate_rf_code.gen_random_tree_regressor", "home.repos.pwc.inspect_result.google_qkeras.lo.generate_rf_code.gen_random_tree_classifier", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "gen_random_forest", "(", "\n", "rf", ",", "name", ",", "bits", ",", "is_neg", ",", "o_bits", ",", "o_is_neg", ",", "is_regressor", "=", "True", ",", "\n", "is_top_level", "=", "False", ",", "is_cc", "=", "True", ")", ":", "\n", "  ", "\"\"\"Generates HLS based C++ or SystemVerilog code for random forest.\"\"\"", "\n", "\n", "# TODO(nunescoelho): need to take care of multiple outputs for classifier.", "\n", "# we can get better result if we do not look at the winning classifier,", "\n", "# but sum how many of them appear in each classifier for leaf nodes.", "\n", "\n", "bdd", "=", "{", "}", "\n", "values_rom", "=", "{", "}", "\n", "offset", "=", "0", "\n", "code", "=", "[", "]", "\n", "\n", "max_value", "=", "(", "1", "<<", "int", "(", "os", ".", "environ", ".", "get", "(", "\"MAX_BITS\"", ",", "1", ")", ")", ")", "-", "1", "\n", "decimal_digits", "=", "int", "(", "os", ".", "environ", ".", "get", "(", "\"MAX_BITS\"", ",", "5", ")", ")", "\n", "\n", "assert", "max_value", ">", "0", "\n", "\n", "o_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "rf", ".", "estimators_", ")", ")", ":", "\n", "    ", "tree", "=", "rf", ".", "estimators_", "[", "i", "]", ".", "tree_", "\n", "code", ".", "append", "(", "\"  //----- TREE {}\"", ".", "format", "(", "i", ")", ")", "\n", "if", "is_regressor", ":", "\n", "      ", "last_var", ",", "offset", "=", "gen_random_tree_regressor", "(", "\n", "tree", ",", "code", ",", "bits", ",", "o_bits", ",", "decimal_digits", ",", "o_is_neg", ",", "bdd", ",", "offset", ",", "is_cc", ")", "\n", "", "else", ":", "\n", "      ", "values_rom", "=", "{", "}", "\n", "last_var", ",", "offset", "=", "gen_random_tree_classifier", "(", "\n", "tree", ",", "code", ",", "bits", ",", "bdd", ",", "max_value", ",", "values_rom", ",", "offset", ",", "is_cc", ")", "\n", "\n", "", "o_list", ".", "append", "(", "last_var", ")", "\n", "\n", "", "if", "is_cc", ":", "\n", "    ", "header", "=", "[", "\n", "\"#include <ac_int.h>\"", ",", "\n", "\"#include <ac_fixed.h>\"", ",", "\n", "\"#include <iostream>\"", ",", "\n", "\"using namespace std;\"", ",", "\n", "\"//#define _PRINT_DEBUG_\"", ",", "\n", "\"#define PB(n) cout << #n << \\\":\\\" << n << endl;\"", ",", "\n", "\"#define PS(n) \\\\\"", ",", "\n", "\"  cout << #n << \\\":\\\" << n.to_double() << \\\" \\\"; \\\\\"", ",", "\n", "\"  for(int i=n.width-1; i>=0; i--) cout << n[i]; cout << endl;\"", "\n", "]", "\n", "\n", "if", "DEBUG", ":", "\n", "      ", "header", "=", "header", "+", "[", "\n", "\"static inline float round_even(float x) {\"", ",", "\n", "\"  int x_int = truncf(x);\"", ",", "\n", "\"  float x_dec = x - x_int;\"", ",", "\n", "\"  if ((x_dec == 0.5) && (x_int % 2 == 0)) {\"", ",", "\n", "\"    return truncf(x);\"", ",", "\n", "\"  } else {\"", ",", "\n", "\"    return truncf(x + 0.5);\"", "\n", "\"  }\"", ",", "\n", "\"}\"", "\n", "]", "\n", "if", "is_top_level", ":", "\n", "        ", "header", ".", "append", "(", "\"#pragma hls_design top\"", ")", "\n", "", "header", ".", "append", "(", "\"void {}(int in[{}], int &out)\"", ".", "format", "(", "\n", "name", ",", "np", ".", "sum", "(", "bits", ")", ",", "o_bits", ")", "+", "\" {\"", ")", "\n", "", "else", ":", "\n", "      ", "n_bits", "=", "int", "(", "np", ".", "ceil", "(", "np", ".", "log2", "(", "len", "(", "o_list", ")", ")", ")", ")", "\n", "header", "=", "header", "+", "[", "\n", "\"static inline ac_int<{},{}> round_even(ac_fixed<{},{},{}> x)\"", ".", "format", "(", "\n", "o_bits", ",", "o_is_neg", ",", "\n", "n_bits", "+", "o_bits", "+", "decimal_digits", ",", "n_bits", "+", "o_bits", "+", "o_is_neg", ",", "\n", "o_is_neg", "\n", ")", "+", "\" {\"", ",", "\n", "\"  bool x_int_is_even = x[{}] == 0;\"", ".", "format", "(", "decimal_digits", "+", "n_bits", ")", ",", "\n", "\"  bool x_frac_is_0_5 = x[{}] && (x.slc<{}>(0) == 0);\"", ".", "format", "(", "\n", "n_bits", "+", "decimal_digits", "-", "1", ",", "n_bits", "+", "decimal_digits", "-", "1", ")", ",", "\n", "\"  if (x_frac_is_0_5 && x_int_is_even) {\"", ",", "\n", "\"    return x.slc<{}>({});\"", ".", "format", "(", "o_bits", ",", "n_bits", "+", "decimal_digits", ")", ",", "\n", "\"  } else {\"", ",", "\n", "\"    ac_int<{},{}> r = x.slc<{}>({}) + 1;\"", ".", "format", "(", "\n", "o_bits", "+", "1", ",", "o_is_neg", ",", "\n", "o_bits", "+", "1", ",", "n_bits", "+", "decimal_digits", "-", "1", ")", ",", "\n", "\"    return r.slc<{}>(1);\"", ".", "format", "(", "o_bits", "+", "1", ")", ",", "\n", "#\"    return (x + ac_fixed<{},{},{}>({})).slc<{}>({});\".format(", "\n", "#    n_bits + o_bits + decimal_digits, n_bits + o_bits + o_is_neg,", "\n", "#    o_is_neg, 1<<(n_bits+decimal_digits-1),", "\n", "#    o_bits, n_bits + decimal_digits),", "\n", "#    #o_is_neg, len(o_list)/2, o_bits, n_bits + decimal_digits),", "\n", "\"  }\"", ",", "\n", "\"}\"", "\n", "]", "\n", "if", "is_top_level", ":", "\n", "        ", "header", ".", "append", "(", "\"#pragma hls_design top\"", ")", "\n", "", "header", ".", "append", "(", "\"void {}(ac_int<{},0> in, ac_int<{},{}> &out)\"", ".", "format", "(", "\n", "name", ",", "np", ".", "sum", "(", "bits", ")", ",", "o_bits", ",", "o_is_neg", ")", "+", "\" {\"", ")", "\n", "", "", "else", ":", "\n", "    ", "n_bits", "=", "int", "(", "np", ".", "ceil", "(", "np", ".", "log2", "(", "len", "(", "o_list", ")", ")", ")", ")", "\n", "i_decl", "=", "\"  input [{}:0] in;\"", ".", "format", "(", "np", ".", "sum", "(", "bits", ")", "-", "1", ")", "\n", "o_sign", "=", "\"signed \"", "if", "o_is_neg", "else", "\"\"", "\n", "o_decl", "=", "\"  output \"", "+", "o_sign", "+", "\"[{}:0] out;\"", ".", "format", "(", "o_bits", "-", "1", ")", "\n", "header", "=", "[", "\n", "\"module \"", "+", "name", "+", "\"(in, out);\"", ",", "\n", "i_decl", ",", "\n", "o_decl", ",", "\n", "\"\"", ",", "\n", "\"  function {}[{}:0] round_even;\"", ".", "format", "(", "o_sign", ",", "o_bits", ")", ",", "\n", "\"  input {}[{}:0] x;\"", ".", "format", "(", "o_sign", ",", "n_bits", "+", "o_bits", "+", "decimal_digits", "-", "1", ")", ",", "\n", "\"  reg x_int_is_even;\"", ",", "\n", "\"  reg x_frac_is_0_5;\"", ",", "\n", "\"  reg {}[{}:0] round_sum;\"", ".", "format", "(", "o_sign", ",", "o_bits", "+", "1", ")", ",", "\n", "\"  begin\"", ",", "\n", "\"    x_int_is_even = x[{}] == 0;\"", ".", "format", "(", "decimal_digits", "+", "n_bits", ")", ",", "\n", "\"    x_frac_is_0_5 = x[{}] && (x[{}:0] == 0);\"", ".", "format", "(", "\n", "n_bits", "+", "decimal_digits", "-", "1", ",", "n_bits", "+", "decimal_digits", "-", "2", ")", ",", "\n", "\"    if (x_frac_is_0_5 && x_int_is_even)\"", ",", "\n", "\"      round_even = x[{}:{}];\"", ".", "format", "(", "\n", "n_bits", "+", "decimal_digits", "+", "o_bits", "-", "1", ",", "n_bits", "+", "decimal_digits", ")", ",", "\n", "\"    else\"", ",", "\n", "\"    begin\"", ",", "\n", "\"      round_sum = x[{}:{}] + 1;\"", ".", "format", "(", "\n", "n_bits", "+", "decimal_digits", "+", "o_bits", "-", "1", ",", "n_bits", "+", "decimal_digits", "-", "1", ")", ",", "\n", "\"      round_even = round_sum[{}:1];\"", ".", "format", "(", "o_bits", "+", "1", ")", ",", "\n", "\"    end\"", ",", "\n", "#\"      round_even = (x + {})[{}:{}];\".format(", "\n", "#    #(1 << (n_bits + decimal_digits - 1)),", "\n", "#    n_bits + decimal_digits + o_bits - 1, n_bits + decimal_digits),", "\n", "\"  end\"", ",", "\n", "\"  endfunction\"", "\n", "]", "\n", "\n", "\n", "", "all_bits", "=", "np", ".", "sum", "(", "bits", ")", "\n", "sum_i", "=", "0", "\n", "for", "i", "in", "range", "(", "bits", ".", "shape", "[", "0", "]", ")", ":", "\n", "    ", "if", "is_cc", ":", "\n", "      ", "if", "bits", "[", "i", "]", ">", "1", ":", "\n", "        ", "if", "DEBUG", ":", "\n", "          ", "header", ".", "append", "(", "\"  int i_{} = in[{}];\"", ".", "format", "(", "i", ",", "i", ")", ")", "\n", "", "else", ":", "\n", "          ", "header", ".", "append", "(", "\"  ac_int<{},{}> i_{} = in.slc<{}>({});\"", ".", "format", "(", "\n", "bits", "[", "i", "]", ",", "is_neg", "[", "i", "]", ",", "i", ",", "bits", "[", "i", "]", ",", "sum_i", ")", ")", "\n", "", "", "else", ":", "\n", "        ", "header", ".", "append", "(", "\"  bool i_{} = in[{}];\"", ".", "format", "(", "i", ",", "sum_i", ")", ")", "\n", "", "", "else", ":", "\n", "      ", "if", "bits", "[", "i", "]", "==", "1", ":", "\n", "        ", "header", ".", "append", "(", "\"  wire i_{} = in[{}];\"", ".", "format", "(", "i", ",", "all_bits", "-", "sum_i", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "        ", "header", ".", "append", "(", "\"  wire i_{}[{}:0] = in[{}:{}];\"", ".", "format", "(", "\n", "i", ",", "bits", "[", "i", "]", ",", "sum_i", "+", "bits", "[", "i", "]", "-", "1", ",", "all_bits", "-", "sum_i", "-", "1", ")", ")", "\n", "", "", "sum_i", "+=", "bits", "[", "i", "]", "\n", "\n", "", "footer", "=", "[", "]", "\n", "\n", "if", "is_regressor", ":", "\n", "    ", "n_bits", "=", "int", "(", "np", ".", "ceil", "(", "np", ".", "log2", "(", "len", "(", "o_list", ")", ")", ")", ")", "\n", "assert", "1", "<<", "n_bits", "==", "len", "(", "o_list", ")", "\n", "\n", "if", "is_cc", ":", "\n", "\n", "      ", "if", "DEBUG", ":", "\n", "        ", "tmp_type", "=", "\"float\"", "\n", "", "else", ":", "\n", "        ", "tmp_type", "=", "\"ac_fixed<{},{},{}>\"", ".", "format", "(", "\n", "n_bits", "+", "o_bits", "+", "decimal_digits", ",", "n_bits", "+", "o_bits", "+", "o_is_neg", ",", "\n", "o_is_neg", ")", "\n", "", "avg_o", "=", "\"  {} o_tmp = {};\"", ".", "format", "(", "tmp_type", ",", "\" + \"", ".", "join", "(", "o_list", ")", ")", "\n", "\n", "# rnd_o = \"  o_tmp += {}({});\".format(tmp_type, len(o_list)/2)", "\n", "\n", "if", "DEBUG", ":", "\n", "        ", "out", "=", "\"  out = round_even(o_tmp / {});\"", ".", "format", "(", "len", "(", "o_list", ")", ")", "\n", "", "else", ":", "\n", "        ", "out", "=", "\"  out = round_even(o_tmp);\"", "\n", "\n", "", "footer", ".", "append", "(", "\"  #ifdef _PRINT_DEBUG_\"", ")", "\n", "for", "o_name", "in", "o_list", ":", "\n", "        ", "footer", ".", "append", "(", "\"  PS({});\"", ".", "format", "(", "o_name", ")", ")", "\n", "", "footer", ".", "append", "(", "\"  #endif\"", ")", "\n", "closing", "=", "\"}\"", "\n", "\n", "", "else", ":", "\n", "      ", "tmp_sign", "=", "\"signed \"", "if", "o_is_neg", "else", "\"\"", "\n", "avg_o", "=", "\"  wire \"", "+", "tmp_sign", "+", "\"[{}:0] o_tmp = {};\"", ".", "format", "(", "\n", "n_bits", "+", "o_bits", "+", "decimal_digits", "-", "1", ",", "\" + \"", ".", "join", "(", "o_list", ")", ")", "\n", "\n", "for", "n", "in", "o_list", ":", "\n", "        ", "footer", ".", "append", "(", "\"  // always @({}) $display(\\\"{} = %f (%b)\\\", {} / 32.0, {});\"", ".", "format", "(", "n", ",", "n", ",", "n", ",", "n", ")", ")", "\n", "", "footer", ".", "append", "(", "\"  // always @(o_tmp) $display(\\\"o_tmp = %b\\\", o_tmp);\"", ")", "\n", "\n", "out", "=", "\"  assign out = round_even(o_tmp);\"", "\n", "\n", "closing", "=", "\"endmodule\"", "\n", "\n", "", "footer", "=", "footer", "+", "[", "avg_o", ",", "out", ",", "closing", "]", "\n", "\n", "", "else", ":", "\n", "\n", "    ", "assert", "not", "o_is_neg", "\n", "\n", "footer", "=", "[", "]", "\n", "\n", "o_suffix", "=", "\"\"", "\n", "if", "DEBUG", ":", "\n", "      ", "o_type", "=", "\"int\"", "\n", "", "elif", "is_cc", ":", "\n", "      ", "o_type", "=", "\"ac_int<{},{}>\"", ".", "format", "(", "o_bits", ",", "o_is_neg", ")", "\n", "", "else", ":", "\n", "      ", "o_sign", "=", "\" signed\"", "if", "o_is_neg", "else", "\"\"", "\n", "o_suffix", "=", "\"[{}:0]\"", ".", "format", "(", "o_bits", ")", "\n", "o_type", "=", "\"wire\"", "+", "o_sign", "+", "\" \"", "+", "o_suffix", "\n", "\n", "", "if", "is_cc", ":", "\n", "      ", "n_classes", "=", "1", "<<", "o_bits", "\n", "max_bits", "=", "int", "(", "np", ".", "ceil", "(", "np", ".", "log2", "(", "max_value", "+", "1", ")", ")", ")", "\n", "log2_o_list", "=", "int", "(", "np", ".", "ceil", "(", "np", ".", "log2", "(", "len", "(", "o_list", ")", ")", ")", ")", "\n", "if", "DEBUG", ":", "\n", "        ", "log2_o_type", "=", "\"int\"", "\n", "", "else", ":", "\n", "        ", "log2_o_type", "=", "\"ac_int<{},false>\"", ".", "format", "(", "log2_o_list", "+", "max_bits", ")", "\n", "", "sum_v", "=", "(", "\n", "\"  {} sum[{}] = \"", ".", "format", "(", "\n", "log2_o_type", ",", "1", "<<", "o_bits", ")", "+", "\"{\"", "+", "\n", "\",\"", ".", "join", "(", "\"0\"", "*", "(", "1", "<<", "o_bits", ")", ")", "+", "\"};\"", "\n", ")", "\n", "footer", "=", "[", "sum_v", "]", "\n", "for", "o_name", "in", "o_list", ":", "\n", "        ", "for", "i", "in", "range", "(", "n_classes", ")", ":", "\n", "          ", "if", "DEBUG", ":", "\n", "            ", "footer", ".", "append", "(", "\"  sum[{}] += ({} >> {}) & {};\"", ".", "format", "(", "\n", "i", ",", "o_name", ",", "(", "n_classes", "-", "i", ")", "*", "max_bits", "-", "max_bits", ",", "\n", "hex", "(", "(", "1", "<<", "max_bits", ")", "-", "1", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "footer", ".", "append", "(", "\"  sum[{}] += {}.slc<{}>({});\"", ".", "format", "(", "\n", "i", ",", "o_name", ",", "max_bits", ",", "(", "n_classes", "-", "i", ")", "*", "max_bits", "-", "max_bits", ")", ")", "\n", "", "", "debug_print", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n_classes", ")", ":", "\n", "          ", "debug_print", ".", "append", "(", "\"{}.slc<{}>({}).to_string(AC_DEC)\"", ".", "format", "(", "\n", "o_name", ",", "max_bits", ",", "(", "n_classes", "-", "i", ")", "*", "max_bits", "-", "max_bits", ")", ")", "\n", "", "footer_s", "=", "(", "\n", "\"  cout << \\\"{} \\\" <<\"", ".", "format", "(", "o_name", ")", "+", "\n", "\" << \\\" \\\" << \"", ".", "join", "(", "debug_print", ")", "+", "\" << endl;\"", "\n", ")", "\n", "footer", ".", "append", "(", "\"  #ifdef _PRINT_DEBUG_\"", ")", "\n", "footer", ".", "append", "(", "footer_s", ")", "\n", "footer", ".", "append", "(", "\"  #endif\"", ")", "\n", "", "footer", ".", "append", "(", "\"  {} max_tmp = sum[0];\"", ".", "format", "(", "log2_o_type", ")", ")", "\n", "footer", ".", "append", "(", "\"  {} max_id = 0;\"", ".", "format", "(", "o_type", ")", ")", "\n", "footer", ".", "append", "(", "\"  for(int i=1; i<{}; i++)\"", ".", "format", "(", "1", "<<", "o_bits", ")", ")", "\n", "footer", ".", "append", "(", "\n", "\"    if (sum[i] >= max_tmp) { max_tmp = sum[i]; max_id = i; }\"", ")", "\n", "out", "=", "\"  out = max_id;\"", "\n", "\n", "footer", ".", "append", "(", "out", ")", "\n", "footer", "+=", "[", "\"}\"", "]", "\n", "", "else", ":", "\n", "      ", "n_classes", "=", "1", "<<", "o_bits", "\n", "max_bits", "=", "int", "(", "np", ".", "ceil", "(", "np", ".", "log2", "(", "max_value", "+", "1", ")", ")", ")", "\n", "log2_o_list", "=", "int", "(", "np", ".", "ceil", "(", "np", ".", "log2", "(", "len", "(", "o_list", ")", ")", ")", ")", "\n", "log2_o_type", "=", "\"wire [{}:0]\"", ".", "format", "(", "log2_o_list", "+", "max_bits", ")", "\n", "footer", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n_classes", ")", ":", "\n", "        ", "code_s", "=", "\"  {} sum_{} = \"", ".", "format", "(", "log2_o_type", ",", "i", ")", "\n", "code_term", "=", "[", "]", "\n", "for", "o_name", "in", "o_list", ":", "\n", "          ", "code_term", ".", "append", "(", "\"{}[{}:{}]\"", ".", "format", "(", "\n", "o_name", ",", "(", "n_classes", "-", "i", ")", "*", "max_bits", ",", "(", "n_classes", "-", "i", ")", "*", "max_bits", "-", "max_bits", ")", ")", "\n", "", "code_s", "+=", "\" + \"", ".", "join", "(", "code_term", ")", "+", "\";\"", "\n", "footer", ".", "append", "(", "code_s", ")", "\n", "footer", ".", "append", "(", "\"  // always @(sum_{}) $display(\\\"sum_{} = %d\\\", sum_{});\"", ".", "format", "(", "\n", "i", ",", "i", ",", "i", ")", ")", "\n", "", "footer", ".", "append", "(", "\"  reg [{}:0] max_tmp;\"", ".", "format", "(", "\n", "log2_o_list", "+", "max_bits", "-", "1", ")", ")", "\n", "footer", ".", "append", "(", "\"  reg [{}:0] max_id;\"", ".", "format", "(", "o_bits", "-", "1", ")", ")", "\n", "footer", ".", "append", "(", "\"  integer i;\"", ")", "\n", "footer", ".", "append", "(", "\"  always @(\"", "+", "\n", "\" or \"", ".", "join", "(", "\n", "[", "\"sum_\"", "+", "str", "(", "i", ")", "for", "i", "in", "range", "(", "n_classes", ")", "]", ")", "+", "\")\"", ")", "\n", "footer", ".", "append", "(", "\"  begin\"", ")", "\n", "footer", ".", "append", "(", "\"    max_tmp = sum_0; max_id = 0;\"", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "n_classes", ")", ":", "\n", "        ", "footer", ".", "append", "(", "\n", "\"    if (sum_{} >= max_tmp) begin max_tmp = sum_{}; max_id = {}; end\"", ".", "format", "(", "\n", "i", ",", "i", ",", "i", ")", ")", "\n", "", "footer", ".", "append", "(", "\"  end\"", ")", "\n", "footer", ".", "append", "(", "\"  assign out = max_id;\"", ")", "\n", "footer", ".", "append", "(", "\"endmodule\"", ")", "\n", "\n", "", "", "return", "header", "+", "code", "+", "footer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.generate_rf_code.gen_testbench_sv": [[721, 768], ["code.append", "int", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "numpy.ceil", "open", "range", "open", "range", "open", "range", "numpy.log2", "len", "f.write", "len", "f.write", "len", "f.write", "hex", "hex", "int", "int", "str", "int"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "gen_testbench_sv", "(", "rf", ",", "name", ",", "bits", ",", "is_neg", ",", "o_bits", ",", "o_is_neg", ",", "x", ",", "y", ",", "p", ",", "code", ")", ":", "\n", "  ", "code", ".", "append", "(", "\"module tb;\"", ")", "\n", "x_0", ",", "x_1", "=", "x", ".", "shape", "\n", "x_0_log2", "=", "int", "(", "np", ".", "ceil", "(", "np", ".", "log2", "(", "x_0", ")", ")", ")", "\n", "code", ".", "append", "(", "\"reg [{}:0] x_rom[{}:0];\"", ".", "format", "(", "x_1", "-", "1", ",", "x_0", "-", "1", ")", ")", "\n", "code", ".", "append", "(", "\"initial $readmemb(\\\"x.rom\\\", x_rom, 0, {});\"", ".", "format", "(", "x_0", "-", "1", ")", ")", "\n", "with", "open", "(", "\"x.rom\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "    ", "for", "i", "in", "range", "(", "len", "(", "x", ")", ")", ":", "\n", "      ", "f", ".", "write", "(", "\"\"", ".", "join", "(", "[", "str", "(", "int", "(", "v", ")", ")", "for", "v", "in", "x", "[", "i", "]", "]", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "o_sign", "=", "\"signed \"", "if", "o_is_neg", "else", "\"\"", "\n", "o_type", "=", "o_sign", "+", "\"[{}:0]\"", ".", "format", "(", "o_bits", "-", "1", ")", "\n", "code", ".", "append", "(", "\"reg {} y_rom[{}:0];\"", ".", "format", "(", "o_type", ",", "x_0", "-", "1", ")", ")", "\n", "code", ".", "append", "(", "\"reg {} p_rom[{}:0];\"", ".", "format", "(", "o_type", ",", "x_0", "-", "1", ")", ")", "\n", "with", "open", "(", "\"y.rom\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "    ", "for", "i", "in", "range", "(", "len", "(", "y", ")", ")", ":", "\n", "      ", "f", ".", "write", "(", "hex", "(", "int", "(", "y", "[", "i", "]", ")", ")", "+", "\"\\n\"", ")", "\n", "", "", "with", "open", "(", "\"p.rom\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "    ", "for", "i", "in", "range", "(", "len", "(", "y", ")", ")", ":", "\n", "      ", "f", ".", "write", "(", "hex", "(", "int", "(", "p", "[", "i", "]", ")", ")", "+", "\"\\n\"", ")", "\n", "", "", "code", ".", "append", "(", "\"initial $readmemh(\\\"y.rom\\\", y_rom, 0, {});\"", ".", "format", "(", "x_0", "-", "1", ")", ")", "\n", "code", ".", "append", "(", "\"initial $readmemh(\\\"p.rom\\\", p_rom, 0, {});\"", ".", "format", "(", "x_0", "-", "1", ")", ")", "\n", "code", ".", "append", "(", "\"integer i;\"", ")", "\n", "code", ".", "append", "(", "\"integer cnt;\"", ")", "\n", "code", ".", "append", "(", "\"reg [{}:0] in;\"", ".", "format", "(", "x_1", "-", "1", ")", ")", "\n", "code", ".", "append", "(", "\"wire {} out;\"", ".", "format", "(", "o_type", ")", ")", "\n", "code", ".", "append", "(", "\"{} {}(in, out);\"", ".", "format", "(", "name", ",", "name", ")", ")", "\n", "code", ".", "append", "(", "\"initial\"", ")", "\n", "code", ".", "append", "(", "\"begin\"", ")", "\n", "code", ".", "append", "(", "\"  cnt = 0;\"", ")", "\n", "code", ".", "append", "(", "\"  in = x_rom[i];\"", ")", "\n", "code", ".", "append", "(", "\"  for (i=0; i<{}; i=i+1)\"", ".", "format", "(", "x_0", ")", ")", "\n", "code", ".", "append", "(", "\"  begin\"", ")", "\n", "code", ".", "append", "(", "\"    in = x_rom[i];\"", ")", "\n", "code", ".", "append", "(", "\"    #1000;\"", ")", "\n", "code", ".", "append", "(", "\"    if (p_rom[i] != out && y_rom[i] != out)\"", ")", "\n", "code", ".", "append", "(", "\"    begin\"", ")", "\n", "code", ".", "append", "(", "\"      $display(\\\"%d: %b y=%d p=%d -> %d\\\", i, x_rom[i], y_rom[i], p_rom[i], out);\"", ")", "\n", "code", ".", "append", "(", "\"    end\"", ")", "\n", "code", ".", "append", "(", "\"    else\"", ")", "\n", "code", ".", "append", "(", "\"    begin\"", ")", "\n", "code", ".", "append", "(", "\"      cnt = cnt + 1;\"", ")", "\n", "code", ".", "append", "(", "\"    end\"", ")", "\n", "code", ".", "append", "(", "\"  end\"", ")", "\n", "code", ".", "append", "(", "\"  $display(\\\"acc = %f\\\", 100.0 * cnt / {});\"", ".", "format", "(", "x_0", ")", ")", "\n", "code", ".", "append", "(", "\"end\"", ")", "\n", "code", ".", "append", "(", "\"endmodule\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.generate_rf_code.gen_testbench_cc": [[770, 822], ["code.append", "range", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "len", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "code.append", "len", "str", "str", "str", "int", "int", "int"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "gen_testbench_cc", "(", "rf", ",", "name", ",", "bits", ",", "is_neg", ",", "o_bits", ",", "o_is_neg", ",", "x", ",", "y", ",", "p", ",", "code", ")", ":", "\n", "  ", "code", ".", "append", "(", "\"int x[{}][{}] = \"", ".", "format", "(", "*", "x", ".", "shape", ")", "+", "\"{\"", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "x", ")", ")", ":", "\n", "    ", "code_s", "=", "\"  {\"", "+", "\",\"", ".", "join", "(", "[", "str", "(", "int", "(", "v", ")", ")", "for", "v", "in", "x", "[", "i", "]", "]", ")", "+", "\"}\"", "\n", "if", "i", "<", "len", "(", "x", ")", "-", "1", ":", "\n", "      ", "code_s", "=", "code_s", "+", "\",\"", "\n", "", "code", ".", "append", "(", "code_s", ")", "\n", "", "code", ".", "append", "(", "\"};\"", ")", "\n", "code_s", "=", "(", "\n", "\"int y[{}] = \"", ".", "format", "(", "y", ".", "shape", "[", "0", "]", ")", "+", "\"{\"", "+", "\n", "\",\"", ".", "join", "(", "[", "str", "(", "int", "(", "v", ")", ")", "for", "v", "in", "y", "]", ")", "+", "\"};\"", "\n", ")", "\n", "code", ".", "append", "(", "code_s", ")", "\n", "code_s", "=", "(", "\n", "\"int p[{}] = \"", ".", "format", "(", "p", ".", "shape", "[", "0", "]", ")", "+", "\"{\"", "+", "\n", "\",\"", ".", "join", "(", "[", "str", "(", "int", "(", "v", ")", ")", "for", "v", "in", "p", "]", ")", "+", "\"};\"", "\n", ")", "\n", "code", ".", "append", "(", "code_s", ")", "\n", "\n", "code", ".", "append", "(", "\"int main()\"", ")", "\n", "code", ".", "append", "(", "\"{\"", ")", "\n", "code", ".", "append", "(", "\"  double acc = 0.0;\"", ")", "\n", "if", "DEBUG", ":", "\n", "    ", "code", ".", "append", "(", "\"  int in[{}];\"", ".", "format", "(", "x", ".", "shape", "[", "1", "]", ")", ")", "\n", "code", ".", "append", "(", "\"  int out;\"", ")", "\n", "", "else", ":", "\n", "    ", "code", ".", "append", "(", "\"  ac_int<{},0> in;\"", ".", "format", "(", "x", ".", "shape", "[", "1", "]", ")", ")", "\n", "code", ".", "append", "(", "\"  ac_int<{},{}> out;\"", ".", "format", "(", "o_bits", ",", "o_is_neg", ")", ")", "\n", "\n", "", "code", ".", "append", "(", "\"  for (int i=0; i<{}; i++)\"", ".", "format", "(", "x", ".", "shape", "[", "0", "]", ")", "+", "\"{\"", ")", "\n", "code", ".", "append", "(", "\"    for (int j=0; j<{}; j++) in[j] = x[i][j];\"", ".", "format", "(", "\n", "x", ".", "shape", "[", "1", "]", ")", ")", "\n", "code", ".", "append", "(", "\"    {}(in, out);\"", ".", "format", "(", "name", ")", ")", "\n", "code", ".", "append", "(", "\"    if (p[i] != out && y[i] != out) {\"", ")", "\n", "code", ".", "append", "(", "\"      cout << i << \\\": \\\";\"", ")", "\n", "code", ".", "append", "(", "\"      for (int j=0; j<{}; j++) cout << in[j];\"", ".", "format", "(", "\n", "x", ".", "shape", "[", "1", "]", ")", ")", "\n", "if", "DEBUG", ":", "\n", "    ", "code", ".", "append", "(", "\"      cout << \\\" y=\\\" << y[i] << \\\" p=\\\" << p[i] << \\\" \\\" << out << endl;\"", ")", "\n", "code", ".", "append", "(", "\"    }\"", ")", "\n", "code", ".", "append", "(", "\"    acc += (y[i] == out);\"", ")", "\n", "", "else", ":", "\n", "    ", "code", ".", "append", "(", "\"      cout << \\\" y=\\\" << y[i] << \\\" p=\\\" << p[i] << \\\" \\\" << out.to_int() << endl;\"", ")", "\n", "code", ".", "append", "(", "\"      #ifdef _PRINT_DEBUG_\"", ")", "\n", "code", ".", "append", "(", "\"        exit(1);\"", ")", "\n", "code", ".", "append", "(", "\"      #endif\"", ")", "\n", "code", ".", "append", "(", "\"    }\"", ")", "\n", "code", ".", "append", "(", "\"    acc += (y[i] == out.to_int());\"", ")", "\n", "", "code", ".", "append", "(", "\"  }\"", ")", "\n", "code", ".", "append", "(", "\"  cout << \\\"acc = \\\" << 100.0 * acc  / {} << endl;\"", ".", "format", "(", "\n", "x", ".", "shape", "[", "0", "]", ")", ")", "\n", "code", ".", "append", "(", "\"}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.receptive.print_rf": [[25, 30], ["print", "print"], "function", ["None"], ["def", "print_rf", "(", "layer_name", ",", "x", ")", ":", "\n", "  ", "print", "(", "\"Layer {}:\"", ".", "format", "(", "layer_name", ")", ")", "\n", "print", "(", "\n", "\"\\theight/width: {}\\n\\tstride: {}\\n\\teq_kernel_size: {}\\n\\tstart: {}\\n\"", ".", "format", "(", "\n", "*", "x", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.receptive.rf_computation_for_layer": [[33, 53], ["math.ceil", "math.floor", "int", "math.floor", "int"], "function", ["None"], ["", "def", "rf_computation_for_layer", "(", "layer", ",", "layer_in", ")", ":", "\n", "  ", "k", ",", "s", ",", "p", "=", "layer", "\n", "n_in", ",", "j_in", ",", "r_in", ",", "start_in", "=", "layer_in", "\n", "\n", "n_out", "=", "int", "(", "math", ".", "floor", "(", "(", "n_in", "+", "2", "*", "p", "-", "k", ")", "/", "s", ")", ")", "+", "1", "\n", "\n", "if", "s", "==", "1", "and", "p", "==", "1", ":", "\n", "    ", "n_out", "=", "n_in", "\n", "\n", "", "actual_p", "=", "(", "n_out", "-", "1", ")", "*", "s", "-", "n_in", "+", "k", "\n", "p_r", "=", "math", ".", "ceil", "(", "actual_p", "/", "2", ")", "\n", "p_l", "=", "math", ".", "floor", "(", "actual_p", "/", "2", ")", "\n", "\n", "j_out", "=", "j_in", "*", "s", "\n", "\n", "r_out", "=", "r_in", "+", "(", "k", "-", "1", ")", "*", "j_in", "\n", "\n", "start_out", "=", "start_in", "+", "(", "int", "(", "(", "k", "-", "1", ")", "/", "2", ")", "-", "p_l", ")", "*", "j_in", "\n", "\n", "return", "n_out", ",", "j_out", ",", "r_out", ",", "start_out", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.receptive.model_to_receptive_field": [[55, 112], ["model.get_layer", "model.get_layer", "model.layers.index", "model.layers.index", "range", "zip", "hasattr", "hasattr", "hasattr", "layers_h.append", "layers_w.append", "receptive.rf_computation_for_layer", "receptive.rf_computation_for_layer", "isinstance", "isinstance", "isinstance", "utils.get_padding_value", "utils.get_padding_value"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.lo.receptive.rf_computation_for_layer", "home.repos.pwc.inspect_result.google_qkeras.lo.receptive.rf_computation_for_layer", "home.repos.pwc.inspect_result.google_qkeras.lo.utils.get_padding_value", "home.repos.pwc.inspect_result.google_qkeras.lo.utils.get_padding_value"], ["", "def", "model_to_receptive_field", "(", "model", ",", "i_name", ",", "o_name", ")", ":", "\n", "  ", "layers_h", "=", "[", "]", "\n", "layers_w", "=", "[", "]", "\n", "\n", "i_layer", "=", "model", ".", "get_layer", "(", "i_name", ")", "\n", "o_layer", "=", "model", ".", "get_layer", "(", "o_name", ")", "\n", "\n", "# right now this only works for sequential layers", "\n", "\n", "i_index", "=", "model", ".", "layers", ".", "index", "(", "i_layer", ")", "\n", "o_index", "=", "model", ".", "layers", ".", "index", "(", "o_layer", ")", "\n", "\n", "for", "i", "in", "range", "(", "i_index", ",", "o_index", "+", "1", ")", ":", "\n", "    ", "k_h", ",", "k_w", "=", "(", "1", ",", "1", ")", "\n", "s_h", ",", "s_w", "=", "(", "1", ",", "1", ")", "\n", "p_h", ",", "p_w", "=", "(", "0", ",", "0", ")", "\n", "\n", "if", "hasattr", "(", "model", ".", "layers", "[", "i", "]", ",", "\"kernel_size\"", ")", ":", "\n", "      ", "kernel", "=", "model", ".", "layers", "[", "i", "]", ".", "kernel_size", "\n", "\n", "if", "isinstance", "(", "kernel", ",", "int", ")", ":", "\n", "        ", "kernel", "=", "[", "kernel", ",", "kernel", "]", "\n", "\n", "", "k_h", ",", "k_w", "=", "kernel", "[", "0", "]", ",", "kernel", "[", "1", "]", "\n", "\n", "", "if", "hasattr", "(", "model", ".", "layers", "[", "i", "]", ",", "\"strides\"", ")", ":", "\n", "      ", "strides", "=", "model", ".", "layers", "[", "i", "]", ".", "strides", "\n", "\n", "if", "isinstance", "(", "strides", ",", "int", ")", ":", "\n", "        ", "strides", "=", "[", "strides", ",", "strides", "]", "\n", "\n", "", "s_h", ",", "s_w", "=", "strides", "[", "0", "]", ",", "strides", "[", "1", "]", "\n", "\n", "", "if", "hasattr", "(", "model", ".", "layers", "[", "i", "]", ",", "\"padding\"", ")", ":", "\n", "      ", "padding", "=", "model", ".", "layers", "[", "i", "]", ".", "padding", "\n", "\n", "if", "isinstance", "(", "padding", ",", "str", ")", ":", "\n", "        ", "padding", "=", "[", "padding", ",", "padding", "]", "\n", "\n", "", "p_h", "=", "get_padding_value", "(", "padding", "[", "0", "]", ",", "k_h", ")", "\n", "p_w", "=", "get_padding_value", "(", "padding", "[", "1", "]", ",", "k_w", ")", "\n", "\n", "", "layers_h", ".", "append", "(", "(", "k_h", ",", "s_h", ",", "p_h", ")", ")", "\n", "layers_w", ".", "append", "(", "(", "k_w", ",", "s_w", ",", "p_w", ")", ")", "\n", "\n", "", "x_h", "=", "(", "i_layer", ".", "input", ".", "shape", "[", "1", "]", ",", "1", ",", "1", ",", "0.5", ")", "\n", "x_w", "=", "(", "i_layer", ".", "input", ".", "shape", "[", "2", "]", ",", "1", ",", "1", ",", "0.5", ")", "\n", "\n", "for", "l_h", ",", "l_w", "in", "zip", "(", "layers_h", ",", "layers_w", ")", ":", "\n", "    ", "x_h", "=", "rf_computation_for_layer", "(", "l_h", ",", "x_h", ")", "\n", "x_w", "=", "rf_computation_for_layer", "(", "l_w", ",", "x_w", ")", "\n", "\n", "", "strides", "=", "(", "x_h", "[", "1", "]", ",", "x_w", "[", "1", "]", ")", "\n", "kernel", "=", "(", "x_h", "[", "2", "]", ",", "x_w", "[", "2", "]", ")", "\n", "padding", "=", "(", "\"valid\"", ",", "\"valid\"", ")", "\n", "\n", "return", "(", "strides", ",", "kernel", ",", "padding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.optimizer.file_compress": [[43, 60], ["compress.Compressor", "open", "open", "compress.Compressor.", "open.close", "print", "line.strip.strip", "compress.Compressor.add_entry", "open.write", "os.path.basename"], "function", ["home.repos.pwc.inspect_result.google_qkeras.lo.compress.Compressor.add_entry"], ["def", "file_compress", "(", "fin", ",", "fout", ")", ":", "\n", "  ", "\"\"\"Compresses table using hash set.\"\"\"", "\n", "c", "=", "Compressor", "(", ")", "\n", "n_lines", "=", "0", "\n", "for", "line", "in", "open", "(", "fin", ")", ":", "\n", "    ", "n_lines", "+=", "1", "\n", "line", "=", "line", ".", "strip", "(", ")", "\n", "c", ".", "add_entry", "(", "line", ")", "\n", "\n", "", "f", "=", "open", "(", "fout", ",", "\"w\"", ")", "\n", "n_compressed", "=", "0", "\n", "for", "line", "in", "c", "(", ")", ":", "\n", "    ", "n_compressed", "+=", "1", "\n", "f", ".", "write", "(", "line", "+", "\"\\n\"", ")", "\n", "", "f", ".", "close", "(", ")", "\n", "print", "(", "\"... random forrest for {} reduced from {} to {} entries\"", ".", "format", "(", "\n", "os", ".", "path", ".", "basename", "(", "fin", ")", ",", "n_lines", ",", "n_compressed", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.optimizer.mp_rf_optimizer_func": [[62, 192], ["fn.split", "path_split[].split", "table.load", "print", "numpy.ceil().astype", "numpy.ceil().astype", "generate_rf_code.gen_random_forest", "open().write", "print", "print", "print", "print", "pickle.dump", "float", "int", "sklearn.ensemble.RandomForestRegressor", "sklearn.ensemble.RandomForestClassifier", "int", "numpy.random.seed", "numpy.random.choice", "warnings.catch_warnings", "warnings.simplefilter", "sklearn.ensemble.RandomForestClassifier.fit", "numpy.round", "numpy.max", "numpy.min", "numpy.sum", "numpy.sum", "numpy.max", "y_test[].astype", "numpy.max", "p[].astype", "open", "numpy.ceil", "numpy.ceil", "open", "sklearn.ensemble.RandomForestClassifier.predict", "numpy.abs", "str", "numpy.log2", "numpy.amin", "numpy.log2", "numpy.amin", "numpy.abs", "numpy.abs", "os.path.basename", "numpy.amax", "numpy.amin", "numpy.amax", "numpy.amin"], "function", ["home.repos.pwc.inspect_result.google_qkeras.table.utils.load", "home.repos.pwc.inspect_result.google_qkeras.lo.generate_rf_code.gen_random_forest", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict"], ["", "def", "mp_rf_optimizer_func", "(", "fn_tuple", ")", ":", "\n", "  ", "\"\"\"Executes in parallel creation of random forrest creation.\"\"\"", "\n", "\n", "fn", ",", "flags", ",", "file_suffix", "=", "fn_tuple", "\n", "\n", "n_trees", "=", "flags", "[", "\"n_trees\"", "]", "\n", "is_regressor", "=", "flags", "[", "\"is_regressor\"", "]", "\n", "sample_size", "=", "flags", "[", "\"sample_size\"", "]", "\n", "n_features", "=", "flags", "[", "\"n_features\"", "]", "\n", "max_depth", "=", "flags", "[", "\"max_depth\"", "]", "\n", "\n", "if", "not", "file_suffix", ":", "\n", "    ", "file_suffix", "=", "\"none\"", "\n", "\n", "", "path_split", "=", "fn", ".", "split", "(", "\"/\"", ")", "\n", "path", "=", "\"/\"", ".", "join", "(", "path_split", "[", ":", "-", "1", "]", ")", "+", "\"/\"", "\n", "fn_split", "=", "path_split", "[", "-", "1", "]", ".", "split", "(", "\".\"", ")", "\n", "# o_file = path + \".\".join(fn_split[0:-2] + [fn_split[-1]])", "\n", "cv_file", "=", "path", "+", "\".\"", ".", "join", "(", "fn_split", "[", "0", ":", "-", "2", "]", "+", "[", "file_suffix", "]", ")", "\n", "rfb_file", "=", "path", "+", "\".\"", ".", "join", "(", "fn_split", "[", "0", ":", "-", "2", "]", "+", "[", "\"rb\"", ",", "\"bin\"", "]", ")", "\n", "\n", "# let's compress the table first to make the job easier for random forest.", "\n", "# compression can usually achieve a ratio of 50x or more.", "\n", "\n", "# compress(fn, o_file)", "\n", "train", "=", "load", "(", "fn", ")", "\n", "\n", "n_features", "=", "\"auto\"", "if", "not", "n_features", "else", "float", "(", "n_features", ")", "\n", "\n", "# min_size = 1", "\n", "\n", "if", "max_depth", ":", "\n", "    ", "max_depth", "=", "int", "(", "max_depth", ")", "\n", "\n", "", "print", "(", "\"... creating random forrest for \"", "+", "os", ".", "path", ".", "basename", "(", "fn", ")", "+", "\" with \"", "+", "\n", "str", "(", "sample_size", ")", "+", "\" samples\"", ")", "\n", "\n", "if", "is_regressor", ":", "\n", "    ", "rf", "=", "RandomForestRegressor", "(", "\n", "n_estimators", "=", "n_trees", ",", "\n", "max_depth", "=", "max_depth", ",", "\n", "# min_samples_split=2,", "\n", "# min_samples_leaf=min_size,", "\n", "max_features", "=", "n_features", ",", "\n", "# max_leaf_nodes=100,", "\n", "# oob_score=True,", "\n", "# warm_start=True,", "\n", "bootstrap", "=", "True", ",", "\n", "random_state", "=", "42", ",", "\n", "n_jobs", "=", "1", ")", "\n", "", "else", ":", "\n", "    ", "rf", "=", "RandomForestClassifier", "(", "\n", "n_estimators", "=", "n_trees", ",", "\n", "max_depth", "=", "max_depth", ",", "\n", "# min_samples_split=2,", "\n", "# min_samples_leaf=min_size,", "\n", "max_features", "=", "n_features", ",", "\n", "# max_leaf_nodes=100,", "\n", "# oob_score=True,", "\n", "# warm_start=True,", "\n", "bootstrap", "=", "True", ",", "\n", "random_state", "=", "42", ",", "\n", "n_jobs", "=", "1", ")", "\n", "\n", "", "if", "sample_size", "and", "train", ".", "shape", "[", "0", "]", ">=", "10000", ":", "\n", "    ", "sample_size", "=", "int", "(", "sample_size", ")", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "idx", "=", "np", ".", "random", ".", "choice", "(", "train", ".", "shape", "[", "0", "]", ",", "train", ".", "shape", "[", "0", "]", ",", "replace", "=", "False", ")", "\n", "\n", "x", "=", "train", "[", "idx", "[", "sample_size", ":", "]", ",", "0", ":", "-", "1", "]", "\n", "y", "=", "train", "[", "idx", "[", "sample_size", ":", "]", ",", "-", "1", "]", "\n", "\n", "x_test", "=", "train", "[", "idx", "[", "0", ":", "sample_size", "]", ",", "0", ":", "-", "1", "]", "\n", "y_test", "=", "train", "[", "idx", "[", "0", ":", "sample_size", "]", ",", "-", "1", "]", "\n", "", "else", ":", "\n", "    ", "x", "=", "train", "[", ":", ",", "0", ":", "-", "1", "]", "\n", "y", "=", "train", "[", ":", ",", "-", "1", "]", "\n", "\n", "x_test", "=", "x", "\n", "y_test", "=", "y", "\n", "\n", "", "estimators", "=", "[", "]", "\n", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "    ", "warnings", ".", "simplefilter", "(", "\"ignore\"", ")", "\n", "rf", ".", "fit", "(", "x", ",", "y", ")", "\n", "\n", "", "func_name", "=", "fn_split", "[", "0", "]", "\n", "\n", "bits", "=", "np", ".", "ceil", "(", "\n", "np", ".", "log2", "(", "\n", "np", ".", "abs", "(", "\n", "np", ".", "amax", "(", "x", ",", "axis", "=", "0", ")", "-", "\n", "np", ".", "amin", "(", "x", ",", "axis", "=", "0", ")", "+", "1", ")", ")", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "is_neg", "=", "(", "np", ".", "amin", "(", "x", ",", "axis", "=", "0", ")", "<", "0", ")", ".", "astype", "(", "np", ".", "int8", ")", "\n", "\n", "o_bits", "=", "np", ".", "ceil", "(", "\n", "np", ".", "log2", "(", "\n", "np", ".", "abs", "(", "\n", "np", ".", "amax", "(", "y", ",", "axis", "=", "0", ")", "-", "\n", "np", ".", "amin", "(", "y", ",", "axis", "=", "0", ")", "+", "1", ")", ")", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "o_is_neg", "=", "(", "np", ".", "amin", "(", "y", ",", "axis", "=", "0", ")", "<", "0", ")", ".", "astype", "(", "np", ".", "int8", ")", "\n", "\n", "rf", ".", "bits", "=", "bits", "\n", "rf", ".", "is_neg", "=", "is_neg", "\n", "rf", ".", "o_bits", "=", "o_bits", "\n", "rf", ".", "o_is_neg", "=", "o_is_neg", "\n", "\n", "code", "=", "gen_random_forest", "(", "\n", "rf", ",", "func_name", ",", "bits", ",", "is_neg", ",", "o_bits", ",", "o_is_neg", ",", "\n", "is_regressor", "=", "is_regressor", ",", "is_top_level", "=", "False", ",", "\n", "is_cc", "=", "file_suffix", "==", "\"cc\"", ")", "\n", "\n", "open", "(", "cv_file", ",", "\"w\"", ")", ".", "write", "(", "\"\\n\"", ".", "join", "(", "code", ")", ")", "\n", "\n", "p", "=", "1.0", "*", "np", ".", "round", "(", "rf", ".", "predict", "(", "x_test", ")", ")", "\n", "\n", "dy", "=", "np", ".", "max", "(", "train", "[", ":", ",", "-", "1", "]", ")", "-", "np", ".", "min", "(", "train", "[", ":", ",", "-", "1", "]", ")", "\n", "\n", "error", "=", "np", ".", "sum", "(", "np", ".", "abs", "(", "y_test", "-", "p", ")", ")", "/", "(", "1.0", "*", "p", ".", "shape", "[", "0", "]", "*", "dy", ")", "\n", "score", "=", "np", ".", "sum", "(", "y_test", "==", "p", ")", "/", "p", ".", "shape", "[", "0", "]", "\n", "\n", "print", "(", "\"y:\"", ",", "np", ".", "max", "(", "y_test", ")", ",", "y_test", "[", "0", ":", "30", "]", ".", "astype", "(", "np", ".", "int32", ")", ")", "\n", "print", "(", "\"p:\"", ",", "np", ".", "max", "(", "p", ")", ",", "p", "[", "0", ":", "30", "]", ".", "astype", "(", "np", ".", "int32", ")", ")", "\n", "\n", "print", "(", "\"... model {} with score of {:.2f}% and error of {:.2f}%\"", ".", "format", "(", "\n", "func_name", ",", "100.0", "*", "score", ",", "100.0", "*", "error", ")", ")", "\n", "\n", "print", "(", "\"... saving model in {}\"", ".", "format", "(", "rfb_file", ")", ")", "\n", "pickle", ".", "dump", "(", "rf", ",", "open", "(", "rfb_file", ",", "\"wb\"", ")", ")", "\n", "return", "rfb_file", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.optimizer.mp_abc_optimizer_func": [[194, 254], ["fn.split", "print", "os.environ.get", "subprocess.check_output", "output.strip.strip", "open", "print", "os.environ.get", "subprocess.check_output", "output.strip.strip", "print", "print", "sys.stdout.flush", "line.strip.strip", "os.environ.get.split", "print", "sys.stdout.flush", "int", "shutil.copyfile"], "function", ["None"], ["", "def", "mp_abc_optimizer_func", "(", "fn", ")", ":", "\n", "  ", "\"\"\"Performs espresso and abc optimization on a single espresso input.\"\"\"", "\n", "\n", "fn_split", "=", "fn", ".", "split", "(", "\".\"", ")", "\n", "o_file", "=", "\".\"", ".", "join", "(", "fn_split", "[", "0", ":", "-", "2", "]", "+", "[", "fn_split", "[", "-", "1", "]", "]", ")", "\n", "v_file", "=", "\".\"", ".", "join", "(", "fn_split", "[", "0", ":", "-", "2", "]", "+", "[", "\"v\"", "]", ")", "\n", "b_file", "=", "\".\"", ".", "join", "(", "fn_split", "[", "0", ":", "-", "2", "]", "+", "[", "\"blif\"", "]", ")", "\n", "\n", "print", "(", "\"...running espresso in \"", "+", "fn", ")", "\n", "\n", "espresso_flags", "=", "os", ".", "environ", ".", "get", "(", "\"ESPRESSO_FLAGS\"", ",", "\"-Dexpand\"", ")", "\n", "\n", "cmd", "=", "\"espresso {} {} > {}\"", ".", "format", "(", "fn", ",", "espresso_flags", ",", "o_file", ")", "\n", "\n", "output", "=", "subprocess", ".", "check_output", "(", "cmd", ",", "stderr", "=", "subprocess", ".", "STDOUT", ",", "shell", "=", "True", ")", "\n", "\n", "output", "=", "output", ".", "strip", "(", ")", "\n", "if", "output", ":", "\n", "    ", "print", "(", "output", ")", "\n", "sys", ".", "stdout", ".", "flush", "(", ")", "\n", "\n", "# check if network is empty", "\n", "\n", "", "for", "line", "in", "open", "(", "o_file", ")", ":", "\n", "    ", "line", "=", "line", ".", "strip", "(", ")", "\n", "if", "line", "[", "0", ":", "2", "]", "==", "\".p\"", ":", "\n", "      ", "terms", "=", "int", "(", "line", "[", "2", ":", "]", ")", "\n", "# empty : espresso optimized away all the logic", "\n", "if", "terms", "==", "0", ":", "\n", "        ", "shutil", ".", "copyfile", "(", "fn", ",", "o_file", ")", "\n", "", "break", "\n", "\n", "", "", "print", "(", "\"...running abc in \"", "+", "o_file", ")", "\n", "\n", "abc_flags", "=", "os", ".", "environ", ".", "get", "(", "\"ABC_FLAGS\"", ",", "\"\"", ")", "\n", "\n", "abc_flags_list", "=", "abc_flags", ".", "split", "(", "\";\"", ")", "if", "abc_flags", "else", "[", "]", "\n", "\n", "abc_cmds_list", "=", "(", "\n", "[", "\"read_pla \"", "+", "o_file", "]", "+", "abc_flags_list", "+", "\n", "[", "\"strash\"", ",", "\n", "\"dc2\"", ",", "\n", "\"strash\"", ",", "\n", "\"if -K 3\"", ",", "\n", "\"write_verilog \"", "+", "v_file", ",", "\n", "\"write_blif \"", "+", "b_file", "\n", "]", ")", "\n", "\n", "abc_cmds", "=", "\";\"", ".", "join", "(", "abc_cmds_list", ")", "\n", "\n", "cmd", "=", "\"abc -c '\"", "+", "abc_cmds", "+", "\"'\"", "\n", "\n", "output", "=", "subprocess", ".", "check_output", "(", "cmd", ",", "stderr", "=", "subprocess", ".", "STDOUT", ",", "shell", "=", "True", ")", "\n", "\n", "output", "=", "output", ".", "strip", "(", ")", "\n", "if", "output", ":", "\n", "    ", "print", "(", "output", ")", "\n", "sys", ".", "stdout", ".", "flush", "(", ")", "\n", "\n", "", "print", "(", "\"...generated \"", "+", "v_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.optimizer.run_abc_optimizer": [[256, 268], ["time.time", "multiprocessing.Pool", "mp.Pool.map", "mp.Pool.close", "print", "multiprocessing.cpu_count", "time.time"], "function", ["None"], ["", "def", "run_abc_optimizer", "(", "files", ")", ":", "\n", "  ", "\"\"\"Implements logic optimizer using espresso/abc.\"\"\"", "\n", "\n", "# intel processors sometimes return number of threads, not processors", "\n", "\n", "cpus", "=", "mp", ".", "cpu_count", "(", ")", "//", "2", "\n", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "pool", "=", "mp", ".", "Pool", "(", "cpus", ")", "\n", "pool", ".", "map", "(", "mp_abc_optimizer_func", ",", "files", ")", "\n", "pool", ".", "close", "(", ")", "\n", "print", "(", "\"Optimizer ran in {} seconds.\"", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start_time", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.optimizer.run_rf_optimizer": [[270, 358], ["time.time", "multiprocessing.Pool", "mp.Pool.map", "mp.Pool.close", "print", "files[].split", "path_split[].split", "pickle.load", "open", "open.write", "range", "open.close", "multiprocessing.cpu_count", "zip", "[].split", "open", "open.write", "fn.split", "path_split[].split", "modules.append", "open.write", "open.write", "open.write", "open.write", "open.write", "open.write", "open.write", "len", "open.write", "open.write", "open.write", "open.write", "open.write", "open.write", "open.write", "len", "len", "time.time", "files[].split", "str", "str", "str", "numpy.sum", "str", "str", "str", "str", "numpy.sum", "str", "len", "str", "str", "len", "str", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.google_qkeras.table.utils.load", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "run_rf_optimizer", "(", "files", ",", "flags", ",", "file_suffix", "=", "\"cc\"", ")", ":", "\n", "  ", "\"\"\"Implements random forest main optimizer.\"\"\"", "\n", "\n", "# intel processors sometimes return number of threads, not processors", "\n", "\n", "cpus", "=", "mp", ".", "cpu_count", "(", ")", "//", "2", "\n", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "pool", "=", "mp", ".", "Pool", "(", "cpus", ")", "\n", "pool", ".", "map", "(", "mp_rf_optimizer_func", ",", "zip", "(", "\n", "files", ",", "[", "flags", "]", "*", "len", "(", "files", ")", ",", "[", "file_suffix", "]", "*", "len", "(", "files", ")", ")", ")", "\n", "pool", ".", "close", "(", ")", "\n", "print", "(", "\"Optimizer ran in {} seconds.\"", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start_time", ")", ")", "\n", "\n", "# generates header file", "\n", "\n", "# .../.../.../conv2d_0_m.csv/conv2d_0_m_0.csv", "\n", "#", "\n", "# returns conv2d_0_m for module_name", "\n", "\n", "module_name", "=", "files", "[", "0", "]", ".", "split", "(", "\"/\"", ")", "[", "-", "2", "]", ".", "split", "(", "\".\"", ")", "[", "0", "]", "\n", "\n", "path_split", "=", "files", "[", "0", "]", ".", "split", "(", "\"/\"", ")", "\n", "path", "=", "\"/\"", ".", "join", "(", "path_split", "[", ":", "-", "1", "]", ")", "+", "\"/\"", "\n", "fn_split", "=", "path_split", "[", "-", "1", "]", ".", "split", "(", "\".\"", ")", "\n", "rfb_file", "=", "path", "+", "\".\"", ".", "join", "(", "fn_split", "[", "0", ":", "-", "2", "]", "+", "[", "\"rb\"", ",", "\"bin\"", "]", ")", "\n", "\n", "rf", "=", "pickle", ".", "load", "(", "open", "(", "rfb_file", ",", "\"rb\"", ")", ")", "\n", "\n", "f", "=", "open", "(", "path", "+", "module_name", "+", "\".\"", "+", "file_suffix", ",", "\"w\"", ")", "\n", "\n", "if", "file_suffix", "==", "\"cc\"", ":", "\n", "    ", "f", ".", "write", "(", "\"#include <ac_int.h>\\n\\n\"", ")", "\n", "\n", "", "modules", "=", "[", "]", "\n", "\n", "for", "fn", "in", "files", ":", "\n", "    ", "path_split", "=", "fn", ".", "split", "(", "\"/\"", ")", "\n", "path", "=", "\"/\"", ".", "join", "(", "path_split", "[", ":", "-", "1", "]", ")", "+", "\"/\"", "\n", "fn_split", "=", "path_split", "[", "-", "1", "]", ".", "split", "(", "\".\"", ")", "\n", "v_file", "=", "\".\"", ".", "join", "(", "fn_split", "[", "0", ":", "-", "2", "]", "+", "[", "file_suffix", "]", ")", "\n", "\n", "func_name", "=", "fn_split", "[", "0", "]", "\n", "\n", "if", "file_suffix", "==", "\"v\"", ":", "\n", "      ", "f", ".", "write", "(", "\"'include \\\"\"", "+", "v_file", "+", "\"\\\"\\n\"", ")", "\n", "", "else", ":", "\n", "      ", "f", ".", "write", "(", "\"#include \\\"\"", "+", "v_file", "+", "\"\\\"\\n\"", ")", "\n", "\n", "", "modules", ".", "append", "(", "func_name", ")", "\n", "\n", "", "f", ".", "write", "(", "\"\\n\\n\"", ")", "\n", "\n", "if", "file_suffix", "==", "\"v\"", ":", "\n", "    ", "f", ".", "write", "(", "\"module \"", "+", "module_name", "+", "\"(\"", ")", "\n", "f", ".", "write", "(", "\"input [\"", "+", "str", "(", "np", ".", "sum", "(", "rf", ".", "bits", ")", "-", "1", ")", "+", "\":0] in, \"", ")", "\n", "o_sign", "=", "\" signed \"", "if", "rf", ".", "o_is_neg", "else", "\"\"", "\n", "f", ".", "write", "(", "\"output \"", "+", "o_sign", "+", "\"[\"", "+", "str", "(", "len", "(", "modules", ")", "*", "rf", ".", "o_bits", "-", "1", ")", "+", "\n", "\":0] out);\\n\"", ")", "\n", "", "else", ":", "\n", "    ", "f", ".", "write", "(", "\"void \"", "+", "module_name", "+", "\"(\"", ")", "\n", "f", ".", "write", "(", "\"ac_int<\"", "+", "str", "(", "np", ".", "sum", "(", "rf", ".", "bits", ")", ")", "+", "\",false> in, \"", ")", "\n", "f", ".", "write", "(", "\"ac_int<\"", "+", "str", "(", "len", "(", "modules", ")", "*", "rf", ".", "o_bits", ")", "+", "\",\"", "+", "\n", "(", "\"true\"", "if", "rf", ".", "o_is_neg", "else", "\"false\"", ")", "+", "\n", "\"> &out)\\n\"", ")", "\n", "f", ".", "write", "(", "\"{\\n\"", ")", "\n", "\n", "", "for", "o", "in", "range", "(", "len", "(", "modules", ")", ")", ":", "\n", "    ", "if", "file_suffix", "==", "\"v\"", ":", "\n", "      ", "f", ".", "write", "(", "\"  wire \"", "+", "(", "\"signed \"", "if", "rf", ".", "o_is_neg", "else", "\"\"", ")", "+", "\n", "\"[\"", "+", "str", "(", "rf", ".", "bits", "[", "-", "1", "]", "-", "1", ")", "+", "\":0] \"", "\n", "\"o_\"", "+", "str", "(", "o", ")", "+", "\";\\n\"", ")", "\n", "f", ".", "write", "(", "\"  \"", "+", "modules", "[", "o", "]", "+", "\"(in, o_\"", "+", "str", "(", "o", ")", "+", "\");\\n\"", ")", "\n", "f", ".", "write", "(", "\"  assign out[\"", "+", "str", "(", "rf", ".", "o_bits", "*", "(", "o", "+", "1", ")", "-", "1", ")", "+", "\":\"", "+", "\n", "str", "(", "rf", ".", "bits", "[", "-", "1", "]", "*", "o", ")", "+", "\"] = o_\"", "+", "str", "(", "o", ")", "+", "\";\\n\"", ")", "\n", "", "else", ":", "\n", "      ", "f", ".", "write", "(", "\"  ac_int<\"", "+", "str", "(", "rf", ".", "o_bits", ")", "+", "\",\"", "+", "\n", "(", "\"true\"", "if", "rf", ".", "o_is_neg", "else", "\"false\"", ")", "+", "\n", "\"> o_\"", "+", "str", "(", "o", ")", "+", "\"; \"", "+", "modules", "[", "o", "]", "+", "\n", "\"(in, o_\"", "+", "str", "(", "o", ")", "+", "\"); out.set_slc<\"", "+", "\n", "str", "(", "rf", ".", "o_bits", ")", "+", "\">(\"", "+", "\n", "str", "(", "rf", ".", "o_bits", "*", "o", ")", "+", "\",\"", "+", "\n", "\"o_\"", "+", "str", "(", "o", ")", "+", "\");\\n\"", ")", "\n", "\n", "", "", "if", "file_suffix", "==", "\"cc\"", ":", "\n", "    ", "f", ".", "write", "(", "\"}\"", ")", "\n", "\n", "", "f", ".", "close", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.lo.utils.get_padding_value": [[21, 33], ["ValueError"], "function", ["None"], ["def", "get_padding_value", "(", "padding", ",", "kernel", ")", ":", "\n", "  ", "\"\"\"Returns padding value for kernel.\"\"\"", "\n", "\n", "if", "padding", "==", "\"valid\"", ":", "\n", "    ", "return", "0", "\n", "", "elif", "padding", "==", "\"same\"", ":", "\n", "    ", "return", "kernel", "//", "2", "\n", "", "elif", "padding", "==", "\"full\"", ":", "\n", "    ", "return", "kernel", "-", "1", "\n", "\n", "", "raise", "ValueError", "(", "\"accepted paddings are 'valid', 'same' or 'full', found \"", "+", "\n", "padding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.utils.get_quantized_bits_dict": [[35, 68], ["range", "str", "str", "bin", "str", "bin", "bin", "len"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "get_quantized_bits_dict", "(", "bits", ",", "ibits", ",", "sign", "=", "False", ",", "mode", "=", "\"bin\"", ")", ":", "\n", "  ", "\"\"\"Returns map from floating values to bit encoding.\"\"\"", "\n", "\n", "o_dict", "=", "{", "}", "\n", "\n", "n_bits", "=", "bits", "\n", "\n", "for", "b", "in", "range", "(", "1", "<<", "(", "bits", "-", "sign", ")", ")", ":", "\n", "    ", "v", "=", "(", "1.0", "*", "b", ")", "*", "(", "1", "<<", "ibits", ")", "/", "(", "1", "<<", "bits", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "      ", "b_str", "=", "bin", "(", "b", ")", "[", "2", ":", "]", "\n", "b_str", "=", "\"0\"", "*", "(", "n_bits", "-", "len", "(", "b_str", ")", ")", "+", "b_str", "\n", "", "else", ":", "# mode == \"dec\":", "\n", "      ", "b_str", "=", "str", "(", "b", ")", "\n", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "if", "b", ">", "0", "and", "sign", ":", "\n", "      ", "if", "mode", "==", "\"bin\"", ":", "\n", "        ", "b_str", "=", "bin", "(", "-", "b", "&", "(", "(", "1", "<<", "n_bits", ")", "-", "1", ")", ")", "[", "2", ":", "]", "\n", "", "else", ":", "# mode == \"dec\"", "\n", "        ", "b_str", "=", "str", "(", "-", "b", ")", "\n", "\n", "", "o_dict", "[", "-", "v", "]", "=", "b_str", "\n", "\n", "", "", "if", "sign", ":", "\n", "    ", "v", "=", "(", "1.0", "*", "(", "1", "<<", "(", "bits", "-", "sign", ")", ")", ")", "*", "(", "1", "<<", "ibits", ")", "/", "(", "1", "<<", "bits", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "      ", "b_str", "=", "bin", "(", "-", "(", "1", "<<", "(", "bits", "-", "sign", ")", ")", "&", "(", "(", "1", "<<", "bits", ")", "-", "1", ")", ")", "[", "2", ":", "]", "\n", "", "else", ":", "\n", "      ", "b_str", "=", "str", "(", "-", "(", "1", "<<", "(", "bits", "-", "sign", ")", ")", ")", "\n", "", "o_dict", "[", "-", "v", "]", "=", "b_str", "\n", "", "return", "o_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.utils.get_quantized_po2_dict": [[70, 181], ["range", "numpy.power", "numpy.power", "str", "list", "enumerate", "str", "numpy.power", "numpy.power", "str", "sorted", "min", "list.index", "str", "str", "numpy.power", "str", "bin", "o_dict.keys", "bin", "bin", "numpy.power", "str", "bin", "abs", "bin", "bin", "utils.get_quantized_po2_dict.invert_bit"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min"], ["", "def", "get_quantized_po2_dict", "(", "\n", "bits", ",", "max_exp", ",", "sign", "=", "False", ",", "make_smaller_zero", "=", "True", ",", "mode", "=", "\"bin\"", ")", ":", "\n", "  ", "\"\"\"Returns map from floating values to bit encoding.\"\"\"", "\n", "\n", "# if make_smaller_zero we will make sure smaller number is 000...0", "\n", "\n", "# mode = \"bin\" |-> make_smaller_zero", "\n", "\n", "assert", "mode", "!=", "\"bin\"", "or", "make_smaller_zero", "\n", "\n", "o_dict", "=", "{", "}", "\n", "\n", "if", "max_exp", ">", "0", ":", "\n", "    ", "v", "=", "1.0", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "      ", "b_str", "=", "\"0\"", "*", "bits", "\n", "", "else", ":", "\n", "      ", "b_str", "=", "\"1\"", "\n", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "if", "sign", ":", "\n", "      ", "v", "=", "-", "1.0", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "        ", "b_str", "=", "\"1\"", "+", "\"0\"", "*", "(", "bits", "-", "sign", ")", "\n", "", "else", ":", "\n", "        ", "b_str", "=", "\"-1\"", "\n", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "", "", "for", "b", "in", "range", "(", "1", ",", "1", "<<", "(", "bits", "-", "sign", "-", "1", ")", ")", ":", "\n", "    ", "v", "=", "np", ".", "power", "(", "2.0", ",", "-", "b", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "      ", "b_sign", "=", "\"0\"", "if", "sign", "else", "\"\"", "\n", "b_str", "=", "b_sign", "+", "bin", "(", "(", "-", "b", ")", "&", "(", "(", "1", "<<", "(", "bits", "-", "sign", "+", "1", ")", ")", "-", "1", ")", ")", "[", "3", ":", "]", "\n", "", "else", ":", "\n", "      ", "b_str", "=", "str", "(", "v", ")", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "if", "b", "<=", "max_exp", ":", "\n", "      ", "v", "=", "np", ".", "power", "(", "2.0", ",", "b", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "        ", "b_str", "=", "bin", "(", "b", ")", "[", "2", ":", "]", "\n", "b_str", "=", "b_sign", "+", "\"0\"", "*", "(", "bits", "-", "sign", "-", "len", "(", "b_str", ")", ")", "+", "b_str", "\n", "", "else", ":", "\n", "        ", "b_str", "=", "str", "(", "v", ")", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "", "if", "sign", ":", "\n", "      ", "v", "=", "-", "np", ".", "power", "(", "2.0", ",", "-", "b", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "        ", "b_sign", "=", "\"1\"", "if", "sign", "else", "\"\"", "\n", "b_str", "=", "b_sign", "+", "bin", "(", "(", "-", "b", ")", "&", "(", "(", "1", "<<", "(", "bits", "-", "sign", "+", "1", ")", ")", "-", "1", ")", ")", "[", "3", ":", "]", "\n", "", "else", ":", "\n", "        ", "b_str", "=", "str", "(", "v", ")", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "if", "b", "<=", "max_exp", ":", "\n", "        ", "v", "=", "-", "np", ".", "power", "(", "2.0", ",", "b", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "          ", "b_str", "=", "bin", "(", "b", ")", "[", "2", ":", "]", "\n", "b_str", "=", "b_sign", "+", "\"0\"", "*", "(", "bits", "-", "sign", "-", "len", "(", "b_str", ")", ")", "+", "b_str", "\n", "", "else", ":", "\n", "          ", "b_str", "=", "str", "(", "v", ")", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "", "", "", "b", "=", "1", "<<", "(", "bits", "-", "sign", "-", "1", ")", "\n", "v", "=", "np", ".", "power", "(", "2.0", ",", "-", "b", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "    ", "b_sign", "=", "\"0\"", "if", "sign", "else", "\"\"", "\n", "b_str", "=", "b_sign", "+", "bin", "(", "(", "-", "b", ")", "&", "(", "(", "1", "<<", "(", "bits", "-", "sign", "+", "1", ")", ")", "-", "1", ")", ")", "[", "3", ":", "]", "\n", "", "else", ":", "\n", "    ", "b_str", "=", "str", "(", "v", ")", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "smaller_mask", "=", "b_str", "\n", "\n", "if", "sign", ":", "\n", "    ", "v", "=", "-", "np", ".", "power", "(", "2.0", ",", "-", "b", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "      ", "b_sign", "=", "\"1\"", "if", "sign", "else", "\"\"", "\n", "b_str", "=", "b_sign", "+", "bin", "(", "(", "-", "b", ")", "&", "(", "(", "1", "<<", "(", "bits", "-", "sign", "+", "1", ")", ")", "-", "1", ")", ")", "[", "3", ":", "]", "\n", "", "else", ":", "\n", "      ", "b_str", "=", "str", "(", "v", ")", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "", "def", "invert_bit", "(", "bit", ",", "mask", ")", ":", "\n", "    ", "\"\"\"Inverts bits if mask is 1.\"\"\"", "\n", "\n", "if", "mask", "==", "\"0\"", ":", "\n", "      ", "return", "bit", "\n", "", "else", ":", "\n", "      ", "return", "\"0\"", "if", "bit", "==", "\"1\"", "else", "\"1\"", "\n", "\n", "", "", "if", "mode", "==", "\"bin\"", ":", "\n", "    ", "if", "make_smaller_zero", ":", "\n", "      ", "for", "v", "in", "o_dict", ":", "\n", "        ", "o_dict", "[", "v", "]", "=", "\"\"", ".", "join", "(", "\n", "invert_bit", "(", "bit", ",", "mask_bit", ")", "\n", "for", "bit", ",", "mask_bit", "in", "zip", "(", "o_dict", "[", "v", "]", ",", "smaller_mask", ")", ")", "\n", "", "", "", "else", ":", "\n", "    ", "keys_sorted", "=", "list", "(", "sorted", "(", "o_dict", ".", "keys", "(", ")", ")", ")", "\n", "if", "make_smaller_zero", ":", "\n", "      ", "min_positive_key", "=", "min", "(", "[", "abs", "(", "v", ")", "for", "v", "in", "keys_sorted", "]", ")", "\n", "min_positive_index", "=", "keys_sorted", ".", "index", "(", "min_positive_key", ")", "\n", "", "else", ":", "\n", "      ", "min_positive_index", "=", "0", "\n", "", "for", "i", ",", "k", "in", "enumerate", "(", "keys_sorted", ")", ":", "\n", "      ", "o_dict", "[", "k", "]", "=", "str", "(", "i", "-", "min_positive_index", ")", "\n", "\n", "", "", "return", "o_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.utils.get_ternary_dict": [[183, 190], ["None"], "function", ["None"], ["", "def", "get_ternary_dict", "(", "mode", "=", "\"bin\"", ")", ":", "\n", "  ", "\"\"\"Returns map from floating values to bit encoding.\"\"\"", "\n", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "    ", "return", "{", "-", "1.0", ":", "\"11\"", ",", "0.0", ":", "\"00\"", ",", "1.0", ":", "\"01\"", "}", "\n", "", "else", ":", "\n", "    ", "return", "{", "-", "1.0", ":", "\"-1\"", ",", "0.0", ":", "\"0\"", ",", "1.0", ":", "\"1\"", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.lo.utils.get_binary_dict": [[192, 205], ["None"], "function", ["None"], ["", "", "def", "get_binary_dict", "(", "symmetric", "=", "False", ",", "mode", "=", "\"bin\"", ")", ":", "\n", "  ", "\"\"\"Returns map from floating values to bit encoding.\"\"\"", "\n", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "    ", "if", "symmetric", ":", "\n", "      ", "return", "{", "-", "1.0", ":", "\"10\"", ",", "1.0", ":", "\"01\"", "}", "\n", "", "else", ":", "\n", "      ", "return", "{", "0.0", ":", "\"0\"", ",", "1.0", ":", "\"1\"", "}", "\n", "", "", "else", ":", "\n", "    ", "if", "symmetric", ":", "\n", "      ", "return", "{", "-", "1.0", ":", "\"-1\"", ",", "1.0", ":", "\"1\"", "}", "\n", "", "else", ":", "\n", "      ", "return", "{", "0.0", ":", "\"0\"", ",", "1.0", ":", "\"1\"", "}", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.__init__": [[30, 34], ["None"], "methods", ["None"], ["  ", "def", "__init__", "(", "self", ",", "max_depth", ",", "min_size", ")", ":", "\n", "    ", "self", ".", "min_size", "=", "min_size", "\n", "self", ".", "max_depth", "=", "max_depth", "\n", "self", ".", "n_features", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.split_into_groups": [[35, 41], ["numpy.logical_not"], "methods", ["None"], ["", "def", "split_into_groups", "(", "self", ",", "index", ",", "value", ",", "dataset", ")", ":", "\n", "    ", "mask_l", "=", "dataset", "[", ":", ",", "index", "]", "<", "value", "\n", "mask_r", "=", "np", ".", "logical_not", "(", "mask_l", ")", "\n", "left", "=", "dataset", "[", "mask_l", ",", "...", "]", "\n", "right", "=", "dataset", "[", "mask_r", ",", "...", "]", "\n", "return", "left", ",", "right", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.gini_index": [[42, 62], ["float", "sum", "float", "len", "numpy.array", "numpy.sum", "len", "numpy.power", "numpy.sum"], "methods", ["None"], ["", "def", "gini_index", "(", "self", ",", "groups", ",", "classes", ")", ":", "\n", "# count all samples at split point", "\n", "    ", "n_instances", "=", "float", "(", "sum", "(", "[", "len", "(", "group", ")", "for", "group", "in", "groups", "]", ")", ")", "\n", "# sum weighted Gini index for each group", "\n", "gini", "=", "0.0", "\n", "for", "group", "in", "groups", ":", "\n", "      ", "size", "=", "float", "(", "len", "(", "group", ")", ")", "\n", "# avoid divide by zero", "\n", "if", "size", "==", "0", ":", "\n", "        ", "continue", "\n", "", "score", "=", "0.0", "\n", "# score the group based on the score for each class", "\n", "for", "class_val", "in", "classes", ":", "\n", "        ", "p", "=", "np", ".", "array", "(", "[", "np", ".", "sum", "(", "group", "[", ":", ",", "-", "1", "]", "==", "class_val", ")", "/", "size", "\n", "for", "class_val", "in", "classes", "]", ")", "\n", "score", "+=", "np", ".", "sum", "(", "np", ".", "power", "(", "p", ",", "2", ")", ")", "\n", "\n", "# weight the group score by its relative size", "\n", "", "gini", "+=", "(", "1.0", "-", "score", ")", "*", "(", "size", "/", "n_instances", ")", "\n", "", "return", "gini", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.select_best_split": [[63, 85], ["list", "list", "set", "numpy.random.choice", "list", "list", "set", "random_tree.RandomTree.split_into_groups", "random_tree.RandomTree.gini_index", "dataset[].flatten", "len", "list"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.split_into_groups", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.gini_index"], ["", "def", "select_best_split", "(", "self", ",", "dataset", ")", ":", "\n", "    ", "class_values", "=", "list", "(", "set", "(", "list", "(", "dataset", "[", ":", ",", "-", "1", "]", ".", "flatten", "(", ")", ")", ")", ")", "\n", "\n", "b_index", ",", "b_value", ",", "b_score", ",", "b_groups", "=", "9999", ",", "9999", ",", "9999", ",", "None", "\n", "\n", "# because several of the entries may be don't cares, we will select the", "\n", "# whole set and restrict to only the ones that are not don't cares", "\n", "\n", "features", "=", "list", "(", "\n", "np", ".", "random", ".", "choice", "(", "len", "(", "dataset", "[", "0", "]", ")", "-", "1", ",", "self", ".", "n_features", ",", "p", "=", "self", ".", "probs", ",", "\n", "replace", "=", "False", ")", ")", "\n", "\n", "for", "index", "in", "features", ":", "\n", "      ", "assert", "self", ".", "mask", "[", "index", "]", "==", "True", "\n", "b_values", "=", "list", "(", "set", "(", "list", "(", "dataset", "[", ":", ",", "index", "]", ")", ")", ")", "\n", "for", "b", "in", "b_values", ":", "\n", "        ", "groups", "=", "self", ".", "split_into_groups", "(", "index", ",", "b", ",", "dataset", ")", "\n", "gini", "=", "self", ".", "gini_index", "(", "groups", ",", "class_values", ")", "\n", "if", "gini", "<", "b_score", ":", "\n", "          ", "b_index", ",", "b_value", ",", "b_score", ",", "b_groups", "=", "index", ",", "b", ",", "gini", ",", "groups", "\n", "\n", "", "", "", "return", "{", "'index'", ":", "b_index", ",", "'value'", ":", "b_value", ",", "'groups'", ":", "b_groups", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.select_terminal": [[86, 89], ["list", "max", "group[].flatten", "set"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "def", "select_terminal", "(", "self", ",", "group", ")", ":", "\n", "    ", "outcomes", "=", "list", "(", "group", "[", ":", ",", "-", "1", "]", ".", "flatten", "(", ")", ")", "\n", "return", "max", "(", "set", "(", "outcomes", ")", ",", "key", "=", "outcomes", ".", "count", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.split_node": [[90, 123], ["random_tree.RandomTree.select_terminal", "random_tree.RandomTree.select_terminal", "random_tree.RandomTree.select_best_split", "random_tree.RandomTree.split_node", "random_tree.RandomTree.select_terminal", "random_tree.RandomTree.select_best_split", "random_tree.RandomTree.split_node", "random_tree.RandomTree.select_terminal", "random_tree.RandomTree.select_terminal", "random_tree.RandomTree.select_terminal", "len", "len", "set", "set", "list", "list", "left[].flatten", "right[].flatten"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.select_terminal", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.select_terminal", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.select_best_split", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.split_node", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.select_terminal", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.select_best_split", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.split_node", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.select_terminal", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.select_terminal", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.select_terminal"], ["", "def", "split_node", "(", "self", ",", "node", ",", "depth", ")", ":", "\n", "    ", "left", ",", "right", "=", "node", "[", "'groups'", "]", "\n", "del", "(", "node", "[", "'groups'", "]", ")", "\n", "\n", "# check for a no split", "\n", "if", "left", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "      ", "node", "[", "'left'", "]", "=", "node", "[", "'right'", "]", "=", "self", ".", "select_terminal", "(", "right", ")", "\n", "return", "\n", "", "elif", "right", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "      ", "node", "[", "'left'", "]", "=", "node", "[", "'right'", "]", "=", "self", ".", "select_terminal", "(", "left", ")", "\n", "return", "\n", "\n", "# check for max depth", "\n", "", "if", "depth", ">=", "self", ".", "max_depth", ":", "\n", "      ", "node", "[", "'left'", "]", ",", "node", "[", "'right'", "]", "=", "(", "self", ".", "select_terminal", "(", "left", ")", ",", "\n", "self", ".", "select_terminal", "(", "right", ")", ")", "\n", "return", "\n", "\n", "# process left child", "\n", "", "if", "len", "(", "set", "(", "list", "(", "\n", "left", "[", ":", ",", "-", "1", "]", ".", "flatten", "(", ")", ")", ")", ")", "==", "1", "or", "left", ".", "shape", "[", "0", "]", "<=", "self", ".", "min_size", ":", "\n", "      ", "node", "[", "'left'", "]", "=", "self", ".", "select_terminal", "(", "left", ")", "\n", "", "else", ":", "\n", "      ", "node", "[", "'left'", "]", "=", "self", ".", "select_best_split", "(", "left", ")", "\n", "self", ".", "split_node", "(", "node", "[", "'left'", "]", ",", "depth", "+", "1", ")", "\n", "\n", "# process right child", "\n", "", "if", "len", "(", "set", "(", "list", "(", "\n", "right", "[", ":", ",", "-", "1", "]", ".", "flatten", "(", ")", ")", ")", ")", "==", "1", "or", "right", ".", "shape", "[", "0", "]", "<=", "self", ".", "min_size", ":", "\n", "      ", "node", "[", "'right'", "]", "=", "self", ".", "select_terminal", "(", "right", ")", "\n", "", "else", ":", "\n", "      ", "node", "[", "'right'", "]", "=", "self", ".", "select_best_split", "(", "right", ")", "\n", "self", ".", "split_node", "(", "node", "[", "'right'", "]", ",", "depth", "+", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.create_mask": [[124, 126], ["numpy.amin", "numpy.amax"], "methods", ["None"], ["", "", "def", "create_mask", "(", "self", ",", "dataset", ")", ":", "\n", "    ", "self", ".", "mask", "=", "np", ".", "amin", "(", "dataset", ",", "axis", "=", "0", ")", "!=", "np", ".", "amax", "(", "dataset", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.fit": [[127, 140], ["random_tree.RandomTree.select_best_split", "random_tree.RandomTree.split_node", "random_tree.RandomTree.create_mask", "numpy.ones", "random_tree.RandomTree.mask[].astype", "numpy.sum", "int", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.select_best_split", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.split_node", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.create_mask"], ["", "def", "fit", "(", "self", ",", "dataset", ",", "mask_stuck_at_values", "=", "False", ")", ":", "\n", "    ", "if", "mask_stuck_at_values", ":", "\n", "      ", "self", ".", "create_mask", "(", "dataset", ")", "\n", "", "else", ":", "\n", "      ", "self", ".", "mask", "=", "np", ".", "ones", "(", "dataset", ".", "shape", "[", "1", "]", ")", "\n", "\n", "", "self", ".", "probs", "=", "self", ".", "mask", "[", ":", "-", "1", "]", ".", "astype", "(", "np", ".", "float32", ")", "/", "np", ".", "sum", "(", "self", ".", "mask", "[", ":", "-", "1", "]", ")", "\n", "\n", "if", "not", "self", ".", "n_features", ":", "\n", "      ", "self", ".", "n_features", "=", "int", "(", "np", ".", "sqrt", "(", "dataset", ".", "shape", "[", "1", "]", "-", "1", ")", ")", "\n", "\n", "", "self", ".", "root", "=", "self", ".", "select_best_split", "(", "dataset", ")", "\n", "self", ".", "split_node", "(", "self", ".", "root", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.predict_internal": [[141, 152], ["isinstance", "isinstance", "random_tree.RandomTree.predict_internal", "random_tree.RandomTree.predict_internal"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.predict_internal", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.predict_internal"], ["", "def", "predict_internal", "(", "self", ",", "node", ",", "data", ")", ":", "\n", "    ", "if", "data", "[", "node", "[", "'index'", "]", "]", "<", "node", "[", "'value'", "]", ":", "\n", "      ", "if", "isinstance", "(", "node", "[", "'left'", "]", ",", "dict", ")", ":", "\n", "        ", "return", "self", ".", "predict_internal", "(", "node", "[", "'left'", "]", ",", "data", ")", "\n", "", "else", ":", "\n", "        ", "return", "node", "[", "'left'", "]", "\n", "", "", "else", ":", "\n", "      ", "if", "isinstance", "(", "node", "[", "'right'", "]", ",", "dict", ")", ":", "\n", "        ", "return", "self", ".", "predict_internal", "(", "node", "[", "'right'", "]", ",", "data", ")", "\n", "", "else", ":", "\n", "        ", "return", "node", "[", "'right'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.predict_row": [[154, 156], ["random_tree.RandomTree.predict_internal"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.predict_internal"], ["", "", "", "def", "predict_row", "(", "self", ",", "row", ")", ":", "\n", "    ", "return", "self", ".", "predict_internal", "(", "self", ".", "root", ",", "row", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.predict": [[158, 160], ["numpy.array", "random_tree.RandomTree.predict_row", "range"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict_row", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "predict", "(", "self", ",", "data", ")", ":", "\n", "    ", "return", "np", ".", "array", "(", "self", ".", "predict_row", "(", "data", "[", "i", "]", ")", "for", "i", "in", "range", "(", "data", ".", "shape", "[", "0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.gen_code_internal": [[161, 180], ["isinstance", "isinstance", "random_tree.RandomTree.gen_code_internal", "str", "random_tree.RandomTree.gen_code_internal", "str", "len", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.gen_code_internal", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.gen_code_internal"], ["", "def", "gen_code_internal", "(", "self", ",", "node", ",", "var_dict", ",", "n_offset", ")", ":", "\n", "# traverse left", "\n", "    ", "cond", "=", "'( i_'", "+", "str", "(", "node", "[", "'index'", "]", ")", "+", "' < '", "+", "str", "(", "node", "[", "'value'", "]", ")", "+", "' )'", "\n", "if", "isinstance", "(", "node", "[", "'left'", "]", ",", "dict", ")", ":", "\n", "      ", "n0", "=", "self", ".", "gen_code_internal", "(", "node", "[", "'left'", "]", ",", "var_dict", ",", "n_offset", ")", "\n", "", "else", ":", "\n", "      ", "n0", "=", "str", "(", "node", "[", "'left'", "]", ")", "\n", "\n", "", "if", "isinstance", "(", "node", "[", "'right'", "]", ",", "dict", ")", ":", "\n", "      ", "n1", "=", "self", ".", "gen_code_internal", "(", "node", "[", "'right'", "]", ",", "var_dict", ",", "n_offset", ")", "\n", "", "else", ":", "\n", "      ", "n1", "=", "str", "(", "node", "[", "'right'", "]", ")", "\n", "\n", "", "index", "=", "len", "(", "var_dict", ")", "+", "n_offset", "\n", "r", "=", "'n_'", "+", "str", "(", "index", ")", "\n", "stmt", "=", "cond", "+", "'? '", "+", "n0", "+", "' : '", "+", "n1", "\n", "var_dict", "[", "r", "]", "=", "stmt", "\n", "\n", "return", "r", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.gen_code": [[181, 187], ["random_tree.RandomTree.gen_code_internal"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.random_forest.random_tree.RandomTree.gen_code_internal"], ["", "def", "gen_code", "(", "self", ",", "n_offset", "=", "0", ")", ":", "\n", "    ", "var_dict", "=", "{", "}", "\n", "\n", "self", ".", "gen_code_internal", "(", "self", ".", "root", ",", "var_dict", ",", "n_offset", ")", "\n", "\n", "return", "var_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.parser.PLA.__init__": [[29, 32], ["None"], "methods", ["None"], ["  ", "def", "__init__", "(", "self", ")", ":", "\n", "    ", "self", ".", "pla_i", "=", "[", "]", "\n", "self", ".", "pla_o", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.parser.t_NUMBER": [[62, 65], ["None"], "function", ["None"], ["def", "t_NUMBER", "(", "t", ")", ":", "\n", "  ", "r\"[\\d\\-]+\"", "\n", "return", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.parser.t_NEWLINE": [[66, 70], ["t.value.count"], "function", ["None"], ["", "def", "t_NEWLINE", "(", "t", ")", ":", "\n", "  ", "r\"\\n+\"", "\n", "t", ".", "lexer", ".", "lineno", "+=", "t", ".", "value", ".", "count", "(", "\"\\n\"", ")", "\n", "return", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.parser.t_error": [[71, 74], ["print", "t.lexer.skip"], "function", ["None"], ["", "def", "t_error", "(", "t", ")", ":", "\n", "  ", "print", "(", "\"Illegal character '{}'\"", ".", "format", "(", "t", ".", "value", ")", ")", "\n", "t", ".", "lexer", ".", "skip", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.parser.p_pla": [[77, 79], ["None"], "function", ["None"], ["def", "p_pla", "(", "p", ")", ":", "\n", "  ", "\"\"\"pla : pla_declarations pla_table pla_end\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.parser.p_pla_declarations": [[80, 83], ["None"], "function", ["None"], ["", "def", "p_pla_declarations", "(", "p", ")", ":", "\n", "  ", "\"\"\"pla_declarations : pla_declarations pla_declaration\n                      | pla_declaration\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.parser.p_pla_declaration": [[84, 109], ["p[].lower", "int", "int", "int"], "function", ["None"], ["", "def", "p_pla_declaration", "(", "p", ")", ":", "\n", "  ", "\"\"\"pla_declaration : I NUMBER NEWLINE\n                     | O NUMBER NEWLINE\n                     | P NUMBER NEWLINE\n                     | MV number_list NEWLINE\n                     | ILB symbol_list NEWLINE\n                     | OB symbol_list NEWLINE\n                     | L NUMBER symbol_list NEWLINE\n                     | TYPE SYMBOL NEWLINE\n  \"\"\"", "\n", "token", "=", "p", "[", "1", "]", ".", "lower", "(", ")", "\n", "if", "token", "==", "\".i\"", ":", "\n", "    ", "pla", ".", "ni", "=", "int", "(", "p", "[", "2", "]", ")", "\n", "", "elif", "token", "==", "\".o\"", ":", "\n", "    ", "pla", ".", "no", "=", "int", "(", "p", "[", "2", "]", ")", "\n", "", "elif", "token", "==", "\".mv\"", ":", "\n", "    ", "pla", ".", "mv", "=", "[", "int", "(", "v", ")", "for", "v", "in", "p", "[", "2", "]", "]", "\n", "", "elif", "token", "==", "\".ilb\"", ":", "\n", "    ", "pla", ".", "ilb", "=", "p", "[", "2", "]", "\n", "", "elif", "token", "==", "\".ob\"", ":", "\n", "    ", "pla", ".", "ob", "=", "p", "[", "2", "]", "\n", "", "elif", "token", "==", "\".l\"", ":", "\n", "    ", "pla", ".", "label", "=", "p", "[", "2", "]", "\n", "", "elif", "token", "==", "\".type\"", ":", "\n", "    ", "pla", ".", "set_type", "=", "p", "[", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.parser.p_pla_table": [[111, 127], ["pla.pla_i.append", "pla.pla_o.append", "len", "hasattr", "hasattr"], "function", ["None"], ["", "", "def", "p_pla_table", "(", "p", ")", ":", "\n", "  ", "\"\"\"pla_table : pla_table number_symbol_list NEWLINE\n               | number_symbol_list NEWLINE\"\"\"", "\n", "if", "len", "(", "p", "[", "1", ":", "]", ")", "==", "3", ":", "\n", "    ", "line", "=", "\"\"", ".", "join", "(", "p", "[", "2", "]", ")", "\n", "", "else", ":", "\n", "    ", "line", "=", "\"\"", ".", "join", "(", "p", "[", "1", "]", ")", "\n", "\n", "", "assert", "hasattr", "(", "pla", ",", "\"ni\"", ")", "and", "hasattr", "(", "pla", ",", "\"no\"", ")", "\n", "\n", "# right now we only process binary functions", "\n", "\n", "line", "=", "[", "_1", "if", "v", "==", "\"1\"", "else", "_0", "if", "v", "==", "\"0\"", "else", "_X", "for", "v", "in", "line", "]", "\n", "\n", "pla", ".", "pla_i", ".", "append", "(", "line", "[", "0", ":", "pla", ".", "ni", "]", ")", "\n", "pla", ".", "pla_o", ".", "append", "(", "line", "[", "pla", ".", "ni", ":", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.parser.p_pla_end": [[129, 132], ["None"], "function", ["None"], ["", "def", "p_pla_end", "(", "p", ")", ":", "\n", "  ", "\"\"\"pla_end : E opt_new_line\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.parser.p_opt_new_line": [[134, 139], ["None"], "function", ["None"], ["", "def", "p_opt_new_line", "(", "p", ")", ":", "\n", "  ", "\"\"\"opt_new_line : NEWLINE\n                  |\n  \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.parser.p_number_list": [[141, 149], ["len"], "function", ["None"], ["", "def", "p_number_list", "(", "p", ")", ":", "\n", "  ", "\"\"\"number_list : number_list NUMBER\n                 | NUMBER\n  \"\"\"", "\n", "if", "len", "(", "p", "[", "1", ":", "]", ")", "==", "2", ":", "\n", "    ", "p", "[", "0", "]", "=", "p", "[", "1", "]", "+", "[", "p", "[", "2", "]", "]", "\n", "", "else", ":", "\n", "    ", "p", "[", "0", "]", "=", "[", "p", "[", "1", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.parser.p_symbol_list": [[151, 159], ["len"], "function", ["None"], ["", "", "def", "p_symbol_list", "(", "p", ")", ":", "\n", "  ", "\"\"\"symbol_list : symbol_list SYMBOL\n                 | SYMBOL\n  \"\"\"", "\n", "if", "len", "(", "p", "[", "1", ":", "]", ")", "==", "2", ":", "\n", "    ", "p", "[", "0", "]", "=", "p", "[", "1", "]", "+", "[", "p", "[", "2", "]", "]", "\n", "", "else", ":", "\n", "    ", "p", "[", "0", "]", "=", "[", "p", "[", "1", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.parser.p_number_symbol_list": [[161, 169], ["len"], "function", ["None"], ["", "", "def", "p_number_symbol_list", "(", "p", ")", ":", "\n", "  ", "\"\"\"number_symbol_list : number_symbol_list number_or_symbol\n                        | number_or_symbol\n  \"\"\"", "\n", "if", "len", "(", "p", "[", "1", ":", "]", ")", "==", "2", ":", "\n", "    ", "p", "[", "0", "]", "=", "p", "[", "1", "]", "+", "[", "p", "[", "2", "]", "]", "\n", "", "else", ":", "\n", "    ", "p", "[", "0", "]", "=", "[", "p", "[", "1", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.parser.p_number_or_symbol": [[171, 176], ["None"], "function", ["None"], ["", "", "def", "p_number_or_symbol", "(", "p", ")", ":", "\n", "  ", "\"\"\"number_or_symbol : NUMBER\n                      | SYMBOL\n  \"\"\"", "\n", "p", "[", "0", "]", "=", "p", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.parser.p_error": [[178, 180], ["print"], "function", ["None"], ["", "def", "p_error", "(", "p", ")", ":", "\n", "  ", "print", "(", "\"Error text at {}\"", ".", "format", "(", "p", ")", ")", "#p.value))", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.parser.get_tokens": [[183, 186], ["ply.lex.input", "open().readlines", "open"], "function", ["None"], ["def", "get_tokens", "(", "fn", ")", ":", "\n", "  ", "lex", ".", "input", "(", "\"\"", ".", "join", "(", "open", "(", "fn", ")", ".", "readlines", "(", ")", ")", ")", "\n", "return", "lex", ".", "token", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.parser.parse": [[187, 194], ["ply.yacc.parse", "numpy.array", "numpy.array", "open().readlines", "open"], "function", ["home.repos.pwc.inspect_result.google_qkeras.table.parser.parse"], ["", "def", "parse", "(", "fn", ")", ":", "\n", "  ", "yacc", ".", "parse", "(", "\"\"", ".", "join", "(", "open", "(", "fn", ")", ".", "readlines", "(", ")", ")", ")", "\n", "\n", "pla", ".", "pla_i", "=", "np", ".", "array", "(", "pla", ".", "pla_i", ")", "\n", "pla", ".", "pla_o", "=", "np", ".", "array", "(", "pla", ".", "pla_o", ")", "\n", "\n", "return", "pla", "\n", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.__init__": [[33, 46], ["None"], "methods", ["None"], ["  ", "def", "__init__", "(", "\n", "self", ",", "max_depth", ",", "min_size", ",", "n_trees", ",", "use_mean", "=", "False", ",", "\n", "sample_size", "=", "None", ")", ":", "\n", "    ", "self", ".", "max_depth", "=", "max_depth", "\n", "self", ".", "min_size", "=", "min_size", "\n", "self", ".", "use_mean", "=", "use_mean", "\n", "self", ".", "sample_size", "=", "sample_size", "\n", "self", ".", "n_trees", "=", "n_trees", "\n", "self", ".", "inputs", "=", "None", "\n", "self", ".", "bits", "=", "None", "\n", "self", ".", "is_neg", "=", "None", "\n", "\n", "self", ".", "trees", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.save": [[47, 54], ["print", "open", "pickle.dump", "open.close"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "save", "(", "model", ",", "filename", ")", ":", "\n", "    ", "\"\"\"Saves model to disk.\"\"\"", "\n", "print", "(", "\"... saving model in {}\"", ".", "format", "(", "filename", ")", ")", "\n", "f", "=", "open", "(", "filename", ",", "\"wb\"", ")", "\n", "pickle", ".", "dump", "(", "model", ",", "f", ")", "\n", "f", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.load": [[56, 65], ["print", "open", "pickle.load", "open.close"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.table.utils.load"], ["", "@", "staticmethod", "\n", "def", "load", "(", "filename", ")", ":", "\n", "    ", "\"\"\"Loads model from disk.\"\"\"", "\n", "print", "(", "\"... loading model from {}\"", ".", "format", "(", "filename", ")", ")", "\n", "f", "=", "open", "(", "filename", ",", "\"rb\"", ")", "\n", "random_forest", "=", "pickle", ".", "load", "(", "f", ")", "\n", "f", ".", "close", "(", ")", "\n", "\n", "return", "random_forest", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.subsample": [[67, 73], ["numpy.random.choice"], "methods", ["None"], ["", "def", "subsample", "(", "self", ",", "dataset", ")", ":", "\n", "    ", "\"\"\"Subsamples dataset if we do not want to use entire dataset.\"\"\"", "\n", "sample_idx", "=", "np", ".", "random", ".", "choice", "(", "\n", "dataset", ".", "shape", "[", "0", "]", ",", "self", ".", "sample_size", ",", "replace", "=", "True", ")", "\n", "sample", "=", "dataset", "[", "sample_idx", ",", "...", "]", "\n", "return", "sample", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.fit": [[75, 103], ["numpy.ceil().astype", "range", "random_forest.RandomForest.trees.append", "numpy.ceil", "print", "random_forest.RandomForest.subsample", "random_forest.fit_parallel", "numpy.log2", "numpy.amin", "print", "numpy.abs", "numpy.amax", "numpy.amin"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.subsample", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.fit_parallel"], ["", "def", "fit", "(", "self", ",", "dataset", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"Fits random tree to model.\"\"\"", "\n", "self", ".", "inputs", "=", "dataset", ".", "shape", "[", "1", "]", "-", "1", "\n", "self", ".", "bits", "=", "np", ".", "ceil", "(", "\n", "np", ".", "log2", "(", "\n", "np", ".", "abs", "(", "\n", "np", ".", "amax", "(", "dataset", ",", "axis", "=", "0", ")", "-", "\n", "np", ".", "amin", "(", "dataset", ",", "axis", "=", "0", ")", ")", ")", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "self", ".", "is_neg", "=", "(", "np", ".", "amin", "(", "dataset", ",", "axis", "=", "0", ")", "<", "0", ")", ".", "astype", "(", "np", ".", "int8", ")", "\n", "\n", "self", ".", "trees", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "n_trees", ")", ":", "\n", "      ", "if", "verbose", ":", "\n", "        ", "print", "(", "\"... creating tree {}\"", ".", "format", "(", "i", ")", ")", "\n", "\n", "# as subsample is an expensive operation, we will only perform it if it", "\n", "# reduces the dataset substantially", "\n", "\n", "", "if", "self", ".", "sample_size", "and", "self", ".", "sample_size", "<", "0.3", "*", "dataset", ".", "shape", "[", "0", "]", ":", "\n", "        ", "if", "verbose", ":", "\n", "          ", "print", "(", "\"... generated subsample of size {}\"", ".", "format", "(", "self", ".", "sample_size", ")", ")", "\n", "", "sample", "=", "self", ".", "subsample", "(", "dataset", ")", "\n", "", "else", ":", "\n", "        ", "sample", "=", "dataset", "\n", "\n", "", "self", ".", "trees", ".", "append", "(", "fit_parallel", "(", "\n", "self", ".", "max_depth", ",", "self", ".", "min_size", ",", "sample", ",", "True", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict_row": [[105, 112], ["tree.predict_row", "int", "max", "numpy.round", "set", "numpy.mean"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict_row", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "", "def", "predict_row", "(", "self", ",", "row", ")", ":", "\n", "    ", "\"\"\"Predicts output for single row.\"\"\"", "\n", "result", "=", "[", "tree", ".", "predict_row", "(", "row", ")", "for", "tree", "in", "self", ".", "trees", "]", "\n", "if", "self", ".", "use_mean", ":", "\n", "      ", "return", "int", "(", "np", ".", "round", "(", "np", ".", "mean", "(", "result", ")", ")", ")", "\n", "", "else", ":", "\n", "      ", "return", "max", "(", "set", "(", "result", ")", ",", "key", "=", "result", ".", "count", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict": [[114, 120], ["numpy.array", "random_forest.RandomForest.predict_row", "range"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict_row", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "", "def", "predict", "(", "self", ",", "data", ")", ":", "\n", "    ", "\"\"\"Predicts class based on data.\"\"\"", "\n", "\n", "assert", "self", ".", "trees", "is", "not", "None", "\n", "\n", "return", "np", ".", "array", "(", "[", "self", ".", "predict_row", "(", "data", "[", "i", "]", ")", "for", "i", "in", "range", "(", "data", ".", "shape", "[", "0", "]", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.gen_code": [[122, 250], ["open", "numpy.sum", "len", "range", "range", "open.close", "vd_list.append", "len", "open.write", "open.write", "open.write", "open.write", "s_in_line.append", "open.write", "len", "open.write", "o_list.append", "len", "open.write", "open.write", "len", "open.write", "open.write", "open.write", "tree.gen_code", "filename.split", "open.write", "len", "len", "len", "open.write", "open.write", "open.write", "len", "open.write", "str", "str", "len", "str", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.gen_code"], ["", "def", "gen_code", "(", "self", ",", "filename", ",", "func_name", ")", ":", "\n", "    ", "\"\"\"Generates code for model.\"\"\"", "\n", "\n", "assert", "self", ".", "bits", "is", "not", "None", "\n", "\n", "vd_list", "=", "[", "]", "\n", "n_vars", "=", "0", "\n", "for", "tree", "in", "self", ".", "trees", ":", "\n", "      ", "vd_list", ".", "append", "(", "tree", ".", "gen_code", "(", "n_vars", ")", ")", "\n", "n_vars", "+=", "len", "(", "vd_list", "[", "-", "1", "]", ")", "\n", "\n", "# checks the type by the suffix", "\n", "\n", "", "is_v", "=", "filename", ".", "split", "(", "\".\"", ")", "[", "-", "1", "]", "==", "\"v\"", "\n", "\n", "assert", "self", ".", "inputs", "\n", "\n", "f", "=", "open", "(", "filename", ",", "\"w\"", ")", "\n", "\n", "i_bits", "=", "np", ".", "sum", "(", "self", ".", "bits", "[", ":", "-", "1", "]", ")", "\n", "o_bits", "=", "self", ".", "bits", "[", "-", "1", "]", "\n", "o_sign", "=", "self", ".", "is_neg", "[", "-", "1", "]", "\n", "\n", "if", "is_v", ":", "\n", "      ", "f", ".", "write", "(", "\"module {}(input [{}:0] i, output [{}:0] o);\\n\"", ".", "format", "(", "\n", "func_name", ",", "i_bits", "-", "1", ",", "o_bits", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "      ", "f", ".", "write", "(", "\"#include<ac_int.h>\\n\\n\"", ")", "\n", "f", ".", "write", "(", "\"void {}(ac_int<{},false> i, ac_int<{},{}> &o)\\n\"", ".", "format", "(", "\n", "func_name", ",", "i_bits", ",", "o_bits", ",", "o_sign", ")", ")", "\n", "f", ".", "write", "(", "\"{\\n\"", ")", "\n", "\n", "\n", "# write function headline", "\n", "", "s_in_line", "=", "[", "]", "\n", "\n", "i_bits", "=", "self", ".", "bits", "[", "0", "]", "\n", "i_sign", "=", "self", ".", "is_neg", "[", "0", "]", "\n", "\n", "if", "is_v", ":", "\n", "      ", "i_datatype", "=", "\"  wire {}[{}:0] \"", ".", "format", "(", "\n", "\"signed \"", "if", "i_sign", "else", "\"\"", ",", "i_bits", "-", "1", ")", "\n", "", "else", ":", "\n", "      ", "i_datatype", "=", "\"  ac_int<{},{}> \"", ".", "format", "(", "i_bits", ",", "i_sign", ")", "\n", "\n", "", "len_s", "=", "len", "(", "i_datatype", ")", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "inputs", ")", ":", "\n", "      ", "if", "is_v", ":", "\n", "        ", "s", "=", "(", "\n", "\"i_\"", "+", "str", "(", "i", ")", "+", "\" = \"", "+", "\"i[\"", "+", "str", "(", "i_bits", "*", "(", "i", "+", "1", ")", "-", "1", ")", "+", "\":\"", "+", "\n", "str", "(", "i_bits", "*", "i", ")", "+", "\"]\"", "\n", ")", "\n", "", "else", ":", "\n", "        ", "s", "=", "(", "\n", "\"i_\"", "+", "str", "(", "i", ")", "+", "\" = \"", "+", "\"i.slc<\"", "+", "str", "(", "i_bits", ")", "+", "\">(\"", "+", "\n", "str", "(", "i_bits", "*", "i", ")", "+", "\")\"", "\n", ")", "\n", "", "if", "(", "\n", "len_s", "+", "len", "(", "s", ")", "+", "2", ">", "70", "or", "i_bits", "!=", "self", ".", "bits", "[", "i", "]", "or", "\n", "i_sign", "!=", "self", ".", "is_neg", "[", "i", "]", "\n", ")", ":", "\n", "        ", "f", ".", "write", "(", "i_datatype", "+", "\", \"", ".", "join", "(", "s_in_line", ")", "+", "\";\\n\"", ")", "\n", "\n", "s_in_line", "=", "[", "]", "\n", "if", "is_v", ":", "\n", "          ", "i_datatype", "=", "\"  wire {}[{}:0] \"", ".", "format", "(", "\n", "\"signed \"", "if", "i_sign", "else", "\"\"", ",", "i_bits", "-", "1", ")", "\n", "", "else", ":", "\n", "          ", "i_datatype", "=", "\"  ac_int<{},{}> \"", ".", "format", "(", "i_bits", ",", "i_sign", ")", "\n", "\n", "", "len_s", "=", "len", "(", "i_datatype", ")", "\n", "\n", "", "s_in_line", ".", "append", "(", "s", ")", "\n", "len_s", "+=", "len", "(", "s", ")", "+", "2", "\n", "\n", "", "if", "s_in_line", ":", "\n", "      ", "f", ".", "write", "(", "i_datatype", "+", "\", \"", ".", "join", "(", "s_in_line", ")", "+", "\";\\n\"", ")", "\n", "\n", "", "if", "is_v", ":", "\n", "      ", "o_datatype", "=", "\"  wire {}[{}:0] \"", ".", "format", "(", "\n", "\"signed \"", "if", "o_sign", "else", "\"\"", ",", "o_bits", ")", "\n", "", "else", ":", "\n", "      ", "o_datatype", "=", "\"  ac_int<{},{}> \"", ".", "format", "(", "o_bits", ",", "o_sign", ")", "\n", "\n", "", "o_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "vd_list", ")", ")", ":", "\n", "      ", "for", "v", "in", "vd_list", "[", "i", "]", ":", "\n", "        ", "if", "is_v", ":", "\n", "          ", "f", ".", "write", "(", "o_datatype", "+", "v", "+", "\" = \"", "+", "vd_list", "[", "i", "]", "[", "v", "]", "+", "\";\\n\"", ")", "\n", "", "else", ":", "\n", "          ", "f", ".", "write", "(", "o_datatype", "+", "v", "+", "\" = \"", "+", "vd_list", "[", "i", "]", "[", "v", "]", "+", "\";\\n\"", ")", "\n", "", "", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "o_list", ".", "append", "(", "v", ")", "\n", "\n", "", "assert", "len", "(", "o_list", ")", "<=", "3", "\n", "\n", "if", "is_v", ":", "\n", "      ", "f", ".", "write", "(", "\"  assign \"", ")", "\n", "", "else", ":", "\n", "      ", "f", ".", "write", "(", "\"  \"", ")", "\n", "\n", "", "if", "len", "(", "o_list", ")", "==", "1", ":", "\n", "      ", "f", ".", "write", "(", "\"o = \"", "+", "o_list", "[", "0", "]", "+", "\";\"", ")", "\n", "", "elif", "len", "(", "o_list", ")", "==", "2", ":", "\n", "      ", "cond", "=", "\"( \"", "+", "o_list", "[", "0", "]", "+", "\" == \"", "+", "o_list", "[", "1", "]", "+", "\" ) \"", "\n", "n1", "=", "o_list", "[", "0", "]", "\n", "n0", "=", "\"( ( \"", "+", "\" + \"", ".", "join", "(", "o_list", ")", "+", "\" ) >> 1 )\"", "\n", "f", ".", "write", "(", "\"o = \"", "+", "cond", "+", "\"? \"", "+", "n1", "+", "\": \"", "+", "n0", ")", "\n", "", "elif", "len", "(", "o_list", ")", "==", "3", ":", "\n", "      ", "cond", "=", "(", "\n", "\"( \"", "+", "\n", "\"( \"", "+", "\" == \"", ".", "join", "(", "o_list", "[", "0", ":", "2", "]", ")", "+", "\" )?\"", "+", "o_list", "[", "0", "]", "+", "\":\"", "+", "\n", "\"( \"", "+", "\" == \"", ".", "join", "(", "o_list", "[", "1", ":", "]", ")", "+", "\" )?\"", "+", "o_list", "[", "1", "]", "+", "\":\"", "+", "\n", "\"( \"", "+", "\" == \"", ".", "join", "(", "[", "o_list", "[", "0", "]", ",", "o_list", "[", "2", "]", "]", ")", "+", "\" )?\"", "+", "o_list", "[", "0", "]", "+", "\n", "\":\"", "+", "\"( \"", "+", "\" < \"", ".", "join", "(", "o_list", "[", "0", ":", "2", "]", ")", "+", "\" ) ?\"", "+", "\n", "\"( ( \"", "+", "\" < \"", ".", "join", "(", "o_list", "[", "1", ":", "]", ")", "+", "\" ) ?\"", "+", "o_list", "[", "1", "]", "+", "\":\"", "+", "\n", "o_list", "[", "2", "]", "+", "\" ) : \"", "+", "\n", "\"( ( \"", "+", "\" < \"", ".", "join", "(", "[", "o_list", "[", "0", "]", ",", "o_list", "[", "2", "]", "]", ")", "+", "\" ) ?\"", "+", "o_list", "[", "0", "]", "+", "\n", "\":\"", "+", "o_list", "[", "2", "]", "+", "\" )\"", "\n", ")", "\n", "f", ".", "write", "(", "\"o = \"", "+", "cond", "+", "\";\\n\"", ")", "\n", "", "if", "is_v", ":", "\n", "      ", "f", ".", "write", "(", "\"endmodule\"", ")", "\n", "", "else", ":", "\n", "      ", "f", ".", "write", "(", "\"}\"", ")", "\n", "\n", "", "f", ".", "close", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.fit_parallel": [[24, 30], ["random_tree.RandomTree", "random_tree.RandomTree.fit"], "function", ["home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit"], ["def", "fit_parallel", "(", "max_depth", ",", "min_size", ",", "sample", ",", "mask_stuck_at_values", ")", ":", "\n", "\n", "  ", "tree", "=", "RandomTree", "(", "max_depth", ",", "min_size", ")", "\n", "tree", ".", "fit", "(", "sample", ",", "mask_stuck_at_values", ")", "\n", "\n", "return", "tree", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.gen_random_tree.gen_random_tree_cc": [[26, 55], ["numpy.zeros", "numpy.zeros", "range", "len", "stack.pop", "stack.append", "stack.append", "print", "print"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["def", "gen_random_tree_cc", "(", "tree", ")", ":", "\n", "  ", "n_nodes", "=", "tree", ".", "node_count", "\n", "children_left", "=", "tree", ".", "children_left", "\n", "children_right", "=", "tree", ".", "children_right", "\n", "feature", "=", "tree", ".", "feature", "\n", "threshold", "=", "tree", ".", "threshold", "\n", "\n", "node_depth", "=", "np", ".", "zeros", "(", "shape", "=", "n_nodes", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "is_leaves", "=", "np", ".", "zeros", "(", "shape", "=", "n_nodes", ",", "dtype", "=", "bool", ")", "\n", "\n", "stack", "=", "[", "(", "0", ",", "-", "1", ")", "]", "\n", "\n", "while", "(", "len", "(", "stack", ")", ">", "0", ")", ":", "\n", "    ", "node_id", ",", "parent_depth", "=", "stack", ".", "pop", "(", ")", "\n", "node_depth", "[", "node_id", "]", "=", "parent_depth", "+", "1", "\n", "\n", "if", "children_left", "[", "node_id", "]", "!=", "children_right", "[", "node_id", "]", ":", "\n", "      ", "stack", ".", "append", "(", "(", "chidren_left", "[", "node_id", "]", ",", "parent_depth", "+", "1", ")", ")", "\n", "stack", ".", "append", "(", "(", "children_right", "[", "node_id", "]", ",", "parent_depth", "+", "1", ")", ")", "\n", "", "else", ":", "\n", "      ", "is_leaves", "[", "node_id", "]", "=", "True", "\n", "\n", "", "", "for", "i", "in", "range", "(", "n_nodes", ")", ":", "\n", "    ", "if", "is_leaves", "[", "i", "]", ":", "\n", "      ", "print", "(", "\"{}n_{} leaf node.\"", ".", "format", "(", "\"  \"", "*", "node_depth", "[", "i", "]", ",", "i", ")", ")", "\n", "", "else", ":", "\n", "      ", "print", "(", "\"{}n_{} (i_{} <= {}) ? n_{} : n_{}\"", ".", "format", "(", "\n", "\"  \"", "*", "node_depth", "[", "i", "]", ",", "i", ",", "feature", "[", "i", "]", ",", "threshold", "[", "i", "]", ",", "\n", "children_left", "[", "i", "]", ",", "children_right", "[", "i", "]", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.utils.str_column_to_float": [[30, 34], ["float", "row[].strip"], "function", ["None"], ["\n", "", "raise", "ValueError", "(", "\"accepted paddings are 'valid', 'same' or 'full', found \"", "+", "\n", "padding", ")", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.utils.str_column_to_int": [[35, 39], ["int", "row[].strip"], "function", ["None"], ["", "def", "get_quantized_bits_dict", "(", "bits", ",", "ibits", ",", "sign", "=", "False", ",", "mode", "=", "\"bin\"", ")", ":", "\n", "  ", "\"\"\"Returns map from floating values to bit encoding.\"\"\"", "\n", "\n", "o_dict", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.utils.str_column_to_number": [[40, 70], ["set", "dict", "enumerate", "int", "float"], "function", ["None"], ["n_bits", "=", "bits", "\n", "\n", "for", "b", "in", "range", "(", "1", "<<", "(", "bits", "-", "sign", ")", ")", ":", "\n", "    ", "v", "=", "(", "1.0", "*", "b", ")", "*", "(", "1", "<<", "ibits", ")", "/", "(", "1", "<<", "bits", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "      ", "b_str", "=", "bin", "(", "b", ")", "[", "2", ":", "]", "\n", "b_str", "=", "\"0\"", "*", "(", "n_bits", "-", "len", "(", "b_str", ")", ")", "+", "b_str", "\n", "", "else", ":", "# mode == \"dec\":", "\n", "      ", "b_str", "=", "str", "(", "b", ")", "\n", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "if", "b", ">", "0", "and", "sign", ":", "\n", "      ", "if", "mode", "==", "\"bin\"", ":", "\n", "        ", "b_str", "=", "bin", "(", "-", "b", "&", "(", "(", "1", "<<", "n_bits", ")", "-", "1", ")", ")", "[", "2", ":", "]", "\n", "", "else", ":", "# mode == \"dec\"", "\n", "        ", "b_str", "=", "str", "(", "-", "b", ")", "\n", "\n", "", "o_dict", "[", "-", "v", "]", "=", "b_str", "\n", "\n", "", "", "if", "sign", ":", "\n", "    ", "v", "=", "(", "1.0", "*", "(", "1", "<<", "(", "bits", "-", "sign", ")", ")", ")", "*", "(", "1", "<<", "ibits", ")", "/", "(", "1", "<<", "bits", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "      ", "b_str", "=", "bin", "(", "-", "(", "1", "<<", "(", "bits", "-", "sign", ")", ")", "&", "(", "(", "1", "<<", "bits", ")", "-", "1", ")", ")", "[", "2", ":", "]", "\n", "", "else", ":", "\n", "      ", "b_str", "=", "str", "(", "-", "(", "1", "<<", "(", "bits", "-", "sign", ")", ")", ")", "\n", "", "o_dict", "[", "-", "v", "]", "=", "b_str", "\n", "", "return", "o_dict", "\n", "\n", "\n", "", "def", "get_quantized_po2_dict", "(", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.utils.load_csv": [[72, 91], ["list", "range", "utils.str_column_to_number", "numpy.array", "open", "csv.reader", "utils.str_column_to_int", "np.array.append", "len", "len"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.table.utils.str_column_to_number", "home.repos.pwc.inspect_result.google_qkeras.table.utils.str_column_to_int"], ["  ", "\"\"\"Returns map from floating values to bit encoding.\"\"\"", "\n", "\n", "# if make_smaller_zero we will make sure smaller number is 000...0", "\n", "\n", "# mode = \"bin\" |-> make_smaller_zero", "\n", "\n", "assert", "mode", "!=", "\"bin\"", "or", "make_smaller_zero", "\n", "\n", "o_dict", "=", "{", "}", "\n", "\n", "if", "max_exp", ">", "0", ":", "\n", "    ", "v", "=", "1.0", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "      ", "b_str", "=", "\"0\"", "*", "bits", "\n", "", "else", ":", "\n", "      ", "b_str", "=", "\"1\"", "\n", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "if", "sign", ":", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.utils.load_pla": [[93, 104], ["list", "parser.parse", "zip", "numpy.array", "np.array.append", "sum", "range", "len", "len"], "function", ["home.repos.pwc.inspect_result.google_qkeras.table.parser.parse", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["if", "mode", "==", "\"bin\"", ":", "\n", "        ", "b_str", "=", "\"1\"", "+", "\"0\"", "*", "(", "bits", "-", "sign", ")", "\n", "", "else", ":", "\n", "        ", "b_str", "=", "\"-1\"", "\n", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "", "", "for", "b", "in", "range", "(", "1", ",", "1", "<<", "(", "bits", "-", "sign", "-", "1", ")", ")", ":", "\n", "    ", "v", "=", "np", ".", "power", "(", "2.0", ",", "-", "b", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "      ", "b_sign", "=", "\"0\"", "if", "sign", "else", "\"\"", "\n", "b_str", "=", "b_sign", "+", "bin", "(", "(", "-", "b", ")", "&", "(", "(", "1", "<<", "(", "bits", "-", "sign", "+", "1", ")", ")", "-", "1", ")", ")", "[", "3", ":", "]", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.random_forest.utils.load": [[106, 117], ["filename.split", "print", "utils.load_pla", "utils.load_csv"], "function", ["home.repos.pwc.inspect_result.google_qkeras.table.utils.load_pla", "home.repos.pwc.inspect_result.google_qkeras.table.utils.load_csv"], ["      ", "b_str", "=", "str", "(", "v", ")", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "if", "b", "<=", "max_exp", ":", "\n", "      ", "v", "=", "np", ".", "power", "(", "2.0", ",", "b", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "        ", "b_str", "=", "bin", "(", "b", ")", "[", "2", ":", "]", "\n", "b_str", "=", "b_sign", "+", "\"0\"", "*", "(", "bits", "-", "sign", "-", "len", "(", "b_str", ")", ")", "+", "b_str", "\n", "", "else", ":", "\n", "        ", "b_str", "=", "str", "(", "v", ")", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.parser.PLA.__init__": [[29, 32], ["None"], "methods", ["None"], ["  ", "def", "__init__", "(", "self", ")", ":", "\n", "    ", "self", ".", "pla_i", "=", "[", "]", "\n", "self", ".", "pla_o", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.parser.t_NUMBER": [[62, 65], ["None"], "function", ["None"], ["def", "t_NUMBER", "(", "t", ")", ":", "\n", "  ", "r\"[\\d\\-]+\"", "\n", "return", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.parser.t_NEWLINE": [[66, 70], ["t.value.count"], "function", ["None"], ["", "def", "t_NEWLINE", "(", "t", ")", ":", "\n", "  ", "r\"\\n+\"", "\n", "t", ".", "lexer", ".", "lineno", "+=", "t", ".", "value", ".", "count", "(", "\"\\n\"", ")", "\n", "return", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.parser.t_error": [[71, 74], ["print", "t.lexer.skip"], "function", ["None"], ["", "def", "t_error", "(", "t", ")", ":", "\n", "  ", "print", "(", "\"Illegal character '{}'\"", ".", "format", "(", "t", ".", "value", ")", ")", "\n", "t", ".", "lexer", ".", "skip", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.parser.p_pla": [[77, 79], ["None"], "function", ["None"], ["def", "p_pla", "(", "p", ")", ":", "\n", "  ", "\"\"\"pla : pla_declarations pla_table pla_end\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.parser.p_pla_declarations": [[80, 83], ["None"], "function", ["None"], ["", "def", "p_pla_declarations", "(", "p", ")", ":", "\n", "  ", "\"\"\"pla_declarations : pla_declarations pla_declaration\n                      | pla_declaration\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.parser.p_pla_declaration": [[84, 109], ["p[].lower", "int", "int", "int"], "function", ["None"], ["", "def", "p_pla_declaration", "(", "p", ")", ":", "\n", "  ", "\"\"\"pla_declaration : I NUMBER NEWLINE\n                     | O NUMBER NEWLINE\n                     | P NUMBER NEWLINE\n                     | MV number_list NEWLINE\n                     | ILB symbol_list NEWLINE\n                     | OB symbol_list NEWLINE\n                     | L NUMBER symbol_list NEWLINE\n                     | TYPE SYMBOL NEWLINE\n  \"\"\"", "\n", "token", "=", "p", "[", "1", "]", ".", "lower", "(", ")", "\n", "if", "token", "==", "\".i\"", ":", "\n", "    ", "pla", ".", "ni", "=", "int", "(", "p", "[", "2", "]", ")", "\n", "", "elif", "token", "==", "\".o\"", ":", "\n", "    ", "pla", ".", "no", "=", "int", "(", "p", "[", "2", "]", ")", "\n", "", "elif", "token", "==", "\".mv\"", ":", "\n", "    ", "pla", ".", "mv", "=", "[", "int", "(", "v", ")", "for", "v", "in", "p", "[", "2", "]", "]", "\n", "", "elif", "token", "==", "\".ilb\"", ":", "\n", "    ", "pla", ".", "ilb", "=", "p", "[", "2", "]", "\n", "", "elif", "token", "==", "\".ob\"", ":", "\n", "    ", "pla", ".", "ob", "=", "p", "[", "2", "]", "\n", "", "elif", "token", "==", "\".l\"", ":", "\n", "    ", "pla", ".", "label", "=", "p", "[", "2", "]", "\n", "", "elif", "token", "==", "\".type\"", ":", "\n", "    ", "pla", ".", "set_type", "=", "p", "[", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.parser.p_pla_table": [[111, 127], ["pla.pla_i.append", "pla.pla_o.append", "len", "hasattr", "hasattr"], "function", ["None"], ["", "", "def", "p_pla_table", "(", "p", ")", ":", "\n", "  ", "\"\"\"pla_table : pla_table number_symbol_list NEWLINE\n               | number_symbol_list NEWLINE\"\"\"", "\n", "if", "len", "(", "p", "[", "1", ":", "]", ")", "==", "3", ":", "\n", "    ", "line", "=", "\"\"", ".", "join", "(", "p", "[", "2", "]", ")", "\n", "", "else", ":", "\n", "    ", "line", "=", "\"\"", ".", "join", "(", "p", "[", "1", "]", ")", "\n", "\n", "", "assert", "hasattr", "(", "pla", ",", "\"ni\"", ")", "and", "hasattr", "(", "pla", ",", "\"no\"", ")", "\n", "\n", "# right now we only process binary functions", "\n", "\n", "line", "=", "[", "_1", "if", "v", "==", "\"1\"", "else", "_0", "if", "v", "==", "\"0\"", "else", "_X", "for", "v", "in", "line", "]", "\n", "\n", "pla", ".", "pla_i", ".", "append", "(", "line", "[", "0", ":", "pla", ".", "ni", "]", ")", "\n", "pla", ".", "pla_o", ".", "append", "(", "line", "[", "pla", ".", "ni", ":", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.parser.p_pla_end": [[129, 132], ["None"], "function", ["None"], ["", "def", "p_pla_end", "(", "p", ")", ":", "\n", "  ", "\"\"\"pla_end : E opt_new_line\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.parser.p_opt_new_line": [[134, 139], ["None"], "function", ["None"], ["", "def", "p_opt_new_line", "(", "p", ")", ":", "\n", "  ", "\"\"\"opt_new_line : NEWLINE\n                  |\n  \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.parser.p_number_list": [[141, 149], ["len"], "function", ["None"], ["", "def", "p_number_list", "(", "p", ")", ":", "\n", "  ", "\"\"\"number_list : number_list NUMBER\n                 | NUMBER\n  \"\"\"", "\n", "if", "len", "(", "p", "[", "1", ":", "]", ")", "==", "2", ":", "\n", "    ", "p", "[", "0", "]", "=", "p", "[", "1", "]", "+", "[", "p", "[", "2", "]", "]", "\n", "", "else", ":", "\n", "    ", "p", "[", "0", "]", "=", "[", "p", "[", "1", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.parser.p_symbol_list": [[151, 159], ["len"], "function", ["None"], ["", "", "def", "p_symbol_list", "(", "p", ")", ":", "\n", "  ", "\"\"\"symbol_list : symbol_list SYMBOL\n                 | SYMBOL\n  \"\"\"", "\n", "if", "len", "(", "p", "[", "1", ":", "]", ")", "==", "2", ":", "\n", "    ", "p", "[", "0", "]", "=", "p", "[", "1", "]", "+", "[", "p", "[", "2", "]", "]", "\n", "", "else", ":", "\n", "    ", "p", "[", "0", "]", "=", "[", "p", "[", "1", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.parser.p_number_symbol_list": [[161, 169], ["len"], "function", ["None"], ["", "", "def", "p_number_symbol_list", "(", "p", ")", ":", "\n", "  ", "\"\"\"number_symbol_list : number_symbol_list number_or_symbol\n                        | number_or_symbol\n  \"\"\"", "\n", "if", "len", "(", "p", "[", "1", ":", "]", ")", "==", "2", ":", "\n", "    ", "p", "[", "0", "]", "=", "p", "[", "1", "]", "+", "[", "p", "[", "2", "]", "]", "\n", "", "else", ":", "\n", "    ", "p", "[", "0", "]", "=", "[", "p", "[", "1", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.parser.p_number_or_symbol": [[171, 176], ["None"], "function", ["None"], ["", "", "def", "p_number_or_symbol", "(", "p", ")", ":", "\n", "  ", "\"\"\"number_or_symbol : NUMBER\n                      | SYMBOL\n  \"\"\"", "\n", "p", "[", "0", "]", "=", "p", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.parser.p_error": [[178, 180], ["print"], "function", ["None"], ["", "def", "p_error", "(", "p", ")", ":", "\n", "  ", "print", "(", "\"Error text at {}\"", ".", "format", "(", "p", ")", ")", "#p.value))", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.parser.get_tokens": [[183, 186], ["ply.lex.input", "open().readlines", "open"], "function", ["None"], ["def", "get_tokens", "(", "fn", ")", ":", "\n", "  ", "lex", ".", "input", "(", "\"\"", ".", "join", "(", "open", "(", "fn", ")", ".", "readlines", "(", ")", ")", ")", "\n", "return", "lex", ".", "token", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.parser.parse": [[187, 194], ["ply.yacc.parse", "numpy.array", "numpy.array", "open().readlines", "open"], "function", ["home.repos.pwc.inspect_result.google_qkeras.table.parser.parse"], ["", "def", "parse", "(", "fn", ")", ":", "\n", "  ", "yacc", ".", "parse", "(", "\"\"", ".", "join", "(", "open", "(", "fn", ")", ".", "readlines", "(", ")", ")", ")", "\n", "\n", "pla", ".", "pla_i", "=", "np", ".", "array", "(", "pla", ".", "pla_i", ")", "\n", "pla", ".", "pla_o", "=", "np", ".", "array", "(", "pla", ".", "pla_o", ")", "\n", "\n", "return", "pla", "\n", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.table.utils.str_column_to_float": [[31, 35], ["float", "row[].strip"], "function", ["None"], ["", "raise", "ValueError", "(", "\"accepted paddings are 'valid', 'same' or 'full', found \"", "+", "\n", "padding", ")", "\n", "\n", "\n", "", "def", "get_quantized_bits_dict", "(", "bits", ",", "ibits", ",", "sign", "=", "False", ",", "mode", "=", "\"bin\"", ")", ":", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.utils.str_column_to_int": [[36, 41], ["int", "row[].strip"], "function", ["None"], ["  ", "\"\"\"Returns map from floating values to bit encoding.\"\"\"", "\n", "\n", "o_dict", "=", "{", "}", "\n", "\n", "n_bits", "=", "bits", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.utils.str_column_to_number": [[42, 72], ["set", "dict", "enumerate", "int", "float"], "function", ["None"], ["for", "b", "in", "range", "(", "1", "<<", "(", "bits", "-", "sign", ")", ")", ":", "\n", "    ", "v", "=", "(", "1.0", "*", "b", ")", "*", "(", "1", "<<", "ibits", ")", "/", "(", "1", "<<", "bits", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "      ", "b_str", "=", "bin", "(", "b", ")", "[", "2", ":", "]", "\n", "b_str", "=", "\"0\"", "*", "(", "n_bits", "-", "len", "(", "b_str", ")", ")", "+", "b_str", "\n", "", "else", ":", "# mode == \"dec\":", "\n", "      ", "b_str", "=", "str", "(", "b", ")", "\n", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "if", "b", ">", "0", "and", "sign", ":", "\n", "      ", "if", "mode", "==", "\"bin\"", ":", "\n", "        ", "b_str", "=", "bin", "(", "-", "b", "&", "(", "(", "1", "<<", "n_bits", ")", "-", "1", ")", ")", "[", "2", ":", "]", "\n", "", "else", ":", "# mode == \"dec\"", "\n", "        ", "b_str", "=", "str", "(", "-", "b", ")", "\n", "\n", "", "o_dict", "[", "-", "v", "]", "=", "b_str", "\n", "\n", "", "", "if", "sign", ":", "\n", "    ", "v", "=", "(", "1.0", "*", "(", "1", "<<", "(", "bits", "-", "sign", ")", ")", ")", "*", "(", "1", "<<", "ibits", ")", "/", "(", "1", "<<", "bits", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "      ", "b_str", "=", "bin", "(", "-", "(", "1", "<<", "(", "bits", "-", "sign", ")", ")", "&", "(", "(", "1", "<<", "bits", ")", "-", "1", ")", ")", "[", "2", ":", "]", "\n", "", "else", ":", "\n", "      ", "b_str", "=", "str", "(", "-", "(", "1", "<<", "(", "bits", "-", "sign", ")", ")", ")", "\n", "", "o_dict", "[", "-", "v", "]", "=", "b_str", "\n", "", "return", "o_dict", "\n", "\n", "\n", "", "def", "get_quantized_po2_dict", "(", "\n", "bits", ",", "max_exp", ",", "sign", "=", "False", ",", "make_smaller_zero", "=", "True", ",", "mode", "=", "\"bin\"", ")", ":", "\n", "  ", "\"\"\"Returns map from floating values to bit encoding.\"\"\"", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.utils.int2bin": [[74, 77], ["format", "int", "str"], "function", ["None"], ["# if make_smaller_zero we will make sure smaller number is 000...0", "\n", "\n", "# mode = \"bin\" |-> make_smaller_zero", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.utils.load_csv": [[79, 92], ["list", "numpy.array", "open", "csv.reader", "list.append"], "function", ["None"], ["\n", "o_dict", "=", "{", "}", "\n", "\n", "if", "max_exp", ">", "0", ":", "\n", "    ", "v", "=", "1.0", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "      ", "b_str", "=", "\"0\"", "*", "bits", "\n", "", "else", ":", "\n", "      ", "b_str", "=", "\"1\"", "\n", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "if", "sign", ":", "\n", "      ", "v", "=", "-", "1.0", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.utils.load_pla": [[94, 105], ["list", "parser.parse", "zip", "numpy.array", "np.array.append", "sum", "range", "len", "len"], "function", ["home.repos.pwc.inspect_result.google_qkeras.table.parser.parse", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["        ", "b_str", "=", "\"1\"", "+", "\"0\"", "*", "(", "bits", "-", "sign", ")", "\n", "", "else", ":", "\n", "        ", "b_str", "=", "\"-1\"", "\n", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "", "", "for", "b", "in", "range", "(", "1", ",", "1", "<<", "(", "bits", "-", "sign", "-", "1", ")", ")", ":", "\n", "    ", "v", "=", "np", ".", "power", "(", "2.0", ",", "-", "b", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "      ", "b_sign", "=", "\"0\"", "if", "sign", "else", "\"\"", "\n", "b_str", "=", "b_sign", "+", "bin", "(", "(", "-", "b", ")", "&", "(", "(", "1", "<<", "(", "bits", "-", "sign", "+", "1", ")", ")", "-", "1", ")", ")", "[", "3", ":", "]", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.table.utils.load": [[107, 118], ["filename.split", "print", "utils.load_pla", "utils.load_csv"], "function", ["home.repos.pwc.inspect_result.google_qkeras.table.utils.load_pla", "home.repos.pwc.inspect_result.google_qkeras.table.utils.load_csv"], ["", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "if", "b", "<=", "max_exp", ":", "\n", "      ", "v", "=", "np", ".", "power", "(", "2.0", ",", "b", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "        ", "b_str", "=", "bin", "(", "b", ")", "[", "2", ":", "]", "\n", "b_str", "=", "b_sign", "+", "\"0\"", "*", "(", "bits", "-", "sign", "-", "len", "(", "b_str", ")", ")", "+", "b_str", "\n", "", "else", ":", "\n", "        ", "b_str", "=", "str", "(", "v", ")", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "", "if", "sign", ":", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.examples.example_qdense.QDenseModel": [[49, 75], ["tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "tensorflow.keras.models.Model.summary", "tensorflow.keras.models.Model.compile", "qkeras.print_qstats", "qkeras.QActivation", "qkeras.QDense", "qkeras.QActivation", "qkeras.QDense", "tensorflow.keras.layers.Activation", "tensorflow.keras.models.Model.load_weights", "qkeras.ternary", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qtools.interface.print_qstats"], ["def", "QDenseModel", "(", "weights_f", ",", "load_weights", "=", "False", ")", ":", "\n", "  ", "\"\"\"Construct QDenseModel.\"\"\"", "\n", "\n", "x", "=", "x_in", "=", "Input", "(", "(", "RESHAPED", ",", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(4)\"", ",", "name", "=", "\"act_i\"", ")", "(", "x", ")", "\n", "x", "=", "QDense", "(", "N_HIDDEN", ",", "kernel_quantizer", "=", "ternary", "(", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "name", "=", "\"dense0\"", ")", "(", "x", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(2)\"", ",", "name", "=", "\"act0\"", ")", "(", "x", ")", "\n", "x", "=", "QDense", "(", "\n", "NB_CLASSES", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"dense2\"", ")", "(", "\n", "x", ")", "\n", "x", "=", "Activation", "(", "\"softmax\"", ",", "name", "=", "\"softmax\"", ")", "(", "x", ")", "\n", "\n", "model", "=", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "model", ".", "summary", "(", ")", "\n", "model", ".", "compile", "(", "loss", "=", "\"categorical_crossentropy\"", ",", "\n", "optimizer", "=", "OPTIMIZER", ",", "metrics", "=", "[", "\"accuracy\"", "]", ")", "\n", "\n", "if", "load_weights", "and", "weights_f", ":", "\n", "    ", "model", ".", "load_weights", "(", "weights_f", ")", "\n", "\n", "", "print_qstats", "(", "model", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.examples.example_qdense.UseNetwork": [[77, 119], ["example_qdense.QDenseModel", "tensorflow.keras.datasets.mnist.load_data", "x_train_.astype.reshape", "x_test_.astype.reshape", "x_train_.astype.astype", "x_test_.astype.astype", "print", "print", "tensorflow.keras.utils.to_categorical", "tensorflow.keras.utils.to_categorical", "QDenseModel.evaluate", "qkeras.print_qstats", "print", "print", "QDenseModel.fit", "QDenseModel.save_weights"], "function", ["home.repos.pwc.inspect_result.google_qkeras.examples.example_qdense.QDenseModel", "home.repos.pwc.inspect_result.google_qkeras.qtools.interface.print_qstats", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit"], ["", "def", "UseNetwork", "(", "weights_f", ",", "load_weights", "=", "False", ")", ":", "\n", "  ", "\"\"\"Use DenseModel.\n\n  Args:\n    weights_f: weight file location.\n    load_weights: load weights when it is True.\n  \"\"\"", "\n", "model", "=", "QDenseModel", "(", "weights_f", ",", "load_weights", ")", "\n", "\n", "batch_size", "=", "BATCH_SIZE", "\n", "(", "x_train_", ",", "y_train_", ")", ",", "(", "x_test_", ",", "y_test_", ")", "=", "mnist", ".", "load_data", "(", ")", "\n", "\n", "x_train_", "=", "x_train_", ".", "reshape", "(", "60000", ",", "RESHAPED", ")", "\n", "x_test_", "=", "x_test_", ".", "reshape", "(", "10000", ",", "RESHAPED", ")", "\n", "x_train_", "=", "x_train_", ".", "astype", "(", "\"float32\"", ")", "\n", "x_test_", "=", "x_test_", ".", "astype", "(", "\"float32\"", ")", "\n", "\n", "x_train_", "/=", "255", "\n", "x_test_", "/=", "255", "\n", "\n", "print", "(", "x_train_", ".", "shape", "[", "0", "]", ",", "\"train samples\"", ")", "\n", "print", "(", "x_test_", ".", "shape", "[", "0", "]", ",", "\"test samples\"", ")", "\n", "\n", "y_train_", "=", "to_categorical", "(", "y_train_", ",", "NB_CLASSES", ")", "\n", "y_test_", "=", "to_categorical", "(", "y_test_", ",", "NB_CLASSES", ")", "\n", "\n", "if", "not", "load_weights", ":", "\n", "    ", "model", ".", "fit", "(", "\n", "x_train_", ",", "\n", "y_train_", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "epochs", "=", "NB_EPOCH", ",", "\n", "verbose", "=", "VERBOSE", ",", "\n", "validation_split", "=", "VALIDATION_SPLIT", ")", "\n", "\n", "if", "weights_f", ":", "\n", "      ", "model", ".", "save_weights", "(", "weights_f", ")", "\n", "\n", "", "", "score", "=", "model", ".", "evaluate", "(", "x_test_", ",", "y_test_", ",", "verbose", "=", "VERBOSE", ")", "\n", "print_qstats", "(", "model", ")", "\n", "print", "(", "\"Test score:\"", ",", "score", "[", "0", "]", ")", "\n", "print", "(", "\"Test accuracy:\"", ",", "score", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.examples.example_qdense.ParserArgs": [[121, 129], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["", "def", "ParserArgs", "(", ")", ":", "\n", "  ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-l\"", ",", "\"--load_weight\"", ",", "default", "=", "\"0\"", ",", "\n", "help", "=", "\"\"\"load weights directly from file.\n                            0 is to disable and train the network.\"\"\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-w\"", ",", "\"--weight_file\"", ",", "default", "=", "None", ")", "\n", "a", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "a", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.examples.example_mnist_prune.build_model": [[51, 79], ["tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "qkeras.QConv2D", "qkeras.QActivation", "qkeras.QConv2D", "qkeras.QActivation", "qkeras.QConv2D", "qkeras.QActivation", "tensorflow.keras.layers.Flatten", "qkeras.QDense", "tensorflow.keras.layers.Activation", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits"], "function", ["None"], ["def", "build_model", "(", "input_shape", ")", ":", "\n", "    ", "x", "=", "x_in", "=", "Input", "(", "shape", "=", "input_shape", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QConv2D", "(", "\n", "32", ",", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"conv2d_0_m\"", ")", "(", "x", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(4,0)\"", ",", "name", "=", "\"act0_m\"", ")", "(", "x", ")", "\n", "x", "=", "QConv2D", "(", "\n", "64", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"conv2d_1_m\"", ")", "(", "x", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(4,0)\"", ",", "name", "=", "\"act1_m\"", ")", "(", "x", ")", "\n", "x", "=", "QConv2D", "(", "\n", "64", ",", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"conv2d_2_m\"", ")", "(", "x", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(4,0)\"", ",", "name", "=", "\"act2_m\"", ")", "(", "x", ")", "\n", "x", "=", "Flatten", "(", ")", "(", "x", ")", "\n", "x", "=", "QDense", "(", "num_classes", ",", "kernel_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"dense\"", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "\"softmax\"", ",", "name", "=", "\"softmax\"", ")", "(", "x", ")", "\n", "\n", "model", "=", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.examples.example_mnist_prune.build_layerwise_model": [[81, 116], ["tensorflow.keras.models.Sequential", "tensorflow_model_optimization.python.core.sparsity.keras.prune.prune_low_magnitude", "qkeras.QActivation", "tensorflow_model_optimization.python.core.sparsity.keras.prune.prune_low_magnitude", "qkeras.QActivation", "tensorflow_model_optimization.python.core.sparsity.keras.prune.prune_low_magnitude", "qkeras.QActivation", "tensorflow.keras.layers.Flatten", "tensorflow_model_optimization.python.core.sparsity.keras.prune.prune_low_magnitude", "tensorflow.keras.layers.Activation", "qkeras.QConv2D", "qkeras.QConv2D", "qkeras.QConv2D", "qkeras.QDense", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits"], "function", ["None"], ["", "def", "build_layerwise_model", "(", "input_shape", ",", "**", "pruning_params", ")", ":", "\n", "    ", "return", "Sequential", "(", "[", "\n", "prune", ".", "prune_low_magnitude", "(", "\n", "QConv2D", "(", "\n", "32", ",", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"conv2d_0_m\"", ")", ",", "\n", "input_shape", "=", "input_shape", ",", "\n", "**", "pruning_params", ")", ",", "\n", "QActivation", "(", "\"quantized_relu(4,0)\"", ",", "name", "=", "\"act0_m\"", ")", ",", "\n", "prune", ".", "prune_low_magnitude", "(", "\n", "QConv2D", "(", "\n", "64", ",", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"conv2d_1_m\"", ")", ",", "\n", "**", "pruning_params", ")", ",", "\n", "QActivation", "(", "\"quantized_relu(4,0)\"", ",", "name", "=", "\"act1_m\"", ")", ",", "\n", "prune", ".", "prune_low_magnitude", "(", "\n", "QConv2D", "(", "\n", "64", ",", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"conv2d_2_m\"", ")", ",", "\n", "**", "pruning_params", ")", ",", "\n", "QActivation", "(", "\"quantized_relu(4,0)\"", ",", "name", "=", "\"act2_m\"", ")", ",", "\n", "Flatten", "(", ")", ",", "\n", "prune", ".", "prune_low_magnitude", "(", "\n", "QDense", "(", "\n", "num_classes", ",", "kernel_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"dense\"", ")", ",", "\n", "**", "pruning_params", ")", ",", "\n", "Activation", "(", "\"softmax\"", ",", "name", "=", "\"softmax\"", ")", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.examples.example_mnist_prune.train_and_save": [[119, 161], ["model.compile", "model.summary", "model.fit", "model.evaluate", "print", "print", "qkeras.utils.print_model_sparsity", "tempfile.mkstemp", "print", "tensorflow.keras.models.save_model", "print", "qkeras.utils.load_qmodel.evaluate", "print", "print", "tensorflow_model_optimization.python.core.sparsity.keras.pruning_callbacks.UpdatePruningStep", "tensorflow_model_optimization.python.core.sparsity.keras.pruning_callbacks.PruningSummaries", "tensorflow_model_optimization.python.core.sparsity.keras.prune.prune_scope", "qkeras.utils.load_qmodel"], "function", ["home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.print_model_sparsity", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.load_qmodel"], ["", "def", "train_and_save", "(", "model", ",", "x_train", ",", "y_train", ",", "x_test", ",", "y_test", ")", ":", "\n", "    ", "model", ".", "compile", "(", "\n", "loss", "=", "\"categorical_crossentropy\"", ",", "\n", "optimizer", "=", "\"adam\"", ",", "\n", "metrics", "=", "[", "\"accuracy\"", "]", ")", "\n", "\n", "# Print the model summary.", "\n", "model", ".", "summary", "(", ")", "\n", "\n", "# Add a pruning step callback to peg the pruning step to the optimizer's", "\n", "# step. Also add a callback to add pruning summaries to tensorboard", "\n", "callbacks", "=", "[", "\n", "pruning_callbacks", ".", "UpdatePruningStep", "(", ")", ",", "\n", "#pruning_callbacks.PruningSummaries(log_dir=tempfile.mkdtemp())", "\n", "pruning_callbacks", ".", "PruningSummaries", "(", "log_dir", "=", "\"/tmp/mnist_prune\"", ")", "\n", "]", "\n", "\n", "model", ".", "fit", "(", "\n", "x_train", ",", "\n", "y_train", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "epochs", "=", "epochs", ",", "\n", "verbose", "=", "1", ",", "\n", "callbacks", "=", "callbacks", ",", "\n", "validation_data", "=", "(", "x_test", ",", "y_test", ")", ")", "\n", "score", "=", "model", ".", "evaluate", "(", "x_test", ",", "y_test", ",", "verbose", "=", "0", ")", "\n", "print", "(", "\"Test loss:\"", ",", "score", "[", "0", "]", ")", "\n", "print", "(", "\"Test accuracy:\"", ",", "score", "[", "1", "]", ")", "\n", "\n", "print_model_sparsity", "(", "model", ")", "\n", "\n", "# Export and import the model. Check that accuracy persists.", "\n", "_", ",", "keras_file", "=", "tempfile", ".", "mkstemp", "(", "\".h5\"", ")", "\n", "print", "(", "\"Saving model to: \"", ",", "keras_file", ")", "\n", "save_model", "(", "model", ",", "keras_file", ")", "\n", "\n", "print", "(", "\"Reloading model\"", ")", "\n", "with", "prune", ".", "prune_scope", "(", ")", ":", "\n", "        ", "loaded_model", "=", "load_qmodel", "(", "keras_file", ")", "\n", "", "score", "=", "loaded_model", ".", "evaluate", "(", "x_test", ",", "y_test", ",", "verbose", "=", "0", ")", "\n", "print", "(", "\"Test loss:\"", ",", "score", "[", "0", "]", ")", "\n", "print", "(", "\"Test accuracy:\"", ",", "score", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.examples.example_mnist_prune.main": [[163, 203], ["tensorflow.keras.datasets.mnist.load_data", "x_train.reshape.astype", "x_test.reshape.astype", "print", "print", "print", "tensorflow.keras.utils.to_categorical", "tensorflow.keras.utils.to_categorical", "example_mnist_prune.train_and_save", "tensorflow.image_data_format", "x_train.reshape.reshape", "x_test.reshape.reshape", "x_train.reshape.reshape", "x_test.reshape.reshape", "tensorflow_model_optimization.python.core.sparsity.keras.pruning_schedule.ConstantSparsity", "example_mnist_prune.build_model", "tensorflow_model_optimization.python.core.sparsity.keras.prune.prune_low_magnitude", "example_mnist_prune.build_layerwise_model"], "function", ["home.repos.pwc.inspect_result.google_qkeras.examples.example_mnist_prune.train_and_save", "home.repos.pwc.inspect_result.google_qkeras.examples.example_mnist_prune.build_model", "home.repos.pwc.inspect_result.google_qkeras.examples.example_mnist_prune.build_layerwise_model"], ["", "def", "main", "(", ")", ":", "\n", "# input image dimensions", "\n", "    ", "img_rows", ",", "img_cols", "=", "28", ",", "28", "\n", "\n", "# the data, shuffled and split between train and test sets", "\n", "(", "x_train", ",", "y_train", ")", ",", "(", "x_test", ",", "y_test", ")", "=", "mnist", ".", "load_data", "(", ")", "\n", "\n", "if", "K", ".", "image_data_format", "(", ")", "==", "\"channels_first\"", ":", "\n", "      ", "x_train", "=", "x_train", ".", "reshape", "(", "x_train", ".", "shape", "[", "0", "]", ",", "1", ",", "img_rows", ",", "img_cols", ")", "\n", "x_test", "=", "x_test", ".", "reshape", "(", "x_test", ".", "shape", "[", "0", "]", ",", "1", ",", "img_rows", ",", "img_cols", ")", "\n", "input_shape", "=", "(", "1", ",", "img_rows", ",", "img_cols", ")", "\n", "", "else", ":", "\n", "      ", "x_train", "=", "x_train", ".", "reshape", "(", "x_train", ".", "shape", "[", "0", "]", ",", "img_rows", ",", "img_cols", ",", "1", ")", "\n", "x_test", "=", "x_test", ".", "reshape", "(", "x_test", ".", "shape", "[", "0", "]", ",", "img_rows", ",", "img_cols", ",", "1", ")", "\n", "input_shape", "=", "(", "img_rows", ",", "img_cols", ",", "1", ")", "\n", "\n", "", "x_train", "=", "x_train", ".", "astype", "(", "\"float32\"", ")", "\n", "x_test", "=", "x_test", ".", "astype", "(", "\"float32\"", ")", "\n", "x_train", "/=", "255", "\n", "x_test", "/=", "255", "\n", "print", "(", "\"x_train shape:\"", ",", "x_train", ".", "shape", ")", "\n", "print", "(", "x_train", ".", "shape", "[", "0", "]", ",", "\"train samples\"", ")", "\n", "print", "(", "x_test", ".", "shape", "[", "0", "]", ",", "\"test samples\"", ")", "\n", "\n", "# convert class vectors to binary class matrices", "\n", "y_train", "=", "to_categorical", "(", "y_train", ",", "num_classes", ")", "\n", "y_test", "=", "to_categorical", "(", "y_test", ",", "num_classes", ")", "\n", "\n", "pruning_params", "=", "{", "\n", "\"pruning_schedule\"", ":", "\n", "pruning_schedule", ".", "ConstantSparsity", "(", "0.75", ",", "begin_step", "=", "2000", ",", "frequency", "=", "100", ")", "\n", "}", "\n", "\n", "if", "prune_whole_model", ":", "\n", "        ", "model", "=", "build_model", "(", "input_shape", ")", "\n", "model", "=", "prune", ".", "prune_low_magnitude", "(", "model", ",", "**", "pruning_params", ")", "\n", "", "else", ":", "\n", "        ", "model", "=", "build_layerwise_model", "(", "input_shape", ",", "**", "pruning_params", ")", "\n", "\n", "", "train_and_save", "(", "model", ",", "x_train", ",", "y_train", ",", "x_test", ",", "y_test", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.examples.example_mnist_bn.LearningRateAdjuster.__init__": [[53, 56], ["None"], "methods", ["None"], ["  ", "def", "__init__", "(", "self", ")", ":", "\n", "    ", "self", ".", "learning_rate_factor", "=", "1.0", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.examples.example_mnist_bn.LearningRateAdjuster.on_epoch_end": [[57, 76], ["tensorflow.get_value", "print", "tensorflow.eval", "numpy.max", "tensorflow.update", "layer.get_weights"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qtools.settings.ConfigClass.update", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights"], ["", "def", "on_epoch_end", "(", "self", ",", "epochs", ",", "logs", ")", ":", "\n", "    ", "max_variance", "=", "-", "1", "\n", "\n", "for", "layer", "in", "self", ".", "model", ".", "layers", ":", "\n", "      ", "if", "layer", ".", "__class__", ".", "__name__", "in", "[", "\n", "\"BatchNormalization\"", ",", "\n", "\"QBatchNormalization\"", "\n", "]", ":", "\n", "        ", "variance", "=", "np", ".", "max", "(", "layer", ".", "get_weights", "(", ")", "[", "-", "1", "]", ")", "\n", "if", "variance", ">", "max_variance", ":", "\n", "          ", "max_variance", "=", "variance", "\n", "\n", "", "", "", "if", "max_variance", ">", "32", "and", "self", ".", "learning_rate_factor", "<", "100", ":", "\n", "      ", "learning_rate", "=", "K", ".", "get_value", "(", "self", ".", "model", ".", "optimizer", ".", "learning_rate", ")", "\n", "self", ".", "learning_rate_factor", "/=", "2.0", "\n", "print", "(", "\"***** max_variance is {} / lr is {} *****\"", ".", "format", "(", "\n", "max_variance", ",", "learning_rate", ")", ")", "\n", "K", ".", "eval", "(", "K", ".", "update", "(", "\n", "self", ".", "model", ".", "optimizer", ".", "learning_rate", ",", "learning_rate", "/", "2.0", "\n", ")", ")", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.examples.example_act.main": [[43, 149], ["numpy.random.seed", "tensorflow.constant", "print", "print", "tensorflow.constant", "print", "tensorflow.constant", "tensorflow.constant", "print", "print", "print", "print", "print", "print", "tensorflow.constant", "print", "print", "print", "print", "print", "print", "tensorflow.constant", "print", "print", "tensorflow.eval", "range", "print", "print", "tensorflow.constant", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "qkeras.set_internal_sigmoid", "print", "print", "print", "print", "print", "print", "print", "print", "print", "qkeras.set_internal_sigmoid", "print", "print", "print", "print", "print", "print", "print", "print", "print", "qkeras.set_internal_sigmoid", "print", "print", "print", "print", "print", "print", "tensorflow.constant", "print", "tensorflow.eval().astype", "range", "print", "print", "print", "range", "range", "range", "qkeras.quantized_po2", "numpy.sum", "qkeras.quantized_relu_po2", "numpy.sum", "qkeras.quantized_relu_po2", "numpy.sum", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "numpy.arange", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "numpy.array", "numpy.sum", "tensorflow.eval().astype", "K.eval().astype.astype", "print", "numpy.round().astype", "tensorflow.eval().astype", "numpy.arange", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "numpy.arange", "tensorflow.eval().astype", "print", "numpy.round().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "print", "print", "print", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval().astype", "qkeras.stochastic_ternary", "tensorflow.eval", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval().astype", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "numpy.round", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "numpy.round", "tensorflow.eval", "tensorflow.eval", "qkeras.smooth_sigmoid", "qkeras.hard_sigmoid", "qkeras.hard_tanh", "qkeras.smooth_tanh", "list", "tensorflow.eval", "qkeras.hard_sigmoid", "qkeras.stochastic_binary", "tensorflow.eval", "tensorflow.eval", "tensorflow.eval", "qkeras.quantized_relu", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "tensorflow.eval", "numpy.sum().astype", "qkeras.ternary", "qkeras.binary", "qkeras.quantized_relu", "qkeras.quantized_relu", "qkeras.quantized_relu", "qkeras.quantized_relu", "qkeras.quantized_relu", "qkeras.quantized_relu", "qkeras.quantized_relu", "qkeras.quantized_relu", "qkeras.quantized_tanh", "qkeras.quantized_tanh", "qkeras.quantized_tanh", "qkeras.quantized_tanh", "qkeras.quantized_relu", "qkeras.quantized_relu", "qkeras.quantized_relu", "qkeras.quantized_relu", "qkeras.quantized_tanh", "qkeras.quantized_tanh", "qkeras.quantized_tanh", "qkeras.quantized_tanh", "qkeras.quantized_relu", "qkeras.quantized_relu", "qkeras.quantized_relu", "qkeras.quantized_relu", "qkeras.quantized_tanh", "qkeras.quantized_tanh", "qkeras.quantized_tanh", "qkeras.quantized_tanh", "qkeras.quantized_po2", "qkeras.quantized_po2", "qkeras.quantized_relu_po2", "qkeras.quantized_relu_po2", "qkeras.quantized_relu_po2", "qkeras.quantized_relu_po2", "numpy.sum", "qkeras.binary", "qkeras.bernoulli", "qkeras.binary", "qkeras.quantized_po2", "qkeras.quantized_relu_po2", "numpy.sum", "K.eval.astype"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.set_internal_sigmoid", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.set_internal_sigmoid", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.set_internal_sigmoid", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.smooth_sigmoid", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.hard_sigmoid", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.hard_tanh", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.smooth_tanh", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.hard_sigmoid"], ["def", "main", "(", ")", ":", "\n", "# check the mean value of samples from stochastic_rounding for po2", "\n", "  ", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "count", "=", "100000", "\n", "val", "=", "42", "\n", "a", "=", "K", ".", "constant", "(", "[", "val", "]", "*", "count", ")", "\n", "b", "=", "quantized_po2", "(", "use_stochastic_rounding", "=", "True", ")", "(", "a", ")", "\n", "res", "=", "np", ".", "sum", "(", "K", ".", "eval", "(", "b", ")", ")", "/", "count", "\n", "print", "(", "res", ",", "\"should be close to \"", ",", "val", ")", "\n", "b", "=", "quantized_relu_po2", "(", "use_stochastic_rounding", "=", "True", ")", "(", "a", ")", "\n", "res", "=", "np", ".", "sum", "(", "K", ".", "eval", "(", "b", ")", ")", "/", "count", "\n", "print", "(", "res", ",", "\"should be close to \"", ",", "val", ")", "\n", "a", "=", "K", ".", "constant", "(", "[", "-", "1", "]", "*", "count", ")", "\n", "b", "=", "quantized_relu_po2", "(", "use_stochastic_rounding", "=", "True", ")", "(", "a", ")", "\n", "res", "=", "np", ".", "sum", "(", "K", ".", "eval", "(", "b", ")", ")", "/", "count", "\n", "print", "(", "res", ",", "\"should be all \"", ",", "0", ")", "\n", "\n", "# non-stochastic rounding quantizer.", "\n", "a", "=", "K", ".", "constant", "(", "[", "-", "3.0", ",", "-", "2.0", ",", "-", "1.0", ",", "-", "0.5", ",", "0.0", ",", "0.5", ",", "1.0", ",", "2.0", ",", "3.0", "]", ")", "\n", "a", "=", "K", ".", "constant", "(", "[", "0.194336", "]", ")", "\n", "print", "(", "\" a =\"", ",", "K", ".", "eval", "(", "a", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qa =\"", ",", "K", ".", "eval", "(", "quantized_relu", "(", "6", ",", "2", ")", "(", "a", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"ss =\"", ",", "K", ".", "eval", "(", "smooth_sigmoid", "(", "a", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"hs =\"", ",", "K", ".", "eval", "(", "hard_sigmoid", "(", "a", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"ht =\"", ",", "K", ".", "eval", "(", "hard_tanh", "(", "a", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"st =\"", ",", "K", ".", "eval", "(", "smooth_tanh", "(", "a", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "c", "=", "K", ".", "constant", "(", "np", ".", "arange", "(", "-", "1.5", ",", "1.51", ",", "0.3", ")", ")", "\n", "print", "(", "\" c =\"", ",", "K", ".", "eval", "(", "c", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qb_111 =\"", ",", "K", ".", "eval", "(", "quantized_bits", "(", "1", ",", "1", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qb_210 =\"", ",", "K", ".", "eval", "(", "quantized_bits", "(", "2", ",", "1", ",", "0", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qb_211 =\"", ",", "K", ".", "eval", "(", "quantized_bits", "(", "2", ",", "1", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qb_300 =\"", ",", "K", ".", "eval", "(", "quantized_bits", "(", "3", ",", "0", ",", "0", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qb_301 =\"", ",", "K", ".", "eval", "(", "quantized_bits", "(", "3", ",", "0", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "c_1000", "=", "K", ".", "constant", "(", "np", ".", "array", "(", "[", "list", "(", "K", ".", "eval", "(", "c", ")", ")", "]", "*", "1000", ")", ")", "\n", "b", "=", "np", ".", "sum", "(", "K", ".", "eval", "(", "bernoulli", "(", ")", "(", "c_1000", ")", ")", ".", "astype", "(", "np", ".", "int32", ")", ",", "axis", "=", "0", ")", "/", "1000.0", "\n", "print", "(", "\"       hs =\"", ",", "K", ".", "eval", "(", "hard_sigmoid", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"    b_all =\"", ",", "b", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "T", "=", "0.0", "\n", "t", "=", "K", ".", "eval", "(", "stochastic_ternary", "(", "alpha", "=", "\"auto\"", ")", "(", "c_1000", ")", ")", "\n", "for", "i", "in", "range", "(", "10", ")", ":", "\n", "    ", "print", "(", "\"stochastic_ternary({}) =\"", ".", "format", "(", "i", ")", ",", "t", "[", "i", "]", ")", "\n", "", "print", "(", "\"   st_all =\"", ",", "np", ".", "round", "(", "\n", "np", ".", "sum", "(", "t", ".", "astype", "(", "np", ".", "float32", ")", ",", "axis", "=", "0", ")", ".", "astype", "(", "np", ".", "float16", ")", "/", "\n", "1000.0", ",", "2", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"  ternary =\"", ",", "K", ".", "eval", "(", "ternary", "(", "threshold", "=", "0.5", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "int32", ")", ")", "\n", "c", "=", "K", ".", "constant", "(", "np", ".", "arange", "(", "-", "1.5", ",", "1.51", ",", "0.3", ")", ")", "\n", "print", "(", "\" c =\"", ",", "K", ".", "eval", "(", "c", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\" b_10 =\"", ",", "K", ".", "eval", "(", "binary", "(", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qr_10 =\"", ",", "K", ".", "eval", "(", "quantized_relu", "(", "1", ",", "0", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qr_11 =\"", ",", "K", ".", "eval", "(", "quantized_relu", "(", "1", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qr_20 =\"", ",", "K", ".", "eval", "(", "quantized_relu", "(", "2", ",", "0", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qr_21 =\"", ",", "K", ".", "eval", "(", "quantized_relu", "(", "2", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qr_101 =\"", ",", "K", ".", "eval", "(", "quantized_relu", "(", "1", ",", "0", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qr_111 =\"", ",", "K", ".", "eval", "(", "quantized_relu", "(", "1", ",", "1", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qr_201 =\"", ",", "K", ".", "eval", "(", "quantized_relu", "(", "2", ",", "0", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qr_211 =\"", ",", "K", ".", "eval", "(", "quantized_relu", "(", "2", ",", "1", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qt_200 =\"", ",", "K", ".", "eval", "(", "quantized_tanh", "(", "2", ",", "0", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qt_210 =\"", ",", "K", ".", "eval", "(", "quantized_tanh", "(", "2", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qt_201 =\"", ",", "K", ".", "eval", "(", "quantized_tanh", "(", "2", ",", "0", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qt_211 =\"", ",", "K", ".", "eval", "(", "quantized_tanh", "(", "2", ",", "1", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "set_internal_sigmoid", "(", "\"smooth\"", ")", ";", "print", "(", "\"with smooth sigmoid\"", ")", "\n", "print", "(", "\"qr_101 =\"", ",", "K", ".", "eval", "(", "quantized_relu", "(", "1", ",", "0", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qr_111 =\"", ",", "K", ".", "eval", "(", "quantized_relu", "(", "1", ",", "1", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qr_201 =\"", ",", "K", ".", "eval", "(", "quantized_relu", "(", "2", ",", "0", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qr_211 =\"", ",", "K", ".", "eval", "(", "quantized_relu", "(", "2", ",", "1", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qt_200 =\"", ",", "K", ".", "eval", "(", "quantized_tanh", "(", "2", ",", "0", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qt_210 =\"", ",", "K", ".", "eval", "(", "quantized_tanh", "(", "2", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qt_201 =\"", ",", "K", ".", "eval", "(", "quantized_tanh", "(", "2", ",", "0", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qt_211 =\"", ",", "K", ".", "eval", "(", "quantized_tanh", "(", "2", ",", "1", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "set_internal_sigmoid", "(", "\"real\"", ")", ";", "print", "(", "\"with real sigmoid\"", ")", "\n", "print", "(", "\"qr_101 =\"", ",", "K", ".", "eval", "(", "quantized_relu", "(", "1", ",", "0", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qr_111 =\"", ",", "K", ".", "eval", "(", "quantized_relu", "(", "1", ",", "1", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qr_201 =\"", ",", "K", ".", "eval", "(", "quantized_relu", "(", "2", ",", "0", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qr_211 =\"", ",", "K", ".", "eval", "(", "quantized_relu", "(", "2", ",", "1", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qt_200 =\"", ",", "K", ".", "eval", "(", "quantized_tanh", "(", "2", ",", "0", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qt_210 =\"", ",", "K", ".", "eval", "(", "quantized_tanh", "(", "2", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qt_201 =\"", ",", "K", ".", "eval", "(", "quantized_tanh", "(", "2", ",", "0", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qt_211 =\"", ",", "K", ".", "eval", "(", "quantized_tanh", "(", "2", ",", "1", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "set_internal_sigmoid", "(", "\"hard\"", ")", "\n", "print", "(", "\" c =\"", ",", "K", ".", "eval", "(", "c", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"q2_31 =\"", ",", "K", ".", "eval", "(", "quantized_po2", "(", "3", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"q2_32 =\"", ",", "K", ".", "eval", "(", "quantized_po2", "(", "3", ",", "2", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qr2_21 =\"", ",", "K", ".", "eval", "(", "quantized_relu_po2", "(", "2", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qr2_22 =\"", ",", "K", ".", "eval", "(", "quantized_relu_po2", "(", "2", ",", "2", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\"qr2_44 =\"", ",", "K", ".", "eval", "(", "quantized_relu_po2", "(", "4", ",", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "\n", "# stochastic rounding", "\n", "c", "=", "K", ".", "constant", "(", "np", ".", "arange", "(", "-", "1.5", ",", "1.51", ",", "0.3", ")", ")", "\n", "print", "(", "\"q2_32_2 =\"", ",", "K", ".", "eval", "(", "quantized_relu_po2", "(", "32", ",", "2", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "b", "=", "K", ".", "eval", "(", "stochastic_binary", "(", ")", "(", "c_1000", ")", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "for", "i", "in", "range", "(", "5", ")", ":", "\n", "    ", "print", "(", "\"sbinary({}) =\"", ".", "format", "(", "i", ")", ",", "b", "[", "i", "]", ")", "\n", "", "print", "(", "\"sbinary =\"", ",", "np", ".", "round", "(", "np", ".", "sum", "(", "b", ",", "axis", "=", "0", ")", "/", "1000.0", ",", "2", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "print", "(", "\" binary =\"", ",", "K", ".", "eval", "(", "binary", "(", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "int32", ")", ")", "\n", "print", "(", "\" c      =\"", ",", "K", ".", "eval", "(", "c", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", "\n", "for", "i", "in", "range", "(", "10", ")", ":", "\n", "    ", "print", "(", "\" s_bin({}) =\"", ".", "format", "(", "i", ")", ",", "\n", "K", ".", "eval", "(", "binary", "(", "use_stochastic_rounding", "=", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "int32", ")", ")", "\n", "", "for", "i", "in", "range", "(", "10", ")", ":", "\n", "    ", "print", "(", "\" s_po2({}) =\"", ".", "format", "(", "i", ")", ",", "\n", "K", ".", "eval", "(", "quantized_po2", "(", "use_stochastic_rounding", "=", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "np", ".", "int32", ")", ")", "\n", "", "for", "i", "in", "range", "(", "10", ")", ":", "\n", "    ", "print", "(", "\n", "\" s_relu_po2({}) =\"", ".", "format", "(", "i", ")", ",", "\n", "K", ".", "eval", "(", "quantized_relu_po2", "(", "use_stochastic_rounding", "=", "1", ")", "(", "c", ")", ")", ".", "astype", "(", "\n", "np", ".", "int32", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.examples.example_qoctave.create_model": [[30, 154], ["tensorflow.keras.initializers.he_normal", "tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "QOctaveConv2D", "QOctaveConv2D", "QOctaveConv2D", "QOctaveConv2D", "QOctaveConv2D", "QOctaveConv2D", "UpSampling2D", "QConv2D", "Activation", "quantized_bits", "quantized_bits"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qoctave.QOctaveConv2D", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qoctave.QOctaveConv2D", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qoctave.QOctaveConv2D", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qoctave.QOctaveConv2D", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qoctave.QOctaveConv2D", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qoctave.QOctaveConv2D"], ["def", "create_model", "(", ")", ":", "\n", "  ", "\"\"\"use qocatve in network.\"\"\"", "\n", "kernel_initializer", "=", "initializers", ".", "he_normal", "(", "seed", "=", "42", ")", "\n", "\n", "x", "=", "x_in", "=", "Input", "(", "shape", "=", "(", "256", ",", "256", ",", "3", ")", ")", "\n", "\n", "# Block 1", "\n", "high", ",", "low", "=", "QOctaveConv2D", "(", "\n", "32", ",", "(", "3", ",", "3", ")", ",", "\n", "alpha", "=", "0.5", ",", "\n", "strides", "=", "(", "2", ",", "2", ")", ",", "\n", "padding", "=", "'valid'", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_initializer", "=", "\"zeros\"", ",", "\n", "bias_quantizer", "=", "\"quantized_bits(4,1)\"", ",", "\n", "depthwise_quantizer", "=", "\"quantized_bits(4,1)\"", ",", "\n", "depthwise_activation", "=", "\"quantized_bits(6,2,1)\"", ",", "\n", "pointwise_quantizer", "=", "\"quantized_bits(4,1)\"", ",", "\n", "acc_quantizer", "=", "\"quantized_bits(16,7,1)\"", ",", "\n", "activation", "=", "\"quantized_relu(6,2)\"", ",", "\n", "use_separable", "=", "True", ",", "\n", "name", "=", "'block1_conv1'", ")", "(", "[", "x", ",", "None", "]", ")", "\n", "\n", "# Block 2", "\n", "high", ",", "low", "=", "QOctaveConv2D", "(", "\n", "64", ",", "(", "3", ",", "3", ")", ",", "\n", "alpha", "=", "0.4", ",", "\n", "strides", "=", "(", "2", ",", "2", ")", ",", "\n", "padding", "=", "'same'", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_initializer", "=", "\"zeros\"", ",", "\n", "bias_quantizer", "=", "\"quantized_bits(4,1)\"", ",", "\n", "depthwise_quantizer", "=", "\"quantized_bits(4,1)\"", ",", "\n", "depthwise_activation", "=", "\"quantized_bits(6,2,1)\"", ",", "\n", "pointwise_quantizer", "=", "\"quantized_bits(4,1)\"", ",", "\n", "acc_quantizer", "=", "\"quantized_bits(16,7,1)\"", ",", "\n", "activation", "=", "\"quantized_relu(6,2)\"", ",", "\n", "use_separable", "=", "True", ",", "\n", "name", "=", "'block2_conv1'", ")", "(", "[", "high", ",", "low", "]", ")", "\n", "\n", "# Block 3", "\n", "high", ",", "low", "=", "QOctaveConv2D", "(", "\n", "64", ",", "(", "3", ",", "3", ")", ",", "\n", "alpha", "=", "0.4", ",", "\n", "strides", "=", "(", "2", ",", "2", ")", ",", "\n", "padding", "=", "'same'", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_initializer", "=", "\"zeros\"", ",", "\n", "bias_quantizer", "=", "\"quantized_bits(4,1)\"", ",", "\n", "depthwise_quantizer", "=", "\"quantized_bits(4,1)\"", ",", "\n", "depthwise_activation", "=", "\"quantized_bits(6,2,1)\"", ",", "\n", "pointwise_quantizer", "=", "\"quantized_bits(4,1)\"", ",", "\n", "acc_quantizer", "=", "\"quantized_bits(16,7,1)\"", ",", "\n", "activation", "=", "\"quantized_relu(6,2)\"", ",", "\n", "use_separable", "=", "True", ",", "\n", "name", "=", "'block3_conv1'", ")", "(", "[", "high", ",", "low", "]", ")", "\n", "\n", "high", ",", "low", "=", "QOctaveConv2D", "(", "\n", "32", ",", "(", "3", ",", "3", ")", ",", "\n", "alpha", "=", "0.4", ",", "\n", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "padding", "=", "'same'", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_initializer", "=", "'zeros'", ",", "\n", "bias_quantizer", "=", "\"quantized_bits(4,1)\"", ",", "\n", "depthwise_quantizer", "=", "\"quantized_bits(4,1)\"", ",", "\n", "depthwise_activation", "=", "\"quantized_bits(6,2,1)\"", ",", "\n", "pointwise_quantizer", "=", "\"quantized_bits(4,1)\"", ",", "\n", "acc_quantizer", "=", "\"quantized_bits(16,7,1)\"", ",", "\n", "activation", "=", "\"quantized_relu(6,2)\"", ",", "\n", "use_separable", "=", "True", ",", "\n", "name", "=", "'block3_conv2'", ")", "(", "[", "high", ",", "low", "]", ")", "\n", "\n", "high", ",", "low", "=", "QOctaveConv2D", "(", "\n", "32", ",", "(", "3", ",", "3", ")", ",", "\n", "alpha", "=", "0.3", ",", "\n", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "padding", "=", "'same'", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_initializer", "=", "'zeros'", ",", "\n", "bias_quantizer", "=", "\"quantized_bits(4,1)\"", ",", "\n", "depthwise_quantizer", "=", "\"quantized_bits(4,1)\"", ",", "\n", "depthwise_activation", "=", "\"quantized_bits(6,2,1)\"", ",", "\n", "pointwise_quantizer", "=", "\"quantized_bits(4,1)\"", ",", "\n", "acc_quantizer", "=", "\"quantized_bits(16,7,1)\"", ",", "\n", "activation", "=", "\"quantized_relu(6,2)\"", ",", "\n", "use_separable", "=", "True", ",", "\n", "name", "=", "'block3_conv3'", ")", "(", "[", "high", ",", "low", "]", ")", "\n", "\n", "x", ",", "_", "=", "QOctaveConv2D", "(", "\n", "32", ",", "(", "3", ",", "3", ")", ",", "\n", "alpha", "=", "0.0", ",", "\n", "strides", "=", "(", "2", ",", "2", ")", ",", "\n", "padding", "=", "'same'", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_initializer", "=", "'zeros'", ",", "\n", "bias_quantizer", "=", "\"quantized_bits(4,1)\"", ",", "\n", "depthwise_quantizer", "=", "\"quantized_bits(4,1)\"", ",", "\n", "depthwise_activation", "=", "\"quantized_bits(6,2,1)\"", ",", "\n", "pointwise_quantizer", "=", "\"quantized_bits(4,1)\"", ",", "\n", "acc_quantizer", "=", "\"quantized_bits(16,7,1)\"", ",", "\n", "activation", "=", "\"quantized_relu(6,2)\"", ",", "\n", "use_separable", "=", "True", ",", "\n", "name", "=", "'block3_conv_down'", ")", "(", "[", "high", ",", "low", "]", ")", "\n", "\n", "# Upsample", "\n", "x", "=", "UpSampling2D", "(", "size", "=", "(", "2", ",", "2", ")", ",", "data_format", "=", "\"channels_last\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "QConv2D", "(", "\n", "2", ",", "(", "2", ",", "2", ")", ",", "\n", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_initializer", "=", "\"ones\"", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "padding", "=", "\"same\"", ",", "\n", "name", "=", "\"conv_up\"", ")", "(", "\n", "x", ")", "\n", "\n", "x", "=", "Activation", "(", "\"softmax\"", ",", "name", "=", "\"softmax\"", ")", "(", "x", ")", "\n", "output", "=", "x", "\n", "\n", "model", "=", "Model", "(", "x_in", ",", "output", ",", "name", "=", "'qoctave_network'", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.examples.example_qoctave.customLoss": [[157, 161], ["tensorflow.pow", "tensorflow.pow", "tensorflow.sum", "tensorflow.log", "tensorflow.log", "tensorflow.mean"], "function", ["None"], ["", "def", "customLoss", "(", "y_true", ",", "y_pred", ")", ":", "\n", "  ", "log1", "=", "1.5", "*", "y_true", "*", "K", ".", "log", "(", "y_pred", "+", "1e-9", ")", "*", "K", ".", "pow", "(", "1", "-", "y_pred", ",", "2", ")", "\n", "log0", "=", "0.5", "*", "(", "1", "-", "y_true", ")", "*", "K", ".", "log", "(", "(", "1", "-", "y_pred", ")", "+", "1e-9", ")", "*", "K", ".", "pow", "(", "y_pred", ",", "2", ")", "\n", "return", "(", "-", "K", ".", "sum", "(", "K", ".", "mean", "(", "log0", "+", "log1", ",", "axis", "=", "0", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.examples.example_ternary._stochastic_rounding": [[32, 65], ["numpy.where", "numpy.random.uniform"], "function", ["None"], ["def", "_stochastic_rounding", "(", "x", ",", "precision", ",", "resolution", ",", "delta", ")", ":", "\n", "  ", "\"\"\"Stochastic_rounding for ternary.\n\n  Args:\n    x:\n    precision: A float. The area we want to make this stochastic rounding.\n       [delta-precision, delta] [delta, delta+precision]\n    resolution: control the quantization resolution.\n    delta: the undiscountinued point (positive number)\n\n  Return:\n    A tensor with stochastic rounding numbers.\n  \"\"\"", "\n", "delta_left", "=", "delta", "-", "precision", "\n", "delta_right", "=", "delta", "+", "precision", "\n", "scale", "=", "1", "/", "resolution", "\n", "scale_delta_left", "=", "delta_left", "*", "scale", "\n", "scale_delta_right", "=", "delta_right", "*", "scale", "\n", "scale_2_delta", "=", "scale_delta_right", "-", "scale_delta_left", "\n", "scale_x", "=", "x", "*", "scale", "\n", "fraction", "=", "scale_x", "-", "scale_delta_left", "\n", "# print(precision, scale, x[0], np.floor(scale_x[0]), scale_x[0], fraction[0])", "\n", "\n", "# we use uniform distribution", "\n", "random_selector", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "size", "=", "x", ".", "shape", ")", "*", "scale_2_delta", "\n", "\n", "# print(precision, scale, x[0], delta_left[0], delta_right[0])", "\n", "# print('x', scale_x[0], fraction[0], random_selector[0], scale_2_delta[0])", "\n", "# rounddown = fraction < random_selector", "\n", "result", "=", "np", ".", "where", "(", "fraction", "<", "random_selector", ",", "\n", "scale_delta_left", "/", "scale", ",", "\n", "scale_delta_right", "/", "scale", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.examples.example_ternary._ternary": [[67, 85], ["numpy.amax", "numpy.where", "numpy.abs", "numpy.sign", "numpy.abs", "numpy.zeros_like", "numpy.sign", "example_ternary._stochastic_rounding", "numpy.abs"], "function", ["home.repos.pwc.inspect_result.google_qkeras.examples.example_ternary._stochastic_rounding"], ["", "def", "_ternary", "(", "x", ",", "sto", "=", "False", ")", ":", "\n", "  ", "m", "=", "np", ".", "amax", "(", "np", ".", "abs", "(", "x", ")", ",", "keepdims", "=", "True", ")", "\n", "scale", "=", "2", "*", "m", "/", "3.0", "\n", "thres", "=", "scale", "/", "2.0", "\n", "ratio", "=", "0.1", "\n", "\n", "if", "sto", ":", "\n", "    ", "sign_bit", "=", "np", ".", "sign", "(", "x", ")", "\n", "x", "=", "np", ".", "abs", "(", "x", ")", "\n", "prec", "=", "x", "/", "scale", "\n", "x", "=", "(", "\n", "sign_bit", "*", "scale", "*", "_stochastic_rounding", "(", "\n", "x", "/", "scale", ",", "\n", "precision", "=", "0.3", ",", "resolution", "=", "0.01", ",", "# those two are all normalized.", "\n", "delta", "=", "thres", "/", "scale", ")", ")", "\n", "# prec + prec *ratio)", "\n", "# mm = np.amax(np.abs(x), keepdims=True)", "\n", "", "return", "np", ".", "where", "(", "np", ".", "abs", "(", "x", ")", "<", "thres", ",", "np", ".", "zeros_like", "(", "x", ")", ",", "np", ".", "sign", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.examples.example_ternary.main": [[87, 109], ["numpy.random.uniform", "numpy.sort", "numpy.zeros_like", "numpy.zeros_like", "range", "matplotlib.plot", "matplotlib.plot", "matplotlib.ylabel", "matplotlib.show", "len", "absl.app.UsageError", "example_ternary._ternary", "example_ternary._ternary"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.examples.example_ternary._ternary", "home.repos.pwc.inspect_result.google_qkeras.examples.example_ternary._ternary"], ["", "def", "main", "(", "argv", ")", ":", "\n", "  ", "if", "len", "(", "argv", ")", ">", "1", ":", "\n", "    ", "raise", "app", ".", "UsageError", "(", "'Too many command-line arguments.'", ")", "\n", "\n", "# x = np.arange(-3.0, 3.0, 0.01)", "\n", "# x = np.random.uniform(-0.01, 0.01, size=1000)", "\n", "", "x", "=", "np", ".", "random", ".", "uniform", "(", "-", "10.0", ",", "10.0", ",", "size", "=", "1000", ")", "\n", "# x = np.random.uniform(-1, 1, size=1000)", "\n", "x", "=", "np", ".", "sort", "(", "x", ")", "\n", "tr", "=", "np", ".", "zeros_like", "(", "x", ")", "\n", "t", "=", "np", ".", "zeros_like", "(", "x", ")", "\n", "iter_count", "=", "500", "\n", "for", "_", "in", "range", "(", "iter_count", ")", ":", "\n", "    ", "y", "=", "_ternary", "(", "x", ")", "\n", "yr", "=", "_ternary", "(", "x", ",", "sto", "=", "True", ")", "\n", "t", "=", "t", "+", "y", "\n", "tr", "=", "tr", "+", "yr", "\n", "\n", "", "plt", ".", "plot", "(", "x", ",", "t", "/", "iter_count", ")", "\n", "plt", ".", "plot", "(", "x", ",", "tr", "/", "iter_count", ")", "\n", "plt", ".", "ylabel", "(", "'mean (%s samples)'", "%", "iter_count", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.examples.example_generate_json.hybrid_model": [[30, 47], ["tensorflow.layers.Input", "tensorflow.Model", "tensorflow.layers.Dense", "tensorflow.layers.Activation", "qkeras.QDense", "qkeras.QActivation", "qkeras.QDense", "tensorflow.layers.Activation", "qkeras.quantizers.quantized_po2", "qkeras.quantizers.quantized_po2", "qkeras.quantizers.quantized_po2", "qkeras.quantizers.quantized_po2"], "function", ["None"], ["def", "hybrid_model", "(", ")", ":", "\n", "  ", "\"\"\"hybrid model that mixes qkeras and keras layers.\"\"\"", "\n", "\n", "x", "=", "x_in", "=", "keras", ".", "layers", ".", "Input", "(", "(", "784", ",", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "keras", ".", "layers", ".", "Dense", "(", "300", ",", "name", "=", "\"d0\"", ")", "(", "x", ")", "\n", "x", "=", "keras", ".", "layers", ".", "Activation", "(", "\"relu\"", ",", "name", "=", "\"d0_act\"", ")", "(", "x", ")", "\n", "x", "=", "QDense", "(", "100", ",", "kernel_quantizer", "=", "quantizers", ".", "quantized_po2", "(", "4", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_po2", "(", "4", ")", ",", "\n", "name", "=", "\"d1\"", ")", "(", "x", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(4,0)\"", ",", "name", "=", "\"d1_qr4\"", ")", "(", "x", ")", "\n", "x", "=", "QDense", "(", "\n", "10", ",", "kernel_quantizer", "=", "quantizers", ".", "quantized_po2", "(", "4", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_po2", "(", "4", ")", ",", "\n", "name", "=", "\"d2\"", ")", "(", "x", ")", "\n", "x", "=", "keras", ".", "layers", ".", "Activation", "(", "\"softmax\"", ",", "name", "=", "\"softmax\"", ")", "(", "x", ")", "\n", "\n", "return", "keras", ".", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.examples.example_generate_json.generate_json": [[49, 123], ["qkeras.qtools.run_qtools.QTools", "run_qtools.QTools.qtools_stats_print", "qkeras.quantizers.quantized_bits"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qtools.run_qtools.QTools.qtools_stats_print"], ["", "def", "generate_json", "(", "in_model", ")", ":", "\n", "  ", "\"\"\"example to generate data type map for a given model.\n\n  Args:\n    in_model: qkeras model object\n\n  Usage:\n    input_quantizer_list:\n      A list of input quantizers for the model. It could be in the form of:\n        1. a list of quantizers, each quantizer for each one of the model inputs\n        2. one single quantizer, which will be used for all of the model inputs\n        3. None. Default input quantizer defined in config_xxx.py will be used\n        for all of the model inputs\n\n    for_reference: get energy for a reference model/trial model\n      1. True: get baseline energy for a given model. Use keras_quantizer/keras_\n        accumulator (or default_interm_quantizer in config_xxx.py if keras_\n        quantizer/keras_accumulator not given) to quantizer all layers in a\n        model in order to calculate its energy. It servers the purpose of\n        setting up a baseline energy for a given model architecture.\n      2. False: get \"real\" energy for a given model use user-specified\n        quantizers. For layers that are not quantized (keras layer) or have no\n        user-specified quantizers (qkeras layers without quantizers specified),\n        keras_quantizer and keras_accumulator(or default_interm_quantizer in\n        config_xxx.py if keras_quantizer/keras_accumulator not given)\n        will be used as their quantizers.\n\n     process: technology process to use in configuration (horowitz, ...)\n\n     weights_path: absolute path to the model weights\n\n     is_inference: whether model has been trained already, which is needed to\n         compute tighter bounds for QBatchNormalization Power estimation\n\n     Other parameters (defined in config_xxx.py):\n       1. \"default_source_quantizer\" is used as default input quantizer\n          if user do not specify any input quantizers,\n       2. \"default_interm_quantizer\": is used as default quantizer for any\n          intermediate variables such as multiplier, accumulator, weight/bias\n          in a qkeras layer if user do not secifiy the corresponding variable\n       3. process_name: energy calculation parameters for different processes.\n          \"horowitz\" is the process we use by default.\n       4. \"include_energy\": what energy to include at each layer\n          when calculation the total energy of the entire model.\n          \"parameters\": memory access energy for loading model parameters.\n          \"inputs\": memory access energy to reading inputs\n          \"outputs\": memory access energy for writing outputs\n          \"op_cost\": operation energy for multiplication and accumulation\n  \"\"\"", "\n", "\n", "input_quantizer_list", "=", "[", "quantizers", ".", "quantized_bits", "(", "8", ",", "0", ",", "1", ")", "]", "\n", "reference_internal", "=", "\"int8\"", "\n", "reference_accumulator", "=", "\"int32\"", "\n", "\n", "# generate QTools object which contains model data type map in json format", "\n", "q", "=", "run_qtools", ".", "QTools", "(", "\n", "in_model", ",", "\n", "# energy calculation using a given process", "\n", "process", "=", "\"horowitz\"", ",", "\n", "# quantizers for model inputs", "\n", "source_quantizers", "=", "input_quantizer_list", ",", "\n", "# training or inference with a pre-trained model", "\n", "is_inference", "=", "False", ",", "\n", "# path to pre-trained model weights", "\n", "weights_path", "=", "None", ",", "\n", "# keras_quantizer to quantize weight/bias in non-quantized keras layers", "\n", "keras_quantizer", "=", "reference_internal", ",", "\n", "# keras_accumulator to quantize MAC in un-quantized keras layers", "\n", "keras_accumulator", "=", "reference_accumulator", ",", "\n", "# calculating baseline energy or not", "\n", "for_reference", "=", "False", ")", "\n", "\n", "# print data type map", "\n", "q", ".", "qtools_stats_print", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.examples.example_get_energy.hybrid_model": [[31, 48], ["tensorflow.layers.Input", "tensorflow.Model", "tensorflow.layers.Dense", "tensorflow.layers.Activation", "qkeras.QDense", "qkeras.QActivation", "qkeras.QDense", "tensorflow.layers.Activation", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits"], "function", ["None"], ["def", "hybrid_model", "(", ")", ":", "\n", "  ", "\"\"\"hybrid model that mixes qkeras and keras layers.\"\"\"", "\n", "\n", "x", "=", "x_in", "=", "keras", ".", "layers", ".", "Input", "(", "(", "784", ",", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "keras", ".", "layers", ".", "Dense", "(", "300", ",", "name", "=", "\"d0\"", ")", "(", "x", ")", "\n", "x", "=", "keras", ".", "layers", ".", "Activation", "(", "\"relu\"", ",", "name", "=", "\"d0_act\"", ")", "(", "x", ")", "\n", "x", "=", "QDense", "(", "100", ",", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"d1\"", ")", "(", "x", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(4,0)\"", ",", "name", "=", "\"d1_qr4\"", ")", "(", "x", ")", "\n", "x", "=", "QDense", "(", "\n", "10", ",", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"d2\"", ")", "(", "x", ")", "\n", "x", "=", "keras", ".", "layers", ".", "Activation", "(", "\"softmax\"", ",", "name", "=", "\"softmax\"", ")", "(", "x", ")", "\n", "\n", "return", "keras", ".", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.automatic_conversion_test.create_network": [[27, 35], ["Input", "Model", "Conv2D", "Activation", "Conv2D", "Activation", "QConv2D"], "function", ["None"], ["def", "create_network", "(", ")", ":", "\n", "  ", "xi", "=", "Input", "(", "(", "28", ",", "28", ",", "1", ")", ")", "\n", "x", "=", "Conv2D", "(", "32", ",", "(", "3", ",", "3", ")", ")", "(", "xi", ")", "\n", "x", "=", "Activation", "(", "\"relu\"", ",", "name", "=", "'relu_act'", ")", "(", "x", ")", "\n", "x", "=", "Conv2D", "(", "32", ",", "(", "3", ",", "3", ")", ",", "activation", "=", "\"relu\"", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "\"softmax\"", ")", "(", "x", ")", "\n", "x", "=", "QConv2D", "(", "32", ",", "(", "3", ",", "3", ")", ",", "activation", "=", "\"quantized_relu(4)\"", ")", "(", "x", ")", "\n", "return", "Model", "(", "inputs", "=", "xi", ",", "outputs", "=", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.automatic_conversion_test.create_network_with_bn": [[36, 46], ["Input", "Model", "Conv2D", "BatchNormalization", "Activation", "Conv2D", "Activation", "DepthwiseConv2D", "BatchNormalization"], "function", ["None"], ["", "def", "create_network_with_bn", "(", ")", ":", "\n", "  ", "xi", "=", "Input", "(", "(", "28", ",", "28", ",", "1", ")", ")", "\n", "x", "=", "Conv2D", "(", "32", ",", "(", "3", ",", "3", ")", ")", "(", "xi", ")", "\n", "x", "=", "BatchNormalization", "(", "axis", "=", "-", "1", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "\"relu\"", ",", "name", "=", "'relu_act'", ")", "(", "x", ")", "\n", "x", "=", "Conv2D", "(", "32", ",", "(", "3", ",", "3", ")", ",", "activation", "=", "\"relu\"", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "\"softmax\"", ")", "(", "x", ")", "\n", "x", "=", "DepthwiseConv2D", "(", "(", "3", ",", "3", ")", ")", "(", "x", ")", "\n", "x", "=", "BatchNormalization", "(", "axis", "=", "-", "1", ")", "(", "x", ")", "\n", "return", "Model", "(", "inputs", "=", "xi", ",", "outputs", "=", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.automatic_conversion_test.create_network_sequential": [[47, 56], ["Sequential", "Conv2D", "Activation", "Conv2D", "Activation", "QConv2D"], "function", ["None"], ["", "def", "create_network_sequential", "(", ")", ":", "\n", "  ", "model", "=", "Sequential", "(", "[", "\n", "Conv2D", "(", "32", ",", "(", "3", ",", "3", ")", ",", "input_shape", "=", "(", "28", ",", "28", ",", "1", ")", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "Conv2D", "(", "32", ",", "(", "3", ",", "3", ")", ",", "activation", "=", "\"relu\"", ")", ",", "\n", "Activation", "(", "'softmax'", ")", ",", "\n", "QConv2D", "(", "32", ",", "(", "3", ",", "3", ")", ",", "activation", "=", "\"quantized_relu(4)\"", ")", "\n", "]", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.automatic_conversion_test.test_linear_activation": [[57, 61], ["automatic_conversion_test.create_network"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.print_qstats_test.create_network"], ["", "def", "test_linear_activation", "(", ")", ":", "\n", "  ", "m", "=", "create_network", "(", ")", "\n", "\n", "assert", "m", ".", "layers", "[", "1", "]", ".", "activation", ".", "__name__", "==", "\"linear\"", ",", "\"test failed\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.automatic_conversion_test.test_linear_activation_conversion": [[63, 76], ["automatic_conversion_test.create_network", "qkeras.utils.model_quantize", "str"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.print_qstats_test.create_network", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize"], ["", "def", "test_linear_activation_conversion", "(", ")", ":", "\n", "  ", "m", "=", "create_network", "(", ")", "\n", "\n", "d", "=", "{", "\n", "\"QConv2D\"", ":", "{", "\n", "\"kernel_quantizer\"", ":", "\"binary\"", ",", "\n", "\"bias_quantizer\"", ":", "\"binary\"", ",", "\n", "\"activation_quantizer\"", ":", "\"binary\"", "\n", "}", "\n", "}", "\n", "qq", "=", "model_quantize", "(", "m", ",", "d", ",", "4", ")", "\n", "\n", "assert", "str", "(", "qq", ".", "layers", "[", "1", "]", ".", "activation", ")", "==", "\"binary()\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.automatic_conversion_test.test_no_activation_conversion_to_quantized": [[78, 84], ["automatic_conversion_test.create_network", "qkeras.utils.model_quantize"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.print_qstats_test.create_network", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize"], ["", "def", "test_no_activation_conversion_to_quantized", "(", ")", ":", "\n", "  ", "m", "=", "create_network", "(", ")", "\n", "d", "=", "{", "\"QConv2D\"", ":", "{", "\"kernel_quantizer\"", ":", "\"binary\"", ",", "\"bias_quantizer\"", ":", "\"binary\"", "}", "}", "\n", "qq", "=", "model_quantize", "(", "m", ",", "d", ",", "4", ")", "\n", "assert", "qq", ".", "layers", "[", "2", "]", ".", "__class__", ".", "__name__", "==", "\"Activation\"", "\n", "assert", "qq", ".", "layers", "[", "4", "]", ".", "__class__", ".", "__name__", "==", "\"Activation\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.automatic_conversion_test.test_automatic_conversion_from_relu_to_qr": [[86, 95], ["automatic_conversion_test.create_network", "qkeras.utils.model_quantize", "str"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.print_qstats_test.create_network", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize"], ["", "def", "test_automatic_conversion_from_relu_to_qr", "(", ")", ":", "\n", "  ", "m", "=", "create_network", "(", ")", "\n", "d", "=", "{", "\n", "\"QConv2D\"", ":", "{", "\n", "\"kernel_quantizer\"", ":", "\"binary\"", ",", "\n", "\"bias_quantizer\"", ":", "\"binary\"", "\n", "}", "}", "\n", "qq", "=", "model_quantize", "(", "m", ",", "d", ",", "4", ")", "\n", "assert", "str", "(", "qq", ".", "layers", "[", "3", "]", ".", "activation", ")", "==", "\"quantized_relu(4,0)\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.automatic_conversion_test.test_conversion_from_relu_activation_to_qr_qactivation": [[97, 112], ["automatic_conversion_test.create_network", "qkeras.utils.model_quantize", "str"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.print_qstats_test.create_network", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize"], ["", "def", "test_conversion_from_relu_activation_to_qr_qactivation", "(", ")", ":", "\n", "  ", "m", "=", "create_network", "(", ")", "\n", "d", "=", "{", "\n", "\"QConv2D\"", ":", "{", "\n", "\"kernel_quantizer\"", ":", "\"binary\"", ",", "\n", "\"bias_quantizer\"", ":", "\"binary\"", "\n", "}", ",", "\n", "\"QActivation\"", ":", "{", "\n", "\"relu\"", ":", "\"ternary\"", "\n", "}", "\n", "}", "\n", "qq", "=", "model_quantize", "(", "m", ",", "d", ",", "4", ")", "\n", "assert", "qq", ".", "layers", "[", "2", "]", ".", "__class__", ".", "__name__", "==", "\"QActivation\"", "\n", "assert", "str", "(", "qq", ".", "layers", "[", "2", "]", ".", "quantizer", ")", "==", "\"ternary()\"", "\n", "assert", "qq", ".", "layers", "[", "4", "]", ".", "__class__", ".", "__name__", "==", "\"Activation\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.automatic_conversion_test.test_conversion_from_relu_activation_to_qadaptiveactivation": [[114, 129], ["automatic_conversion_test.create_network", "qkeras.utils.model_quantize", "str().startswith", "str"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.print_qstats_test.create_network", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize"], ["", "def", "test_conversion_from_relu_activation_to_qadaptiveactivation", "(", ")", ":", "\n", "  ", "m", "=", "create_network", "(", ")", "\n", "d", "=", "{", "\n", "\"QConv2D\"", ":", "{", "\n", "\"kernel_quantizer\"", ":", "\"binary\"", ",", "\n", "\"bias_quantizer\"", ":", "\"binary\"", "\n", "}", ",", "\n", "\"QAdaptiveActivation\"", ":", "{", "\n", "\"relu\"", ":", "\"quantized_relu(8)\"", "\n", "}", "\n", "}", "\n", "qq", "=", "model_quantize", "(", "m", ",", "d", ",", "4", ")", "\n", "assert", "qq", ".", "layers", "[", "2", "]", ".", "__class__", ".", "__name__", "==", "\"QAdaptiveActivation\"", "\n", "assert", "str", "(", "qq", ".", "layers", "[", "2", "]", ".", "quantizer", ")", ".", "startswith", "(", "\"quantized_relu(8,\"", ")", "\n", "assert", "qq", ".", "layers", "[", "4", "]", ".", "__class__", ".", "__name__", "==", "\"Activation\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.automatic_conversion_test.test_conversion_qadaptiveactivation_with_preference": [[131, 154], ["automatic_conversion_test.create_network", "qkeras.utils.model_quantize", "str().startswith", "qkeras.utils.model_quantize", "str().startswith", "str", "str"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.print_qstats_test.create_network", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize"], ["", "def", "test_conversion_qadaptiveactivation_with_preference", "(", ")", ":", "\n", "  ", "m", "=", "create_network", "(", ")", "\n", "d", "=", "{", "\n", "\"QConv2D\"", ":", "{", "\n", "\"kernel_quantizer\"", ":", "\"binary\"", ",", "\n", "\"bias_quantizer\"", ":", "\"binary\"", "\n", "}", ",", "\n", "\"relu_act\"", ":", "{", "\n", "\"relu\"", ":", "\"quantized_relu(8)\"", "\n", "}", "\n", "}", "\n", "\n", "# Test with QActivation preference", "\n", "qq1", "=", "model_quantize", "(", "m", ",", "d", ",", "4", ",", "prefer_qadaptiveactivation", "=", "False", ")", "\n", "assert", "qq1", ".", "layers", "[", "2", "]", ".", "__class__", ".", "__name__", "==", "\"QActivation\"", "\n", "assert", "str", "(", "qq1", ".", "layers", "[", "2", "]", ".", "quantizer", ")", ".", "startswith", "(", "\"quantized_relu(8,\"", ")", "\n", "assert", "qq1", ".", "layers", "[", "4", "]", ".", "__class__", ".", "__name__", "==", "\"Activation\"", "\n", "\n", "# Test with QAdaptiveActivation preference", "\n", "qq2", "=", "model_quantize", "(", "m", ",", "d", ",", "4", ",", "prefer_qadaptiveactivation", "=", "True", ")", "\n", "assert", "qq2", ".", "layers", "[", "2", "]", ".", "__class__", ".", "__name__", "==", "\"QAdaptiveActivation\"", "\n", "assert", "str", "(", "qq2", ".", "layers", "[", "2", "]", ".", "quantizer", ")", ".", "startswith", "(", "\"quantized_relu(8,\"", ")", "\n", "assert", "qq2", ".", "layers", "[", "4", "]", ".", "__class__", ".", "__name__", "==", "\"Activation\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.automatic_conversion_test.test_sequential_model_conversion": [[156, 165], ["automatic_conversion_test.create_network_sequential", "qkeras.utils.model_quantize", "str"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.automatic_conversion_test.create_network_sequential", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize"], ["", "def", "test_sequential_model_conversion", "(", ")", ":", "\n", "  ", "m", "=", "create_network_sequential", "(", ")", "\n", "d", "=", "{", "\n", "\"QConv2D\"", ":", "{", "\n", "\"kernel_quantizer\"", ":", "\"binary\"", ",", "\n", "\"bias_quantizer\"", ":", "\"binary\"", "\n", "}", "}", "\n", "qq", "=", "model_quantize", "(", "m", ",", "d", ",", "4", ")", "\n", "assert", "str", "(", "qq", ".", "layers", "[", "2", "]", ".", "activation", ")", "==", "\"quantized_relu(4,0)\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.automatic_conversion_test.test_folded_layer_conversion": [[167, 248], ["automatic_conversion_test.create_network", "automatic_conversion_test.create_network_with_bn", "qkeras.utils.model_quantize", "str().startswith", "qkeras.utils.model_quantize", "str().startswith", "str().startswith", "str().startswith", "qkeras.utils.model_quantize", "str().startswith", "str().startswith", "str().startswith", "qkeras.utils.model_quantize", "str().startswith", "str().startswith", "str().startswith", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.print_qstats_test.create_network", "home.repos.pwc.inspect_result.google_qkeras.tests.print_qstats_test.create_network_with_bn", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize"], ["", "def", "test_folded_layer_conversion", "(", ")", ":", "\n", "# create a sequential model with conv2d layer and activation layers", "\n", "  ", "m1", "=", "create_network", "(", ")", "\n", "\n", "# create a sequantial model with conv2d layer followed by bn layer", "\n", "m2", "=", "create_network_with_bn", "(", ")", "\n", "\n", "# quantization config", "\n", "d", "=", "{", "\n", "\"QConv2D\"", ":", "{", "\n", "\"kernel_quantizer\"", ":", "\"binary\"", ",", "\n", "\"bias_quantizer\"", ":", "\"binary\"", "\n", "}", ",", "\n", "\"QDepthwiseConv2D\"", ":", "{", "\n", "\"depthwise_quantizer\"", ":", "\"binary\"", ",", "\n", "\"bias_quantizer\"", ":", "\"binary\"", "\n", "}", ",", "\n", "\"QConv2DBatchnorm\"", ":", "{", "\n", "\"kernel_quantizer\"", ":", "\"ternary\"", ",", "\n", "\"bias_quantizer\"", ":", "\"ternary\"", ",", "\n", "}", ",", "\n", "\"QDepthwiseConv2DBatchnorm\"", ":", "{", "\n", "\"depthwise_quantizer\"", ":", "\"ternary\"", ",", "\n", "\"bias_quantizer\"", ":", "\"ternary\"", ",", "\n", "}", ",", "\n", "\"relu_act\"", ":", "{", "\n", "\"relu\"", ":", "\"quantized_relu(8)\"", "\n", "}", "\n", "}", "\n", "\n", "# test when model has no layer to fold", "\n", "# desired behavior: un-folded layers", "\n", "qq1", "=", "model_quantize", "(", "m1", ",", "d", ",", "4", ",", "enable_bn_folding", "=", "True", ")", "\n", "assert", "qq1", ".", "layers", "[", "1", "]", ".", "__class__", ".", "__name__", "==", "\"QConv2D\"", "\n", "assert", "str", "(", "qq1", ".", "layers", "[", "1", "]", ".", "quantizers", "[", "0", "]", ")", ".", "startswith", "(", "\"binary\"", ")", "\n", "\n", "# test when the 1st conv2d layers needs to fold but the 2nd conv2d layer", "\n", "# does not (not followed by bn layer)", "\n", "# desired behavior: 1st conv2d is folded, 2nd conv2d unfolded", "\n", "# also test the depthwiseconv2d layer should fold", "\n", "qq2", "=", "model_quantize", "(", "m2", ",", "d", ",", "4", ",", "enable_bn_folding", "=", "True", ")", "\n", "assert", "qq2", ".", "layers", "[", "1", "]", ".", "__class__", ".", "__name__", "==", "\"QConv2DBatchnorm\"", "\n", "assert", "str", "(", "qq2", ".", "layers", "[", "1", "]", ".", "quantizers", "[", "0", "]", ")", ".", "startswith", "(", "\"ternary\"", ")", "\n", "assert", "qq2", ".", "layers", "[", "3", "]", ".", "__class__", ".", "__name__", "==", "\"QConv2D\"", "\n", "assert", "str", "(", "qq2", ".", "layers", "[", "3", "]", ".", "quantizers", "[", "0", "]", ")", ".", "startswith", "(", "\"binary\"", ")", "\n", "assert", "qq2", ".", "layers", "[", "5", "]", ".", "__class__", ".", "__name__", "==", "\"QDepthwiseConv2DBatchnorm\"", "\n", "assert", "str", "(", "qq2", ".", "layers", "[", "5", "]", ".", "quantizers", "[", "0", "]", ")", ".", "startswith", "(", "\"ternary\"", ")", "\n", "\n", "# test when there are layers to fold but folding is disabled", "\n", "# desired behavior: all conv2d/depthwise2d layers are not folded", "\n", "qq3", "=", "model_quantize", "(", "m2", ",", "d", ",", "4", ",", "enable_bn_folding", "=", "False", ")", "\n", "assert", "qq3", ".", "layers", "[", "1", "]", ".", "__class__", ".", "__name__", "==", "\"QConv2D\"", "\n", "assert", "str", "(", "qq3", ".", "layers", "[", "1", "]", ".", "quantizers", "[", "0", "]", ")", ".", "startswith", "(", "\"binary\"", ")", "\n", "assert", "qq3", ".", "layers", "[", "2", "]", ".", "__class__", ".", "__name__", "==", "\"BatchNormalization\"", "\n", "assert", "str", "(", "qq3", ".", "layers", "[", "3", "]", ".", "quantizer", ")", ".", "startswith", "(", "\"quantized_relu\"", ")", "\n", "assert", "qq3", ".", "layers", "[", "6", "]", ".", "__class__", ".", "__name__", "==", "\"QDepthwiseConv2D\"", "\n", "assert", "str", "(", "qq3", ".", "layers", "[", "6", "]", ".", "quantizers", "[", "0", "]", ")", ".", "startswith", "(", "\"binary\"", ")", "\n", "\n", "# test when QConv2DBatchnorm quantizer, e.g., is not given in config", "\n", "# desired behavior: quantizers for QConv2DBatchnorm layer fall back to QConv2D", "\n", "#   quantizers", "\n", "d", "=", "{", "\n", "\"QConv2D\"", ":", "{", "\n", "\"kernel_quantizer\"", ":", "\"binary\"", ",", "\n", "\"bias_quantizer\"", ":", "\"binary\"", "\n", "}", ",", "\n", "\"QDepthwiseConv2D\"", ":", "{", "\n", "\"depthwise_quantizer\"", ":", "\"binary\"", ",", "\n", "\"bias_quantizer\"", ":", "\"binary\"", "\n", "}", ",", "\n", "\"relu_act\"", ":", "{", "\n", "\"relu\"", ":", "\"quantized_relu(8)\"", "\n", "}", "\n", "}", "\n", "qq4", "=", "model_quantize", "(", "m2", ",", "d", ",", "4", ",", "enable_bn_folding", "=", "True", ")", "\n", "assert", "qq4", ".", "layers", "[", "1", "]", ".", "__class__", ".", "__name__", "==", "\"QConv2DBatchnorm\"", "\n", "assert", "str", "(", "qq4", ".", "layers", "[", "1", "]", ".", "quantizers", "[", "0", "]", ")", ".", "startswith", "(", "\"binary\"", ")", "\n", "assert", "qq4", ".", "layers", "[", "3", "]", ".", "__class__", ".", "__name__", "==", "\"QConv2D\"", "\n", "assert", "str", "(", "qq4", ".", "layers", "[", "3", "]", ".", "quantizers", "[", "0", "]", ")", ".", "startswith", "(", "\"binary\"", ")", "\n", "assert", "qq4", ".", "layers", "[", "5", "]", ".", "__class__", ".", "__name__", "==", "\"QDepthwiseConv2DBatchnorm\"", "\n", "assert", "str", "(", "qq4", ".", "layers", "[", "5", "]", ".", "quantizers", "[", "0", "]", ")", ".", "startswith", "(", "\"binary\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qpooling_test.test_q_average_pooling": [[49, 143], ["pytest.mark.parametrize", "numpy.random.seed", "tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "qkeras.print_qstats", "numpy.random.rand", "numpy.testing.assert_raises", "tensorflow.keras.models.Model.predict().astype", "numpy.testing.assert_allclose", "tensorflow.keras.models.Model.to_json", "tensorflow.keras.backend.clear_session", "qkeras.utils.quantized_model_from_json", "qkeras.utils.quantized_model_from_json.predict().astype", "numpy.testing.assert_allclose", "tempfile.mkstemp", "tensorflow.keras.models.Model.save", "qkeras.utils.load_qmodel", "os.close", "os.remove", "qkeras.utils.model_save_quantized_weights", "qkeras.utils.load_qmodel.predict().astype", "numpy.testing.assert_allclose", "qkeras.QAveragePooling2D", "qkeras.QGlobalAveragePooling2D", "qkeras.quantized_bits", "qkeras.quantized_bits", "numpy.array().astype", "qkeras.quantized_bits", "qkeras.quantized_bits", "numpy.array().astype", "qkeras.quantized_bits", "qkeras.quantized_bits", "numpy.array().astype", "qkeras.quantized_bits", "qkeras.quantized_bits", "numpy.array().astype", "qkeras.quantized_bits", "qkeras.quantized_bits", "numpy.array().astype", "qkeras.quantized_bits", "qkeras.quantized_bits", "tensorflow.keras.models.Model.predict", "qkeras.utils.quantized_model_from_json.predict", "qkeras.utils.load_qmodel.predict", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qtools.interface.print_qstats", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.quantized_model_from_json", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.save", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.load_qmodel", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_save_quantized_weights", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "(", "'pooling, input_size, pool_size, strides, padding, data_format,'", "\n", "'average_quantizer, activation_quantizer,  y'", ")", ",", "[", "\n", "(", "'QAveragePooling2D'", ",", "(", "4", ",", "4", ",", "3", ")", ",", "(", "2", ",", "2", ")", ",", "(", "2", ",", "2", ")", ",", "'valid'", ",", "\n", "'channels_last'", ",", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "[", "[", "0.375", ",", "0.625", ",", "0.375", "]", ",", "[", "0.25", ",", "0.75", ",", "0.5", "]", "]", ",", "\n", "[", "[", "0.375", ",", "0.25", ",", "0.625", "]", ",", "[", "0.625", ",", "0.5", ",", "0.375", "]", "]", "]", ",", "\n", "[", "[", "[", "0.375", ",", "0.375", ",", "0.5", "]", ",", "[", "0.375", ",", "0.5", ",", "0.625", "]", "]", ",", "\n", "[", "[", "0.75", ",", "0.625", ",", "0.5", "]", ",", "[", "0.5", ",", "0.5", ",", "0.75", "]", "]", "]", "]", ")", ".", "astype", "(", "\n", "np", ".", "float16", ")", ")", ",", "\n", "(", "'QAveragePooling2D'", ",", "(", "4", ",", "4", ",", "3", ")", ",", "(", "3", ",", "3", ")", ",", "(", "3", ",", "3", ")", ",", "'valid'", ",", "\n", "'channels_last'", ",", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "[", "[", "0.375", ",", "0.625", ",", "0.625", "]", "]", "]", ",", "[", "[", "[", "0.625", ",", "0.5", ",", "0.625", "]", "]", "]", "]", ")", ".", "astype", "(", "\n", "np", ".", "float16", ")", ")", ",", "\n", "(", "'QGlobalAveragePooling2D'", ",", "(", "4", ",", "4", ",", "3", ")", ",", "(", "2", ",", "2", ")", ",", "(", "2", ",", "2", ")", ",", "'valid'", ",", "\n", "'channels_last'", ",", "quantized_bits", "(", "10", ",", "0", ",", "1", ")", ",", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "0.5", ",", "0.5", ",", "0.375", "]", ",", "[", "0.5", ",", "0.5", ",", "0.625", "]", "]", ")", ".", "astype", "(", "np", ".", "float16", ")", ")", ",", "\n", "(", "'QAveragePooling2D'", ",", "(", "4", ",", "4", ",", "3", ")", ",", "(", "2", ",", "2", ")", ",", "(", "3", ",", "3", ")", ",", "'valid'", ",", "\n", "'channels_last'", ",", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "[", "[", "0.375", ",", "0.625", ",", "0.375", "]", "]", "]", ",", "[", "[", "[", "0.375", ",", "0.375", ",", "0.5", "]", "]", "]", "]", ")", ".", "astype", "(", "\n", "np", ".", "float16", ")", ")", ",", "\n", "(", "'QAveragePooling2D'", ",", "(", "4", ",", "4", ",", "3", ")", ",", "(", "2", ",", "2", ")", ",", "(", "3", ",", "3", ")", ",", "'same'", ",", "\n", "'channels_last'", ",", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "[", "[", "0.375", ",", "0.625", ",", "0.375", "]", ",", "[", "0.375", ",", "0.75", ",", "0.25", "]", "]", ",", "\n", "[", "[", "0.75", ",", "0.25", ",", "0.375", "]", ",", "[", "0.75", ",", "0.75", ",", "0.25", "]", "]", "]", ",", "\n", "[", "[", "[", "0.375", ",", "0.375", ",", "0.5", "]", ",", "[", "0.25", ",", "0.625", ",", "0.5", "]", "]", ",", "\n", "[", "[", "0.625", ",", "0.625", ",", "0.5", "]", ",", "[", "0.625", ",", "0.625", ",", "0.875", "]", "]", "]", "]", ")", ".", "astype", "(", "\n", "np", ".", "float16", ")", ")", ",", "\n", "(", "'QAveragePooling2D'", ",", "(", "4", ",", "4", ",", "3", ")", ",", "(", "2", ",", "2", ")", ",", "\n", "(", "2", ",", "2", ")", ",", "'valid'", ",", "'channels_first'", ",", "quantized_bits", "(", "\n", "4", ",", "0", ",", "1", ")", ",", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "None", ")", ",", "\n", "]", ")", "\n", "def", "test_q_average_pooling", "(", "pooling", ",", "input_size", ",", "pool_size", ",", "strides", ",", "padding", ",", "\n", "data_format", ",", "average_quantizer", ",", "\n", "activation_quantizer", ",", "y", ")", ":", "\n", "  ", "\"\"\"q_average_pooling test utility.\"\"\"", "\n", "\n", "np", ".", "random", ".", "seed", "(", "33", ")", "\n", "\n", "x", "=", "Input", "(", "input_size", ")", "\n", "xin", "=", "x", "\n", "if", "pooling", "==", "'QAveragePooling2D'", ":", "\n", "    ", "x", "=", "QAveragePooling2D", "(", "\n", "pool_size", "=", "pool_size", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "data_format", "=", "data_format", ",", "\n", "average_quantizer", "=", "average_quantizer", ",", "\n", "activation", "=", "activation_quantizer", ",", "\n", "name", "=", "'qpooling'", ")", "(", "x", ")", "\n", "", "else", ":", "\n", "    ", "x", "=", "QGlobalAveragePooling2D", "(", "\n", "data_format", "=", "data_format", ",", "\n", "average_quantizer", "=", "average_quantizer", ",", "\n", "activation", "=", "activation_quantizer", ",", "\n", "name", "=", "'qpooling'", ")", "(", "\n", "x", ")", "\n", "", "model", "=", "Model", "(", "inputs", "=", "xin", ",", "outputs", "=", "x", ")", "\n", "\n", "# Prints qstats to make sure it works with Conv1D layer", "\n", "print_qstats", "(", "model", ")", "\n", "\n", "size", "=", "(", "2", ",", ")", "+", "input_size", "\n", "inputs", "=", "np", ".", "random", ".", "rand", "(", "size", "[", "0", "]", ",", "size", "[", "1", "]", ",", "size", "[", "2", "]", ",", "size", "[", "3", "]", ")", "\n", "\n", "if", "data_format", "==", "'channels_first'", ":", "\n", "    ", "assert_raises", "(", "tf", ".", "errors", ".", "InvalidArgumentError", ",", "model", ".", "predict", ",", "inputs", ")", "\n", "", "else", ":", "\n", "    ", "p", "=", "model", ".", "predict", "(", "inputs", ")", ".", "astype", "(", "np", ".", "float16", ")", "\n", "assert_allclose", "(", "p", ",", "y", ",", "rtol", "=", "1e-4", ")", "\n", "\n", "# Reloads the model to ensure saving/loading works", "\n", "json_string", "=", "model", ".", "to_json", "(", ")", "\n", "clear_session", "(", ")", "\n", "reload_model", "=", "quantized_model_from_json", "(", "json_string", ")", "\n", "p", "=", "reload_model", ".", "predict", "(", "inputs", ")", ".", "astype", "(", "np", ".", "float16", ")", "\n", "assert_allclose", "(", "p", ",", "y", ",", "rtol", "=", "1e-4", ")", "\n", "\n", "# Saves the model as an h5 file using Keras's model.save()", "\n", "fd", ",", "fname", "=", "tempfile", ".", "mkstemp", "(", "\".h5\"", ")", "\n", "model", ".", "save", "(", "fname", ")", "\n", "del", "model", "# Delete the existing model", "\n", "\n", "# Returns a compiled model identical to the previous one", "\n", "loaded_model", "=", "load_qmodel", "(", "fname", ")", "\n", "\n", "# Cleans the created h5 file after loading the model", "\n", "os", ".", "close", "(", "fd", ")", "\n", "os", ".", "remove", "(", "fname", ")", "\n", "\n", "# Applys quantizer to weights", "\n", "model_save_quantized_weights", "(", "loaded_model", ")", "\n", "p", "=", "loaded_model", ".", "predict", "(", "inputs", ")", ".", "astype", "(", "np", ".", "float16", ")", "\n", "assert_allclose", "(", "p", ",", "y", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qpooling_test.test_qpooling_in_model_quantize": [[145, 173], ["tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "qkeras.utils.model_quantize", "qkeras.print_qstats", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "tensorflow.keras.layers.AveragePooling2D", "tensorflow.keras.layers.GlobalAveragePooling2D", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize", "home.repos.pwc.inspect_result.google_qkeras.qtools.interface.print_qstats"], ["", "", "def", "test_qpooling_in_model_quantize", "(", ")", ":", "\n", "  ", "input_size", "=", "(", "16", ",", "16", ",", "3", ")", "\n", "pool_size", "=", "(", "2", ",", "2", ")", "\n", "\n", "x", "=", "Input", "(", "input_size", ")", "\n", "xin", "=", "x", "\n", "x", "=", "AveragePooling2D", "(", "pool_size", "=", "pool_size", ",", "name", "=", "\"pooling\"", ")", "(", "x", ")", "\n", "x", "=", "GlobalAveragePooling2D", "(", "name", "=", "\"global_pooling\"", ")", "(", "x", ")", "\n", "model", "=", "Model", "(", "inputs", "=", "xin", ",", "outputs", "=", "x", ")", "\n", "\n", "quantize_config", "=", "{", "\n", "\"QAveragePooling2D\"", ":", "{", "\n", "\"average_quantizer\"", ":", "\"binary\"", ",", "\n", "\"activation_quantizer\"", ":", "\"binary\"", "\n", "}", ",", "\n", "\"QGlobalAveragePooling2D\"", ":", "{", "\n", "\"average_quantizer\"", ":", "\"quantized_bits(4, 0, 1)\"", ",", "\n", "\"activation_quantizer\"", ":", "\"ternary\"", "\n", "}", "\n", "}", "\n", "\n", "qmodel", "=", "model_quantize", "(", "model", ",", "quantize_config", ",", "4", ")", "\n", "print_qstats", "(", "qmodel", ")", "\n", "assert_equal", "(", "str", "(", "qmodel", ".", "layers", "[", "1", "]", ".", "average_quantizer_internal", ")", ",", "\"binary()\"", ")", "\n", "assert_equal", "(", "str", "(", "qmodel", ".", "layers", "[", "1", "]", ".", "activation", ")", ",", "\"binary()\"", ")", "\n", "assert_equal", "(", "\n", "str", "(", "qmodel", ".", "layers", "[", "2", "]", ".", "average_quantizer_internal", ")", ",", "\"quantized_bits(4,0,1)\"", ")", "\n", "assert_equal", "(", "str", "(", "qmodel", ".", "layers", "[", "2", "]", ".", "activation", ")", ",", "\"ternary()\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qpooling_test.test_qpooling_in_qtools": [[175, 261], ["tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "qkeras.qtools.qgraph.CreateGraph", "qkeras.qtools.qgraph.GraphPropagateActivationsToEdges", "qkeras.qtools.generate_layer_data_type_map.generate_layer_data_type_map", "qkeras.qtools.interface.map_to_json", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "qkeras.quantized_bits", "qkeras.QAveragePooling2D", "qkeras.QGlobalAveragePooling2D", "qkeras.binary", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.ternary"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.CreateGraph", "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphPropagateActivationsToEdges", "home.repos.pwc.inspect_result.google_qkeras.qtools.generate_layer_data_type_map.generate_layer_data_type_map", "home.repos.pwc.inspect_result.google_qkeras.qtools.interface.map_to_json"], ["", "def", "test_qpooling_in_qtools", "(", ")", ":", "\n", "  ", "input_size", "=", "(", "16", ",", "16", ",", "3", ")", "\n", "pool_size", "=", "(", "2", ",", "2", ")", "\n", "input_quantizers", "=", "[", "quantized_bits", "(", "8", ",", "0", ",", "1", ")", "]", "\n", "is_inference", "=", "False", "\n", "\n", "x", "=", "Input", "(", "input_size", ")", "\n", "xin", "=", "x", "\n", "x", "=", "QAveragePooling2D", "(", "\n", "pool_size", "=", "pool_size", ",", "\n", "average_quantizer", "=", "binary", "(", ")", ",", "\n", "activation", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"pooling\"", ")", "(", "\n", "x", ")", "\n", "x", "=", "QGlobalAveragePooling2D", "(", "\n", "average_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "activation", "=", "ternary", "(", ")", ",", "\n", "name", "=", "\"global_pooling\"", ")", "(", "\n", "x", ")", "\n", "model", "=", "Model", "(", "inputs", "=", "xin", ",", "outputs", "=", "x", ")", "\n", "\n", "(", "graph", ",", "source_quantizer_list", ")", "=", "qgraph", ".", "CreateGraph", "(", "\n", "model", ",", "input_quantizers", ")", "\n", "\n", "qgraph", ".", "GraphPropagateActivationsToEdges", "(", "graph", ")", "\n", "\n", "layer_map", "=", "generate_layer_data_type_map", ".", "generate_layer_data_type_map", "(", "\n", "graph", ",", "source_quantizer_list", ",", "is_inference", ")", "\n", "\n", "dtype_dict", "=", "interface", ".", "map_to_json", "(", "layer_map", ")", "\n", "\n", "# Checks the QAveragePpooling layer datatype", "\n", "multiplier", "=", "dtype_dict", "[", "\"pooling\"", "]", "[", "\"pool_avg_multiplier\"", "]", "\n", "accumulator", "=", "dtype_dict", "[", "\"pooling\"", "]", "[", "\"pool_sum_accumulator\"", "]", "\n", "average_quantizer", "=", "dtype_dict", "[", "\"pooling\"", "]", "[", "\"average_quantizer\"", "]", "\n", "output", "=", "dtype_dict", "[", "\"pooling\"", "]", "[", "\"output_quantizer\"", "]", "\n", "\n", "assert_equal", "(", "multiplier", "[", "\"quantizer_type\"", "]", ",", "\"quantized_bits\"", ")", "\n", "assert_equal", "(", "multiplier", "[", "\"bits\"", "]", ",", "10", ")", "\n", "assert_equal", "(", "multiplier", "[", "\"int_bits\"", "]", ",", "3", ")", "\n", "assert_equal", "(", "multiplier", "[", "\"is_signed\"", "]", ",", "1", ")", "\n", "assert_equal", "(", "multiplier", "[", "\"op_type\"", "]", ",", "\"mux\"", ")", "\n", "\n", "assert_equal", "(", "accumulator", "[", "\"quantizer_type\"", "]", ",", "\"quantized_bits\"", ")", "\n", "assert_equal", "(", "accumulator", "[", "\"bits\"", "]", ",", "10", ")", "\n", "assert_equal", "(", "accumulator", "[", "\"int_bits\"", "]", ",", "3", ")", "\n", "assert_equal", "(", "accumulator", "[", "\"is_signed\"", "]", ",", "1", ")", "\n", "assert_equal", "(", "accumulator", "[", "\"op_type\"", "]", ",", "\"add\"", ")", "\n", "\n", "assert_equal", "(", "output", "[", "\"quantizer_type\"", "]", ",", "\"quantized_bits\"", ")", "\n", "assert_equal", "(", "output", "[", "\"bits\"", "]", ",", "4", ")", "\n", "assert_equal", "(", "output", "[", "\"int_bits\"", "]", ",", "1", ")", "\n", "assert_equal", "(", "output", "[", "\"is_signed\"", "]", ",", "1", ")", "\n", "\n", "assert_equal", "(", "average_quantizer", "[", "\"quantizer_type\"", "]", ",", "\"binary\"", ")", "\n", "assert_equal", "(", "average_quantizer", "[", "\"bits\"", "]", ",", "1", ")", "\n", "assert_equal", "(", "average_quantizer", "[", "\"int_bits\"", "]", ",", "1", ")", "\n", "assert_equal", "(", "average_quantizer", "[", "\"is_signed\"", "]", ",", "1", ")", "\n", "\n", "# Checks the QGlobalAveragePooling layer datatype", "\n", "multiplier", "=", "dtype_dict", "[", "\"global_pooling\"", "]", "[", "\"pool_avg_multiplier\"", "]", "\n", "accumulator", "=", "dtype_dict", "[", "\"global_pooling\"", "]", "[", "\"pool_sum_accumulator\"", "]", "\n", "average_quantizer", "=", "dtype_dict", "[", "\"global_pooling\"", "]", "[", "\"average_quantizer\"", "]", "\n", "output", "=", "dtype_dict", "[", "\"global_pooling\"", "]", "[", "\"output_quantizer\"", "]", "\n", "\n", "assert_equal", "(", "multiplier", "[", "\"quantizer_type\"", "]", ",", "\"quantized_bits\"", ")", "\n", "assert_equal", "(", "multiplier", "[", "\"bits\"", "]", ",", "13", ")", "\n", "assert_equal", "(", "multiplier", "[", "\"int_bits\"", "]", ",", "7", ")", "\n", "assert_equal", "(", "multiplier", "[", "\"is_signed\"", "]", ",", "1", ")", "\n", "assert_equal", "(", "multiplier", "[", "\"op_type\"", "]", ",", "\"mul\"", ")", "\n", "\n", "assert_equal", "(", "accumulator", "[", "\"quantizer_type\"", "]", ",", "\"quantized_bits\"", ")", "\n", "assert_equal", "(", "accumulator", "[", "\"bits\"", "]", ",", "10", ")", "\n", "assert_equal", "(", "accumulator", "[", "\"int_bits\"", "]", ",", "7", ")", "\n", "assert_equal", "(", "accumulator", "[", "\"is_signed\"", "]", ",", "1", ")", "\n", "assert_equal", "(", "accumulator", "[", "\"op_type\"", "]", ",", "\"add\"", ")", "\n", "\n", "assert_equal", "(", "output", "[", "\"quantizer_type\"", "]", ",", "\"ternary\"", ")", "\n", "assert_equal", "(", "output", "[", "\"bits\"", "]", ",", "2", ")", "\n", "assert_equal", "(", "output", "[", "\"int_bits\"", "]", ",", "2", ")", "\n", "assert_equal", "(", "output", "[", "\"is_signed\"", "]", ",", "1", ")", "\n", "\n", "assert_equal", "(", "average_quantizer", "[", "\"quantizer_type\"", "]", ",", "\"quantized_bits\"", ")", "\n", "assert_equal", "(", "average_quantizer", "[", "\"bits\"", "]", ",", "4", ")", "\n", "assert_equal", "(", "average_quantizer", "[", "\"int_bits\"", "]", ",", "1", ")", "\n", "assert_equal", "(", "average_quantizer", "[", "\"is_signed\"", "]", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qpooling_test.test_QAveragePooling_output": [[263, 278], ["numpy.ones", "tensorflow.constant", "y.numpy.numpy", "numpy.all", "qkeras.QAveragePooling2D"], "function", ["None"], ["", "def", "test_QAveragePooling_output", "(", ")", ":", "\n", "# Checks if the output of QAveragePooling layer with average_quantizer", "\n", "# is correct.", "\n", "  ", "x", "=", "np", ".", "ones", "(", "shape", "=", "(", "2", ",", "6", ",", "6", ",", "1", ")", ")", "\n", "x", "[", "0", ",", "0", ",", ":", ",", ":", "]", "=", "0", "\n", "x", "=", "tf", ".", "constant", "(", "x", ")", "\n", "\n", "y", "=", "QAveragePooling2D", "(", "\n", "pool_size", "=", "(", "3", ",", "3", ")", ",", "\n", "strides", "=", "3", ",", "\n", "padding", "=", "\"valid\"", ",", "\n", "average_quantizer", "=", "\"quantized_bits(8, 1, 1)\"", ")", "(", "x", ")", "\n", "y", "=", "y", ".", "numpy", "(", ")", "\n", "assert", "np", ".", "all", "(", "y", "==", "[", "[", "[", "[", "0.65625", "]", ",", "[", "0.65625", "]", "]", ",", "[", "[", "0.984375", "]", ",", "[", "0.984375", "]", "]", "]", ",", "\n", "[", "[", "[", "0.984375", "]", ",", "[", "0.984375", "]", "]", ",", "[", "[", "0.984375", "]", ",", "[", "0.984375", "]", "]", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qpooling_test.test_QGlobalAveragePooling_output": [[280, 289], ["numpy.ones", "tensorflow.constant", "y.numpy.numpy", "numpy.all", "qkeras.QGlobalAveragePooling2D", "numpy.array"], "function", ["None"], ["", "def", "test_QGlobalAveragePooling_output", "(", ")", ":", "\n", "# Checks if the output of QGlobalAveragePooling layer with average_quantizer", "\n", "# is correct.", "\n", "  ", "x", "=", "np", ".", "ones", "(", "shape", "=", "(", "2", ",", "3", ",", "3", ",", "2", ")", ")", "\n", "x", "[", "0", ",", "0", ",", "1", ",", ":", "]", "=", "0", "\n", "x", "=", "tf", ".", "constant", "(", "x", ")", "\n", "y", "=", "QGlobalAveragePooling2D", "(", "average_quantizer", "=", "\"quantized_bits(8, 1, 1)\"", ")", "(", "x", ")", "\n", "y", "=", "y", ".", "numpy", "(", ")", "\n", "assert", "np", ".", "all", "(", "y", "==", "np", ".", "array", "(", "[", "[", "0.875", ",", "0.875", "]", ",", "[", "0.984375", ",", "0.984375", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qlayers_test.qdense_util": [[38, 54], ["layer_cls", "tensorflow.keras.layers.Input", "layer_cls.", "layer_cls.set_weights", "tensorflow.keras.models.Model", "tensorflow.keras.models.Model.predict", "numpy.testing.assert_allclose"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict"], ["def", "qdense_util", "(", "layer_cls", ",", "\n", "kwargs", "=", "None", ",", "\n", "input_data", "=", "None", ",", "\n", "weight_data", "=", "None", ",", "\n", "expected_output", "=", "None", ")", ":", "\n", "  ", "\"\"\"qlayer test utility.\"\"\"", "\n", "input_shape", "=", "input_data", ".", "shape", "\n", "input_dtype", "=", "input_data", ".", "dtype", "\n", "layer", "=", "layer_cls", "(", "**", "kwargs", ")", "\n", "x", "=", "Input", "(", "shape", "=", "input_shape", "[", "1", ":", "]", ",", "dtype", "=", "input_dtype", ")", "\n", "y", "=", "layer", "(", "x", ")", "\n", "layer", ".", "set_weights", "(", "weight_data", ")", "\n", "model", "=", "Model", "(", "x", ",", "y", ")", "\n", "actual_output", "=", "model", ".", "predict", "(", "input_data", ")", "\n", "if", "expected_output", "is", "not", "None", ":", "\n", "    ", "assert_allclose", "(", "actual_output", ",", "expected_output", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qlayers_test.test_qdense": [[56, 94], ["pytest.mark.parametrize", "qlayers_test.qdense_util", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.qlayers_test.qdense_util"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'layer_kwargs, input_data, weight_data, bias_data, expected_output'", ",", "\n", "[", "\n", "(", "\n", "{", "\n", "'units'", ":", "2", ",", "\n", "'use_bias'", ":", "True", ",", "\n", "'kernel_initializer'", ":", "'glorot_uniform'", ",", "\n", "'bias_initializer'", ":", "'zeros'", "\n", "}", ",", "\n", "np", ".", "array", "(", "[", "[", "1", ",", "1", ",", "1", ",", "1", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "10", ",", "20", "]", ",", "[", "10", ",", "20", "]", ",", "[", "10", ",", "20", "]", ",", "[", "10", ",", "20", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "# weight_data", "\n", "np", ".", "array", "(", "[", "0", ",", "0", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "# bias", "\n", "np", ".", "array", "(", "[", "[", "40", ",", "80", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ")", ",", "# expected_output", "\n", "(", "\n", "{", "\n", "'units'", ":", "2", ",", "\n", "'use_bias'", ":", "True", ",", "\n", "'kernel_initializer'", ":", "'glorot_uniform'", ",", "\n", "'bias_initializer'", ":", "'zeros'", ",", "\n", "'kernel_quantizer'", ":", "'quantized_bits(2,0,alpha=1.0)'", ",", "\n", "'bias_quantizer'", ":", "'quantized_bits(2,0)'", ",", "\n", "}", ",", "\n", "np", ".", "array", "(", "[", "[", "1", ",", "1", ",", "1", ",", "1", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "10", ",", "20", "]", ",", "[", "10", ",", "20", "]", ",", "[", "10", ",", "20", "]", ",", "[", "10", ",", "20", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "# weight_data", "\n", "np", ".", "array", "(", "[", "0", ",", "0", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "# bias", "\n", "np", ".", "array", "(", "[", "[", "2", ",", "2", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ")", ",", "#expected_output", "\n", "]", ")", "\n", "def", "test_qdense", "(", "layer_kwargs", ",", "input_data", ",", "weight_data", ",", "bias_data", ",", "\n", "expected_output", ")", ":", "\n", "  ", "qdense_util", "(", "\n", "layer_cls", "=", "QDense", ",", "\n", "kwargs", "=", "layer_kwargs", ",", "\n", "input_data", "=", "input_data", ",", "\n", "weight_data", "=", "[", "weight_data", ",", "bias_data", "]", ",", "\n", "expected_output", "=", "expected_output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.quantizer_impl_test.test_QuantizedBits": [[34, 47], ["qkeras.quantizers.quantized_bits", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits", "quantizer_impl.QuantizedBits.convert_qkeras_quantizer", "quantizer_impl.QuantizedBits.convert_to_qkeras_quantizer", "result.items", "numpy.testing.assert_equal"], "function", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_qkeras_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_to_qkeras_quantizer"], ["def", "test_QuantizedBits", "(", ")", ":", "\n", "  ", "qkeras_quantizer", "=", "quantizers", ".", "quantized_bits", "(", ")", "\n", "qtools_quantizer", "=", "quantizer_impl", ".", "QuantizedBits", "(", ")", "\n", "qtools_quantizer", ".", "convert_qkeras_quantizer", "(", "qkeras_quantizer", ")", "\n", "new_quantizer", "=", "qtools_quantizer", ".", "convert_to_qkeras_quantizer", "(", "\n", "symmetric", "=", "qkeras_quantizer", ".", "symmetric", ",", "alpha", "=", "qkeras_quantizer", ".", "alpha", ",", "\n", "use_stochastic_rounding", "=", "qkeras_quantizer", ".", "use_stochastic_rounding", ",", "\n", "scale_axis", "=", "qkeras_quantizer", ".", "scale_axis", ",", "\n", "qnoise_factor", "=", "qkeras_quantizer", ".", "qnoise_factor", ")", "\n", "\n", "result", "=", "new_quantizer", ".", "__dict__", "\n", "for", "(", "key", ",", "val", ")", "in", "result", ".", "items", "(", ")", ":", "\n", "    ", "assert_equal", "(", "val", ",", "qkeras_quantizer", ".", "__dict__", "[", "key", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.quantizer_impl_test.test_QuantizedTanh": [[49, 60], ["qkeras.quantizers.quantized_tanh", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedTanh", "quantizer_impl.QuantizedTanh.convert_qkeras_quantizer", "quantizer_impl.QuantizedTanh.convert_to_qkeras_quantizer", "result.items", "numpy.testing.assert_equal"], "function", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_qkeras_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_to_qkeras_quantizer"], ["", "", "def", "test_QuantizedTanh", "(", ")", ":", "\n", "  ", "qkeras_quantizer", "=", "quantizers", ".", "quantized_tanh", "(", ")", "\n", "qtools_quantizer", "=", "quantizer_impl", ".", "QuantizedTanh", "(", ")", "\n", "qtools_quantizer", ".", "convert_qkeras_quantizer", "(", "qkeras_quantizer", ")", "\n", "new_quantizer", "=", "qtools_quantizer", ".", "convert_to_qkeras_quantizer", "(", "\n", "use_stochastic_rounding", "=", "qkeras_quantizer", ".", "use_stochastic_rounding", ",", "\n", "symmetric", "=", "qkeras_quantizer", ".", "symmetric", ")", "\n", "\n", "result", "=", "new_quantizer", ".", "__dict__", "\n", "for", "(", "key", ",", "val", ")", "in", "result", ".", "items", "(", ")", ":", "\n", "    ", "assert_equal", "(", "val", ",", "qkeras_quantizer", ".", "__dict__", "[", "key", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.quantizer_impl_test.test_QuantizedUlaw": [[62, 73], ["qkeras.quantizers.quantized_ulaw", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedUlaw", "quantizer_impl.QuantizedUlaw.convert_qkeras_quantizer", "quantizer_impl.QuantizedUlaw.convert_to_qkeras_quantizer", "result.items", "numpy.testing.assert_equal"], "function", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_qkeras_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_to_qkeras_quantizer"], ["", "", "def", "test_QuantizedUlaw", "(", ")", ":", "\n", "  ", "qkeras_quantizer", "=", "quantizers", ".", "quantized_ulaw", "(", ")", "\n", "qtools_quantizer", "=", "quantizer_impl", ".", "QuantizedUlaw", "(", ")", "\n", "qtools_quantizer", ".", "convert_qkeras_quantizer", "(", "qkeras_quantizer", ")", "\n", "new_quantizer", "=", "qtools_quantizer", ".", "convert_to_qkeras_quantizer", "(", "\n", "symmetric", "=", "qkeras_quantizer", ".", "symmetric", ",", "\n", "u", "=", "qkeras_quantizer", ".", "u", ")", "\n", "\n", "result", "=", "new_quantizer", ".", "__dict__", "\n", "for", "(", "key", ",", "val", ")", "in", "result", ".", "items", "(", ")", ":", "\n", "    ", "assert_equal", "(", "val", ",", "qkeras_quantizer", ".", "__dict__", "[", "key", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.quantizer_impl_test.test_Binary": [[75, 86], ["qkeras.quantizers.binary", "qkeras.qtools.quantized_operators.quantizer_impl.Binary", "quantizer_impl.Binary.convert_qkeras_quantizer", "quantizer_impl.Binary.convert_to_qkeras_quantizer", "result.items", "numpy.testing.assert_equal"], "function", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_qkeras_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_to_qkeras_quantizer"], ["", "", "def", "test_Binary", "(", ")", ":", "\n", "  ", "qkeras_quantizer", "=", "quantizers", ".", "binary", "(", ")", "\n", "qtools_quantizer", "=", "quantizer_impl", ".", "Binary", "(", ")", "\n", "qtools_quantizer", ".", "convert_qkeras_quantizer", "(", "qkeras_quantizer", ")", "\n", "new_quantizer", "=", "qtools_quantizer", ".", "convert_to_qkeras_quantizer", "(", "\n", "alpha", "=", "qkeras_quantizer", ".", "alpha", ",", "\n", "use_stochastic_rounding", "=", "qkeras_quantizer", ".", "use_stochastic_rounding", ")", "\n", "\n", "result", "=", "new_quantizer", ".", "__dict__", "\n", "for", "(", "key", ",", "val", ")", "in", "result", ".", "items", "(", ")", ":", "\n", "    ", "assert_equal", "(", "val", ",", "qkeras_quantizer", ".", "__dict__", "[", "key", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.quantizer_impl_test.test_StochasticBinary": [[88, 100], ["qkeras.quantizers.stochastic_binary", "qkeras.qtools.quantized_operators.quantizer_impl.StochasticBinary", "quantizer_impl.StochasticBinary.convert_qkeras_quantizer", "quantizer_impl.StochasticBinary.convert_to_qkeras_quantizer", "result.items", "numpy.testing.assert_equal"], "function", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_qkeras_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_to_qkeras_quantizer"], ["", "", "def", "test_StochasticBinary", "(", ")", ":", "\n", "  ", "qkeras_quantizer", "=", "quantizers", ".", "stochastic_binary", "(", ")", "\n", "qtools_quantizer", "=", "quantizer_impl", ".", "StochasticBinary", "(", ")", "\n", "qtools_quantizer", ".", "convert_qkeras_quantizer", "(", "qkeras_quantizer", ")", "\n", "new_quantizer", "=", "qtools_quantizer", ".", "convert_to_qkeras_quantizer", "(", "\n", "alpha", "=", "qkeras_quantizer", ".", "alpha", ",", "\n", "temperature", "=", "qkeras_quantizer", ".", "temperature", ",", "\n", "use_real_sigmoid", "=", "qkeras_quantizer", ".", "use_real_sigmoid", ")", "\n", "\n", "result", "=", "new_quantizer", ".", "__dict__", "\n", "for", "(", "key", ",", "val", ")", "in", "result", ".", "items", "(", ")", ":", "\n", "    ", "assert_equal", "(", "val", ",", "qkeras_quantizer", ".", "__dict__", "[", "key", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.quantizer_impl_test.test_Bernoulli": [[102, 113], ["qkeras.quantizers.bernoulli", "qkeras.qtools.quantized_operators.quantizer_impl.Bernoulli", "quantizer_impl.Bernoulli.convert_qkeras_quantizer", "quantizer_impl.Bernoulli.convert_to_qkeras_quantizer", "result.items", "numpy.testing.assert_equal"], "function", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_qkeras_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_to_qkeras_quantizer"], ["", "", "def", "test_Bernoulli", "(", ")", ":", "\n", "  ", "qkeras_quantizer", "=", "quantizers", ".", "bernoulli", "(", ")", "\n", "qtools_quantizer", "=", "quantizer_impl", ".", "Bernoulli", "(", ")", "\n", "qtools_quantizer", ".", "convert_qkeras_quantizer", "(", "qkeras_quantizer", ")", "\n", "new_quantizer", "=", "qtools_quantizer", ".", "convert_to_qkeras_quantizer", "(", "\n", "alpha", "=", "qkeras_quantizer", ".", "alpha", ",", "temperature", "=", "qkeras_quantizer", ".", "temperature", ",", "\n", "use_real_sigmoid", "=", "qkeras_quantizer", ".", "use_real_sigmoid", ")", "\n", "\n", "result", "=", "new_quantizer", ".", "__dict__", "\n", "for", "(", "key", ",", "val", ")", "in", "result", ".", "items", "(", ")", ":", "\n", "    ", "assert_equal", "(", "val", ",", "qkeras_quantizer", ".", "__dict__", "[", "key", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.quantizer_impl_test.test_QuantizedRelu": [[115, 130], ["qkeras.quantizers.quantized_relu", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedRelu", "quantizer_impl.QuantizedRelu.convert_qkeras_quantizer", "quantizer_impl.QuantizedRelu.convert_to_qkeras_quantizer", "result.items", "numpy.testing.assert_equal"], "function", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_qkeras_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_to_qkeras_quantizer"], ["", "", "def", "test_QuantizedRelu", "(", ")", ":", "\n", "  ", "qkeras_quantizer", "=", "quantizers", ".", "quantized_relu", "(", ")", "\n", "qtools_quantizer", "=", "quantizer_impl", ".", "QuantizedRelu", "(", ")", "\n", "qtools_quantizer", ".", "convert_qkeras_quantizer", "(", "qkeras_quantizer", ")", "\n", "new_quantizer", "=", "qtools_quantizer", ".", "convert_to_qkeras_quantizer", "(", "\n", "use_sigmoid", "=", "qkeras_quantizer", ".", "use_sigmoid", ",", "\n", "negative_slope", "=", "qkeras_quantizer", ".", "negative_slope", ",", "\n", "use_stochastic_rounding", "=", "qkeras_quantizer", ".", "use_stochastic_rounding", ",", "\n", "relu_upper_bound", "=", "qkeras_quantizer", ".", "relu_upper_bound", ",", "\n", "is_quantized_clip", "=", "qkeras_quantizer", ".", "is_quantized_clip", ",", "\n", "qnoise_factor", "=", "qkeras_quantizer", ".", "qnoise_factor", ")", "\n", "\n", "result", "=", "new_quantizer", ".", "__dict__", "\n", "for", "(", "key", ",", "val", ")", "in", "result", ".", "items", "(", ")", ":", "\n", "    ", "assert_equal", "(", "val", ",", "qkeras_quantizer", ".", "__dict__", "[", "key", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.quantizer_impl_test.test_Ternary": [[132, 145], ["qkeras.quantizers.ternary", "qkeras.qtools.quantized_operators.quantizer_impl.Ternary", "quantizer_impl.Ternary.convert_qkeras_quantizer", "quantizer_impl.Ternary.convert_to_qkeras_quantizer", "result.items", "numpy.testing.assert_equal"], "function", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_qkeras_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_to_qkeras_quantizer"], ["", "", "def", "test_Ternary", "(", ")", ":", "\n", "\n", "  ", "qkeras_quantizer", "=", "quantizers", ".", "ternary", "(", ")", "\n", "qtools_quantizer", "=", "quantizer_impl", ".", "Ternary", "(", ")", "\n", "qtools_quantizer", ".", "convert_qkeras_quantizer", "(", "qkeras_quantizer", ")", "\n", "new_quantizer", "=", "qtools_quantizer", ".", "convert_to_qkeras_quantizer", "(", "\n", "alpha", "=", "qkeras_quantizer", ".", "alpha", ",", "threshold", "=", "qkeras_quantizer", ".", "threshold", ",", "\n", "use_stochastic_rounding", "=", "qkeras_quantizer", ".", "use_stochastic_rounding", ",", "\n", "number_of_unrolls", "=", "qkeras_quantizer", ".", "number_of_unrolls", ")", "\n", "\n", "result", "=", "new_quantizer", ".", "__dict__", "\n", "for", "(", "key", ",", "val", ")", "in", "result", ".", "items", "(", ")", ":", "\n", "    ", "assert_equal", "(", "val", ",", "qkeras_quantizer", ".", "__dict__", "[", "key", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.quantizer_impl_test.test_StochasticTernary": [[147, 160], ["qkeras.quantizers.stochastic_ternary", "qkeras.qtools.quantized_operators.quantizer_impl.StochasticTernary", "quantizer_impl.StochasticTernary.convert_qkeras_quantizer", "quantizer_impl.StochasticTernary.convert_to_qkeras_quantizer", "result.items", "numpy.testing.assert_equal"], "function", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_qkeras_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_to_qkeras_quantizer"], ["", "", "def", "test_StochasticTernary", "(", ")", ":", "\n", "  ", "qkeras_quantizer", "=", "quantizers", ".", "stochastic_ternary", "(", ")", "\n", "qtools_quantizer", "=", "quantizer_impl", ".", "StochasticTernary", "(", ")", "\n", "qtools_quantizer", ".", "convert_qkeras_quantizer", "(", "qkeras_quantizer", ")", "\n", "new_quantizer", "=", "qtools_quantizer", ".", "convert_to_qkeras_quantizer", "(", "\n", "alpha", "=", "qkeras_quantizer", ".", "alpha", ",", "threshold", "=", "qkeras_quantizer", ".", "threshold", ",", "\n", "temperature", "=", "qkeras_quantizer", ".", "temperature", ",", "\n", "use_real_sigmoid", "=", "qkeras_quantizer", ".", "use_real_sigmoid", ",", "\n", "number_of_unrolls", "=", "qkeras_quantizer", ".", "number_of_unrolls", ")", "\n", "\n", "result", "=", "new_quantizer", ".", "__dict__", "\n", "for", "(", "key", ",", "val", ")", "in", "result", ".", "items", "(", ")", ":", "\n", "    ", "assert_equal", "(", "val", ",", "qkeras_quantizer", ".", "__dict__", "[", "key", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.quantizer_impl_test.test_PowerOfTwo": [[162, 174], ["qkeras.quantizers.quantized_po2", "qkeras.qtools.quantized_operators.quantizer_impl.PowerOfTwo", "quantizer_impl.PowerOfTwo.convert_qkeras_quantizer", "quantizer_impl.PowerOfTwo.convert_to_qkeras_quantizer", "result.items", "numpy.testing.assert_equal"], "function", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_qkeras_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_to_qkeras_quantizer"], ["", "", "def", "test_PowerOfTwo", "(", ")", ":", "\n", "  ", "qkeras_quantizer", "=", "quantizers", ".", "quantized_po2", "(", ")", "\n", "qtools_quantizer", "=", "quantizer_impl", ".", "PowerOfTwo", "(", "is_signed", "=", "True", ")", "\n", "qtools_quantizer", ".", "convert_qkeras_quantizer", "(", "qkeras_quantizer", ")", "\n", "new_quantizer", "=", "qtools_quantizer", ".", "convert_to_qkeras_quantizer", "(", "\n", "negative_slope", "=", "None", ",", "\n", "use_stochastic_rounding", "=", "qkeras_quantizer", ".", "use_stochastic_rounding", ",", "\n", "quadratic_approximation", "=", "qkeras_quantizer", ".", "quadratic_approximation", ")", "\n", "\n", "result", "=", "new_quantizer", ".", "__dict__", "\n", "for", "(", "key", ",", "val", ")", "in", "result", ".", "items", "(", ")", ":", "\n", "    ", "assert_equal", "(", "val", ",", "qkeras_quantizer", ".", "__dict__", "[", "key", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.quantizer_impl_test.test_ReluPowerOfTwo": [[176, 188], ["qkeras.quantizers.quantized_relu_po2", "qkeras.qtools.quantized_operators.quantizer_impl.ReluPowerOfTwo", "quantizer_impl.ReluPowerOfTwo.convert_qkeras_quantizer", "quantizer_impl.ReluPowerOfTwo.convert_to_qkeras_quantizer", "result.items", "numpy.testing.assert_equal"], "function", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_qkeras_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_to_qkeras_quantizer"], ["", "", "def", "test_ReluPowerOfTwo", "(", ")", ":", "\n", "  ", "qkeras_quantizer", "=", "quantizers", ".", "quantized_relu_po2", "(", ")", "\n", "qtools_quantizer", "=", "quantizer_impl", ".", "ReluPowerOfTwo", "(", ")", "\n", "qtools_quantizer", ".", "convert_qkeras_quantizer", "(", "qkeras_quantizer", ")", "\n", "new_quantizer", "=", "qtools_quantizer", ".", "convert_to_qkeras_quantizer", "(", "\n", "negative_slope", "=", "qkeras_quantizer", ".", "negative_slope", ",", "\n", "use_stochastic_rounding", "=", "qkeras_quantizer", ".", "use_stochastic_rounding", ",", "\n", "quadratic_approximation", "=", "qkeras_quantizer", ".", "quadratic_approximation", ")", "\n", "\n", "result", "=", "new_quantizer", ".", "__dict__", "\n", "for", "(", "key", ",", "val", ")", "in", "result", ".", "items", "(", ")", ":", "\n", "    ", "assert_equal", "(", "val", ",", "qkeras_quantizer", ".", "__dict__", "[", "key", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.quantizer_impl_test.test_GetScale_PerChannelScale": [[190, 230], ["tensorflow.ones", "tensorflow.ones", "qkeras.quantizers._get_scale", "qkeras.quantizers._get_scale", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "tensorflow.ones", "tensorflow.ones", "qkeras.quantizers._get_scale", "qkeras.quantizers._get_scale", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "tensorflow.ones", "tensorflow.ones", "qkeras.quantizers._get_scale", "qkeras.quantizers._get_scale", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "tensorflow.ones", "tensorflow.ones", "qkeras.quantizers._get_scale", "qkeras.quantizers._get_scale", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "tensorflow.shape().numpy", "tensorflow.shape().numpy", "tensorflow.shape().numpy", "tensorflow.shape().numpy", "tensorflow.shape().numpy", "tensorflow.shape().numpy", "tensorflow.shape().numpy", "tensorflow.shape().numpy", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_scale", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_scale", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_scale", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_scale", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_scale", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_scale", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_scale", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_scale"], ["", "", "def", "test_GetScale_PerChannelScale", "(", ")", ":", "\n", "# Rank1 tensors", "\n", "  ", "x_r1", "=", "tf", ".", "ones", "(", "[", "4", "]", ")", "\n", "q_r1", "=", "tf", ".", "ones", "(", "[", "4", "]", ")", "\n", "scale_r1_pcs_true", "=", "quantizers", ".", "_get_scale", "(", "\n", "\"auto\"", ",", "x_r1", ",", "q_r1", ",", "scale_axis", "=", "None", ",", "per_channel_scale", "=", "True", ")", "\n", "scale_r1_pcs_false", "=", "quantizers", ".", "_get_scale", "(", "\n", "\"auto\"", ",", "x_r1", ",", "q_r1", ",", "scale_axis", "=", "None", ",", "per_channel_scale", "=", "False", ")", "\n", "assert_equal", "(", "tf", ".", "shape", "(", "scale_r1_pcs_true", ")", ".", "numpy", "(", ")", ",", "[", "4", "]", ")", "\n", "assert_equal", "(", "tf", ".", "shape", "(", "scale_r1_pcs_false", ")", ".", "numpy", "(", ")", ",", "[", "1", "]", ")", "\n", "\n", "# Rank2 tensors", "\n", "x_r2", "=", "tf", ".", "ones", "(", "[", "2", ",", "4", "]", ")", "\n", "q_r2", "=", "tf", ".", "ones", "(", "[", "2", ",", "4", "]", ")", "\n", "scale_r2_pcs_true", "=", "quantizers", ".", "_get_scale", "(", "\n", "\"auto\"", ",", "x_r2", ",", "q_r2", ",", "scale_axis", "=", "None", ",", "per_channel_scale", "=", "True", ")", "\n", "scale_r2_pcs_false", "=", "quantizers", ".", "_get_scale", "(", "\n", "\"auto\"", ",", "x_r2", ",", "q_r2", ",", "scale_axis", "=", "None", ",", "per_channel_scale", "=", "False", ")", "\n", "assert_equal", "(", "tf", ".", "shape", "(", "scale_r2_pcs_true", ")", ".", "numpy", "(", ")", ",", "[", "1", ",", "4", "]", ")", "\n", "assert_equal", "(", "tf", ".", "shape", "(", "scale_r2_pcs_false", ")", ".", "numpy", "(", ")", ",", "[", "1", ",", "1", "]", ")", "\n", "\n", "# Rank3 tensors", "\n", "x_r3", "=", "tf", ".", "ones", "(", "[", "3", ",", "3", ",", "4", "]", ")", "\n", "q_r3", "=", "tf", ".", "ones", "(", "[", "3", ",", "3", ",", "4", "]", ")", "\n", "scale_r3_pcs_true", "=", "quantizers", ".", "_get_scale", "(", "\n", "\"auto\"", ",", "x_r3", ",", "q_r3", ",", "scale_axis", "=", "None", ",", "per_channel_scale", "=", "True", ")", "\n", "scale_r3_pcs_false", "=", "quantizers", ".", "_get_scale", "(", "\n", "\"auto\"", ",", "x_r3", ",", "q_r3", ",", "scale_axis", "=", "None", ",", "per_channel_scale", "=", "False", ")", "\n", "assert_equal", "(", "tf", ".", "shape", "(", "scale_r3_pcs_true", ")", ".", "numpy", "(", ")", ",", "[", "1", ",", "1", ",", "4", "]", ")", "\n", "assert_equal", "(", "tf", ".", "shape", "(", "scale_r3_pcs_false", ")", ".", "numpy", "(", ")", ",", "[", "1", ",", "1", ",", "1", "]", ")", "\n", "\n", "# Rank4 tensors", "\n", "x_r4", "=", "tf", ".", "ones", "(", "[", "1", ",", "1", ",", "3", ",", "4", "]", ")", "\n", "q_r4", "=", "tf", ".", "ones", "(", "[", "1", ",", "1", ",", "3", ",", "4", "]", ")", "\n", "scale_r4_pcs_true", "=", "quantizers", ".", "_get_scale", "(", "\n", "\"auto\"", ",", "x_r4", ",", "q_r4", ",", "scale_axis", "=", "None", ",", "per_channel_scale", "=", "True", ")", "\n", "scale_r4_pcs_false", "=", "quantizers", ".", "_get_scale", "(", "\n", "\"auto\"", ",", "x_r4", ",", "q_r4", ",", "scale_axis", "=", "None", ",", "per_channel_scale", "=", "False", ")", "\n", "assert_equal", "(", "tf", ".", "shape", "(", "scale_r4_pcs_true", ")", ".", "numpy", "(", ")", ",", "[", "1", ",", "1", ",", "1", ",", "4", "]", ")", "\n", "assert_equal", "(", "tf", ".", "shape", "(", "scale_r4_pcs_false", ")", ".", "numpy", "(", ")", ",", "[", "1", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.safe_eval_test.myaddcls.__call__": [[80, 82], ["None"], "methods", ["None"], ["  ", "def", "__call__", "(", "self", ",", "a", "=", "32", ",", "b", "=", "10", ")", ":", "\n", "    ", "return", "a", "+", "b", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.safe_eval_test.test_get_params1": [[31, 36], ["qkeras.safe_eval.GetParams"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.GetParams"], ["def", "test_get_params1", "(", ")", ":", "\n", "  ", "s", "=", "\"(3, 0.3, sep=5  )\"", "\n", "args", ",", "kwargs", "=", "GetParams", "(", "s", ")", "\n", "assert", "args", "==", "[", "3", ",", "0.3", "]", "\n", "assert", "kwargs", "==", "{", "\"sep\"", ":", "5", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.safe_eval_test.test_get_params2": [[38, 45], ["qkeras.safe_eval.GetParams"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.GetParams"], ["", "def", "test_get_params2", "(", ")", ":", "\n", "  ", "s", "=", "\"(  )\"", "\n", "\n", "args", ",", "kwargs", "=", "GetParams", "(", "s", ")", "\n", "\n", "assert", "not", "args", "\n", "assert", "not", "kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.safe_eval_test.test_get_params3": [[47, 60], ["qkeras.safe_eval.GetParams"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.GetParams"], ["", "def", "test_get_params3", "(", ")", ":", "\n", "  ", "s", "=", "(", "\"(3, 0.3,  -1.0, True, False, 'string1', num1=0.1, num2=-3.0, \"", "\n", "\"str1='string2', bool1=True, bool2=False)\"", ")", "\n", "\n", "args", ",", "kwargs", "=", "GetParams", "(", "s", ")", "\n", "\n", "assert", "args", "==", "[", "3", ",", "0.3", ",", "-", "1.0", ",", "True", ",", "False", ",", "\"string1\"", "]", "\n", "assert", "kwargs", "==", "{", "\n", "\"num1\"", ":", "0.1", ",", "\n", "\"num2\"", ":", "-", "3.0", ",", "\n", "\"str1\"", ":", "\"string2\"", ",", "\n", "\"bool1\"", ":", "True", ",", "\n", "\"bool2\"", ":", "False", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.safe_eval_test.test_safe_eval1": [[63, 66], ["qkeras.safe_eval.safe_eval", "globals"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.safe_eval"], ["", "def", "test_safe_eval1", "(", ")", ":", "\n", "  ", "s", "=", "\"add(3,3)\"", "\n", "assert", "safe_eval", "(", "s", ",", "globals", "(", ")", ")", "==", "6", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.safe_eval_test.i_func": [[68, 70], ["None"], "function", ["None"], ["", "def", "i_func", "(", "s", ")", ":", "\n", "  ", "return", "-", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.safe_eval_test.myadd2": [[72, 74], ["safe_eval_test.i_func", "safe_eval_test.i_func"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.safe_eval_test.i_func", "home.repos.pwc.inspect_result.google_qkeras.tests.safe_eval_test.i_func"], ["", "def", "myadd2", "(", "a", ",", "b", ")", ":", "\n", "  ", "return", "i_func", "(", "a", ")", "+", "i_func", "(", "b", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.safe_eval_test.myadd": [[76, 78], ["None"], "function", ["None"], ["", "def", "myadd", "(", "a", "=", "32", ",", "b", "=", "10", ")", ":", "\n", "  ", "return", "a", "+", "b", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.safe_eval_test.test_safe_eval2": [[83, 86], ["qkeras.safe_eval.safe_eval", "globals"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.safe_eval"], ["", "", "def", "test_safe_eval2", "(", ")", ":", "\n", "  ", "s_add", "=", "[", "3", ",", "39", "]", "\n", "assert", "safe_eval", "(", "\"add\"", ",", "globals", "(", ")", ",", "*", "s_add", ")", "==", "42", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.safe_eval_test.test_safe_eval3": [[88, 91], ["qkeras.safe_eval.safe_eval", "qkeras.safe_eval.safe_eval", "globals", "globals"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.safe_eval", "home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.safe_eval"], ["", "def", "test_safe_eval3", "(", ")", ":", "\n", "  ", "assert", "safe_eval", "(", "\"myadd()\"", ",", "globals", "(", ")", ")", "==", "42", "\n", "assert", "safe_eval", "(", "\"myadd(a=39)\"", ",", "globals", "(", ")", ",", "b", "=", "3", ")", "==", "42", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.safe_eval_test.test_safe_eval4": [[93, 97], ["qkeras.safe_eval.safe_eval", "qkeras.safe_eval.safe_eval", "qkeras.safe_eval.safe_eval", "globals", "globals", "globals"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.safe_eval", "home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.safe_eval", "home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.safe_eval"], ["", "def", "test_safe_eval4", "(", ")", ":", "\n", "  ", "assert", "safe_eval", "(", "\"myadd2(a=39)\"", ",", "globals", "(", ")", ",", "b", "=", "3", ")", "==", "-", "42", "\n", "assert", "safe_eval", "(", "\"myadd2(a= 39)\"", ",", "globals", "(", ")", ",", "b", "=", "3", ")", "==", "-", "42", "\n", "assert", "safe_eval", "(", "\"myadd2(a= 39, b = 3)\"", ",", "globals", "(", ")", ")", "==", "-", "42", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.safe_eval_test.test_safe_eval5": [[98, 102], ["qkeras.safe_eval.safe_eval", "qkeras.safe_eval.safe_eval", "qkeras.safe_eval.safe_eval", "globals", "globals", "globals"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.safe_eval", "home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.safe_eval", "home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.safe_eval"], ["", "def", "test_safe_eval5", "(", ")", ":", "\n", "  ", "assert", "safe_eval", "(", "\"myadd\"", ",", "globals", "(", ")", ")", "(", "3", ",", "39", ")", "==", "42", "\n", "assert", "safe_eval", "(", "\"myaddcls\"", ",", "globals", "(", ")", ")", "(", "3", ",", "39", ")", "==", "42", "\n", "assert", "safe_eval", "(", "\"myaddcls()\"", ",", "globals", "(", ")", ")", "(", "3", ",", "39", ")", "==", "42", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.codebook_test.test_codebook_weights": [[30, 75], ["pytest.mark.parametrize", "numpy.random.seed", "weights.reshape.reshape", "expected_result.reshape.reshape", "qkeras.codebook.weight_compression", "numpy.zeros", "range", "numpy.testing.assert_allclose", "qkeras.quantized_bits", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.codebook.weight_compression", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'bits, axis, quantizer, weights, expected_result'", ",", "\n", "[", "\n", "(", "\n", "3", ",", "3", ",", "quantized_bits", "(", "4", ",", "0", ",", "1", ",", "alpha", "=", "'auto_po2'", ")", ",", "\n", "np", ".", "array", "(", "[", "\n", "[", "[", "0.14170583", ",", "-", "0.34360626", ",", "0.29548156", "]", ",", "\n", "[", "0.6517242", ",", "0.06870092", ",", "-", "0.21646781", "]", ",", "\n", "[", "0.12486842", ",", "-", "0.05406165", ",", "-", "0.23690471", "]", "]", ",", "\n", "\n", "[", "[", "-", "0.07540564", ",", "0.2123149", ",", "0.2382695", "]", ",", "\n", "[", "0.78434753", ",", "0.36171672", ",", "-", "0.43612534", "]", ",", "\n", "[", "0.3685556", ",", "0.41328752", ",", "-", "0.48990643", "]", "]", ",", "\n", "\n", "[", "[", "-", "0.04438099", ",", "0.0590747", ",", "-", "0.0644061", "]", ",", "\n", "[", "0.15280165", ",", "0.40714318", ",", "-", "0.04622072", "]", ",", "\n", "[", "0.21560416", ",", "-", "0.22131851", ",", "-", "0.5365659", "]", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "np", ".", "array", "(", "[", "\n", "[", "[", "0.125", ",", "-", "0.375", ",", "0.25", "]", ",", "\n", "[", "0.75", ",", "0.125", ",", "-", "0.25", "]", ",", "\n", "[", "0.125", ",", "0.0", ",", "-", "0.25", "]", "]", ",", "\n", "\n", "[", "[", "0.0", ",", "0.25", ",", "0.25", "]", ",", "\n", "[", "0.75", ",", "0.375", ",", "-", "0.375", "]", ",", "\n", "[", "0.375", ",", "0.375", ",", "-", "0.5", "]", "]", ",", "\n", "\n", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "\n", "[", "0.125", ",", "0.375", ",", "0.0", "]", ",", "\n", "[", "0.25", ",", "-", "0.25", ",", "-", "0.5", "]", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", ")", "\n", "]", "\n", ")", "\n", "def", "test_codebook_weights", "(", "bits", ",", "axis", ",", "quantizer", ",", "weights", ",", "expected_result", ")", ":", "\n", "  ", "np", ".", "random", ".", "seed", "(", "22", ")", "\n", "weights", "=", "weights", ".", "reshape", "(", "weights", ".", "shape", "+", "(", "1", ",", ")", ")", "\n", "expected_result", "=", "expected_result", ".", "reshape", "(", "expected_result", ".", "shape", "+", "(", "1", ",", ")", ")", "\n", "index_table", ",", "codebook_table", "=", "weight_compression", "(", "weights", ",", "\n", "bits", ",", "\n", "axis", ",", "\n", "quantizer", ")", "\n", "new_weights", "=", "np", ".", "zeros", "(", "weights", ".", "shape", ")", "\n", "for", "i", "in", "range", "(", "weights", ".", "shape", "[", "axis", "]", ")", ":", "\n", "    ", "new_weights", "[", ":", ",", ":", ",", ":", ",", "i", "]", "=", "codebook_table", "[", "i", "]", "[", "index_table", "[", ":", ",", ":", ",", ":", ",", "i", "]", "]", "\n", "\n", "", "assert_allclose", "(", "new_weights", ",", "expected_result", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.range_test.test_quantized_relu_range": [[30, 52], ["pytest.mark.parametrize", "qkeras.quantized_relu", "qkeras.quantized_relu.range", "numpy.testing.assert_allclose", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'bits, integer, expected_values'", ",", "\n", "[", "\n", "(", "3", ",", "0", ",", "np", ".", "array", "(", "[", "0.0", ",", "0.125", ",", "0.25", ",", "0.375", ",", "0.5", ",", "0.625", ",", "0.75", ",", "0.875", "]", ")", ")", ",", "\n", "(", "3", ",", "1", ",", "np", ".", "array", "(", "[", "0.0", ",", "0.25", ",", "0.5", ",", "0.75", ",", "1.0", ",", "1.25", ",", "1.5", ",", "1.75", "]", ")", ")", ",", "\n", "(", "3", ",", "2", ",", "np", ".", "array", "(", "[", "0.0", ",", "0.5", ",", "1.0", ",", "1.5", ",", "2.0", ",", "2.5", ",", "3.0", ",", "3.5", "]", ")", ")", ",", "\n", "(", "3", ",", "3", ",", "np", ".", "array", "(", "[", "0", ",", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", "]", ")", ")", ",", "\n", "(", "6", ",", "1", ",", "np", ".", "array", "(", "\n", "[", "0.0", ",", "0.03125", ",", "0.0625", ",", "0.09375", ",", "0.125", ",", "0.15625", ",", "0.1875", ",", "0.21875", ",", "\n", "0.25", ",", "0.28125", ",", "0.3125", ",", "0.34375", ",", "0.375", ",", "0.40625", ",", "0.4375", ",", "0.46875", ",", "\n", "0.5", ",", "0.53125", ",", "0.5625", ",", "0.59375", ",", "0.625", ",", "0.65625", ",", "0.6875", ",", "0.71875", ",", "\n", "0.75", ",", "0.78125", ",", "0.8125", ",", "0.84375", ",", "0.875", ",", "0.90625", ",", "0.9375", ",", "0.96875", ",", "\n", "1.0", ",", "1.03125", ",", "1.0625", ",", "1.09375", ",", "1.125", ",", "1.15625", ",", "1.1875", ",", "1.21875", ",", "\n", "1.25", ",", "1.28125", ",", "1.3125", ",", "1.34375", ",", "1.375", ",", "1.40625", ",", "1.4375", ",", "1.46875", ",", "\n", "1.5", ",", "1.53125", ",", "1.5625", ",", "1.59375", ",", "1.625", ",", "1.65625", ",", "1.6875", ",", "1.71875", ",", "\n", "1.75", ",", "1.78125", ",", "1.8125", ",", "1.84375", ",", "1.875", ",", "1.90625", ",", "1.9375", ",", "1.96875", "]", ")", ")", "\n", "]", ")", "\n", "def", "test_quantized_relu_range", "(", "bits", ",", "integer", ",", "expected_values", ")", ":", "\n", "  ", "\"\"\"Test quantized_relu range function.\"\"\"", "\n", "q", "=", "quantized_relu", "(", "bits", ",", "integer", ")", "\n", "result", "=", "q", ".", "range", "(", ")", "\n", "assert_allclose", "(", "result", ",", "expected_values", ",", "rtol", "=", "1e-05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.range_test.test_quantized_bits_range": [[54, 75], ["pytest.mark.parametrize", "qkeras.quantized_bits", "qkeras.quantized_bits.range", "numpy.testing.assert_allclose", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'bits, integer, expected_values'", ",", "\n", "[", "\n", "(", "3", ",", "0", ",", "np", ".", "array", "(", "[", "0.0", ",", "0.25", ",", "0.5", ",", "0.75", ",", "-", "1.0", ",", "-", "0.75", ",", "-", "0.5", ",", "-", "0.25", "]", ")", ")", ",", "\n", "(", "3", ",", "1", ",", "np", ".", "array", "(", "[", "0.0", ",", "0.5", ",", "1.0", ",", "1.5", ",", "-", "2.0", ",", "-", "1.5", ",", "-", "1.0", ",", "-", "0.5", "]", ")", ")", ",", "\n", "(", "3", ",", "2", ",", "np", ".", "array", "(", "[", "0.0", ",", "1.0", ",", "2.0", ",", "3.0", ",", "-", "4.0", ",", "-", "3.0", ",", "-", "2.0", ",", "-", "1.0", "]", ")", ")", ",", "\n", "(", "3", ",", "3", ",", "np", ".", "array", "(", "[", "0.0", ",", "2.0", ",", "4.0", ",", "6.0", ",", "-", "8.0", ",", "-", "6.0", ",", "-", "4.0", ",", "-", "2.0", "]", ")", ")", ",", "\n", "(", "6", ",", "1", ",", "np", ".", "array", "(", "\n", "[", "0.0", ",", "0.0625", ",", "0.125", ",", "0.1875", ",", "0.25", ",", "0.3125", ",", "0.375", ",", "0.4375", ",", "0.5", ",", "0.5625", ",", "\n", "0.625", ",", "0.6875", ",", "0.75", ",", "0.8125", ",", "0.875", ",", "0.9375", ",", "1.0", ",", "1.0625", ",", "1.125", ",", "1.1875", ",", "\n", "1.25", ",", "1.3125", ",", "1.375", ",", "1.4375", ",", "1.5", ",", "1.5625", ",", "1.625", ",", "1.6875", ",", "1.75", ",", "1.8125", ",", "\n", "1.875", ",", "1.9375", ",", "-", "2.0", ",", "-", "1.9375", ",", "-", "1.875", ",", "-", "1.8125", ",", "-", "1.75", ",", "-", "1.6875", ",", "-", "1.625", ",", "\n", "-", "1.5625", ",", "-", "1.5", ",", "-", "1.4375", ",", "-", "1.375", ",", "-", "1.3125", ",", "-", "1.25", ",", "-", "1.1875", ",", "-", "1.125", ",", "-", "1.0625", ",", "\n", "-", "1.0", ",", "-", "0.9375", ",", "-", "0.875", ",", "-", "0.8125", ",", "-", "0.75", ",", "-", "0.6875", ",", "-", "0.625", ",", "-", "0.5625", ",", "-", "0.5", ",", "\n", "-", "0.4375", ",", "-", "0.375", ",", "-", "0.3125", ",", "-", "0.25", ",", "-", "0.1875", ",", "-", "0.125", ",", "-", "0.0625", "]", ")", ")", "\n", "]", ")", "\n", "def", "test_quantized_bits_range", "(", "bits", ",", "integer", ",", "expected_values", ")", ":", "\n", "  ", "\"\"\"Test quantized_bits range function.\"\"\"", "\n", "q", "=", "quantized_bits", "(", "bits", ",", "integer", ")", "\n", "result", "=", "q", ".", "range", "(", ")", "\n", "assert_allclose", "(", "result", ",", "expected_values", ",", "rtol", "=", "1e-05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.leakyrelu_test.test_quantized_relu": [[30, 82], ["pytest.mark.parametrize", "tensorflow.keras.backend.placeholder", "tensorflow.keras.backend.function", "numpy.testing.assert_allclose", "K.function.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "qkeras.quantized_relu", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx"], "function", ["None"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'bits, integer, use_sigmoid, negative_slope, test_values, expected_values'", ",", "\n", "[", "\n", "(", "6", ",", "2", ",", "0", ",", "0.25", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "-", "3.0", ",", "-", "2.0", ",", "-", "1.0", ",", "0.0", ",", "2.5625", ",", "3.3671875", ",", "1.5625", ",", "1.046875", ",", "\n", "0.054688", ",", "6.0", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "0.75", ",", "-", "0.5", ",", "-", "0.25", ",", "0.0", ",", "2.5", ",", "3.375", ",", "1.5", ",", "1.0", ",", "0.0", ",", "3.875", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "6", ",", "2", ",", "1", ",", "0.125", ",", "\n", "np", ".", "array", "(", "[", "[", "\n", "0.458069", ",", "0.573227", ",", "0.194336", ",", "1.539047", ",", "0.045883", ",", "4.009995", ",", "\n", "3.962494", ",", "3.937500", ",", "0.363266", ",", "0.875198", ",", "0.710938", ",", "4.000000", ",", "\n", "7.000000", ",", "3.937500", ",", "3.937592", ",", "0.199326", ",", "0.458008", ",", "0.625977", ",", "\n", "0.544922", ",", "1.046875", ",", "0.586899", ",", "3.367188", ",", "3.804688", ",", "0.312500", ",", "\n", "0.062500", ",", "0.562500", ",", "0.375000", ",", "3.367188", ",", "1.046875", ",", "2.796875", ",", "\n", "0.054688", ",", "1.562500", ",", "2.562500", "\n", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "\n", "0.5", ",", "0.5", ",", "0.25", ",", "1.5", ",", "0.", ",", "3.875", ",", "3.875", ",", "3.875", ",", "0.25", ",", "\n", "1.", ",", "0.75", ",", "3.875", ",", "3.875", ",", "3.875", ",", "3.875", ",", "0.25", ",", "0.5", ",", "0.75", ",", "\n", "0.5", ",", "1.", ",", "0.5", ",", "3.25", ",", "3.75", ",", "0.25", ",", "0.", ",", "0.5", ",", "0.5", ",", "\n", "3.25", ",", "1.", ",", "2.75", ",", "0.", ",", "1.5", ",", "2.5", "\n", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ")", ",", "\n", "(", "6", ",", "2", ",", "1", ",", "0.125", ",", "\n", "np", ".", "array", "(", "[", "[", "\n", "-", "0.458069", ",", "-", "0.573227", ",", "-", "0.194336", ",", "-", "1.539047", ",", "-", "0.045883", ",", "-", "4.009995", ",", "\n", "-", "3.962494", ",", "-", "3.937500", ",", "-", "0.363266", ",", "-", "0.875198", ",", "-", "0.710938", ",", "-", "4.000000", ",", "\n", "-", "7.000000", ",", "-", "3.937500", ",", "-", "3.937592", ",", "-", "0.199326", ",", "-", "0.458008", ",", "-", "0.625977", ",", "\n", "-", "0.544922", ",", "-", "1.046875", ",", "-", "0.586899", ",", "-", "3.367188", ",", "-", "3.804688", ",", "-", "0.312500", ",", "\n", "-", "0.062500", ",", "-", "0.562500", ",", "-", "0.375000", ",", "-", "3.367188", ",", "-", "1.046875", ",", "-", "2.796875", ",", "\n", "-", "0.054688", ",", "-", "1.562500", ",", "-", "2.562500", "\n", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "\n", "0.0", ",", "0.0", ",", "0.0", ",", "-", "0.25", ",", "0.0", ",", "-", "0.5", ",", "\n", "-", "0.5", ",", "-", "0.5", ",", "0.0", ",", "0.0", ",", "0.0", ",", "-", "0.5", ",", "\n", "-", "0.5", ",", "-", "0.5", ",", "-", "0.5", ",", "0.0", ",", "0.0", ",", "0.0", ",", "\n", "0.0", ",", "-", "0.25", ",", "0.0", ",", "-", "0.5", ",", "-", "0.5", ",", "0.0", ",", "\n", "0.0", ",", "0.0", ",", "0.0", ",", "-", "0.5", ",", "-", "0.25", ",", "-", "0.25", ",", "\n", "0.0", ",", "-", "0.25", ",", "-", "0.25", "\n", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ")", ",", "\n", "]", ")", "\n", "def", "test_quantized_relu", "(", "bits", ",", "integer", ",", "use_sigmoid", ",", "negative_slope", ",", "test_values", ",", "\n", "expected_values", ")", ":", "\n", "  ", "\"\"\"Test quantized_relu function.\"\"\"", "\n", "x", "=", "K", ".", "placeholder", "(", "ndim", "=", "2", ")", "\n", "f", "=", "K", ".", "function", "(", "[", "x", "]", ",", "[", "quantized_relu", "(", "bits", ",", "integer", ",", "use_sigmoid", ",", "\n", "negative_slope", ")", "(", "x", ")", "]", ")", "\n", "result", "=", "f", "(", "[", "test_values", "]", ")", "[", "0", "]", "\n", "assert_allclose", "(", "result", ",", "expected_values", ",", "rtol", "=", "1e-05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.leakyrelu_test.test_quantized_relu_po2": [[84, 136], ["pytest.mark.parametrize", "tensorflow.keras.backend.placeholder", "tensorflow.keras.backend.function", "numpy.testing.assert_allclose", "K.function.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "qkeras.quantized_relu_po2", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'bits, negative_slope, test_values, expected_values'", ",", "\n", "[", "\n", "(", "\n", "8", ",", "2", "**", "-", "4", ",", "\n", "np", ".", "array", "(", "[", "[", "\n", "-", "1.00000000e+00", ",", "-", "9.00000000e-01", ",", "-", "8.00000000e-01", ",", "-", "7.00000000e-01", ",", "\n", "-", "6.00000000e-01", ",", "-", "5.00000000e-01", ",", "-", "4.00000000e-01", ",", "-", "3.00000000e-01", ",", "\n", "-", "2.00000000e-01", ",", "-", "1.00000000e-01", ",", "-", "2.22044605e-16", ",", "1.00000000e-01", ",", "\n", "2.00000000e-01", ",", "3.00000000e-01", ",", "4.00000000e-01", ",", "5.00000000e-01", ",", "\n", "6.00000000e-01", ",", "7.00000000e-01", ",", "8.00000000e-01", ",", "9.00000000e-01", "\n", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "\n", "-", "0.0625", ",", "-", "0.0625", ",", "-", "0.0625", ",", "-", "0.03125", ",", "-", "0.03125", ",", "\n", "-", "0.03125", ",", "-", "0.03125", ",", "-", "0.015625", ",", "-", "0.015625", ",", "-", "0.0078125", ",", "\n", "0.", ",", "0.125", ",", "0.25", ",", "0.25", ",", "0.5", ",", "\n", "0.5", ",", "0.5", ",", "0.5", ",", "1.", ",", "1.", "\n", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", "\n", ")", ",", "\n", "(", "\n", "3", ",", "2", "**", "-", "4", ",", "\n", "np", ".", "array", "(", "[", "[", "\n", "-", "1.00000000e+00", ",", "-", "9.00000000e-01", ",", "-", "8.00000000e-01", ",", "-", "7.00000000e-01", ",", "\n", "-", "6.00000000e-01", ",", "-", "5.00000000e-01", ",", "-", "4.00000000e-01", ",", "-", "3.00000000e-01", ",", "\n", "-", "2.00000000e-01", ",", "-", "1.00000000e-01", ",", "-", "2.22044605e-16", ",", "1.00000000e-01", ",", "\n", "2.00000000e-01", ",", "3.00000000e-01", ",", "4.00000000e-01", ",", "5.00000000e-01", ",", "\n", "6.00000000e-01", ",", "7.00000000e-01", ",", "8.00000000e-01", ",", "9.00000000e-01", "\n", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "\n", "-", "0.0625", ",", "-", "0.0625", ",", "-", "0.0625", ",", "-", "0.0625", ",", "-", "0.0625", ",", "-", "0.0625", ",", "-", "0.0625", ",", "\n", "-", "0.0625", ",", "-", "0.0625", ",", "-", "0.0625", ",", "-", "0.0625", ",", "0.125", ",", "0.25", ",", "0.25", ",", "\n", "0.5", ",", "0.5", ",", "0.5", ",", "0.5", ",", "1.", ",", "1.", "\n", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", "\n", ")", ",", "\n", "(", "\n", "6", ",", "2", "**", "-", "3", ",", "\n", "np", ".", "array", "(", "[", "[", "\n", "-", "3.0", ",", "-", "2.0", ",", "-", "1.0", ",", "0.0", ",", "2.5625", ",", "3.3671875", ",", "1.5625", ",", "1.046875", ",", "\n", "0.054688", ",", "6.0", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "\n", "-", "5.00000000e-01", ",", "-", "2.50000000e-01", ",", "-", "1.25000000e-01", ",", "2.32830644e-10", ",", "\n", "2.00000000e+00", ",", "4.00000000e+00", ",", "2.00000000e+00", ",", "1.00000000e+00", ",", "\n", "6.25000000e-02", ",", "8.00000000e+00", "\n", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", "\n", ")", "\n", "\n", "]", ")", "\n", "def", "test_quantized_relu_po2", "(", "bits", ",", "negative_slope", ",", "test_values", ",", "expected_values", ")", ":", "\n", "  ", "x", "=", "K", ".", "placeholder", "(", "ndim", "=", "2", ")", "\n", "f", "=", "K", ".", "function", "(", "[", "x", "]", ",", "[", "quantized_relu_po2", "(", "bits", ",", "negative_slope", "=", "negative_slope", ")", "(", "x", ")", "]", ")", "\n", "result", "=", "f", "(", "[", "test_values", "]", ")", "[", "0", "]", "\n", "assert_allclose", "(", "result", ",", "expected_values", ",", "rtol", "=", "1e-05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.get_qconv2d_model": [[43, 84], ["tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "qkeras.QConv2D", "tensorflow.keras.layers.BatchNormalization", "tensorflow.keras.layers.Flatten", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Activation"], "function", ["None"], ["def", "get_qconv2d_model", "(", "input_shape", ",", "kernel_size", ",", "kernel_quantizer", "=", "None", ")", ":", "\n", "  ", "num_class", "=", "2", "\n", "\n", "x", "=", "x_in", "=", "layers", ".", "Input", "(", "input_shape", ",", "name", "=", "\"input\"", ")", "\n", "\n", "x", "=", "QConv2D", "(", "\n", "filters", "=", "2", ",", "kernel_size", "=", "kernel_size", ",", "strides", "=", "(", "4", ",", "4", ")", ",", "\n", "kernel_initializer", "=", "\"ones\"", ",", "\n", "bias_initializer", "=", "\"zeros\"", ",", "use_bias", "=", "False", ",", "\n", "kernel_quantizer", "=", "kernel_quantizer", ",", "bias_quantizer", "=", "None", ",", "\n", "name", "=", "\"conv2d\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "layers", ".", "BatchNormalization", "(", "\n", "axis", "=", "-", "1", ",", "\n", "momentum", "=", "0.99", ",", "\n", "epsilon", "=", "0.001", ",", "\n", "center", "=", "True", ",", "\n", "scale", "=", "True", ",", "\n", "beta_initializer", "=", "\"zeros\"", ",", "\n", "gamma_initializer", "=", "\"ones\"", ",", "\n", "moving_mean_initializer", "=", "\"zeros\"", ",", "\n", "moving_variance_initializer", "=", "\"ones\"", ",", "\n", "beta_regularizer", "=", "None", ",", "\n", "gamma_regularizer", "=", "None", ",", "\n", "beta_constraint", "=", "None", ",", "\n", "gamma_constraint", "=", "None", ",", "\n", "renorm", "=", "False", ",", "\n", "renorm_clipping", "=", "None", ",", "\n", "renorm_momentum", "=", "0.99", ",", "\n", "fused", "=", "None", ",", "\n", "trainable", "=", "True", ",", "\n", "virtual_batch_size", "=", "None", ",", "\n", "adjustment", "=", "None", ",", "\n", "name", "=", "\"bn\"", ")", "(", "\n", "x", ")", "\n", "x", "=", "layers", ".", "Flatten", "(", "name", "=", "\"flatten\"", ")", "(", "x", ")", "\n", "x", "=", "layers", ".", "Dense", "(", "num_class", ",", "use_bias", "=", "False", ",", "kernel_initializer", "=", "\"ones\"", ",", "\n", "name", "=", "\"dense\"", ")", "(", "x", ")", "\n", "x", "=", "layers", ".", "Activation", "(", "\"softmax\"", ",", "name", "=", "\"softmax\"", ")", "(", "x", ")", "\n", "model", "=", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.get_qconv2d_batchnorm_model": [[86, 105], ["tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "qkeras.QConv2DBatchnorm", "tensorflow.keras.layers.Flatten", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Activation"], "function", ["None"], ["", "def", "get_qconv2d_batchnorm_model", "(", "input_shape", ",", "kernel_size", ",", "folding_mode", ",", "\n", "kernel_quantizer", "=", "None", ")", ":", "\n", "  ", "num_class", "=", "2", "\n", "\n", "x", "=", "x_in", "=", "layers", ".", "Input", "(", "input_shape", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QConv2DBatchnorm", "(", "\n", "filters", "=", "2", ",", "kernel_size", "=", "kernel_size", ",", "strides", "=", "(", "4", ",", "4", ")", ",", "\n", "kernel_initializer", "=", "\"ones\"", ",", "bias_initializer", "=", "\"zeros\"", ",", "use_bias", "=", "False", ",", "\n", "kernel_quantizer", "=", "kernel_quantizer", ",", "beta_initializer", "=", "\"zeros\"", ",", "\n", "gamma_initializer", "=", "\"ones\"", ",", "moving_mean_initializer", "=", "\"zeros\"", ",", "\n", "moving_variance_initializer", "=", "\"ones\"", ",", "folding_mode", "=", "folding_mode", ",", "\n", "name", "=", "\"foldconv2d\"", ")", "(", "x", ")", "\n", "\n", "x", "=", "layers", ".", "Flatten", "(", "name", "=", "\"flatten\"", ")", "(", "x", ")", "\n", "x", "=", "layers", ".", "Dense", "(", "num_class", ",", "use_bias", "=", "False", ",", "kernel_initializer", "=", "\"ones\"", ",", "\n", "name", "=", "\"dense\"", ")", "(", "x", ")", "\n", "x", "=", "layers", ".", "Activation", "(", "\"softmax\"", ",", "name", "=", "\"softmax\"", ")", "(", "x", ")", "\n", "model", "=", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.get_models_with_one_layer": [[107, 159], ["tensorflow.keras.losses.MeanSquaredError", "tensorflow.keras.optimizers.SGD", "tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "tensorflow.keras.models.Model.compile", "tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "tensorflow.keras.models.Model.compile", "qkeras.QConv2D", "tensorflow.keras.layers.BatchNormalization", "qkeras.QConv2DBatchnorm"], "function", ["None"], ["", "def", "get_models_with_one_layer", "(", "kernel_quantizer", ",", "folding_mode", ",", "ema_freeze_delay", ")", ":", "\n", "\n", "  ", "x_shape", "=", "(", "2", ",", "2", ",", "1", ")", "\n", "loss_fn", "=", "tf", ".", "keras", ".", "losses", ".", "MeanSquaredError", "(", ")", "\n", "optimizer", "=", "tf", ".", "keras", ".", "optimizers", ".", "SGD", "(", "learning_rate", "=", "1e-3", ")", "\n", "\n", "# define a model with seperate conv2d and bn layers", "\n", "x", "=", "x_in", "=", "layers", ".", "Input", "(", "x_shape", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QConv2D", "(", "\n", "filters", "=", "2", ",", "kernel_size", "=", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "4", ",", "4", ")", ",", "\n", "kernel_initializer", "=", "\"ones\"", ",", "\n", "bias_initializer", "=", "\"zeros\"", ",", "use_bias", "=", "False", ",", "\n", "kernel_quantizer", "=", "kernel_quantizer", ",", "bias_quantizer", "=", "None", ",", "\n", "name", "=", "\"conv2d\"", ")", "(", "x", ")", "\n", "x", "=", "layers", ".", "BatchNormalization", "(", "\n", "axis", "=", "-", "1", ",", "\n", "momentum", "=", "0.99", ",", "\n", "epsilon", "=", "0.001", ",", "\n", "center", "=", "True", ",", "\n", "scale", "=", "True", ",", "\n", "beta_initializer", "=", "\"zeros\"", ",", "\n", "gamma_initializer", "=", "\"ones\"", ",", "\n", "moving_mean_initializer", "=", "\"zeros\"", ",", "\n", "moving_variance_initializer", "=", "\"ones\"", ",", "\n", "beta_regularizer", "=", "None", ",", "\n", "gamma_regularizer", "=", "None", ",", "\n", "beta_constraint", "=", "None", ",", "\n", "gamma_constraint", "=", "None", ",", "\n", "renorm", "=", "False", ",", "\n", "renorm_clipping", "=", "None", ",", "\n", "renorm_momentum", "=", "0.99", ",", "\n", "fused", "=", "None", ",", "\n", "trainable", "=", "True", ",", "\n", "virtual_batch_size", "=", "None", ",", "\n", "adjustment", "=", "None", ",", "\n", "name", "=", "\"bn\"", ")", "(", "x", ")", "\n", "unfold_model", "=", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "unfold_model", ".", "compile", "(", "loss", "=", "loss_fn", ",", "optimizer", "=", "optimizer", ",", "metrics", "=", "\"acc\"", ")", "\n", "\n", "x", "=", "x_in", "=", "layers", ".", "Input", "(", "x_shape", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QConv2DBatchnorm", "(", "\n", "filters", "=", "2", ",", "kernel_size", "=", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "4", ",", "4", ")", ",", "\n", "kernel_initializer", "=", "\"ones\"", ",", "bias_initializer", "=", "\"zeros\"", ",", "use_bias", "=", "False", ",", "\n", "kernel_quantizer", "=", "kernel_quantizer", ",", "beta_initializer", "=", "\"zeros\"", ",", "\n", "gamma_initializer", "=", "\"ones\"", ",", "moving_mean_initializer", "=", "\"zeros\"", ",", "\n", "moving_variance_initializer", "=", "\"ones\"", ",", "folding_mode", "=", "folding_mode", ",", "\n", "ema_freeze_delay", "=", "ema_freeze_delay", ",", "\n", "name", "=", "\"foldconv2d\"", ")", "(", "x", ")", "\n", "fold_model", "=", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "fold_model", ".", "compile", "(", "loss", "=", "loss_fn", ",", "optimizer", "=", "optimizer", ",", "metrics", "=", "\"acc\"", ")", "\n", "\n", "return", "(", "unfold_model", ",", "fold_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.get_debug_model": [[161, 169], ["tensorflow.keras.models.Model", "layer_output_list.append"], "function", ["None"], ["", "def", "get_debug_model", "(", "model", ")", ":", "\n", "  ", "layer_output_list", "=", "[", "]", "\n", "for", "layer", "in", "model", ".", "layers", ":", "\n", "    ", "if", "layer", ".", "__class__", ".", "__name__", "not", "in", "[", "\"Flatten\"", ",", "\"InputLayer\"", "]", ":", "\n", "      ", "layer_output_list", ".", "append", "(", "layer", ".", "output", ")", "\n", "\n", "", "", "debug_model", "=", "Model", "(", "inputs", "=", "model", ".", "inputs", ",", "outputs", "=", "layer_output_list", ")", "\n", "return", "debug_model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.generate_dataset": [[171, 192], ["numpy.random.randint", "numpy.random.rand", "tensorflow.data.Dataset.from_tensor_slices", "train_ds.batch.batch", "numpy.random.random_sample", "numpy.random.randint", "tensorflow.keras.utils.to_categorical"], "function", ["None"], ["", "def", "generate_dataset", "(", "train_size", "=", "10", ",", "\n", "batch_size", "=", "5", ",", "\n", "input_shape", "=", "(", "3", ",", "3", ",", "1", ")", ",", "\n", "num_class", "=", "2", ",", "\n", "output_shape", "=", "None", ")", ":", "\n", "  ", "\"\"\"create tf.data.Dataset with shape: (N,) + input_shape.\"\"\"", "\n", "\n", "x_train", "=", "np", ".", "random", ".", "randint", "(", "\n", "4", ",", "size", "=", "(", "train_size", ",", "input_shape", "[", "0", "]", ",", "input_shape", "[", "1", "]", ",", "input_shape", "[", "2", "]", ")", ")", "\n", "x_train", "=", "np", ".", "random", ".", "rand", "(", "\n", "train_size", ",", "input_shape", "[", "0", "]", ",", "input_shape", "[", "1", "]", ",", "input_shape", "[", "2", "]", ")", "\n", "\n", "if", "output_shape", ":", "\n", "    ", "y_train", "=", "np", ".", "random", ".", "random_sample", "(", "(", "train_size", ",", ")", "+", "output_shape", ")", "\n", "", "else", ":", "\n", "    ", "y_train", "=", "np", ".", "random", ".", "randint", "(", "num_class", ",", "size", "=", "train_size", ")", "\n", "y_train", "=", "to_categorical", "(", "y_train", ",", "num_class", ")", "\n", "\n", "", "train_ds", "=", "tf", ".", "data", ".", "Dataset", ".", "from_tensor_slices", "(", "(", "x_train", ",", "y_train", ")", ")", "\n", "train_ds", "=", "train_ds", ".", "batch", "(", "batch_size", ")", "\n", "return", "train_ds", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.run_training": [[194, 235], ["range", "enumerate", "print", "print", "tensorflow.GradientTape", "model", "loss_fn", "tape.gradient", "optimizer.apply_gradients", "loss_metric", "zip", "print", "print", "print", "print", "print", "loss_metric.result"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "run_training", "(", "model", ",", "epochs", ",", "loss_fn", ",", "loss_metric", ",", "optimizer", ",", "\n", "train_ds", ",", "do_print", "=", "False", ")", ":", "\n", "\n", "# Iterate over epochs.", "\n", "  ", "for", "epoch", "in", "range", "(", "epochs", ")", ":", "\n", "    ", "if", "do_print", ":", "\n", "      ", "print", "(", "\"- epoch {} -\"", ".", "format", "(", "epoch", ")", ")", "\n", "\n", "# Iterate over the batches of the dataset.", "\n", "", "for", "step", ",", "(", "x_batch_train", ",", "y_batch_train", ")", "in", "enumerate", "(", "train_ds", ")", ":", "\n", "      ", "if", "do_print", ":", "\n", "        ", "print", "(", "\"\\n   - step {} -\"", ".", "format", "(", "step", ")", ")", "\n", "", "with", "tf", ".", "GradientTape", "(", ")", "as", "tape", ":", "\n", "        ", "predictions", "=", "model", "(", "x_batch_train", ",", "training", "=", "True", ")", "\n", "\n", "if", "epoch", "==", "epochs", "-", "1", ":", "\n", "          ", "if", "do_print", ":", "\n", "            ", "print", "(", "\"y_pred:\"", ",", "predictions", ")", "\n", "print", "(", "\"y:\"", ",", "y_batch_train", ")", "\n", "", "output_predictions", "=", "predictions", "\n", "\n", "# Compute loss", "\n", "", "loss", "=", "loss_fn", "(", "y_batch_train", ",", "predictions", ")", "\n", "\n", "grads", "=", "tape", ".", "gradient", "(", "loss", ",", "model", ".", "trainable_weights", ")", "\n", "if", "do_print", ":", "\n", "          ", "if", "epoch", "==", "epochs", "-", "1", ":", "\n", "# print(\"old trainable:\", model.trainable_weights)", "\n", "            ", "print", "(", "\"grads:\"", ",", "grads", ")", "\n", "", "", "optimizer", ".", "apply_gradients", "(", "zip", "(", "grads", ",", "model", ".", "trainable_weights", ")", ")", "\n", "\n", "if", "do_print", ":", "\n", "          ", "if", "epoch", "==", "epochs", "-", "1", ":", "\n", "# print(\"new trainable:\", model.trainable_weights)", "\n", "            ", "print", "(", "\"loss:\"", ",", "loss", ")", "\n", "", "", "loss_metric", "(", "loss", ")", "\n", "if", "do_print", ":", "\n", "          ", "if", "epoch", "==", "epochs", "-", "1", ":", "\n", "            ", "print", "(", "\"mean loss = %.4f\"", "%", "(", "loss_metric", ".", "result", "(", ")", ")", ")", "\n", "\n", "", "", "", "", "", "return", "output_predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.test_unfold_model": [[237, 345], ["numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "bn_folding_test.test_unfold_model._get_sequantial_folded_model"], "function", ["None"], ["", "def", "test_unfold_model", "(", ")", ":", "\n", "  ", "\"\"\"Test if unfold_model works properly.\n\n  Convert a folded model to a normal model. The kernel/bias weight in\n  the normal model should be the same as the folded kernel/bias in the folded\n  model. Test if the function can convert both sequential and non-sequantial\n  models properly.\n  \"\"\"", "\n", "\n", "x_shape", "=", "(", "2", ",", "2", ",", "1", ")", "\n", "kernel_quantizer", "=", "\"quantized_bits(4, 0, 1)\"", "\n", "folding_mode", "=", "\"batch_stats_folding\"", "\n", "ema_freeze_delay", "=", "10", "\n", "kernel", "=", "np", ".", "array", "(", "[", "[", "[", "[", "1.", ",", "1.", "]", "]", ",", "[", "[", "1.", ",", "0.", "]", "]", "]", ",", "[", "[", "[", "1.", ",", "1.", "]", "]", ",", "[", "[", "0.", ",", "1.", "]", "]", "]", "]", ")", "\n", "gamma", "=", "np", ".", "array", "(", "[", "2.", ",", "1.", "]", ")", "\n", "beta", "=", "np", ".", "array", "(", "[", "0.", ",", "1.", "]", ")", "\n", "moving_mean", "=", "np", ".", "array", "(", "[", "1.", ",", "1.", "]", ")", "\n", "moving_variance", "=", "np", ".", "array", "(", "[", "1.", ",", "2.", "]", ")", "\n", "iteration", "=", "np", ".", "array", "(", "-", "1", ")", "\n", "\n", "def", "_get_sequantial_folded_model", "(", "x_shape", ")", ":", "\n", "    ", "x", "=", "x_in", "=", "layers", ".", "Input", "(", "x_shape", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QConv2DBatchnorm", "(", "\n", "filters", "=", "2", ",", "kernel_size", "=", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "\n", "kernel_initializer", "=", "\"ones\"", ",", "bias_initializer", "=", "\"zeros\"", ",", "use_bias", "=", "False", ",", "\n", "kernel_quantizer", "=", "kernel_quantizer", ",", "beta_initializer", "=", "\"zeros\"", ",", "\n", "gamma_initializer", "=", "\"ones\"", ",", "moving_mean_initializer", "=", "\"zeros\"", ",", "\n", "moving_variance_initializer", "=", "\"ones\"", ",", "folding_mode", "=", "folding_mode", ",", "\n", "ema_freeze_delay", "=", "ema_freeze_delay", ",", "\n", "name", "=", "\"foldconv2d\"", ")", "(", "x", ")", "\n", "x", "=", "QDepthwiseConv2DBatchnorm", "(", "\n", "kernel_size", "=", "(", "2", ",", "2", ")", ",", "\n", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "use_bias", "=", "False", ",", "\n", "depthwise_quantizer", "=", "kernel_quantizer", ",", "\n", "folding_mode", "=", "folding_mode", ",", "\n", "ema_freeze_delay", "=", "ema_freeze_delay", ",", "\n", "name", "=", "\"folddepthwiseconv2d\"", ")", "(", "x", ")", "\n", "model", "=", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "model", ".", "layers", "[", "1", "]", ".", "set_weights", "(", "[", "\n", "kernel", ",", "gamma", ",", "beta", ",", "iteration", ",", "moving_mean", ",", "moving_variance", "\n", "]", ")", "\n", "\n", "return", "model", "\n", "\n", "", "def", "_get_nonseq_folded_model", "(", "x_shape", ")", ":", "\n", "    ", "x", "=", "x_in", "=", "layers", ".", "Input", "(", "x_shape", ",", "name", "=", "\"input\"", ")", "\n", "x1", "=", "layers", ".", "Conv2D", "(", "filters", "=", "1", ",", "kernel_size", "=", "(", "1", ",", "1", ")", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "name", "=", "\"conv2d_1\"", ")", "(", "x", ")", "\n", "x2", "=", "layers", ".", "Conv2D", "(", "filters", "=", "1", ",", "kernel_size", "=", "(", "1", ",", "1", ")", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "name", "=", "\"conv2d_2\"", ")", "(", "x", ")", "\n", "x", "=", "layers", ".", "Maximum", "(", ")", "(", "[", "x1", ",", "x2", "]", ")", "\n", "x", "=", "QConv2DBatchnorm", "(", "\n", "filters", "=", "2", ",", "kernel_size", "=", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "4", ",", "4", ")", ",", "\n", "kernel_initializer", "=", "\"ones\"", ",", "bias_initializer", "=", "\"zeros\"", ",", "use_bias", "=", "False", ",", "\n", "kernel_quantizer", "=", "kernel_quantizer", ",", "beta_initializer", "=", "\"zeros\"", ",", "\n", "gamma_initializer", "=", "\"ones\"", ",", "moving_mean_initializer", "=", "\"zeros\"", ",", "\n", "moving_variance_initializer", "=", "\"ones\"", ",", "folding_mode", "=", "folding_mode", ",", "\n", "ema_freeze_delay", "=", "ema_freeze_delay", ",", "\n", "name", "=", "\"foldconv2d\"", ")", "(", "x", ")", "\n", "x", "=", "layers", ".", "Flatten", "(", "name", "=", "\"flatten\"", ")", "(", "x", ")", "\n", "x", "=", "layers", ".", "Dense", "(", "2", ",", "use_bias", "=", "False", ",", "kernel_initializer", "=", "\"ones\"", ",", "\n", "name", "=", "\"dense\"", ")", "(", "x", ")", "\n", "model", "=", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "model", ".", "layers", "[", "4", "]", ".", "set_weights", "(", "[", "\n", "kernel", ",", "gamma", ",", "beta", ",", "iteration", ",", "moving_mean", ",", "moving_variance", "\n", "]", ")", "\n", "return", "model", "\n", "\n", "", "seq_model", "=", "_get_sequantial_folded_model", "(", "(", "4", ",", "4", ",", "1", ")", ")", "\n", "nonseq_model", "=", "_get_nonseq_folded_model", "(", "x_shape", ")", "\n", "\n", "for", "model", "in", "[", "nonseq_model", ",", "seq_model", "]", ":", "\n", "\n", "# preparing data for testing if model prediction matches", "\n", "\n", "    ", "output_shape", "=", "model", ".", "output_shape", "[", "1", ":", "]", "\n", "input_shape", "=", "model", ".", "input_shape", "[", "1", ":", "]", "\n", "train_ds", "=", "generate_dataset", "(", "train_size", "=", "10", ",", "batch_size", "=", "5", ",", "\n", "input_shape", "=", "input_shape", ",", "\n", "output_shape", "=", "output_shape", ")", "\n", "\n", "# convert model with folded layers to a model with coresspoinding QConv2D", "\n", "# or QDepthwiseConv2D layers", "\n", "cvt_model", "=", "bn_folding_utils", ".", "unfold_model", "(", "model", ")", "\n", "\n", "for", "layer_type", "in", "[", "\"QConv2DBatchnorm\"", ",", "\"QDepthwiseConv2DBatchnorm\"", "]", ":", "\n", "      ", "weight1", "=", "None", "\n", "weight2", "=", "None", "\n", "for", "layer", "in", "model", ".", "layers", ":", "\n", "        ", "if", "layer", ".", "__class__", ".", "__name__", "==", "layer_type", ":", "\n", "          ", "weight1", "=", "layer", ".", "get_folded_weights", "(", ")", "\n", "break", "\n", "\n", "", "", "for", "layer", "in", "cvt_model", ".", "layers", ":", "\n", "        ", "if", "layer", ".", "__class__", ".", "__name__", "==", "layer_type", "[", ":", "-", "9", "]", ":", "\n", "          ", "weight2", "=", "layer", ".", "get_weights", "(", ")", "\n", "break", "\n", "\n", "# test if the corresponding layers have identical weights", "\n", "", "", "if", "weight1", "and", "weight2", ":", "\n", "        ", "assert_equal", "(", "weight1", "[", "0", "]", ",", "weight2", "[", "0", "]", ")", "\n", "assert_equal", "(", "weight1", "[", "1", "]", ",", "weight2", "[", "1", "]", ")", "\n", "\n", "# test if the predictions of the two models are identical", "\n", "", "", "pred1", "=", "model", ".", "predict", "(", "train_ds", ")", "\n", "pred2", "=", "cvt_model", ".", "predict", "(", "train_ds", ")", "\n", "assert_equal", "(", "pred1", ",", "pred2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.test_loading": [[347, 392], ["tensorflow.keras.losses.MeanSquaredError", "tensorflow.keras.metrics.Mean", "tensorflow.keras.optimizers.SGD", "qkeras.utils._add_supported_quantized_objects", "bn_folding_test.generate_dataset", "bn_folding_test.get_qconv2d_batchnorm_model", "get_qconv2d_batchnorm_model.compile", "bn_folding_test.run_training", "get_qconv2d_batchnorm_model.to_json", "tensorflow.keras.backend.clear_session", "qkeras.utils.quantized_model_from_json", "tempfile.mkstemp", "get_qconv2d_batchnorm_model.save", "qkeras.utils.load_qmodel", "get_qconv2d_batchnorm_model.layers[].get_folded_weights", "qkeras_utils.load_qmodel.layers[].get_folded_weights", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "qkeras.bn_folding_utils.unfold_model", "bn_folding_utils.unfold_model.layers[].get_weights", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "qkeras_utils.quantized_model_from_json.to_json", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.utils._add_supported_quantized_objects", "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.generate_dataset", "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.get_qconv2d_batchnorm_model", "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.run_training", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.quantized_model_from_json", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.save", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.load_qmodel", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconv2d_batchnorm.QConv2DBatchnorm.get_folded_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconv2d_batchnorm.QConv2DBatchnorm.get_folded_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.bn_folding_utils.unfold_model", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights"], ["", "", "def", "test_loading", "(", ")", ":", "\n", "  ", "\"\"\"Test to load model using different approahches.\"\"\"", "\n", "\n", "loss_fn", "=", "tf", ".", "keras", ".", "losses", ".", "MeanSquaredError", "(", ")", "\n", "loss_metric", "=", "metrics", ".", "Mean", "(", ")", "\n", "optimizer", "=", "tf", ".", "keras", ".", "optimizers", ".", "SGD", "(", "learning_rate", "=", "1e-3", ")", "\n", "x_shape", "=", "(", "2", ",", "2", ",", "1", ")", "\n", "\n", "custom_objects", "=", "{", "}", "\n", "qkeras_utils", ".", "_add_supported_quantized_objects", "(", "custom_objects", ")", "\n", "\n", "train_ds", "=", "generate_dataset", "(", "train_size", "=", "1", ",", "batch_size", "=", "1", ",", "\n", "input_shape", "=", "x_shape", ",", "num_class", "=", "2", ")", "\n", "\n", "model_fold", "=", "get_qconv2d_batchnorm_model", "(", "\n", "input_shape", "=", "x_shape", ",", "kernel_size", "=", "(", "2", ",", "2", ")", ",", "\n", "folding_mode", "=", "\"ema_stats_folding\"", ")", "\n", "model_fold", ".", "compile", "(", "loss", "=", "loss_fn", ",", "optimizer", "=", "optimizer", ",", "metrics", "=", "\"acc\"", ")", "\n", "\n", "run_training", "(", "model_fold", ",", "10", ",", "loss_fn", ",", "loss_metric", ",", "optimizer", ",", "train_ds", ",", "\n", "do_print", "=", "False", ")", "\n", "\n", "# test load model from json to ensure saving/loading model architecture works", "\n", "json_string", "=", "model_fold", ".", "to_json", "(", ")", "\n", "clear_session", "(", ")", "\n", "model_from_json", "=", "qkeras_utils", ".", "quantized_model_from_json", "(", "json_string", ")", "\n", "assert", "json_string", "==", "model_from_json", ".", "to_json", "(", ")", "\n", "\n", "# test reload model from hdf5 files to ensure saving/loading works", "\n", "_", ",", "fname", "=", "tempfile", ".", "mkstemp", "(", "\".h5\"", ")", "\n", "model_fold", ".", "save", "(", "fname", ")", "\n", "model_loaded", "=", "qkeras_utils", ".", "load_qmodel", "(", "fname", ")", "\n", "weight1", "=", "model_fold", ".", "layers", "[", "1", "]", ".", "get_folded_weights", "(", ")", "\n", "weight2", "=", "model_loaded", ".", "layers", "[", "1", "]", ".", "get_folded_weights", "(", ")", "\n", "assert_equal", "(", "np", ".", "array", "(", "weight1", "[", "0", "]", ")", ",", "np", ".", "array", "(", "weight2", "[", "0", "]", ")", ")", "\n", "assert_equal", "(", "np", ".", "array", "(", "weight1", "[", "1", "]", ")", ",", "np", ".", "array", "(", "weight2", "[", "1", "]", ")", ")", "\n", "\n", "# test convert a folded model to a normal model for zpm", "\n", "# the kernel/bias weight in the normal model should be the same as the folded", "\n", "# kernel/bias in the folded model", "\n", "normal_model", "=", "bn_folding_utils", ".", "unfold_model", "(", "model_fold", ")", "\n", "weight2", "=", "normal_model", ".", "layers", "[", "1", "]", ".", "get_weights", "(", ")", "\n", "\n", "assert_equal", "(", "weight1", "[", "0", "]", ",", "weight2", "[", "0", "]", ")", "\n", "assert_equal", "(", "weight1", "[", "1", "]", ",", "weight2", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.test_same_training_and_prediction": [[394, 602], ["tensorflow.keras.losses.MeanSquaredError", "tensorflow.keras.metrics.Mean", "tensorflow.keras.optimizers.SGD", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "bn_folding_test.generate_dataset", "bn_folding_test.get_models_with_one_layer", "bn_folding_test.get_models_with_one_layer", "unfold_model.layers[].set_weights", "unfold_model.layers[].set_weights", "fold_model_batch.layers[].set_weights", "fold_model_ema.layers[].set_weights", "unfold_model.predict", "fold_model_batch.predict", "fold_model_ema.predict", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "bn_folding_test.run_training", "bn_folding_test.run_training", "bn_folding_test.run_training", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.array", "bn_folding_test.get_models_with_one_layer", "bn_folding_test.get_models_with_one_layer", "unfold_model.layers[].set_weights", "unfold_model.layers[].set_weights", "fold_model_batch.layers[].set_weights", "fold_model_ema.layers[].set_weights", "bn_folding_test.run_training", "bn_folding_test.run_training", "bn_folding_test.run_training", "numpy.testing.assert_raises", "numpy.testing.assert_allclose", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "bn_folding_test.generate_dataset", "bn_folding_test.test_same_training_and_prediction._get_models"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.generate_dataset", "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.get_models_with_one_layer", "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.get_models_with_one_layer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict", "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.run_training", "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.run_training", "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.run_training", "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.get_models_with_one_layer", "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.get_models_with_one_layer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.run_training", "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.run_training", "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.run_training", "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.generate_dataset"], ["", "def", "test_same_training_and_prediction", "(", ")", ":", "\n", "  ", "\"\"\"test if fold/unfold layer has the same training and prediction output.\"\"\"", "\n", "\n", "epochs", "=", "5", "\n", "loss_fn", "=", "tf", ".", "keras", ".", "losses", ".", "MeanSquaredError", "(", ")", "\n", "loss_metric", "=", "metrics", ".", "Mean", "(", ")", "\n", "optimizer", "=", "tf", ".", "keras", ".", "optimizers", ".", "SGD", "(", "learning_rate", "=", "1e-3", ")", "\n", "\n", "x_shape", "=", "(", "2", ",", "2", ",", "1", ")", "\n", "kernel", "=", "np", ".", "array", "(", "[", "[", "[", "[", "1.", ",", "1.", "]", "]", ",", "[", "[", "1.", ",", "0.", "]", "]", "]", ",", "[", "[", "[", "1.", ",", "1.", "]", "]", ",", "[", "[", "0.", ",", "1.", "]", "]", "]", "]", ")", "\n", "gamma", "=", "np", ".", "array", "(", "[", "2.", ",", "1.", "]", ")", "\n", "beta", "=", "np", ".", "array", "(", "[", "0.", ",", "1.", "]", ")", "\n", "moving_mean", "=", "np", ".", "array", "(", "[", "1.", ",", "1.", "]", ")", "\n", "moving_variance", "=", "np", ".", "array", "(", "[", "1.", ",", "2.", "]", ")", "\n", "iteration", "=", "np", ".", "array", "(", "-", "1", ")", "\n", "\n", "train_ds", "=", "generate_dataset", "(", "train_size", "=", "10", ",", "batch_size", "=", "10", ",", "input_shape", "=", "x_shape", ",", "\n", "num_class", "=", "2", ")", "\n", "\n", "(", "unfold_model", ",", "fold_model_batch", ")", "=", "get_models_with_one_layer", "(", "\n", "kernel_quantizer", "=", "None", ",", "folding_mode", "=", "\"batch_stats_folding\"", ",", "\n", "ema_freeze_delay", "=", "10", ")", "\n", "(", "_", ",", "fold_model_ema", ")", "=", "get_models_with_one_layer", "(", "\n", "kernel_quantizer", "=", "None", ",", "folding_mode", "=", "\"ema_stats_folding\"", ",", "\n", "ema_freeze_delay", "=", "10", ")", "\n", "\n", "unfold_model", ".", "layers", "[", "1", "]", ".", "set_weights", "(", "[", "kernel", "]", ")", "\n", "unfold_model", ".", "layers", "[", "2", "]", ".", "set_weights", "(", "\n", "[", "gamma", ",", "beta", ",", "moving_mean", ",", "moving_variance", "]", ")", "\n", "fold_model_batch", ".", "layers", "[", "1", "]", ".", "set_weights", "(", "[", "\n", "kernel", ",", "gamma", ",", "beta", ",", "iteration", ",", "moving_mean", ",", "moving_variance", "\n", "]", ")", "\n", "fold_model_ema", ".", "layers", "[", "1", "]", ".", "set_weights", "(", "[", "\n", "kernel", ",", "gamma", ",", "beta", ",", "iteration", ",", "moving_mean", ",", "moving_variance", "\n", "]", ")", "\n", "\n", "# check if prediction is the same", "\n", "y1", "=", "unfold_model", ".", "predict", "(", "train_ds", ")", "\n", "y2_batch", "=", "fold_model_batch", ".", "predict", "(", "train_ds", ")", "\n", "y2_ema", "=", "fold_model_ema", ".", "predict", "(", "train_ds", ")", "\n", "assert_allclose", "(", "y1", ",", "y2_batch", ",", "rtol", "=", "1e-4", ")", "\n", "assert_allclose", "(", "y1", ",", "y2_ema", ",", "rtol", "=", "1e-4", ")", "\n", "\n", "# check if training for a number of epochs, and before bn freeeze, models", "\n", "# reached the same point", "\n", "y1", "=", "run_training", "(", "unfold_model", ",", "epochs", ",", "loss_fn", ",", "loss_metric", ",", "optimizer", ",", "\n", "train_ds", ",", "do_print", "=", "False", ")", "\n", "y2_batch", "=", "run_training", "(", "fold_model_batch", ",", "epochs", ",", "loss_fn", ",", "loss_metric", ",", "\n", "optimizer", ",", "train_ds", ",", "do_print", "=", "False", ")", "\n", "y2_ema", "=", "run_training", "(", "fold_model_ema", ",", "epochs", ",", "loss_fn", ",", "loss_metric", ",", "optimizer", ",", "\n", "train_ds", ",", "do_print", "=", "False", ")", "\n", "assert_allclose", "(", "y1", ",", "y2_batch", ",", "rtol", "=", "1e-4", ")", "\n", "assert_allclose", "(", "y1", ",", "y2_ema", ",", "rtol", "=", "1e-4", ")", "\n", "\n", "# check if training for long enough (after bn freezes), unfold model and fold", "\n", "# models should be different, but the two folding modes should be the same", "\n", "epochs", "=", "5", "\n", "iteration", "=", "np", ".", "array", "(", "8", ")", "\n", "(", "unfold_model", ",", "fold_model_batch", ")", "=", "get_models_with_one_layer", "(", "\n", "kernel_quantizer", "=", "None", ",", "folding_mode", "=", "\"batch_stats_folding\"", ",", "\n", "ema_freeze_delay", "=", "10", ")", "\n", "(", "_", ",", "fold_model_ema", ")", "=", "get_models_with_one_layer", "(", "\n", "kernel_quantizer", "=", "None", ",", "folding_mode", "=", "\"ema_stats_folding\"", ",", "\n", "ema_freeze_delay", "=", "10", ")", "\n", "unfold_model", ".", "layers", "[", "1", "]", ".", "set_weights", "(", "[", "kernel", "]", ")", "\n", "unfold_model", ".", "layers", "[", "2", "]", ".", "set_weights", "(", "\n", "[", "gamma", ",", "beta", ",", "moving_mean", ",", "moving_variance", "]", ")", "\n", "fold_model_batch", ".", "layers", "[", "1", "]", ".", "set_weights", "(", "[", "\n", "kernel", ",", "gamma", ",", "beta", ",", "iteration", ",", "moving_mean", ",", "moving_variance", "\n", "]", ")", "\n", "fold_model_ema", ".", "layers", "[", "1", "]", ".", "set_weights", "(", "[", "\n", "kernel", ",", "gamma", ",", "beta", ",", "iteration", ",", "moving_mean", ",", "moving_variance", "\n", "]", ")", "\n", "y1", "=", "run_training", "(", "\n", "unfold_model", ",", "\n", "epochs", ",", "\n", "loss_fn", ",", "\n", "loss_metric", ",", "\n", "optimizer", ",", "\n", "train_ds", ",", "\n", "do_print", "=", "False", ")", "\n", "y2_batch", "=", "run_training", "(", "\n", "fold_model_batch", ",", "\n", "epochs", ",", "\n", "loss_fn", ",", "\n", "loss_metric", ",", "\n", "optimizer", ",", "\n", "train_ds", ",", "\n", "do_print", "=", "False", ")", "\n", "y2_ema", "=", "run_training", "(", "\n", "fold_model_ema", ",", "\n", "epochs", ",", "\n", "loss_fn", ",", "\n", "loss_metric", ",", "\n", "optimizer", ",", "\n", "train_ds", ",", "\n", "do_print", "=", "False", ")", "\n", "assert_raises", "(", "AssertionError", ",", "assert_allclose", ",", "y1", ",", "y2_batch", ",", "rtol", "=", "1e-4", ")", "\n", "assert_allclose", "(", "y2_batch", ",", "y2_ema", ",", "rtol", "=", "1e-4", ")", "\n", "\n", "# test QDepthwiseConv2DBatchnorm layers", "\n", "def", "_get_models", "(", "x_shape", ",", "num_class", ",", "depthwise_quantizer", ",", "folding_mode", ",", "\n", "ema_freeze_delay", ")", ":", "\n", "    ", "x", "=", "x_in", "=", "layers", ".", "Input", "(", "x_shape", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QDepthwiseConv2DBatchnorm", "(", "\n", "kernel_size", "=", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "depth_multiplier", "=", "1", ",", "\n", "depthwise_initializer", "=", "\"ones\"", ",", "bias_initializer", "=", "\"zeros\"", ",", "use_bias", "=", "False", ",", "\n", "depthwise_quantizer", "=", "depthwise_quantizer", ",", "beta_initializer", "=", "\"zeros\"", ",", "\n", "gamma_initializer", "=", "\"ones\"", ",", "moving_mean_initializer", "=", "\"zeros\"", ",", "\n", "moving_variance_initializer", "=", "\"ones\"", ",", "folding_mode", "=", "folding_mode", ",", "\n", "ema_freeze_delay", "=", "ema_freeze_delay", ",", "\n", "name", "=", "\"fold_depthwiseconv2d\"", ")", "(", "x", ")", "\n", "x", "=", "layers", ".", "Flatten", "(", "name", "=", "\"flatten\"", ")", "(", "x", ")", "\n", "x", "=", "layers", ".", "Dense", "(", "num_class", ",", "use_bias", "=", "False", ",", "kernel_initializer", "=", "\"ones\"", ",", "\n", "name", "=", "\"dense\"", ")", "(", "x", ")", "\n", "x", "=", "layers", ".", "Activation", "(", "\"softmax\"", ",", "name", "=", "\"softmax\"", ")", "(", "x", ")", "\n", "fold_model", "=", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "\n", "x", "=", "x_in", "=", "layers", ".", "Input", "(", "x_shape", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QDepthwiseConv2D", "(", "\n", "kernel_size", "=", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "depth_multiplier", "=", "1", ",", "\n", "depthwise_initializer", "=", "\"ones\"", ",", "bias_initializer", "=", "\"zeros\"", ",", "use_bias", "=", "False", ",", "\n", "depthwise_quantizer", "=", "depthwise_quantizer", ",", "\n", "name", "=", "\"depthwiseconv2d\"", ")", "(", "x", ")", "\n", "x", "=", "layers", ".", "BatchNormalization", "(", "\n", "beta_initializer", "=", "\"zeros\"", ",", "\n", "gamma_initializer", "=", "\"ones\"", ",", "moving_mean_initializer", "=", "\"zeros\"", ",", "\n", "moving_variance_initializer", "=", "\"ones\"", ",", "\n", "name", "=", "\"bn\"", ")", "(", "x", ")", "\n", "x", "=", "layers", ".", "Flatten", "(", "name", "=", "\"flatten\"", ")", "(", "x", ")", "\n", "x", "=", "layers", ".", "Dense", "(", "num_class", ",", "use_bias", "=", "False", ",", "kernel_initializer", "=", "\"ones\"", ",", "\n", "name", "=", "\"dense\"", ")", "(", "x", ")", "\n", "x", "=", "layers", ".", "Activation", "(", "\"softmax\"", ",", "name", "=", "\"softmax\"", ")", "(", "x", ")", "\n", "model", "=", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "\n", "return", "(", "model", ",", "fold_model", ")", "\n", "\n", "", "input_shape", "=", "(", "4", ",", "4", ",", "1", ")", "\n", "num_class", "=", "2", "\n", "depthwise_quantizer", "=", "None", "\n", "folding_mode", "=", "\"ema_stats_folding\"", "\n", "ema_freeze_delay", "=", "10", "\n", "\n", "# weights", "\n", "depthwise_kernel", "=", "np", ".", "array", "(", "[", "[", "[", "[", "1.", "]", "]", ",", "[", "[", "0.", "]", "]", "]", ",", "[", "[", "[", "0.", "]", "]", ",", "[", "[", "1.", "]", "]", "]", "]", ")", "\n", "gamma", "=", "np", ".", "array", "(", "[", "2", "]", ")", "\n", "beta", "=", "np", ".", "array", "(", "[", "0", "]", ")", "\n", "moving_mean", "=", "np", ".", "array", "(", "[", "4.", "]", ")", "\n", "moving_variance", "=", "np", ".", "array", "(", "[", "2.", "]", ")", "\n", "iteration", "=", "np", ".", "array", "(", "2", ")", "\n", "folded_depthwise_kernel_quantized", "=", "np", ".", "array", "(", "\n", "[", "[", "[", "[", "1.4138602", "]", "]", ",", "[", "[", "0.", "]", "]", "]", ",", "[", "[", "[", "0.", "]", "]", ",", "[", "[", "1.4138602", "]", "]", "]", "]", ")", "\n", "folded_bias_quantized", "=", "np", ".", "array", "(", "[", "-", "5.655441", "]", ")", "\n", "dense_weight", "=", "np", ".", "array", "(", "[", "[", "1.", ",", "0", "]", ",", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", ")", "\n", "\n", "# generate dataset", "\n", "train_ds", "=", "generate_dataset", "(", "train_size", "=", "3", ",", "batch_size", "=", "3", ",", "\n", "input_shape", "=", "input_shape", ",", "num_class", "=", "2", ")", "\n", "\n", "# define models, one with folded layer and one without", "\n", "(", "model", ",", "fold_model", ")", "=", "_get_models", "(", "\n", "input_shape", ",", "num_class", "=", "num_class", ",", "depthwise_quantizer", "=", "depthwise_quantizer", ",", "\n", "folding_mode", "=", "folding_mode", ",", "ema_freeze_delay", "=", "ema_freeze_delay", ")", "\n", "\n", "# set weights", "\n", "fold_model", ".", "layers", "[", "1", "]", ".", "set_weights", "(", "[", "\n", "depthwise_kernel", ",", "gamma", ",", "beta", ",", "iteration", ",", "moving_mean", ",", "moving_variance", "]", ")", "\n", "fold_model", ".", "layers", "[", "3", "]", ".", "set_weights", "(", "[", "dense_weight", "]", ")", "\n", "\n", "model", ".", "layers", "[", "1", "]", ".", "set_weights", "(", "[", "depthwise_kernel", "]", ")", "\n", "model", ".", "layers", "[", "2", "]", ".", "set_weights", "(", "[", "gamma", ",", "beta", ",", "moving_mean", ",", "moving_variance", "]", ")", "\n", "model", ".", "layers", "[", "4", "]", ".", "set_weights", "(", "[", "dense_weight", "]", ")", "\n", "\n", "# perform training", "\n", "epochs", "=", "5", "\n", "loss_fn", "=", "tf", ".", "keras", ".", "losses", ".", "MeanSquaredError", "(", ")", "\n", "loss_metric", "=", "metrics", ".", "Mean", "(", ")", "\n", "optimizer", "=", "tf", ".", "keras", ".", "optimizers", ".", "SGD", "(", "learning_rate", "=", "1e-3", ")", "\n", "\n", "pred1", "=", "run_training", "(", "\n", "model", ",", "epochs", ",", "loss_fn", ",", "loss_metric", ",", "optimizer", ",", "train_ds", ",", "do_print", "=", "False", ")", "\n", "pred2", "=", "run_training", "(", "\n", "fold_model", ",", "epochs", ",", "loss_fn", ",", "loss_metric", ",", "optimizer", ",", "train_ds", ",", "\n", "do_print", "=", "False", ")", "\n", "\n", "# before bn freezes, the two models should reach the same point", "\n", "assert_allclose", "(", "pred1", ",", "pred2", ",", "rtol", "=", "1e-4", ")", "\n", "\n", "# after bn freezes, the two models will not reach the same", "\n", "iteration", "=", "np", ".", "array", "(", "12", ")", "\n", "epochs", "=", "5", "\n", "ema_freeze_delay", "=", "10", "\n", "(", "model", ",", "fold_model", ")", "=", "_get_models", "(", "\n", "input_shape", ",", "num_class", "=", "num_class", ",", "depthwise_quantizer", "=", "depthwise_quantizer", ",", "\n", "folding_mode", "=", "folding_mode", ",", "ema_freeze_delay", "=", "ema_freeze_delay", ")", "\n", "fold_model", ".", "layers", "[", "1", "]", ".", "set_weights", "(", "[", "\n", "depthwise_kernel", ",", "gamma", ",", "beta", ",", "iteration", ",", "moving_mean", ",", "moving_variance", "]", ")", "\n", "fold_model", ".", "layers", "[", "3", "]", ".", "set_weights", "(", "[", "dense_weight", "]", ")", "\n", "model", ".", "layers", "[", "1", "]", ".", "set_weights", "(", "[", "depthwise_kernel", "]", ")", "\n", "model", ".", "layers", "[", "2", "]", ".", "set_weights", "(", "[", "gamma", ",", "beta", ",", "moving_mean", ",", "moving_variance", "]", ")", "\n", "model", ".", "layers", "[", "4", "]", ".", "set_weights", "(", "[", "dense_weight", "]", ")", "\n", "pred1", "=", "run_training", "(", "\n", "model", ",", "epochs", ",", "loss_fn", ",", "loss_metric", ",", "optimizer", ",", "train_ds", ",", "do_print", "=", "False", ")", "\n", "pred2", "=", "run_training", "(", "\n", "fold_model", ",", "epochs", ",", "loss_fn", ",", "loss_metric", ",", "optimizer", ",", "train_ds", ",", "\n", "do_print", "=", "False", ")", "\n", "\n", "assert_raises", "(", "AssertionError", ",", "assert_allclose", ",", "pred1", ",", "pred2", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.bn_folding_test.test_populate_bias_quantizer_from_accumulator": [[604, 657], ["tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "numpy.testing.assert_equal", "qkeras.bn_folding_utils.populate_bias_quantizer_from_accumulator", "numpy.testing.assert_equal", "qkeras.bn_folding_utils.populate_bias_quantizer_from_accumulator", "numpy.testing.assert_equal", "qkeras.QConv2D", "qkeras.QConv2D", "tensorflow.keras.layers.Maximum", "qkeras.QActivation", "qkeras.QConv2DBatchnorm", "tensorflow.keras.layers.Flatten", "qkeras.QDense", "tensorflow.keras.models.Model.layers[].get_quantizers", "q.__str__", "tensorflow.keras.models.Model.layers[].get_quantizers", "q.__str__", "tensorflow.keras.models.Model.layers[].get_quantizers"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.bn_folding_utils.populate_bias_quantizer_from_accumulator", "home.repos.pwc.inspect_result.google_qkeras.qkeras.bn_folding_utils.populate_bias_quantizer_from_accumulator", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.__str__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.__str__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers"], ["", "def", "test_populate_bias_quantizer_from_accumulator", "(", ")", ":", "\n", "  ", "\"\"\"Test populate_bias_quantizer_from_accumulator function.\n\n  Define a qkeras model with a QConv2DBatchnorm layer. Set bias quantizer in the\n  layer as None. Call populate_bias_quantizer_from_accumulator function\n  to automatically generate bias quantizer type from the MAC accumulator type.\n  Set the bias quantizer accordingly in the model.\n\n  Call populate_bias_quantizer_from_accumulator again in this model. This time\n  since bias quantizer is already set, populate_bias_quantizer_from_accumulator\n  function should not change the bias quantizer.\n  \"\"\"", "\n", "\n", "x_shape", "=", "(", "2", ",", "2", ",", "1", ")", "\n", "\n", "# get a qkeras model with QConv2DBatchnorm layer. Set bias quantizer in the", "\n", "# layer as None.", "\n", "x", "=", "x_in", "=", "layers", ".", "Input", "(", "x_shape", ",", "name", "=", "\"input\"", ")", "\n", "x1", "=", "QConv2D", "(", "filters", "=", "1", ",", "kernel_size", "=", "(", "1", ",", "1", ")", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "use_bias", "=", "False", ",", "\n", "kernel_quantizer", "=", "\"quantized_bits(4, 0, 1)\"", ",", "name", "=", "\"conv2d_1\"", ")", "(", "x", ")", "\n", "x2", "=", "QConv2D", "(", "filters", "=", "1", ",", "kernel_size", "=", "(", "1", ",", "1", ")", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "use_bias", "=", "False", ",", "\n", "kernel_quantizer", "=", "\"quantized_bits(4, 0, 1)\"", ",", "name", "=", "\"conv2d_2\"", ")", "(", "x", ")", "\n", "x", "=", "layers", ".", "Maximum", "(", ")", "(", "[", "x1", ",", "x2", "]", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(4, 1)\"", ")", "(", "x", ")", "\n", "x", "=", "QConv2DBatchnorm", "(", "\n", "filters", "=", "2", ",", "kernel_size", "=", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "4", ",", "4", ")", ",", "\n", "kernel_initializer", "=", "\"ones\"", ",", "bias_initializer", "=", "\"zeros\"", ",", "use_bias", "=", "False", ",", "\n", "kernel_quantizer", "=", "\"quantized_bits(4, 0, 1)\"", ",", "bias_quantizer", "=", "None", ",", "\n", "beta_initializer", "=", "\"zeros\"", ",", "\n", "gamma_initializer", "=", "\"ones\"", ",", "moving_mean_initializer", "=", "\"zeros\"", ",", "\n", "moving_variance_initializer", "=", "\"ones\"", ",", "folding_mode", "=", "\"batch_stats_folding\"", ",", "\n", "ema_freeze_delay", "=", "10", ",", "\n", "name", "=", "\"foldconv2d\"", ")", "(", "x", ")", "\n", "x1", "=", "x", "\n", "x2", "=", "layers", ".", "Flatten", "(", "name", "=", "\"flatten\"", ")", "(", "x", ")", "\n", "x2", "=", "QDense", "(", "2", ",", "use_bias", "=", "False", ",", "kernel_initializer", "=", "\"ones\"", ",", "\n", "kernel_quantizer", "=", "\"quantized_bits(6, 2, 1)\"", ",", "name", "=", "\"dense\"", ")", "(", "x2", ")", "\n", "model", "=", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x1", ",", "x2", "]", ")", "\n", "assert_equal", "(", "model", ".", "layers", "[", "5", "]", ".", "get_quantizers", "(", ")", "[", "1", "]", ",", "None", ")", "\n", "\n", "# Call populate_bias_quantizer_from_accumulator function", "\n", "# to automatically generate bias quantizer from the MAC accumulator type.", "\n", "_", "=", "bn_folding_utils", ".", "populate_bias_quantizer_from_accumulator", "(", "\n", "model", ",", "[", "\"quantized_bits(8, 0, 1)\"", "]", ")", "\n", "q", "=", "model", ".", "layers", "[", "5", "]", ".", "get_quantizers", "(", ")", "[", "1", "]", "\n", "assert_equal", "(", "q", ".", "__str__", "(", ")", ",", "\"quantized_bits(10,3,1)\"", ")", "\n", "\n", "# Call populate_bias_quantizer_from_accumulator function again", "\n", "# bias quantizer should not change", "\n", "_", "=", "bn_folding_utils", ".", "populate_bias_quantizer_from_accumulator", "(", "\n", "model", ",", "[", "\"quantized_bits(8, 0, 1)\"", "]", ")", "\n", "q", "=", "model", ".", "layers", "[", "5", "]", ".", "get_quantizers", "(", ")", "[", "1", "]", "\n", "assert_equal", "(", "q", ".", "__str__", "(", ")", ",", "\"quantized_bits(10,3,1)\"", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.tests.callbacks_test.qconv_model": [[34, 47], ["tensorflow.keras.layers.Input", "keras.Model", "QConv2D", "QActivation", "quantized_bits", "quantized_bits"], "function", ["None"], ["def", "qconv_model", "(", ")", ":", "\n", "  ", "x", "=", "x_in", "=", "tf", ".", "keras", ".", "layers", ".", "Input", "(", "(", "4", ",", "4", ",", "1", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QConv2D", "(", "\n", "1", ",", "\n", "2", ",", "\n", "1", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "6", ",", "2", ",", "1", ",", "alpha", "=", "1.0", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"qconv2d_1\"", ")", "(", "\n", "x", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(4)\"", ",", "name", "=", "\"QA_1\"", ")", "(", "x", ")", "\n", "model", "=", "keras", ".", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.callbacks_test.test_QNoiseScheduler": [[49, 220], ["callbacks_test.qconv_model", "qconv_model.compile", "numpy.random.rand", "numpy.random.rand", "qkeras.callbacks.QNoiseScheduler", "qconv_model.fit", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "qkeras.callbacks.QNoiseScheduler", "qconv_model.fit", "numpy.testing.assert_equal", "qkeras.callbacks.QNoiseScheduler", "qconv_model.fit", "numpy.testing.assert_equal", "qkeras.callbacks.QNoiseScheduler", "qconv_model.fit", "numpy.testing.assert_equal", "qkeras.callbacks.QNoiseScheduler", "qconv_model.fit", "numpy.testing.assert_equal", "qkeras.callbacks.QNoiseScheduler", "qconv_model.fit", "numpy.testing.assert_equal", "qkeras.callbacks.QNoiseScheduler", "qconv_model.fit", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "hasattr", "numpy.array", "numpy.ones_like", "numpy.array", "numpy.power", "numpy.full_like", "numpy.array", "numpy.power", "numpy.full_like", "numpy.array", "numpy.zeros_like", "numpy.array", "numpy.power", "numpy.full_like", "numpy.array", "numpy.power", "numpy.full_like", "numpy.array", "numpy.power", "numpy.full_like", "len", "tensorflow.keras.losses.MeanSquaredError"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.qconv_model", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit"], ["", "def", "test_QNoiseScheduler", "(", ")", ":", "\n", "  ", "model", "=", "qconv_model", "(", ")", "\n", "model", ".", "compile", "(", "optimizer", "=", "\"sgd\"", ",", "loss", "=", "tf", ".", "keras", ".", "losses", ".", "MeanSquaredError", "(", ")", ")", "\n", "num_data", "=", "5", "\n", "x_train", "=", "np", ".", "random", ".", "rand", "(", "num_data", ",", "4", ",", "4", ",", "1", ")", "\n", "y_train", "=", "np", ".", "random", ".", "rand", "(", "num_data", ",", "1", ")", "\n", "\n", "#########################", "\n", "# Test \"step\" freq_type #", "\n", "#########################", "\n", "\n", "# The number of batch passes the finish of 4.", "\n", "gradual_qnoise_callback_0", "=", "QNoiseScheduler", "(", "\n", "start", "=", "2", ",", "finish", "=", "4", ",", "freq_type", "=", "\"step\"", ",", "exponent", "=", "3.0", ")", "\n", "\n", "model", ".", "fit", "(", "\n", "x_train", ",", "\n", "y_train", ",", "\n", "batch_size", "=", "1", ",", "\n", "epochs", "=", "1", ",", "\n", "verbose", "=", "0", ",", "\n", "callbacks", "=", "[", "\n", "gradual_qnoise_callback_0", ",", "\n", "]", ",", "\n", ")", "\n", "\n", "# QConv2D has a kernel_quantizer and a bias_quantizer, and QActivation has a", "\n", "# quantizer.", "\n", "num_quantizers_with_qnoise_factor", "=", "0", "\n", "for", "quantizer", "in", "gradual_qnoise_callback_0", ".", "quantizers", ":", "\n", "    ", "if", "hasattr", "(", "quantizer", ",", "\"qnoise_factor\"", ")", ":", "\n", "      ", "num_quantizers_with_qnoise_factor", "+=", "1", "\n", "", "", "assert_equal", "(", "num_quantizers_with_qnoise_factor", ",", "3", ")", "# Test \"step\"", "\n", "\n", "qnoise_factor", "=", "[", "\n", "np", ".", "array", "(", "d", ".", "qnoise_factor", ")", "for", "d", "in", "gradual_qnoise_callback_0", ".", "quantizers", "\n", "]", "\n", "assert_equal", "(", "qnoise_factor", ",", "np", ".", "ones_like", "(", "qnoise_factor", ")", ")", "\n", "\n", "\n", "# The number of batch does not pass the finish of 10. Exponent 3.0", "\n", "gradual_qnoise_callback_1", "=", "QNoiseScheduler", "(", "\n", "start", "=", "2", ",", "finish", "=", "10", ",", "freq_type", "=", "\"step\"", ",", "exponent", "=", "3.0", ")", "\n", "\n", "model", ".", "fit", "(", "\n", "x_train", ",", "\n", "y_train", ",", "\n", "batch_size", "=", "1", ",", "\n", "epochs", "=", "1", ",", "\n", "verbose", "=", "0", ",", "\n", "callbacks", "=", "[", "\n", "gradual_qnoise_callback_1", ",", "\n", "]", ",", "\n", ")", "\n", "qnoise_factor", "=", "[", "\n", "np", ".", "array", "(", "d", ".", "qnoise_factor", ")", "for", "d", "in", "gradual_qnoise_callback_1", ".", "quantizers", "\n", "]", "\n", "val", "=", "1", "-", "np", ".", "power", "(", "(", "10.0", "-", "4.0", ")", "/", "(", "10.0", "-", "2.0", ")", ",", "3", ")", "\n", "assert_equal", "(", "qnoise_factor", ",", "np", ".", "full_like", "(", "qnoise_factor", ",", "val", ")", ")", "\n", "\n", "# The number of batch does not pass the finish of 10. Exponent 2.0", "\n", "gradual_qnoise_callback_2", "=", "QNoiseScheduler", "(", "\n", "start", "=", "2", ",", "finish", "=", "10", ",", "freq_type", "=", "\"step\"", ",", "exponent", "=", "2.0", ")", "\n", "\n", "model", ".", "fit", "(", "\n", "x_train", ",", "\n", "y_train", ",", "\n", "batch_size", "=", "1", ",", "\n", "epochs", "=", "1", ",", "\n", "verbose", "=", "0", ",", "\n", "callbacks", "=", "[", "\n", "gradual_qnoise_callback_2", ",", "\n", "]", ",", "\n", ")", "\n", "qnoise_factor", "=", "[", "\n", "np", ".", "array", "(", "d", ".", "qnoise_factor", ")", "for", "d", "in", "gradual_qnoise_callback_2", ".", "quantizers", "\n", "]", "\n", "val", "=", "1", "-", "np", ".", "power", "(", "(", "10.0", "-", "4.0", ")", "/", "(", "10.0", "-", "2.0", ")", ",", "2", ")", "\n", "assert_equal", "(", "qnoise_factor", ",", "np", ".", "full_like", "(", "qnoise_factor", ",", "val", ")", ")", "\n", "\n", "# The number of batch does not pass the start of 6.", "\n", "gradual_qnoise_callback_3", "=", "QNoiseScheduler", "(", "\n", "start", "=", "6", ",", "finish", "=", "10", ",", "freq_type", "=", "\"step\"", ",", "exponent", "=", "3.0", ")", "\n", "\n", "model", ".", "fit", "(", "\n", "x_train", ",", "\n", "y_train", ",", "\n", "batch_size", "=", "1", ",", "\n", "epochs", "=", "1", ",", "\n", "verbose", "=", "0", ",", "\n", "callbacks", "=", "[", "\n", "gradual_qnoise_callback_3", ",", "\n", "]", ",", "\n", ")", "\n", "qnoise_factor", "=", "[", "\n", "np", ".", "array", "(", "d", ".", "qnoise_factor", ")", "for", "d", "in", "gradual_qnoise_callback_3", ".", "quantizers", "\n", "]", "\n", "assert_equal", "(", "qnoise_factor", ",", "np", ".", "zeros_like", "(", "qnoise_factor", ")", ")", "\n", "\n", "\n", "# The number of training iterations passes the number of batches of an epoch.", "\n", "gradual_qnoise_callback_4", "=", "QNoiseScheduler", "(", "\n", "start", "=", "6", ",", "finish", "=", "20", ",", "freq_type", "=", "\"step\"", ",", "exponent", "=", "3.0", ")", "\n", "epochs", "=", "2", "\n", "model", ".", "fit", "(", "\n", "x_train", ",", "\n", "y_train", ",", "\n", "batch_size", "=", "1", ",", "\n", "epochs", "=", "epochs", ",", "\n", "verbose", "=", "0", ",", "\n", "callbacks", "=", "[", "\n", "gradual_qnoise_callback_4", ",", "\n", "]", ",", "\n", ")", "\n", "qnoise_factor", "=", "[", "\n", "np", ".", "array", "(", "d", ".", "qnoise_factor", ")", "for", "d", "in", "gradual_qnoise_callback_4", ".", "quantizers", "\n", "]", "\n", "val", "=", "1", "-", "np", ".", "power", "(", "(", "20.0", "-", "(", "epochs", "*", "num_data", "-", "1", ")", ")", "/", "(", "20.0", "-", "6.0", ")", ",", "3", ")", "\n", "assert_equal", "(", "qnoise_factor", ",", "np", ".", "full_like", "(", "qnoise_factor", ",", "val", ")", ")", "\n", "\n", "# The number of training iterations passes the number of batches of an epoch", "\n", "# with update_freq = 2.", "\n", "gradual_qnoise_callback_5", "=", "QNoiseScheduler", "(", "\n", "start", "=", "0", ",", "\n", "finish", "=", "20", ",", "\n", "freq_type", "=", "\"step\"", ",", "\n", "update_freq", "=", "2", ",", "\n", "exponent", "=", "3.0", ")", "\n", "epochs", "=", "2", "\n", "model", ".", "fit", "(", "\n", "x_train", ",", "\n", "y_train", ",", "\n", "batch_size", "=", "1", ",", "\n", "epochs", "=", "epochs", ",", "\n", "verbose", "=", "0", ",", "\n", "callbacks", "=", "[", "\n", "gradual_qnoise_callback_5", ",", "\n", "]", ",", "\n", ")", "\n", "qnoise_factor", "=", "[", "\n", "np", ".", "array", "(", "d", ".", "qnoise_factor", ")", "for", "d", "in", "gradual_qnoise_callback_5", ".", "quantizers", "\n", "]", "\n", "# It updates when the number of training iterations modulo update_freq is 0.", "\n", "val", "=", "1", "-", "np", ".", "power", "(", "\n", "(", "20.0", "-", "epochs", "*", "(", "(", "epochs", "*", "num_data", "-", "1", ")", "//", "epochs", ")", ")", "/", "(", "20.0", "-", "0.0", ")", ",", "3", ")", "\n", "assert_equal", "(", "qnoise_factor", ",", "np", ".", "full_like", "(", "qnoise_factor", ",", "val", ")", ")", "\n", "\n", "\n", "##########################", "\n", "# Test \"epoch\" freq_type #", "\n", "##########################", "\n", "# The number of epoch does not pass the finish of 5.", "\n", "gradual_qnoise_callback_6", "=", "QNoiseScheduler", "(", "\n", "start", "=", "1", ",", "finish", "=", "5", ",", "freq_type", "=", "\"epoch\"", ",", "exponent", "=", "3.0", ")", "\n", "\n", "model", ".", "fit", "(", "\n", "x_train", ",", "\n", "y_train", ",", "\n", "batch_size", "=", "1", ",", "\n", "epochs", "=", "3", ",", "\n", "verbose", "=", "0", ",", "\n", "callbacks", "=", "[", "\n", "gradual_qnoise_callback_6", ",", "\n", "]", ",", "\n", ")", "\n", "qnoise_factor", "=", "[", "\n", "np", ".", "array", "(", "d", ".", "qnoise_factor", ")", "for", "d", "in", "gradual_qnoise_callback_6", ".", "quantizers", "\n", "]", "\n", "val", "=", "1", "-", "np", ".", "power", "(", "(", "5.0", "-", "2.0", ")", "/", "(", "5.0", "-", "1.0", ")", ",", "3", ")", "\n", "assert_equal", "(", "qnoise_factor", ",", "np", ".", "full_like", "(", "qnoise_factor", ",", "val", ")", ")", "\n", "assert_equal", "(", "len", "(", "gradual_qnoise_callback_6", ".", "quantizers", ")", ",", "3", ")", "# Test \"epoch\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.autoqkeras_test.dense_model": [[38, 56], ["tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.BatchNormalization", "tensorflow.keras.layers.Activation", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.BatchNormalization", "tensorflow.keras.layers.Activation", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.BatchNormalization", "tensorflow.keras.layers.Activation", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Activation"], "function", ["None"], ["def", "dense_model", "(", ")", ":", "\n", "  ", "\"\"\"Creates test dense model.\"\"\"", "\n", "\n", "x", "=", "x_in", "=", "Input", "(", "(", "4", ",", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "Dense", "(", "20", ",", "name", "=", "\"dense_0\"", ")", "(", "x", ")", "\n", "x", "=", "BatchNormalization", "(", "name", "=", "\"bn0\"", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "\"relu\"", ",", "name", "=", "\"relu_0\"", ")", "(", "x", ")", "\n", "x", "=", "Dense", "(", "40", ",", "name", "=", "\"dense_1\"", ")", "(", "x", ")", "\n", "x", "=", "BatchNormalization", "(", "name", "=", "\"bn1\"", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "\"relu\"", ",", "name", "=", "\"relu_1\"", ")", "(", "x", ")", "\n", "x", "=", "Dense", "(", "20", ",", "name", "=", "\"dense_2\"", ")", "(", "x", ")", "\n", "x", "=", "BatchNormalization", "(", "name", "=", "\"bn2\"", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "\"relu\"", ",", "name", "=", "\"relu_2\"", ")", "(", "x", ")", "\n", "x", "=", "Dense", "(", "3", ",", "name", "=", "\"dense\"", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "\"softmax\"", ",", "name", "=", "\"softmax\"", ")", "(", "x", ")", "\n", "\n", "model", "=", "Model", "(", "inputs", "=", "x_in", ",", "outputs", "=", "x", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.autoqkeras_test.test_autoqkeras": [[58, 151], ["numpy.random.seed", "tensorflow.random.set_seed", "sklearn.datasets.load_iris", "sklearn.preprocessing.MinMaxScaler", "sklearn.preprocessing.MinMaxScaler.fit", "sklearn.preprocessing.MinMaxScaler.transform", "tensorflow.keras.utils.to_categorical", "autoqkeras_test.dense_model", "dense_model.summary", "tensorflow.keras.optimizers.Adam", "dense_model.compile", "qkeras.autoqkeras.AutoQKerasScheduler", "qkeras.autoqkeras.AutoQKerasScheduler.fit", "qkeras.autoqkeras.AutoQKerasScheduler.get_best_model", "tensorflow.keras.optimizers.Adam", "autoqk.get_best_model.compile", "autoqk.get_best_model.fit", "numpy.max", "tempfile.mkdtemp"], "function", ["home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit", "home.repos.pwc.inspect_result.google_qkeras.tests.autoqkeras_test.dense_model", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.get_best_model", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "def", "test_autoqkeras", "(", ")", ":", "\n", "  ", "\"\"\"Tests AutoQKeras scheduler.\"\"\"", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "tf", ".", "random", ".", "set_seed", "(", "42", ")", "\n", "\n", "x_train", ",", "y_train", "=", "load_iris", "(", "return_X_y", "=", "True", ")", "\n", "\n", "scaler", "=", "MinMaxScaler", "(", "feature_range", "=", "(", "-", "0.5", ",", "0.5", ")", ")", "\n", "scaler", ".", "fit", "(", "x_train", ")", "\n", "x_train", "=", "scaler", ".", "transform", "(", "x_train", ")", "\n", "\n", "nb_classes", "=", "np", ".", "max", "(", "y_train", ")", "+", "1", "\n", "y_train", "=", "to_categorical", "(", "y_train", ",", "nb_classes", ")", "\n", "\n", "quantization_config", "=", "{", "\n", "\"kernel\"", ":", "{", "\n", "\"stochastic_ternary\"", ":", "2", ",", "\n", "\"quantized_bits(8,0,1,alpha=1.0)\"", ":", "8", "\n", "}", ",", "\n", "\"bias\"", ":", "{", "\n", "\"quantized_bits(4,0,1)\"", ":", "4", "\n", "}", ",", "\n", "\"activation\"", ":", "{", "\n", "\"quantized_relu(4,1)\"", ":", "4", "\n", "}", ",", "\n", "\"linear\"", ":", "{", "\n", "\"binary\"", ":", "1", "\n", "}", "\n", "}", "\n", "\n", "goal", "=", "{", "\n", "\"type\"", ":", "\"energy\"", ",", "\n", "\"params\"", ":", "{", "\n", "\"delta_p\"", ":", "8.0", ",", "\n", "\"delta_n\"", ":", "8.0", ",", "\n", "\"rate\"", ":", "2.0", ",", "\n", "\"stress\"", ":", "1.0", ",", "\n", "\"process\"", ":", "\"horowitz\"", ",", "\n", "\"parameters_on_memory\"", ":", "[", "\"sram\"", ",", "\"sram\"", "]", ",", "\n", "\"activations_on_memory\"", ":", "[", "\"sram\"", ",", "\"sram\"", "]", ",", "\n", "\"rd_wr_on_io\"", ":", "[", "False", ",", "False", "]", ",", "\n", "\"min_sram_size\"", ":", "[", "0", ",", "0", "]", ",", "\n", "\"reference_internal\"", ":", "\"int8\"", ",", "\n", "\"reference_accumulator\"", ":", "\"int32\"", "\n", "}", "\n", "}", "\n", "\n", "model", "=", "dense_model", "(", ")", "\n", "model", ".", "summary", "(", ")", "\n", "optimizer", "=", "Adam", "(", "lr", "=", "0.01", ")", "\n", "model", ".", "compile", "(", "optimizer", "=", "optimizer", ",", "loss", "=", "\"categorical_crossentropy\"", ",", "\n", "metrics", "=", "[", "\"acc\"", "]", ")", "\n", "\n", "limit", "=", "{", "\n", "\"dense_0\"", ":", "[", "[", "\"stochastic_ternary\"", "]", ",", "8", ",", "4", "]", ",", "\n", "\"dense\"", ":", "[", "[", "\"quantized_bits(8,0,1,alpha=1.0)\"", "]", ",", "8", ",", "4", "]", ",", "\n", "\"BatchNormalization\"", ":", "[", "]", ",", "\n", "\"Activation\"", ":", "[", "4", "]", "\n", "}", "\n", "\n", "run_config", "=", "{", "\n", "\"output_dir\"", ":", "tempfile", ".", "mkdtemp", "(", ")", ",", "\n", "\"goal\"", ":", "goal", ",", "\n", "\"quantization_config\"", ":", "quantization_config", ",", "\n", "\"learning_rate_optimizer\"", ":", "False", ",", "\n", "\"transfer_weights\"", ":", "False", ",", "\n", "\"mode\"", ":", "\"random\"", ",", "\n", "\"seed\"", ":", "42", ",", "\n", "\"limit\"", ":", "limit", ",", "\n", "\"tune_filters\"", ":", "\"layer\"", ",", "\n", "\"tune_filters_exceptions\"", ":", "\"^dense$\"", ",", "\n", "\"max_trials\"", ":", "1", ",", "\n", "\n", "\"blocks\"", ":", "[", "\n", "\"^.*0$\"", ",", "\n", "\"^dense$\"", "\n", "]", ",", "\n", "\"schedule_block\"", ":", "\"cost\"", "\n", "}", "\n", "\n", "autoqk", "=", "AutoQKerasScheduler", "(", "model", ",", "metrics", "=", "[", "\"acc\"", "]", ",", "**", "run_config", ")", "\n", "autoqk", ".", "fit", "(", "x_train", ",", "y_train", ",", "validation_split", "=", "0.1", ",", "batch_size", "=", "150", ",", "epochs", "=", "4", ")", "\n", "\n", "qmodel", "=", "autoqk", ".", "get_best_model", "(", ")", "\n", "\n", "optimizer", "=", "Adam", "(", "lr", "=", "0.01", ")", "\n", "qmodel", ".", "compile", "(", "optimizer", "=", "optimizer", ",", "loss", "=", "\"categorical_crossentropy\"", ",", "\n", "metrics", "=", "[", "\"acc\"", "]", ")", "\n", "history", "=", "qmodel", ".", "fit", "(", "x_train", ",", "y_train", ",", "epochs", "=", "5", ",", "batch_size", "=", "150", ",", "\n", "validation_split", "=", "0.1", ")", "\n", "\n", "quantized_acc", "=", "history", ".", "history", "[", "\"acc\"", "]", "[", "-", "1", "]", "\n", "assert", "quantized_acc", ">=", "0.93", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.min_max_test.test_binary": [[26, 34], ["binary", "stochastic_binary", "stochastic_binary.min", "stochastic_binary.max", "stochastic_binary.min", "stochastic_binary.max"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["def", "test_binary", "(", ")", ":", "\n", "  ", "q", "=", "binary", "(", "alpha", "=", "1.0", ")", "\n", "assert", "q", ".", "min", "(", ")", "==", "-", "1.0", "\n", "assert", "q", ".", "max", "(", ")", "==", "1.0", "\n", "\n", "q", "=", "stochastic_binary", "(", "alpha", "=", "1.0", ")", "\n", "assert", "q", ".", "min", "(", ")", "==", "-", "1.0", "\n", "assert", "q", ".", "max", "(", ")", "==", "1.0", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.min_max_test.test_ternary": [[36, 44], ["ternary", "stochastic_ternary", "stochastic_ternary.min", "stochastic_ternary.max", "stochastic_ternary.min", "stochastic_ternary.max"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "def", "test_ternary", "(", ")", ":", "\n", "  ", "q", "=", "ternary", "(", "alpha", "=", "1.0", ")", "\n", "assert", "q", ".", "min", "(", ")", "==", "-", "1.0", "\n", "assert", "q", ".", "max", "(", ")", "==", "1.0", "\n", "\n", "q", "=", "stochastic_ternary", "(", "alpha", "=", "1.0", ")", "\n", "assert", "q", ".", "min", "(", ")", "==", "-", "1.0", "\n", "assert", "q", ".", "max", "(", ")", "==", "1.0", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.min_max_test.test_quantized_bits": [[46, 79], ["range", "range", "quantized_bits", "quantized_bits.min", "quantized_bits.max"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "def", "test_quantized_bits", "(", ")", ":", "\n", "  ", "results", "=", "{", "\n", "(", "1", ",", "0", ")", ":", "[", "-", "1.0", ",", "1.0", "]", ",", "\n", "(", "2", ",", "0", ")", ":", "[", "-", "1.0", ",", "1.0", "]", ",", "\n", "(", "3", ",", "0", ")", ":", "[", "-", "1.0", ",", "1.0", "]", ",", "\n", "(", "4", ",", "0", ")", ":", "[", "-", "1.0", ",", "1.0", "]", ",", "\n", "(", "5", ",", "0", ")", ":", "[", "-", "1.0", ",", "1.0", "]", ",", "\n", "(", "6", ",", "0", ")", ":", "[", "-", "1.0", ",", "1.0", "]", ",", "\n", "(", "7", ",", "0", ")", ":", "[", "-", "1.0", ",", "1.0", "]", ",", "\n", "(", "8", ",", "0", ")", ":", "[", "-", "1.0", ",", "1.0", "]", ",", "\n", "(", "1", ",", "1", ")", ":", "[", "-", "1.0", ",", "1.0", "]", ",", "\n", "(", "2", ",", "1", ")", ":", "[", "-", "2.0", ",", "2.0", "]", ",", "\n", "(", "3", ",", "1", ")", ":", "[", "-", "2.0", ",", "2.0", "]", ",", "\n", "(", "4", ",", "1", ")", ":", "[", "-", "2.0", ",", "2.0", "]", ",", "\n", "(", "5", ",", "1", ")", ":", "[", "-", "2.0", ",", "2.0", "]", ",", "\n", "(", "6", ",", "1", ")", ":", "[", "-", "2.0", ",", "2.0", "]", ",", "\n", "(", "7", ",", "1", ")", ":", "[", "-", "2.0", ",", "2.0", "]", ",", "\n", "(", "8", ",", "1", ")", ":", "[", "-", "2.0", ",", "2.0", "]", ",", "\n", "(", "3", ",", "2", ")", ":", "[", "-", "4.0", ",", "4.0", "]", ",", "\n", "(", "4", ",", "2", ")", ":", "[", "-", "4.0", ",", "4.0", "]", ",", "\n", "(", "5", ",", "2", ")", ":", "[", "-", "4.0", ",", "4.0", "]", ",", "\n", "(", "6", ",", "2", ")", ":", "[", "-", "4.0", ",", "4.0", "]", ",", "\n", "(", "7", ",", "2", ")", ":", "[", "-", "4.0", ",", "4.0", "]", ",", "\n", "(", "8", ",", "2", ")", ":", "[", "-", "4.0", ",", "4.0", "]", ",", "\n", "}", "\n", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "    ", "for", "b", "in", "range", "(", "1", ",", "9", ")", ":", "\n", "      ", "if", "b", "<=", "i", ":", "continue", "\n", "q", "=", "quantized_bits", "(", "b", ",", "i", ",", "1", ")", "\n", "expected", "=", "results", "[", "(", "b", ",", "i", ")", "]", "\n", "assert", "expected", "[", "0", "]", "==", "q", ".", "min", "(", ")", "\n", "assert", "expected", "[", "1", "]", "==", "q", ".", "max", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.min_max_test.test_po2": [[81, 138], ["range", "range", "quantized_po2", "range", "quantized_po2", "quantized_relu_po2", "quantized_po2.min", "quantized_po2.max", "quantized_po2", "quantized_po2.min", "quantized_po2.max", "quantized_po2.min", "quantized_po2.max", "quantized_po2.min", "quantized_po2.max"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "", "", "def", "test_po2", "(", ")", ":", "\n", "  ", "po2", "=", "{", "\n", "3", ":", "[", "-", "2", ",", "2", "]", ",", "\n", "4", ":", "[", "-", "8", ",", "8", "]", ",", "\n", "5", ":", "[", "-", "128", ",", "128", "]", ",", "\n", "6", ":", "[", "-", "32768", ",", "32768", "]", "\n", "}", "\n", "\n", "po2_max_value", "=", "{", "\n", "(", "3", ",", "1", ")", ":", "[", "-", "1.0", ",", "1.0", "]", ",", "\n", "(", "3", ",", "2", ")", ":", "[", "-", "2", ",", "2", "]", ",", "\n", "(", "3", ",", "4", ")", ":", "[", "-", "4", ",", "4", "]", ",", "\n", "(", "4", ",", "1", ")", ":", "[", "-", "1.0", ",", "1.0", "]", ",", "\n", "(", "4", ",", "2", ")", ":", "[", "-", "2", ",", "2", "]", ",", "\n", "(", "4", ",", "4", ")", ":", "[", "-", "4", ",", "4", "]", ",", "\n", "(", "4", ",", "8", ")", ":", "[", "-", "8", ",", "8", "]", ",", "\n", "(", "5", ",", "1", ")", ":", "[", "-", "1.0", ",", "1.0", "]", ",", "\n", "(", "5", ",", "2", ")", ":", "[", "-", "2", ",", "2", "]", ",", "\n", "(", "5", ",", "4", ")", ":", "[", "-", "4", ",", "4", "]", ",", "\n", "(", "5", ",", "8", ")", ":", "[", "-", "8", ",", "8", "]", ",", "\n", "(", "5", ",", "16", ")", ":", "[", "-", "16", ",", "16", "]", ",", "\n", "(", "6", ",", "1", ")", ":", "[", "-", "1.0", ",", "1.0", "]", ",", "\n", "(", "6", ",", "2", ")", ":", "[", "-", "2", ",", "2", "]", ",", "\n", "(", "6", ",", "4", ")", ":", "[", "-", "4", ",", "4", "]", ",", "\n", "(", "6", ",", "8", ")", ":", "[", "-", "8", ",", "8", "]", ",", "\n", "(", "6", ",", "16", ")", ":", "[", "-", "16", ",", "16", "]", ",", "\n", "(", "6", ",", "32", ")", ":", "[", "-", "32", ",", "32", "]", "\n", "}", "\n", "\n", "po2_quadratic", "=", "{", "\n", "4", ":", "[", "-", "4", ",", "4", "]", ",", "\n", "5", ":", "[", "-", "64", ",", "64", "]", ",", "\n", "6", ":", "[", "-", "16384", ",", "16384", "]", "\n", "}", "\n", "\n", "relu_po2_quadratic", "=", "{", "\n", "4", ":", "[", "0.00390625", ",", "64", "]", ",", "\n", "5", ":", "[", "1.52587890625e-05", ",", "16384", "]", ",", "\n", "6", ":", "[", "2.3283064365386963e-10", ",", "1073741824", "]", "\n", "}", "\n", "\n", "for", "b", "in", "range", "(", "3", ",", "7", ")", ":", "\n", "    ", "q", "=", "quantized_po2", "(", "b", ")", "\n", "assert", "po2", "[", "b", "]", "[", "0", "]", "==", "q", ".", "min", "(", ")", "\n", "assert", "po2", "[", "b", "]", "[", "1", "]", "==", "q", ".", "max", "(", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "b", ")", ":", "\n", "      ", "q", "=", "quantized_po2", "(", "b", ",", "2", "**", "i", ")", "\n", "assert", "po2_max_value", "[", "(", "b", ",", "2", "**", "i", ")", "]", "[", "0", "]", "==", "q", ".", "min", "(", ")", "\n", "assert", "po2_max_value", "[", "(", "b", ",", "2", "**", "i", ")", "]", "[", "1", "]", "==", "q", ".", "max", "(", ")", "\n", "\n", "", "", "for", "b", "in", "range", "(", "4", ",", "7", ")", ":", "\n", "    ", "q", "=", "quantized_po2", "(", "b", ",", "quadratic_approximation", "=", "True", ")", "\n", "assert", "po2_quadratic", "[", "b", "]", "[", "0", "]", "==", "q", ".", "min", "(", ")", "\n", "assert", "po2_quadratic", "[", "b", "]", "[", "1", "]", "==", "q", ".", "max", "(", ")", "\n", "q", "=", "quantized_relu_po2", "(", "b", ",", "quadratic_approximation", "=", "True", ")", "\n", "assert", "relu_po2_quadratic", "[", "b", "]", "[", "0", "]", "==", "q", ".", "min", "(", ")", "\n", "assert", "relu_po2_quadratic", "[", "b", "]", "[", "1", "]", "==", "q", ".", "max", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qactivation_test.disable_test_quantized_po2": [[43, 129], ["pytest.mark.parametrize", "tensorflow.keras.backend.placeholder", "tensorflow.keras.backend.function", "numpy.testing.assert_allclose", "K.function.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "qkeras.quantized_po2", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx"], "function", ["None"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'bits, max_value, use_stochastic_rounding, quadratic_approximation, '", "\n", "'log2_rounding, test_values, expected_values'", ",", "[", "\n", "# bits=4 without max_value. Therefore the max exponent is 4 when", "\n", "# quadratic approximiation is enabled. The max and min values from this", "\n", "# quantization function are 16 and -16 respectively.", "\n", "(", "\n", "4", ",", "None", ",", "0", ",", "1", ",", "\"floor\"", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "-", "10.0", ",", "-", "0.25", ",", "0.25", ",", "1.0", ",", "1.99", ",", "2.0", ",", "5.0", ",", "10.0", ",", "16.0", ",", "32.0", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "-", "4.0", ",", "-", "0.25", ",", "0.25", ",", "1.0", ",", "1.0", ",", "1.0", ",", "4.0", ",", "4.0", ",", "16.0", ",", "16.0", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "# bits=3. The minimum exponent is -4. Therefore, the smallest absolute", "\n", "# value is 0.0625 in this quantization. The max absolute value is 0.5,", "\n", "# which is specified by the second input argument.", "\n", "(", "\n", "3", ",", "0.5", ",", "0", ",", "0", ",", "\"floor\"", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "7", ",", "-", "0.12", ",", "-", "0.03", ",", "0.01", ",", "5", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "0.5", ",", "-", "0.0625", ",", "-", "0.0625", ",", "0.0625", ",", "0.5", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "8", ",", "None", ",", "0", ",", "0", ",", "\"floor\"", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "-", "3", ",", "-", "2", ",", "-", "1.5", ",", "-", "0.5", ",", "-", "0.033", ",", "0.5", ",", "0.667", ",", "1", ",", "1.5", ",", "4", ",", "10", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "-", "2", ",", "-", "2", ",", "-", "1", ",", "-", "0.5", ",", "-", "0.03125", ",", "0.5", ",", "0.5", ",", "1", ",", "1", ",", "4", ",", "8", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "4", ",", "None", ",", "0", ",", "0", ",", "\"floor\"", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "-", "16", ",", "-", "7", ",", "-", "0.12", ",", "-", "0.03", ",", "0", ",", "0.01", ",", "5", ",", "10", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "-", "8", ",", "-", "4", ",", "-", "0.0625", ",", "-", "0.0625", ",", "0.0625", ",", "0.0625", ",", "4", ",", "8", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "3", ",", "0.5", ",", "0", ",", "0", ",", "\"floor\"", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "7", ",", "-", "0.12", ",", "-", "0.03", ",", "0.01", ",", "5", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "0.5", ",", "-", "0.0625", ",", "-", "0.0625", ",", "0.0625", ",", "0.5", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "4", ",", "4", ",", "0", ",", "0", ",", "\"floor\"", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "7", ",", "-", "0.12", ",", "-", "0.03", ",", "0", ",", "0.01", ",", "5", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "4", ",", "-", "0.0625", ",", "-", "0.0625", ",", "0.0625", ",", "0.0625", ",", "4", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "4", ",", "None", ",", "0", ",", "1", ",", "\"floor\"", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "0.01", ",", "0.03", ",", "0.06", ",", "0.5", ",", "1", ",", "2", ",", "5", ",", "10", ",", "16", ",", "32", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "0.00390625", ",", "0.015625", ",", "0.015625", ",", "0.25", ",", "1", ",", "1", ",", "4", ",", "4", ",", "16", ",", "16", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "4", ",", "None", ",", "0", ",", "1", ",", "\"floor\"", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "-", "32", ",", "-", "16", ",", "-", "10", ",", "-", "5", ",", "-", "2", ",", "-", "1", ",", "-", "0.5", ",", "-", "0.03", ",", "-", "0.01", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "-", "16", ",", "-", "16", ",", "-", "4", ",", "-", "4", ",", "-", "1", ",", "-", "1", ",", "-", "0.25", ",", "-", "0.015625", ",", "-", "0.00390625", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "4", ",", "None", ",", "0", ",", "1", ",", "\"floor\"", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "-", "32", ",", "-", "16", ",", "-", "10", ",", "-", "5", ",", "-", "2", ",", "-", "1", ",", "-", "0.5", ",", "-", "0.03", ",", "-", "0.01", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "-", "16", ",", "-", "16", ",", "-", "4", ",", "-", "4", ",", "-", "1", ",", "-", "1", ",", "-", "0.25", ",", "-", "0.015625", ",", "-", "0.00390625", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "]", ")", "\n", "def", "disable_test_quantized_po2", "(", "bits", ",", "\n", "max_value", ",", "\n", "use_stochastic_rounding", ",", "\n", "quadratic_approximation", ",", "\n", "log2_rounding", ",", "\n", "test_values", ",", "\n", "expected_values", ")", ":", "\n", "  ", "\"\"\"Test quantized_po2 function.\"\"\"", "\n", "x", "=", "K", ".", "placeholder", "(", "ndim", "=", "2", ")", "\n", "f", "=", "K", ".", "function", "(", "[", "x", "]", ",", "[", "quantized_po2", "(", "\n", "bits", ",", "max_value", ",", "use_stochastic_rounding", ",", "\n", "quadratic_approximation", ",", "log2_rounding", ")", "(", "x", ")", "]", ")", "\n", "result", "=", "f", "(", "[", "test_values", "]", ")", "[", "0", "]", "\n", "assert_allclose", "(", "result", ",", "expected_values", ",", "rtol", "=", "1e-05", ",", "atol", "=", "1e-05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qactivation_test.disable_test_quantized_relu_po2": [[131, 201], ["pytest.mark.parametrize", "tensorflow.keras.backend.placeholder", "tensorflow.keras.backend.function", "numpy.testing.assert_allclose", "K.function.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "qkeras.quantized_relu_po2", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'bits, max_value, use_stochastic_rounding, quadratic_approximation, '", "+", "\n", "'log2_rounding, test_values, expected_values'", ",", "\n", "[", "\n", "# bits=3 without max_value. Therefore the max exponent is 4 when", "\n", "# quadratic approximiation is enabled. The max value from this", "\n", "# quantization function is 16. For the negative value, relu enforce it", "\n", "# to be the minimum value of this quantization function, which is 2**-4.", "\n", "(", "\n", "3", ",", "None", ",", "0", ",", "1", ",", "\"floor\"", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "-", "10.0", ",", "-", "0.25", ",", "0.25", ",", "1.0", ",", "1.99", ",", "2.01", ",", "5.0", ",", "10.0", ",", "16.0", ",", "32.0", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "0.0625", ",", "0.0625", ",", "0.25", ",", "1.0", ",", "1.0", ",", "1.0", ",", "4.0", ",", "4.0", ",", "16.0", ",", "16.0", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "# bits=3. The minimum exponent is -4. Therefore, the smallest absolute", "\n", "# value is 0.0625 in this quantization. The max absolute value is 4,", "\n", "# which is specified by the second input argument.", "\n", "(", "3", ",", "4", ",", "0", ",", "0", ",", "\"floor\"", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "7.0", ",", "-", "0.12", ",", "-", "0.03", ",", "0", ",", "0.01", ",", "5.0", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "0.0625", ",", "0.0625", ",", "0.0625", ",", "0.0625", ",", "0.0625", ",", "4.0", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", "\n", ")", ",", "\n", "(", "8", ",", "None", ",", "0", ",", "0", ",", "\"floor\"", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "0.033", ",", "0.5", ",", "0.667", ",", "1", ",", "1.5", ",", "4", ",", "10", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "0", ",", "0.5", ",", "0.5", ",", "1", ",", "1", ",", "4", ",", "8", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "3", ",", "None", ",", "0", ",", "0", ",", "\"floor\"", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "-", "16.0", ",", "-", "7.0", ",", "-", "0.12", ",", "-", "0.03", ",", "0", ",", "0.01", ",", "5.0", ",", "10.0", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "0.0625", ",", "0.0625", ",", "0.0625", ",", "0.0625", ",", "0.0625", ",", "0.0625", ",", "4.0", ",", "8.0", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "2", ",", "0.5", ",", "0", ",", "0", ",", "\"floor\"", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "7.0", ",", "-", "0.12", ",", "-", "0.03", ",", "0.01", ",", "5.0", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "0.0625", ",", "0.0625", ",", "0.0625", ",", "0.0625", ",", "0.5", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "3", ",", "4", ",", "0", ",", "0", ",", "\"floor\"", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "-", "7.0", ",", "-", "0.12", ",", "-", "0.03", ",", "0", ",", "0.01", ",", "5.0", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "0.0625", ",", "0.0625", ",", "0.0625", ",", "0.0625", ",", "0.0625", ",", "4.0", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "3", ",", "None", ",", "0", ",", "1", ",", "\"floor\"", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "0.01", ",", "0.03", ",", "0.06", ",", "0.5", ",", "1", ",", "2", ",", "5", ",", "10", ",", "16", ",", "32", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "0.00390625", ",", "0.015625", ",", "0.015625", ",", "0.25", ",", "1", ",", "1", ",", "4", ",", "4", ",", "16", ",", "16", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "]", ")", "\n", "def", "disable_test_quantized_relu_po2", "(", "bits", ",", "max_value", ",", "use_stochastic_rounding", ",", "\n", "quadratic_approximation", ",", "log2_rounding", ",", "\n", "test_values", ",", "expected_values", ")", ":", "\n", "  ", "\"\"\"Test quantized_po2 function.\"\"\"", "\n", "x", "=", "K", ".", "placeholder", "(", "ndim", "=", "2", ")", "\n", "f", "=", "K", ".", "function", "(", "[", "x", "]", ",", "\n", "[", "quantized_relu_po2", "(", "bits", ",", "max_value", ",", "0", ",", "\n", "use_stochastic_rounding", ",", "\n", "quadratic_approximation", ",", "\n", "log2_rounding", ")", "(", "x", ")", "]", ")", "\n", "result", "=", "f", "(", "[", "test_values", "]", ")", "[", "0", "]", "\n", "assert_allclose", "(", "result", ",", "expected_values", ",", "rtol", "=", "1e-05", ",", "atol", "=", "1e-05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qactivation_test.test_smooth_sigmoid": [[203, 220], ["numpy.array", "numpy.vectorize", "tensorflow.keras.backend.placeholder", "tensorflow.keras.backend.function", "np.vectorize.", "numpy.testing.assert_allclose", "K.function.", "tensorflow.keras.backend.floatx", "qkeras.smooth_sigmoid"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.smooth_sigmoid"], ["", "def", "test_smooth_sigmoid", "(", ")", ":", "\n", "  ", "\"\"\"Test smooth_sigmoid function.\"\"\"", "\n", "test_values", "=", "np", ".", "array", "(", "\n", "[", "[", "-", "3.0", ",", "-", "2.0", ",", "-", "1.0", ",", "-", "0.5", ",", "0.005", ",", "0.0", ",", "0.005", ",", "0.5", ",", "1", ",", "4", ",", "10", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", "\n", "\n", "def", "ref_smooth_sigmoid", "(", "y", ")", ":", "\n", "    ", "x", "=", "0.1875", "*", "y", "+", "0.5", "\n", "z", "=", "0.0", "if", "x", "<=", "0.0", "else", "(", "1.0", "if", "x", ">=", "1.0", "else", "x", ")", "\n", "return", "z", "\n", "\n", "", "sigmoid", "=", "np", ".", "vectorize", "(", "ref_smooth_sigmoid", ")", "\n", "x", "=", "K", ".", "placeholder", "(", "ndim", "=", "2", ")", "\n", "f", "=", "K", ".", "function", "(", "[", "x", "]", ",", "[", "smooth_sigmoid", "(", "x", ")", "]", ")", "\n", "result", "=", "f", "(", "[", "test_values", "]", ")", "[", "0", "]", "\n", "expected", "=", "sigmoid", "(", "test_values", ")", "\n", "assert_allclose", "(", "result", ",", "expected", ",", "rtol", "=", "1e-05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qactivation_test.test_hard_sigmoid": [[222, 240], ["numpy.array", "numpy.vectorize", "tensorflow.keras.backend.placeholder", "tensorflow.keras.backend.function", "np.vectorize.", "numpy.testing.assert_allclose", "K.function.", "tensorflow.keras.backend.floatx", "qkeras.hard_sigmoid"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.hard_sigmoid"], ["", "def", "test_hard_sigmoid", "(", ")", ":", "\n", "  ", "\"\"\"Test hard_sigmoid function.\"\"\"", "\n", "test_values", "=", "np", ".", "array", "(", "\n", "[", "[", "-", "3.0", ",", "-", "2.0", ",", "-", "1.0", ",", "-", "0.5", ",", "0.005", ",", "0.0", ",", "0.005", ",", "0.5", ",", "1", ",", "4", ",", "10", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", "\n", "\n", "def", "ref_hard_sigmoid", "(", "y", ")", ":", "\n", "    ", "x", "=", "0.5", "*", "y", "+", "0.5", "\n", "z", "=", "0.0", "if", "x", "<=", "0.0", "else", "(", "1.0", "if", "x", ">=", "1.0", "else", "x", ")", "\n", "return", "z", "\n", "\n", "", "sigmoid", "=", "np", ".", "vectorize", "(", "ref_hard_sigmoid", ")", "\n", "\n", "x", "=", "K", ".", "placeholder", "(", "ndim", "=", "2", ")", "\n", "f", "=", "K", ".", "function", "(", "[", "x", "]", ",", "[", "hard_sigmoid", "(", "x", ")", "]", ")", "\n", "result", "=", "f", "(", "[", "test_values", "]", ")", "[", "0", "]", "\n", "expected", "=", "sigmoid", "(", "test_values", ")", "\n", "assert_allclose", "(", "result", ",", "expected", ",", "rtol", "=", "1e-05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qactivation_test.test_quantized_sigmoid": [[242, 285], ["pytest.mark.parametrize", "qkeras.set_internal_sigmoid", "tensorflow.keras.backend.placeholder", "tensorflow.keras.backend.function", "qkeras.set_internal_sigmoid", "numpy.testing.assert_allclose", "K.function.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "qkeras.quantized_sigmoid", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.set_internal_sigmoid", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.set_internal_sigmoid"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'bits, sigmoid_type, use_real_sigmoid, test_values, expected_values'", ",", "[", "\n", "(", "\n", "6", ",", "\n", "\"hard\"", ",", "\n", "False", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "-", "1.", ",", "-", "0.75", ",", "-", "0.5", ",", "-", "0.25", ",", "0.", ",", "0.25", ",", "0.5", ",", "0.75", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "0.015625", ",", "0.125", ",", "0.25", ",", "0.375", ",", "0.5", ",", "0.625", ",", "0.75", ",", "0.875", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "\n", "6", ",", "\n", "\"smooth\"", ",", "\n", "False", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "-", "1.", ",", "-", "0.75", ",", "-", "0.5", ",", "-", "0.25", ",", "0.", ",", "0.25", ",", "0.5", ",", "0.75", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "0.3125", ",", "0.359375", ",", "0.40625", ",", "0.453125", ",", "0.5", ",", "0.546875", ",", "0.59375", ",", "0.640625", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "\n", "6", ",", "\n", "\"real\"", ",", "\n", "True", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "-", "1.", ",", "-", "0.75", ",", "-", "0.5", ",", "-", "0.25", ",", "0.", ",", "0.25", ",", "0.5", ",", "0.75", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "0.265625", ",", "0.328125", ",", "0.375", ",", "0.4375", ",", "0.5", ",", "0.5625", ",", "0.625", ",", "0.671875", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "]", ")", "\n", "def", "test_quantized_sigmoid", "(", "bits", ",", "sigmoid_type", ",", "use_real_sigmoid", ",", "test_values", ",", "expected_values", ")", ":", "\n", "  ", "\"\"\"Test quantized_sigmoid function with three different sigmoid variants.\"\"\"", "\n", "\n", "set_internal_sigmoid", "(", "sigmoid_type", ")", "\n", "x", "=", "K", ".", "placeholder", "(", "ndim", "=", "2", ")", "\n", "f", "=", "K", ".", "function", "(", "[", "x", "]", ",", "[", "quantized_sigmoid", "(", "bits", ",", "symmetric", "=", "True", ",", "use_real_sigmoid", "=", "use_real_sigmoid", ")", "(", "x", ")", "]", ")", "\n", "set_internal_sigmoid", "(", "_default_sigmoid_type", ")", "\n", "\n", "result", "=", "f", "(", "[", "test_values", "]", ")", "[", "0", "]", "\n", "assert_allclose", "(", "result", ",", "expected_values", ",", "rtol", "=", "1e-05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qactivation_test.test_quantized_sigmoid_limits": [[287, 336], ["pytest.mark.parametrize", "qkeras.set_internal_sigmoid", "tensorflow.keras.backend.placeholder", "tensorflow.keras.backend.function", "qkeras.set_internal_sigmoid", "numpy.array", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "K.function.", "qkeras.quantized_sigmoid().min", "qkeras.quantized_sigmoid().max", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "qkeras.quantized_sigmoid", "qkeras.quantized_sigmoid", "qkeras.quantized_sigmoid", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.set_internal_sigmoid", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.set_internal_sigmoid", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'bits, sigmoid_type, use_real_sigmoid, test_values, expected_values'", ",", "[", "\n", "(", "\n", "4", ",", "\n", "\"hard\"", ",", "\n", "False", ",", "\n", "np", ".", "array", "(", "\n", "[", "-", "15", ",", "15", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "0.0625", ",", "0.9375", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "\n", "4", ",", "\n", "\"smooth\"", ",", "\n", "False", ",", "\n", "np", ".", "array", "(", "\n", "[", "-", "15", ",", "15", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "0.0625", ",", "0.9375", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "\n", "4", ",", "\n", "\"real\"", ",", "\n", "True", ",", "\n", "np", ".", "array", "(", "\n", "[", "-", "15", ",", "15", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "0.0625", ",", "0.9375", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "]", ")", "\n", "\n", "def", "test_quantized_sigmoid_limits", "(", "bits", ",", "sigmoid_type", ",", "use_real_sigmoid", ",", "test_values", ",", "expected_values", ")", ":", "\n", "  ", "\"\"\"Test the min and max values of quantized_sigmoid function with three different sigmoid variants.\"\"\"", "\n", "\n", "set_internal_sigmoid", "(", "sigmoid_type", ")", "\n", "x", "=", "K", ".", "placeholder", "(", "ndim", "=", "2", ")", "\n", "f", "=", "K", ".", "function", "(", "[", "x", "]", ",", "[", "quantized_sigmoid", "(", "bits", ",", "symmetric", "=", "True", ",", "use_real_sigmoid", "=", "use_real_sigmoid", ")", "(", "x", ")", "]", ")", "\n", "set_internal_sigmoid", "(", "_default_sigmoid_type", ")", "\n", "\n", "result", "=", "f", "(", "[", "test_values", "]", ")", "[", "0", "]", "\n", "min_max", "=", "np", ".", "array", "(", "\n", "[", "quantized_sigmoid", "(", "bits", ",", "symmetric", "=", "True", ",", "use_real_sigmoid", "=", "use_real_sigmoid", ")", ".", "min", "(", ")", ",", "\n", "quantized_sigmoid", "(", "bits", ",", "symmetric", "=", "True", ",", "use_real_sigmoid", "=", "use_real_sigmoid", ")", ".", "max", "(", ")", "]", ")", "\n", "\n", "assert_allclose", "(", "result", ",", "expected_values", ",", "rtol", "=", "1e-05", ")", "\n", "assert_allclose", "(", "result", ",", "min_max", ",", "rtol", "=", "1e-05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qactivation_test.test_quantized_tanh": [[338, 370], ["pytest.mark.parametrize", "qkeras.set_internal_sigmoid", "tensorflow.keras.backend.placeholder", "tensorflow.keras.backend.function", "qkeras.set_internal_sigmoid", "numpy.testing.assert_allclose", "K.function.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "qkeras.quantized_tanh", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.set_internal_sigmoid", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.set_internal_sigmoid"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'bits, use_real_tanh, test_values, expected_values'", ",", "[", "\n", "(", "\n", "4", ",", "\n", "False", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "-", "1.", ",", "-", "0.75", ",", "-", "0.5", ",", "-", "0.25", ",", "0.", ",", "0.25", ",", "0.5", ",", "0.75", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "0.875", ",", "-", "0.75", ",", "-", "0.5", ",", "-", "0.25", ",", "0.", ",", "0.25", ",", "0.5", ",", "0.75", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "\n", "4", ",", "\n", "True", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "-", "1.", ",", "-", "0.75", ",", "-", "0.5", ",", "-", "0.25", ",", "0.", ",", "0.25", ",", "0.5", ",", "0.75", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "0.75", ",", "-", "0.625", ",", "-", "0.5", ",", "-", "0.25", ",", "0.", ",", "0.25", ",", "0.5", ",", "0.625", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", "\n", "]", ")", "\n", "def", "test_quantized_tanh", "(", "bits", ",", "use_real_tanh", ",", "test_values", ",", "expected_values", ")", ":", "\n", "  ", "\"\"\"Test quantized_tanh function with three different sigmoid variants.\"\"\"", "\n", "# store previous sigmoid type", "\n", "\n", "set_internal_sigmoid", "(", "'hard'", ")", "\n", "x", "=", "K", ".", "placeholder", "(", "ndim", "=", "2", ")", "\n", "f", "=", "K", ".", "function", "(", "[", "x", "]", ",", "[", "quantized_tanh", "(", "bits", ",", "symmetric", "=", "True", ",", "use_real_tanh", "=", "use_real_tanh", ")", "(", "x", ")", "]", ")", "\n", "set_internal_sigmoid", "(", "_default_sigmoid_type", ")", "\n", "\n", "result", "=", "f", "(", "[", "test_values", "]", ")", "[", "0", "]", "\n", "assert_allclose", "(", "result", ",", "expected_values", ",", "rtol", "=", "1e-05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qactivation_test.test_quantized_tanh_limits": [[372, 420], ["pytest.mark.parametrize", "qkeras.set_internal_sigmoid", "tensorflow.keras.backend.placeholder", "tensorflow.keras.backend.function", "qkeras.set_internal_sigmoid", "numpy.array", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "K.function.", "qkeras.quantized_tanh().min", "qkeras.quantized_tanh().max", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "qkeras.quantized_tanh", "qkeras.quantized_tanh", "qkeras.quantized_tanh", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.set_internal_sigmoid", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.set_internal_sigmoid", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'bits, sigmoid_type, use_real_tanh, test_values, expected_values'", ",", "[", "\n", "(", "\n", "4", ",", "\n", "\"hard\"", ",", "\n", "False", ",", "\n", "np", ".", "array", "(", "\n", "[", "-", "15", ",", "15", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "-", "0.875", ",", "0.875", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "\n", "4", ",", "\n", "\"smooth\"", ",", "\n", "False", ",", "\n", "np", ".", "array", "(", "\n", "[", "-", "15", ",", "15", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "-", "0.875", ",", "0.875", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "\n", "4", ",", "\n", "\"real\"", ",", "\n", "True", ",", "\n", "np", ".", "array", "(", "\n", "[", "-", "15", ",", "15", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "-", "0.875", ",", "0.875", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "]", ")", "\n", "def", "test_quantized_tanh_limits", "(", "bits", ",", "sigmoid_type", ",", "use_real_tanh", ",", "test_values", ",", "expected_values", ")", ":", "\n", "  ", "\"\"\"Test the min and max values of quantized_tanh function with three different sigmoid variants.\"\"\"", "\n", "\n", "set_internal_sigmoid", "(", "sigmoid_type", ")", "\n", "x", "=", "K", ".", "placeholder", "(", "ndim", "=", "2", ")", "\n", "f", "=", "K", ".", "function", "(", "[", "x", "]", ",", "[", "quantized_tanh", "(", "bits", ",", "symmetric", "=", "True", ",", "use_real_tanh", "=", "use_real_tanh", ")", "(", "x", ")", "]", ")", "\n", "set_internal_sigmoid", "(", "_default_sigmoid_type", ")", "\n", "\n", "result", "=", "f", "(", "[", "test_values", "]", ")", "[", "0", "]", "\n", "min_max", "=", "np", ".", "array", "(", "\n", "[", "quantized_tanh", "(", "bits", ",", "symmetric", "=", "True", ",", "use_real_tanh", "=", "use_real_tanh", ")", ".", "min", "(", ")", ",", "\n", "quantized_tanh", "(", "bits", ",", "symmetric", "=", "True", ",", "use_real_tanh", "=", "use_real_tanh", ")", ".", "max", "(", ")", "]", ")", "\n", "\n", "assert_allclose", "(", "result", ",", "expected_values", ",", "rtol", "=", "1e-05", ")", "\n", "assert_allclose", "(", "result", ",", "min_max", ",", "rtol", "=", "1e-05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qactivation_test.test_quantized_relu": [[422, 460], ["pytest.mark.parametrize", "tensorflow.keras.backend.placeholder", "tensorflow.keras.backend.function", "numpy.testing.assert_allclose", "K.function.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "qkeras.quantized_relu", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'bits, integer, use_sigmoid, test_values, expected_values'", ",", "[", "\n", "(", "\n", "6", ",", "\n", "2", ",", "\n", "0", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "-", "3.0", ",", "0.0", ",", "2.5625", ",", "3.3671875", ",", "1.5625", ",", "1.046875", ",", "0.054688", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "0.0", ",", "0.0", ",", "2.5625", ",", "3.375", ",", "1.5625", ",", "1.0625", ",", "0.0625", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "6", ",", "2", ",", "1", ",", "\n", "np", ".", "array", "(", "[", "[", "\n", "0.458069", ",", "0.573227", ",", "0.194336", ",", "1.539047", ",", "0.045883", ",", "4.009995", ",", "\n", "3.962494", ",", "3.937500", ",", "0.363266", ",", "0.875198", ",", "0.710938", ",", "4.000000", ",", "\n", "7.000000", ",", "3.937500", ",", "3.937592", ",", "0.199326", ",", "0.458008", ",", "0.625977", ",", "\n", "0.544922", ",", "1.046875", ",", "0.586899", ",", "3.367188", ",", "3.804688", ",", "0.312500", ",", "\n", "0.062500", ",", "0.562500", ",", "0.375000", ",", "3.367188", ",", "1.046875", ",", "2.796875", ",", "\n", "0.054688", ",", "1.562500", ",", "2.562500", "\n", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "\n", "0.500000", ",", "0.625000", ",", "0.250000", ",", "1.500000", ",", "0.000000", ",", "3.937500", ",", "\n", "3.937500", ",", "3.937500", ",", "0.375000", ",", "0.875000", ",", "0.750000", ",", "3.937500", ",", "\n", "3.937500", ",", "3.937500", ",", "3.937500", ",", "0.250000", ",", "0.500000", ",", "0.625000", ",", "\n", "0.500000", ",", "1.000000", ",", "0.625000", ",", "3.375000", ",", "3.750000", ",", "0.250000", ",", "\n", "0.000000", ",", "0.500000", ",", "0.375000", ",", "3.375000", ",", "1.000000", ",", "2.750000", ",", "\n", "0.000000", ",", "1.500000", ",", "2.500000", "\n", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ")", ",", "\n", "]", ")", "\n", "def", "test_quantized_relu", "(", "bits", ",", "integer", ",", "use_sigmoid", ",", "test_values", ",", "expected_values", ")", ":", "\n", "  ", "\"\"\"Test quantized_relu function.\"\"\"", "\n", "x", "=", "K", ".", "placeholder", "(", "ndim", "=", "2", ")", "\n", "f", "=", "K", ".", "function", "(", "[", "x", "]", ",", "[", "quantized_relu", "(", "bits", ",", "integer", ",", "use_sigmoid", ")", "(", "x", ")", "]", ")", "\n", "result", "=", "f", "(", "[", "test_values", "]", ")", "[", "0", "]", "\n", "assert_allclose", "(", "result", ",", "expected_values", ",", "rtol", "=", "1e-05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qactivation_test.test_quantized_bits": [[462, 502], ["pytest.mark.parametrize", "tensorflow.keras.backend.placeholder", "tensorflow.keras.backend.function", "numpy.testing.assert_allclose", "K.function.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "qkeras.quantized_bits", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'bits, integer, symmetric, keep_negative, test_values, expected_values'", ",", "[", "\n", "(", "\n", "6", ",", "\n", "2", ",", "\n", "0", ",", "\n", "True", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "3.0", ",", "-", "2.0", ",", "-", "1.0", ",", "-", "0.5", ",", "0.0", ",", "0.5", ",", "1", ",", "4", ",", "10", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "3.0", ",", "-", "2.0", ",", "-", "1.0", ",", "-", "0.5", ",", "0.0", ",", "0.5", ",", "1", ",", "3.875", ",", "3.875", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "\n", "6", ",", "\n", "2", ",", "\n", "0", ",", "\n", "False", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "3.0", ",", "-", "2.0", ",", "-", "1.0", ",", "-", "0.5", ",", "0.0", ",", "0.5", ",", "1", ",", "4", ",", "10", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", ",", "0.0", ",", "0.0", ",", "0.5", ",", "1", ",", "3.9375", ",", "3.9375", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "\n", "6", ",", "\n", "2", ",", "\n", "1", ",", "\n", "True", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "10", ",", "-", "4", ",", "-", "1.0", ",", "-", "0.5", ",", "0.0", ",", "0.5", ",", "1", ",", "4", ",", "10", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "3.875", ",", "-", "3.875", ",", "-", "1.0", ",", "-", "0.5", ",", "0.0", ",", "0.5", ",", "1", ",", "3.875", ",", "3.875", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", "\n", "]", ")", "\n", "def", "test_quantized_bits", "(", "bits", ",", "integer", ",", "symmetric", ",", "keep_negative", ",", "test_values", ",", "\n", "expected_values", ")", ":", "\n", "  ", "x", "=", "K", ".", "placeholder", "(", "ndim", "=", "2", ")", "\n", "f", "=", "K", ".", "function", "(", "[", "x", "]", ",", "\n", "[", "quantized_bits", "(", "bits", ",", "integer", ",", "symmetric", ",", "keep_negative", ")", "(", "x", ")", "]", ")", "\n", "result", "=", "f", "(", "[", "test_values", "]", ")", "[", "0", "]", "\n", "assert_allclose", "(", "result", ",", "expected_values", ",", "rtol", "=", "1e-05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qactivation_test.test_ternary": [[504, 519], ["pytest.mark.parametrize", "tensorflow.keras.backend.placeholder", "tensorflow.keras.backend.function", "numpy.testing.assert_allclose", "K.function.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "qkeras.ternary", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'alpha, threshold, test_values, expected_values'", ",", "[", "\n", "(", "1.0", ",", "0.33", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "3.0", ",", "-", "2.0", ",", "-", "1.0", ",", "-", "0.2", ",", "0.0", ",", "0.3", ",", "1", ",", "4", ",", "10", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "1.0", ",", "-", "1.0", ",", "-", "1.0", ",", "0", ",", "0.0", ",", "0.0", ",", "1", ",", "1", ",", "1", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ")", ",", "\n", "(", "10.0", ",", "5.0", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "11.0", ",", "-", "7.0", ",", "-", "4.0", ",", "-", "0.2", ",", "0.0", ",", "0.3", ",", "1", ",", "4", ",", "10", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "10.0", ",", "-", "10.0", ",", "0.0", ",", "0", ",", "0.0", ",", "0.0", ",", "0", ",", "0", ",", "10", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ")", ",", "\n", "]", ")", "\n", "def", "test_ternary", "(", "alpha", ",", "threshold", ",", "test_values", ",", "expected_values", ")", ":", "\n", "  ", "x", "=", "K", ".", "placeholder", "(", "ndim", "=", "2", ")", "\n", "f", "=", "K", ".", "function", "(", "[", "x", "]", ",", "\n", "[", "ternary", "(", "alpha", ",", "threshold", ")", "(", "x", ")", "]", ")", "\n", "result", "=", "f", "(", "[", "test_values", "]", ")", "[", "0", "]", "\n", "assert_allclose", "(", "result", ",", "expected_values", ",", "rtol", "=", "1e-05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qactivation_test.test_binary": [[521, 539], ["pytest.mark.parametrize", "tensorflow.keras.backend.placeholder", "tensorflow.keras.backend.function", "numpy.testing.assert_allclose", "K.function.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "qkeras.binary", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'use_01, alpha, test_values, expected_values'", ",", "[", "\n", "(", "False", ",", "1.0", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "3.0", ",", "-", "2.0", ",", "-", "1.0", ",", "-", "0.2", ",", "0.0", ",", "0.3", ",", "1", ",", "4", ",", "10", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "1.0", ",", "-", "1.0", ",", "-", "1.0", ",", "-", "1.0", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ")", ",", "\n", "(", "False", ",", "5.0", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "11.0", ",", "-", "7.0", ",", "-", "4.0", ",", "-", "0.2", ",", "0.0", ",", "0.3", ",", "1", ",", "4", ",", "10", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "5.0", ",", "-", "5.0", ",", "-", "5.0", ",", "-", "5", ",", "5.0", ",", "5.0", ",", "5", ",", "5", ",", "5", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ")", ",", "\n", "(", "True", ",", "5.0", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "11.0", ",", "-", "7.0", ",", "-", "4.0", ",", "-", "0.2", ",", "0.0", ",", "0.3", ",", "1", ",", "4", ",", "10", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "0", ",", "0", ",", "5", ",", "5", ",", "5", ",", "5", ",", "5", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ")", ",", "\n", "]", ")", "\n", "def", "test_binary", "(", "use_01", ",", "alpha", ",", "test_values", ",", "expected_values", ")", ":", "\n", "  ", "x", "=", "K", ".", "placeholder", "(", "ndim", "=", "2", ")", "\n", "f", "=", "K", ".", "function", "(", "[", "x", "]", ",", "[", "binary", "(", "use_01", ",", "alpha", ")", "(", "x", ")", "]", ")", "\n", "result", "=", "f", "(", "[", "test_values", "]", ")", "[", "0", "]", "\n", "assert_allclose", "(", "result", ",", "expected_values", ",", "rtol", "=", "1e-05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qactivation_test.test_stochastic_round_quantized_po2": [[541, 560], ["pytest.mark.parametrize", "tensorflow.keras.backend.set_learning_phase", "numpy.random.seed", "tensorflow.keras.backend.placeholder", "qkeras.quantized_po2", "tensorflow.keras.backend.function", "numpy.average", "numpy.testing.assert_allclose", "K.function.", "qkeras.quantized_po2.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'test_values, expected_values'", ",", "[", "\n", "(", "np", ".", "array", "(", "[", "[", "42.0", "]", "*", "100000", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "42.0", ")", ",", "\n", "(", "np", ".", "array", "(", "[", "[", "100.0", "]", "*", "100000", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "100.0", ")", ",", "\n", "(", "np", ".", "array", "(", "[", "[", "48.0", "]", "*", "100000", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "48.0", ")", ",", "\n", "(", "np", ".", "array", "(", "[", "[", "-", "141.0", "]", "*", "100000", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "-", "141.0", ")", ",", "\n", "(", "np", ".", "array", "(", "[", "[", "-", "32.0", "]", "*", "100000", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "-", "32.0", ")", ",", "\n", "(", "np", ".", "array", "(", "[", "[", "32.0", "]", "*", "100000", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "32.0", ")", ",", "\n", "(", "np", ".", "array", "(", "[", "[", "10031.0", "]", "*", "100000", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "10031.0", ")", ",", "\n", "(", "np", ".", "array", "(", "[", "[", "0.0", "]", "*", "100000", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "0.0", ")", ",", "\n", "]", ")", "\n", "def", "test_stochastic_round_quantized_po2", "(", "test_values", ",", "expected_values", ")", ":", "\n", "  ", "K", ".", "set_learning_phase", "(", "1", ")", "\n", "np", ".", "random", ".", "seed", "(", "666", ")", "\n", "x", "=", "K", ".", "placeholder", "(", "ndim", "=", "2", ")", "\n", "q", "=", "quantized_po2", "(", "use_stochastic_rounding", "=", "True", ")", "\n", "f", "=", "K", ".", "function", "(", "[", "x", "]", ",", "[", "q", "(", "x", ")", "]", ")", "\n", "res", "=", "f", "(", "[", "test_values", "]", ")", "[", "0", "]", "\n", "res", "=", "np", ".", "average", "(", "res", ")", "\n", "assert_allclose", "(", "res", ",", "expected_values", ",", "rtol", "=", "1e-01", ",", "atol", "=", "1e-6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qactivation_test.test_stochastic_round_quantized_relu_po2": [[562, 578], ["pytest.mark.parametrize", "tensorflow.keras.backend.set_learning_phase", "numpy.random.seed", "tensorflow.keras.backend.placeholder", "qkeras.quantized_relu_po2", "tensorflow.keras.backend.function", "numpy.average", "numpy.testing.assert_allclose", "K.function.", "qkeras.quantized_relu_po2.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'test_values, expected_values'", ",", "[", "\n", "(", "np", ".", "array", "(", "[", "[", "42.0", "]", "*", "100000", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "42.0", ")", ",", "\n", "(", "np", ".", "array", "(", "[", "[", "-", "42.0", "]", "*", "100000", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "0.0", ")", ",", "\n", "(", "np", ".", "array", "(", "[", "[", "0.0", "]", "*", "100000", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "0.0", ")", ",", "\n", "(", "np", ".", "array", "(", "[", "[", "100.0", "]", "*", "100000", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "100.0", ")", ",", "\n", "(", "np", ".", "array", "(", "[", "[", "48.0", "]", "*", "100000", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "48.0", ")", ",", "\n", "]", ")", "\n", "def", "test_stochastic_round_quantized_relu_po2", "(", "test_values", ",", "expected_values", ")", ":", "\n", "  ", "K", ".", "set_learning_phase", "(", "1", ")", "\n", "np", ".", "random", ".", "seed", "(", "666", ")", "\n", "x", "=", "K", ".", "placeholder", "(", "ndim", "=", "2", ")", "\n", "q", "=", "quantized_relu_po2", "(", "use_stochastic_rounding", "=", "True", ")", "\n", "f", "=", "K", ".", "function", "(", "[", "x", "]", ",", "[", "q", "(", "x", ")", "]", ")", "\n", "res", "=", "f", "(", "[", "test_values", "]", ")", "[", "0", "]", "\n", "res", "=", "np", ".", "average", "(", "res", ")", "\n", "assert_allclose", "(", "res", ",", "expected_values", ",", "rtol", "=", "1e-01", ",", "atol", "=", "1e-6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qactivation_test.test_stochastic_binary": [[580, 616], ["numpy.random.seed", "tensorflow.keras.backend.set_learning_phase", "numpy.random.uniform", "numpy.sort", "numpy.expand_dims", "qkeras.stochastic_binary", "numpy.zeros_like", "range", "numpy.squeeze", "numpy.array", "numpy.squeeze", "numpy.array().astype", "numpy.array", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "tensorflow.keras.backend.eval", "qkeras.stochastic_binary.", "tensorflow.keras.backend.eval", "numpy.array", "tensorflow.keras.backend.constant"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "test_stochastic_binary", "(", ")", ":", "\n", "  ", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "K", ".", "set_learning_phase", "(", "1", ")", "\n", "\n", "x", "=", "np", ".", "random", ".", "uniform", "(", "-", "0.01", ",", "0.01", ",", "size", "=", "10", ")", "\n", "x", "=", "np", ".", "sort", "(", "x", ")", "\n", "# Adding a dimension to have a common channel axis for quantization. This is", "\n", "# to cope with a bug fix in \"_get_scale\" without changing the test cases.", "\n", "x", "=", "np", ".", "expand_dims", "(", "x", ",", "axis", "=", "1", ")", "\n", "\n", "s", "=", "stochastic_binary", "(", "alpha", "=", "\"auto_po2\"", ")", "\n", "\n", "ty", "=", "np", ".", "zeros_like", "(", "s", ")", "\n", "ts", "=", "0.0", "\n", "\n", "n", "=", "1000", "\n", "\n", "for", "_", "in", "range", "(", "n", ")", ":", "\n", "    ", "y", "=", "K", ".", "eval", "(", "s", "(", "K", ".", "constant", "(", "x", ")", ")", ")", "\n", "scale", "=", "K", ".", "eval", "(", "s", ".", "scale", ")", "[", "0", "]", "\n", "ts", "=", "ts", "+", "scale", "\n", "ty", "=", "ty", "+", "(", "y", "/", "scale", ")", "\n", "\n", "# Perform squeezing to remove the common channel axis.", "\n", "", "result", "=", "(", "ty", "/", "n", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "result", "=", "np", ".", "squeeze", "(", "result", ")", "\n", "scale", "=", "np", ".", "array", "(", "[", "ts", "/", "n", "]", ")", "\n", "scale", "=", "np", ".", "squeeze", "(", "scale", ")", "\n", "\n", "expected", "=", "np", ".", "array", "(", "\n", "[", "-", "1.", ",", "-", "1.", ",", "-", "1.", ",", "-", "0.852", ",", "0.782", ",", "0.768", ",", "0.97", ",", "0.978", ",", "1.0", ",", "1.0", "]", "\n", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "expected_scale", "=", "np", ".", "array", "(", "[", "0.003906", "]", ")", "\n", "\n", "assert_allclose", "(", "result", ",", "expected", ",", "atol", "=", "0.1", ")", "\n", "assert_allclose", "(", "scale", ",", "expected_scale", ",", "rtol", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qactivation_test.test_stochastic_binary_inference_mode": [[618, 634], ["pytest.mark.parametrize", "tensorflow.keras.backend.set_learning_phase", "tensorflow.keras.backend.placeholder", "qkeras.stochastic_binary", "tensorflow.keras.backend.function", "numpy.testing.assert_allclose", "K.function.", "qkeras.stochastic_binary.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'alpha, test_values, expected_values'", ",", "[", "\n", "(", "1.0", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "3.0", ",", "-", "2.0", ",", "-", "1.0", ",", "-", "0.2", ",", "0.0", ",", "0.3", ",", "1", ",", "4", ",", "10", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "1.0", ",", "-", "1.0", ",", "-", "1.0", ",", "-", "1.0", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ")", ",", "\n", "(", "5.0", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "11.0", ",", "-", "7.0", ",", "-", "4.0", ",", "-", "0.2", ",", "0.0", ",", "0.3", ",", "1", ",", "4", ",", "10", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "5.0", ",", "-", "5.0", ",", "-", "5.0", ",", "-", "5", ",", "5.0", ",", "5.0", ",", "5", ",", "5", ",", "5", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ")", "\n", "]", ")", "\n", "def", "test_stochastic_binary_inference_mode", "(", "alpha", ",", "test_values", ",", "expected_values", ")", ":", "\n", "  ", "K", ".", "set_learning_phase", "(", "0", ")", "\n", "x", "=", "K", ".", "placeholder", "(", "ndim", "=", "2", ")", "\n", "q", "=", "stochastic_binary", "(", "alpha", ")", "\n", "f", "=", "K", ".", "function", "(", "[", "x", "]", ",", "[", "q", "(", "x", ")", "]", ")", "\n", "result", "=", "f", "(", "[", "test_values", "]", ")", "[", "0", "]", "\n", "assert_allclose", "(", "result", ",", "expected_values", ",", "rtol", "=", "1e-05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qactivation_test.test_stochastic_ternary": [[636, 679], ["pytest.mark.parametrize", "numpy.random.seed", "tensorflow.keras.backend.set_learning_phase", "numpy.random.uniform", "numpy.sort", "qkeras.stochastic_ternary", "tensorflow.keras.backend.eval", "numpy.zeros_like", "range", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "qkeras.stochastic_ternary.", "tensorflow.keras.backend.eval().astype", "tensorflow.keras.backend.constant", "numpy.array().astype", "numpy.array().astype", "numpy.array().astype", "numpy.array().astype", "tensorflow.keras.backend.eval", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'bound, alpha, temperature, expected_values, expected_scale'", ",", "[", "\n", "(", "\n", "0.01", ",", "\n", "\"auto\"", ",", "\n", "8", ",", "\n", "np", ".", "array", "(", "[", "-", "0.973", ",", "-", "0.903", ",", "-", "0.759", ",", "-", "0.574", ",", "-", "0.242", ",", "0.161", ",", "0.508", ",", "0.723", ",", "\n", "0.874", ",", "0.975", "]", ")", ".", "astype", "(", "np", ".", "float32", ")", ",", "\n", "np", ".", "array", "(", "[", "0.008427", ",", "0.007001", ",", "0.0057", ",", "0.004457", ",", "0.003537", ",", "0.003416", ",", "\n", "0.004507", ",", "0.005536", ",", "0.006853", ",", "0.008282", "]", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", ")", ",", "\n", "(", "\n", "0.01", ",", "\n", "\"auto_po2\"", ",", "\n", "8", ",", "\n", "np", ".", "array", "(", "[", "-", "0.979", ",", "-", "0.877", ",", "-", "0.639", ",", "-", "0.586", ",", "-", "0.23", ",", "0.154", ",", "0.327", ",", "0.603", ",", "\n", "0.83", ",", "0.986", "]", ")", ".", "astype", "(", "np", ".", "float32", ")", ",", "\n", "np", ".", "array", "(", "[", "0.007812", ",", "0.007812", ",", "0.007812", ",", "0.003906", ",", "0.003906", ",", "0.003906", ",", "\n", "0.007812", ",", "0.007812", ",", "0.007812", ",", "0.007812", "]", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", ")", "\n", "]", ")", "\n", "def", "test_stochastic_ternary", "(", "bound", ",", "alpha", ",", "temperature", ",", "expected_values", ",", "expected_scale", ")", ":", "\n", "  ", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "K", ".", "set_learning_phase", "(", "1", ")", "\n", "\n", "n", "=", "1000", "\n", "\n", "x", "=", "np", ".", "random", ".", "uniform", "(", "-", "bound", ",", "bound", ",", "size", "=", "(", "n", ",", "10", ")", ")", "\n", "x", "=", "np", ".", "sort", "(", "x", ",", "axis", "=", "1", ")", "\n", "\n", "s", "=", "stochastic_ternary", "(", "alpha", "=", "alpha", ",", "temperature", "=", "temperature", ")", "\n", "\n", "y", "=", "K", ".", "eval", "(", "s", "(", "K", ".", "constant", "(", "x", ")", ")", ")", "\n", "scale", "=", "K", ".", "eval", "(", "s", ".", "scale", ")", ".", "astype", "(", "np", ".", "float32", ")", "[", "0", "]", "\n", "\n", "ty", "=", "np", ".", "zeros_like", "(", "s", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "    ", "ty", "=", "ty", "+", "(", "y", "[", "i", "]", "/", "scale", ")", "\n", "\n", "", "result", "=", "(", "ty", "/", "n", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "assert_allclose", "(", "result", ",", "expected_values", ",", "atol", "=", "0.1", ")", "\n", "assert_allclose", "(", "scale", ",", "expected_scale", ",", "rtol", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qactivation_test.test_stochastic_ternary_inference_mode": [[681, 698], ["pytest.mark.parametrize", "tensorflow.keras.backend.set_learning_phase", "tensorflow.keras.backend.placeholder", "qkeras.stochastic_ternary", "tensorflow.keras.backend.function", "numpy.testing.assert_allclose", "K.function.", "qkeras.stochastic_ternary.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'alpha, threshold, test_values, expected_values'", ",", "[", "\n", "(", "1.0", ",", "0.33", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "3.0", ",", "-", "2.0", ",", "-", "1.0", ",", "-", "0.2", ",", "0.0", ",", "0.3", ",", "1", ",", "4", ",", "10", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "1.0", ",", "-", "1.0", ",", "-", "1.0", ",", "0", ",", "0.0", ",", "0.0", ",", "1", ",", "1", ",", "1", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ")", ",", "\n", "(", "10.0", ",", "5.0", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "11.0", ",", "-", "7.0", ",", "-", "4.0", ",", "-", "0.2", ",", "0.0", ",", "0.3", ",", "1", ",", "4", ",", "10", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "10.0", ",", "-", "10.0", ",", "0.0", ",", "0", ",", "0.0", ",", "0.0", ",", "0", ",", "0", ",", "10", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ")", ",", "\n", "]", ")", "\n", "def", "test_stochastic_ternary_inference_mode", "(", "alpha", ",", "threshold", ",", "test_values", ",", "expected_values", ")", ":", "\n", "  ", "K", ".", "set_learning_phase", "(", "0", ")", "\n", "x", "=", "K", ".", "placeholder", "(", "ndim", "=", "2", ")", "\n", "q", "=", "stochastic_ternary", "(", "alpha", ",", "threshold", ")", "\n", "f", "=", "K", ".", "function", "(", "[", "x", "]", ",", "\n", "[", "q", "(", "x", ")", "]", ")", "\n", "result", "=", "f", "(", "[", "test_values", "]", ")", "[", "0", "]", "\n", "assert_allclose", "(", "result", ",", "expected_values", ",", "rtol", "=", "1e-05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qactivation_test.test_quantized_hswish": [[700, 735], ["pytest.mark.parametrize", "tensorflow.keras.backend.placeholder", "tensorflow.keras.backend.function", "numpy.testing.assert_allclose", "K.function.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "qkeras.quantized_hswish", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx", "tensorflow.keras.backend.floatx"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "# y = x * relu6(x+3)/6, the total world length is 6 bits with 2 integer", "\n", "# bits. The quantization is in asymmetric mode.", "\n", "(", "'bits, integer, symmetric, relu_shift, relu_upper_bound,'", "\n", "'test_values, expected_values'", ")", ",", "[", "\n", "(", "\n", "6", ",", "2", ",", "0", ",", "3", ",", "6", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "3.0", ",", "-", "2.0", ",", "-", "1.0", ",", "-", "0.5", ",", "0.0", ",", "0.5", ",", "1", ",", "4", ",", "10", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "0.", ",", "-", "0.375", ",", "-", "0.375", ",", "-", "0.25", ",", "0.", ",", "0.25", ",", "0.625", ",", "\n", "3.875", ",", "3.875", "]", "]", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "\n", "6", ",", "4", ",", "1", ",", "3", ",", "6", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "10.0", ",", "-", "2.0", ",", "-", "2.3", ",", "-", "0.25", ",", "0.0", ",", "0.5", ",", "1", ",", "4", ",", "10", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "0.", ",", "-", "0.5", ",", "-", "0.5", ",", "0.", ",", "0.", ",", "0.5", ",", "0.5", ",", "4.", ",", "10.", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "(", "\n", "2", ",", "0", ",", "0", ",", "3", ",", "6", ",", "\n", "np", ".", "array", "(", "[", "[", "-", "10.0", ",", "-", "2.0", ",", "-", "2.3", ",", "-", "0.25", ",", "0.0", ",", "0.5", ",", "1", ",", "4", ",", "10", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "0.", ",", "-", "0.5", ",", "-", "0.5", ",", "0.", ",", "0.", ",", "0.5", ",", "0.5", ",", "0.5", ",", "0.5", "]", "]", ",", "\n", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ",", "\n", ")", ",", "\n", "]", ")", "\n", "def", "test_quantized_hswish", "(", "bits", ",", "integer", ",", "symmetric", ",", "relu_shift", ",", "\n", "relu_upper_bound", ",", "test_values", ",", "expected_values", ")", ":", "\n", "  ", "x", "=", "K", ".", "placeholder", "(", "ndim", "=", "2", ")", "\n", "f", "=", "K", ".", "function", "(", "\n", "[", "x", "]", ",", "[", "quantized_hswish", "(", "bits", ",", "integer", ",", "symmetric", ",", "relu_shift", "=", "relu_shift", ",", "\n", "relu_upper_bound", "=", "relu_upper_bound", ")", "(", "x", ")", "]", ")", "\n", "result", "=", "f", "(", "[", "test_values", "]", ")", "[", "0", "]", "\n", "assert_allclose", "(", "result", ",", "expected_values", ",", "rtol", "=", "1e-05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qnoise_test.test_qnoise_quantized_bits": [[30, 67], ["qkeras.quantizers.quantized_bits", "numpy.array", "numpy.array", "numpy.array", "qkeras.quantizers.quantized_bits.update_qnoise_factor", "qkeras.quantizers.quantized_bits.", "numpy.testing.assert_equal", "qkeras.quantizers.quantized_bits.update_qnoise_factor", "qkeras.quantizers.quantized_bits.", "numpy.testing.assert_equal", "qkeras.quantizers.quantized_bits.update_qnoise_factor", "qkeras.quantizers.quantized_bits.", "numpy.testing.assert_equal"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor", "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor", "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor"], ["def", "test_qnoise_quantized_bits", "(", ")", ":", "\n", "# 1 sign bit, 1 integer bit, and 2 fractional bits.", "\n", "  ", "bits", "=", "4", "\n", "integer", "=", "1", "\n", "symmetric", "=", "True", "\n", "keep_negative", "=", "True", "\n", "alpha", "=", "1", "\n", "use_stochastic_rounding", "=", "False", "\n", "\n", "qb", "=", "quantized_bits", "(", "\n", "bits", "=", "bits", ",", "\n", "integer", "=", "integer", ",", "\n", "symmetric", "=", "symmetric", ",", "\n", "keep_negative", "=", "keep_negative", ",", "\n", "alpha", "=", "alpha", ",", "\n", "use_stochastic_rounding", "=", "use_stochastic_rounding", ",", "\n", "use_variables", "=", "True", ")", "\n", "\n", "inputs", "=", "np", ".", "array", "(", "[", "0.0", ",", "0.5", ",", "-", "0.5", ",", "0.6", ",", "-", "0.6", ",", "2.0", ",", "-", "2.0", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "x", "=", "np", ".", "array", "(", "[", "0.0", ",", "0.5", ",", "-", "0.5", ",", "0.6", ",", "-", "0.6", ",", "2.0", ",", "-", "2.0", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "xq", "=", "np", ".", "array", "(", "[", "0.0", ",", "0.5", ",", "-", "0.5", ",", "0.5", ",", "-", "0.5", ",", "1.75", ",", "-", "1.75", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "x_xq", "=", "0.5", "*", "(", "x", "+", "xq", ")", "\n", "\n", "# no quantization", "\n", "qb", ".", "update_qnoise_factor", "(", "qnoise_factor", "=", "0.0", ")", "\n", "x_q_0", "=", "qb", "(", "inputs", ")", "\n", "assert_equal", "(", "x_q_0", ",", "x", ")", "\n", "\n", "# full quantization", "\n", "qb", ".", "update_qnoise_factor", "(", "qnoise_factor", "=", "1.0", ")", "\n", "x_q_1", "=", "qb", "(", "inputs", ")", "\n", "assert_equal", "(", "x_q_1", ",", "xq", ")", "\n", "\n", "# mixing half and half of x and xq", "\n", "qb", ".", "update_qnoise_factor", "(", "qnoise_factor", "=", "0.5", ")", "\n", "x_q_05", "=", "qb", "(", "inputs", ")", "\n", "assert_equal", "(", "x_q_05", ",", "x_xq", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qnoise_test.test_qnoise_quantized_relu": [[69, 205], ["numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "qkeras.quantizers.quantized_relu", "qkeras.quantizers.quantized_relu.update_qnoise_factor", "qkeras.quantizers.quantized_relu.", "numpy.testing.assert_equal", "qkeras.quantizers.quantized_relu.update_qnoise_factor", "qkeras.quantizers.quantized_relu.", "numpy.testing.assert_equal", "qkeras.quantizers.quantized_relu.update_qnoise_factor", "qkeras.quantizers.quantized_relu.", "numpy.testing.assert_equal", "qkeras.quantizers.quantized_relu", "qkeras.quantizers.quantized_relu.update_qnoise_factor", "qkeras.quantizers.quantized_relu.", "numpy.testing.assert_equal", "qkeras.quantizers.quantized_relu.update_qnoise_factor", "qkeras.quantizers.quantized_relu.", "numpy.testing.assert_equal", "qkeras.quantizers.quantized_relu.update_qnoise_factor", "qkeras.quantizers.quantized_relu.", "numpy.testing.assert_equal", "qkeras.quantizers.quantized_relu", "qkeras.quantizers.quantized_relu.update_qnoise_factor", "qkeras.quantizers.quantized_relu.", "numpy.testing.assert_equal", "qkeras.quantizers.quantized_relu.update_qnoise_factor", "qkeras.quantizers.quantized_relu.", "numpy.testing.assert_equal", "qkeras.quantizers.quantized_relu.update_qnoise_factor", "qkeras.quantizers.quantized_relu.", "numpy.testing.assert_equal", "qkeras.quantizers.quantized_relu", "qkeras.quantizers.quantized_relu.update_qnoise_factor", "qkeras.quantizers.quantized_relu.", "numpy.testing.assert_equal", "qkeras.quantizers.quantized_relu.update_qnoise_factor", "qkeras.quantizers.quantized_relu.", "numpy.testing.assert_equal", "qkeras.quantizers.quantized_relu.update_qnoise_factor", "qkeras.quantizers.quantized_relu.", "numpy.testing.assert_equal", "numpy.clip", "numpy.clip", "numpy.clip"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor", "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor", "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor", "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor", "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor", "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor", "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor", "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor", "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor", "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor", "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor", "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor"], ["", "def", "test_qnoise_quantized_relu", "(", ")", ":", "\n", "# 0 sign bit, 1 integer bit, and 3 fractional bits.", "\n", "  ", "bits", "=", "4", "\n", "integer", "=", "1", "\n", "use_sigmoid", "=", "False", "\n", "negative_slope", "=", "0", "\n", "use_stochastic_rounding", "=", "False", "\n", "\n", "# input to quantized relu", "\n", "inputs", "=", "np", ".", "array", "(", "[", "0.0", ",", "0.5", ",", "-", "0.5", ",", "0.6", ",", "2.0", ",", "3.0", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "# float relu", "\n", "x", "=", "np", ".", "array", "(", "[", "0.0", ",", "0.5", ",", "0.0", ",", "0.6", ",", "2.0", ",", "3.0", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "# float relu with upper bound 1.5", "\n", "x_ub", "=", "np", ".", "array", "(", "[", "0.0", ",", "0.5", ",", "0.0", ",", "0.6", ",", "1.5", ",", "1.5", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "# float relu with quantized clipping", "\n", "x_clipped", "=", "np", ".", "array", "(", "[", "0.0", ",", "0.5", ",", "0.0", ",", "0.6", ",", "1.875", ",", "1.875", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "# quantized relu", "\n", "xq", "=", "np", ".", "array", "(", "[", "0.0", ",", "0.5", ",", "0.0", ",", "0.625", ",", "1.875", ",", "1.875", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "# mixing half and half", "\n", "x_xq", "=", "0.5", "*", "(", "x", "+", "xq", ")", "\n", "x_clipped_xq", "=", "0.5", "*", "(", "x_clipped", "+", "xq", ")", "\n", "x_ub_xq", "=", "0.5", "*", "(", "x_ub", "+", "xq", ")", "\n", "\n", "#########################################", "\n", "# No relu upper bound", "\n", "# No quantized clip for float relu", "\n", "#########################################", "\n", "qr_qc_false", "=", "quantized_relu", "(", "\n", "bits", "=", "bits", ",", "\n", "integer", "=", "integer", ",", "\n", "use_sigmoid", "=", "use_sigmoid", ",", "\n", "negative_slope", "=", "negative_slope", ",", "\n", "use_stochastic_rounding", "=", "use_stochastic_rounding", ",", "\n", "relu_upper_bound", "=", "None", ",", "\n", "is_quantized_clip", "=", "False", ",", "\n", "use_variables", "=", "True", ")", "\n", "# no quantization", "\n", "qr_qc_false", ".", "update_qnoise_factor", "(", "qnoise_factor", "=", "0.0", ")", "\n", "x_q_0", "=", "qr_qc_false", "(", "inputs", ")", "\n", "assert_equal", "(", "x_q_0", ",", "x", ")", "\n", "\n", "# full quantization", "\n", "qr_qc_false", ".", "update_qnoise_factor", "(", "qnoise_factor", "=", "1.0", ")", "\n", "x_q_1", "=", "qr_qc_false", "(", "inputs", ")", "\n", "assert_equal", "(", "x_q_1", ",", "xq", ")", "\n", "\n", "# mixing half and half", "\n", "qr_qc_false", ".", "update_qnoise_factor", "(", "qnoise_factor", "=", "0.5", ")", "\n", "x_q_05", "=", "qr_qc_false", "(", "inputs", ")", "\n", "assert_equal", "(", "x_q_05", ",", "x_xq", ")", "\n", "\n", "#########################################", "\n", "# No relu upper bound", "\n", "# Quantized clip for float relu", "\n", "#########################################", "\n", "qr_qc_true", "=", "quantized_relu", "(", "\n", "bits", "=", "bits", ",", "\n", "integer", "=", "integer", ",", "\n", "use_sigmoid", "=", "use_sigmoid", ",", "\n", "negative_slope", "=", "negative_slope", ",", "\n", "use_stochastic_rounding", "=", "use_stochastic_rounding", ",", "\n", "relu_upper_bound", "=", "None", ",", "\n", "is_quantized_clip", "=", "True", ",", "\n", "use_variables", "=", "True", ")", "\n", "# no quantization", "\n", "qr_qc_true", ".", "update_qnoise_factor", "(", "qnoise_factor", "=", "0.0", ")", "\n", "x_q_0", "=", "qr_qc_true", "(", "inputs", ")", "\n", "assert_equal", "(", "x_q_0", ",", "x_clipped", ")", "\n", "\n", "# full quantization", "\n", "qr_qc_true", ".", "update_qnoise_factor", "(", "qnoise_factor", "=", "1.0", ")", "\n", "x_q_1", "=", "qr_qc_true", "(", "inputs", ")", "\n", "assert_equal", "(", "x_q_1", ",", "xq", ")", "\n", "\n", "# mixing half and half", "\n", "qr_qc_true", ".", "update_qnoise_factor", "(", "qnoise_factor", "=", "0.5", ")", "\n", "x_q_05", "=", "qr_qc_true", "(", "inputs", ")", "\n", "assert_equal", "(", "x_q_05", ",", "x_clipped_xq", ")", "\n", "\n", "#########################################", "\n", "# Relu upper bound", "\n", "# No quantized clip for float relu", "\n", "#########################################", "\n", "qr_ub_qc_false", "=", "quantized_relu", "(", "\n", "bits", "=", "bits", ",", "\n", "integer", "=", "integer", ",", "\n", "use_sigmoid", "=", "use_sigmoid", ",", "\n", "negative_slope", "=", "negative_slope", ",", "\n", "use_stochastic_rounding", "=", "use_stochastic_rounding", ",", "\n", "relu_upper_bound", "=", "1.5", ",", "\n", "is_quantized_clip", "=", "False", ",", "\n", "use_variables", "=", "True", ")", "\n", "# no quantization", "\n", "qr_ub_qc_false", ".", "update_qnoise_factor", "(", "qnoise_factor", "=", "0.0", ")", "\n", "x_q_0", "=", "qr_ub_qc_false", "(", "inputs", ")", "\n", "assert_equal", "(", "x_q_0", ",", "np", ".", "clip", "(", "x_ub", ",", "a_min", "=", "None", ",", "a_max", "=", "1.5", ")", ")", "\n", "\n", "# full quantization", "\n", "qr_ub_qc_false", ".", "update_qnoise_factor", "(", "qnoise_factor", "=", "1.0", ")", "\n", "x_q_1", "=", "qr_ub_qc_false", "(", "inputs", ")", "\n", "assert_equal", "(", "x_q_1", ",", "np", ".", "clip", "(", "xq", ",", "a_min", "=", "None", ",", "a_max", "=", "1.5", ")", ")", "\n", "\n", "# mixing half and half", "\n", "qr_ub_qc_false", ".", "update_qnoise_factor", "(", "qnoise_factor", "=", "0.5", ")", "\n", "x_q_05", "=", "qr_ub_qc_false", "(", "inputs", ")", "\n", "assert_equal", "(", "x_q_05", ",", "np", ".", "clip", "(", "x_ub_xq", ",", "a_min", "=", "None", ",", "a_max", "=", "1.5", ")", ")", "\n", "\n", "#########################################", "\n", "# Relu upper bound", "\n", "# Quantized clip for float relu", "\n", "# (The quantized clip has precedence over the relu upper bound.)", "\n", "#########################################", "\n", "qr_ub_qc_true", "=", "quantized_relu", "(", "\n", "bits", "=", "bits", ",", "\n", "integer", "=", "integer", ",", "\n", "use_sigmoid", "=", "use_sigmoid", ",", "\n", "negative_slope", "=", "negative_slope", ",", "\n", "use_stochastic_rounding", "=", "use_stochastic_rounding", ",", "\n", "relu_upper_bound", "=", "1.5", ",", "\n", "is_quantized_clip", "=", "True", ",", "\n", "use_variables", "=", "True", ")", "\n", "# no quantization", "\n", "qr_ub_qc_true", ".", "update_qnoise_factor", "(", "qnoise_factor", "=", "0.0", ")", "\n", "x_q_0", "=", "qr_ub_qc_true", "(", "inputs", ")", "\n", "assert_equal", "(", "x_q_0", ",", "x_clipped", ")", "\n", "\n", "# full quantization", "\n", "qr_ub_qc_true", ".", "update_qnoise_factor", "(", "qnoise_factor", "=", "1.0", ")", "\n", "x_q_1", "=", "qr_ub_qc_true", "(", "inputs", ")", "\n", "assert_equal", "(", "x_q_1", ",", "xq", ")", "\n", "\n", "# mixing half and half", "\n", "qr_ub_qc_true", ".", "update_qnoise_factor", "(", "qnoise_factor", "=", "0.5", ")", "\n", "x_q_05", "=", "qr_ub_qc_true", "(", "inputs", ")", "\n", "assert_equal", "(", "x_q_05", ",", "x_clipped_xq", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qadaptiveactivation_test.run_qadaptiveactivation_test": [[31, 114], ["tensorflow.keras.Sequential", "tf.keras.Sequential.compile", "tf.keras.Sequential.numpy", "numpy.isclose().all", "numpy.isclose().all", "numpy.isclose().all", "tf.keras.Sequential.numpy", "qkeras.quantizers._get_integer_bits().numpy", "numpy.isclose().all", "kwargs[].assign", "numpy.array", "quant.update_qnoise_factor", "numpy.copy", "quant.update_qnoise_factor", "tf.keras.Sequential.numpy", "numpy.isclose().all", "tf.keras.Sequential.numpy", "numpy.isclose().all", "len", "kwargs[].numpy", "numpy.isclose().all", "numpy.isclose().all", "numpy.isclose().all", "numpy.isclose().all", "numpy.isclose().all", "tensorflow.constant", "quant", "qkeras.qlayers.QAdaptiveActivation", "tf.keras.Sequential.", "numpy.isclose", "numpy.isclose", "numpy.isclose", "tf.keras.Sequential.", "numpy.isclose().all", "ValueError", "qkeras.quantizers._get_integer_bits", "numpy.isclose", "tf.keras.Sequential.", "numpy.isclose", "tf.keras.Sequential.", "numpy.isclose", "tf.keras.Sequential.layers[].quantizer", "tf.keras.Sequential.layers[].ema_min.numpy().flatten", "tf.keras.Sequential.layers[].ema_max.numpy().flatten", "numpy.isclose", "numpy.isclose", "numpy.isclose", "numpy.isclose", "numpy.isclose", "tf.keras.Sequential.layers[].ema_min.numpy", "tf.keras.Sequential.layers[].ema_max.numpy", "quant.integer.numpy", "quant", "numpy.maximum", "numpy.isclose", "tf.keras.Sequential.layers[].ema_min.numpy", "numpy.min", "tf.keras.Sequential.layers[].ema_max.numpy", "numpy.max", "tf.keras.Sequential.layers[].ema_min.numpy", "numpy.min", "tf.keras.Sequential.layers[].ema_max.numpy", "numpy.max", "tf.keras.Sequential.layers[].ema_min.numpy", "tf.keras.Sequential.layers[].ema_max.numpy"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor", "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_integer_bits", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["def", "run_qadaptiveactivation_test", "(", "input_val", ",", "kwargs", ")", ":", "\n", "  ", "\"\"\"Helper function to test QAdaptiveActivation inputs and outputs.\"\"\"", "\n", "err", "=", "'Failed test with {} on input {}'", ".", "format", "(", "kwargs", ",", "input_val", ")", "\n", "\n", "# Only test inputs of shape (batch_size, width, height, channels)", "\n", "assert", "len", "(", "input_val", ".", "shape", ")", "==", "4", ",", "err", "\n", "\n", "# Only test short term layer usage with ema_decay == 0", "\n", "assert", "kwargs", "[", "'ema_decay'", "]", "==", "0", ",", "err", "\n", "assert", "kwargs", "[", "'ema_freeze_delay'", "]", "is", "None", ",", "err", "\n", "\n", "# Prepare layer in a static TF graph", "\n", "model", "=", "tf", ".", "keras", ".", "Sequential", "(", "[", "QAdaptiveActivation", "(", "**", "kwargs", ")", "]", ")", "\n", "model", ".", "compile", "(", ")", "\n", "\n", "# Test input on untrained EMAs", "\n", "qout", "=", "model", "(", "input_val", ",", "training", "=", "False", ")", ".", "numpy", "(", ")", "\n", "assert", "np", ".", "isclose", "(", "model", ".", "layers", "[", "0", "]", ".", "quantizer", "(", "input_val", ")", ",", "qout", ")", ".", "all", "(", ")", ",", "err", "\n", "assert", "np", ".", "isclose", "(", "model", ".", "layers", "[", "0", "]", ".", "ema_min", ".", "numpy", "(", ")", ".", "flatten", "(", ")", ",", "0", ")", ".", "all", "(", ")", ",", "err", "\n", "assert", "np", ".", "isclose", "(", "model", ".", "layers", "[", "0", "]", ".", "ema_max", ".", "numpy", "(", ")", ".", "flatten", "(", ")", ",", "0", ")", ".", "all", "(", ")", ",", "err", "\n", "\n", "# Run an unquantized input and train the EMA", "\n", "unquantized_out", "=", "model", "(", "input_val", ",", "training", "=", "True", ")", ".", "numpy", "(", ")", "\n", "assert", "kwargs", "[", "'current_step'", "]", ".", "numpy", "(", ")", "==", "0", ",", "err", "\n", "if", "kwargs", "[", "'activation'", "]", "==", "'quantized_relu'", ":", "\n", "    ", "assert", "np", ".", "isclose", "(", "unquantized_out", ",", "np", ".", "maximum", "(", "input_val", ",", "0", ")", ")", ".", "all", "(", ")", ",", "err", "\n", "", "elif", "kwargs", "[", "'activation'", "]", "==", "'quantized_bits'", ":", "\n", "    ", "assert", "np", ".", "isclose", "(", "unquantized_out", ",", "input_val", ")", ".", "all", "(", ")", ",", "err", "\n", "", "else", ":", "\n", "    ", "raise", "ValueError", "(", "'Invalid quantizer type '", ",", "kwargs", "[", "'activation'", "]", ")", "\n", "\n", "# Check EMAs", "\n", "", "if", "kwargs", "[", "'per_channel'", "]", ":", "\n", "    ", "assert", "np", ".", "isclose", "(", "model", ".", "layers", "[", "0", "]", ".", "ema_min", ".", "numpy", "(", ")", ",", "\n", "np", ".", "min", "(", "input_val", ",", "axis", "=", "(", "0", ",", "1", ",", "2", ")", ")", ")", ".", "all", "(", ")", ",", "err", "\n", "assert", "np", ".", "isclose", "(", "model", ".", "layers", "[", "0", "]", ".", "ema_max", ".", "numpy", "(", ")", ",", "\n", "np", ".", "max", "(", "input_val", ",", "axis", "=", "(", "0", ",", "1", ",", "2", ")", ")", ")", ".", "all", "(", ")", ",", "err", "\n", "", "else", ":", "\n", "    ", "assert", "np", ".", "isclose", "(", "model", ".", "layers", "[", "0", "]", ".", "ema_min", ".", "numpy", "(", ")", ",", "\n", "np", ".", "min", "(", "input_val", ",", "axis", "=", "(", "0", ",", "1", ",", "2", ",", "3", ")", ")", ")", ".", "all", "(", ")", ",", "err", "\n", "assert", "np", ".", "isclose", "(", "model", ".", "layers", "[", "0", "]", ".", "ema_max", ".", "numpy", "(", ")", ",", "\n", "np", ".", "max", "(", "input_val", ",", "axis", "=", "(", "0", ",", "1", ",", "2", ",", "3", ")", ")", ")", ".", "all", "(", ")", ",", "err", "\n", "\n", "# Check quantizer", "\n", "", "quant", "=", "model", ".", "layers", "[", "0", "]", ".", "quantizer", "\n", "assert", "quant", ".", "__class__", ".", "__name__", "==", "kwargs", "[", "'activation'", "]", ",", "err", "\n", "assert", "quant", ".", "bits", "==", "kwargs", "[", "'total_bits'", "]", ",", "err", "\n", "assert", "quant", ".", "symmetric", "==", "kwargs", "[", "'symmetric'", "]", ",", "err", "\n", "keep_negative", "=", "None", "\n", "if", "kwargs", "[", "'activation'", "]", "==", "'quantized_relu'", ":", "\n", "    ", "assert", "not", "quant", ".", "is_quantized_clip", ",", "err", "\n", "assert", "quant", ".", "negative_slope", "==", "kwargs", "[", "'relu_neg_slope'", "]", ",", "err", "\n", "assert", "quant", ".", "relu_upper_bound", "is", "None", ",", "err", "\n", "keep_negative", "=", "kwargs", "[", "'relu_neg_slope'", "]", "!=", "0", "\n", "", "elif", "kwargs", "[", "'activation'", "]", "==", "'quantized_bits'", ":", "\n", "    ", "assert", "quant", ".", "keep_negative", ",", "err", "\n", "assert", "quant", ".", "alpha", "==", "1.0", ",", "err", "\n", "keep_negative", "=", "True", "\n", "", "expected_integer_bits", "=", "_get_integer_bits", "(", "model", ".", "layers", "[", "0", "]", ".", "ema_min", ".", "numpy", "(", ")", ",", "\n", "model", ".", "layers", "[", "0", "]", ".", "ema_max", ".", "numpy", "(", ")", ",", "\n", "kwargs", "[", "'total_bits'", "]", ",", "\n", "kwargs", "[", "'symmetric'", "]", ",", "\n", "keep_negative", ",", "\n", "kwargs", "[", "'po2_rounding'", "]", ")", ".", "numpy", "(", ")", "\n", "assert", "np", ".", "isclose", "(", "expected_integer_bits", ",", "quant", ".", "integer", ".", "numpy", "(", ")", ")", ".", "all", "(", ")", ",", "err", "\n", "\n", "# Skip to a step where the quantization is used", "\n", "kwargs", "[", "'current_step'", "]", ".", "assign", "(", "tf", ".", "constant", "(", "kwargs", "[", "'quantization_delay'", "]", ",", "\n", "tf", ".", "int64", ")", ")", "\n", "\n", "# Check quantized output", "\n", "# To set qnoise_factor to 1.0 explicitly.", "\n", "qnoise_factor", "=", "np", ".", "array", "(", "quant", ".", "qnoise_factor", ")", "\n", "quant", ".", "update_qnoise_factor", "(", "1.0", ")", "\n", "expected_qout", "=", "np", ".", "copy", "(", "quant", "(", "input_val", ")", ")", "\n", "# Revert qnoise_factor to its original value.", "\n", "quant", ".", "update_qnoise_factor", "(", "qnoise_factor", ")", "\n", "qout", "=", "model", "(", "input_val", ",", "training", "=", "True", ")", ".", "numpy", "(", ")", "\n", "assert", "np", ".", "isclose", "(", "expected_qout", ",", "qout", ")", ".", "all", "(", ")", ",", "err", "\n", "\n", "# Check testing mode", "\n", "qout", "=", "model", "(", "input_val", ",", "training", "=", "False", ")", ".", "numpy", "(", ")", "\n", "assert", "np", ".", "isclose", "(", "quant", "(", "input_val", ")", ",", "qout", ")", ".", "all", "(", ")", ",", "err", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qadaptiveactivation_test.test_qadaptiveact_ema": [[116, 167], ["pytest.mark.parametrize", "qkeras.qlayers.QAdaptiveActivation", "tensorflow.keras.Sequential", "tf.keras.Sequential.compile", "range", "tensorflow.Variable", "tf.keras.Sequential.", "qkeras.quantizers._get_integer_bits", "numpy.isclose", "numpy.random.random", "numpy.equal", "numpy.abs", "qkeras.quantizers._get_integer_bits.numpy", "qkeras.qlayers.QAdaptiveActivation.quantizer.integer.numpy", "tf.Variable.assign_add", "qkeras.qlayers.QAdaptiveActivation.step.numpy", "vals.max", "vals.min", "qkeras.qlayers.QAdaptiveActivation.ema_max.numpy"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_integer_bits", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'momentum, ema_freeze_delay, total_steps, estimate_step_count'", ",", "\n", "[", "(", "0.9", ",", "50", ",", "100", ",", "False", ")", ",", "(", "0.5", ",", "1000", ",", "1500", ",", "False", ")", ",", "(", "0.1", ",", "2", ",", "100", ",", "False", ")", ",", "\n", "(", "0.999", ",", "98", ",", "100", ",", "False", ")", ",", "(", "0.9", ",", "50", ",", "100", ",", "True", ")", ",", "(", "0.5", ",", "1000", ",", "1500", ",", "True", ")", ",", "\n", "(", "0.1", ",", "2", ",", "100", ",", "True", ")", ",", "(", "0.999", ",", "98", ",", "100", ",", "True", ")", "]", ")", "\n", "def", "test_qadaptiveact_ema", "(", "momentum", ",", "ema_freeze_delay", ",", "total_steps", ",", "\n", "estimate_step_count", ")", ":", "\n", "  ", "\"\"\"Test the exponential moving averages over time for QAdaptiveActivation.\"\"\"", "\n", "\n", "# Initialize a QAdaptiveActivation layer just for testing the EMA", "\n", "if", "estimate_step_count", ":", "\n", "    ", "step", "=", "None", "\n", "", "else", ":", "\n", "    ", "step", "=", "tf", ".", "Variable", "(", "0", ",", "dtype", "=", "tf", ".", "int64", ")", "\n", "", "q_act", "=", "QAdaptiveActivation", "(", "activation", "=", "'quantized_bits'", ",", "\n", "total_bits", "=", "8", ",", "\n", "current_step", "=", "step", ",", "\n", "quantization_delay", "=", "total_steps", "*", "2", ",", "\n", "ema_freeze_delay", "=", "ema_freeze_delay", ",", "\n", "ema_decay", "=", "momentum", ",", "\n", "per_channel", "=", "True", ",", "\n", "po2_rounding", "=", "False", ")", "\n", "model", "=", "tf", ".", "keras", ".", "Sequential", "(", "[", "q_act", "]", ")", "\n", "model", ".", "compile", "(", ")", "\n", "\n", "# Simulate a number of training steps and check the EMA values", "\n", "exp_ema_max", "=", "0.0", "\n", "exp_ema_min", "=", "0.0", "\n", "for", "i", "in", "range", "(", "0", ",", "total_steps", ")", ":", "\n", "    ", "vals", "=", "np", ".", "random", ".", "random", "(", "(", "1", ",", "2", ",", "1", ")", ")", "*", "i", "# generate random values for update", "\n", "model", "(", "vals", ",", "training", "=", "True", ")", "# Simulate training", "\n", "\n", "# Check the steps match", "\n", "if", "estimate_step_count", ":", "\n", "      ", "assert", "np", ".", "equal", "(", "q_act", ".", "step", ".", "numpy", "(", ")", ",", "i", ")", "\n", "\n", "# Calculate expected values", "\n", "", "if", "i", "<=", "ema_freeze_delay", ":", "\n", "      ", "exp_ema_max", "=", "(", "exp_ema_max", "*", "momentum", ")", "+", "(", "vals", ".", "max", "(", ")", "*", "(", "1.0", "-", "momentum", ")", ")", "\n", "exp_ema_min", "=", "(", "exp_ema_min", "*", "momentum", ")", "+", "(", "vals", ".", "min", "(", ")", "*", "(", "1.0", "-", "momentum", ")", ")", "\n", "", "exp_int_bits", "=", "_get_integer_bits", "(", "exp_ema_min", ",", "exp_ema_max", ",", "\n", "q_act", ".", "quantizer", ".", "bits", ",", "\n", "q_act", ".", "quantizer", ".", "symmetric", ",", "\n", "q_act", ".", "quantizer", ".", "symmetric", ",", "False", ")", "\n", "\n", "# Check results", "\n", "assert", "np", ".", "abs", "(", "exp_ema_max", "-", "q_act", ".", "ema_max", ".", "numpy", "(", ")", "[", "0", "]", ")", "<", "0.0001", "\n", "\n", "assert", "np", ".", "isclose", "(", "exp_int_bits", ".", "numpy", "(", ")", ",", "q_act", ".", "quantizer", ".", "integer", ".", "numpy", "(", ")", ")", "\n", "if", "not", "estimate_step_count", ":", "\n", "      ", "step", ".", "assign_add", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qadaptiveactivation_test.test_qadaptiveactivation": [[169, 190], ["itertools.product", "test_options.values", "list", "range", "tensorflow.Variable", "qadaptiveactivation_test.run_qadaptiveactivation_test", "test_options.keys", "len", "numpy.random.random"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.tests.qadaptiveactivation_test.run_qadaptiveactivation_test"], ["", "", "", "def", "test_qadaptiveactivation", "(", ")", ":", "\n", "  ", "\"\"\"Test a wide variety of inputs to the QAdaptiveActivation layer.\"\"\"", "\n", "test_options", "=", "{", "\n", "'activation'", ":", "[", "'quantized_bits'", ",", "'quantized_relu'", "]", ",", "\n", "'total_bits'", ":", "[", "1", ",", "2", ",", "4", ",", "8", ",", "16", "]", ",", "\n", "'symmetric'", ":", "[", "True", ",", "False", "]", ",", "\n", "'quantization_delay'", ":", "[", "1", "]", ",", "# We will only run for one step", "\n", "'per_channel'", ":", "[", "True", ",", "False", "]", ",", "\n", "'po2_rounding'", ":", "[", "True", ",", "False", "]", ",", "\n", "'relu_neg_slope'", ":", "[", "0.0", ",", "-", "0.5", "]", "\n", "}", "\n", "\n", "for", "args", "in", "itertools", ".", "product", "(", "*", "test_options", ".", "values", "(", ")", ")", ":", "\n", "    ", "args", "=", "{", "list", "(", "test_options", ".", "keys", "(", ")", ")", "[", "i", "]", ":", "args", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "args", ")", ")", "}", "\n", "args", "[", "'ema_freeze_delay'", "]", "=", "None", "# This test does not test the EMA freeze", "\n", "args", "[", "'ema_decay'", "]", "=", "0", "# This test not test the EMA delay", "\n", "for", "img_shape", "in", "[", "(", "1", ",", "28", ",", "28", ",", "3", ")", ",", "(", "1", ",", "3", ",", "4", ",", "5", ")", "]", ":", "\n", "      ", "for", "input_scale", "in", "[", "255", ",", "1", "]", ":", "\n", "        ", "args", "[", "'current_step'", "]", "=", "tf", ".", "Variable", "(", "0", ",", "dtype", "=", "tf", ".", "int64", ")", "\n", "img", "=", "np", ".", "random", ".", "random", "(", "img_shape", ")", "*", "input_scale", "\n", "run_qadaptiveactivation_test", "(", "img", ",", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.print_qstats_test.create_network": [[33, 40], ["tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "tensorflow.keras.layers.Conv2D", "tensorflow.keras.layers.Activation", "tensorflow.keras.layers.Conv2D", "tensorflow.keras.layers.Activation"], "function", ["None"], ["def", "create_network", "(", ")", ":", "\n", "  ", "xi", "=", "Input", "(", "(", "28", ",", "28", ",", "1", ")", ")", "\n", "x", "=", "Conv2D", "(", "32", ",", "(", "3", ",", "3", ")", ")", "(", "xi", ")", "\n", "x", "=", "Activation", "(", "\"relu\"", ")", "(", "x", ")", "\n", "x", "=", "Conv2D", "(", "32", ",", "(", "3", ",", "3", ")", ",", "activation", "=", "\"relu\"", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "\"softmax\"", ")", "(", "x", ")", "\n", "return", "Model", "(", "inputs", "=", "xi", ",", "outputs", "=", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.print_qstats_test.create_mix_network": [[42, 50], ["tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "qkeras.QConv2D", "tensorflow.keras.layers.Activation", "tensorflow.keras.layers.Conv2D", "tensorflow.keras.layers.Activation", "binary"], "function", ["None"], ["", "def", "create_mix_network", "(", ")", ":", "\n", "\n", "  ", "xi", "=", "Input", "(", "(", "28", ",", "28", ",", "1", ")", ")", "\n", "x", "=", "QConv2D", "(", "32", ",", "(", "3", ",", "3", ")", ",", "kernel_quantizer", "=", "binary", "(", ")", ")", "(", "xi", ")", "\n", "x", "=", "Activation", "(", "\"relu\"", ")", "(", "x", ")", "\n", "x", "=", "Conv2D", "(", "32", ",", "(", "3", ",", "3", ")", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "\"softmax\"", ")", "(", "x", ")", "\n", "return", "Model", "(", "inputs", "=", "xi", ",", "outputs", "=", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.print_qstats_test.create_network_with_bn": [[52, 63], ["tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "tensorflow.keras.layers.Conv2D", "tensorflow.keras.layers.BatchNormalization", "tensorflow.keras.layers.Activation", "tensorflow.keras.layers.DepthwiseConv2D", "tensorflow.keras.layers.BatchNormalization", "tensorflow.keras.layers.Activation"], "function", ["None"], ["", "def", "create_network_with_bn", "(", ")", ":", "\n", "  ", "\"\"\"Creates a network contains both QConv2D and QDepthwiseConv2D layers.\"\"\"", "\n", "\n", "xi", "=", "Input", "(", "(", "28", ",", "28", ",", "1", ")", ")", "\n", "x", "=", "Conv2D", "(", "32", ",", "(", "3", ",", "3", ")", ")", "(", "xi", ")", "\n", "x", "=", "BatchNormalization", "(", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "\"relu\"", ")", "(", "x", ")", "\n", "x", "=", "DepthwiseConv2D", "(", "(", "3", ",", "3", ")", ",", "activation", "=", "\"relu\"", ")", "(", "x", ")", "\n", "x", "=", "BatchNormalization", "(", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "\"softmax\"", ")", "(", "x", ")", "\n", "return", "Model", "(", "inputs", "=", "xi", ",", "outputs", "=", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.print_qstats_test.test_conversion_print_qstats": [[65, 109], ["print_qstats_test.create_network", "qkeras.utils.model_quantize", "qkeras.utils.model_quantize.summary", "qkeras.estimate.print_qstats", "qkeras.estimate.print_qstats", "print_qstats_test.create_mix_network", "qkeras.estimate.print_qstats", "print_qstats_test.create_network_with_bn", "qkeras.utils.model_quantize", "qkeras.utils.model_quantize.summary", "qkeras.estimate.print_qstats"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.print_qstats_test.create_network", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize", "home.repos.pwc.inspect_result.google_qkeras.qtools.interface.print_qstats", "home.repos.pwc.inspect_result.google_qkeras.qtools.interface.print_qstats", "home.repos.pwc.inspect_result.google_qkeras.tests.print_qstats_test.create_mix_network", "home.repos.pwc.inspect_result.google_qkeras.qtools.interface.print_qstats", "home.repos.pwc.inspect_result.google_qkeras.tests.print_qstats_test.create_network_with_bn", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize", "home.repos.pwc.inspect_result.google_qkeras.qtools.interface.print_qstats"], ["", "def", "test_conversion_print_qstats", "(", ")", ":", "\n", "# this tests if references in tensorflow are working properly.", "\n", "  ", "m", "=", "create_network", "(", ")", "\n", "d", "=", "{", "\n", "\"QConv2D\"", ":", "{", "\n", "\"kernel_quantizer\"", ":", "\"binary\"", ",", "\n", "\"bias_quantizer\"", ":", "\"binary\"", "\n", "}", ",", "\n", "\"QActivation\"", ":", "{", "\n", "\"relu\"", ":", "\"ternary\"", "\n", "}", "\n", "}", "\n", "qq", "=", "model_quantize", "(", "m", ",", "d", ",", "4", ")", "\n", "qq", ".", "summary", "(", ")", "\n", "print_qstats", "(", "qq", ")", "\n", "\n", "# test if print_qstats works with unquantized layers", "\n", "print_qstats", "(", "m", ")", "\n", "\n", "# test if print_qstats works with mixture of quantized and unquantized layers", "\n", "m1", "=", "create_mix_network", "(", ")", "\n", "print_qstats", "(", "m1", ")", "\n", "\n", "m2", "=", "create_network_with_bn", "(", ")", "\n", "d2", "=", "{", "\n", "\"QConv2D\"", ":", "{", "\n", "\"kernel_quantizer\"", ":", "\"binary\"", ",", "\n", "\"bias_quantizer\"", ":", "\"binary\"", "\n", "}", ",", "\n", "\"QActivation\"", ":", "{", "\n", "\"relu\"", ":", "\"ternary\"", "\n", "}", ",", "\n", "\"QConv2DBatchnorm\"", ":", "{", "\n", "\"kernel_quantizer\"", ":", "\"ternary\"", ",", "\n", "\"bias_quantizer\"", ":", "\"ternary\"", ",", "\n", "}", ",", "\n", "\"QDepthwiseConv2DBatchnorm\"", ":", "{", "\n", "\"depthwise_quantizer\"", ":", "\"ternary\"", ",", "\n", "\"bias_quantizer\"", ":", "\"ternary\"", ",", "\n", "}", ",", "\n", "}", "\n", "m2", "=", "model_quantize", "(", "m2", ",", "d2", ",", "4", ",", "enable_bn_folding", "=", "True", ")", "\n", "m2", ".", "summary", "(", ")", "\n", "print_qstats", "(", "m2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qrecurrent_test.test_qrnn": [[58, 162], ["pytest.mark.parametrize", "tensorflow.keras.backend.set_learning_phase", "numpy.random.seed", "tensorflow.random.set_seed", "tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "qkeras.utils.load_qmodel.to_json", "tensorflow.keras.backend.clear_session", "qkeras.utils.quantized_model_from_json", "tempfile.mkstemp", "qkeras.utils.load_qmodel.save", "qkeras.utils.load_qmodel", "os.close", "os.remove", "qkeras.utils.model_save_quantized_weights", "numpy.array", "numpy.all", "qkeras.utils.load_qmodel.predict().astype", "numpy.testing.assert_allclose", "rnn", "qkeras.QDense", "tensorflow.keras.layers.Activation", "enumerate", "numpy.random.rand", "layer.get_weights", "numpy.sum", "np.array.append", "qkeras.utils.load_qmodel.predict", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "qkeras.quantized_tanh", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.quantized_model_from_json", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.save", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.load_qmodel", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_save_quantized_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "'rnn, all_weights_signature, expected_output'", ",", "[", "\n", "(", "QSimpleRNN", ",", "\n", "np", ".", "array", "(", "[", "5.109375", ",", "-", "1.8828125", ",", "0.0", ",", "-", "0.5", ",", "0.0", "]", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "0.281", ",", "0.4956", ",", "0.1047", ",", "0.1188", "]", ",", "\n", "[", "0.185", ",", "0.6016", ",", "0.0977", ",", "0.1157", "]", ",", "\n", "[", "0.3892", ",", "0.483", ",", "0.03528", ",", "0.0926", "]", ",", "\n", "[", "0.4038", ",", "0.511", ",", "0.01686", ",", "0.06824", "]", ",", "\n", "[", "0.3354", ",", "0.5376", ",", "0.02602", ",", "0.101", "]", ",", "\n", "[", "0.2043", ",", "0.587", ",", "0.04147", ",", "0.1675", "]", ",", "\n", "[", "0.2297", ",", "0.6455", ",", "0.0456", ",", "0.0789", "]", ",", "\n", "[", "0.4512", ",", "0.4326", ",", "0.01938", ",", "0.0968", "]", ",", "\n", "[", "0.6304", ",", "0.2498", ",", "0.03345", ",", "0.0866", "]", ",", "\n", "[", "0.4924", ",", "0.3735", ",", "0.011925", ",", "0.1222", "]", "]", ",", "\n", "dtype", "=", "np", ".", "float16", ")", ")", ",", "\n", "(", "QLSTM", ",", "np", ".", "array", "(", "[", "3.7421875", ",", "2.1328125", ",", "15.875", ",", "-", "0.5", ",", "0.0", "]", ",", "\n", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "0.27", ",", "0.1814", ",", "0.3108", ",", "0.2378", "]", ",", "\n", "[", "0.2976", ",", "0.2424", ",", "0.248", ",", "0.2119", "]", ",", "\n", "[", "0.3054", ",", "0.2004", ",", "0.2705", ",", "0.2238", "]", ",", "\n", "[", "0.325", ",", "0.1656", ",", "0.269", ",", "0.2401", "]", ",", "\n", "[", "0.271", ",", "0.1796", ",", "0.3", ",", "0.2493", "]", ",", "\n", "[", "0.3066", ",", "0.1873", ",", "0.2477", ",", "0.2583", "]", ",", "\n", "[", "0.2798", ",", "0.1757", ",", "0.2944", ",", "0.25", "]", ",", "\n", "[", "0.2693", ",", "0.2335", ",", "0.2534", ",", "0.2437", "]", ",", "\n", "[", "0.2808", ",", "0.2057", ",", "0.2712", ",", "0.2422", "]", ",", "\n", "[", "0.2732", ",", "0.2336", ",", "0.2491", ",", "0.244", "]", "]", ",", "\n", "dtype", "=", "np", ".", "float16", ")", ")", ",", "\n", "(", "QGRU", ",", "np", ".", "array", "(", "[", "4.6875", ",", "4.3984375", ",", "0.0", ",", "-", "0.5", ",", "0.0", "]", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "0.2025", ",", "0.3467", ",", "0.2952", ",", "0.1556", "]", ",", "\n", "[", "0.2935", ",", "0.3313", ",", "0.2058", ",", "0.1694", "]", ",", "\n", "[", "0.2046", ",", "0.4465", ",", "0.1827", ",", "0.1661", "]", ",", "\n", "[", "0.1913", ",", "0.498", ",", "0.1583", ",", "0.1525", "]", ",", "\n", "[", "0.1578", ",", "0.477", ",", "0.1973", ",", "0.1677", "]", ",", "\n", "[", "0.2018", ",", "0.44", ",", "0.1714", ",", "0.1869", "]", ",", "\n", "[", "0.157", ",", "0.551", ",", "0.1709", ",", "0.12115", "]", ",", "\n", "[", "0.1973", ",", "0.4353", ",", "0.1672", ",", "0.2001", "]", ",", "\n", "[", "0.1622", ",", "0.5146", ",", "0.1741", ",", "0.149", "]", ",", "\n", "[", "0.2101", ",", "0.3855", ",", "0.2069", ",", "0.1976", "]", "]", ",", "\n", "dtype", "=", "np", ".", "float16", ")", ")", ",", "\n", "]", ")", "\n", "def", "test_qrnn", "(", "rnn", ",", "all_weights_signature", ",", "expected_output", ")", ":", "\n", "  ", "K", ".", "set_learning_phase", "(", "0", ")", "\n", "np", ".", "random", ".", "seed", "(", "22", ")", "\n", "tf", ".", "random", ".", "set_seed", "(", "22", ")", "\n", "\n", "x", "=", "x_in", "=", "Input", "(", "(", "2", ",", "4", ")", ",", "name", "=", "'input'", ")", "\n", "x", "=", "rnn", "(", "\n", "16", ",", "\n", "activation", "=", "quantized_tanh", "(", "bits", "=", "8", ",", "symmetric", "=", "True", ")", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "8", ",", "0", ",", "1", ",", "alpha", "=", "1.0", ")", ",", "\n", "recurrent_quantizer", "=", "quantized_bits", "(", "8", ",", "0", ",", "1", ",", "alpha", "=", "1.0", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "8", ",", "0", ",", "1", ",", "alpha", "=", "1.0", ")", ",", "\n", "state_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ",", "alpha", "=", "1.0", ")", ",", "\n", "name", "=", "'qrnn_0'", ")", "(", "\n", "x", ")", "\n", "x", "=", "QDense", "(", "\n", "4", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "6", ",", "2", ",", "1", ",", "alpha", "=", "1.0", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "'dense'", ")", "(", "\n", "x", ")", "\n", "x", "=", "Activation", "(", "'softmax'", ",", "name", "=", "'softmax'", ")", "(", "x", ")", "\n", "\n", "model", "=", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "\n", "# reload the model to ensure saving/loading works", "\n", "json_string", "=", "model", ".", "to_json", "(", ")", "\n", "clear_session", "(", ")", "\n", "model", "=", "quantized_model_from_json", "(", "json_string", ")", "\n", "\n", "# Save the model as an h5 file using Keras's model.save()", "\n", "fd", ",", "fname", "=", "tempfile", ".", "mkstemp", "(", "'.h5'", ")", "\n", "model", ".", "save", "(", "fname", ")", "\n", "del", "model", "# Delete the existing model", "\n", "\n", "# Return a compiled model identical to the previous one", "\n", "model", "=", "load_qmodel", "(", "fname", ")", "\n", "\n", "# Clean the created h5 file after loading the model", "\n", "os", ".", "close", "(", "fd", ")", "\n", "os", ".", "remove", "(", "fname", ")", "\n", "\n", "# apply quantizer to weights", "\n", "model_save_quantized_weights", "(", "model", ")", "\n", "\n", "all_weights", "=", "[", "]", "\n", "\n", "for", "layer", "in", "model", ".", "layers", ":", "\n", "    ", "for", "i", ",", "weights", "in", "enumerate", "(", "layer", ".", "get_weights", "(", ")", ")", ":", "\n", "      ", "w", "=", "np", ".", "sum", "(", "weights", ")", "\n", "all_weights", ".", "append", "(", "w", ")", "\n", "\n", "", "", "all_weights", "=", "np", ".", "array", "(", "all_weights", ")", "\n", "\n", "assert", "all_weights", ".", "size", "==", "all_weights_signature", ".", "size", "\n", "assert", "np", ".", "all", "(", "all_weights", "==", "all_weights_signature", ")", "\n", "\n", "# test forward:", "\n", "inputs", "=", "2", "*", "np", ".", "random", ".", "rand", "(", "10", ",", "2", ",", "4", ")", "\n", "actual_output", "=", "model", ".", "predict", "(", "inputs", ")", ".", "astype", "(", "np", ".", "float16", ")", "\n", "assert_allclose", "(", "actual_output", ",", "expected_output", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qrecurrent_test.test_qbidirectional": [[164, 264], ["pytest.mark.parametrize", "tensorflow.keras.backend.set_learning_phase", "numpy.random.seed", "tensorflow.random.set_seed", "tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "qkeras.utils.load_qmodel.to_json", "tensorflow.keras.backend.clear_session", "qkeras.utils.quantized_model_from_json", "tempfile.mkstemp", "qkeras.utils.load_qmodel.save", "qkeras.utils.load_qmodel", "os.close", "os.remove", "qkeras.utils.model_save_quantized_weights", "numpy.array", "numpy.all", "qkeras.utils.load_qmodel.predict().astype", "numpy.testing.assert_allclose", "qkeras.QBidirectional", "qkeras.QDense", "tensorflow.keras.layers.Activation", "enumerate", "numpy.random.rand", "rnn", "layer.get_weights", "numpy.sum", "np.array.append", "qkeras.utils.load_qmodel.predict", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "qkeras.quantized_bits", "qkeras.quantized_bits"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.quantized_model_from_json", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.save", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.load_qmodel", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_save_quantized_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'rnn, all_weights_signature, expected_output'", ",", "[", "\n", "(", "QSimpleRNN", ",", "\n", "np", ".", "array", "(", "[", "\n", "-", "2.6562500e+00", ",", "-", "4.3466797e+00", ",", "8.6736174e-19", ",", "6.2548828e-01", ",", "\n", "-", "6.0751953e+00", ",", "8.6736174e-19", ",", "-", "7.5000000e-01", ",", "0.0", "\n", "]", ",", "\n", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "0.0851", ",", "0.1288", ",", "0.586", ",", "0.2002", "]", ",", "[", "0.1044", ",", "0.1643", ",", "0.7217", ",", "0.00978", "]", ",", "\n", "[", "0.04135", ",", "0.0537", ",", "0.8706", ",", "0.03455", "]", ",", "[", "0.03354", ",", "0.0489", ",", "0.889", ",", "0.02852", "]", ",", "\n", "[", "0.04358", ",", "0.05246", ",", "0.7563", ",", "0.1478", "]", ",", "[", "0.03403", ",", "0.0743", ",", "0.4177", ",", "0.4739", "]", ",", "\n", "[", "0.0859", ",", "0.1567", ",", "0.3972", ",", "0.36", "]", ",", "[", "0.27", ",", "0.1945", ",", "0.4841", ",", "0.05124", "]", ",", "\n", "[", "0.12115", ",", "0.05722", ",", "0.728", ",", "0.0938", "]", ",", "[", "0.2864", ",", "0.1262", ",", "0.339", ",", "0.2484", "]", "]", ",", "\n", "dtype", "=", "np", ".", "float16", ")", ")", ",", "\n", "(", "QLSTM", ",", "\n", "np", ".", "array", "(", "\n", "[", "-", "4.1406555", ",", "3.2921143", ",", "16.", ",", "7.0236816", ",", "4.1237793", ",", "16.", ",", "-", "0.75", ",", "0.", "]", ",", "\n", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "0.301", ",", "0.2236", ",", "0.2275", ",", "0.2478", "]", ",", "[", "0.2135", ",", "0.2627", ",", "0.2439", ",", "0.2798", "]", ",", "\n", "[", "0.1671", ",", "0.2252", ",", "0.2844", ",", "0.3232", "]", ",", "[", "0.2211", ",", "0.2178", ",", "0.2817", ",", "0.2795", "]", ",", "\n", "[", "0.3384", ",", "0.1732", ",", "0.2451", ",", "0.2434", "]", ",", "[", "0.296", ",", "0.1979", ",", "0.2468", ",", "0.2593", "]", ",", "\n", "[", "0.2698", ",", "0.1753", ",", "0.288", ",", "0.267", "]", ",", "[", "0.258", ",", "0.1888", ",", "0.3228", ",", "0.2301", "]", ",", "\n", "[", "0.2169", ",", "0.1578", ",", "0.3699", ",", "0.2554", "]", ",", "[", "0.2783", ",", "0.1816", ",", "0.2986", ",", "0.2415", "]", "]", ",", "\n", "dtype", "=", "np", ".", "float16", ")", ")", ",", "\n", "(", "QGRU", ",", "\n", "np", ".", "array", "(", "[", "\n", "-", "6.7578125e-01", ",", "3.6837769e-01", ",", "2.6020852e-18", ",", "4.1682129e+00", ",", "\n", "-", "7.5769043e-01", ",", "2.6020852e-18", ",", "-", "7.5000000e-01", ",", "0.0", "\n", "]", ",", "\n", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "np", ".", "array", "(", "\n", "[", "[", "0.278", ",", "0.1534", ",", "0.314", ",", "0.2546", "]", ",", "[", "0.1985", ",", "0.1788", ",", "0.3823", ",", "0.2402", "]", ",", "\n", "[", "0.1997", ",", "0.1621", ",", "0.3792", ",", "0.259", "]", ",", "[", "0.2534", ",", "0.1605", ",", "0.281", ",", "0.3052", "]", ",", "\n", "[", "0.3794", ",", "0.1266", ",", "0.2296", ",", "0.2642", "]", ",", "[", "0.285", ",", "0.1754", ",", "0.2847", ",", "0.255", "]", ",", "\n", "[", "0.2878", ",", "0.1339", ",", "0.3042", ",", "0.274", "]", ",", "[", "0.2874", ",", "0.1475", ",", "0.279", ",", "0.2861", "]", ",", "\n", "[", "0.2379", ",", "0.1356", ",", "0.3186", ",", "0.3079", "]", ",", "[", "0.2234", ",", "0.1476", ",", "0.3274", ",", "0.3015", "]", "]", ",", "\n", "dtype", "=", "np", ".", "float16", ")", ")", "\n", "]", ")", "\n", "def", "test_qbidirectional", "(", "rnn", ",", "all_weights_signature", ",", "expected_output", ")", ":", "\n", "  ", "K", ".", "set_learning_phase", "(", "0", ")", "\n", "np", ".", "random", ".", "seed", "(", "22", ")", "\n", "tf", ".", "random", ".", "set_seed", "(", "22", ")", "\n", "\n", "x", "=", "x_in", "=", "Input", "(", "(", "2", ",", "4", ")", ",", "name", "=", "'input'", ")", "\n", "x", "=", "QBidirectional", "(", "\n", "rnn", "(", "16", ",", "\n", "activation", "=", "'quantized_po2(8)'", ",", "\n", "kernel_quantizer", "=", "'quantized_po2(8)'", ",", "\n", "recurrent_quantizer", "=", "'quantized_po2(8)'", ",", "\n", "bias_quantizer", "=", "'quantized_po2(8)'", ",", "\n", "state_quantizer", "=", "'quantized_po2(8)'", ",", "\n", "name", "=", "'qbirnn_0'", ")", ")", "(", "\n", "x", ")", "\n", "x", "=", "QDense", "(", "\n", "4", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "8", ",", "2", ",", "1", ",", "alpha", "=", "1.0", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "8", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "'dense'", ")", "(", "\n", "x", ")", "\n", "x", "=", "Activation", "(", "'softmax'", ",", "name", "=", "'softmax'", ")", "(", "x", ")", "\n", "\n", "model", "=", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "\n", "# reload the model to ensure saving/loading works", "\n", "json_string", "=", "model", ".", "to_json", "(", ")", "\n", "clear_session", "(", ")", "\n", "model", "=", "quantized_model_from_json", "(", "json_string", ")", "\n", "\n", "# Save the model as an h5 file using Keras's model.save()", "\n", "fd", ",", "fname", "=", "tempfile", ".", "mkstemp", "(", "'.h5'", ")", "\n", "model", ".", "save", "(", "fname", ")", "\n", "del", "model", "# Delete the existing model", "\n", "\n", "# Return a compiled model identical to the previous one", "\n", "model", "=", "load_qmodel", "(", "fname", ")", "\n", "\n", "# Clean the created h5 file after loading the model", "\n", "os", ".", "close", "(", "fd", ")", "\n", "os", ".", "remove", "(", "fname", ")", "\n", "\n", "# apply quantizer to weights", "\n", "model_save_quantized_weights", "(", "model", ")", "\n", "\n", "all_weights", "=", "[", "]", "\n", "\n", "for", "layer", "in", "model", ".", "layers", ":", "\n", "    ", "for", "_", ",", "weights", "in", "enumerate", "(", "layer", ".", "get_weights", "(", ")", ")", ":", "\n", "\n", "      ", "w", "=", "np", ".", "sum", "(", "weights", ")", "\n", "all_weights", ".", "append", "(", "w", ")", "\n", "\n", "", "", "all_weights", "=", "np", ".", "array", "(", "all_weights", ")", "\n", "assert", "all_weights", ".", "size", "==", "all_weights_signature", ".", "size", "\n", "assert", "np", ".", "all", "(", "all_weights", "==", "all_weights_signature", ")", "\n", "\n", "# test forward:", "\n", "inputs", "=", "2", "*", "np", ".", "random", ".", "rand", "(", "10", ",", "2", ",", "4", ")", "\n", "actual_output", "=", "model", ".", "predict", "(", "inputs", ")", ".", "astype", "(", "np", ".", "float16", ")", "\n", "assert_allclose", "(", "actual_output", ",", "expected_output", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qrecurrent_test.create_network_rnn": [[266, 270], ["tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "rnn"], "function", ["None"], ["", "def", "create_network_rnn", "(", "rnn", ")", ":", "\n", "  ", "xi", "=", "Input", "(", "(", "16", ",", "1", ",", ")", ")", "\n", "x", "=", "rnn", "(", "8", ")", "(", "xi", ")", "\n", "return", "Model", "(", "inputs", "=", "xi", ",", "outputs", "=", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qrecurrent_test.test_rnn_conversion": [[272, 296], ["pytest.mark.parametrize", "qrecurrent_test.create_network_rnn", "qkeras.utils.model_quantize", "str", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.qrecurrent_test.create_network_rnn", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'rnn'", ",", "[", "SimpleRNN", ",", "LSTM", ",", "GRU", "]", ")", "\n", "def", "test_rnn_conversion", "(", "rnn", ")", ":", "\n", "  ", "m", "=", "create_network_rnn", "(", "rnn", ")", "\n", "name", "=", "'Q'", "+", "m", ".", "layers", "[", "1", "]", ".", "__class__", ".", "__name__", "\n", "d", "=", "{", "\n", "name", ":", "{", "\n", "'kernel_quantizer'", ":", "'binary'", ",", "\n", "'recurrent_quantizer'", ":", "'binary'", ",", "\n", "'bias_quantizer'", ":", "'binary'", ",", "\n", "'state_quantizer'", ":", "'binary'", ",", "\n", "'activation_quantizer'", ":", "'binary'", ",", "\n", "}", "\n", "}", "\n", "if", "name", "!=", "'QSimpleRNN'", ":", "\n", "    ", "d", "[", "name", "]", "[", "'recurrent_activation_quantizer'", "]", "=", "'binary'", "\n", "\n", "", "qq", "=", "model_quantize", "(", "m", ",", "d", ",", "4", ")", "\n", "assert", "str", "(", "qq", ".", "layers", "[", "1", "]", ".", "kernel_quantizer", ")", "==", "'binary'", "\n", "assert", "str", "(", "qq", ".", "layers", "[", "1", "]", ".", "recurrent_quantizer", ")", "==", "'binary'", "\n", "assert", "str", "(", "qq", ".", "layers", "[", "1", "]", ".", "bias_quantizer", ")", "==", "'binary'", "\n", "assert", "str", "(", "qq", ".", "layers", "[", "1", "]", ".", "state_quantizer", ")", "==", "'binary'", "\n", "assert", "str", "(", "qq", ".", "layers", "[", "1", "]", ".", "activation", ")", "==", "'binary()'", "\n", "if", "name", "!=", "'QSimpleRNN'", ":", "\n", "    ", "assert", "str", "(", "qq", ".", "layers", "[", "1", "]", ".", "recurrent_activation", ")", "==", "'binary()'", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qrecurrent_test.create_network_birnn": [[298, 302], ["tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "tensorflow.keras.layers.Bidirectional", "rnn"], "function", ["None"], ["", "", "def", "create_network_birnn", "(", "rnn", ")", ":", "\n", "  ", "xi", "=", "Input", "(", "(", "16", ",", "1", ",", ")", ")", "\n", "x", "=", "Bidirectional", "(", "rnn", "(", "8", ")", ")", "(", "xi", ")", "\n", "return", "Model", "(", "inputs", "=", "xi", ",", "outputs", "=", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qrecurrent_test.test_birnn_conversion": [[304, 338], ["pytest.mark.parametrize", "qrecurrent_test.create_network_birnn", "qkeras.utils.model_quantize", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.qrecurrent_test.create_network_birnn", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'rnn'", ",", "[", "SimpleRNN", ",", "LSTM", ",", "GRU", "]", ")", "\n", "def", "test_birnn_conversion", "(", "rnn", ")", ":", "\n", "  ", "m", "=", "create_network_birnn", "(", "rnn", ")", "\n", "name", "=", "'Q'", "+", "m", ".", "layers", "[", "1", "]", ".", "layer", ".", "__class__", ".", "__name__", "\n", "d", "=", "{", "\n", "'QBidirectional'", ":", "{", "\n", "'kernel_quantizer'", ":", "'binary'", ",", "\n", "'recurrent_quantizer'", ":", "'binary'", ",", "\n", "'bias_quantizer'", ":", "'binary'", ",", "\n", "'state_quantizer'", ":", "'binary'", ",", "\n", "'activation_quantizer'", ":", "'binary'", ",", "\n", "}", "\n", "}", "\n", "if", "name", "!=", "'QSimpleRNN'", ":", "\n", "    ", "d", "[", "'QBidirectional'", "]", "[", "'recurrent_activation_quantizer'", "]", "=", "'binary'", "\n", "\n", "", "qq", "=", "model_quantize", "(", "m", ",", "d", ",", "4", ")", "\n", "layer", "=", "qq", ".", "layers", "[", "1", "]", ".", "layer", "\n", "assert", "str", "(", "layer", ".", "kernel_quantizer", ")", "==", "'binary'", "\n", "assert", "str", "(", "layer", ".", "recurrent_quantizer", ")", "==", "'binary'", "\n", "assert", "str", "(", "layer", ".", "bias_quantizer", ")", "==", "'binary'", "\n", "assert", "str", "(", "layer", ".", "state_quantizer", ")", "==", "'binary'", "\n", "assert", "str", "(", "layer", ".", "activation", ")", "==", "'binary()'", "\n", "if", "name", "!=", "'QSimpleRNN'", ":", "\n", "    ", "assert", "str", "(", "layer", ".", "recurrent_activation", ")", "==", "'binary()'", "\n", "", "backward_layer", "=", "qq", ".", "layers", "[", "1", "]", ".", "backward_layer", "\n", "# backwards weight quantizers are dict because of contraints.serialize", "\n", "assert", "str", "(", "backward_layer", ".", "kernel_quantizer", "[", "'class_name'", "]", ")", "==", "'binary'", "\n", "assert", "str", "(", "backward_layer", ".", "recurrent_quantizer", "[", "'class_name'", "]", ")", "==", "'binary'", "\n", "assert", "str", "(", "backward_layer", ".", "bias_quantizer", "[", "'class_name'", "]", ")", "==", "'binary'", "\n", "assert", "str", "(", "backward_layer", ".", "state_quantizer", "[", "'class_name'", "]", ")", "==", "'binary'", "\n", "assert", "str", "(", "backward_layer", ".", "activation", ")", "==", "'binary()'", "\n", "if", "name", "!=", "'QSimpleRNN'", ":", "\n", "    ", "assert", "str", "(", "backward_layer", ".", "recurrent_activation", ")", "==", "'binary()'", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qrecurrent_test.test_birnn_subrnn": [[340, 367], ["tensorflow.keras.models.Sequential", "qkeras.utils.model_quantize", "str", "str", "str", "str", "str", "tensorflow.keras.layers.Bidirectional", "tensorflow.keras.layers.LSTM", "tensorflow.keras.layers.LSTM"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize"], ["", "", "def", "test_birnn_subrnn", "(", ")", ":", "\n", "  ", "model", "=", "Sequential", "(", "[", "Bidirectional", "(", "LSTM", "(", "16", ")", ")", ",", "LSTM", "(", "8", ")", "]", ")", "\n", "d", "=", "{", "\n", "'QLSTM'", ":", "{", "\n", "'activation_quantizer'", ":", "'ternary'", ",", "\n", "'recurrent_activation_quantizer'", ":", "'ternary'", ",", "\n", "'kernel_quantizer'", ":", "'ternary'", ",", "\n", "'recurrent_quantizer'", ":", "'ternary'", ",", "\n", "'bias_quantizer'", ":", "'ternary'", ",", "\n", "'state_quantizer'", ":", "'ternary'", ",", "\n", "}", ",", "\n", "'QBidirectional'", ":", "{", "\n", "'activation_quantizer'", ":", "'binary'", ",", "\n", "'recurrent_activation_quantizer'", ":", "'binary'", ",", "\n", "'kernel_quantizer'", ":", "'binary'", ",", "\n", "'recurrent_quantizer'", ":", "'binary'", ",", "\n", "'bias_quantizer'", ":", "'binary'", ",", "\n", "'state_quantizer'", ":", "'binary'", ",", "\n", "}", "\n", "}", "\n", "qmodel", "=", "model_quantize", "(", "model", ",", "d", ",", "4", ")", "\n", "layer", "=", "qmodel", ".", "layers", "[", "1", "]", "\n", "assert", "str", "(", "layer", ".", "kernel_quantizer", ")", "==", "'ternary'", "\n", "assert", "str", "(", "layer", ".", "recurrent_quantizer", ")", "==", "'ternary'", "\n", "assert", "str", "(", "layer", ".", "bias_quantizer", ")", "==", "'ternary'", "\n", "assert", "str", "(", "layer", ".", "state_quantizer", ")", "==", "'ternary'", "\n", "assert", "str", "(", "layer", ".", "activation", ")", "==", "'ternary()'", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qalpha_test.test_binary_auto": [[37, 56], ["numpy.random.seed", "numpy.random.uniform().astype", "tensorflow.keras.backend.constant", "qkeras.binary", "tensorflow.keras.backend.eval", "qkeras.get_weight_scale", "logging.info", "logging.info", "numpy.testing.assert_allclose", "tensorflow.keras.backend.floatx", "qkeras.binary.", "numpy.random.uniform"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_weight_scale"], ["def", "test_binary_auto", "(", ")", ":", "\n", "  ", "\"\"\"Test binary auto scale quantizer.\"\"\"", "\n", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "N", "=", "1000000", "\n", "m_list", "=", "[", "1.0", ",", "0.1", ",", "0.01", ",", "0.001", "]", "\n", "\n", "for", "m", "in", "m_list", ":", "\n", "    ", "x", "=", "np", ".", "random", ".", "uniform", "(", "-", "m", ",", "m", ",", "(", "N", ",", "10", ")", ")", ".", "astype", "(", "K", ".", "floatx", "(", ")", ")", "\n", "x", "=", "K", ".", "constant", "(", "x", ")", "\n", "\n", "quantizer", "=", "binary", "(", "alpha", "=", "\"auto\"", ")", "\n", "q", "=", "K", ".", "eval", "(", "quantizer", "(", "x", ")", ")", "\n", "\n", "result", "=", "get_weight_scale", "(", "quantizer", ",", "q", ")", "\n", "expected", "=", "m", "/", "2.0", "\n", "logging", ".", "info", "(", "\"expect %s\"", ",", "expected", ")", "\n", "logging", ".", "info", "(", "\"result %s\"", ",", "result", ")", "\n", "assert_allclose", "(", "result", ",", "expected", ",", "rtol", "=", "0.02", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qalpha_test.test_binary_auto_po2": [[58, 81], ["numpy.random.seed", "numpy.random.uniform().astype", "tensorflow.keras.backend.constant", "qkeras.binary", "qkeras.binary", "tensorflow.keras.backend.eval", "tensorflow.keras.backend.eval", "qkeras.get_weight_scale", "numpy.power", "qkeras.get_weight_scale", "numpy.testing.assert_allclose", "tensorflow.keras.backend.floatx", "qkeras.binary.", "qkeras.binary.", "numpy.round", "numpy.random.uniform", "numpy.log2"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_weight_scale", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_weight_scale"], ["", "", "def", "test_binary_auto_po2", "(", ")", ":", "\n", "  ", "\"\"\"Test binary auto_po2 scale quantizer.\"\"\"", "\n", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "N", "=", "1000000", "\n", "m_list", "=", "[", "1.0", ",", "0.1", ",", "0.01", ",", "0.001", "]", "\n", "\n", "for", "m", "in", "m_list", ":", "\n", "    ", "x", "=", "np", ".", "random", ".", "uniform", "(", "-", "m", ",", "m", ",", "(", "N", ",", "10", ")", ")", ".", "astype", "(", "K", ".", "floatx", "(", ")", ")", "\n", "x", "=", "K", ".", "constant", "(", "x", ")", "\n", "\n", "quantizer_ref", "=", "binary", "(", "alpha", "=", "\"auto\"", ")", "\n", "quantizer", "=", "binary", "(", "alpha", "=", "\"auto_po2\"", ")", "\n", "\n", "q_ref", "=", "K", ".", "eval", "(", "quantizer_ref", "(", "x", ")", ")", "\n", "q", "=", "K", ".", "eval", "(", "quantizer", "(", "x", ")", ")", "\n", "\n", "ref", "=", "get_weight_scale", "(", "quantizer_ref", ",", "q_ref", ")", "\n", "\n", "expected", "=", "np", ".", "power", "(", "2.0", ",", "np", ".", "round", "(", "np", ".", "log2", "(", "ref", ")", ")", ")", "\n", "result", "=", "get_weight_scale", "(", "quantizer", ",", "q", ")", "\n", "\n", "assert_allclose", "(", "result", ",", "expected", ",", "rtol", "=", "0.0001", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qalpha_test.test_ternary_auto": [[83, 101], ["numpy.random.seed", "numpy.random.uniform().astype", "tensorflow.keras.backend.constant", "qkeras.ternary", "tensorflow.keras.backend.eval", "numpy.mean", "numpy.testing.assert_allclose", "tensorflow.keras.backend.floatx", "qkeras.ternary.", "qkeras.get_weight_scale", "numpy.random.uniform"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_weight_scale"], ["", "", "def", "test_ternary_auto", "(", ")", ":", "\n", "  ", "\"\"\"Test ternary auto scale quantizer.\"\"\"", "\n", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "N", "=", "1000000", "\n", "m_list", "=", "[", "1.0", ",", "0.1", ",", "0.01", ",", "0.001", "]", "\n", "\n", "for", "m", "in", "m_list", ":", "\n", "    ", "x", "=", "np", ".", "random", ".", "uniform", "(", "-", "m", ",", "m", ",", "(", "N", ",", "10", ")", ")", ".", "astype", "(", "K", ".", "floatx", "(", ")", ")", "\n", "x", "=", "K", ".", "constant", "(", "x", ")", "\n", "\n", "quantizer", "=", "ternary", "(", "alpha", "=", "\"auto\"", ")", "\n", "q", "=", "K", ".", "eval", "(", "quantizer", "(", "x", ")", ")", "\n", "\n", "d", "=", "m", "/", "3.0", "\n", "result", "=", "np", ".", "mean", "(", "get_weight_scale", "(", "quantizer", ",", "q", ")", ")", "\n", "expected", "=", "(", "m", "+", "d", ")", "/", "2.0", "\n", "assert_allclose", "(", "result", ",", "expected", ",", "rtol", "=", "0.02", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qalpha_test.test_ternary_auto_po2": [[103, 126], ["numpy.random.seed", "numpy.random.uniform().astype", "tensorflow.keras.backend.constant", "qkeras.ternary", "qkeras.ternary", "tensorflow.keras.backend.eval", "tensorflow.keras.backend.eval", "qkeras.get_weight_scale", "numpy.power", "qkeras.get_weight_scale", "numpy.testing.assert_allclose", "tensorflow.keras.backend.floatx", "qkeras.ternary.", "qkeras.ternary.", "numpy.round", "numpy.random.uniform", "numpy.log2"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_weight_scale", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_weight_scale"], ["", "", "def", "test_ternary_auto_po2", "(", ")", ":", "\n", "  ", "\"\"\"Test ternary auto_po2 scale quantizer.\"\"\"", "\n", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "N", "=", "1000000", "\n", "m_list", "=", "[", "1.0", ",", "0.1", ",", "0.01", ",", "0.001", "]", "\n", "\n", "for", "m", "in", "m_list", ":", "\n", "    ", "x", "=", "np", ".", "random", ".", "uniform", "(", "-", "m", ",", "m", ",", "(", "N", ",", "10", ")", ")", ".", "astype", "(", "K", ".", "floatx", "(", ")", ")", "\n", "x", "=", "K", ".", "constant", "(", "x", ")", "\n", "\n", "quantizer_ref", "=", "ternary", "(", "alpha", "=", "\"auto\"", ")", "\n", "quantizer", "=", "ternary", "(", "alpha", "=", "\"auto_po2\"", ")", "\n", "\n", "q_ref", "=", "K", ".", "eval", "(", "quantizer_ref", "(", "x", ")", ")", "\n", "q", "=", "K", ".", "eval", "(", "quantizer", "(", "x", ")", ")", "\n", "\n", "ref", "=", "get_weight_scale", "(", "quantizer_ref", ",", "q_ref", ")", "\n", "\n", "expected", "=", "np", ".", "power", "(", "2.0", ",", "np", ".", "round", "(", "np", ".", "log2", "(", "ref", ")", ")", ")", "\n", "result", "=", "get_weight_scale", "(", "quantizer", ",", "q", ")", "\n", "\n", "assert_allclose", "(", "result", ",", "expected", ",", "rtol", "=", "0.0001", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qalpha_test.test_get_integer_bits": [[128, 230], ["numpy.array", "numpy.array", "qkeras.quantizers._get_integer_bits", "numpy.testing.assert_equal", "qkeras.quantizers._get_integer_bits", "numpy.testing.assert_equal", "qkeras.quantizers._get_integer_bits", "numpy.testing.assert_equal", "qkeras.quantizers._get_integer_bits", "numpy.testing.assert_equal", "qkeras.quantizers._get_integer_bits", "numpy.testing.assert_equal", "qkeras.quantizers._get_integer_bits", "numpy.testing.assert_equal", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_integer_bits", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_integer_bits", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_integer_bits", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_integer_bits", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_integer_bits", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_integer_bits"], ["", "", "def", "test_get_integer_bits", "(", ")", ":", "\n", "  ", "\"\"\"Test automated integer bit (po2 scale) estimator.\"\"\"", "\n", "\n", "bits", "=", "4", "\n", "min_value", "=", "np", ".", "array", "(", "[", "\n", "-", "4.0", ",", "-", "4.0", ",", "-", "4.0", ",", "-", "4.0", ",", "1.0", ",", "-", "3.0", ",", "-", "10.0", ",", "-", "16", ",", "-", "25", ",", "0", ",", "0", ",", "0", ",", "0.1", ",", "0.0", ",", "\n", "-", "1.0", ",", "0.0", ",", "0.0", ",", "0.0", ",", "0", ",", "0", ",", "0", "\n", "]", ")", "\n", "max_value", "=", "np", ".", "array", "(", "[", "\n", "3.5", ",", "3.51", ",", "3.75", ",", "3.751", ",", "2.0", ",", "4.0", ",", "5.0", ",", "8", ",", "0", ",", "0", ",", "0.1", ",", "0.999", ",", "0.5", ",", "0.8751", ",", "\n", "0.9375", ",", "0.93751", ",", "1.875", ",", "1.8751", ",", "9", ",", "11", ",", "12", "\n", "]", ")", "\n", "\n", "# unsigned number (keep_negative=False) without clippling.", "\n", "symmetric", "=", "False", "# symmetric is irrelevant.", "\n", "keep_negative", "=", "False", "\n", "is_clipping", "=", "False", "\n", "integer_bits", "=", "_get_integer_bits", "(", "\n", "min_value", "=", "min_value", ",", "\n", "max_value", "=", "max_value", ",", "\n", "bits", "=", "bits", ",", "\n", "symmetric", "=", "symmetric", ",", "\n", "keep_negative", "=", "keep_negative", ",", "\n", "is_clipping", "=", "is_clipping", ")", "\n", "assert_equal", "(", "\n", "integer_bits", ",", "\n", "np", ".", "array", "(", "[", "2", ",", "2", ",", "2", ",", "3", ",", "2", ",", "3", ",", "3", ",", "4", ",", "0", ",", "0", ",", "0", ",", "1", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "2", ",", "4", ",", "4", ",", "4", "]", ")", ")", "\n", "\n", "# unsigned number (keep_negative=False) with clippling.", "\n", "symmetric", "=", "False", "# symmetric is irrelevant.", "\n", "keep_negative", "=", "False", "\n", "is_clipping", "=", "True", "\n", "integer_bits", "=", "_get_integer_bits", "(", "\n", "min_value", "=", "min_value", ",", "\n", "max_value", "=", "max_value", ",", "\n", "bits", "=", "bits", ",", "\n", "symmetric", "=", "symmetric", ",", "\n", "keep_negative", "=", "keep_negative", ",", "\n", "is_clipping", "=", "is_clipping", ")", "\n", "assert_equal", "(", "\n", "integer_bits", ",", "\n", "np", ".", "array", "(", "[", "2", ",", "2", ",", "2", ",", "2", ",", "1", ",", "2", ",", "2", ",", "3", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "3", ",", "3", ",", "4", "]", ")", ")", "\n", "\n", "# signed number (keep_negative=True) non-symmetric without clippling", "\n", "symmetric", "=", "False", "\n", "keep_negative", "=", "True", "\n", "is_clipping", "=", "False", "\n", "integer_bits", "=", "_get_integer_bits", "(", "\n", "min_value", "=", "min_value", ",", "\n", "max_value", "=", "max_value", ",", "\n", "bits", "=", "bits", ",", "\n", "symmetric", "=", "symmetric", ",", "\n", "keep_negative", "=", "keep_negative", ",", "\n", "is_clipping", "=", "is_clipping", ")", "\n", "assert_equal", "(", "\n", "integer_bits", ",", "\n", "np", ".", "array", "(", "[", "2", ",", "3", ",", "3", ",", "3", ",", "2", ",", "3", ",", "3", ",", "3", ",", "3", ",", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "1", ",", "2", ",", "2", ",", "3", ",", "3", ",", "3", "]", ")", ")", "\n", "\n", "# signed number (keep_negative=True) non-symmetric with clippling", "\n", "symmetric", "=", "False", "\n", "keep_negative", "=", "True", "\n", "is_clipping", "=", "True", "\n", "integer_bits", "=", "_get_integer_bits", "(", "\n", "min_value", "=", "min_value", ",", "\n", "max_value", "=", "max_value", ",", "\n", "bits", "=", "bits", ",", "\n", "symmetric", "=", "symmetric", ",", "\n", "keep_negative", "=", "keep_negative", ",", "\n", "is_clipping", "=", "is_clipping", ")", "\n", "assert_equal", "(", "\n", "integer_bits", ",", "\n", "np", ".", "array", "(", "[", "2", ",", "2", ",", "2", ",", "2", ",", "1", ",", "2", ",", "3", ",", "3", ",", "3", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "3", ",", "3", ",", "3", "]", ")", ")", "\n", "\n", "# signed number (keep_negative=True) symmetric without clippling", "\n", "symmetric", "=", "True", "\n", "keep_negative", "=", "True", "\n", "is_clipping", "=", "False", "\n", "integer_bits", "=", "_get_integer_bits", "(", "\n", "min_value", "=", "min_value", ",", "\n", "max_value", "=", "max_value", ",", "\n", "bits", "=", "bits", ",", "\n", "symmetric", "=", "symmetric", ",", "\n", "keep_negative", "=", "keep_negative", ",", "\n", "is_clipping", "=", "is_clipping", ")", "\n", "assert_equal", "(", "\n", "integer_bits", ",", "\n", "np", ".", "array", "(", "[", "3", ",", "3", ",", "3", ",", "3", ",", "2", ",", "3", ",", "3", ",", "3", ",", "3", ",", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "1", ",", "2", ",", "2", ",", "3", ",", "3", ",", "3", "]", ")", ")", "\n", "\n", "# signed number (keep_negative=True) symmetric with clippling", "\n", "symmetric", "=", "True", "\n", "keep_negative", "=", "True", "\n", "is_clipping", "=", "True", "\n", "integer_bits", "=", "_get_integer_bits", "(", "\n", "min_value", "=", "min_value", ",", "\n", "max_value", "=", "max_value", ",", "\n", "bits", "=", "bits", ",", "\n", "symmetric", "=", "symmetric", ",", "\n", "keep_negative", "=", "keep_negative", ",", "\n", "is_clipping", "=", "is_clipping", ")", "\n", "assert_equal", "(", "\n", "integer_bits", ",", "\n", "np", ".", "array", "(", "[", "2", ",", "2", ",", "2", ",", "2", ",", "1", ",", "2", ",", "3", ",", "3", ",", "3", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "3", ",", "3", ",", "3", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qconvolutional_test.test_qnetwork": [[52, 160], ["tensorflow.keras.backend.set_learning_phase", "tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "qkeras.utils.quantized_model_from_json.to_json", "tensorflow.keras.backend.clear_session", "qkeras.utils.quantized_model_from_json", "numpy.random.seed", "qkeras.utils.model_save_quantized_weights", "numpy.array", "numpy.array", "numpy.all", "numpy.array().astype", "qkeras.utils.quantized_model_from_json.predict().astype", "numpy.testing.assert_allclose", "qkeras.QSeparableConv2D", "qkeras.QActivation", "qkeras.QConv2D", "qkeras.QConv2D", "qkeras.QActivation", "tensorflow.keras.layers.Flatten", "qkeras.QDense", "tensorflow.keras.layers.Activation", "enumerate", "enumerate", "numpy.random.rand", "layer.get_weights", "numpy.prod", "print", "np.array.append", "layer.set_weights", "layer.get_weights", "numpy.sum", "np.array.append", "numpy.array", "qkeras.utils.quantized_model_from_json.predict", "qkeras.binary", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.ternary", "qkeras.quantized_bits", "qkeras.quantized_relu", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "layer.input.shape.as_list", "len", "numpy.prod", "numpy.random.normal", "layer.get_weights", "numpy.sqrt"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.quantized_model_from_json", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_save_quantized_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights"], ["def", "test_qnetwork", "(", ")", ":", "\n", "  ", "K", ".", "set_learning_phase", "(", "1", ")", "\n", "x", "=", "x_in", "=", "Input", "(", "(", "28", ",", "28", ",", "1", ")", ",", "name", "=", "'input'", ")", "\n", "x", "=", "QSeparableConv2D", "(", "\n", "32", ",", "(", "2", ",", "2", ")", ",", "\n", "strides", "=", "(", "2", ",", "2", ")", ",", "\n", "depthwise_quantizer", "=", "binary", "(", "alpha", "=", "1.0", ")", ",", "\n", "pointwise_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ",", "alpha", "=", "1.0", ")", ",", "\n", "activation", "=", "quantized_bits", "(", "6", ",", "2", ",", "1", ",", "alpha", "=", "1.0", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "'conv2d_0_m'", ")", "(", "\n", "x", ")", "\n", "x", "=", "QActivation", "(", "'quantized_relu(6,2,1)'", ",", "name", "=", "'act0_m'", ")", "(", "x", ")", "\n", "x", "=", "QConv2D", "(", "\n", "64", ",", "(", "3", ",", "3", ")", ",", "\n", "strides", "=", "(", "2", ",", "2", ")", ",", "\n", "kernel_quantizer", "=", "ternary", "(", "alpha", "=", "1.0", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "'conv2d_1_m'", ",", "\n", "activation", "=", "quantized_relu", "(", "6", ",", "3", ",", "1", ")", ")", "(", "\n", "x", ")", "\n", "x", "=", "QConv2D", "(", "\n", "64", ",", "(", "2", ",", "2", ")", ",", "\n", "strides", "=", "(", "2", ",", "2", ")", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "6", ",", "2", ",", "1", ",", "alpha", "=", "1.0", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "'conv2d_2_m'", ")", "(", "\n", "x", ")", "\n", "x", "=", "QActivation", "(", "'quantized_relu(6,4,1)'", ",", "name", "=", "'act2_m'", ")", "(", "x", ")", "\n", "x", "=", "Flatten", "(", "name", "=", "'flatten'", ")", "(", "x", ")", "\n", "x", "=", "QDense", "(", "\n", "10", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "6", ",", "2", ",", "1", ",", "alpha", "=", "1.0", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "'dense'", ")", "(", "\n", "x", ")", "\n", "x", "=", "Activation", "(", "'softmax'", ",", "name", "=", "'softmax'", ")", "(", "x", ")", "\n", "\n", "model", "=", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "\n", "# reload the model to ensure saving/loading works", "\n", "json_string", "=", "model", ".", "to_json", "(", ")", "\n", "clear_session", "(", ")", "\n", "model", "=", "quantized_model_from_json", "(", "json_string", ")", "\n", "\n", "# generate same output for weights", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "for", "layer", "in", "model", ".", "layers", ":", "\n", "    ", "all_weights", "=", "[", "]", "\n", "\n", "for", "i", ",", "weights", "in", "enumerate", "(", "layer", ".", "get_weights", "(", ")", ")", ":", "\n", "      ", "input_size", "=", "np", ".", "prod", "(", "layer", ".", "input", ".", "shape", ".", "as_list", "(", ")", "[", "1", ":", "]", ")", "\n", "if", "(", "len", "(", "layer", ".", "get_weights", "(", ")", ")", "==", "3", "and", "i", ">", "0", ")", ":", "# pointwise kernel and bias", "\n", "        ", "input_size", "=", "input_size", "//", "np", ".", "prod", "(", "layer", ".", "kernel_size", ")", "\n", "", "shape", "=", "weights", ".", "shape", "\n", "print", "(", "shape", ")", "\n", "assert", "input_size", ">", "0", ",", "'input size for {} {}'", ".", "format", "(", "layer", ".", "name", ",", "i", ")", "\n", "# he normal initialization with a scale factor of 2.0", "\n", "all_weights", ".", "append", "(", "\n", "10.0", "*", "np", ".", "random", ".", "normal", "(", "0.0", ",", "np", ".", "sqrt", "(", "2.0", "/", "input_size", ")", ",", "shape", ")", ")", "\n", "", "if", "all_weights", ":", "\n", "      ", "layer", ".", "set_weights", "(", "all_weights", ")", "\n", "\n", "# apply quantizer to weights", "\n", "", "", "model_save_quantized_weights", "(", "model", ")", "\n", "\n", "all_weights", "=", "[", "]", "\n", "\n", "for", "layer", "in", "model", ".", "layers", ":", "\n", "    ", "for", "i", ",", "weights", "in", "enumerate", "(", "layer", ".", "get_weights", "(", ")", ")", ":", "\n", "\n", "      ", "w", "=", "np", ".", "sum", "(", "weights", ")", "\n", "all_weights", ".", "append", "(", "w", ")", "\n", "\n", "", "", "all_weights", "=", "np", ".", "array", "(", "all_weights", ")", "\n", "\n", "# test_qnetwork_weight_quantization", "\n", "all_weights_signature", "=", "np", ".", "array", "(", "\n", "[", "2.", ",", "-", "6.75", ",", "-", "0.625", ",", "-", "2.", ",", "-", "0.25", ",", "-", "56.", ",", "1.125", ",", "-", "1.625", ",", "-", "1.125", "]", ")", "\n", "\n", "assert", "all_weights", ".", "size", "==", "all_weights_signature", ".", "size", "\n", "assert", "np", ".", "all", "(", "all_weights", "==", "all_weights_signature", ")", "\n", "\n", "# test_qnetwork_forward:", "\n", "expected_output", "=", "np", ".", "array", "(", "\n", "[", "[", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "\n", "0.e+00", ",", "1.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", "]", ",", "\n", "[", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "\n", "0.e+00", ",", "1.e+00", ",", "0.e+00", ",", "0.e+00", ",", "7.6e-06", "]", ",", "\n", "[", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "\n", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "1.e+00", "]", ",", "\n", "[", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "\n", "0.e+00", ",", "1.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", "]", ",", "\n", "[", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "\n", "0.e+00", ",", "1.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", "]", ",", "\n", "[", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "\n", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "1.e+00", "]", ",", "\n", "[", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "\n", "0.e+00", ",", "1.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", "]", ",", "\n", "[", "0.e+00", ",", "1.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "\n", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", "]", ",", "\n", "[", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "1.e+00", ",", "\n", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", "]", ",", "\n", "[", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "\n", "1.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", ",", "0.e+00", "]", "]", ")", ".", "astype", "(", "np", ".", "float16", ")", "\n", "inputs", "=", "2", "*", "np", ".", "random", ".", "rand", "(", "10", ",", "28", ",", "28", ",", "1", ")", "\n", "actual_output", "=", "model", ".", "predict", "(", "inputs", ")", ".", "astype", "(", "np", ".", "float16", ")", "\n", "assert_allclose", "(", "actual_output", ",", "expected_output", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qconvolutional_test.test_sequential_qnetwork": [[162, 203], ["tensorflow.keras.Sequential", "tf.keras.Sequential.add", "tf.keras.Sequential.add", "tf.keras.Sequential.add", "tf.keras.Sequential.add", "tf.keras.Sequential.add", "tf.keras.Sequential.add", "tf.keras.Sequential.add", "tf.keras.Sequential.add", "tf.keras.Sequential.add", "tf.keras.Sequential.add", "qkeras.extract_model_operations", "qkeras.extract_model_operations.keys", "tensorflow.keras.layers.Input", "qkeras.QConv2D", "qkeras.QActivation", "qkeras.QConv2D", "qkeras.QActivation", "qkeras.QConv2D", "qkeras.QActivation", "tensorflow.keras.layers.Flatten", "qkeras.QDense", "tensorflow.keras.layers.Activation", "qkeras.quantized_relu", "qkeras.quantized_relu", "qkeras.quantized_relu", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.extract_model_operations"], ["", "def", "test_sequential_qnetwork", "(", ")", ":", "\n", "  ", "model", "=", "tf", ".", "keras", ".", "Sequential", "(", ")", "\n", "model", ".", "add", "(", "Input", "(", "(", "28", ",", "28", ",", "1", ")", ",", "name", "=", "'input'", ")", ")", "\n", "model", ".", "add", "(", "\n", "QConv2D", "(", "\n", "32", ",", "(", "2", ",", "2", ")", ",", "\n", "strides", "=", "(", "2", ",", "2", ")", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "'conv2d_0_m'", ")", ")", "\n", "model", ".", "add", "(", "QActivation", "(", "quantized_relu", "(", "4", ",", "0", ")", ",", "name", "=", "'act0_m'", ")", ")", "\n", "model", ".", "add", "(", "\n", "QConv2D", "(", "\n", "64", ",", "(", "3", ",", "3", ")", ",", "\n", "strides", "=", "(", "2", ",", "2", ")", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "'conv2d_1_m'", ")", ")", "\n", "model", ".", "add", "(", "QActivation", "(", "quantized_relu", "(", "4", ",", "0", ")", ",", "name", "=", "'act1_m'", ")", ")", "\n", "model", ".", "add", "(", "\n", "QConv2D", "(", "\n", "64", ",", "(", "2", ",", "2", ")", ",", "\n", "strides", "=", "(", "2", ",", "2", ")", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "'conv2d_2_m'", ")", ")", "\n", "model", ".", "add", "(", "QActivation", "(", "quantized_relu", "(", "4", ",", "0", ")", ",", "name", "=", "'act2_m'", ")", ")", "\n", "model", ".", "add", "(", "Flatten", "(", ")", ")", "\n", "model", ".", "add", "(", "\n", "QDense", "(", "\n", "10", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "'dense'", ")", ")", "\n", "model", ".", "add", "(", "Activation", "(", "'softmax'", ",", "name", "=", "'softmax'", ")", ")", "\n", "\n", "# Check that all model operation were found correctly", "\n", "model_ops", "=", "extract_model_operations", "(", "model", ")", "\n", "for", "layer", "in", "model_ops", ".", "keys", "(", ")", ":", "\n", "    ", "assert", "model_ops", "[", "layer", "]", "[", "'type'", "]", "[", "0", "]", "!=", "'null'", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qconvolutional_test.test_qconv1d": [[205, 287], ["pytest.mark.parametrize", "numpy.random.seed", "qkeras.extract_model_operations", "qkeras.print_qstats", "tempfile.mkstemp", "tensorflow.keras.models.Model.save", "qkeras.utils.load_qmodel", "os.close", "os.remove", "qkeras.utils.model_save_quantized_weights", "numpy.random.rand", "tensorflow.keras.models.Model.predict().astype", "numpy.testing.assert_allclose", "tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "enumerate", "numpy.array().astype", "numpy.array().astype", "qkeras.QConv1D", "qkeras.QSeparableConv1D", "layer.get_weights", "numpy.prod", "all_weights.append", "layer.set_weights", "tensorflow.keras.models.Model.predict", "numpy.array", "numpy.array", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "qkeras.quantized_bits", "layer.input.shape.as_list", "numpy.random.normal", "numpy.sqrt"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.extract_model_operations", "home.repos.pwc.inspect_result.google_qkeras.qtools.interface.print_qstats", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.save", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.load_qmodel", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_save_quantized_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"layer_cls\"", ",", "[", "\"QConv1D\"", ",", "\"QSeparableConv1D\"", "]", ")", "\n", "def", "test_qconv1d", "(", "layer_cls", ")", ":", "\n", "  ", "np", ".", "random", ".", "seed", "(", "33", ")", "\n", "if", "layer_cls", "==", "\"QConv1D\"", ":", "\n", "    ", "x", "=", "Input", "(", "(", "4", ",", "4", ",", ")", ")", "\n", "y", "=", "QConv1D", "(", "\n", "2", ",", "1", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "6", ",", "2", ",", "1", ",", "alpha", "=", "1.0", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "'qconv1d'", ")", "(", "\n", "x", ")", "\n", "model", "=", "Model", "(", "inputs", "=", "x", ",", "outputs", "=", "y", ")", "\n", "", "else", ":", "\n", "    ", "x", "=", "Input", "(", "(", "4", ",", "4", ",", ")", ")", "\n", "y", "=", "QSeparableConv1D", "(", "\n", "2", ",", "2", ",", "\n", "depthwise_quantizer", "=", "quantized_bits", "(", "6", ",", "2", ",", "1", ",", "alpha", "=", "1.0", ")", ",", "\n", "pointwise_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ",", "alpha", "=", "1.0", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "'qconv1d'", ")", "(", "\n", "x", ")", "\n", "model", "=", "Model", "(", "inputs", "=", "x", ",", "outputs", "=", "y", ")", "\n", "\n", "# Extract model operations", "\n", "", "model_ops", "=", "extract_model_operations", "(", "model", ")", "\n", "\n", "# Check the input layer model operation was found correctly", "\n", "assert", "model_ops", "[", "'qconv1d'", "]", "[", "'type'", "]", "[", "0", "]", "!=", "'null'", "\n", "\n", "# Assertion about the number of operations for this (Separable)Conv1D layer", "\n", "if", "layer_cls", "==", "\"QConv1D\"", ":", "\n", "    ", "assert", "model_ops", "[", "'qconv1d'", "]", "[", "'number_of_operations'", "]", "==", "32", "\n", "", "else", ":", "\n", "    ", "assert", "model_ops", "[", "'qconv1d'", "]", "[", "'number_of_operations'", "]", "==", "30", "\n", "\n", "# Print qstats to make sure it works with Conv1D layer", "\n", "", "print_qstats", "(", "model", ")", "\n", "\n", "# reload the model to ensure saving/loading works", "\n", "# json_string = model.to_json()", "\n", "# clear_session()", "\n", "# model = quantized_model_from_json(json_string)", "\n", "\n", "for", "layer", "in", "model", ".", "layers", ":", "\n", "    ", "all_weights", "=", "[", "]", "\n", "for", "i", ",", "weights", "in", "enumerate", "(", "layer", ".", "get_weights", "(", ")", ")", ":", "\n", "      ", "input_size", "=", "np", ".", "prod", "(", "layer", ".", "input", ".", "shape", ".", "as_list", "(", ")", "[", "1", ":", "]", ")", "\n", "if", "input_size", "is", "None", ":", "\n", "        ", "input_size", "=", "10", "*", "10", "\n", "", "shape", "=", "weights", ".", "shape", "\n", "assert", "input_size", ">", "0", ",", "'input size for {} {}'", ".", "format", "(", "layer", ".", "name", ",", "i", ")", "\n", "all_weights", ".", "append", "(", "\n", "10.0", "*", "np", ".", "random", ".", "normal", "(", "0.0", ",", "np", ".", "sqrt", "(", "2.0", "/", "input_size", ")", ",", "shape", ")", ")", "\n", "", "if", "all_weights", ":", "\n", "      ", "layer", ".", "set_weights", "(", "all_weights", ")", "\n", "# Save the model as an h5 file using Keras's model.save()", "\n", "", "", "fd", ",", "fname", "=", "tempfile", ".", "mkstemp", "(", "'.h5'", ")", "\n", "model", ".", "save", "(", "fname", ")", "\n", "del", "model", "# Delete the existing model", "\n", "\n", "# Return a compiled model identical to the previous one", "\n", "model", "=", "load_qmodel", "(", "fname", ")", "\n", "\n", "# Clean the created h5 file after loading the model", "\n", "os", ".", "close", "(", "fd", ")", "\n", "os", ".", "remove", "(", "fname", ")", "\n", "\n", "# apply quantizer to weights", "\n", "model_save_quantized_weights", "(", "model", ")", "\n", "\n", "inputs", "=", "np", ".", "random", ".", "rand", "(", "2", ",", "4", ",", "4", ")", "\n", "p", "=", "model", ".", "predict", "(", "inputs", ")", ".", "astype", "(", "np", ".", "float16", ")", "\n", "if", "layer_cls", "==", "\"QConv1D\"", ":", "\n", "    ", "y", "=", "np", ".", "array", "(", "[", "[", "[", "-", "2.441", ",", "3.816", "]", ",", "[", "-", "3.807", ",", "-", "1.426", "]", ",", "[", "-", "2.684", ",", "-", "1.317", "]", ",", "\n", "[", "-", "1.659", ",", "0.9834", "]", "]", ",", "\n", "[", "[", "-", "4.99", ",", "1.139", "]", ",", "[", "-", "2.559", ",", "-", "1.216", "]", ",", "[", "-", "2.285", ",", "1.905", "]", ",", "\n", "[", "-", "2.652", ",", "-", "0.467", "]", "]", "]", ")", ".", "astype", "(", "np", ".", "float16", ")", "\n", "", "else", ":", "\n", "    ", "y", "=", "np", ".", "array", "(", "[", "[", "[", "-", "2.275", ",", "-", "3.178", "]", ",", "[", "-", "0.4358", ",", "-", "3.262", "]", ",", "[", "1.987", ",", "0.3987", "]", "]", ",", "\n", "[", "[", "-", "0.01251", ",", "-", "0.376", "]", ",", "[", "0.3928", ",", "-", "1.328", "]", ",", "[", "-", "1.243", ",", "-", "2.43", "]", "]", "]", "\n", ")", ".", "astype", "(", "np", ".", "float16", ")", "\n", "", "assert_allclose", "(", "p", ",", "y", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qconvolutional_test.test_qconv2dtranspose": [[288, 310], ["tensorflow.keras.layers.Input", "tensorflow.keras.models.Model", "numpy.ones", "numpy.ones", "numpy.ones", "tensorflow.keras.models.Model.get_layer().set_weights", "tensorflow.keras.models.Model.predict().astype", "numpy.array().reshape().astype", "numpy.testing.assert_allclose", "qkeras.QConv2DTranspose", "tensorflow.keras.models.Model.get_layer", "tensorflow.keras.models.Model.predict", "numpy.array().reshape", "qkeras.binary", "qkeras.binary", "numpy.array"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict"], ["", "def", "test_qconv2dtranspose", "(", ")", ":", "\n", "  ", "x", "=", "Input", "(", "(", "4", ",", "4", ",", "1", ",", ")", ")", "\n", "y", "=", "QConv2DTranspose", "(", "\n", "1", ",", "\n", "kernel_size", "=", "(", "3", ",", "3", ")", ",", "\n", "kernel_quantizer", "=", "binary", "(", ")", ",", "\n", "bias_quantizer", "=", "binary", "(", ")", ",", "\n", "name", "=", "'conv2d_tran'", ")", "(", "x", ")", "\n", "model", "=", "Model", "(", "inputs", "=", "x", ",", "outputs", "=", "y", ")", "\n", "data", "=", "np", ".", "ones", "(", "shape", "=", "(", "1", ",", "4", ",", "4", ",", "1", ")", ")", "\n", "kernel", "=", "np", ".", "ones", "(", "shape", "=", "(", "3", ",", "3", ",", "1", ",", "1", ")", ")", "\n", "bias", "=", "np", ".", "ones", "(", "shape", "=", "(", "1", ",", ")", ")", "\n", "model", ".", "get_layer", "(", "'conv2d_tran'", ")", ".", "set_weights", "(", "[", "kernel", ",", "bias", "]", ")", "\n", "actual_output", "=", "model", ".", "predict", "(", "data", ")", ".", "astype", "(", "np", ".", "float16", ")", "\n", "expected_output", "=", "np", ".", "array", "(", "\n", "[", "[", "2.", ",", "3.", ",", "4.", ",", "4.", ",", "3.", ",", "2.", "]", ",", "\n", "[", "3.", ",", "5.", ",", "7.", ",", "7.", ",", "5.", ",", "3.", "]", ",", "\n", "[", "4.", ",", "7.", ",", "10.", ",", "10.", ",", "7.", ",", "4.", "]", ",", "\n", "[", "4.", ",", "7.", ",", "10.", ",", "10.", ",", "7.", ",", "4.", "]", ",", "\n", "[", "3.", ",", "5.", ",", "7.", ",", "7.", ",", "5.", ",", "3.", "]", ",", "\n", "[", "2.", ",", "3.", ",", "4.", ",", "4.", ",", "3.", ",", "2.", "]", "]", ")", ".", "reshape", "(", "(", "1", ",", "6", ",", "6", ",", "1", ")", ")", ".", "astype", "(", "np", ".", "float16", ")", "\n", "assert_allclose", "(", "actual_output", ",", "expected_output", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.utils_test.create_quantized_network": [[35, 58], ["Input", "Model", "qkeras.utils.model_quantize", "Conv2D", "Activation", "Conv2D", "Activation"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize"], ["def", "create_quantized_network", "(", ")", ":", "\n", "  ", "\"\"\"Creates a simple quantized conv net model.\"\"\"", "\n", "# Create a simple model", "\n", "xi", "=", "Input", "(", "(", "28", ",", "28", ",", "1", ")", ")", "\n", "x", "=", "Conv2D", "(", "32", ",", "(", "3", ",", "3", ")", ")", "(", "xi", ")", "\n", "x", "=", "Activation", "(", "\"relu\"", ")", "(", "x", ")", "\n", "x", "=", "Conv2D", "(", "32", ",", "(", "3", ",", "3", ")", ",", "activation", "=", "\"relu\"", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "\"softmax\"", ")", "(", "x", ")", "\n", "model", "=", "Model", "(", "inputs", "=", "xi", ",", "outputs", "=", "x", ")", "\n", "\n", "# Quantize the model", "\n", "quantizer_config", "=", "{", "\n", "\"QConv2D\"", ":", "{", "\n", "\"kernel_quantizer\"", ":", "\"quantized_bits(4)\"", ",", "\n", "\"bias_quantizer\"", ":", "\"quantized_bits(4)\"", "\n", "}", ",", "\n", "\"QActivation\"", ":", "{", "\n", "\"relu\"", ":", "\"ternary\"", "\n", "}", "\n", "}", "\n", "activation_bits", "=", "4", "\n", "qmodel", "=", "model_quantize", "(", "model", ",", "quantizer_config", ",", "activation_bits", ")", "\n", "return", "qmodel", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.utils_test.create_quantized_po2_network": [[60, 69], ["Input", "Model", "QConv2D", "QActivation", "QConv2D", "QActivation", "quantized_bits", "quantized_bits", "quantized_po2", "quantized_po2"], "function", ["None"], ["", "def", "create_quantized_po2_network", "(", ")", ":", "\n", "  ", "\"\"\"Creates a simple quantized conv net model with po2 quantizers.\"\"\"", "\n", "xi", "=", "Input", "(", "(", "28", ",", "28", ",", "1", ")", ")", "\n", "x", "=", "QConv2D", "(", "32", ",", "(", "3", ",", "3", ")", ",", "kernel_quantizer", "=", "quantized_po2", "(", "4", ")", ")", "(", "xi", ")", "\n", "x", "=", "QActivation", "(", "quantized_bits", "(", "8", ")", ")", "(", "x", ")", "\n", "x", "=", "QConv2D", "(", "32", ",", "(", "3", ",", "3", ")", ",", "kernel_quantizer", "=", "quantized_po2", "(", "4", ")", ")", "(", "x", ")", "\n", "x", "=", "QActivation", "(", "quantized_bits", "(", "8", ")", ")", "(", "x", ")", "\n", "qmodel", "=", "Model", "(", "xi", ",", "x", ",", "name", "=", "'simple_po2_qmodel'", ")", "\n", "return", "qmodel", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.utils_test.set_network_sparsity": [[71, 84], ["layer.get_weights", "layer.set_weights", "numpy.random.shuffle", "new_weights.append", "numpy.random.rand", "sparse_weights.reshape", "int"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights"], ["", "def", "set_network_sparsity", "(", "model", ",", "sparsity", ")", ":", "\n", "  ", "\"\"\"Set the sparsity of the given model using random weights.\"\"\"", "\n", "\n", "for", "layer", "in", "model", ".", "layers", ":", "\n", "    ", "new_weights", "=", "[", "]", "\n", "for", "w", "in", "layer", ".", "get_weights", "(", ")", ":", "\n", "# Create weights with desired sparsity", "\n", "      ", "sparse_weights", "=", "np", ".", "random", ".", "rand", "(", "w", ".", "size", ")", "+", "0.1", "\n", "sparse_weights", "[", ":", "int", "(", "w", ".", "size", "*", "sparsity", ")", "]", "=", "0", "\n", "np", ".", "random", ".", "shuffle", "(", "sparse_weights", ")", "\n", "new_weights", ".", "append", "(", "sparse_weights", ".", "reshape", "(", "w", ".", "shape", ")", ")", "\n", "", "layer", ".", "set_weights", "(", "new_weights", ")", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.utils_test.test_get_model_sparsity": [[86, 98], ["utils_test.create_quantized_network", "numpy.concatenate().round", "utils_test.set_network_sparsity", "qkeras.utils.get_model_sparsity", "numpy.concatenate", "numpy.abs", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.utils_test.create_quantized_network", "home.repos.pwc.inspect_result.google_qkeras.tests.utils_test.set_network_sparsity", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.get_model_sparsity"], ["", "def", "test_get_model_sparsity", "(", ")", ":", "\n", "  ", "\"\"\"Tests if the method get_model_sparsity in utils.py works correctly.\"\"\"", "\n", "qmodel", "=", "create_quantized_network", "(", ")", "\n", "\n", "# Generate sparsity levels to test", "\n", "sparsity_levels", "=", "np", ".", "concatenate", "(", "(", "np", ".", "random", ".", "rand", "(", "10", ")", ",", "[", "1.0", ",", "0.0", "]", ")", ")", ".", "round", "(", "2", ")", "\n", "\n", "# Test various sparsity levels", "\n", "for", "true_sparsity", "in", "sparsity_levels", ":", "\n", "    ", "qmodel", "=", "set_network_sparsity", "(", "qmodel", ",", "true_sparsity", ")", "\n", "calc_sparsity", "=", "get_model_sparsity", "(", "qmodel", ")", "\n", "assert", "np", ".", "abs", "(", "calc_sparsity", "-", "true_sparsity", ")", "<", "0.01", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.utils_test.test_get_po2_model_sparsity": [[100, 116], ["utils_test.create_quantized_po2_network", "numpy.concatenate().round", "utils_test.set_network_sparsity", "qkeras.utils.get_model_sparsity", "numpy.concatenate", "numpy.abs", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.utils_test.create_quantized_po2_network", "home.repos.pwc.inspect_result.google_qkeras.tests.utils_test.set_network_sparsity", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.get_model_sparsity"], ["", "", "def", "test_get_po2_model_sparsity", "(", ")", ":", "\n", "  ", "\"\"\"Tests get_model_sparsity on a po2-quantized model.\n\n  Models quantized with po2 quantizers should have a sparsity near 0 because\n  if the exponent is set to 0, the value of the weight will equal 2^0 == 1 != 0\n  \"\"\"", "\n", "qmodel", "=", "create_quantized_po2_network", "(", ")", "\n", "\n", "# Generate sparsity levels to test", "\n", "sparsity_levels", "=", "np", ".", "concatenate", "(", "(", "np", ".", "random", ".", "rand", "(", "10", ")", ",", "[", "1.0", ",", "0.0", "]", ")", ")", ".", "round", "(", "2", ")", "\n", "\n", "# Test various sparsity levels", "\n", "for", "set_sparsity", "in", "sparsity_levels", ":", "\n", "    ", "qmodel", "=", "set_network_sparsity", "(", "qmodel", ",", "set_sparsity", ")", "\n", "calc_sparsity", "=", "get_model_sparsity", "(", "qmodel", ")", "\n", "assert", "np", ".", "abs", "(", "calc_sparsity", "-", "0", ")", "<", "0.01", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.utils_test.test_convert_to_folded_model": [[118, 164], ["utils_test.test_convert_to_folded_model.get_add_model"], "function", ["None"], ["", "", "def", "test_convert_to_folded_model", "(", ")", ":", "\n", "  ", "\"\"\"Test convert_to_folded_model to work properly on non-sequential model.\"\"\"", "\n", "\n", "def", "get_add_model", "(", ")", ":", "\n", "    ", "x", "=", "x_in", "=", "Input", "(", "shape", "=", "(", "4", ",", "4", ",", "1", ")", ",", "name", "=", "\"input\"", ")", "\n", "x1", "=", "Conv2D", "(", "4", ",", "kernel_size", "=", "(", "2", ",", "2", ")", ",", "padding", "=", "\"valid\"", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "name", "=", "\"conv2d_1\"", ")", "(", "x", ")", "\n", "x1", "=", "BatchNormalization", "(", "name", "=", "\"bn_1\"", ")", "(", "x1", ")", "\n", "x1", "=", "Activation", "(", "\"relu\"", ",", "name", "=", "\"relu_1\"", ")", "(", "x1", ")", "\n", "x2", "=", "Conv2D", "(", "4", ",", "kernel_size", "=", "(", "2", ",", "2", ")", ",", "padding", "=", "\"valid\"", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "name", "=", "\"conv2d_2\"", ")", "(", "x", ")", "\n", "x2", "=", "BatchNormalization", "(", "name", "=", "\"bn_2\"", ")", "(", "x2", ")", "\n", "x2", "=", "Activation", "(", "\"relu\"", ",", "name", "=", "\"relu_2\"", ")", "(", "x2", ")", "\n", "x", "=", "Add", "(", "name", "=", "\"add\"", ")", "(", "[", "x1", ",", "x2", "]", ")", "\n", "x", "=", "Softmax", "(", ")", "(", "x", ")", "\n", "\n", "return", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "\n", "", "model", "=", "get_add_model", "(", ")", "\n", "\n", "fmodel", ",", "_", "=", "convert_to_folded_model", "(", "model", ")", "\n", "\n", "assert", "fmodel", ".", "layers", "[", "5", "]", ".", "name", "==", "\"add\"", "\n", "\n", "# test if convert_to_folded_model work with TFOpLambda layers", "\n", "def", "hard_sigmoid", "(", "x", ")", ":", "\n", "    ", "return", "ReLU", "(", "6.", ")", "(", "x", "+", "3.", ")", "*", "(", "1.", "/", "6.", ")", "\n", "\n", "", "def", "hard_swish", "(", "x", ")", ":", "\n", "    ", "return", "Multiply", "(", ")", "(", "[", "hard_sigmoid", "(", "x", ")", ",", "x", "]", ")", "\n", "\n", "", "def", "get_lambda_model", "(", ")", ":", "\n", "    ", "x", "=", "x_in", "=", "Input", "(", "shape", "=", "(", "4", ",", "4", ",", "1", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "Conv2D", "(", "\n", "4", ",", "kernel_size", "=", "(", "2", ",", "2", ")", ",", "padding", "=", "\"valid\"", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "name", "=", "\"conv2d_1\"", ")", "(", "x", ")", "\n", "x", "=", "hard_swish", "(", "x", ")", "\n", "\n", "return", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "\n", "", "model", "=", "get_lambda_model", "(", ")", "\n", "fmodel", ",", "_", "=", "convert_to_folded_model", "(", "model", ")", "\n", "\n", "assert", "is_TFOpLambda_layer", "(", "model", ".", "layers", "[", "2", "]", ")", "\n", "assert", "is_TFOpLambda_layer", "(", "model", ".", "layers", "[", "4", "]", ")", "\n", "assert", "isinstance", "(", "fmodel", ".", "layers", "[", "5", "]", ",", "Multiply", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.utils_test.test_find_bn_fusing_layer_pair": [[166, 223], ["Input", "Model", "qkeras.utils.find_bn_fusing_layer_pair", "conv_layer.set_weights", "bn_layer.set_weights", "qkeras.utils.add_bn_fusing_weights", "numpy.all", "numpy.all", "QConv2D", "QBatchNormalization", "QConv2D", "QBatchNormalization", "Add", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "quantized_bits", "quantized_bits", "quantized_bits", "quantized_bits", "quantized_bits", "quantized_bits", "quantized_bits", "quantized_bits", "quantized_bits", "quantized_bits"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.find_bn_fusing_layer_pair", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.add_bn_fusing_weights"], ["", "def", "test_find_bn_fusing_layer_pair", "(", ")", ":", "\n", "  ", "x", "=", "x_in", "=", "Input", "(", "(", "23", ",", "23", ",", "1", ")", ",", "name", "=", "\"input\"", ")", "\n", "x1", "=", "QConv2D", "(", "\n", "2", ",", "2", ",", "1", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "use_bias", "=", "False", ",", "\n", "name", "=", "\"conv1\"", ")", "(", "x", ")", "\n", "x1", "=", "QBatchNormalization", "(", "\n", "mean_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "gamma_quantizer", "=", "None", ",", "\n", "variance_quantizer", "=", "None", ",", "\n", "beta_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "inverse_quantizer", "=", "quantized_bits", "(", "8", ",", "0", ",", "1", ")", ",", "name", "=", "\"bn1\"", ")", "(", "x1", ")", "\n", "\n", "x2", "=", "QConv2D", "(", "\n", "2", ",", "2", ",", "1", ",", "\n", "kernel_quantizer", "=", "quantized_bits", "(", "3", ",", "0", ")", ",", "\n", "bias_quantizer", "=", "quantized_bits", "(", "3", ",", "2", ")", ",", "\n", "name", "=", "\"conv2\"", ")", "(", "x", ")", "\n", "\n", "x2", "=", "QBatchNormalization", "(", "\n", "mean_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "gamma_quantizer", "=", "None", ",", "\n", "variance_quantizer", "=", "None", ",", "\n", "beta_quantizer", "=", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "inverse_quantizer", "=", "quantized_bits", "(", "8", ",", "0", ",", "1", ")", ",", "name", "=", "\"bn2\"", ")", "(", "x2", ")", "\n", "\n", "x", "=", "Add", "(", "name", "=", "\"add\"", ")", "(", "[", "x1", ",", "x2", "]", ")", "\n", "model", "=", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "\n", "(", "conv_bn_pair_dict", ",", "_", ")", "=", "find_bn_fusing_layer_pair", "(", "model", ")", "\n", "assert", "conv_bn_pair_dict", "[", "\"conv1\"", "]", "==", "\"bn1\"", "\n", "assert", "conv_bn_pair_dict", "[", "\"conv2\"", "]", "==", "\"bn2\"", "\n", "\n", "conv_layer", "=", "model", ".", "layers", "[", "1", "]", "\n", "bn_layer", "=", "model", ".", "layers", "[", "3", "]", "\n", "\n", "conv_layer", ".", "set_weights", "(", "[", "\n", "np", ".", "array", "(", "[", "[", "[", "[", "0.5", ",", "0.75", "]", "]", ",", "[", "[", "1.5", ",", "-", "0.625", "]", "]", "]", ",", "\n", "[", "[", "[", "-", "0.875", ",", "1.25", "]", "]", ",", "[", "[", "-", "1.25", ",", "-", "2.5", "]", "]", "]", "]", ")", "\n", "]", ")", "\n", "bn_layer", ".", "set_weights", "(", "[", "\n", "np", ".", "array", "(", "[", "1.", ",", "0.25", "]", ")", ",", "\n", "np", ".", "array", "(", "[", "0.5", ",", "1.0", "]", ")", ",", "\n", "np", ".", "array", "(", "[", "0.5", ",", "2.5", "]", ")", ",", "\n", "np", ".", "array", "(", "[", "1.5", ",", "1.", "]", ")", "\n", "]", ")", "\n", "saved_weights", "=", "{", "}", "\n", "saved_weights", "[", "conv_layer", ".", "name", "]", "=", "{", "}", "\n", "add_bn_fusing_weights", "(", "conv_layer", ",", "bn_layer", ",", "saved_weights", ")", "\n", "\n", "d", "=", "saved_weights", "[", "conv_layer", ".", "name", "]", "\n", "assert", "d", "[", "\"enable_bn_fusing\"", "]", "\n", "assert", "d", "[", "\"fused_bn_layer_name\"", "]", "==", "\"bn1\"", "\n", "assert", "np", ".", "all", "(", "d", "[", "\"bn_inv\"", "]", "==", "np", ".", "array", "(", "[", "0.8125", ",", "0.25", "]", ")", ")", "\n", "assert", "np", ".", "all", "(", "d", "[", "\"fused_bias\"", "]", "==", "np", ".", "array", "(", "[", "0.09375", ",", "0.65625", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.qdense_model_fork": [[43, 68], ["tensorflow.layers.Input", "tensorflow.Model", "qkeras.QDense", "qkeras.QDense", "qkeras.QActivation", "qkeras.QDense", "qkeras.QActivation", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_po2", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_relu", "qkeras.quantizers.binary", "qkeras.quantizers.binary"], "function", ["None"], ["def", "qdense_model_fork", "(", ")", ":", "\n", "  ", "x", "=", "x_in", "=", "keras", ".", "layers", ".", "Input", "(", "(", "23", ",", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QDense", "(", "\n", "10", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "activation", "=", "quantizers", ".", "quantized_po2", "(", "3", ",", "1", ")", ",", "\n", "name", "=", "\"qdense_0\"", ")", "(", "x", ")", "\n", "x", "=", "QDense", "(", "\n", "20", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "activation", "=", "quantizers", ".", "quantized_relu", "(", "6", ",", "2", ")", ",", "\n", "name", "=", "\"qdense_1\"", ")", "(", "x", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(4)\"", ",", "name", "=", "\"QA_2\"", ")", "(", "x", ")", "\n", "x_1", "=", "QDense", "(", "\n", "30", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "binary", "(", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "binary", "(", ")", ",", "\n", "name", "=", "\"qdense_3\"", ")", "(", "x", ")", "\n", "x_2", "=", "QActivation", "(", "\"quantized_relu(6,2)\"", ",", "name", "=", "\"QA_3\"", ")", "(", "x", ")", "\n", "\n", "model", "=", "keras", ".", "Model", "(", "\n", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x_1", ",", "x_2", ",", "]", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.qconv_model": [[70, 95], ["tensorflow.layers.Input", "tensorflow.Model", "qkeras.QActivation", "qkeras.QConv2D", "qkeras.QConv2D", "qkeras.QConv2D", "qkeras.QActivation", "qkeras.quantizers.binary", "qkeras.quantizers.ternary", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_relu", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_relu"], "function", ["None"], ["", "def", "qconv_model", "(", ")", ":", "\n", "  ", "x", "=", "x_in", "=", "keras", ".", "layers", ".", "Input", "(", "(", "23", ",", "23", ",", "1", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(4)\"", ",", "name", "=", "\"QA_0\"", ")", "(", "x", ")", "\n", "x", "=", "QConv2D", "(", "\n", "16", ",", "2", ",", "2", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "binary", "(", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "ternary", "(", ")", ",", "\n", "name", "=", "\"qconv2d_1\"", ")", "(", "x", ")", "\n", "x", "=", "QConv2D", "(", "\n", "8", ",", "2", ",", "2", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "activation", "=", "quantizers", ".", "quantized_relu", "(", "6", ",", "2", ")", ",", "\n", "name", "=", "\"qconv2D_2\"", ")", "(", "x", ")", "\n", "x", "=", "QConv2D", "(", "\n", "2", ",", "2", ",", "2", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "activation", "=", "quantizers", ".", "quantized_relu", "(", "6", ",", "2", ")", ",", "\n", "name", "=", "\"qconv2d_3\"", ")", "(", "x", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_bits(6, 0, 1)\"", ",", "name", "=", "\"QA_4\"", ")", "(", "x", ")", "\n", "\n", "model", "=", "keras", ".", "Model", "(", "\n", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.po2_qbits_model": [[97, 108], ["tensorflow.layers.Input", "tensorflow.Model", "qkeras.QActivation", "qkeras.QConv2D", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits"], "function", ["None"], ["", "def", "po2_qbits_model", "(", ")", ":", "\n", "  ", "x", "=", "x_in", "=", "keras", ".", "layers", ".", "Input", "(", "(", "23", ",", "23", ",", "1", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu_po2(3, 2)\"", ",", "name", "=", "\"QA_0\"", ")", "(", "x", ")", "\n", "x", "=", "QConv2D", "(", "\n", "16", ",", "2", ",", "2", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"qconv2d_1\"", ")", "(", "x", ")", "\n", "\n", "model", "=", "keras", ".", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.float_po2_model": [[110, 130], ["tensorflow.layers.Input", "tensorflow.Model", "qkeras.QConv2D", "qkeras.QActivation", "qkeras.QConv2D", "print", "print", "qkeras.quantizers.quantized_po2", "qkeras.quantizers.quantized_po2", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits"], "function", ["None"], ["", "def", "float_po2_model", "(", ")", ":", "\n", "  ", "x", "=", "x_in", "=", "keras", ".", "layers", ".", "Input", "(", "(", "23", ",", "23", ",", "1", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QConv2D", "(", "\n", "16", ",", "2", ",", "2", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_po2", "(", "5", ",", "0", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_po2", "(", "5", ",", "0", ")", ",", "\n", "name", "=", "\"qconv2d_1\"", ")", "(", "x", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu_po2(3, 2)\"", ",", "name", "=", "\"QA_0\"", ")", "(", "x", ")", "\n", "x", "=", "QConv2D", "(", "\n", "10", ",", "2", ",", "2", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "2", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "2", ",", "1", ")", ",", "\n", "name", "=", "\"qconv2d_0\"", ")", "(", "x", ")", "\n", "model", "=", "keras", ".", "Model", "(", "\n", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "\n", "for", "layer", "in", "model", ".", "layers", ":", "\n", "    ", "print", "(", "layer", ")", "\n", "print", "(", "layer", ".", "output_shape", ")", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.qbn_model": [[132, 151], ["qkeras.quantizers.quantized_relu_po2", "qkeras.quantizers.quantized_relu_po2", "tensorflow.layers.Input", "tensorflow.Model", "qkeras.QActivation", "qkeras.QBatchNormalization"], "function", ["None"], ["", "def", "qbn_model", "(", "\n", "act", "=", "\"binary(use_01=0)\"", ",", "\n", "gamma", "=", "quantizers", ".", "quantized_relu_po2", "(", "4", ",", "2", ")", ",", "\n", "variance", "=", "quantizers", ".", "quantized_relu_po2", "(", "4", ",", "2", ")", ",", "\n", "beta", "=", "None", ",", "mean", "=", "None", ")", ":", "\n", "\n", "  ", "x", "=", "x_in", "=", "keras", ".", "layers", ".", "Input", "(", "(", "23", ",", "23", ",", "1", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QActivation", "(", "act", ",", "name", "=", "\"QA_0\"", ")", "(", "x", ")", "\n", "x", "=", "QBatchNormalization", "(", "\n", "gamma_quantizer", "=", "gamma", ",", "\n", "variance_quantizer", "=", "variance", ",", "\n", "beta_quantizer", "=", "beta", ",", "\n", "mean_quantizer", "=", "mean", ",", "\n", "gamma_range", "=", "8", ",", "beta_range", "=", "4", ",", "name", "=", "\"qbn_1\"", ")", "(", "x", ")", "\n", "\n", "model", "=", "keras", ".", "Model", "(", "\n", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.qbn_model_inference": [[153, 207], ["tensorflow.layers.Input", "tensorflow.Model", "keras.Model.compile", "keras.Model.get_layer().set_weights", "keras.Model.get_layer().set_weights", "keras.Model.get_layer().set_weights", "keras.Model.get_layer().set_weights", "qkeras.utils.model_save_quantized_weights", "qkeras.QConv2D", "qkeras.QBatchNormalization", "qkeras.QActivation", "qkeras.QConv2D", "qkeras.QBatchNormalization", "keras.Model.get_layer", "numpy.array", "keras.Model.get_layer", "numpy.array", "numpy.array", "keras.Model.get_layer", "numpy.array", "numpy.array", "keras.Model.get_layer", "numpy.array", "numpy.array", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_save_quantized_weights"], ["", "def", "qbn_model_inference", "(", ")", ":", "\n", "\n", "  ", "x", "=", "x_in", "=", "keras", ".", "layers", ".", "Input", "(", "(", "23", ",", "23", ",", "1", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QConv2D", "(", "\n", "4", ",", "2", ",", "23", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ",", "alpha", "=", "1.0", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ",", "alpha", "=", "1.0", ")", ",", "\n", "use_bias", "=", "False", ",", "\n", "name", "=", "\"qconv2d_1\"", ")", "(", "x", ")", "\n", "x", "=", "QBatchNormalization", "(", "\n", "mean_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "6", ",", "0", ",", "1", ")", ",", "\n", "gamma_quantizer", "=", "None", ",", "\n", "variance_quantizer", "=", "None", ",", "\n", "beta_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "6", ",", "0", ",", "1", ")", ",", "\n", "inverse_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "16", ",", "0", ",", "1", ")", ",", "\n", "scale", "=", "False", ",", "\n", "center", "=", "False", ",", "\n", "gamma_range", "=", "8", ",", "beta_range", "=", "4", ",", "name", "=", "\"qbn_2\"", ")", "(", "x", ")", "\n", "x", "=", "QActivation", "(", "activation", "=", "\"quantized_bits(5, 0, 1)\"", ",", "name", "=", "\"act\"", ")", "(", "x", ")", "\n", "x", "=", "QConv2D", "(", "\n", "2", ",", "1", ",", "1", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "3", ",", "0", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "3", ",", "2", ")", ",", "\n", "name", "=", "\"qconv2d_3\"", ")", "(", "x", ")", "\n", "# Add an extra QNormalization here to test auto_po2 type of inverse_quantizer", "\n", "# in batchnorm fusing.", "\n", "x", "=", "QBatchNormalization", "(", "\n", "mean_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "6", ",", "0", ",", "1", ")", ",", "\n", "gamma_quantizer", "=", "None", ",", "\n", "variance_quantizer", "=", "None", ",", "\n", "beta_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "6", ",", "0", ",", "1", ")", ",", "\n", "inverse_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "8", ",", "0", ",", "1", ",", "alpha", "=", "\"auto_po2\"", ")", ",", "\n", "scale", "=", "False", ",", "\n", "center", "=", "False", ",", "\n", "gamma_range", "=", "8", ",", "beta_range", "=", "4", ",", "name", "=", "\"qbn_4\"", ")", "(", "x", ")", "\n", "\n", "model", "=", "keras", ".", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "model", ".", "compile", "(", "loss", "=", "\"mse\"", ",", "run_eagerly", "=", "True", ")", "\n", "model", ".", "get_layer", "(", "\"qconv2d_1\"", ")", ".", "set_weights", "(", "[", "\n", "np", ".", "array", "(", "[", "[", "[", "[", "0.11", ",", "-", "0.5", ",", "-", "0.14", ",", "-", "0.41", "]", "]", ",", "[", "[", "-", "0.4", ",", "0.9", ",", "0.6", ",", "-", "1.", "]", "]", "]", ",", "\n", "[", "[", "[", "-", "0.35", ",", "1.", ",", "0.54", ",", "0.17", "]", "]", ",", "[", "[", "0.39", ",", "-", "0.2", ",", "-", "0.41", ",", "-", "0.7", "]", "]", "]", "]", ")", "\n", "]", ")", "\n", "model", ".", "get_layer", "(", "\"qbn_2\"", ")", ".", "set_weights", "(", "\n", "[", "np", ".", "array", "(", "[", "0.", ",", "0", ",", "0", ",", "0.", "]", ")", ",", "\n", "np", ".", "array", "(", "[", "1", ",", "1", ",", "1", ",", "1", "]", ")", "]", ")", "\n", "model", ".", "get_layer", "(", "\"qconv2d_3\"", ")", ".", "set_weights", "(", "[", "\n", "np", ".", "array", "(", "[", "[", "[", "[", "1.2", ",", "-", "1.5", "]", ",", "[", "10.", ",", "1.3", "]", ",", "[", "-", "0.7", ",", "1.2", "]", ",", "[", "1.7", ",", "1.5", "]", "]", "]", "]", ")", ",", "\n", "np", ".", "array", "(", "[", "0.7", ",", "0.8", "]", ")", "\n", "]", ")", "\n", "model", ".", "get_layer", "(", "\"qbn_4\"", ")", ".", "set_weights", "(", "\n", "[", "np", ".", "array", "(", "[", "0", ",", "0", "]", ")", ",", "np", ".", "array", "(", "[", "0.3", ",", "16.8", "]", ")", "]", ")", "\n", "\n", "hw_weight_dict", "=", "model_save_quantized_weights", "(", "model", ")", "\n", "return", "(", "hw_weight_dict", ",", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.add_qmodel": [[209, 242], ["tensorflow.layers.Input", "tensorflow.layers.Input", "tensorflow.layers.Input", "tensorflow.layers.add", "tensorflow.Model", "qkeras.QDense", "qkeras.QDense", "qkeras.QDense", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits"], "function", ["None"], ["", "def", "add_qmodel", "(", "quantizer1", ",", "quantizer2", ",", "quantizer3", ")", ":", "\n", "\n", "# Layer that add a list of inputs.", "\n", "# It takes as input a list of tensors, all of the same shape,", "\n", "# and returns a single tensor (also of the same shape).", "\n", "\n", "  ", "x1", "=", "input1", "=", "keras", ".", "layers", ".", "Input", "(", "(", "16", ",", ")", ",", "name", "=", "\"input_0\"", ")", "\n", "x1", "=", "QDense", "(", "\n", "8", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "activation", "=", "quantizer1", ",", "name", "=", "\"dense_0\"", ")", "(", "x1", ")", "\n", "\n", "x2", "=", "input2", "=", "keras", ".", "layers", ".", "Input", "(", "shape", "=", "(", "32", ",", ")", ",", "name", "=", "\"input_1\"", ")", "\n", "x2", "=", "QDense", "(", "\n", "8", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "activation", "=", "quantizer2", ",", "name", "=", "\"dense_1\"", ")", "(", "x2", ")", "\n", "\n", "x3", "=", "input3", "=", "keras", ".", "layers", ".", "Input", "(", "shape", "=", "(", "64", ",", ")", ",", "name", "=", "\"input_2\"", ")", "\n", "x3", "=", "QDense", "(", "\n", "8", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "activation", "=", "quantizer3", ",", "name", "=", "\"dense_2\"", ")", "(", "x3", ")", "\n", "\n", "x", "=", "keras", ".", "layers", ".", "add", "(", "[", "x1", ",", "x2", ",", "x3", "]", ",", "name", "=", "\"add\"", ")", "\n", "\n", "model", "=", "keras", ".", "Model", "(", "\n", "inputs", "=", "[", "input1", ",", "input2", ",", "input3", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.multiply_qmodel": [[244, 278], ["tensorflow.layers.Input", "tensorflow.layers.Input", "tensorflow.layers.Input", "tensorflow.layers.multiply", "tensorflow.Model", "qkeras.QDense", "qkeras.QDense", "qkeras.QDense", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits"], "function", ["None"], ["", "def", "multiply_qmodel", "(", ")", ":", "\n", "\n", "# element-wise multiply a list of inputs.", "\n", "# It takes as input a list of tensors, all of the same shape,", "\n", "# and returns a single tensor (also of the same shape).", "\n", "  ", "x1", "=", "input1", "=", "keras", ".", "layers", ".", "Input", "(", "(", "16", ",", ")", ",", "name", "=", "\"input_0\"", ")", "\n", "x1", "=", "QDense", "(", "\n", "8", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "activation", "=", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"dense_0\"", ")", "(", "x1", ")", "\n", "\n", "x2", "=", "input2", "=", "keras", ".", "layers", ".", "Input", "(", "shape", "=", "(", "32", ",", ")", ",", "name", "=", "\"input_1\"", ")", "\n", "x2", "=", "QDense", "(", "\n", "8", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "activation", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"dense_1\"", ")", "(", "x2", ")", "\n", "\n", "x3", "=", "input3", "=", "keras", ".", "layers", ".", "Input", "(", "shape", "=", "(", "64", ",", ")", ",", "name", "=", "\"input_2\"", ")", "\n", "x3", "=", "QDense", "(", "\n", "8", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "activation", "=", "quantizers", ".", "quantized_bits", "(", "6", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"dense_2\"", ")", "(", "x3", ")", "\n", "\n", "x", "=", "keras", ".", "layers", ".", "multiply", "(", "[", "x1", ",", "x2", ",", "x3", "]", ",", "name", "=", "\"multiply\"", ")", "\n", "model", "=", "keras", ".", "Model", "(", "\n", "inputs", "=", "[", "input1", ",", "input2", ",", "input3", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.pooling_qmodel": [[280, 291], ["tensorflow.layers.Input", "tensorflow.Model", "tensorflow.layers.AveragePooling2D", "tensorflow.layers.GlobalAveragePooling2D"], "function", ["None"], ["", "def", "pooling_qmodel", "(", ")", ":", "\n", "\n", "# Average pooling and global average pooling operation for spatial data.", "\n", "  ", "x", "=", "input1", "=", "keras", ".", "layers", ".", "Input", "(", "(", "16", ",", "16", ",", "3", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "keras", ".", "layers", ".", "AveragePooling2D", "(", "pool_size", "=", "(", "2", ",", "2", ")", ",", "padding", "=", "\"valid\"", ",", "\n", "name", "=", "\"avg_pooling\"", ")", "(", "x", ")", "\n", "x", "=", "keras", ".", "layers", ".", "GlobalAveragePooling2D", "(", "name", "=", "\"global_avg_pooling\"", ")", "(", "x", ")", "\n", "\n", "model", "=", "keras", ".", "Model", "(", "inputs", "=", "[", "input1", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.maximum_qmodel": [[293, 324], ["tensorflow.layers.Input", "tensorflow.layers.Input", "tensorflow.layers.Input", "tensorflow.layers.maximum", "tensorflow.Model", "qkeras.QDense", "qkeras.QDense", "qkeras.QDense", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits"], "function", ["None"], ["", "def", "maximum_qmodel", "(", "quantizer1", ",", "quantizer2", ",", "quantizer3", ")", ":", "\n", "\n", "# element-wise maximum/minimum/average of a list of inputs.", "\n", "# It takes as input a list of tensors, all of the same shape,", "\n", "# and returns a single tensor (also of the same shape).", "\n", "  ", "x1", "=", "input1", "=", "keras", ".", "layers", ".", "Input", "(", "(", "16", ",", ")", ",", "name", "=", "\"input_0\"", ")", "\n", "x1", "=", "QDense", "(", "\n", "8", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "activation", "=", "quantizer1", ",", "name", "=", "\"qdense_0\"", ")", "(", "x1", ")", "\n", "\n", "x2", "=", "input2", "=", "keras", ".", "layers", ".", "Input", "(", "shape", "=", "(", "32", ",", ")", ",", "name", "=", "\"input_1\"", ")", "\n", "x2", "=", "QDense", "(", "\n", "8", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "activation", "=", "quantizer2", ",", "name", "=", "\"dense_1\"", ")", "(", "x2", ")", "\n", "\n", "x3", "=", "input3", "=", "keras", ".", "layers", ".", "Input", "(", "shape", "=", "(", "64", ",", ")", ",", "name", "=", "\"input_2\"", ")", "\n", "x3", "=", "QDense", "(", "\n", "8", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "activation", "=", "quantizer3", ",", "name", "=", "\"dense_2\"", ")", "(", "x3", ")", "\n", "\n", "x", "=", "keras", ".", "layers", ".", "maximum", "(", "[", "x1", ",", "x2", ",", "x3", "]", ",", "name", "=", "\"maximum\"", ")", "\n", "model", "=", "keras", ".", "Model", "(", "\n", "inputs", "=", "[", "input1", ",", "input2", ",", "input3", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.concatenate_qmodel": [[326, 358], ["tensorflow.layers.Input", "tensorflow.layers.Input", "tensorflow.layers.Input", "tensorflow.layers.concatenate", "tensorflow.Model", "qkeras.QConv2D", "qkeras.QConv2D", "qkeras.QConv2D"], "function", ["None"], ["", "def", "concatenate_qmodel", "(", "quantizer1", ",", "quantizer2", ",", "quantizer3", ")", ":", "\n", "\n", "# Layer that concatenates a list of inputs.", "\n", "# It takes as input a list of tensors, all of the same shape except", "\n", "# for the concatenation axis, and returns a single tensor,", "\n", "# the concatenation of all inputs..", "\n", "\n", "  ", "x1", "=", "input1", "=", "keras", ".", "layers", ".", "Input", "(", "(", "16", ",", "16", ",", "1", ")", ",", "name", "=", "\"input_0\"", ")", "\n", "x1", "=", "QConv2D", "(", "\n", "16", ",", "2", ",", "2", ",", "\n", "kernel_quantizer", "=", "quantizer1", ",", "\n", "bias_quantizer", "=", "quantizer1", ",", "\n", "name", "=", "\"conv2d_0\"", ")", "(", "x1", ")", "\n", "\n", "x2", "=", "input2", "=", "keras", ".", "layers", ".", "Input", "(", "(", "16", ",", "16", ",", "1", ")", ",", "name", "=", "\"input_1\"", ")", "\n", "x2", "=", "QConv2D", "(", "\n", "32", ",", "2", ",", "2", ",", "\n", "kernel_quantizer", "=", "quantizer2", ",", "\n", "bias_quantizer", "=", "quantizer2", ",", "\n", "name", "=", "\"conv2d_1\"", ")", "(", "x2", ")", "\n", "\n", "x3", "=", "input3", "=", "keras", ".", "layers", ".", "Input", "(", "(", "16", ",", "16", ",", "1", ")", ",", "name", "=", "\"input_2\"", ")", "\n", "x3", "=", "QConv2D", "(", "\n", "64", ",", "2", ",", "2", ",", "\n", "kernel_quantizer", "=", "quantizer3", ",", "\n", "bias_quantizer", "=", "quantizer3", ",", "\n", "name", "=", "\"conv2d_2\"", ")", "(", "x3", ")", "\n", "\n", "x", "=", "keras", ".", "layers", ".", "concatenate", "(", "[", "x1", ",", "x2", ",", "x3", "]", ",", "axis", "=", "-", "1", ",", "name", "=", "\"concatenate\"", ")", "\n", "model", "=", "keras", ".", "Model", "(", "inputs", "=", "[", "input1", ",", "input2", ",", "input3", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.run": [[360, 379], ["qkeras.qtools.qgraph.CreateGraph", "qkeras.qtools.qgraph.GraphPropagateActivationsToEdges", "qkeras.qtools.generate_layer_data_type_map.generate_layer_data_type_map", "qkeras.qtools.interface.map_to_json", "json.dumps", "print"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.CreateGraph", "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphPropagateActivationsToEdges", "home.repos.pwc.inspect_result.google_qkeras.qtools.generate_layer_data_type_map.generate_layer_data_type_map", "home.repos.pwc.inspect_result.google_qkeras.qtools.interface.map_to_json"], ["", "def", "run", "(", "model", ",", "input_quantizers", ",", "is_inference", "=", "False", ",", "\n", "verbose", "=", "False", ",", "hw_weight_dict", "=", "None", ")", ":", "\n", "  ", "(", "graph", ",", "source_quantizer_list", ")", "=", "qgraph", ".", "CreateGraph", "(", "\n", "model", ",", "input_quantizers", ")", "\n", "# qgraph.PrintGraph(graph)", "\n", "qgraph", ".", "GraphPropagateActivationsToEdges", "(", "graph", ")", "\n", "\n", "layer_map", "=", "generate_layer_data_type_map", ".", "generate_layer_data_type_map", "(", "\n", "graph", "=", "graph", ",", "source_quantizer_list", "=", "source_quantizer_list", ",", "\n", "is_inference", "=", "is_inference", ",", "hw_weight_dict", "=", "hw_weight_dict", ")", "\n", "\n", "# interface.print_layer_data_type_map(dict)", "\n", "output_dict", "=", "interface", ".", "map_to_json", "(", "layer_map", ")", "\n", "\n", "if", "verbose", ":", "\n", "    ", "dict_to_json", "=", "json", ".", "dumps", "(", "output_dict", ",", "indent", "=", "4", ")", "\n", "print", "(", "dict_to_json", ")", "\n", "\n", "", "return", "output_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.test_wrong_input_quantizers": [[381, 407], ["tensorflow.layers.Input", "tensorflow.layers.Input", "tensorflow.layers.add", "tensorflow.Model", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.QDense", "qkeras.QDense", "pytest.raises", "qtools_model_test.run", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.run"], ["", "def", "test_wrong_input_quantizers", "(", ")", ":", "\n", "  ", "input_quantizers", "=", "[", "\n", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "quantizers", ".", "quantized_bits", "(", "6", ",", "0", ",", "1", ")", "\n", "]", "\n", "# INPUT_QUANTIZERS = None", "\n", "x1", "=", "input1", "=", "keras", ".", "layers", ".", "Input", "(", "(", "16", ",", ")", ",", "name", "=", "\"input_0\"", ")", "\n", "x1", "=", "QDense", "(", "\n", "8", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"dense_0\"", ")", "(", "x1", ")", "\n", "x2", "=", "input2", "=", "keras", ".", "layers", ".", "Input", "(", "shape", "=", "(", "32", ",", ")", ",", "name", "=", "\"input_1\"", ")", "\n", "x2", "=", "QDense", "(", "\n", "8", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"dense_1\"", ")", "(", "x2", ")", "\n", "x", "=", "keras", ".", "layers", ".", "add", "(", "[", "x1", ",", "x2", "]", ",", "name", "=", "\"add\"", ")", "\n", "\n", "model", "=", "keras", ".", "Model", "(", "\n", "inputs", "=", "[", "input1", ",", "input2", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "qgraph", ".", "WrongInputQuantizerError", ")", ":", "\n", "    ", "run", "(", "model", ",", "input_quantizers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.test_qbn_inference": [[409, 474], ["qtools_model_test.qbn_model_inference", "qtools_model_test.run", "qkeras.quantizers.quantized_bits"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.qbn_model_inference", "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.run"], ["", "", "def", "test_qbn_inference", "(", ")", ":", "\n", "  ", "input_quantizers", "=", "[", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", "]", "\n", "(", "hw_weight_dict", ",", "model", ")", "=", "qbn_model_inference", "(", ")", "\n", "\n", "dtype_dict", "=", "run", "(", "model", ",", "input_quantizers", ",", "is_inference", "=", "True", ",", "\n", "hw_weight_dict", "=", "hw_weight_dict", ")", "\n", "multiplier", "=", "dtype_dict", "[", "\"qconv2d_1\"", "]", "[", "\"multiplier\"", "]", "\n", "accumulator", "=", "dtype_dict", "[", "\"qconv2d_1\"", "]", "[", "\"accumulator\"", "]", "\n", "output", "=", "dtype_dict", "[", "\"qconv2d_1\"", "]", "[", "\"output_quantizer\"", "]", "\n", "fused_accumulator", "=", "dtype_dict", "[", "\"qconv2d_1\"", "]", "[", "\"fused_accumulator\"", "]", "\n", "\n", "assert", "multiplier", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "multiplier", "[", "\"bits\"", "]", "==", "7", "\n", "assert", "multiplier", "[", "\"int_bits\"", "]", "==", "1", "\n", "assert", "multiplier", "[", "\"is_signed\"", "]", "==", "1", "\n", "assert", "multiplier", "[", "\"op_type\"", "]", "==", "\"mul\"", "\n", "\n", "assert", "accumulator", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "accumulator", "[", "\"bits\"", "]", "==", "9", "\n", "assert", "accumulator", "[", "\"int_bits\"", "]", "==", "3", "\n", "assert", "accumulator", "[", "\"is_signed\"", "]", "==", "1", "\n", "assert", "accumulator", "[", "\"op_type\"", "]", "==", "\"add\"", "\n", "\n", "assert", "fused_accumulator", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "fused_accumulator", "[", "\"bits\"", "]", "==", "25", "\n", "assert", "fused_accumulator", "[", "\"int_bits\"", "]", "==", "4", "\n", "assert", "accumulator", "[", "\"is_signed\"", "]", "==", "1", "\n", "assert", "fused_accumulator", "[", "\"op_type\"", "]", "==", "\"add\"", "\n", "\n", "# Tests auto_po2 type of quantizer in conv2d and batchnorm fusing. Here", "\n", "# we set the layer weights in a way that scale value would be !=1 so that", "\n", "# we need to check bits and int_bits are adjusted properly to incorporate", "\n", "# the scale value.", "\n", "multiplier", "=", "dtype_dict", "[", "\"qconv2d_3\"", "]", "[", "\"multiplier\"", "]", "\n", "accumulator", "=", "dtype_dict", "[", "\"qconv2d_3\"", "]", "[", "\"accumulator\"", "]", "\n", "output", "=", "dtype_dict", "[", "\"qconv2d_3\"", "]", "[", "\"output_quantizer\"", "]", "\n", "fused_accumulator", "=", "dtype_dict", "[", "\"qconv2d_3\"", "]", "[", "\"fused_accumulator\"", "]", "\n", "\n", "# w_bits = 3, w_intbits =0", "\n", "# x_bits = 5, x_intbits =0", "\n", "# weight scale = [[[[16.  2.]]]]", "\n", "# before scale adjustment: m_bits=(3-1)+(5-1)+1=7   m_intbits = 0", "\n", "# after scale adjustment: m_bits=7+(log16-log2)=10  m_intbits = 0+log16=4", "\n", "# Note: dict here added sign bit to the intbit to match hardware format.", "\n", "assert", "multiplier", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "multiplier", "[", "\"bits\"", "]", "==", "10", "\n", "assert", "multiplier", "[", "\"int_bits\"", "]", "==", "5", "\n", "assert", "multiplier", "[", "\"is_signed\"", "]", "==", "1", "\n", "assert", "multiplier", "[", "\"op_type\"", "]", "==", "\"mul\"", "\n", "\n", "assert", "accumulator", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "accumulator", "[", "\"bits\"", "]", "==", "13", "\n", "assert", "accumulator", "[", "\"int_bits\"", "]", "==", "8", "\n", "assert", "accumulator", "[", "\"is_signed\"", "]", "==", "1", "\n", "assert", "accumulator", "[", "\"op_type\"", "]", "==", "\"add\"", "\n", "\n", "# Calculates fused_accumulator according to fused_bn_factory/FusedBNFactory.", "\n", "# For example, wiht inv_quantizer scale:[2. 2.] we have here,", "\n", "# multiplier_x before adjust - bits:19 int_bits:6", "\n", "# multiplier_x after adjust - bits:19 int_bits:7", "\n", "assert", "fused_accumulator", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "fused_accumulator", "[", "\"bits\"", "]", "==", "20", "\n", "assert", "fused_accumulator", "[", "\"int_bits\"", "]", "==", "9", "\n", "assert", "accumulator", "[", "\"is_signed\"", "]", "==", "1", "\n", "assert", "fused_accumulator", "[", "\"op_type\"", "]", "==", "\"add\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.test_invalid_denominator_qbn": [[476, 486], ["qkeras.quantizers.ternary", "qtools_model_test.qbn_model", "pytest.raises", "qtools_model_test.run"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.qbn_model", "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.run"], ["", "def", "test_invalid_denominator_qbn", "(", ")", ":", "\n", "  ", "input_quantizers", "=", "None", "\n", "act", "=", "\"binary(use_01=0)\"", "\n", "gamma", "=", "quantizers", ".", "ternary", "(", ")", "\n", "variance", "=", "gamma", "\n", "model", "=", "qbn_model", "(", "\n", "act", "=", "act", ",", "gamma", "=", "gamma", ",", "variance", "=", "variance", ",", "\n", "beta", "=", "None", ",", "mean", "=", "None", ")", "\n", "with", "pytest", ".", "raises", "(", "divider_factory", ".", "UnacceptedQuantizerError", ")", ":", "\n", "    ", "run", "(", "model", ",", "input_quantizers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.test_conv2d": [[488, 519], ["qkeras.quantizers.quantized_relu_po2", "tensorflow.layers.Input", "tensorflow.Model", "qtools_model_test.run", "qkeras.QActivation", "qkeras.QConv2D"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.run"], ["", "", "def", "test_conv2d", "(", ")", ":", "\n", "  ", "input_quantizers", "=", "None", "\n", "\n", "act", "=", "\"quantized_bits(6, 0, 1)\"", "\n", "weight", "=", "quantizers", ".", "quantized_relu_po2", "(", "4", ",", "2", ")", "\n", "x", "=", "x_in", "=", "keras", ".", "layers", ".", "Input", "(", "(", "23", ",", "23", ",", "1", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QActivation", "(", "act", ",", "name", "=", "\"QA_0\"", ")", "(", "x", ")", "\n", "x", "=", "QConv2D", "(", "\n", "16", ",", "2", ",", "2", ",", "\n", "kernel_quantizer", "=", "weight", ",", "\n", "bias_quantizer", "=", "weight", ",", "\n", "name", "=", "\"qconv2d_1\"", ")", "(", "x", ")", "\n", "\n", "model", "=", "keras", ".", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "\n", "dtype_dict", "=", "run", "(", "model", ",", "input_quantizers", ")", "\n", "multiplier", "=", "dtype_dict", "[", "\"qconv2d_1\"", "]", "[", "\"multiplier\"", "]", "\n", "accumulator", "=", "dtype_dict", "[", "\"qconv2d_1\"", "]", "[", "\"accumulator\"", "]", "\n", "op_count", "=", "dtype_dict", "[", "\"qconv2d_1\"", "]", "[", "\"operation_count\"", "]", "\n", "\n", "assert", "multiplier", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "multiplier", "[", "\"bits\"", "]", "==", "15", "\n", "assert", "multiplier", "[", "\"int_bits\"", "]", "==", "2", "\n", "assert", "multiplier", "[", "\"is_signed\"", "]", "==", "1", "\n", "assert", "multiplier", "[", "\"op_type\"", "]", "==", "\"shifter\"", "\n", "assert", "accumulator", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "accumulator", "[", "\"bits\"", "]", "==", "18", "\n", "assert", "accumulator", "[", "\"int_bits\"", "]", "==", "5", "\n", "assert", "accumulator", "[", "\"is_signed\"", "]", "==", "1", "\n", "assert", "accumulator", "[", "\"op_type\"", "]", "==", "\"add\"", "\n", "assert", "op_count", "==", "7744", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.test_qdense_model_fork": [[521, 539], ["qtools_model_test.qdense_model_fork", "qtools_model_test.run", "qkeras.quantizers.quantized_bits"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.qdense_model_fork", "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.run"], ["", "def", "test_qdense_model_fork", "(", ")", ":", "\n", "  ", "input_quantizers", "=", "[", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", "]", "\n", "model", "=", "qdense_model_fork", "(", ")", "\n", "dtype_dict", "=", "run", "(", "model", ",", "input_quantizers", ")", "\n", "\n", "multiplier", "=", "dtype_dict", "[", "\"qdense_3\"", "]", "[", "\"multiplier\"", "]", "\n", "assert", "multiplier", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "multiplier", "[", "\"bits\"", "]", "==", "5", "\n", "assert", "multiplier", "[", "\"int_bits\"", "]", "==", "1", "\n", "assert", "multiplier", "[", "\"is_signed\"", "]", "==", "1", "\n", "assert", "multiplier", "[", "\"op_type\"", "]", "==", "\"mux\"", "\n", "\n", "accumulator", "=", "dtype_dict", "[", "\"qdense_3\"", "]", "[", "\"accumulator\"", "]", "\n", "assert", "accumulator", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "accumulator", "[", "\"bits\"", "]", "==", "11", "\n", "assert", "accumulator", "[", "\"int_bits\"", "]", "==", "7", "\n", "assert", "accumulator", "[", "\"is_signed\"", "]", "==", "1", "\n", "assert", "accumulator", "[", "\"op_type\"", "]", "==", "\"add\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.test_util_layers": [[541, 580], ["tensorflow.layers.Input", "tensorflow.Model", "qtools_model_test.run", "qkeras.QActivation", "tensorflow.layers.Reshape", "tensorflow.layers.MaxPooling2D", "tensorflow.layers.Flatten", "qkeras.QDense", "qkeras.quantizers.binary", "qkeras.quantizers.binary", "qkeras.quantizers.quantized_po2"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.run"], ["", "def", "test_util_layers", "(", ")", ":", "\n", "  ", "input_quantizers", "=", "None", "# quantizers.quantized_bits(4, 0, 1)", "\n", "\n", "act", "=", "\"quantized_bits(6, 0, 1)\"", "\n", "x", "=", "x_in", "=", "keras", ".", "layers", ".", "Input", "(", "(", "24", ",", "24", ",", "1", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QActivation", "(", "act", ",", "name", "=", "\"QA_0\"", ")", "(", "x", ")", "\n", "x", "=", "keras", ".", "layers", ".", "Reshape", "(", "(", "12", "*", "12", ",", "4", ",", "1", ")", ",", "name", "=", "\"reshape_1\"", ")", "(", "x", ")", "\n", "x", "=", "keras", ".", "layers", ".", "MaxPooling2D", "(", "\n", "pool_size", "=", "(", "2", ",", "2", ")", ",", "name", "=", "\"maxpooling_2\"", ")", "(", "x", ")", "\n", "x", "=", "keras", ".", "layers", ".", "Flatten", "(", "name", "=", "\"flatten_3\"", ")", "(", "x", ")", "\n", "x", "=", "QDense", "(", "\n", "30", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "binary", "(", "use_01", "=", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "binary", "(", "use_01", "=", "1", ")", ",", "\n", "activation", "=", "quantizers", ".", "quantized_po2", "(", "3", ",", "2", ")", ",", "\n", "name", "=", "\"qdense_4\"", ")", "(", "x", ")", "\n", "\n", "model", "=", "keras", ".", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "dtype_dict", "=", "run", "(", "model", ",", "input_quantizers", ")", "\n", "\n", "multiplier", "=", "dtype_dict", "[", "\"qdense_4\"", "]", "[", "\"multiplier\"", "]", "\n", "assert", "multiplier", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "multiplier", "[", "\"bits\"", "]", "==", "6", "\n", "assert", "multiplier", "[", "\"int_bits\"", "]", "==", "1", "\n", "assert", "multiplier", "[", "\"is_signed\"", "]", "==", "1", "\n", "assert", "multiplier", "[", "\"op_type\"", "]", "==", "\"and\"", "\n", "\n", "accumulator", "=", "dtype_dict", "[", "\"qdense_4\"", "]", "[", "\"accumulator\"", "]", "\n", "assert", "accumulator", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "accumulator", "[", "\"bits\"", "]", "==", "15", "\n", "assert", "accumulator", "[", "\"int_bits\"", "]", "==", "10", "\n", "assert", "accumulator", "[", "\"is_signed\"", "]", "==", "1", "\n", "assert", "accumulator", "[", "\"op_type\"", "]", "==", "\"add\"", "\n", "\n", "output", "=", "dtype_dict", "[", "\"qdense_4\"", "]", "[", "\"output_quantizer\"", "]", "\n", "assert", "output", "[", "\"quantizer_type\"", "]", "==", "\"quantized_po2\"", "\n", "assert", "output", "[", "\"bits\"", "]", "==", "3", "\n", "assert", "output", "[", "\"is_signed\"", "]", "==", "1", "\n", "assert", "output", "[", "\"max_value\"", "]", "==", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.test_merge_layers": [[582, 624], ["qtools_model_test.add_qmodel", "qtools_model_test.run", "qtools_model_test.multiply_qmodel", "qtools_model_test.run", "qtools_model_test.maximum_qmodel", "qtools_model_test.run", "qtools_model_test.concatenate_qmodel", "qtools_model_test.run", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.add_qmodel", "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.run", "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.multiply_qmodel", "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.run", "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.maximum_qmodel", "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.run", "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.concatenate_qmodel", "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.run"], ["", "def", "test_merge_layers", "(", ")", ":", "\n", "  ", "input_quantizers", "=", "[", "\n", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "quantizers", ".", "quantized_bits", "(", "6", ",", "0", ",", "1", ")", "]", "\n", "model", "=", "add_qmodel", "(", "\n", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "0", ")", ",", "\n", "quantizers", ".", "quantized_bits", "(", "6", ",", "0", ",", "1", ")", ")", "\n", "dtype_dict", "=", "run", "(", "model", ",", "input_quantizers", ")", "\n", "merge_quantizer", "=", "dtype_dict", "[", "\"add\"", "]", "[", "\"Add_quantizer\"", "]", "\n", "assert", "merge_quantizer", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "merge_quantizer", "[", "\"bits\"", "]", "==", "7", "\n", "assert", "merge_quantizer", "[", "\"int_bits\"", "]", "==", "2", "\n", "assert", "merge_quantizer", "[", "\"is_signed\"", "]", "==", "1", "\n", "\n", "model", "=", "multiply_qmodel", "(", ")", "\n", "dtype_dict", "=", "run", "(", "model", ",", "input_quantizers", ")", "\n", "merge_quantizer", "=", "dtype_dict", "[", "\"multiply\"", "]", "[", "\"Multiply_quantizer\"", "]", "\n", "assert", "merge_quantizer", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "merge_quantizer", "[", "\"bits\"", "]", "==", "13", "\n", "assert", "merge_quantizer", "[", "\"int_bits\"", "]", "==", "1", "\n", "assert", "merge_quantizer", "[", "\"is_signed\"", "]", "==", "1", "\n", "assert", "merge_quantizer", "[", "\"op_type\"", "]", "==", "\"mul\"", "\n", "\n", "model", "=", "maximum_qmodel", "(", "\n", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "0", ")", ",", "\n", "quantizers", ".", "quantized_bits", "(", "6", ",", "0", ",", "1", ")", ")", "\n", "dtype_dict", "=", "run", "(", "model", ",", "input_quantizers", ")", "\n", "merge_quantizer", "=", "dtype_dict", "[", "\"maximum\"", "]", "[", "\"Maximum_quantizer\"", "]", "\n", "assert", "merge_quantizer", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "merge_quantizer", "[", "\"bits\"", "]", "==", "6", "\n", "assert", "merge_quantizer", "[", "\"int_bits\"", "]", "==", "1", "\n", "assert", "merge_quantizer", "[", "\"is_signed\"", "]", "==", "1", "\n", "\n", "model", "=", "concatenate_qmodel", "(", "\n", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "0", ")", ",", "\n", "quantizers", ".", "quantized_bits", "(", "6", ",", "0", ",", "1", ")", ")", "\n", "dtype_dict", "=", "run", "(", "model", ",", "input_quantizers", ")", "\n", "merge_quantizer", "=", "dtype_dict", "[", "\"concatenate\"", "]", "[", "\"Concatenate_quantizer\"", "]", "\n", "assert", "merge_quantizer", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "merge_quantizer", "[", "\"bits\"", "]", "==", "14", "\n", "assert", "merge_quantizer", "[", "\"int_bits\"", "]", "==", "4", "\n", "assert", "merge_quantizer", "[", "\"is_signed\"", "]", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.test_pooling": [[626, 640], ["qtools_model_test.pooling_qmodel", "qtools_model_test.run", "qkeras.quantizers.quantized_bits"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.pooling_qmodel", "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.run"], ["", "def", "test_pooling", "(", ")", ":", "\n", "  ", "input_quantizers", "=", "[", "quantizers", ".", "quantized_bits", "(", "8", ",", "0", ",", "1", ")", "]", "\n", "model", "=", "pooling_qmodel", "(", ")", "\n", "dtype_dict", "=", "run", "(", "model", ",", "input_quantizers", ")", "\n", "\n", "accumulator", "=", "dtype_dict", "[", "\"avg_pooling\"", "]", "[", "\"pool_sum_accumulator\"", "]", "\n", "assert", "accumulator", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "accumulator", "[", "\"bits\"", "]", "==", "10", "\n", "assert", "accumulator", "[", "\"int_bits\"", "]", "==", "3", "\n", "\n", "accumulator", "=", "dtype_dict", "[", "\"global_avg_pooling\"", "]", "[", "\"pool_sum_accumulator\"", "]", "\n", "assert", "accumulator", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "accumulator", "[", "\"bits\"", "]", "==", "16", "\n", "assert", "accumulator", "[", "\"int_bits\"", "]", "==", "9", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.test_qenergy": [[642, 742], ["tensorflow.layers.Input", "tensorflow.Model", "qkeras.qtools.run_qtools.QTools", "run_qtools.QTools.pe", "run_qtools.QTools.extract_energy_sum", "qkeras.qtools.run_qtools.QTools", "run_qtools.QTools.pe", "run_qtools.QTools.extract_energy_sum", "qkeras.QDense", "qkeras.QActivation", "qkeras.QDense", "qkeras.QAdaptiveActivation", "qkeras.QDense", "tensorflow.layers.Activation", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "pytest.approx", "int", "int", "qkeras.quantizers.binary", "qkeras.quantizers.binary", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qtools.run_qtools.QTools.pe", "home.repos.pwc.inspect_result.google_qkeras.qtools.run_qtools.QTools.extract_energy_sum", "home.repos.pwc.inspect_result.google_qkeras.qtools.run_qtools.QTools.pe", "home.repos.pwc.inspect_result.google_qkeras.qtools.run_qtools.QTools.extract_energy_sum"], ["", "def", "test_qenergy", "(", ")", ":", "\n", "  ", "x", "=", "x_in", "=", "keras", ".", "layers", ".", "Input", "(", "(", "784", ",", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QDense", "(", "\n", "300", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "binary", "(", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "binary", "(", ")", ",", "\n", "name", "=", "\"d0\"", ")", "(", "x", ")", "\n", "x", "=", "QActivation", "(", "\"quantized_relu(4,0)\"", ",", "name", "=", "\"d0_qr4\"", ")", "(", "x", ")", "\n", "x", "=", "QDense", "(", "100", ",", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"d1\"", ")", "(", "x", ")", "\n", "x", "=", "QAdaptiveActivation", "(", "\"quantized_relu\"", ",", "4", ",", "name", "=", "\"d1_qr4\"", ")", "(", "x", ")", "\n", "x", "=", "QDense", "(", "\n", "10", ",", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"d2\"", ")", "(", "x", ")", "\n", "x", "=", "keras", ".", "layers", ".", "Activation", "(", "\"softmax\"", ",", "name", "=", "\"softmax\"", ")", "(", "x", ")", "\n", "\n", "model", "=", "keras", ".", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "# print(model.summary())", "\n", "\n", "reference_internal", "=", "\"int8\"", "\n", "reference_accumulator", "=", "\"int32\"", "\n", "\n", "# get reference energy cost", "\n", "q", "=", "run_qtools", ".", "QTools", "(", "\n", "model", ",", "process", "=", "\"horowitz\"", ",", "\n", "source_quantizers", "=", "reference_internal", ",", "\n", "is_inference", "=", "False", ",", "weights_path", "=", "None", ",", "\n", "keras_quantizer", "=", "reference_internal", ",", "\n", "keras_accumulator", "=", "reference_accumulator", ",", "\n", "for_reference", "=", "True", ")", "\n", "\n", "ref_energy_dict", "=", "q", ".", "pe", "(", "\n", "weights_on_memory", "=", "\"sram\"", ",", "\n", "activations_on_memory", "=", "\"sram\"", ",", "\n", "min_sram_size", "=", "8", "*", "16", "*", "1024", "*", "1024", ",", "\n", "rd_wr_on_io", "=", "False", ")", "\n", "reference_size", "=", "q", ".", "extract_energy_sum", "(", "\n", "qtools_settings", ".", "cfg", ".", "include_energy", ",", "ref_energy_dict", ")", "\n", "\n", "# get trial energy cost", "\n", "q", "=", "run_qtools", ".", "QTools", "(", "\n", "model", ",", "process", "=", "\"horowitz\"", ",", "\n", "source_quantizers", "=", "reference_internal", ",", "\n", "is_inference", "=", "False", ",", "weights_path", "=", "None", ",", "\n", "keras_quantizer", "=", "reference_internal", ",", "\n", "keras_accumulator", "=", "reference_accumulator", ",", "\n", "for_reference", "=", "False", ")", "\n", "trial_energy_dict", "=", "q", ".", "pe", "(", "\n", "weights_on_memory", "=", "\"sram\"", ",", "\n", "activations_on_memory", "=", "\"sram\"", ",", "\n", "min_sram_size", "=", "8", "*", "16", "*", "1024", "*", "1024", ",", "\n", "rd_wr_on_io", "=", "False", ")", "\n", "trial_size", "=", "q", ".", "extract_energy_sum", "(", "\n", "qtools_settings", ".", "cfg", ".", "include_energy", ",", "trial_energy_dict", ")", "\n", "\n", "# Reference energy number is now updated with keras_accumulator as", "\n", "# output quantizer", "\n", "tmp", "=", "ref_energy_dict", "[", "\"d0\"", "]", "[", "\"energy\"", "]", "\n", "assert", "tmp", "[", "\"inputs\"", "]", "==", "pytest", ".", "approx", "(", "372.77", ",", "abs", "=", "0.1", ")", "\n", "assert", "tmp", "[", "\"outputs\"", "]", "==", "pytest", ".", "approx", "(", "570.57", ",", "abs", "=", "0.1", ")", "\n", "assert", "tmp", "[", "\"parameters\"", "]", "==", "pytest", ".", "approx", "(", "111975.96", ",", "abs", "=", "0.1", ")", "\n", "assert", "tmp", "[", "\"op_cost\"", "]", "==", "pytest", ".", "approx", "(", "70560.0", ",", "abs", "=", "0.1", ")", "\n", "\n", "tmp", "=", "ref_energy_dict", "[", "\"d1\"", "]", "[", "\"energy\"", "]", "\n", "assert", "tmp", "[", "\"inputs\"", "]", "==", "pytest", ".", "approx", "(", "570.57", ",", "abs", "=", "0.1", ")", "\n", "assert", "tmp", "[", "\"outputs\"", "]", "==", "pytest", ".", "approx", "(", "190.19", ",", "abs", "=", "0.1", ")", "\n", "assert", "tmp", "[", "\"parameters\"", "]", "==", "pytest", ".", "approx", "(", "14313.66", ",", "abs", "=", "0.1", ")", "\n", "assert", "tmp", "[", "\"op_cost\"", "]", "==", "pytest", ".", "approx", "(", "26500.0", ",", "abs", "=", "0.1", ")", "\n", "\n", "tmp", "=", "ref_energy_dict", "[", "\"d2\"", "]", "[", "\"energy\"", "]", "\n", "assert", "tmp", "[", "\"inputs\"", "]", "==", "pytest", ".", "approx", "(", "190.19", ",", "abs", "=", "0.1", ")", "\n", "assert", "tmp", "[", "\"outputs\"", "]", "==", "pytest", ".", "approx", "(", "19.02", ",", "abs", "=", "0.1", ")", "\n", "assert", "tmp", "[", "\"parameters\"", "]", "==", "pytest", ".", "approx", "(", "483.08", ",", "abs", "=", "0.1", ")", "\n", "assert", "tmp", "[", "\"op_cost\"", "]", "==", "pytest", ".", "approx", "(", "883.33", ",", "abs", "=", "0.1", ")", "\n", "\n", "# Trial", "\n", "tmp", "=", "trial_energy_dict", "[", "\"d0\"", "]", "[", "\"energy\"", "]", "\n", "assert", "tmp", "[", "\"inputs\"", "]", "==", "pytest", ".", "approx", "(", "372.77", ",", "abs", "=", "0.1", ")", "\n", "assert", "tmp", "[", "\"outputs\"", "]", "==", "pytest", ".", "approx", "(", "342.34", ",", "abs", "=", "0.1", ")", "\n", "assert", "tmp", "[", "\"parameters\"", "]", "==", "pytest", ".", "approx", "(", "13997.95", ",", "abs", "=", "0.1", ")", "\n", "assert", "tmp", "[", "\"op_cost\"", "]", "==", "pytest", ".", "approx", "(", "15729.0", ",", "abs", "=", "0.1", ")", "\n", "\n", "tmp", "=", "trial_energy_dict", "[", "\"d1\"", "]", "[", "\"energy\"", "]", "\n", "assert", "tmp", "[", "\"inputs\"", "]", "==", "pytest", ".", "approx", "(", "72.27", ",", "abs", "=", "0.1", ")", "\n", "assert", "tmp", "[", "\"outputs\"", "]", "==", "pytest", ".", "approx", "(", "110.31", ",", "abs", "=", "0.1", ")", "\n", "assert", "tmp", "[", "\"parameters\"", "]", "==", "pytest", ".", "approx", "(", "7158.73", ",", "abs", "=", "0.1", ")", "\n", "assert", "tmp", "[", "\"op_cost\"", "]", "==", "pytest", ".", "approx", "(", "3250.0", ",", "abs", "=", "0.1", ")", "\n", "\n", "tmp", "=", "trial_energy_dict", "[", "\"d2\"", "]", "[", "\"energy\"", "]", "\n", "assert", "tmp", "[", "\"inputs\"", "]", "==", "pytest", ".", "approx", "(", "26.63", ",", "abs", "=", "0.1", ")", "\n", "assert", "tmp", "[", "\"outputs\"", "]", "==", "pytest", ".", "approx", "(", "11.41", ",", "abs", "=", "0.1", ")", "\n", "assert", "tmp", "[", "\"parameters\"", "]", "==", "pytest", ".", "approx", "(", "243.44", ",", "abs", "=", "0.1", ")", "\n", "assert", "tmp", "[", "\"op_cost\"", "]", "==", "pytest", ".", "approx", "(", "102.08", ",", "abs", "=", "0.1", ")", "\n", "\n", "# print(ref_energy_dict)", "\n", "# print(trial_energy_dict)", "\n", "assert", "int", "(", "reference_size", ")", "==", "226629", "\n", "assert", "int", "(", "trial_size", ")", "==", "41070", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.test_quntized_reference_energy_same_as_floating_trial": [[744, 836], ["qtools_model_test.test_quntized_reference_energy_same_as_floating_trial.get_model"], "function", ["home.repos.pwc.inspect_result.google_qkeras.run.get_model.get_model"], ["", "def", "test_quntized_reference_energy_same_as_floating_trial", "(", ")", ":", "\n", "# Test if reference energy from quantized model and floating model is the", "\n", "# same", "\n", "  ", "def", "get_model", "(", "quantize", "=", "False", ")", ":", "\n", "    ", "x1", "=", "input1", "=", "keras", ".", "layers", ".", "Input", "(", "(", "16", ",", "16", ",", "3", ")", ",", "name", "=", "\"input_0\"", ")", "\n", "if", "quantize", ":", "\n", "      ", "x1", "=", "QConv2D", "(", "\n", "16", ",", "2", ",", "2", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"conv_0\"", ")", "(", "x1", ")", "\n", "", "else", ":", "\n", "      ", "x1", "=", "keras", ".", "layers", ".", "Conv2D", "(", "16", ",", "2", ",", "2", ",", "name", "=", "\"conv_0\"", ")", "(", "x1", ")", "\n", "\n", "", "x2", "=", "input2", "=", "keras", ".", "layers", ".", "Input", "(", "shape", "=", "(", "16", ",", "16", ",", "3", ")", ",", "name", "=", "\"input_1\"", ")", "\n", "if", "quantize", ":", "\n", "      ", "x2", "=", "QConv2D", "(", "\n", "16", ",", "2", ",", "2", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"conv_1\"", ")", "(", "x2", ")", "\n", "", "else", ":", "\n", "      ", "x2", "=", "keras", ".", "layers", ".", "Conv2D", "(", "16", ",", "2", ",", "2", ",", "name", "=", "\"conv_1\"", ")", "(", "x2", ")", "\n", "\n", "", "x", "=", "keras", ".", "layers", ".", "add", "(", "[", "x1", ",", "x2", "]", ",", "name", "=", "\"add\"", ")", "\n", "if", "quantize", ":", "\n", "      ", "x", "=", "QActivation", "(", "activation", "=", "\"quantized_relu(8, 2)\"", ",", "name", "=", "\"relu\"", ")", "(", "x", ")", "\n", "", "else", ":", "\n", "      ", "x", "=", "keras", ".", "layers", ".", "Activation", "(", "\"relu\"", ",", "name", "=", "\"relu\"", ")", "(", "x", ")", "\n", "\n", "", "if", "quantize", ":", "\n", "      ", "x", "=", "QConv2D", "(", "\n", "2", ",", "2", ",", "2", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "5", ",", "0", ",", "1", ")", ",", "\n", "name", "=", "\"conv_2\"", ")", "(", "x", ")", "\n", "", "else", ":", "\n", "      ", "x", "=", "keras", ".", "layers", ".", "Conv2D", "(", "2", ",", "2", ",", "2", ",", "name", "=", "\"conv_2\"", ")", "(", "x", ")", "\n", "\n", "", "model", "=", "keras", ".", "Model", "(", "inputs", "=", "[", "input1", ",", "input2", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "return", "model", "\n", "\n", "", "def", "get_qenergy", "(", "model", ",", "qenergy_config", ",", "for_reference", ")", ":", "\n", "    ", "q", "=", "run_qtools", ".", "QTools", "(", "\n", "model", ",", "process", "=", "qenergy_config", "[", "\"process\"", "]", ",", "\n", "source_quantizers", "=", "qenergy_config", "[", "\"reference_internal\"", "]", ",", "\n", "is_inference", "=", "qenergy_config", "[", "\"trained_model\"", "]", ",", "\n", "weights_path", "=", "None", ",", "\n", "keras_quantizer", "=", "qenergy_config", "[", "\"reference_internal\"", "]", ",", "\n", "keras_accumulator", "=", "qenergy_config", "[", "\"reference_accumulator\"", "]", ",", "\n", "for_reference", "=", "for_reference", ")", "\n", "\n", "# caculate energy of the derived data type map.", "\n", "energy_dict", "=", "q", ".", "pe", "(", "\n", "weights_on_memory", "=", "qenergy_config", "[", "\"parameters_on_memory\"", "]", ",", "\n", "activations_on_memory", "=", "qenergy_config", "[", "\"activations_on_memory\"", "]", ",", "\n", "min_sram_size", "=", "qenergy_config", "[", "\"min_sram_size\"", "]", ",", "\n", "rd_wr_on_io", "=", "qenergy_config", "[", "\"rd_wr_on_io\"", "]", ")", "\n", "\n", "total_energy", "=", "q", ".", "extract_energy_sum", "(", "qtools_settings", ".", "cfg", ".", "include_energy", ",", "\n", "energy_dict", ")", "\n", "\n", "return", "q", ",", "total_energy", "\n", "\n", "", "qenergy_config", "=", "{", "\n", "\"trained_model\"", ":", "True", ",", "\n", "\"delta_p\"", ":", "8.0", ",", "\n", "\"delta_n\"", ":", "8.0", ",", "\n", "\"rate\"", ":", "2.0", ",", "\n", "\"stress\"", ":", "1.0", ",", "\n", "\"process\"", ":", "\"horowitz\"", ",", "\n", "\"parameters_on_memory\"", ":", "\"sram\"", ",", "\n", "\"activations_on_memory\"", ":", "\"sram\"", ",", "\n", "\"rd_wr_on_io\"", ":", "False", ",", "\n", "\"min_sram_size\"", ":", "0", ",", "\n", "\"source_quantizers\"", ":", "[", "\"quantizers.quantized_bits(8, 0, 1)\"", "]", ",", "\n", "\"reference_internal\"", ":", "\"int8\"", ",", "\n", "\"reference_accumulator\"", ":", "\"int32\"", "\n", "}", "\n", "\n", "float_model", "=", "get_model", "(", "quantize", "=", "False", ")", "\n", "quantized_model", "=", "get_model", "(", "quantize", "=", "True", ")", "\n", "\n", "_", ",", "float_reference_energy", "=", "get_qenergy", "(", "\n", "float_model", ",", "qenergy_config", ",", "for_reference", "=", "False", ")", "\n", "_", ",", "float_trial_energy", "=", "get_qenergy", "(", "\n", "float_model", ",", "qenergy_config", ",", "for_reference", "=", "True", ")", "\n", "_", ",", "quantized_reference_energy", "=", "get_qenergy", "(", "\n", "quantized_model", ",", "qenergy_config", ",", "for_reference", "=", "True", ")", "\n", "\n", "assert", "float_reference_energy", "==", "quantized_reference_energy", "\n", "assert", "float_reference_energy", "==", "float_trial_energy", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.test_auto_po2": [[838, 898], ["qtools_model_test.test_auto_po2.gen_model"], "function", ["None"], ["", "def", "test_auto_po2", "(", ")", ":", "\n", "  ", "def", "gen_model", "(", "img_shape", ")", ":", "\n", "    ", "img_input", "=", "x", "=", "keras", ".", "Input", "(", "shape", "=", "img_shape", ")", "\n", "x", "=", "QConv2D", "(", "\n", "filters", "=", "5", ",", "kernel_size", "=", "4", ",", "strides", "=", "4", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "8", ",", "3", ",", "alpha", "=", "\"auto_po2\"", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "8", ",", "3", ")", ",", "\n", "name", "=", "\"conv\"", ")", "(", "x", ")", "\n", "x", "=", "QActivation", "(", "activation", "=", "quantizers", ".", "quantized_relu", "(", "4", ",", "0", ")", ",", "name", "=", "\"act\"", ")", "(", "x", ")", "\n", "x", "=", "keras", ".", "layers", ".", "Flatten", "(", "name", "=", "\"flatten\"", ")", "(", "x", ")", "\n", "x", "=", "QDense", "(", "5", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "\n", "8", ",", "0", ",", "alpha", "=", "\"auto_po2\"", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "8", ",", "3", ")", ",", "\n", "name", "=", "\"dense\"", ")", "(", "x", ")", "\n", "model", "=", "keras", ".", "Model", "(", "inputs", "=", "img_input", ",", "outputs", "=", "[", "x", "]", ")", "\n", "return", "model", "\n", "\n", "", "model", "=", "gen_model", "(", "(", "32", ",", "32", ",", "3", ",", ")", ")", "\n", "model", ".", "compile", "(", "loss", "=", "\"mse\"", ",", "run_eagerly", "=", "True", ")", "\n", "model", ".", "layers", "[", "1", "]", ".", "quantizers", "[", "0", "]", ".", "scale", "=", "tf", ".", "constant", "(", "\n", "[", "[", "[", "[", "0.0625", ",", "0.0625", ",", "0.0625", ",", "0.0625", ",", "0.03125", "]", "]", "]", "]", ")", "\n", "model", ".", "layers", "[", "4", "]", ".", "quantizers", "[", "0", "]", ".", "scale", "=", "tf", ".", "constant", "(", "[", "[", "0.5", ",", "0.5", ",", "1", ",", "0.5", ",", "0.25", "]", "]", ")", "\n", "input_quantizers", "=", "[", "\n", "quantizers", ".", "quantized_bits", "(", "bits", "=", "8", ",", "integer", "=", "0", ",", "keep_negative", "=", "False", ")", "\n", "]", "\n", "dtype_dict", "=", "run", "(", "model", ",", "input_quantizers", ")", "\n", "\n", "# Original multiplier has 16 bits(16=8+8) and 3 int_bits", "\n", "multiplier", "=", "dtype_dict", "[", "\"conv\"", "]", "[", "\"multiplier\"", "]", "\n", "assert", "multiplier", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "multiplier", "[", "\"bits\"", "]", "==", "16", "\n", "assert", "multiplier", "[", "\"int_bits\"", "]", "==", "4", "\n", "\n", "# Original accumulator has 16+log2(4*4*3)+1 bits,", "\n", "# and 4+log2(4*4*3)+1 int_bits", "\n", "accumulator", "=", "dtype_dict", "[", "\"conv\"", "]", "[", "\"accumulator\"", "]", "\n", "assert", "accumulator", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "accumulator", "[", "\"bits\"", "]", "==", "23", "\n", "assert", "accumulator", "[", "\"int_bits\"", "]", "==", "11", "\n", "\n", "# adjusting multiplier with auto_po2:", "\n", "# bits = max_fractional_bits + max_int_bits = bits + max_shift - min_shift", "\n", "# max_shift = log2(0.0625) = -4", "\n", "# min_shift=log2(0.03125) = -5", "\n", "# So adjusted multiplier bits=17, 1 bit bigger than original multiplier.", "\n", "# Modified multiplier int_bits = int_bits + max_shift = 3 - 4 = -1", "\n", "# Because in datatype map we add int_bits with 1 extra sign bit,", "\n", "# adjusted multiplier int_bits = 0, 4 bit smaller than original multiplier.", "\n", "# When we pass the adjusted multiplier to fused_accumulator, we", "\n", "# get bits = 23+1=24, and int_bits = 11-4=7", "\n", "fused_accumulator", "=", "dtype_dict", "[", "\"conv\"", "]", "[", "\"fused_accumulator\"", "]", "\n", "assert", "fused_accumulator", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "fused_accumulator", "[", "\"bits\"", "]", "==", "24", "\n", "assert", "fused_accumulator", "[", "\"int_bits\"", "]", "==", "7", "\n", "\n", "multiplier", "=", "dtype_dict", "[", "\"dense\"", "]", "[", "\"multiplier\"", "]", "\n", "assert", "multiplier", "[", "\"quantizer_type\"", "]", "==", "\"quantized_bits\"", "\n", "assert", "multiplier", "[", "\"bits\"", "]", "==", "12", "\n", "assert", "multiplier", "[", "\"int_bits\"", "]", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.test_big_bias_quantizer": [[900, 911], ["qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits", "quantizer_impl.QuantizedBits.convert_qkeras_quantizer", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits", "quantizer_impl.QuantizedBits.convert_qkeras_quantizer", "qkeras.qtools.quantized_operators.adder_impl.FixedPointAdder", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits"], "function", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_qkeras_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_qkeras_quantizer"], ["", "def", "test_big_bias_quantizer", "(", ")", ":", "\n", "  ", "q1", "=", "quantizer_impl", ".", "QuantizedBits", "(", ")", "\n", "q1", ".", "convert_qkeras_quantizer", "(", "quantizers", ".", "quantized_bits", "(", "8", ",", "3", ")", ")", "\n", "q2", "=", "quantizer_impl", ".", "QuantizedBits", "(", ")", "\n", "q2", ".", "convert_qkeras_quantizer", "(", "quantizers", ".", "quantized_bits", "(", "16", ",", "4", ")", ")", "\n", "r", "=", "adder_impl", ".", "FixedPointAdder", "(", "q1", ",", "q2", ")", "\n", "\n", "# int_bits = max(q1.int_bits, q2.int_bits) + 1", "\n", "# bits = int_bits + sign_bit + max(q1_fraction_bit, q2_fraction bit)", "\n", "assert", "r", ".", "output", ".", "bits", "==", "17", "\n", "assert", "r", ".", "output", ".", "int_bits", "==", "5", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.test_qdepthwiseconv2d": [[913, 947], ["tensorflow.layers.Input", "tensorflow.Model", "qtools_model_test.run", "qkeras.QDepthwiseConv2D", "qkeras.QConv2D", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits", "qkeras.quantizers.quantized_bits"], "function", ["home.repos.pwc.inspect_result.google_qkeras.tests.qtools_model_test.run"], ["", "def", "test_qdepthwiseconv2d", "(", ")", ":", "\n", "  ", "x", "=", "x_in", "=", "keras", ".", "layers", ".", "Input", "(", "(", "64", ",", "64", ",", "3", ")", ",", "name", "=", "\"input\"", ")", "\n", "x", "=", "QDepthwiseConv2D", "(", "\n", "kernel_size", "=", "(", "1", ",", "7", ")", ",", "\n", "depthwise_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "8", ",", "0", ",", "1", ",", "alpha", "=", "1.0", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "12", ",", "6", ",", "1", ",", "alpha", "=", "1.0", ")", ",", "\n", "name", "=", "\"dw_conv\"", ")", "(", "x", ")", "\n", "x", "=", "QConv2D", "(", "\n", "filters", "=", "16", ",", "\n", "kernel_size", "=", "(", "1", ",", "1", ")", ",", "\n", "bias_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "12", ",", "4", ",", "1", ",", "alpha", "=", "1.0", ")", ",", "\n", "kernel_quantizer", "=", "quantizers", ".", "quantized_bits", "(", "4", ",", "0", ",", "1", ",", "alpha", "=", "1.0", ")", ",", "\n", "name", "=", "\"pw_conv\"", ")", "(", "x", ")", "\n", "\n", "model", "=", "keras", ".", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "\n", "input_quantizers", "=", "[", "quantizers", ".", "quantized_bits", "(", "8", ",", "0", ",", "1", ")", "]", "\n", "dtype_dict", "=", "run", "(", "model", ",", "input_quantizers", ")", "\n", "\n", "# multiplier_int_bits = 0(x_int_bits) + 0(w_int_bits) = 0 (excluding sign_bit)", "\n", "# multiplier_fractional_bits = 7(x_fractional) + 7(w_fractional) = 14", "\n", "# multiplier_bits = 0 + 14 + sign_bit = 15", "\n", "assert", "dtype_dict", "[", "\"dw_conv\"", "]", "[", "\"multiplier\"", "]", "[", "\"bits\"", "]", "==", "15", "\n", "assert", "dtype_dict", "[", "\"dw_conv\"", "]", "[", "\"multiplier\"", "]", "[", "\"int_bits\"", "]", "==", "1", "\n", "# accumulator_int_bits = max(bias_int_bits, log7 + 0) + 1 = 7", "\n", "# accumulator_fractional_bits = max(bias_fractional, 14) = 14", "\n", "# accumulator_bits = int_bits + fractional_bits + sign_bit = 22", "\n", "assert", "dtype_dict", "[", "\"dw_conv\"", "]", "[", "\"accumulator\"", "]", "[", "\"bits\"", "]", "==", "22", "\n", "assert", "dtype_dict", "[", "\"dw_conv\"", "]", "[", "\"accumulator\"", "]", "[", "\"int_bits\"", "]", "==", "8", "\n", "\n", "assert", "dtype_dict", "[", "\"pw_conv\"", "]", "[", "\"multiplier\"", "]", "[", "\"bits\"", "]", "==", "25", "\n", "assert", "dtype_dict", "[", "\"pw_conv\"", "]", "[", "\"multiplier\"", "]", "[", "\"int_bits\"", "]", "==", "8", "\n", "assert", "dtype_dict", "[", "\"pw_conv\"", "]", "[", "\"accumulator\"", "]", "[", "\"bits\"", "]", "==", "28", "\n", "assert", "dtype_dict", "[", "\"pw_conv\"", "]", "[", "\"accumulator\"", "]", "[", "\"int_bits\"", "]", "==", "11", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.test_forgiving_factor.get_model": [[26, 46], ["Input", "tensorflow.keras.models.Model", "Conv2D", "BatchNormalization", "Activation", "MaxPooling2D", "QConv2D", "QBatchNormalization", "QActivation", "MaxPooling2D", "QConv2D", "Flatten", "Dense"], "function", ["None"], ["def", "get_model", "(", ")", ":", "\n", "  ", "\"\"\"Returns sample model.\"\"\"", "\n", "xi", "=", "Input", "(", "(", "28", ",", "28", ",", "1", ")", ",", "name", "=", "\"input\"", ")", "# pylint: disable=undefined-variable", "\n", "x", "=", "Conv2D", "(", "32", ",", "3", ",", "strides", "=", "1", ",", "padding", "=", "\"same\"", ",", "name", "=", "\"c1\"", ")", "(", "xi", ")", "# pylint: disable=undefined-variable", "\n", "x", "=", "BatchNormalization", "(", "name", "=", "\"b1\"", ")", "(", "x", ")", "# pylint: disable=undefined-variable", "\n", "x", "=", "Activation", "(", "\"relu\"", ",", "name", "=", "\"a1\"", ")", "(", "x", ")", "# pylint: disable=undefined-variable", "\n", "x", "=", "MaxPooling2D", "(", "2", ",", "2", ",", "name", "=", "\"mp1\"", ")", "(", "x", ")", "# pylint: disable=undefined-variable", "\n", "x", "=", "QConv2D", "(", "32", ",", "3", ",", "kernel_quantizer", "=", "\"binary\"", ",", "bias_quantizer", "=", "\"binary\"", ",", "# pylint: disable=undefined-variable", "\n", "strides", "=", "1", ",", "padding", "=", "\"same\"", ",", "name", "=", "\"c2\"", ")", "(", "x", ")", "\n", "x", "=", "QBatchNormalization", "(", "name", "=", "\"b2\"", ")", "(", "x", ")", "# pylint: disable=undefined-variable", "\n", "x", "=", "QActivation", "(", "\"binary\"", ",", "name", "=", "\"a2\"", ")", "(", "x", ")", "# pylint: disable=undefined-variable", "\n", "x", "=", "MaxPooling2D", "(", "2", ",", "2", ",", "name", "=", "\"mp2\"", ")", "(", "x", ")", "# pylint: disable=undefined-variable", "\n", "x", "=", "QConv2D", "(", "32", ",", "3", ",", "kernel_quantizer", "=", "\"ternary\"", ",", "bias_quantizer", "=", "\"ternary\"", ",", "# pylint: disable=undefined-variable", "\n", "strides", "=", "1", ",", "padding", "=", "\"same\"", ",", "activation", "=", "\"binary\"", ",", "name", "=", "\"c3\"", ")", "(", "x", ")", "\n", "x", "=", "Flatten", "(", "name", "=", "\"flatten\"", ")", "(", "x", ")", "# pylint: disable=undefined-variable", "\n", "x", "=", "Dense", "(", "1", ",", "name", "=", "\"dense\"", ",", "activation", "=", "\"softmax\"", ")", "(", "x", ")", "# pylint: disable=undefined-variable", "\n", "\n", "model", "=", "Model", "(", "inputs", "=", "xi", ",", "outputs", "=", "x", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.test_forgiving_factor.test_forgiving_factor_bits": [[48, 88], ["test_forgiving_factor.get_model", "qkeras.autoqkeras.forgiving_metrics.ForgivingFactorBits", "qkeras.autoqkeras.forgiving_metrics.ForgivingFactorBits.compute_model_size"], "function", ["home.repos.pwc.inspect_result.google_qkeras.run.get_model.get_model", "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits.compute_model_size"], ["", "def", "test_forgiving_factor_bits", "(", ")", ":", "\n", "  ", "\"\"\"Tests forgiving factor bits.\"\"\"", "\n", "delta_p", "=", "8.0", "\n", "delta_n", "=", "8.0", "\n", "rate", "=", "2.0", "\n", "stress", "=", "1.0", "\n", "input_bits", "=", "8", "\n", "output_bits", "=", "8", "\n", "ref_bits", "=", "8", "\n", "\n", "config", "=", "{", "\n", "\"QDense\"", ":", "[", "\"parameters\"", ",", "\"activations\"", "]", ",", "\n", "\"Dense\"", ":", "[", "\"parameters\"", ",", "\"activations\"", "]", ",", "\n", "\"QConv2D\"", ":", "[", "\"parameters\"", ",", "\"activations\"", "]", ",", "\n", "\"Conv2D\"", ":", "[", "\"parameters\"", ",", "\"activations\"", "]", ",", "\n", "\"DepthwiseConv2D\"", ":", "[", "\"parameters\"", ",", "\"activations\"", "]", ",", "\n", "\"QDepthwiseConv2D\"", ":", "[", "\"parameters\"", ",", "\"activations\"", "]", ",", "\n", "\"Activation\"", ":", "[", "\"activations\"", "]", ",", "\n", "\"QActivation\"", ":", "[", "\"activations\"", "]", ",", "\n", "\"QBatchNormalization\"", ":", "[", "\"parameters\"", "]", ",", "\n", "\"BatchNormalization\"", ":", "[", "\"parameters\"", "]", ",", "\n", "\"default\"", ":", "[", "\"activations\"", "]", ",", "\n", "}", "\n", "\n", "model", "=", "get_model", "(", ")", "\n", "\n", "ffb", "=", "ForgivingFactorBits", "(", "\n", "delta_p", ",", "delta_n", ",", "rate", ",", "stress", ",", "\n", "input_bits", ",", "output_bits", ",", "ref_bits", ",", "\n", "config", "\n", ")", "\n", "\n", "cached_result", "=", "ffb", ".", "compute_model_size", "(", "model", ")", "\n", "ref_size", "=", "cached_result", "[", "0", "]", "\n", "ref_p", "=", "cached_result", "[", "1", "]", "\n", "ref_a", "=", "cached_result", "[", "2", "]", "\n", "\n", "assert", "ref_size", "==", "258544", "\n", "assert", "ref_p", "==", "43720", "\n", "assert", "ref_a", "==", "214824", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.tests.test_forgiving_factor.test_new_forgiving_factor": [[90, 148], ["test_forgiving_factor.get_model", "qkeras.autoqkeras.forgiving_metrics.ForgivingFactorBits", "qkeras.autoqkeras.forgiving_metrics.ForgivingFactorBits.compute_model_size", "qkeras.utils.model_quantize", "qkeras.autoqkeras.forgiving_metrics.ForgivingFactorBits.compute_model_size"], "function", ["home.repos.pwc.inspect_result.google_qkeras.run.get_model.get_model", "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits.compute_model_size", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize", "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits.compute_model_size"], ["", "def", "test_new_forgiving_factor", "(", ")", ":", "\n", "  ", "\"\"\"Tests forgiving factor.\"\"\"", "\n", "delta_p", "=", "8.0", "\n", "delta_n", "=", "8.0", "\n", "rate", "=", "2.0", "\n", "stress", "=", "1.0", "\n", "input_bits", "=", "8", "\n", "output_bits", "=", "8", "\n", "ref_bits", "=", "8", "\n", "\n", "config", "=", "{", "\n", "\"QDense\"", ":", "[", "\"parameters\"", ",", "\"activations\"", "]", ",", "\n", "\"Dense\"", ":", "[", "\"parameters\"", ",", "\"activations\"", "]", ",", "\n", "\"QConv2D\"", ":", "[", "\"parameters\"", ",", "\"activations\"", "]", ",", "\n", "\"Conv2D\"", ":", "[", "\"parameters\"", ",", "\"activations\"", "]", ",", "\n", "\"DepthwiseConv2D\"", ":", "[", "\"parameters\"", ",", "\"activations\"", "]", ",", "\n", "\"QDepthwiseConv2D\"", ":", "[", "\"parameters\"", ",", "\"activations\"", "]", ",", "\n", "\"Activation\"", ":", "[", "\"activations\"", "]", ",", "\n", "\"QActivation\"", ":", "[", "\"activations\"", "]", ",", "\n", "\"QBatchNormalization\"", ":", "[", "\"parameters\"", "]", ",", "\n", "\"BatchNormalization\"", ":", "[", "\"parameters\"", "]", ",", "\n", "\"default\"", ":", "[", "\"activations\"", "]", "\n", "}", "\n", "\n", "model", "=", "get_model", "(", ")", "\n", "\n", "ffb", "=", "ForgivingFactorBits", "(", "\n", "delta_p", ",", "delta_n", ",", "rate", ",", "stress", ",", "\n", "input_bits", ",", "output_bits", ",", "ref_bits", ",", "\n", "config", "\n", ")", "\n", "\n", "cached_result", "=", "ffb", ".", "compute_model_size", "(", "model", ")", "\n", "ref_size", "=", "cached_result", "[", "0", "]", "\n", "ref_p", "=", "cached_result", "[", "1", "]", "\n", "ref_a", "=", "cached_result", "[", "2", "]", "\n", "ref_size_dict", "=", "cached_result", "[", "3", "]", "\n", "\n", "assert", "ref_size", "==", "258544", "\n", "assert", "ref_p", "==", "43720", "\n", "assert", "ref_a", "==", "214824", "\n", "\n", "q_dict", "=", "{", "\n", "\"c1\"", ":", "{", "\n", "\"kernel_quantizer\"", ":", "\"binary\"", ",", "\n", "\"bias_quantizer\"", ":", "\"quantized_bits(4)\"", "\n", "}", "\n", "}", "\n", "\n", "q_model", "=", "model_quantize", "(", "model", ",", "q_dict", ",", "4", ")", "\n", "\n", "cached_result", "=", "ffb", ".", "compute_model_size", "(", "q_model", ")", "\n", "trial_size_dict", "=", "cached_result", "[", "3", "]", "\n", "\n", "for", "name", "in", "trial_size_dict", ":", "\n", "    ", "if", "name", "!=", "\"c1\"", ":", "\n", "      ", "assert", "trial_size_dict", "[", "name", "]", "==", "ref_size_dict", "[", "name", "]", "\n", "", "", "assert", "trial_size_dict", "[", "\"c1\"", "]", "[", "\"parameters\"", "]", "==", "416", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNNCell.__init__": [[62, 139], ["quantizers.get_quantizer", "quantizers.get_quantizer", "quantizers.get_quantizer", "quantizers.get_quantizer", "hasattr", "hasattr", "qlayers.get_auto_range_constraint_initializer", "qlayers.get_auto_range_constraint_initializer", "tensorflow.keras.layers.SimpleRNNCell.__init__", "qrecurrent.QSimpleRNNCell.kernel_quantizer_internal._set_trainable_parameter", "qrecurrent.QSimpleRNNCell.recurrent_quantizer_internal._set_trainable_parameter", "qlayers.get_auto_range_constraint_initializer", "quantizers.get_quantizer"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary._set_trainable_parameter", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary._set_trainable_parameter", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer"], ["def", "__init__", "(", "self", ",", "\n", "units", ",", "\n", "activation", "=", "'quantized_tanh'", ",", "\n", "use_bias", "=", "True", ",", "\n", "kernel_initializer", "=", "'glorot_uniform'", ",", "\n", "recurrent_initializer", "=", "'orthogonal'", ",", "\n", "bias_initializer", "=", "'zeros'", ",", "\n", "kernel_regularizer", "=", "None", ",", "\n", "recurrent_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "kernel_constraint", "=", "None", ",", "\n", "recurrent_constraint", "=", "None", ",", "\n", "bias_constraint", "=", "None", ",", "\n", "kernel_quantizer", "=", "None", ",", "\n", "recurrent_quantizer", "=", "None", ",", "\n", "bias_quantizer", "=", "None", ",", "\n", "state_quantizer", "=", "None", ",", "\n", "dropout", "=", "0.", ",", "\n", "recurrent_dropout", "=", "0.", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "    ", "self", ".", "kernel_quantizer", "=", "kernel_quantizer", "\n", "self", ".", "recurrent_quantizer", "=", "recurrent_quantizer", "\n", "self", ".", "bias_quantizer", "=", "bias_quantizer", "\n", "self", ".", "state_quantizer", "=", "state_quantizer", "\n", "\n", "self", ".", "kernel_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "kernel_quantizer", ")", "\n", "self", ".", "recurrent_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "recurrent_quantizer", ")", "\n", "self", ".", "bias_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "bias_quantizer", ")", "\n", "self", ".", "state_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "state_quantizer", ")", "\n", "\n", "self", ".", "quantizers", "=", "[", "\n", "self", ".", "kernel_quantizer_internal", ",", "self", ".", "recurrent_quantizer_internal", ",", "\n", "self", ".", "bias_quantizer_internal", ",", "self", ".", "state_quantizer_internal", "\n", "]", "\n", "\n", "if", "hasattr", "(", "self", ".", "kernel_quantizer_internal", ",", "\"_set_trainable_parameter\"", ")", ":", "\n", "      ", "self", ".", "kernel_quantizer_internal", ".", "_set_trainable_parameter", "(", ")", "\n", "\n", "", "if", "hasattr", "(", "self", ".", "recurrent_quantizer_internal", ",", "\"_set_trainable_parameter\"", ")", ":", "\n", "      ", "self", ".", "recurrent_quantizer_internal", ".", "_set_trainable_parameter", "(", ")", "\n", "\n", "", "kernel_constraint", ",", "kernel_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "kernel_quantizer_internal", ",", "\n", "kernel_constraint", ",", "\n", "kernel_initializer", ")", ")", "\n", "\n", "recurrent_constraint", ",", "recurrent_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "recurrent_quantizer_internal", ",", "\n", "recurrent_constraint", ",", "\n", "recurrent_initializer", ")", ")", "\n", "\n", "if", "use_bias", ":", "\n", "      ", "bias_constraint", ",", "bias_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "bias_quantizer_internal", ",", "\n", "bias_constraint", ",", "\n", "bias_initializer", ")", ")", "\n", "\n", "", "if", "activation", "is", "not", "None", ":", "\n", "      ", "activation", "=", "get_quantizer", "(", "activation", ")", "\n", "\n", "", "super", "(", "QSimpleRNNCell", ",", "self", ")", ".", "__init__", "(", "\n", "units", "=", "units", ",", "\n", "activation", "=", "activation", ",", "\n", "use_bias", "=", "use_bias", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "recurrent_initializer", "=", "recurrent_initializer", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "recurrent_regularizer", "=", "recurrent_regularizer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "recurrent_constraint", "=", "recurrent_constraint", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "dropout", "=", "dropout", ",", "\n", "recurrent_dropout", "=", "recurrent_dropout", ",", "\n", "**", "kwargs", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNNCell.call": [[141, 184], ["qrecurrent.QSimpleRNNCell.get_dropout_mask_for_cell", "qrecurrent.QSimpleRNNCell.get_recurrent_dropout_mask_for_cell", "tensorflow.python.util.nest.is_sequence", "tensorflow.python.util.nest.is_sequence", "qrecurrent.QSimpleRNNCell.state_quantizer_internal", "qrecurrent.QSimpleRNNCell.kernel_quantizer_internal", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.bias_add", "tensorflow.bias_add", "qrecurrent.QSimpleRNNCell.recurrent_quantizer_internal", "tensorflow.dot", "tensorflow.dot", "qrecurrent.QSimpleRNNCell.activation", "qrecurrent.QSimpleRNNCell.bias_quantizer_internal"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.state_quantizer_internal", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.kernel_quantizer_internal", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.recurrent_quantizer_internal", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QBidirectional.activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.bias_quantizer_internal"], ["", "def", "call", "(", "self", ",", "inputs", ",", "states", ",", "training", "=", "None", ")", ":", "\n", "    ", "prev_output", "=", "states", "[", "0", "]", "if", "nest", ".", "is_sequence", "(", "states", ")", "else", "states", "\n", "\n", "dp_mask", "=", "self", ".", "get_dropout_mask_for_cell", "(", "inputs", ",", "training", ")", "\n", "rec_dp_mask", "=", "self", ".", "get_recurrent_dropout_mask_for_cell", "(", "\n", "prev_output", ",", "training", ")", "\n", "\n", "if", "self", ".", "state_quantizer", ":", "\n", "      ", "quantized_prev_output", "=", "self", ".", "state_quantizer_internal", "(", "prev_output", ")", "\n", "", "else", ":", "\n", "      ", "quantized_prev_output", "=", "prev_output", "\n", "\n", "", "if", "self", ".", "kernel_quantizer", ":", "\n", "      ", "quantized_kernel", "=", "self", ".", "kernel_quantizer_internal", "(", "self", ".", "kernel", ")", "\n", "", "else", ":", "\n", "      ", "quantized_kernel", "=", "self", ".", "kernel", "\n", "\n", "", "if", "dp_mask", "is", "not", "None", ":", "\n", "      ", "h", "=", "K", ".", "dot", "(", "inputs", "*", "dp_mask", ",", "quantized_kernel", ")", "\n", "", "else", ":", "\n", "      ", "h", "=", "K", ".", "dot", "(", "inputs", ",", "quantized_kernel", ")", "\n", "\n", "", "if", "self", ".", "bias", "is", "not", "None", ":", "\n", "      ", "if", "self", ".", "bias_quantizer", ":", "\n", "        ", "quantized_bias", "=", "self", ".", "bias_quantizer_internal", "(", "self", ".", "bias", ")", "\n", "", "else", ":", "\n", "        ", "quantized_bias", "=", "self", ".", "bias", "\n", "\n", "", "h", "=", "K", ".", "bias_add", "(", "h", ",", "quantized_bias", ")", "\n", "\n", "", "if", "rec_dp_mask", "is", "not", "None", ":", "\n", "      ", "quantized_prev_output", "=", "quantized_prev_output", "*", "rec_dp_mask", "\n", "\n", "", "if", "self", ".", "recurrent_quantizer", ":", "\n", "      ", "quantized_recurrent", "=", "self", ".", "recurrent_quantizer_internal", "(", "self", ".", "recurrent_kernel", ")", "\n", "", "else", ":", "\n", "      ", "quantized_recurrent", "=", "self", ".", "recurrent_kernel", "\n", "\n", "", "output", "=", "h", "+", "K", ".", "dot", "(", "quantized_prev_output", ",", "quantized_recurrent", ")", "\n", "\n", "if", "self", ".", "activation", "is", "not", "None", ":", "\n", "      ", "output", "=", "self", ".", "activation", "(", "output", ")", "\n", "", "return", "output", ",", "[", "output", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNNCell.get_config": [[185, 198], ["super().get_config", "dict", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "list", "list", "super().get_config.items", "config.items"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "\"kernel_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "kernel_quantizer_internal", ")", ",", "\n", "\"recurrent_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "recurrent_quantizer_internal", ")", ",", "\n", "\"bias_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "bias_quantizer_internal", ")", ",", "\n", "\"state_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "state_quantizer_internal", ")", "\n", "}", "\n", "base_config", "=", "super", "(", "QSimpleRNNCell", ",", "self", ")", ".", "get_config", "(", ")", "\n", "return", "dict", "(", "list", "(", "base_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.__init__": [[220, 286], ["qrecurrent.QSimpleRNNCell", "tensorflow.keras.layers.RNN.__init__", "tensorflow.keras.regularizers.get", "tensorflow.keras.regularizers.get", "tensorflow.keras.layers.InputSpec", "tensorflow.keras.layers.InputSpec", "kwargs.pop", "kwargs.get", "kwargs.get"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "\n", "units", ",", "\n", "activation", "=", "'quantized_tanh'", ",", "\n", "use_bias", "=", "True", ",", "\n", "kernel_initializer", "=", "'glorot_uniform'", ",", "\n", "recurrent_initializer", "=", "'orthogonal'", ",", "\n", "bias_initializer", "=", "'zeros'", ",", "\n", "kernel_regularizer", "=", "None", ",", "\n", "recurrent_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "activity_regularizer", "=", "None", ",", "\n", "kernel_constraint", "=", "None", ",", "\n", "recurrent_constraint", "=", "None", ",", "\n", "bias_constraint", "=", "None", ",", "\n", "kernel_quantizer", "=", "None", ",", "\n", "recurrent_quantizer", "=", "None", ",", "\n", "bias_quantizer", "=", "None", ",", "\n", "state_quantizer", "=", "None", ",", "\n", "dropout", "=", "0.", ",", "\n", "recurrent_dropout", "=", "0.", ",", "\n", "return_sequences", "=", "False", ",", "\n", "return_state", "=", "False", ",", "\n", "go_backwards", "=", "False", ",", "\n", "stateful", "=", "False", ",", "\n", "unroll", "=", "False", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "    ", "if", "'enable_caching_device'", "in", "kwargs", ":", "\n", "      ", "cell_kwargs", "=", "{", "'enable_caching_device'", ":", "\n", "kwargs", ".", "pop", "(", "'enable_caching_device'", ")", "}", "\n", "", "else", ":", "\n", "      ", "cell_kwargs", "=", "{", "}", "\n", "\n", "", "cell", "=", "QSimpleRNNCell", "(", "\n", "units", ",", "\n", "activation", "=", "activation", ",", "\n", "use_bias", "=", "use_bias", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "recurrent_initializer", "=", "recurrent_initializer", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "recurrent_regularizer", "=", "recurrent_regularizer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "recurrent_constraint", "=", "recurrent_constraint", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "kernel_quantizer", "=", "kernel_quantizer", ",", "\n", "recurrent_quantizer", "=", "recurrent_quantizer", ",", "\n", "bias_quantizer", "=", "bias_quantizer", ",", "\n", "state_quantizer", "=", "state_quantizer", ",", "\n", "dropout", "=", "dropout", ",", "\n", "recurrent_dropout", "=", "recurrent_dropout", ",", "\n", "dtype", "=", "kwargs", ".", "get", "(", "'dtype'", ")", ",", "\n", "trainable", "=", "kwargs", ".", "get", "(", "'trainable'", ",", "True", ")", ",", "\n", "**", "cell_kwargs", ")", "\n", "\n", "super", "(", "QSimpleRNN", ",", "self", ")", ".", "__init__", "(", "\n", "cell", ",", "\n", "return_sequences", "=", "return_sequences", ",", "\n", "return_state", "=", "return_state", ",", "\n", "go_backwards", "=", "go_backwards", ",", "\n", "stateful", "=", "stateful", ",", "\n", "unroll", "=", "unroll", ",", "\n", "**", "kwargs", ")", "\n", "self", ".", "activity_regularizer", "=", "regularizers", ".", "get", "(", "activity_regularizer", ")", "\n", "self", ".", "input_spec", "=", "[", "tf", ".", "keras", ".", "layers", ".", "InputSpec", "(", "ndim", "=", "3", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.call": [[287, 291], ["qrecurrent.QSimpleRNN._maybe_reset_cell_dropout_mask", "super().call"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.call"], ["", "def", "call", "(", "self", ",", "inputs", ",", "mask", "=", "None", ",", "training", "=", "None", ",", "initial_state", "=", "None", ")", ":", "\n", "    ", "self", ".", "_maybe_reset_cell_dropout_mask", "(", "self", ".", "cell", ")", "\n", "return", "super", "(", "QSimpleRNN", ",", "self", ")", ".", "call", "(", "\n", "inputs", ",", "mask", "=", "mask", ",", "training", "=", "training", ",", "initial_state", "=", "initial_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.get_quantizers": [[292, 294], ["None"], "methods", ["None"], ["", "def", "get_quantizers", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "quantizers", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.get_prunable_weights": [[295, 297], ["None"], "methods", ["None"], ["", "def", "get_prunable_weights", "(", "self", ")", ":", "\n", "    ", "return", "[", "self", ".", "cell", ".", "kernel", ",", "self", ".", "cell", ".", "recurrent_kernel", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.units": [[298, 301], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "units", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "units", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.activation": [[302, 305], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "activation", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "activation", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.use_bias": [[306, 309], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "use_bias", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "use_bias", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.kernel_initializer": [[310, 313], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "kernel_initializer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "kernel_initializer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.recurrent_initializer": [[314, 317], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_initializer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "recurrent_initializer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.bias_initializer": [[318, 321], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "bias_initializer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "bias_initializer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.kernel_regularizer": [[322, 325], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "kernel_regularizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "kernel_regularizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.recurrent_regularizer": [[326, 329], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_regularizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "recurrent_regularizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.bias_regularizer": [[330, 333], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "bias_regularizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "bias_regularizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.kernel_constraint": [[334, 337], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "kernel_constraint", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "kernel_constraint", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.recurrent_constraint": [[338, 341], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_constraint", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "recurrent_constraint", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.bias_constraint": [[342, 345], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "bias_constraint", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "bias_constraint", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.kernel_quantizer_internal": [[346, 349], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "kernel_quantizer_internal", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "kernel_quantizer_internal", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.recurrent_quantizer_internal": [[350, 353], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_quantizer_internal", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "recurrent_quantizer_internal", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.bias_quantizer_internal": [[354, 357], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "bias_quantizer_internal", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "bias_quantizer_internal", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.state_quantizer_internal": [[358, 361], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "state_quantizer_internal", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "state_quantizer_internal", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.kernel_quantizer": [[362, 365], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "kernel_quantizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "kernel_quantizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.recurrent_quantizer": [[366, 369], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_quantizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "recurrent_quantizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.bias_quantizer": [[370, 373], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "bias_quantizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "bias_quantizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.state_quantizer": [[374, 377], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "state_quantizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "state_quantizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.dropout": [[378, 381], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "dropout", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "dropout", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.recurrent_dropout": [[382, 385], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_dropout", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "recurrent_dropout", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.get_config": [[386, 430], ["super().get_config", "dict", "tensorflow.keras.activations.serialize", "tensorflow.keras.activations.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "list", "list", "super().get_config.items", "config.items"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "'units'", ":", "\n", "self", ".", "units", ",", "\n", "'activation'", ":", "\n", "activations", ".", "serialize", "(", "self", ".", "activation", ")", ",", "\n", "'use_bias'", ":", "\n", "self", ".", "use_bias", ",", "\n", "'kernel_initializer'", ":", "\n", "initializers", ".", "serialize", "(", "self", ".", "kernel_initializer", ")", ",", "\n", "'recurrent_initializer'", ":", "\n", "initializers", ".", "serialize", "(", "self", ".", "recurrent_initializer", ")", ",", "\n", "'bias_initializer'", ":", "\n", "initializers", ".", "serialize", "(", "self", ".", "bias_initializer", ")", ",", "\n", "'kernel_regularizer'", ":", "\n", "regularizers", ".", "serialize", "(", "self", ".", "kernel_regularizer", ")", ",", "\n", "'recurrent_regularizer'", ":", "\n", "regularizers", ".", "serialize", "(", "self", ".", "recurrent_regularizer", ")", ",", "\n", "'bias_regularizer'", ":", "\n", "regularizers", ".", "serialize", "(", "self", ".", "bias_regularizer", ")", ",", "\n", "'activity_regularizer'", ":", "\n", "regularizers", ".", "serialize", "(", "self", ".", "activity_regularizer", ")", ",", "\n", "'kernel_constraint'", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "kernel_constraint", ")", ",", "\n", "'recurrent_constraint'", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "recurrent_constraint", ")", ",", "\n", "'bias_constraint'", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "bias_constraint", ")", ",", "\n", "\"kernel_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "kernel_quantizer_internal", ")", ",", "\n", "\"recurrent_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "recurrent_quantizer_internal", ")", ",", "\n", "\"bias_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "bias_quantizer_internal", ")", ",", "\n", "\"state_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "state_quantizer_internal", ")", ",", "\n", "'dropout'", ":", "\n", "self", ".", "dropout", ",", "\n", "'recurrent_dropout'", ":", "\n", "self", ".", "recurrent_dropout", "\n", "}", "\n", "base_config", "=", "super", "(", "QSimpleRNN", ",", "self", ")", ".", "get_config", "(", ")", "\n", "del", "base_config", "[", "'cell'", "]", "\n", "return", "dict", "(", "list", "(", "base_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.get_quantization_config": [[431, 443], ["str", "str", "str", "str", "str"], "methods", ["None"], ["", "def", "get_quantization_config", "(", "self", ")", ":", "\n", "    ", "return", "{", "\n", "\"kernel_quantizer\"", ":", "\n", "str", "(", "self", ".", "kernel_quantizer_internal", ")", ",", "\n", "\"recurrent_quantizer\"", ":", "\n", "str", "(", "self", ".", "recurrent_quantizer_internal", ")", ",", "\n", "\"bias_quantizer\"", ":", "\n", "str", "(", "self", ".", "bias_quantizer_internal", ")", ",", "\n", "\"state_quantizer\"", ":", "\n", "str", "(", "self", ".", "state_quantizer_internal", ")", ",", "\n", "\"activation\"", ":", "\n", "str", "(", "self", ".", "activation", ")", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QSimpleRNN.from_config": [[445, 450], ["cls", "config.pop"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "config", ")", ":", "\n", "    ", "if", "'implementation'", "in", "config", ":", "\n", "      ", "config", ".", "pop", "(", "'implementation'", ")", "\n", "", "return", "cls", "(", "**", "config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTMCell.__init__": [[471, 558], ["quantizers.get_quantizer", "quantizers.get_quantizer", "quantizers.get_quantizer", "quantizers.get_quantizer", "hasattr", "hasattr", "qlayers.get_auto_range_constraint_initializer", "qlayers.get_auto_range_constraint_initializer", "tensorflow.keras.layers.LSTMCell.__init__", "qrecurrent.QLSTMCell.kernel_quantizer_internal._set_trainable_parameter", "qrecurrent.QLSTMCell.recurrent_quantizer_internal._set_trainable_parameter", "qlayers.get_auto_range_constraint_initializer", "quantizers.get_quantizer", "quantizers.get_quantizer"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary._set_trainable_parameter", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary._set_trainable_parameter", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer"], ["def", "__init__", "(", "self", ",", "\n", "units", ",", "\n", "activation", "=", "'quantized_tanh'", ",", "\n", "recurrent_activation", "=", "'hard_sigmoid'", ",", "\n", "use_bias", "=", "True", ",", "\n", "kernel_initializer", "=", "'glorot_uniform'", ",", "\n", "recurrent_initializer", "=", "'orthogonal'", ",", "\n", "bias_initializer", "=", "'zeros'", ",", "\n", "unit_forget_bias", "=", "True", ",", "\n", "kernel_regularizer", "=", "None", ",", "\n", "recurrent_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "kernel_constraint", "=", "None", ",", "\n", "recurrent_constraint", "=", "None", ",", "\n", "bias_constraint", "=", "None", ",", "\n", "kernel_quantizer", "=", "None", ",", "\n", "recurrent_quantizer", "=", "None", ",", "\n", "bias_quantizer", "=", "None", ",", "\n", "state_quantizer", "=", "None", ",", "\n", "dropout", "=", "0.", ",", "\n", "recurrent_dropout", "=", "0.", ",", "\n", "implementation", "=", "1", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "self", ".", "kernel_quantizer", "=", "kernel_quantizer", "\n", "self", ".", "recurrent_quantizer", "=", "recurrent_quantizer", "\n", "self", ".", "bias_quantizer", "=", "bias_quantizer", "\n", "self", ".", "state_quantizer", "=", "state_quantizer", "\n", "\n", "self", ".", "kernel_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "kernel_quantizer", ")", "\n", "self", ".", "recurrent_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "recurrent_quantizer", ")", "\n", "self", ".", "bias_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "bias_quantizer", ")", "\n", "self", ".", "state_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "state_quantizer", ")", "\n", "\n", "self", ".", "quantizers", "=", "[", "\n", "self", ".", "kernel_quantizer_internal", ",", "\n", "self", ".", "recurrent_quantizer_internal", ",", "\n", "self", ".", "bias_quantizer_internal", ",", "\n", "self", ".", "state_quantizer_internal", ",", "\n", "]", "\n", "\n", "if", "hasattr", "(", "self", ".", "kernel_quantizer_internal", ",", "\"_set_trainable_parameter\"", ")", ":", "\n", "      ", "self", ".", "kernel_quantizer_internal", ".", "_set_trainable_parameter", "(", ")", "\n", "\n", "", "if", "hasattr", "(", "self", ".", "recurrent_quantizer_internal", ",", "\"_set_trainable_parameter\"", ")", ":", "\n", "      ", "self", ".", "recurrent_quantizer_internal", ".", "_set_trainable_parameter", "(", ")", "\n", "\n", "", "kernel_constraint", ",", "kernel_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "kernel_quantizer_internal", ",", "\n", "kernel_constraint", ",", "\n", "kernel_initializer", ")", ")", "\n", "\n", "recurrent_constraint", ",", "recurrent_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "recurrent_quantizer_internal", ",", "\n", "recurrent_constraint", ",", "\n", "recurrent_initializer", ")", ")", "\n", "\n", "if", "use_bias", ":", "\n", "      ", "bias_constraint", ",", "bias_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "bias_quantizer_internal", ",", "\n", "bias_constraint", ",", "\n", "bias_initializer", ")", ")", "\n", "\n", "", "if", "activation", "is", "not", "None", ":", "\n", "      ", "activation", "=", "get_quantizer", "(", "activation", ")", "\n", "\n", "", "if", "recurrent_activation", "is", "not", "None", ":", "\n", "      ", "recurrent_activation", "=", "get_quantizer", "(", "recurrent_activation", ")", "\n", "\n", "", "super", "(", "QLSTMCell", ",", "self", ")", ".", "__init__", "(", "\n", "units", "=", "units", ",", "\n", "activation", "=", "activation", ",", "\n", "use_bias", "=", "use_bias", ",", "\n", "recurrent_activation", "=", "recurrent_activation", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "recurrent_initializer", "=", "recurrent_initializer", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "unit_forget_bias", "=", "True", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "recurrent_regularizer", "=", "recurrent_regularizer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "recurrent_constraint", "=", "recurrent_constraint", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "dropout", "=", "dropout", ",", "\n", "recurrent_dropout", "=", "recurrent_dropout", ",", "\n", "implementation", "=", "implementation", ",", "\n", "**", "kwargs", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTMCell._compute_carry_and_output": [[560, 573], ["qrecurrent.QLSTMCell.recurrent_activation", "qrecurrent.QLSTMCell.recurrent_activation", "qrecurrent.QLSTMCell.recurrent_activation", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "qrecurrent.QLSTMCell.activation", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.recurrent_activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.recurrent_activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.recurrent_activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QBidirectional.activation"], ["", "def", "_compute_carry_and_output", "(", "self", ",", "x", ",", "h_tm1", ",", "c_tm1", ",", "quantized_recurrent", ")", ":", "\n", "    ", "\"\"\"Computes carry and output using split kernels.\"\"\"", "\n", "x_i", ",", "x_f", ",", "x_c", ",", "x_o", "=", "x", "\n", "h_tm1_i", ",", "h_tm1_f", ",", "h_tm1_c", ",", "h_tm1_o", "=", "h_tm1", "\n", "i", "=", "self", ".", "recurrent_activation", "(", "\n", "x_i", "+", "K", ".", "dot", "(", "h_tm1_i", ",", "quantized_recurrent", "[", ":", ",", ":", "self", ".", "units", "]", ")", ")", "\n", "f", "=", "self", ".", "recurrent_activation", "(", "x_f", "+", "K", ".", "dot", "(", "\n", "h_tm1_f", ",", "quantized_recurrent", "[", ":", ",", "self", ".", "units", ":", "self", ".", "units", "*", "2", "]", ")", ")", "\n", "c", "=", "f", "*", "c_tm1", "+", "i", "*", "self", ".", "activation", "(", "x_c", "+", "K", ".", "dot", "(", "\n", "h_tm1_c", ",", "quantized_recurrent", "[", ":", ",", "self", ".", "units", "*", "2", ":", "self", ".", "units", "*", "3", "]", ")", ")", "\n", "o", "=", "self", ".", "recurrent_activation", "(", "\n", "x_o", "+", "K", ".", "dot", "(", "h_tm1_o", ",", "quantized_recurrent", "[", ":", ",", "self", ".", "units", "*", "3", ":", "]", ")", ")", "\n", "return", "c", ",", "o", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTMCell._compute_carry_and_output_fused": [[574, 582], ["qrecurrent.QLSTMCell.recurrent_activation", "qrecurrent.QLSTMCell.recurrent_activation", "qrecurrent.QLSTMCell.recurrent_activation", "qrecurrent.QLSTMCell.activation"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.recurrent_activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.recurrent_activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.recurrent_activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QBidirectional.activation"], ["", "def", "_compute_carry_and_output_fused", "(", "self", ",", "z", ",", "c_tm1", ")", ":", "\n", "    ", "\"\"\"Computes carry and output using fused kernels.\"\"\"", "\n", "z0", ",", "z1", ",", "z2", ",", "z3", "=", "z", "\n", "i", "=", "self", ".", "recurrent_activation", "(", "z0", ")", "\n", "f", "=", "self", ".", "recurrent_activation", "(", "z1", ")", "\n", "c", "=", "f", "*", "c_tm1", "+", "i", "*", "self", ".", "activation", "(", "z2", ")", "\n", "o", "=", "self", ".", "recurrent_activation", "(", "z3", ")", "\n", "return", "c", ",", "o", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTMCell.call": [[583, 662], ["qrecurrent.QLSTMCell.get_dropout_mask_for_cell", "qrecurrent.QLSTMCell.get_recurrent_dropout_mask_for_cell", "qrecurrent.QLSTMCell.state_quantizer_internal", "qrecurrent.QLSTMCell.state_quantizer_internal", "qrecurrent.QLSTMCell.kernel_quantizer_internal", "qrecurrent.QLSTMCell.recurrent_quantizer_internal", "qrecurrent.QLSTMCell.bias_quantizer_internal", "tensorflow.python.ops.array_ops.split", "tensorflow.python.ops.array_ops.split", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "qrecurrent.QLSTMCell._compute_carry_and_output", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.python.ops.array_ops.split", "tensorflow.python.ops.array_ops.split", "qrecurrent.QLSTMCell._compute_carry_and_output_fused", "qrecurrent.QLSTMCell.activation", "tensorflow.python.ops.array_ops.split", "tensorflow.python.ops.array_ops.split", "tensorflow.bias_add", "tensorflow.bias_add", "tensorflow.bias_add", "tensorflow.bias_add", "tensorflow.bias_add", "tensorflow.bias_add", "tensorflow.bias_add", "tensorflow.bias_add", "tensorflow.bias_add", "tensorflow.bias_add"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.state_quantizer_internal", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.state_quantizer_internal", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.kernel_quantizer_internal", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.recurrent_quantizer_internal", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.bias_quantizer_internal", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTMCell._compute_carry_and_output", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTMCell._compute_carry_and_output_fused", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QBidirectional.activation"], ["", "def", "call", "(", "self", ",", "inputs", ",", "states", ",", "training", "=", "None", ")", ":", "\n", "    ", "h_tm1_tmp", "=", "states", "[", "0", "]", "# previous memory state", "\n", "c_tm1_tmp", "=", "states", "[", "1", "]", "# previous carry state", "\n", "\n", "if", "self", ".", "state_quantizer", ":", "\n", "      ", "c_tm1", "=", "self", ".", "state_quantizer_internal", "(", "c_tm1_tmp", ")", "\n", "h_tm1", "=", "self", ".", "state_quantizer_internal", "(", "h_tm1_tmp", ")", "\n", "", "else", ":", "\n", "      ", "c_tm1", "=", "c_tm1_tmp", "\n", "h_tm1", "=", "h_tm1_tmp", "\n", "\n", "", "dp_mask", "=", "self", ".", "get_dropout_mask_for_cell", "(", "inputs", ",", "training", ",", "count", "=", "4", ")", "\n", "rec_dp_mask", "=", "self", ".", "get_recurrent_dropout_mask_for_cell", "(", "\n", "h_tm1", ",", "training", ",", "count", "=", "4", ")", "\n", "\n", "if", "self", ".", "kernel_quantizer", ":", "\n", "      ", "quantized_kernel", "=", "self", ".", "kernel_quantizer_internal", "(", "self", ".", "kernel", ")", "\n", "", "else", ":", "\n", "      ", "quantized_kernel", "=", "self", ".", "kernel", "\n", "", "if", "self", ".", "recurrent_quantizer", ":", "\n", "      ", "quantized_recurrent", "=", "self", ".", "recurrent_quantizer_internal", "(", "self", ".", "recurrent_kernel", ")", "\n", "", "else", ":", "\n", "      ", "quantized_recurrent", "=", "self", ".", "recurrent_kernel", "\n", "", "if", "self", ".", "bias_quantizer", ":", "\n", "      ", "quantized_bias", "=", "self", ".", "bias_quantizer_internal", "(", "self", ".", "bias", ")", "\n", "", "else", ":", "\n", "      ", "quantized_bias", "=", "self", ".", "bias", "\n", "\n", "", "if", "self", ".", "implementation", "==", "1", ":", "\n", "      ", "if", "0", "<", "self", ".", "dropout", "<", "1.", ":", "\n", "        ", "inputs_i", "=", "inputs", "*", "dp_mask", "[", "0", "]", "\n", "inputs_f", "=", "inputs", "*", "dp_mask", "[", "1", "]", "\n", "inputs_c", "=", "inputs", "*", "dp_mask", "[", "2", "]", "\n", "inputs_o", "=", "inputs", "*", "dp_mask", "[", "3", "]", "\n", "", "else", ":", "\n", "        ", "inputs_i", "=", "inputs", "\n", "inputs_f", "=", "inputs", "\n", "inputs_c", "=", "inputs", "\n", "inputs_o", "=", "inputs", "\n", "", "k_i", ",", "k_f", ",", "k_c", ",", "k_o", "=", "array_ops", ".", "split", "(", "\n", "quantized_kernel", ",", "num_or_size_splits", "=", "4", ",", "axis", "=", "1", ")", "\n", "x_i", "=", "K", ".", "dot", "(", "inputs_i", ",", "k_i", ")", "\n", "x_f", "=", "K", ".", "dot", "(", "inputs_f", ",", "k_f", ")", "\n", "x_c", "=", "K", ".", "dot", "(", "inputs_c", ",", "k_c", ")", "\n", "x_o", "=", "K", ".", "dot", "(", "inputs_o", ",", "k_o", ")", "\n", "if", "self", ".", "use_bias", ":", "\n", "        ", "b_i", ",", "b_f", ",", "b_c", ",", "b_o", "=", "array_ops", ".", "split", "(", "\n", "quantized_bias", ",", "num_or_size_splits", "=", "4", ",", "axis", "=", "0", ")", "\n", "x_i", "=", "K", ".", "bias_add", "(", "x_i", ",", "b_i", ")", "\n", "x_f", "=", "K", ".", "bias_add", "(", "x_f", ",", "b_f", ")", "\n", "x_c", "=", "K", ".", "bias_add", "(", "x_c", ",", "b_c", ")", "\n", "x_o", "=", "K", ".", "bias_add", "(", "x_o", ",", "b_o", ")", "\n", "\n", "", "if", "0", "<", "self", ".", "recurrent_dropout", "<", "1.", ":", "\n", "        ", "h_tm1_i", "=", "h_tm1", "*", "rec_dp_mask", "[", "0", "]", "\n", "h_tm1_f", "=", "h_tm1", "*", "rec_dp_mask", "[", "1", "]", "\n", "h_tm1_c", "=", "h_tm1", "*", "rec_dp_mask", "[", "2", "]", "\n", "h_tm1_o", "=", "h_tm1", "*", "rec_dp_mask", "[", "3", "]", "\n", "", "else", ":", "\n", "        ", "h_tm1_i", "=", "h_tm1", "\n", "h_tm1_f", "=", "h_tm1", "\n", "h_tm1_c", "=", "h_tm1", "\n", "h_tm1_o", "=", "h_tm1", "\n", "", "x", "=", "(", "x_i", ",", "x_f", ",", "x_c", ",", "x_o", ")", "\n", "h_tm1", "=", "(", "h_tm1_i", ",", "h_tm1_f", ",", "h_tm1_c", ",", "h_tm1_o", ")", "\n", "c", ",", "o", "=", "self", ".", "_compute_carry_and_output", "(", "x", ",", "h_tm1", ",", "c_tm1", ",", "quantized_recurrent", ")", "\n", "", "else", ":", "\n", "      ", "if", "0.", "<", "self", ".", "dropout", "<", "1.", ":", "\n", "        ", "inputs", "=", "inputs", "*", "dp_mask", "[", "0", "]", "\n", "", "z", "=", "K", ".", "dot", "(", "inputs", ",", "quantized_kernel", ")", "\n", "z", "+=", "K", ".", "dot", "(", "h_tm1", ",", "quantized_recurrent", ")", "\n", "if", "self", ".", "use_bias", ":", "\n", "        ", "z", "=", "K", ".", "bias_add", "(", "z", ",", "quantized_bias", ")", "\n", "\n", "", "z", "=", "array_ops", ".", "split", "(", "z", ",", "num_or_size_splits", "=", "4", ",", "axis", "=", "1", ")", "\n", "c", ",", "o", "=", "self", ".", "_compute_carry_and_output_fused", "(", "z", ",", "c_tm1", ")", "\n", "\n", "", "h", "=", "o", "*", "self", ".", "activation", "(", "c", ")", "\n", "return", "h", ",", "[", "h", ",", "c", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTMCell.get_config": [[663, 676], ["super().get_config", "dict", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "list", "list", "super().get_config.items", "config.items"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "\"kernel_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "kernel_quantizer_internal", ")", ",", "\n", "\"recurrent_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "recurrent_quantizer_internal", ")", ",", "\n", "\"bias_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "bias_quantizer_internal", ")", ",", "\n", "\"state_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "state_quantizer_internal", ")", "\n", "}", "\n", "base_config", "=", "super", "(", "QLSTMCell", ",", "self", ")", ".", "get_config", "(", ")", "\n", "return", "dict", "(", "list", "(", "base_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.__init__": [[697, 773], ["qrecurrent.QLSTMCell", "tensorflow.keras.layers.RNN.__init__", "tensorflow.keras.regularizers.get", "tensorflow.keras.regularizers.get", "print", "tensorflow.keras.layers.InputSpec", "tensorflow.keras.layers.InputSpec", "kwargs.pop", "kwargs.get", "kwargs.get"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "\n", "units", ",", "\n", "activation", "=", "'quantized_tanh'", ",", "\n", "recurrent_activation", "=", "'hard_sigmoid'", ",", "\n", "use_bias", "=", "True", ",", "\n", "kernel_initializer", "=", "'glorot_uniform'", ",", "\n", "recurrent_initializer", "=", "'orthogonal'", ",", "\n", "bias_initializer", "=", "'zeros'", ",", "\n", "unit_forget_bias", "=", "True", ",", "\n", "kernel_regularizer", "=", "None", ",", "\n", "recurrent_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "activity_regularizer", "=", "None", ",", "\n", "kernel_constraint", "=", "None", ",", "\n", "recurrent_constraint", "=", "None", ",", "\n", "bias_constraint", "=", "None", ",", "\n", "kernel_quantizer", "=", "None", ",", "\n", "recurrent_quantizer", "=", "None", ",", "\n", "bias_quantizer", "=", "None", ",", "\n", "state_quantizer", "=", "None", ",", "\n", "dropout", "=", "0.", ",", "\n", "recurrent_dropout", "=", "0.", ",", "\n", "implementation", "=", "1", ",", "\n", "return_sequences", "=", "False", ",", "\n", "return_state", "=", "False", ",", "\n", "go_backwards", "=", "False", ",", "\n", "stateful", "=", "False", ",", "\n", "unroll", "=", "False", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "if", "implementation", "==", "0", ":", "\n", "      ", "print", "(", "'`implementation=0` has been deprecated, '", "\n", "'and now defaults to `implementation=1`.'", "\n", "'Please update your layer call.'", ")", "\n", "\n", "", "if", "'enable_caching_device'", "in", "kwargs", ":", "\n", "      ", "cell_kwargs", "=", "{", "'enable_caching_device'", ":", "\n", "kwargs", ".", "pop", "(", "'enable_caching_device'", ")", "}", "\n", "", "else", ":", "\n", "      ", "cell_kwargs", "=", "{", "}", "\n", "\n", "", "cell", "=", "QLSTMCell", "(", "\n", "units", ",", "\n", "activation", "=", "activation", ",", "\n", "recurrent_activation", "=", "recurrent_activation", ",", "\n", "use_bias", "=", "use_bias", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "recurrent_initializer", "=", "recurrent_initializer", ",", "\n", "unit_forget_bias", "=", "unit_forget_bias", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "recurrent_regularizer", "=", "recurrent_regularizer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "recurrent_constraint", "=", "recurrent_constraint", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "kernel_quantizer", "=", "kernel_quantizer", ",", "\n", "recurrent_quantizer", "=", "recurrent_quantizer", ",", "\n", "bias_quantizer", "=", "bias_quantizer", ",", "\n", "state_quantizer", "=", "state_quantizer", ",", "\n", "dropout", "=", "dropout", ",", "\n", "recurrent_dropout", "=", "recurrent_dropout", ",", "\n", "implementation", "=", "implementation", ",", "\n", "dtype", "=", "kwargs", ".", "get", "(", "'dtype'", ")", ",", "\n", "trainable", "=", "kwargs", ".", "get", "(", "'trainable'", ",", "True", ")", ",", "\n", "**", "cell_kwargs", ")", "\n", "\n", "super", "(", "QLSTM", ",", "self", ")", ".", "__init__", "(", "\n", "cell", ",", "\n", "return_sequences", "=", "return_sequences", ",", "\n", "return_state", "=", "return_state", ",", "\n", "go_backwards", "=", "go_backwards", ",", "\n", "stateful", "=", "stateful", ",", "\n", "unroll", "=", "unroll", ",", "\n", "**", "kwargs", ")", "\n", "self", ".", "activity_regularizer", "=", "regularizers", ".", "get", "(", "activity_regularizer", ")", "\n", "self", ".", "input_spec", "=", "[", "tf", ".", "keras", ".", "layers", ".", "InputSpec", "(", "ndim", "=", "3", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.call": [[774, 778], ["qrecurrent.QLSTM._maybe_reset_cell_dropout_mask", "super().call"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.call"], ["", "def", "call", "(", "self", ",", "inputs", ",", "mask", "=", "None", ",", "training", "=", "None", ",", "initial_state", "=", "None", ")", ":", "\n", "    ", "self", ".", "_maybe_reset_cell_dropout_mask", "(", "self", ".", "cell", ")", "\n", "return", "super", "(", "QLSTM", ",", "self", ")", ".", "call", "(", "\n", "inputs", ",", "mask", "=", "mask", ",", "training", "=", "training", ",", "initial_state", "=", "initial_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.get_quantizers": [[779, 781], ["None"], "methods", ["None"], ["", "def", "get_quantizers", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "quantizers", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.get_prunable_weights": [[782, 784], ["None"], "methods", ["None"], ["", "def", "get_prunable_weights", "(", "self", ")", ":", "\n", "    ", "return", "[", "self", ".", "cell", ".", "kernel", ",", "self", ".", "cell", ".", "recurrent_kernel", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.units": [[785, 788], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "units", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "units", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.activation": [[789, 792], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "activation", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "activation", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.recurrent_activation": [[793, 796], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_activation", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "recurrent_activation", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.use_bias": [[797, 800], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "use_bias", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "use_bias", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.kernel_initializer": [[801, 804], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "kernel_initializer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "kernel_initializer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.recurrent_initializer": [[805, 808], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_initializer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "recurrent_initializer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.bias_initializer": [[809, 812], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "bias_initializer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "bias_initializer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.unit_forget_bias": [[813, 816], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "unit_forget_bias", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "unit_forget_bias", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.kernel_regularizer": [[817, 820], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "kernel_regularizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "kernel_regularizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.recurrent_regularizer": [[821, 824], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_regularizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "recurrent_regularizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.bias_regularizer": [[825, 828], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "bias_regularizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "bias_regularizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.kernel_constraint": [[829, 832], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "kernel_constraint", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "kernel_constraint", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.recurrent_constraint": [[833, 836], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_constraint", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "recurrent_constraint", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.bias_constraint": [[837, 840], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "bias_constraint", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "bias_constraint", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.kernel_quantizer_internal": [[841, 844], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "kernel_quantizer_internal", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "kernel_quantizer_internal", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.recurrent_quantizer_internal": [[845, 848], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_quantizer_internal", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "recurrent_quantizer_internal", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.bias_quantizer_internal": [[849, 852], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "bias_quantizer_internal", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "bias_quantizer_internal", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.state_quantizer_internal": [[853, 856], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "state_quantizer_internal", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "state_quantizer_internal", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.kernel_quantizer": [[857, 860], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "kernel_quantizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "kernel_quantizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.recurrent_quantizer": [[861, 864], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_quantizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "recurrent_quantizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.bias_quantizer": [[865, 868], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "bias_quantizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "bias_quantizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.state_quantizer": [[869, 872], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "state_quantizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "state_quantizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.dropout": [[873, 876], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "dropout", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "dropout", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.recurrent_dropout": [[877, 880], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_dropout", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "recurrent_dropout", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.implementation": [[881, 884], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "implementation", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "implementation", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.get_config": [[885, 935], ["super().get_config", "dict", "tensorflow.keras.activations.serialize", "tensorflow.keras.activations.serialize", "tensorflow.keras.activations.serialize", "tensorflow.keras.activations.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "list", "list", "super().get_config.items", "config.items"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "'units'", ":", "\n", "self", ".", "units", ",", "\n", "'activation'", ":", "\n", "activations", ".", "serialize", "(", "self", ".", "activation", ")", ",", "\n", "'recurrent_activation'", ":", "\n", "activations", ".", "serialize", "(", "self", ".", "recurrent_activation", ")", ",", "\n", "'use_bias'", ":", "\n", "self", ".", "use_bias", ",", "\n", "'kernel_initializer'", ":", "\n", "initializers", ".", "serialize", "(", "self", ".", "kernel_initializer", ")", ",", "\n", "'recurrent_initializer'", ":", "\n", "initializers", ".", "serialize", "(", "self", ".", "recurrent_initializer", ")", ",", "\n", "'bias_initializer'", ":", "\n", "initializers", ".", "serialize", "(", "self", ".", "bias_initializer", ")", ",", "\n", "'unit_forget_bias'", ":", "\n", "self", ".", "unit_forget_bias", ",", "\n", "'kernel_regularizer'", ":", "\n", "regularizers", ".", "serialize", "(", "self", ".", "kernel_regularizer", ")", ",", "\n", "'recurrent_regularizer'", ":", "\n", "regularizers", ".", "serialize", "(", "self", ".", "recurrent_regularizer", ")", ",", "\n", "'bias_regularizer'", ":", "\n", "regularizers", ".", "serialize", "(", "self", ".", "bias_regularizer", ")", ",", "\n", "'activity_regularizer'", ":", "\n", "regularizers", ".", "serialize", "(", "self", ".", "activity_regularizer", ")", ",", "\n", "'kernel_constraint'", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "kernel_constraint", ")", ",", "\n", "'recurrent_constraint'", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "recurrent_constraint", ")", ",", "\n", "'bias_constraint'", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "bias_constraint", ")", ",", "\n", "\"kernel_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "kernel_quantizer_internal", ")", ",", "\n", "\"recurrent_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "recurrent_quantizer_internal", ")", ",", "\n", "\"bias_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "bias_quantizer_internal", ")", ",", "\n", "\"state_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "state_quantizer_internal", ")", ",", "\n", "'dropout'", ":", "\n", "self", ".", "dropout", ",", "\n", "'recurrent_dropout'", ":", "\n", "self", ".", "recurrent_dropout", ",", "\n", "'implementation'", ":", "\n", "self", ".", "implementation", "\n", "}", "\n", "base_config", "=", "super", "(", "QLSTM", ",", "self", ")", ".", "get_config", "(", ")", "\n", "del", "base_config", "[", "'cell'", "]", "\n", "return", "dict", "(", "list", "(", "base_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.get_quantization_config": [[936, 950], ["str", "str", "str", "str", "str", "str"], "methods", ["None"], ["", "def", "get_quantization_config", "(", "self", ")", ":", "\n", "    ", "return", "{", "\n", "\"kernel_quantizer\"", ":", "\n", "str", "(", "self", ".", "kernel_quantizer_internal", ")", ",", "\n", "\"recurrent_quantizer\"", ":", "\n", "str", "(", "self", ".", "recurrent_quantizer_internal", ")", ",", "\n", "\"bias_quantizer\"", ":", "\n", "str", "(", "self", ".", "bias_quantizer_internal", ")", ",", "\n", "\"state_quantizer\"", ":", "\n", "str", "(", "self", ".", "state_quantizer_internal", ")", ",", "\n", "\"activation\"", ":", "\n", "str", "(", "self", ".", "activation", ")", ",", "\n", "\"recurrent_activation\"", ":", "\n", "str", "(", "self", ".", "recurrent_activation", ")", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QLSTM.from_config": [[952, 957], ["cls"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "config", ")", ":", "\n", "    ", "if", "'implementation'", "in", "config", "and", "config", "[", "'implementation'", "]", "==", "0", ":", "\n", "      ", "config", "[", "'implementation'", "]", "=", "1", "\n", "", "return", "cls", "(", "**", "config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRUCell.__init__": [[978, 1066], ["quantizers.get_quantizer", "quantizers.get_quantizer", "quantizers.get_quantizer", "quantizers.get_quantizer", "hasattr", "hasattr", "qlayers.get_auto_range_constraint_initializer", "qlayers.get_auto_range_constraint_initializer", "tensorflow.keras.layers.GRUCell.__init__", "qrecurrent.QGRUCell.kernel_quantizer_internal._set_trainable_parameter", "qrecurrent.QGRUCell.recurrent_quantizer_internal._set_trainable_parameter", "qlayers.get_auto_range_constraint_initializer", "quantizers.get_quantizer", "quantizers.get_quantizer"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary._set_trainable_parameter", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary._set_trainable_parameter", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer"], ["def", "__init__", "(", "self", ",", "\n", "units", ",", "\n", "activation", "=", "'quantized_tanh'", ",", "\n", "recurrent_activation", "=", "'hard_sigmoid'", ",", "\n", "use_bias", "=", "True", ",", "\n", "kernel_initializer", "=", "'glorot_uniform'", ",", "\n", "recurrent_initializer", "=", "'orthogonal'", ",", "\n", "bias_initializer", "=", "'zeros'", ",", "\n", "kernel_regularizer", "=", "None", ",", "\n", "recurrent_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "kernel_constraint", "=", "None", ",", "\n", "recurrent_constraint", "=", "None", ",", "\n", "bias_constraint", "=", "None", ",", "\n", "kernel_quantizer", "=", "None", ",", "\n", "recurrent_quantizer", "=", "None", ",", "\n", "bias_quantizer", "=", "None", ",", "\n", "state_quantizer", "=", "None", ",", "\n", "dropout", "=", "0.", ",", "\n", "recurrent_dropout", "=", "0.", ",", "\n", "implementation", "=", "1", ",", "\n", "reset_after", "=", "False", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "    ", "self", ".", "kernel_quantizer", "=", "kernel_quantizer", "\n", "self", ".", "recurrent_quantizer", "=", "recurrent_quantizer", "\n", "self", ".", "bias_quantizer", "=", "bias_quantizer", "\n", "self", ".", "state_quantizer", "=", "state_quantizer", "\n", "\n", "self", ".", "kernel_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "kernel_quantizer", ")", "\n", "self", ".", "recurrent_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "recurrent_quantizer", ")", "\n", "self", ".", "bias_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "bias_quantizer", ")", "\n", "self", ".", "state_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "state_quantizer", ")", "\n", "\n", "self", ".", "quantizers", "=", "[", "\n", "self", ".", "kernel_quantizer_internal", ",", "\n", "self", ".", "recurrent_quantizer_internal", ",", "\n", "self", ".", "bias_quantizer_internal", ",", "\n", "self", ".", "state_quantizer_internal", "\n", "]", "\n", "\n", "if", "hasattr", "(", "self", ".", "kernel_quantizer_internal", ",", "\"_set_trainable_parameter\"", ")", ":", "\n", "      ", "self", ".", "kernel_quantizer_internal", ".", "_set_trainable_parameter", "(", ")", "\n", "\n", "", "if", "hasattr", "(", "self", ".", "recurrent_quantizer_internal", ",", "\"_set_trainable_parameter\"", ")", ":", "\n", "      ", "self", ".", "recurrent_quantizer_internal", ".", "_set_trainable_parameter", "(", ")", "\n", "\n", "", "kernel_constraint", ",", "kernel_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "kernel_quantizer_internal", ",", "\n", "kernel_constraint", ",", "\n", "kernel_initializer", ")", ")", "\n", "\n", "recurrent_constraint", ",", "recurrent_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "recurrent_quantizer_internal", ",", "\n", "recurrent_constraint", ",", "\n", "recurrent_initializer", ")", ")", "\n", "\n", "if", "use_bias", ":", "\n", "      ", "bias_constraint", ",", "bias_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "bias_quantizer_internal", ",", "\n", "bias_constraint", ",", "\n", "bias_initializer", ")", ")", "\n", "\n", "", "if", "activation", "is", "not", "None", ":", "\n", "      ", "activation", "=", "get_quantizer", "(", "activation", ")", "\n", "\n", "", "if", "recurrent_activation", "is", "not", "None", ":", "\n", "      ", "recurrent_activation", "=", "get_quantizer", "(", "recurrent_activation", ")", "\n", "\n", "", "super", "(", "QGRUCell", ",", "self", ")", ".", "__init__", "(", "\n", "units", "=", "units", ",", "\n", "activation", "=", "activation", ",", "\n", "recurrent_activation", "=", "recurrent_activation", ",", "\n", "use_bias", "=", "use_bias", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "recurrent_initializer", "=", "recurrent_initializer", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "recurrent_regularizer", "=", "recurrent_regularizer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "recurrent_constraint", "=", "recurrent_constraint", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "dropout", "=", "dropout", ",", "\n", "recurrent_dropout", "=", "recurrent_dropout", ",", "\n", "implementation", "=", "implementation", ",", "\n", "reset_after", "=", "reset_after", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRUCell.call": [[1067, 1187], ["qrecurrent.QGRUCell.get_dropout_mask_for_cell", "qrecurrent.QGRUCell.get_recurrent_dropout_mask_for_cell", "tensorflow.python.util.nest.is_sequence", "tensorflow.python.util.nest.is_sequence", "qrecurrent.QGRUCell.state_quantizer_internal", "qrecurrent.QGRUCell.kernel_quantizer_internal", "qrecurrent.QGRUCell.recurrent_quantizer_internal", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "qrecurrent.QGRUCell.recurrent_activation", "qrecurrent.QGRUCell.recurrent_activation", "qrecurrent.QGRUCell.activation", "tensorflow.dot", "tensorflow.dot", "tensorflow.python.ops.array_ops.split", "tensorflow.python.ops.array_ops.split", "tensorflow.python.ops.array_ops.split", "tensorflow.python.ops.array_ops.split", "qrecurrent.QGRUCell.recurrent_activation", "qrecurrent.QGRUCell.recurrent_activation", "qrecurrent.QGRUCell.activation", "qrecurrent.QGRUCell.bias_quantizer_internal", "tensorflow.python.ops.array_ops.unstack", "tensorflow.python.ops.array_ops.unstack", "tensorflow.bias_add", "tensorflow.bias_add", "tensorflow.bias_add", "tensorflow.bias_add", "tensorflow.bias_add", "tensorflow.bias_add", "tensorflow.bias_add", "tensorflow.bias_add", "tensorflow.bias_add", "tensorflow.bias_add", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.bias_add", "tensorflow.bias_add", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.dot", "tensorflow.bias_add", "tensorflow.bias_add", "tensorflow.bias_add", "tensorflow.bias_add"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.state_quantizer_internal", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.kernel_quantizer_internal", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.recurrent_quantizer_internal", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.recurrent_activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.recurrent_activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QBidirectional.activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.recurrent_activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.recurrent_activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QBidirectional.activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.bias_quantizer_internal"], ["", "def", "call", "(", "self", ",", "inputs", ",", "states", ",", "training", "=", "None", ")", ":", "\n", "# previous memory", "\n", "    ", "h_tm1_tmp", "=", "states", "[", "0", "]", "if", "nest", ".", "is_sequence", "(", "states", ")", "else", "states", "\n", "\n", "dp_mask", "=", "self", ".", "get_dropout_mask_for_cell", "(", "inputs", ",", "training", ",", "count", "=", "3", ")", "\n", "rec_dp_mask", "=", "self", ".", "get_recurrent_dropout_mask_for_cell", "(", "\n", "h_tm1_tmp", ",", "training", ",", "count", "=", "3", ")", "\n", "\n", "if", "self", ".", "state_quantizer", ":", "\n", "      ", "h_tm1", "=", "self", ".", "state_quantizer_internal", "(", "h_tm1_tmp", ")", "\n", "", "else", ":", "\n", "      ", "h_tm1", "=", "h_tm1_tmp", "\n", "\n", "", "if", "self", ".", "kernel_quantizer", ":", "\n", "      ", "quantized_kernel", "=", "self", ".", "kernel_quantizer_internal", "(", "self", ".", "kernel", ")", "\n", "", "else", ":", "\n", "      ", "quantized_kernel", "=", "self", ".", "kernel", "\n", "", "if", "self", ".", "recurrent_quantizer", ":", "\n", "      ", "quantized_recurrent", "=", "self", ".", "recurrent_quantizer_internal", "(", "self", ".", "recurrent_kernel", ")", "\n", "", "else", ":", "\n", "      ", "quantized_recurrent", "=", "self", ".", "kernel", "\n", "\n", "", "if", "self", ".", "use_bias", ":", "\n", "      ", "if", "self", ".", "bias_quantizer", ":", "\n", "        ", "quantized_bias", "=", "self", ".", "bias_quantizer_internal", "(", "self", ".", "bias", ")", "\n", "", "else", ":", "\n", "        ", "quantized_bias", "=", "self", ".", "bias", "\n", "\n", "", "if", "not", "self", ".", "reset_after", ":", "\n", "        ", "input_bias", ",", "recurrent_bias", "=", "quantized_bias", ",", "None", "\n", "", "else", ":", "\n", "        ", "input_bias", ",", "recurrent_bias", "=", "array_ops", ".", "unstack", "(", "quantized_bias", ")", "\n", "\n", "", "", "if", "self", ".", "implementation", "==", "1", ":", "\n", "      ", "if", "0.", "<", "self", ".", "dropout", "<", "1.", ":", "\n", "        ", "inputs_z", "=", "inputs", "*", "dp_mask", "[", "0", "]", "\n", "inputs_r", "=", "inputs", "*", "dp_mask", "[", "1", "]", "\n", "inputs_h", "=", "inputs", "*", "dp_mask", "[", "2", "]", "\n", "", "else", ":", "\n", "        ", "inputs_z", "=", "inputs", "\n", "inputs_r", "=", "inputs", "\n", "inputs_h", "=", "inputs", "\n", "\n", "", "x_z", "=", "K", ".", "dot", "(", "inputs_z", ",", "quantized_kernel", "[", ":", ",", ":", "self", ".", "units", "]", ")", "\n", "x_r", "=", "K", ".", "dot", "(", "inputs_r", ",", "quantized_kernel", "[", ":", ",", "self", ".", "units", ":", "self", ".", "units", "*", "2", "]", ")", "\n", "x_h", "=", "K", ".", "dot", "(", "inputs_h", ",", "quantized_kernel", "[", ":", ",", "self", ".", "units", "*", "2", ":", "]", ")", "\n", "\n", "if", "self", ".", "use_bias", ":", "\n", "        ", "x_z", "=", "K", ".", "bias_add", "(", "x_z", ",", "input_bias", "[", ":", "self", ".", "units", "]", ")", "\n", "x_r", "=", "K", ".", "bias_add", "(", "x_r", ",", "input_bias", "[", "self", ".", "units", ":", "self", ".", "units", "*", "2", "]", ")", "\n", "x_h", "=", "K", ".", "bias_add", "(", "x_h", ",", "input_bias", "[", "self", ".", "units", "*", "2", ":", "]", ")", "\n", "\n", "", "if", "0.", "<", "self", ".", "recurrent_dropout", "<", "1.", ":", "\n", "        ", "h_tm1_z", "=", "h_tm1", "*", "rec_dp_mask", "[", "0", "]", "\n", "h_tm1_r", "=", "h_tm1", "*", "rec_dp_mask", "[", "1", "]", "\n", "h_tm1_h", "=", "h_tm1", "*", "rec_dp_mask", "[", "2", "]", "\n", "", "else", ":", "\n", "        ", "h_tm1_z", "=", "h_tm1", "\n", "h_tm1_r", "=", "h_tm1", "\n", "h_tm1_h", "=", "h_tm1", "\n", "\n", "", "recurrent_z", "=", "K", ".", "dot", "(", "h_tm1_z", ",", "quantized_recurrent", "[", ":", ",", ":", "self", ".", "units", "]", ")", "\n", "recurrent_r", "=", "K", ".", "dot", "(", "h_tm1_r", ",", "\n", "quantized_recurrent", "[", ":", ",", "self", ".", "units", ":", "self", ".", "units", "*", "2", "]", ")", "\n", "if", "self", ".", "reset_after", "and", "self", ".", "use_bias", ":", "\n", "        ", "recurrent_z", "=", "K", ".", "bias_add", "(", "recurrent_z", ",", "recurrent_bias", "[", ":", "self", ".", "units", "]", ")", "\n", "recurrent_r", "=", "K", ".", "bias_add", "(", "recurrent_r", ",", "\n", "recurrent_bias", "[", "self", ".", "units", ":", "self", ".", "units", "*", "2", "]", ")", "\n", "\n", "", "z", "=", "self", ".", "recurrent_activation", "(", "x_z", "+", "recurrent_z", ")", "\n", "r", "=", "self", ".", "recurrent_activation", "(", "x_r", "+", "recurrent_r", ")", "\n", "\n", "# reset gate applied after/before matrix multiplication", "\n", "if", "self", ".", "reset_after", ":", "\n", "        ", "recurrent_h", "=", "K", ".", "dot", "(", "h_tm1_h", ",", "quantized_recurrent", "[", ":", ",", "self", ".", "units", "*", "2", ":", "]", ")", "\n", "if", "self", ".", "use_bias", ":", "\n", "          ", "recurrent_h", "=", "K", ".", "bias_add", "(", "recurrent_h", ",", "recurrent_bias", "[", "self", ".", "units", "*", "2", ":", "]", ")", "\n", "", "recurrent_h", "=", "r", "*", "recurrent_h", "\n", "", "else", ":", "\n", "        ", "recurrent_h", "=", "K", ".", "dot", "(", "r", "*", "h_tm1_h", ",", "\n", "quantized_recurrent", "[", ":", ",", "self", ".", "units", "*", "2", ":", "]", ")", "\n", "\n", "", "hh", "=", "self", ".", "activation", "(", "x_h", "+", "recurrent_h", ")", "\n", "", "else", ":", "\n", "      ", "if", "0.", "<", "self", ".", "dropout", "<", "1.", ":", "\n", "        ", "inputs", "=", "inputs", "*", "dp_mask", "[", "0", "]", "\n", "\n", "# inputs projected by all gate matrices at once", "\n", "", "matrix_x", "=", "K", ".", "dot", "(", "inputs", ",", "quantized_kernel", ")", "\n", "if", "self", ".", "use_bias", ":", "\n", "# biases: bias_z_i, bias_r_i, bias_h_i", "\n", "        ", "matrix_x", "=", "K", ".", "bias_add", "(", "matrix_x", ",", "input_bias", ")", "\n", "\n", "", "x_z", ",", "x_r", ",", "x_h", "=", "array_ops", ".", "split", "(", "matrix_x", ",", "3", ",", "axis", "=", "-", "1", ")", "\n", "\n", "if", "self", ".", "reset_after", ":", "\n", "# hidden state projected by all gate matrices at once", "\n", "        ", "matrix_inner", "=", "K", ".", "dot", "(", "h_tm1", ",", "quantized_recurrent", ")", "\n", "if", "self", ".", "use_bias", ":", "\n", "          ", "matrix_inner", "=", "K", ".", "bias_add", "(", "matrix_inner", ",", "recurrent_bias", ")", "\n", "", "", "else", ":", "\n", "# hidden state projected separately for update/reset and new", "\n", "        ", "matrix_inner", "=", "K", ".", "dot", "(", "h_tm1", ",", "quantized_recurrent", "[", ":", ",", ":", "2", "*", "self", ".", "units", "]", ")", "\n", "\n", "", "recurrent_z", ",", "recurrent_r", ",", "recurrent_h", "=", "array_ops", ".", "split", "(", "\n", "matrix_inner", ",", "[", "self", ".", "units", ",", "self", ".", "units", ",", "-", "1", "]", ",", "axis", "=", "-", "1", ")", "\n", "\n", "z", "=", "self", ".", "recurrent_activation", "(", "x_z", "+", "recurrent_z", ")", "\n", "r", "=", "self", ".", "recurrent_activation", "(", "x_r", "+", "recurrent_r", ")", "\n", "\n", "if", "self", ".", "reset_after", ":", "\n", "        ", "recurrent_h", "=", "r", "*", "recurrent_h", "\n", "", "else", ":", "\n", "        ", "recurrent_h", "=", "K", ".", "dot", "(", "r", "*", "h_tm1", ",", "\n", "quantized_recurrent", "[", ":", ",", "2", "*", "self", ".", "units", ":", "]", ")", "\n", "\n", "", "hh", "=", "self", ".", "activation", "(", "x_h", "+", "recurrent_h", ")", "\n", "# previous and candidate state mixed by update gate", "\n", "", "h", "=", "z", "*", "h_tm1", "+", "(", "1", "-", "z", ")", "*", "hh", "\n", "return", "h", ",", "[", "h", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRUCell.get_config": [[1188, 1201], ["super().get_config", "dict", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "list", "list", "super().get_config.items", "config.items"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "\"kernel_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "kernel_quantizer_internal", ")", ",", "\n", "\"recurrent_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "recurrent_quantizer_internal", ")", ",", "\n", "\"bias_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "bias_quantizer_internal", ")", ",", "\n", "\"state_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "state_quantizer_internal", ")", "\n", "}", "\n", "base_config", "=", "super", "(", "QGRUCell", ",", "self", ")", ".", "get_config", "(", ")", "\n", "return", "dict", "(", "list", "(", "base_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.__init__": [[1223, 1299], ["qrecurrent.QGRUCell", "tensorflow.keras.layers.RNN.__init__", "tensorflow.keras.regularizers.get", "tensorflow.keras.regularizers.get", "print", "tensorflow.keras.layers.InputSpec", "tensorflow.keras.layers.InputSpec", "kwargs.pop", "kwargs.get", "kwargs.get"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "\n", "units", ",", "\n", "activation", "=", "'quantized_tanh'", ",", "\n", "recurrent_activation", "=", "'hard_sigmoid'", ",", "\n", "use_bias", "=", "True", ",", "\n", "kernel_initializer", "=", "'glorot_uniform'", ",", "\n", "recurrent_initializer", "=", "'orthogonal'", ",", "\n", "bias_initializer", "=", "'zeros'", ",", "\n", "kernel_regularizer", "=", "None", ",", "\n", "recurrent_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "activity_regularizer", "=", "None", ",", "\n", "kernel_constraint", "=", "None", ",", "\n", "recurrent_constraint", "=", "None", ",", "\n", "bias_constraint", "=", "None", ",", "\n", "kernel_quantizer", "=", "None", ",", "\n", "recurrent_quantizer", "=", "None", ",", "\n", "bias_quantizer", "=", "None", ",", "\n", "state_quantizer", "=", "None", ",", "\n", "dropout", "=", "0.", ",", "\n", "recurrent_dropout", "=", "0.", ",", "\n", "implementation", "=", "1", ",", "\n", "return_sequences", "=", "False", ",", "\n", "return_state", "=", "False", ",", "\n", "go_backwards", "=", "False", ",", "\n", "stateful", "=", "False", ",", "\n", "unroll", "=", "False", ",", "\n", "reset_after", "=", "False", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "if", "implementation", "==", "0", ":", "\n", "      ", "print", "(", "'`implementation=0` has been deprecated, '", "\n", "'and now defaults to `implementation=1`.'", "\n", "'Please update your layer call.'", ")", "\n", "\n", "", "if", "'enable_caching_device'", "in", "kwargs", ":", "\n", "      ", "cell_kwargs", "=", "{", "'enable_caching_device'", ":", "\n", "kwargs", ".", "pop", "(", "'enable_caching_device'", ")", "}", "\n", "", "else", ":", "\n", "      ", "cell_kwargs", "=", "{", "}", "\n", "\n", "", "cell", "=", "QGRUCell", "(", "\n", "units", ",", "\n", "activation", "=", "activation", ",", "\n", "recurrent_activation", "=", "recurrent_activation", ",", "\n", "use_bias", "=", "use_bias", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "recurrent_initializer", "=", "recurrent_initializer", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "recurrent_regularizer", "=", "recurrent_regularizer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "recurrent_constraint", "=", "recurrent_constraint", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "kernel_quantizer", "=", "kernel_quantizer", ",", "\n", "recurrent_quantizer", "=", "recurrent_quantizer", ",", "\n", "bias_quantizer", "=", "bias_quantizer", ",", "\n", "state_quantizer", "=", "state_quantizer", ",", "\n", "dropout", "=", "dropout", ",", "\n", "recurrent_dropout", "=", "recurrent_dropout", ",", "\n", "implementation", "=", "implementation", ",", "\n", "reset_after", "=", "reset_after", ",", "\n", "dtype", "=", "kwargs", ".", "get", "(", "'dtype'", ")", ",", "\n", "trainable", "=", "kwargs", ".", "get", "(", "'trainable'", ",", "True", ")", ",", "\n", "**", "cell_kwargs", ")", "\n", "\n", "super", "(", "QGRU", ",", "self", ")", ".", "__init__", "(", "\n", "cell", ",", "\n", "return_sequences", "=", "return_sequences", ",", "\n", "return_state", "=", "return_state", ",", "\n", "go_backwards", "=", "go_backwards", ",", "\n", "stateful", "=", "stateful", ",", "\n", "unroll", "=", "unroll", ",", "\n", "**", "kwargs", ")", "\n", "self", ".", "activity_regularizer", "=", "regularizers", ".", "get", "(", "activity_regularizer", ")", "\n", "self", ".", "input_spec", "=", "[", "tf", ".", "keras", ".", "layers", ".", "InputSpec", "(", "ndim", "=", "3", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.call": [[1300, 1304], ["qrecurrent.QGRU._maybe_reset_cell_dropout_mask", "super().call"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.call"], ["", "def", "call", "(", "self", ",", "inputs", ",", "mask", "=", "None", ",", "training", "=", "None", ",", "initial_state", "=", "None", ")", ":", "\n", "    ", "self", ".", "_maybe_reset_cell_dropout_mask", "(", "self", ".", "cell", ")", "\n", "return", "super", "(", "QGRU", ",", "self", ")", ".", "call", "(", "\n", "inputs", ",", "mask", "=", "mask", ",", "training", "=", "training", ",", "initial_state", "=", "initial_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.get_quantizers": [[1305, 1307], ["None"], "methods", ["None"], ["", "def", "get_quantizers", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "quantizers", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.get_prunable_weights": [[1308, 1310], ["None"], "methods", ["None"], ["", "def", "get_prunable_weights", "(", "self", ")", ":", "\n", "    ", "return", "[", "self", ".", "cell", ".", "kernel", ",", "self", ".", "cell", ".", "recurrent_kernel", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.units": [[1311, 1314], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "units", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "units", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.activation": [[1315, 1318], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "activation", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "activation", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.recurrent_activation": [[1319, 1322], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_activation", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "recurrent_activation", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.use_bias": [[1323, 1326], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "use_bias", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "use_bias", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.kernel_initializer": [[1327, 1330], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "kernel_initializer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "kernel_initializer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.recurrent_initializer": [[1331, 1334], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_initializer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "recurrent_initializer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.bias_initializer": [[1335, 1338], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "bias_initializer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "bias_initializer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.kernel_regularizer": [[1339, 1342], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "kernel_regularizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "kernel_regularizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.recurrent_regularizer": [[1343, 1346], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_regularizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "recurrent_regularizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.bias_regularizer": [[1347, 1350], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "bias_regularizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "bias_regularizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.kernel_constraint": [[1351, 1354], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "kernel_constraint", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "kernel_constraint", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.recurrent_constraint": [[1355, 1358], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_constraint", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "recurrent_constraint", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.bias_constraint": [[1359, 1362], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "bias_constraint", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "bias_constraint", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.kernel_quantizer_internal": [[1363, 1366], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "kernel_quantizer_internal", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "kernel_quantizer_internal", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.recurrent_quantizer_internal": [[1367, 1370], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_quantizer_internal", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "recurrent_quantizer_internal", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.bias_quantizer_internal": [[1371, 1374], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "bias_quantizer_internal", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "bias_quantizer_internal", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.state_quantizer_internal": [[1375, 1378], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "state_quantizer_internal", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "state_quantizer_internal", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.kernel_quantizer": [[1379, 1382], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "kernel_quantizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "kernel_quantizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.recurrent_quantizer": [[1383, 1386], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_quantizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "recurrent_quantizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.bias_quantizer": [[1387, 1390], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "bias_quantizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "bias_quantizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.state_quantizer": [[1391, 1394], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "state_quantizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "state_quantizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.dropout": [[1395, 1398], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "dropout", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "dropout", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.recurrent_dropout": [[1399, 1402], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_dropout", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "recurrent_dropout", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.implementation": [[1403, 1406], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "implementation", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "implementation", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.reset_after": [[1407, 1410], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "reset_after", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "cell", ".", "reset_after", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.get_config": [[1411, 1461], ["super().get_config", "dict", "tensorflow.keras.activations.serialize", "tensorflow.keras.activations.serialize", "tensorflow.keras.activations.serialize", "tensorflow.keras.activations.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "list", "list", "super().get_config.items", "config.items"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "'units'", ":", "\n", "self", ".", "units", ",", "\n", "'activation'", ":", "\n", "activations", ".", "serialize", "(", "self", ".", "activation", ")", ",", "\n", "'recurrent_activation'", ":", "\n", "activations", ".", "serialize", "(", "self", ".", "recurrent_activation", ")", ",", "\n", "'use_bias'", ":", "\n", "self", ".", "use_bias", ",", "\n", "'kernel_initializer'", ":", "\n", "initializers", ".", "serialize", "(", "self", ".", "kernel_initializer", ")", ",", "\n", "'recurrent_initializer'", ":", "\n", "initializers", ".", "serialize", "(", "self", ".", "recurrent_initializer", ")", ",", "\n", "'bias_initializer'", ":", "\n", "initializers", ".", "serialize", "(", "self", ".", "bias_initializer", ")", ",", "\n", "'kernel_regularizer'", ":", "\n", "regularizers", ".", "serialize", "(", "self", ".", "kernel_regularizer", ")", ",", "\n", "'recurrent_regularizer'", ":", "\n", "regularizers", ".", "serialize", "(", "self", ".", "recurrent_regularizer", ")", ",", "\n", "'bias_regularizer'", ":", "\n", "regularizers", ".", "serialize", "(", "self", ".", "bias_regularizer", ")", ",", "\n", "'activity_regularizer'", ":", "\n", "regularizers", ".", "serialize", "(", "self", ".", "activity_regularizer", ")", ",", "\n", "'kernel_constraint'", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "kernel_constraint", ")", ",", "\n", "'recurrent_constraint'", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "recurrent_constraint", ")", ",", "\n", "'bias_constraint'", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "bias_constraint", ")", ",", "\n", "\"kernel_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "kernel_quantizer_internal", ")", ",", "\n", "\"recurrent_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "recurrent_quantizer_internal", ")", ",", "\n", "\"bias_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "bias_quantizer_internal", ")", ",", "\n", "\"state_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "state_quantizer_internal", ")", ",", "\n", "'dropout'", ":", "\n", "self", ".", "dropout", ",", "\n", "'recurrent_dropout'", ":", "\n", "self", ".", "recurrent_dropout", ",", "\n", "'implementation'", ":", "\n", "self", ".", "implementation", ",", "\n", "'reset_after'", ":", "\n", "self", ".", "reset_after", "\n", "}", "\n", "base_config", "=", "super", "(", "QGRU", ",", "self", ")", ".", "get_config", "(", ")", "\n", "del", "base_config", "[", "'cell'", "]", "\n", "return", "dict", "(", "list", "(", "base_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.get_quantization_config": [[1462, 1476], ["str", "str", "str", "str", "str", "str"], "methods", ["None"], ["", "def", "get_quantization_config", "(", "self", ")", ":", "\n", "    ", "return", "{", "\n", "\"kernel_quantizer\"", ":", "\n", "str", "(", "self", ".", "kernel_quantizer_internal", ")", ",", "\n", "\"recurrent_quantizer\"", ":", "\n", "str", "(", "self", ".", "recurrent_quantizer_internal", ")", ",", "\n", "\"bias_quantizer\"", ":", "\n", "str", "(", "self", ".", "bias_quantizer_internal", ")", ",", "\n", "\"state_quantizer\"", ":", "\n", "str", "(", "self", ".", "state_quantizer_internal", ")", ",", "\n", "\"activation\"", ":", "\n", "str", "(", "self", ".", "activation", ")", ",", "\n", "\"recurrent_activation\"", ":", "\n", "str", "(", "self", ".", "recurrent_activation", ")", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.from_config": [[1478, 1483], ["cls"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "config", ")", ":", "\n", "    ", "if", "'implementation'", "in", "config", "and", "config", "[", "'implementation'", "]", "==", "0", ":", "\n", "      ", "config", "[", "'implementation'", "]", "=", "1", "\n", "", "return", "cls", "(", "**", "config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QBidirectional.get_quantizers": [[1496, 1501], ["qrecurrent.QBidirectional.forward_layer.get_quantizers", "qrecurrent.QBidirectional.backward_layer.get_quantizers"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers"], ["def", "get_quantizers", "(", "self", ")", ":", "\n", "    ", "\"\"\"\n    Returns quantizers in the order they were created.\n    \"\"\"", "\n", "return", "self", ".", "forward_layer", ".", "get_quantizers", "(", ")", "+", "self", ".", "backward_layer", ".", "get_quantizers", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QBidirectional.activation": [[1502, 1505], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "activation", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "layer", ".", "activation", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QBidirectional.get_quantization_config": [[1506, 1510], ["qrecurrent.QBidirectional.layer.get_quantization_config", "qrecurrent.QBidirectional.backward_layer.get_quantization_config"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantization_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantization_config"], ["", "def", "get_quantization_config", "(", "self", ")", ":", "\n", "    ", "return", "{", "\n", "\"layer\"", ":", "self", ".", "layer", ".", "get_quantization_config", "(", ")", ",", "\n", "\"backward_layer\"", ":", "self", ".", "backward_layer", ".", "get_quantization_config", "(", ")", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qdepthwiseconv2d_batchnorm.QDepthwiseConv2DBatchnorm.__init__": [[34, 149], ["qconvolutional.QDepthwiseConv2D.__init__", "tensorflow.keras.layers.BatchNormalization"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "# QDepthwiseConv2d params", "\n", "kernel_size", ",", "\n", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "padding", "=", "\"VALID\"", ",", "\n", "depth_multiplier", "=", "1", ",", "\n", "data_format", "=", "None", ",", "\n", "activation", "=", "None", ",", "\n", "use_bias", "=", "True", ",", "\n", "depthwise_initializer", "=", "\"he_normal\"", ",", "\n", "bias_initializer", "=", "\"zeros\"", ",", "\n", "depthwise_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "activity_regularizer", "=", "None", ",", "\n", "depthwise_constraint", "=", "None", ",", "\n", "bias_constraint", "=", "None", ",", "\n", "dilation_rate", "=", "(", "1", ",", "1", ")", ",", "\n", "depthwise_quantizer", "=", "None", ",", "\n", "bias_quantizer", "=", "None", ",", "\n", "depthwise_range", "=", "None", ",", "\n", "bias_range", "=", "None", ",", "\n", "\n", "# batchnorm params", "\n", "axis", "=", "-", "1", ",", "\n", "momentum", "=", "0.99", ",", "\n", "epsilon", "=", "0.001", ",", "\n", "center", "=", "True", ",", "\n", "scale", "=", "True", ",", "\n", "beta_initializer", "=", "\"zeros\"", ",", "\n", "gamma_initializer", "=", "\"ones\"", ",", "\n", "moving_mean_initializer", "=", "\"zeros\"", ",", "\n", "moving_variance_initializer", "=", "\"ones\"", ",", "\n", "beta_regularizer", "=", "None", ",", "\n", "gamma_regularizer", "=", "None", ",", "\n", "beta_constraint", "=", "None", ",", "\n", "gamma_constraint", "=", "None", ",", "\n", "renorm", "=", "False", ",", "\n", "renorm_clipping", "=", "None", ",", "\n", "renorm_momentum", "=", "0.99", ",", "\n", "fused", "=", "None", ",", "\n", "trainable", "=", "True", ",", "\n", "virtual_batch_size", "=", "None", ",", "\n", "adjustment", "=", "None", ",", "\n", "\n", "# other params", "\n", "ema_freeze_delay", "=", "None", ",", "\n", "folding_mode", "=", "\"ema_stats_folding\"", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "    ", "\"\"\"A composite layer that folds depthwiseconv2d and batch normalization.\n\n    The first group of parameters correponds to the initialization parameters\n      of a QDepthwiseConv2d layer. check qkeras.qconvolutional.QDepthwiseConv2D\n      for details.\n\n    The 2nd group of parameters corresponds to the initialization parameters\n      of a BatchNormalization layer. Check keras.layers.normalization.BatchNorma\n      lizationBase for details.\n\n    The 3rd group of parameters corresponds to the initialization parameters\n      specific to this class.\n\n      ema_freeze_delay: int or None. number of steps before batch normalization\n        mv_mean and mv_variance will be frozen and used in the folded layer.\n      folding_mode: string\n        \"ema_stats_folding\": mimic tflite which uses the ema statistics to\n          fold the kernel to suppress quantization induced jitter then performs\n          the correction to have a similar effect of using the current batch\n          statistics.\n        \"batch_stats_folding\": use batch mean and variance to fold kernel first;\n          after enough training steps switch to moving_mean and moving_variance\n          for kernel folding.\n    \"\"\"", "\n", "\n", "# intialization the QDepthwiseConv2d part of the composite layer", "\n", "super", "(", "QDepthwiseConv2DBatchnorm", ",", "self", ")", ".", "__init__", "(", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "depth_multiplier", "=", "depth_multiplier", ",", "\n", "data_format", "=", "data_format", ",", "\n", "activation", "=", "activation", ",", "\n", "use_bias", "=", "use_bias", ",", "\n", "depthwise_initializer", "=", "depthwise_initializer", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "depthwise_regularizer", "=", "depthwise_regularizer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "activity_regularizer", "=", "activity_regularizer", ",", "\n", "depthwise_constraint", "=", "depthwise_constraint", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "dilation_rate", "=", "dilation_rate", ",", "\n", "depthwise_quantizer", "=", "depthwise_quantizer", ",", "\n", "bias_quantizer", "=", "bias_quantizer", ",", "\n", "depthwise_range", "=", "depthwise_range", ",", "\n", "bias_range", "=", "bias_range", ",", "\n", "**", "kwargs", ")", "\n", "\n", "# initialization of batchnorm part of the composite layer", "\n", "self", ".", "batchnorm", "=", "layers", ".", "BatchNormalization", "(", "\n", "axis", "=", "axis", ",", "momentum", "=", "momentum", ",", "epsilon", "=", "epsilon", ",", "center", "=", "center", ",", "\n", "scale", "=", "scale", ",", "beta_initializer", "=", "beta_initializer", ",", "\n", "gamma_initializer", "=", "gamma_initializer", ",", "\n", "moving_mean_initializer", "=", "moving_mean_initializer", ",", "\n", "moving_variance_initializer", "=", "moving_variance_initializer", ",", "\n", "beta_regularizer", "=", "beta_regularizer", ",", "\n", "gamma_regularizer", "=", "gamma_regularizer", ",", "\n", "beta_constraint", "=", "beta_constraint", ",", "gamma_constraint", "=", "gamma_constraint", ",", "\n", "renorm", "=", "renorm", ",", "renorm_clipping", "=", "renorm_clipping", ",", "\n", "renorm_momentum", "=", "renorm_momentum", ",", "fused", "=", "fused", ",", "trainable", "=", "trainable", ",", "\n", "virtual_batch_size", "=", "virtual_batch_size", ",", "adjustment", "=", "adjustment", ")", "\n", "\n", "self", ".", "ema_freeze_delay", "=", "ema_freeze_delay", "\n", "assert", "folding_mode", "in", "[", "\"ema_stats_folding\"", ",", "\"batch_stats_folding\"", "]", "\n", "self", ".", "folding_mode", "=", "folding_mode", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qdepthwiseconv2d_batchnorm.QDepthwiseConv2DBatchnorm.build": [[150, 159], ["super().build", "tensorflow.Variable"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.networks.conv_block.ConvBlockNetwork.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "    ", "super", "(", "QDepthwiseConv2DBatchnorm", ",", "self", ")", ".", "build", "(", "input_shape", ")", "\n", "\n", "# If start training from scratch, self._iteration (i.e., training_steps)", "\n", "# is initialized with -1. When loading ckpt, it can load the number of", "\n", "# training steps that have been previously trainied.", "\n", "# TODO(lishanok): develop a way to count iterations outside layer", "\n", "self", ".", "_iteration", "=", "tf", ".", "Variable", "(", "-", "1", ",", "trainable", "=", "False", ",", "name", "=", "\"iteration\"", ",", "\n", "dtype", "=", "tf", ".", "int64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qdepthwiseconv2d_batchnorm.QDepthwiseConv2DBatchnorm.call": [[160, 306], ["qdepthwiseconv2d_batchnorm.QDepthwiseConv2DBatchnorm.batchnorm._get_training_value", "tensorflow.keras.backend.depthwise_conv2d", "qdepthwiseconv2d_batchnorm.QDepthwiseConv2DBatchnorm.batchnorm", "qdepthwiseconv2d_batchnorm.QDepthwiseConv2DBatchnorm._iteration.assign_add", "len", "qdepthwiseconv2d_batchnorm.QDepthwiseConv2DBatchnorm.batchnorm._moments", "tensorflow.python.ops.math_ops.rsqrt", "tensorflow.python.ops.math_ops.rsqrt", "tensorflow.python.framework.smart_cond.smart_cond", "tensorflow.python.ops.array_ops.reshape", "tensorflow.keras.backend.depthwise_conv2d", "tensorflow.keras.backend.bias_add", "tensorflow.cast", "tensorflow.math.logical_and", "tensorflow.keras.backend.bias_add", "tensorflow.python.framework.smart_cond.smart_cond", "len", "tensorflow.python.ops.math_ops.cast", "ValueError", "tensorflow.python.framework.smart_cond.smart_cond", "qdepthwiseconv2d_batchnorm.QDepthwiseConv2DBatchnorm.depthwise_quantizer_internal", "qdepthwiseconv2d_batchnorm.QDepthwiseConv2DBatchnorm.bias_quantizer_internal", "tensorflow.python.ops.math_ops.rsqrt", "tensorflow.python.framework.smart_cond.smart_cond", "tensorflow.python.ops.math_ops.mul", "qdepthwiseconv2d_batchnorm.QDepthwiseConv2DBatchnorm.activation", "tensorflow.math.less_equal", "range", "depthwise_kernel.get_shape().as_list", "depthwise_kernel.get_shape().as_list", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "depthwise_kernel.get_shape", "depthwise_kernel.get_shape", "tensorflow.python.ops.math_ops.sqrt", "tensorflow.python.ops.math_ops.rsqrt"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.bias_quantizer_internal", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QBidirectional.activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "call", "(", "self", ",", "inputs", ",", "training", "=", "None", ")", ":", "\n", "\n", "# numpy value, mark the layer is in training", "\n", "    ", "training", "=", "self", ".", "batchnorm", ".", "_get_training_value", "(", "training", ")", "# pylint: disable=protected-access", "\n", "\n", "# checking if to update batchnorm params", "\n", "if", "(", "self", ".", "ema_freeze_delay", "is", "None", ")", "or", "(", "self", ".", "ema_freeze_delay", "<", "0", ")", ":", "\n", "# if ema_freeze_delay is None or a negative value, do not freeze bn stats", "\n", "      ", "bn_training", "=", "tf", ".", "cast", "(", "training", ",", "dtype", "=", "bool", ")", "\n", "", "else", ":", "\n", "      ", "bn_training", "=", "tf", ".", "math", ".", "logical_and", "(", "training", ",", "tf", ".", "math", ".", "less_equal", "(", "\n", "self", ".", "_iteration", ",", "self", ".", "ema_freeze_delay", ")", ")", "\n", "\n", "", "depthwise_kernel", "=", "self", ".", "depthwise_kernel", "\n", "\n", "# run depthwise_conv2d to produce output for the following batchnorm", "\n", "conv_outputs", "=", "tf", ".", "keras", ".", "backend", ".", "depthwise_conv2d", "(", "\n", "inputs", ",", "\n", "depthwise_kernel", ",", "\n", "strides", "=", "self", ".", "strides", ",", "\n", "padding", "=", "self", ".", "padding", ",", "\n", "dilation_rate", "=", "self", ".", "dilation_rate", ",", "\n", "data_format", "=", "self", ".", "data_format", ")", "\n", "\n", "if", "self", ".", "use_bias", ":", "\n", "      ", "bias", "=", "self", ".", "bias", "\n", "conv_outputs", "=", "tf", ".", "keras", ".", "backend", ".", "bias_add", "(", "\n", "conv_outputs", ",", "bias", ",", "data_format", "=", "self", ".", "data_format", ")", "\n", "", "else", ":", "\n", "      ", "bias", "=", "0", "\n", "\n", "", "_", "=", "self", ".", "batchnorm", "(", "conv_outputs", ",", "training", "=", "bn_training", ")", "\n", "\n", "self", ".", "_iteration", ".", "assign_add", "(", "tf_utils", ".", "smart_cond", "(", "\n", "training", ",", "lambda", ":", "tf", ".", "constant", "(", "1", ",", "tf", ".", "int64", ")", ",", "\n", "lambda", ":", "tf", ".", "constant", "(", "0", ",", "tf", ".", "int64", ")", ")", ")", "\n", "\n", "# calcuate mean and variance from current batch", "\n", "bn_shape", "=", "conv_outputs", ".", "shape", "\n", "ndims", "=", "len", "(", "bn_shape", ")", "\n", "reduction_axes", "=", "[", "i", "for", "i", "in", "range", "(", "ndims", ")", "if", "i", "not", "in", "self", ".", "batchnorm", ".", "axis", "]", "\n", "keep_dims", "=", "len", "(", "self", ".", "batchnorm", ".", "axis", ")", ">", "1", "\n", "mean", ",", "variance", "=", "self", ".", "batchnorm", ".", "_moments", "(", "# pylint: disable=protected-access", "\n", "math_ops", ".", "cast", "(", "conv_outputs", ",", "self", ".", "batchnorm", ".", "_param_dtype", ")", ",", "# pylint: disable=protected-access", "\n", "reduction_axes", ",", "\n", "keep_dims", "=", "keep_dims", ")", "\n", "gamma", "=", "self", ".", "batchnorm", ".", "gamma", "\n", "beta", "=", "self", ".", "batchnorm", ".", "beta", "\n", "moving_mean", "=", "self", ".", "batchnorm", ".", "moving_mean", "\n", "moving_variance", "=", "self", ".", "batchnorm", ".", "moving_variance", "\n", "\n", "if", "self", ".", "folding_mode", "not", "in", "[", "\"batch_stats_folding\"", ",", "\"ema_stats_folding\"", "]", ":", "\n", "      ", "assert", "ValueError", "(", "\"mode {} not supported!\"", ".", "format", "(", "self", ".", "folding_mode", ")", ")", "\n", "\n", "", "mv_inv", "=", "math_ops", ".", "rsqrt", "(", "moving_variance", "+", "self", ".", "batchnorm", ".", "epsilon", ")", "\n", "batch_inv", "=", "math_ops", ".", "rsqrt", "(", "variance", "+", "self", ".", "batchnorm", ".", "epsilon", ")", "\n", "\n", "if", "gamma", "is", "not", "None", ":", "\n", "      ", "mv_inv", "*=", "gamma", "\n", "batch_inv", "*=", "gamma", "\n", "\n", "", "folded_bias", "=", "tf_utils", ".", "smart_cond", "(", "\n", "bn_training", ",", "\n", "lambda", ":", "batch_inv", "*", "(", "bias", "-", "mean", ")", "+", "beta", ",", "\n", "lambda", ":", "mv_inv", "*", "(", "bias", "-", "moving_mean", ")", "+", "beta", ")", "\n", "\n", "if", "self", ".", "folding_mode", "==", "\"batch_stats_folding\"", ":", "\n", "# using batch mean and variance in the initial training stage", "\n", "# after sufficient training, switch to moving mean and variance", "\n", "      ", "inv", "=", "tf_utils", ".", "smart_cond", "(", "bn_training", ",", "lambda", ":", "batch_inv", ",", "lambda", ":", "mv_inv", ")", "\n", "\n", "", "elif", "self", ".", "folding_mode", "==", "\"ema_stats_folding\"", ":", "\n", "# We always scale the weights with a correction factor to the long term", "\n", "# statistics prior to quantization. This ensures that there is no jitter", "\n", "# in the quantized weights due to batch to batch variation. During the", "\n", "# initial phase of training, we undo the scaling of the weights so that", "\n", "# outputs are identical to regular batch normalization. We also modify", "\n", "# the bias terms correspondingly. After sufficient training, switch from", "\n", "# using batch statistics to long term moving averages for batch", "\n", "# normalization.", "\n", "\n", "# use batch stats for calcuating bias before bn freeze, and use moving", "\n", "# stats after bn freeze", "\n", "\n", "# moving stats is always used to fold kernel in tflite; before bn freeze", "\n", "# an additional correction factor will be applied to the depthwiseconv2d", "\n", "# output", "\n", "      ", "inv", "=", "mv_inv", "\n", "\n", "# for DepthwiseConv2D inv needs to be broadcasted to the last 2 dimensions", "\n", "# of the kernels", "\n", "", "depthwise_weights_shape", "=", "[", "\n", "depthwise_kernel", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "2", "]", ",", "\n", "depthwise_kernel", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "3", "]", "\n", "]", "\n", "inv", "=", "array_ops", ".", "reshape", "(", "inv", ",", "depthwise_weights_shape", ")", "\n", "# wrap conv kernel with bn parameters", "\n", "folded_depthwise_kernel", "=", "inv", "*", "depthwise_kernel", "\n", "# quantize the folded kernel", "\n", "if", "self", ".", "depthwise_quantizer", "is", "not", "None", ":", "\n", "      ", "q_folded_depthwise_kernel", "=", "self", ".", "depthwise_quantizer_internal", "(", "\n", "folded_depthwise_kernel", ")", "\n", "", "else", ":", "\n", "      ", "q_folded_depthwise_kernel", "=", "folded_depthwise_kernel", "\n", "\n", "# If loaded from a ckpt, bias_quantizer is the ckpt value", "\n", "# Else if bias_quantizer not specified, bias", "\n", "#   quantizer is None and we need to calculate bias quantizer", "\n", "#   type according to accumulator type. User can call", "\n", "#   bn_folding_utils.populate_bias_quantizer_for_folded_layers(", "\n", "#      model, input_quantizer_list]) to populate such bias quantizer.", "\n", "", "if", "self", ".", "bias_quantizer", "is", "not", "None", ":", "\n", "      ", "q_folded_bias", "=", "self", ".", "bias_quantizer_internal", "(", "folded_bias", ")", "\n", "", "else", ":", "\n", "      ", "q_folded_bias", "=", "folded_bias", "\n", "\n", "", "applied_kernel", "=", "q_folded_depthwise_kernel", "\n", "applied_bias", "=", "q_folded_bias", "\n", "\n", "# calculate depthwise_conv2d output using the quantized folded kernel", "\n", "folded_outputs", "=", "tf", ".", "keras", ".", "backend", ".", "depthwise_conv2d", "(", "\n", "inputs", ",", "\n", "applied_kernel", ",", "\n", "strides", "=", "self", ".", "strides", ",", "\n", "padding", "=", "self", ".", "padding", ",", "\n", "dilation_rate", "=", "self", ".", "dilation_rate", ",", "\n", "data_format", "=", "self", ".", "data_format", ")", "\n", "\n", "if", "training", "is", "True", "and", "self", ".", "folding_mode", "==", "\"ema_stats_folding\"", ":", "\n", "      ", "batch_inv", "=", "math_ops", ".", "rsqrt", "(", "variance", "+", "self", ".", "batchnorm", ".", "epsilon", ")", "\n", "y_corr", "=", "tf_utils", ".", "smart_cond", "(", "\n", "bn_training", ",", "\n", "lambda", ":", "(", "math_ops", ".", "sqrt", "(", "moving_variance", "+", "self", ".", "batchnorm", ".", "epsilon", ")", "*", "\n", "math_ops", ".", "rsqrt", "(", "variance", "+", "self", ".", "batchnorm", ".", "epsilon", ")", ")", ",", "\n", "lambda", ":", "tf", ".", "constant", "(", "1.0", ",", "shape", "=", "moving_variance", ".", "shape", ")", ")", "\n", "folded_outputs", "=", "math_ops", ".", "mul", "(", "folded_outputs", ",", "y_corr", ")", "\n", "\n", "", "folded_outputs", "=", "tf", ".", "keras", ".", "backend", ".", "bias_add", "(", "\n", "folded_outputs", ",", "\n", "applied_bias", ",", "\n", "data_format", "=", "self", ".", "data_format", ")", "\n", "\n", "if", "self", ".", "activation", "is", "not", "None", ":", "\n", "      ", "return", "self", ".", "activation", "(", "folded_outputs", ")", "\n", "\n", "", "return", "folded_outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qdepthwiseconv2d_batchnorm.QDepthwiseConv2DBatchnorm.get_config": [[307, 321], ["super().get_config", "qdepthwiseconv2d_batchnorm.QDepthwiseConv2DBatchnorm.batchnorm.get_config", "dict", "list", "list", "list", "config.items", "super().get_config.items", "qdepthwiseconv2d_batchnorm.QDepthwiseConv2DBatchnorm.items"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "base_config", "=", "super", "(", ")", ".", "get_config", "(", ")", "\n", "bn_config", "=", "self", ".", "batchnorm", ".", "get_config", "(", ")", "\n", "config", "=", "{", "\"ema_freeze_delay\"", ":", "self", ".", "ema_freeze_delay", ",", "\n", "\"folding_mode\"", ":", "self", ".", "folding_mode", "}", "\n", "name", "=", "base_config", "[", "\"name\"", "]", "\n", "out_config", "=", "dict", "(", "\n", "list", "(", "base_config", ".", "items", "(", ")", ")", "\n", "+", "list", "(", "bn_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n", "# names from different config override each other; use the base layer name", "\n", "# as the this layer's config name", "\n", "out_config", "[", "\"name\"", "]", "=", "name", "\n", "return", "out_config", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qdepthwiseconv2d_batchnorm.QDepthwiseConv2DBatchnorm.get_quantization_config": [[322, 328], ["str", "str", "str", "str"], "methods", ["None"], ["", "def", "get_quantization_config", "(", "self", ")", ":", "\n", "    ", "return", "{", "\n", "\"depthwise_quantizer\"", ":", "str", "(", "self", ".", "depthwise_quantizer_internal", ")", ",", "\n", "\"bias_quantizer\"", ":", "str", "(", "self", ".", "bias_quantizer_internal", ")", ",", "\n", "\"activation\"", ":", "str", "(", "self", ".", "activation", ")", ",", "\n", "\"filters\"", ":", "str", "(", "self", ".", "filters", ")", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qdepthwiseconv2d_batchnorm.QDepthwiseConv2DBatchnorm.get_quantizers": [[330, 332], ["None"], "methods", ["None"], ["", "def", "get_quantizers", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "quantizers", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qdepthwiseconv2d_batchnorm.QDepthwiseConv2DBatchnorm.get_folded_weights": [[333, 374], ["tensorflow.python.ops.math_ops.rsqrt", "tensorflow.python.ops.array_ops.reshape", "depthwise_kernel.get_shape().as_list", "depthwise_kernel.get_shape().as_list", "depthwise_kernel.get_shape", "depthwise_kernel.get_shape"], "methods", ["None"], ["", "def", "get_folded_weights", "(", "self", ")", ":", "\n", "    ", "\"\"\"Function to get the batchnorm folded weights.\n\n    This function converts the weights by folding batchnorm parameters into\n    the weight of QDepthwiseConv2d. The high-level equation:\n\n    W_fold = gamma * W / sqrt(variance + epsilon)\n    bias_fold = gamma * (bias - moving_mean) / sqrt(variance + epsilon) + beta\n    \"\"\"", "\n", "\n", "depthwise_kernel", "=", "self", ".", "depthwise_kernel", "\n", "\n", "if", "self", ".", "use_bias", ":", "\n", "      ", "bias", "=", "self", ".", "bias", "\n", "", "else", ":", "\n", "      ", "bias", "=", "0", "\n", "\n", "# get Batchnorm stats", "\n", "", "gamma", "=", "self", ".", "batchnorm", ".", "gamma", "\n", "beta", "=", "self", ".", "batchnorm", ".", "beta", "\n", "moving_mean", "=", "self", ".", "batchnorm", ".", "moving_mean", "\n", "moving_variance", "=", "self", ".", "batchnorm", ".", "moving_variance", "\n", "\n", "# get the inversion factor so that we replace division by multiplication", "\n", "inv", "=", "math_ops", ".", "rsqrt", "(", "moving_variance", "+", "self", ".", "batchnorm", ".", "epsilon", ")", "\n", "if", "gamma", "is", "not", "None", ":", "\n", "      ", "inv", "*=", "gamma", "\n", "# fold bias with bn stats", "\n", "", "folded_bias", "=", "inv", "*", "(", "bias", "-", "moving_mean", ")", "+", "beta", "\n", "\n", "# for DepthwiseConv2D inv needs to be broadcasted to the last 2 dimensions", "\n", "# of the kernels", "\n", "depthwise_weights_shape", "=", "[", "\n", "depthwise_kernel", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "2", "]", ",", "\n", "depthwise_kernel", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "3", "]", "\n", "]", "\n", "inv", "=", "array_ops", ".", "reshape", "(", "inv", ",", "depthwise_weights_shape", ")", "\n", "# wrap conv kernel with bn parameters", "\n", "folded_depthwise_kernel", "=", "inv", "*", "depthwise_kernel", "\n", "\n", "return", "[", "folded_depthwise_kernel", ",", "folded_bias", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qpooling.QAveragePooling2D.__init__": [[31, 51], ["quantizers.get_quantizer", "tensorflow.keras.layers.AveragePooling2D.__init__", "quantizers.get_quantizer"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer"], ["def", "__init__", "(", "self", ",", "pool_size", "=", "(", "2", ",", "2", ")", ",", "\n", "strides", "=", "None", ",", "\n", "padding", "=", "\"valid\"", ",", "\n", "data_format", "=", "None", ",", "\n", "average_quantizer", "=", "None", ",", "\n", "activation", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "    ", "self", ".", "average_quantizer", "=", "average_quantizer", "\n", "self", ".", "average_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "average_quantizer", ")", "\n", "self", ".", "quantizers", "=", "[", "self", ".", "average_quantizer_internal", "]", "\n", "\n", "if", "activation", "is", "not", "None", ":", "\n", "      ", "self", ".", "activation", "=", "get_quantizer", "(", "activation", ")", "\n", "", "else", ":", "\n", "      ", "self", ".", "activation", "=", "activation", "\n", "\n", "", "super", "(", "QAveragePooling2D", ",", "self", ")", ".", "__init__", "(", "\n", "pool_size", "=", "pool_size", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "\n", "data_format", "=", "data_format", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qpooling.QAveragePooling2D.call": [[52, 103], ["isinstance", "super().call", "qpooling.QAveragePooling2D.average_quantizer_internal", "tensorflow.cast_to_floatx", "tensorflow.cast_to_floatx", "super().call", "qpooling.QAveragePooling2D.activation", "numpy.prod"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.call", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.call", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QBidirectional.activation"], ["", "def", "call", "(", "self", ",", "inputs", ")", ":", "\n", "    ", "\"\"\"Performs quantized AveragePooling followed by QActivation.\n\n    Since there is no specific parameter for averaging op, we couldn't apply\n    averaging quantizer to the averaging op. We have two options:\n    1. we perform our own average as sum first then multiply with the\n       inversion\n       of the division factor: sum(x) * quantize(1/pool_area)\n    2. first, we call keras version of averaging first: y1 = keras_average(x)\n       then multiply it with pool_size^2: y2 = y1 * pool_area\n       Last, y3 = y2 * quantize(1/ pool_area)\n    3. Improved based on #2, but multiply x with pool_area before averaging\n       so that we don't lose precision during averaging. The order now becomes:\n       first, multiply x with pool_area: y1 = x * pool_area\n       then we call keras version of averaging: y2 = keras_average(y1)\n       Last, y3 = y2 * quantize(1/ pool_area)\n    4. Since there is sum_pooling operation, another solution is to use\n       depthwise_conv2d with kernel weights = 1 to get the pooling sum. In this\n       case we don't lose precision due to averaging. However, this solution\n       will introduce extra weights to the layer, which might break our code\n       elsewhere.\n\n    Since we need to match software and hardware inference numerics, we are now\n    using #3 in the implementation.\n    \"\"\"", "\n", "\n", "if", "self", ".", "average_quantizer", ":", "\n", "# Calculates the pool area", "\n", "      ", "if", "isinstance", "(", "self", ".", "pool_size", ",", "int", ")", ":", "\n", "        ", "pool_area", "=", "self", ".", "pool_size", "*", "self", ".", "pool_size", "\n", "", "else", ":", "\n", "        ", "pool_area", "=", "np", ".", "prod", "(", "self", ".", "pool_size", ")", "\n", "\n", "# Calculates the pooling average of x*pool_area", "\n", "", "x", "=", "super", "(", "QAveragePooling2D", ",", "self", ")", ".", "call", "(", "inputs", "*", "pool_area", ")", "\n", "\n", "# Quantizes the multiplication factor.", "\n", "mult_factor", "=", "1.0", "/", "pool_area", "\n", "q_mult_factor", "=", "self", ".", "average_quantizer_internal", "(", "mult_factor", ")", "\n", "q_mult_factor", "=", "K", ".", "cast_to_floatx", "(", "q_mult_factor", ")", "\n", "\n", "# Computes pooling average.", "\n", "x", "=", "x", "*", "q_mult_factor", "\n", "\n", "", "else", ":", "\n", "# Since no quantizer is available, we directly call the keras layer", "\n", "      ", "x", "=", "super", "(", "QAveragePooling2D", ",", "self", ")", ".", "call", "(", "inputs", ")", "\n", "\n", "", "if", "self", ".", "activation", "is", "not", "None", ":", "\n", "      ", "return", "self", ".", "activation", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qpooling.QAveragePooling2D.get_config": [[104, 112], ["super().get_config", "dict", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "list", "list", "super().get_config.items", "config.items"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "\"average_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "average_quantizer_internal", ")", ",", "\n", "\"activation\"", ":", "constraints", ".", "serialize", "(", "self", ".", "activation", ")", ",", "\n", "}", "\n", "base_config", "=", "super", "(", "QAveragePooling2D", ",", "self", ")", ".", "get_config", "(", ")", "\n", "return", "dict", "(", "list", "(", "base_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qpooling.QAveragePooling2D.get_quantization_config": [[113, 119], ["str", "str"], "methods", ["None"], ["", "def", "get_quantization_config", "(", "self", ")", ":", "\n", "    ", "return", "{", "\n", "\"average_quantizer\"", ":", "\n", "str", "(", "self", ".", "average_quantizer_internal", ")", ",", "\n", "\"activation\"", ":", "\n", "str", "(", "self", ".", "activation", ")", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qpooling.QAveragePooling2D.get_quantizers": [[121, 123], ["None"], "methods", ["None"], ["", "def", "get_quantizers", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "quantizers", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qpooling.QGlobalAveragePooling2D.__init__": [[128, 144], ["quantizers.get_quantizer", "tensorflow.keras.layers.GlobalAveragePooling2D.__init__", "quantizers.get_quantizer"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer"], ["def", "__init__", "(", "self", ",", "data_format", "=", "None", ",", "\n", "average_quantizer", "=", "None", ",", "\n", "activation", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "    ", "self", ".", "average_quantizer", "=", "average_quantizer", "\n", "self", ".", "average_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "average_quantizer", ")", "\n", "self", ".", "quantizers", "=", "[", "self", ".", "average_quantizer_internal", "]", "\n", "\n", "if", "activation", "is", "not", "None", ":", "\n", "      ", "self", ".", "activation", "=", "get_quantizer", "(", "activation", ")", "\n", "", "else", ":", "\n", "      ", "self", ".", "activation", "=", "activation", "\n", "\n", "", "super", "(", "QGlobalAveragePooling2D", ",", "self", ")", ".", "__init__", "(", "\n", "data_format", "=", "data_format", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qpooling.QGlobalAveragePooling2D.compute_pooling_area": [[145, 152], ["isinstance", "input_shape.as_list.as_list.as_list"], "methods", ["None"], ["", "def", "compute_pooling_area", "(", "self", ",", "input_shape", ")", ":", "\n", "    ", "if", "not", "isinstance", "(", "input_shape", ",", "tuple", ")", ":", "\n", "      ", "input_shape", "=", "input_shape", ".", "as_list", "(", ")", "\n", "", "if", "self", ".", "data_format", "==", "\"channels_last\"", ":", "\n", "      ", "return", "input_shape", "[", "1", "]", "*", "input_shape", "[", "2", "]", "\n", "", "else", ":", "\n", "      ", "return", "input_shape", "[", "2", "]", "*", "input_shape", "[", "3", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qpooling.QGlobalAveragePooling2D.call": [[153, 198], ["qpooling.QGlobalAveragePooling2D.compute_pooling_area", "qpooling.QGlobalAveragePooling2D.average_quantizer_internal", "super().call", "qpooling.QGlobalAveragePooling2D.activation", "tensorflow.sum", "tensorflow.sum", "tensorflow.sum", "tensorflow.sum"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qpooling.QGlobalAveragePooling2D.compute_pooling_area", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.call", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QBidirectional.activation"], ["", "", "def", "call", "(", "self", ",", "inputs", ")", ":", "\n", "    ", "\"\"\"Performs quantized GlobalAveragePooling followed by QActivation.\n\n    Since there is no specific parameter for averaging op, we couldn't apply\n    averaging quantizer to the averaging op. We have two options:\n    1. we perform our own average as sum first then multiply with the\n       inversion\n       of the division factor: sum(x) * quantize(1/pool_area)\n    2. first, we call keras version of averaging first:\n       y1 = keras_global_average(x)\n       then multiply it with the denominator(pool_area) used by averaging:\n       y2 = y1 * pool_area\n       Last, y3 = y2 * quantize(1/ pool_area)\n    3. we perform pooling sum, and then multiply the sum with the quantized\n       inverse multiplication factor to get the average value.\n\n    Our previous implementation uses option #2. Yet we observed minor numerical\n    mismatch between software and hardware inference. Therefore we use #3 as\n    the current implementation.\n    \"\"\"", "\n", "\n", "if", "self", ".", "average_quantizer", ":", "\n", "# Calculates pooling sum.", "\n", "      ", "if", "self", ".", "data_format", "==", "\"channels_last\"", ":", "\n", "        ", "x", "=", "K", ".", "sum", "(", "inputs", ",", "axis", "=", "[", "1", ",", "2", "]", ",", "keepdims", "=", "self", ".", "keepdims", ")", "\n", "", "else", ":", "\n", "        ", "x", "=", "K", ".", "sum", "(", "inputs", ",", "axis", "=", "[", "2", ",", "3", "]", ",", "keepdims", "=", "self", ".", "keepdims", ")", "\n", "\n", "# Calculates the pooling area", "\n", "", "pool_area", "=", "self", ".", "compute_pooling_area", "(", "input_shape", "=", "inputs", ".", "shape", ")", "\n", "\n", "# Quantizes the inverse multiplication factor", "\n", "mult_factor", "=", "1.0", "/", "pool_area", "\n", "q_mult_factor", "=", "self", ".", "average_quantizer_internal", "(", "mult_factor", ")", "\n", "\n", "# Derives average pooling value from pooling sum.", "\n", "x", "=", "x", "*", "q_mult_factor", "\n", "\n", "", "else", ":", "\n", "# If quantizer is not available, calls the keras layer.", "\n", "      ", "x", "=", "super", "(", "QGlobalAveragePooling2D", ",", "self", ")", ".", "call", "(", "inputs", ")", "\n", "\n", "", "if", "self", ".", "activation", "is", "not", "None", ":", "\n", "      ", "return", "self", ".", "activation", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qpooling.QGlobalAveragePooling2D.get_config": [[199, 207], ["super().get_config", "dict", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "list", "list", "super().get_config.items", "config.items"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "\"average_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "average_quantizer_internal", ")", ",", "\n", "\"activation\"", ":", "constraints", ".", "serialize", "(", "self", ".", "activation", ")", ",", "\n", "}", "\n", "base_config", "=", "super", "(", "QGlobalAveragePooling2D", ",", "self", ")", ".", "get_config", "(", ")", "\n", "return", "dict", "(", "list", "(", "base_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qpooling.QGlobalAveragePooling2D.get_quantization_config": [[208, 214], ["str", "str"], "methods", ["None"], ["", "def", "get_quantization_config", "(", "self", ")", ":", "\n", "    ", "return", "{", "\n", "\"average_quantizer\"", ":", "\n", "str", "(", "self", ".", "average_quantizer_internal", ")", ",", "\n", "\"activation\"", ":", "\n", "str", "(", "self", ".", "activation", ")", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qpooling.QGlobalAveragePooling2D.get_quantizers": [[216, 218], ["None"], "methods", ["None"], ["", "def", "get_quantizers", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "quantizers", "\n", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.b2t.BinaryToThermometer": [[22, 121], ["x.astype.astype", "numpy.floor", "tensorflow.keras.utils.to_categorical", "numpy.ceil", "xc_f.reshape.reshape", "tensorflow.keras.utils.to_categorical", "numpy.any", "numpy.any", "numpy.any", "len", "len", "x_mod_f.reshape", "x_mod_f.reshape", "x_mod_f.reshape"], "function", ["None"], ["def", "BinaryToThermometer", "(", "\n", "x", ",", "classes", ",", "value_range", ",", "with_residue", "=", "False", ",", "merge_with_channels", "=", "False", ",", "\n", "use_two_hot_encoding", "=", "False", ")", ":", "\n", "\n", "  ", "\"\"\"Converts binary to one-hot (with scales).\n\n  Given input matrix x with values (for example) 0, 1, 2, 3, 4, 5, 6, 7, create\n  a number of classes as follows:\n\n  classes=2, value_range=8, with_residue=0\n\n  A true one-hot representation, and the remaining bits are truncated, using\n  one bit representation.\n\n  0 - [1,0] 1 - [1,0] 2 - [1,0] 3 - [1,0]\n  4 - [0,1] 5 - [0,1] 6 - [0,1] 7 - [0,1]\n\n  classes=2, value_range=8, with_residue=1\n\n  In this case, the residue is added to the one-hot class, and the class will\n  use 2 bits (for the remainder) + 1 bit (for the one hot)\n\n  0 - [1,0] 1 - [1.25,0] 2 - [1.5,0] 3 - [1.75,0]\n  4 - [0,1] 5 - [0,1.25] 6 - [0,1.5] 7 - [0,1.75]\n\n  Arguments:\n    x: the input vector we want to convert. typically its dimension will be\n      (B,H,W,C) for an image, or (B,T,C) or (B,C) for for a 1D signal, where\n      B=batch, H=height, W=width, C=channels or features, T=time for time\n      series.\n    classes: the number of classes to (or log2(classes) bits) to use of the\n      values.\n    value_range: max(x) - min(x) over all possible x values (e.g. for 8 bits,\n      we would use 256 here).\n    with_residue: if true, we split the value range into two sets and add\n      the decimal fraction of the set to the one-hot representation for partial\n      thermometer representation.\n    merge_with_channels: if True, we will not create a separate dimension\n      for the resulting matrix, but we will merge this dimension with\n      the last dimension.\n    use_two_hot_encoding: if true, we will distribute the weight between\n      the current value and the next one to make sure the numbers will always\n      be < 1.\n\n  Returns:\n    Converted x with classes with the last shape being C*classes.\n\n  \"\"\"", "\n", "\n", "# just make sure we are processing floats so that we can compute fractional", "\n", "# values", "\n", "\n", "x", "=", "x", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "# the number of ranges are equal to the span of the original values", "\n", "# divided by the number of target classes.", "\n", "#", "\n", "# for example, if value_range is 256 and number of classes is 16, we have", "\n", "# 16 values (remaining 4 bits to redistribute).", "\n", "\n", "ranges", "=", "value_range", "/", "classes", "\n", "x_floor", "=", "np", ".", "floor", "(", "x", "/", "ranges", ")", "\n", "\n", "if", "use_two_hot_encoding", ":", "\n", "    ", "x_ceil", "=", "np", ".", "ceil", "(", "x", "/", "ranges", ")", "\n", "\n", "", "if", "with_residue", ":", "\n", "    ", "x_mod_f", "=", "(", "x", "-", "x_floor", "*", "ranges", ")", "/", "ranges", "\n", "\n", "# convert values to categorical. if use_two_hot_encoding, we may", "\n", "# end up with one more class because we need to distribute the", "\n", "# remaining bits to the saturation class. For example, if we have", "\n", "# value_range = 4 (0,1,2,3) and classes = 2, if we use_two_hot_encoding", "\n", "# we will have the classes 0, 1, 2, where for the number 3, we will", "\n", "# allocate 0.5 to bin 1 and 0.5 to bin 2 (namelly 3 = 0.5 * (2**2 + 2**1)).", "\n", "\n", "", "xc_f", "=", "to_categorical", "(", "x_floor", ",", "classes", "+", "use_two_hot_encoding", ")", "\n", "\n", "if", "with_residue", ":", "\n", "    ", "xc_f_m", "=", "xc_f", "==", "1", "\n", "\n", "if", "use_two_hot_encoding", ":", "\n", "      ", "xc_c", "=", "to_categorical", "(", "x_ceil", ",", "classes", "+", "use_two_hot_encoding", ")", "\n", "xc_c_m", "=", "xc_c", "==", "1", "\n", "if", "np", ".", "any", "(", "xc_c_m", ")", ":", "\n", "        ", "xc_c", "[", "xc_c_m", "]", "=", "x_mod_f", ".", "reshape", "(", "xc_c", "[", "xc_c_m", "]", ".", "shape", ")", "\n", "", "if", "np", ".", "any", "(", "xc_f_m", ")", ":", "\n", "        ", "xc_f", "[", "xc_f_m", "]", "=", "(", "1.0", "-", "x_mod_f", ".", "reshape", "(", "xc_f", "[", "xc_f_m", "]", ".", "shape", ")", ")", "\n", "", "xc_f", "+=", "xc_c", "\n", "", "else", ":", "\n", "      ", "if", "np", ".", "any", "(", "xc_f_m", ")", ":", "\n", "        ", "xc_f", "[", "xc_f_m", "]", "+=", "x_mod_f", ".", "reshape", "(", "xc_f", "[", "xc_f_m", "]", ".", "shape", ")", "\n", "\n", "", "", "", "if", "merge_with_channels", "and", "len", "(", "xc_f", ".", "shape", ")", "!=", "len", "(", "x", ".", "shape", ")", ":", "\n", "    ", "sz", "=", "xc_f", ".", "shape", "\n", "sz", "=", "sz", "[", ":", "-", "2", "]", "+", "(", "sz", "[", "-", "2", "]", "*", "sz", "[", "-", "1", "]", ",", ")", "\n", "xc_f", "=", "xc_f", ".", "reshape", "(", "sz", ")", "\n", "\n", "", "return", "xc_f", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.BaseQuantizer.__init__": [[388, 390], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "    ", "self", ".", "built", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.BaseQuantizer.build": [[391, 406], ["hasattr", "hasattr", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.constant", "tensorflow.constant", "quantizers._create_variable_name", "tensorflow.constant", "tensorflow.constant", "quantizers._create_variable_name"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._create_variable_name", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._create_variable_name"], ["", "def", "build", "(", "self", ",", "var_name", "=", "None", ",", "use_variables", "=", "False", ")", ":", "\n", "    ", "if", "use_variables", ":", "\n", "      ", "if", "hasattr", "(", "self", ",", "\"qnoise_factor\"", ")", ":", "\n", "        ", "self", ".", "qnoise_factor", "=", "tf", ".", "Variable", "(", "\n", "lambda", ":", "tf", ".", "constant", "(", "self", ".", "qnoise_factor", ",", "dtype", "=", "tf", ".", "float32", ")", ",", "\n", "name", "=", "_create_variable_name", "(", "\"qnoise_factor\"", ",", "var_name", "=", "var_name", ")", ",", "\n", "dtype", "=", "tf", ".", "float32", ",", "\n", "trainable", "=", "False", ")", "\n", "", "if", "hasattr", "(", "self", ",", "\"integer\"", ")", ":", "\n", "        ", "self", ".", "integer", "=", "tf", ".", "Variable", "(", "\n", "lambda", ":", "tf", ".", "constant", "(", "self", ".", "integer", ",", "dtype", "=", "tf", ".", "int32", ")", ",", "\n", "name", "=", "_create_variable_name", "(", "\"integer\"", ",", "var_name", "=", "var_name", ")", ",", "\n", "dtype", "=", "tf", ".", "int32", ",", "\n", "trainable", "=", "False", ")", "\n", "", "", "self", ".", "built", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.BaseQuantizer._set_trainable_parameter": [[407, 409], ["None"], "methods", ["None"], ["", "def", "_set_trainable_parameter", "(", "self", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.BaseQuantizer.update_qnoise_factor": [[410, 426], ["isinstance", "quantizers.BaseQuantizer.qnoise_factor.assign", "isinstance", "qnoise_factor.eval"], "methods", ["None"], ["", "def", "update_qnoise_factor", "(", "self", ",", "qnoise_factor", ")", ":", "\n", "    ", "\"\"\"Update qnoise_factor.\"\"\"", "\n", "if", "isinstance", "(", "self", ".", "qnoise_factor", ",", "tf", ".", "Variable", ")", ":", "\n", "# self.qnoise_factor is a tf.Variable.", "\n", "# This is to update self.qnoise_factor during training.", "\n", "      ", "self", ".", "qnoise_factor", ".", "assign", "(", "qnoise_factor", ")", "\n", "", "else", ":", "\n", "      ", "if", "isinstance", "(", "qnoise_factor", ",", "tf", ".", "Variable", ")", ":", "\n", "# self.qnoise_factor is a numpy variable, and qnoise_factor is a", "\n", "# tf.Variable.", "\n", "        ", "self", ".", "qnoise_factor", "=", "qnoise_factor", ".", "eval", "(", ")", "\n", "", "else", ":", "\n", "# self.qnoise_factor and qnoise_factor are numpy variables.", "\n", "# This is to set self.qnoise_factor before building", "\n", "# (creating tf.Variable) it.", "\n", "        ", "self", ".", "qnoise_factor", "=", "qnoise_factor", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.BaseQuantizer.variables": [[428, 431], ["None"], "methods", ["None"], ["", "", "", "@", "property", "\n", "def", "variables", "(", "self", ")", ":", "\n", "    ", "return", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.BaseQuantizer.trainable_variables": [[433, 436], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "trainable_variables", "(", "self", ")", ":", "\n", "    ", "return", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.BaseQuantizer.non_trainable_variables": [[438, 441], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "non_trainable_variables", "(", "self", ")", ":", "\n", "    ", "return", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_bits.__init__": [[504, 532], ["quantizers.BaseQuantizer.__init__", "isinstance"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "\n", "bits", "=", "8", ",", "\n", "integer", "=", "0", ",", "\n", "symmetric", "=", "0", ",", "\n", "keep_negative", "=", "True", ",", "\n", "alpha", "=", "None", ",", "\n", "use_stochastic_rounding", "=", "False", ",", "\n", "scale_axis", "=", "None", ",", "\n", "qnoise_factor", "=", "1.0", ",", "\n", "var_name", "=", "None", ",", "\n", "use_ste", "=", "True", ",", "\n", "use_variables", "=", "False", ")", ":", "\n", "    ", "super", "(", "quantized_bits", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "bits", "=", "bits", "\n", "self", ".", "integer", "=", "integer", "\n", "self", ".", "symmetric", "=", "symmetric", "\n", "self", ".", "keep_negative", "=", "keep_negative", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "use_stochastic_rounding", "=", "use_stochastic_rounding", "\n", "# \"auto*\" |-> symmetric", "\n", "if", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "      ", "self", ".", "symmetric", "=", "True", "\n", "", "self", ".", "scale", "=", "None", "\n", "self", ".", "scale_axis", "=", "scale_axis", "\n", "self", ".", "qnoise_factor", "=", "qnoise_factor", "\n", "self", ".", "use_ste", "=", "use_ste", "\n", "self", ".", "var_name", "=", "var_name", "\n", "self", ".", "use_variables", "=", "use_variables", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_bits.__str__": [[533, 553], ["re.sub", "str", "str", "str", "flags.append", "str", "isinstance", "flags.append", "flags.append", "int", "isinstance", "quantizers.quantized_bits.integer.numpy", "str", "int"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "# Convert Tensors to printable strings by converting to a numpy array and", "\n", "# then using regex to remove brackets when there is only one integer bit", "\n", "    ", "integer_bits", "=", "re", ".", "sub", "(", "\n", "r\"\\[(\\d)\\]\"", ",", "r\"\\g<1>\"", ",", "\n", "str", "(", "self", ".", "integer", ".", "numpy", "(", ")", "if", "isinstance", "(", "self", ".", "integer", ",", "tf", ".", "Variable", "\n", ")", "else", "self", ".", "integer", ")", ")", "\n", "\n", "flags", "=", "[", "str", "(", "self", ".", "bits", ")", ",", "integer_bits", ",", "str", "(", "int", "(", "self", ".", "symmetric", ")", ")", "]", "\n", "if", "not", "self", ".", "keep_negative", ":", "\n", "      ", "flags", ".", "append", "(", "\"keep_negative=False\"", ")", "\n", "", "if", "self", ".", "alpha", ":", "\n", "      ", "alpha", "=", "str", "(", "self", ".", "alpha", ")", "\n", "if", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "        ", "alpha", "=", "\"'\"", "+", "alpha", "+", "\"'\"", "\n", "", "flags", ".", "append", "(", "\"alpha=\"", "+", "alpha", ")", "\n", "", "if", "self", ".", "use_stochastic_rounding", ":", "\n", "      ", "flags", ".", "append", "(", "\"use_stochastic_rounding=\"", "+", "\n", "str", "(", "int", "(", "self", ".", "use_stochastic_rounding", ")", ")", ")", "\n", "", "return", "\"quantized_bits(\"", "+", "\",\"", ".", "join", "(", "flags", ")", "+", "\")\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_bits.__call__": [[554, 651], ["tensorflow.cast_to_floatx", "tensorflow.cast_to_floatx", "tensorflow.cast_to_floatx", "tensorflow.cast_to_floatx", "tensorflow.cast_to_floatx", "tensorflow.cast_to_floatx", "quantizers.quantized_bits.build", "pow", "tensorflow.pow", "tensorflow.pow", "isinstance", "tensorflow.sign", "tensorflow.sign", "len", "tensorflow.abs", "tensorflow.abs", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "quantizers._get_scaling_axis", "tensorflow.pow", "tensorflow.pow", "six.moves.range", "tensorflow.keras.backend.clip", "tensorflow.keras.backend.clip", "tensorflow.max", "tensorflow.max", "tensorflow.math.round", "tensorflow.math.round", "tensorflow.floor", "tensorflow.floor", "quantizers._get_scale", "tensorflow.floor", "tensorflow.floor", "ValueError", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "quantizers._round_through", "abs", "tensorflow.sign", "tensorflow.sign", "tensorflow.where", "tensorflow.where", "tensorflow.sign", "tensorflow.sign", "tensorflow.where", "tensorflow.where", "tensorflow.log", "tensorflow.log", "numpy.log", "tensorflow.abs", "tensorflow.abs", "tensorflow.abs", "tensorflow.abs", "tensorflow.epsilon", "tensorflow.epsilon", "tensorflow.ones_like", "tensorflow.ones_like", "tensorflow.ones_like", "tensorflow.ones_like"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.networks.conv_block.ConvBlockNetwork.build", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_scaling_axis", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_scale", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._round_through"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "    ", "\"\"\"Computes fixedpoint quantization of x.\"\"\"", "\n", "if", "not", "self", ".", "built", ":", "\n", "      ", "self", ".", "build", "(", "var_name", "=", "self", ".", "var_name", ",", "use_variables", "=", "self", ".", "use_variables", ")", "\n", "\n", "", "x", "=", "K", ".", "cast_to_floatx", "(", "x", ")", "\n", "\n", "# quantized_bits with \"1\" bit becomes a binary implementation.", "\n", "unsigned_bits", "=", "self", ".", "bits", "-", "self", ".", "keep_negative", "\n", "m", "=", "K", ".", "cast_to_floatx", "(", "pow", "(", "2", ",", "unsigned_bits", ")", ")", "\n", "m_i", "=", "K", ".", "cast_to_floatx", "(", "K", ".", "pow", "(", "2", ",", "self", ".", "integer", ")", ")", "\n", "\n", "if", "self", ".", "alpha", "is", "None", ":", "\n", "      ", "scale", "=", "1.0", "\n", "", "elif", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "# We only deal with the symmetric case right now.", "\n", "      ", "assert", "self", ".", "symmetric", ",", "\"Only symmetric quantizers are implemented\"", "\n", "len_axis", "=", "len", "(", "x", ".", "shape", ")", "\n", "if", "len_axis", ">", "1", ":", "\n", "        ", "axis", "=", "_get_scaling_axis", "(", "self", ".", "scale_axis", ",", "len_axis", ")", "\n", "", "else", ":", "\n", "        ", "axis", "=", "[", "0", "]", "\n", "\n", "", "x", "=", "x", "/", "m_i", "\n", "\n", "# Using 2's complement, we can represent 2**(bits-1)-1 positive values", "\n", "# If we wish to maintain symmetry, we can double 2**(bits-1)-1 to get", "\n", "# the total number of possible values we can represent.", "\n", "# If symmetry is not enforced, then we can represent (2**bits)-1 values", "\n", "# using 2's complement.", "\n", "levels", "=", "(", "2", "**", "(", "self", ".", "bits", "-", "1", ")", "-", "1", ")", "*", "2", "if", "self", ".", "symmetric", "else", "(", "2", "**", "self", ".", "bits", ")", "-", "1", "\n", "\n", "scale", "=", "(", "K", ".", "max", "(", "abs", "(", "x", ")", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", "*", "2", ")", "/", "levels", "\n", "\n", "# If alpha is \"auto_po2\", then get the \"best\" po2 scale", "\n", "if", "\"po2\"", "in", "self", ".", "alpha", ":", "\n", "        ", "scale", "=", "K", ".", "pow", "(", "2.0", ",", "\n", "tf", ".", "math", ".", "round", "(", "K", ".", "log", "(", "scale", "+", "K", ".", "epsilon", "(", ")", ")", "/", "np", ".", "log", "(", "2.0", ")", ")", ")", "\n", "for", "_", "in", "range", "(", "5", ")", ":", "\n", "          ", "v", "=", "tf", ".", "floor", "(", "tf", ".", "abs", "(", "x", ")", "/", "scale", "+", "0.5", ")", "\n", "mask", "=", "v", "<", "levels", "/", "2", "\n", "z", "=", "tf", ".", "sign", "(", "x", ")", "*", "tf", ".", "where", "(", "mask", ",", "v", ",", "tf", ".", "ones_like", "(", "v", ")", "*", "levels", "/", "2", ")", "\n", "scale", "=", "_get_scale", "(", "alpha", "=", "\"auto_po2\"", ",", "x", "=", "x", ",", "q", "=", "z", ",", "\n", "scale_axis", "=", "self", ".", "scale_axis", ")", "\n", "\n", "# If alpha is \"auto\", then get the \"best\" floating point scale", "\n", "", "", "elif", "self", ".", "alpha", "==", "\"auto\"", ":", "\n", "        ", "v", "=", "tf", ".", "floor", "(", "tf", ".", "abs", "(", "x", ")", "/", "scale", "+", "0.5", ")", "\n", "mask", "=", "v", "<", "levels", "/", "2", "\n", "z", "=", "tf", ".", "sign", "(", "x", ")", "*", "tf", ".", "where", "(", "mask", ",", "v", ",", "tf", ".", "ones_like", "(", "v", ")", "*", "levels", "/", "2", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"Invalid alpha '{self.alpha}'\"", ")", "\n", "\n", "# z is an integer number, so we must make the scale * m and z / m", "\n", "", "scale", "=", "scale", "*", "m", "\n", "\n", "# we will not use \"z\" right now because of stochastic_rounding", "\n", "# this is still under test.", "\n", "\n", "# if \"new\" in self.alpha:", "\n", "#  z = z / m", "\n", "#  self.scale = scale", "\n", "#  return x + tf.stop_gradient(-x + scale * z)", "\n", "x", "=", "m_i", "*", "x", "\n", "xq", "=", "m_i", "*", "z", "/", "m", "\n", "self", ".", "scale", "=", "scale", "\n", "xq", "=", "scale", "*", "xq", "\n", "\n", "if", "self", ".", "use_ste", ":", "\n", "        ", "return", "x", "+", "tf", ".", "stop_gradient", "(", "self", ".", "qnoise_factor", "*", "(", "-", "x", "+", "xq", ")", ")", "\n", "", "else", ":", "\n", "        ", "return", "(", "1", "-", "self", ".", "qnoise_factor", ")", "*", "x", "+", "tf", ".", "stop_gradient", "(", "\n", "self", ".", "qnoise_factor", "*", "xq", ")", "\n", "\n", "", "", "else", ":", "\n", "      ", "scale", "=", "self", ".", "alpha", "\n", "\n", "# quantized_bits with \"1\" bit becomes a binary implementation.", "\n", "", "if", "unsigned_bits", ">", "0", ":", "\n", "      ", "p", "=", "x", "*", "m", "/", "m_i", "\n", "xq", "=", "m_i", "*", "tf", ".", "keras", ".", "backend", ".", "clip", "(", "\n", "_round_through", "(", "p", ",", "self", ".", "use_stochastic_rounding", ",", "precision", "=", "1.0", ")", ",", "\n", "self", ".", "keep_negative", "*", "(", "-", "m", "+", "self", ".", "symmetric", ")", ",", "m", "-", "1", ")", "/", "m", "\n", "", "else", ":", "\n", "      ", "xq", "=", "tf", ".", "sign", "(", "x", ")", "\n", "xq", "+=", "(", "1.0", "-", "tf", ".", "abs", "(", "xq", ")", ")", "\n", "if", "not", "self", ".", "keep_negative", ":", "\n", "        ", "xq", "=", "(", "xq", "+", "1.0", ")", "/", "2.0", "\n", "\n", "", "", "self", ".", "scale", "=", "scale", "\n", "xq", "=", "scale", "*", "xq", "\n", "\n", "if", "self", ".", "use_ste", ":", "\n", "      ", "return", "x", "+", "tf", ".", "stop_gradient", "(", "self", ".", "qnoise_factor", "*", "(", "-", "x", "+", "xq", ")", ")", "\n", "", "else", ":", "\n", "      ", "return", "(", "1", "-", "self", ".", "qnoise_factor", ")", "*", "x", "+", "tf", ".", "stop_gradient", "(", "\n", "self", ".", "qnoise_factor", "*", "xq", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_bits._set_trainable_parameter": [[652, 656], ["None"], "methods", ["None"], ["", "", "def", "_set_trainable_parameter", "(", "self", ")", ":", "\n", "    ", "if", "self", ".", "alpha", "is", "None", ":", "\n", "      ", "self", ".", "alpha", "=", "\"auto_po2\"", "\n", "self", ".", "symmetric", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_bits.max": [[657, 668], ["quantizers.quantized_bits.max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "", "def", "max", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get maximum value that quantized_bits class can represent.\"\"\"", "\n", "unsigned_bits", "=", "self", ".", "bits", "-", "self", ".", "keep_negative", "\n", "if", "unsigned_bits", ">", "0", ":", "\n", "      ", "return", "max", "(", "\n", "1.0", ",", "\n", "np", ".", "array", "(", "\n", "K", ".", "pow", "(", "2.", ",", "K", ".", "cast", "(", "self", ".", "integer", ",", "dtype", "=", "\"float32\"", ")", ")", ",", "\n", "dtype", "=", "\"float32\"", ")", ")", "\n", "", "else", ":", "\n", "      ", "return", "1.0", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_bits.min": [[669, 681], ["quantizers.quantized_bits.max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "", "def", "min", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get minimum value that quantized_bits class can represent.\"\"\"", "\n", "if", "not", "self", ".", "keep_negative", ":", "\n", "      ", "return", "0.0", "\n", "", "unsigned_bits", "=", "self", ".", "bits", "-", "self", ".", "keep_negative", "\n", "if", "unsigned_bits", ">", "0", ":", "\n", "      ", "return", "-", "max", "(", "\n", "1.0", ",", "\n", "np", ".", "array", "(", "\n", "K", ".", "pow", "(", "2", ",", "K", ".", "cast", "(", "self", ".", "integer", ",", "dtype", "=", "\"float32\"", ")", ")", ",", "dtype", "=", "\"float32\"", ")", ")", "\n", "", "else", ":", "\n", "      ", "return", "-", "1.0", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_bits.range": [[682, 695], ["numpy.asarray", "numpy.where", "six.moves.range", "numpy.array", "tensorflow.pow", "tensorflow.pow", "tensorflow.cast", "tensorflow.cast"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "", "def", "range", "(", "self", ")", ":", "\n", "    ", "\"\"\"Returns a list of all values that quantized_bits can represent\n    ordered by their binary representation ascending.\"\"\"", "\n", "assert", "self", ".", "symmetric", "==", "0", "\n", "assert", "self", ".", "keep_negative", "\n", "assert", "self", ".", "alpha", "is", "None", "or", "self", ".", "alpha", "==", "1.0", "\n", "\n", "x", "=", "np", ".", "asarray", "(", "range", "(", "2", "**", "self", ".", "bits", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "p_and_n", "=", "np", ".", "where", "(", "x", ">=", "2", "**", "(", "self", ".", "bits", "-", "1", ")", ",", "\n", "(", "x", "-", "2", "**", "(", "self", ".", "bits", "-", "1", ")", ")", "-", "2", "**", "(", "self", ".", "bits", "-", "1", ")", ",", "x", ")", "\n", "return", "p_and_n", "*", "np", ".", "array", "(", "\n", "K", ".", "pow", "(", "2.0", ",", "-", "self", ".", "bits", "+", "K", ".", "cast", "(", "self", ".", "integer", ",", "dtype", "=", "\"float32\"", ")", "+", "1", ")", ",", "\n", "dtype", "=", "\"float32\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_bits.from_config": [[696, 699], ["cls"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "config", ")", ":", "\n", "    ", "return", "cls", "(", "**", "config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_bits.get_config": [[700, 720], ["isinstance", "quantizers.quantized_bits.integer.numpy", "isinstance", "quantizers.quantized_bits.qnoise_factor.numpy"], "methods", ["None"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "\"bits\"", ":", "\n", "self", ".", "bits", ",", "\n", "\"integer\"", ":", "\n", "self", ".", "integer", ".", "numpy", "(", ")", "\n", "if", "isinstance", "(", "self", ".", "integer", ",", "tf", ".", "Variable", ")", "else", "self", ".", "integer", ",", "\n", "\"symmetric\"", ":", "\n", "self", ".", "symmetric", ",", "\n", "\"alpha\"", ":", "\n", "self", ".", "alpha", ",", "\n", "\"keep_negative\"", ":", "\n", "self", ".", "keep_negative", ",", "\n", "\"use_stochastic_rounding\"", ":", "\n", "self", ".", "use_stochastic_rounding", ",", "\n", "\"qnoise_factor\"", ":", "\n", "self", ".", "qnoise_factor", ".", "numpy", "(", ")", "if", "isinstance", "(", "\n", "self", ".", "qnoise_factor", ",", "tf", ".", "Variable", ")", "else", "self", ".", "qnoise_factor", "\n", "}", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.bernoulli.__init__": [[752, 760], ["quantizers.BaseQuantizer.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "alpha", "=", "None", ",", "temperature", "=", "6.0", ",", "use_real_sigmoid", "=", "True", ")", ":", "\n", "    ", "super", "(", "bernoulli", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "bits", "=", "1", "\n", "self", ".", "temperature", "=", "temperature", "\n", "self", ".", "use_real_sigmoid", "=", "use_real_sigmoid", "\n", "self", ".", "default_alpha", "=", "1.0", "\n", "self", ".", "scale", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.bernoulli.__str__": [[761, 773], ["str", "isinstance", "flags.append", "flags.append", "flags.append", "str", "str", "int"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "    ", "flags", "=", "[", "]", "\n", "if", "self", ".", "alpha", "is", "not", "None", ":", "\n", "      ", "alpha", "=", "str", "(", "self", ".", "alpha", ")", "\n", "if", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "        ", "alpha", "=", "\"'\"", "+", "alpha", "+", "\"'\"", "\n", "", "flags", ".", "append", "(", "\"alpha=\"", "+", "alpha", ")", "\n", "", "if", "self", ".", "temperature", "!=", "6.0", ":", "\n", "      ", "flags", ".", "append", "(", "\"temperature=\"", "+", "str", "(", "self", ".", "temperature", ")", ")", "\n", "", "if", "not", "self", ".", "use_real_sigmoid", ":", "\n", "      ", "flags", ".", "append", "(", "\"use_real_sigmoid=\"", "+", "str", "(", "int", "(", "self", ".", "use_real_sigmoid", ")", ")", ")", "\n", "", "return", "\"bernoulli(\"", "+", "\",\"", ".", "join", "(", "flags", ")", "+", "\")\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.bernoulli.__call__": [[774, 811], ["isinstance", "isinstance", "tensorflow.random.uniform", "tensorflow.random.uniform", "tensorflow.sign", "tensorflow.sign", "tensorflow.sign", "tensorflow.sign", "quantizers._get_scale", "len", "tensorflow.keras.backend.sigmoid", "tensorflow.keras.backend.sigmoid", "_sigmoid", "tensorflow.shape", "tensorflow.shape", "tensorflow.abs", "tensorflow.abs", "tensorflow.abs", "tensorflow.abs", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "tensorflow.std", "tensorflow.std", "tensorflow.epsilon", "tensorflow.epsilon", "tensorflow.image_data_format", "tensorflow.image_data_format", "list", "list", "six.moves.range", "six.moves.range"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_scale", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "    ", "if", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "      ", "assert", "self", ".", "alpha", "in", "[", "\"auto\"", ",", "\"auto_po2\"", "]", "\n", "\n", "", "if", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "      ", "len_axis", "=", "len", "(", "x", ".", "shape", ")", "\n", "\n", "if", "len_axis", ">", "1", ":", "\n", "        ", "if", "K", ".", "image_data_format", "(", ")", "==", "\"channels_last\"", ":", "\n", "          ", "axis", "=", "list", "(", "range", "(", "len_axis", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "          ", "axis", "=", "list", "(", "range", "(", "1", ",", "len_axis", ")", ")", "\n", "", "", "else", ":", "\n", "        ", "axis", "=", "[", "0", "]", "\n", "\n", "", "std", "=", "K", ".", "std", "(", "x", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", "+", "K", ".", "epsilon", "(", ")", "\n", "", "else", ":", "\n", "      ", "std", "=", "1.0", "\n", "\n", "", "if", "self", ".", "use_real_sigmoid", ":", "\n", "      ", "p", "=", "tf", ".", "keras", ".", "backend", ".", "sigmoid", "(", "self", ".", "temperature", "*", "x", "/", "std", ")", "\n", "", "else", ":", "\n", "      ", "p", "=", "_sigmoid", "(", "self", ".", "temperature", "*", "x", "/", "std", ")", "\n", "", "r", "=", "tf", ".", "random", ".", "uniform", "(", "tf", ".", "shape", "(", "x", ")", ")", "\n", "q", "=", "tf", ".", "sign", "(", "p", "-", "r", ")", "\n", "q", "+=", "(", "1.0", "-", "tf", ".", "abs", "(", "q", ")", ")", "\n", "q", "=", "(", "q", "+", "1.0", ")", "/", "2.0", "\n", "\n", "q_non_stochastic", "=", "tf", ".", "sign", "(", "x", ")", "\n", "q_non_stochastic", "+=", "(", "1.0", "-", "tf", ".", "abs", "(", "q_non_stochastic", ")", ")", "\n", "q_non_stochastic", "=", "(", "q_non_stochastic", "+", "1.0", ")", "/", "2.0", "\n", "\n", "# if we use non stochastic binary to compute alpha,", "\n", "# this function seems to behave better", "\n", "scale", "=", "_get_scale", "(", "self", ".", "alpha", ",", "x", ",", "q_non_stochastic", ")", "\n", "self", ".", "scale", "=", "scale", "\n", "return", "x", "+", "tf", ".", "stop_gradient", "(", "-", "x", "+", "scale", "*", "q", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.bernoulli._set_trainable_parameter": [[812, 815], ["None"], "methods", ["None"], ["", "def", "_set_trainable_parameter", "(", "self", ")", ":", "\n", "    ", "if", "self", ".", "alpha", "is", "None", ":", "\n", "      ", "self", ".", "alpha", "=", "\"auto_po2\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.bernoulli.max": [[816, 822], ["isinstance", "quantizers.bernoulli.max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "", "def", "max", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get the maximum value bernoulli class can represent.\"\"\"", "\n", "if", "self", ".", "alpha", "is", "None", "or", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "      ", "return", "1.0", "\n", "", "else", ":", "\n", "      ", "return", "max", "(", "1.0", ",", "self", ".", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.bernoulli.min": [[823, 826], ["None"], "methods", ["None"], ["", "", "def", "min", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get the minimum value bernoulli class can represent.\"\"\"", "\n", "return", "0.0", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.bernoulli.from_config": [[827, 830], ["cls"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "config", ")", ":", "\n", "    ", "return", "cls", "(", "**", "config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.bernoulli.get_config": [[831, 834], ["None"], "methods", ["None"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\"alpha\"", ":", "self", ".", "alpha", "}", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.ternary.__init__": [[856, 867], ["quantizers.BaseQuantizer.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "alpha", "=", "None", ",", "threshold", "=", "None", ",", "use_stochastic_rounding", "=", "False", ",", "\n", "number_of_unrolls", "=", "5", ")", ":", "\n", "    ", "super", "(", "ternary", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "bits", "=", "2", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "threshold", "=", "threshold", "\n", "self", ".", "use_stochastic_rounding", "=", "use_stochastic_rounding", "\n", "self", ".", "default_alpha", "=", "1.0", "\n", "self", ".", "default_threshold", "=", "0.33", "\n", "self", ".", "number_of_unrolls", "=", "number_of_unrolls", "\n", "self", ".", "scale", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.ternary.__str__": [[868, 884], ["str", "isinstance", "flags.append", "flags.append", "flags.append", "flags.append", "str", "str", "str", "int", "int"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "    ", "flags", "=", "[", "]", "\n", "if", "self", ".", "alpha", "is", "not", "None", ":", "\n", "      ", "alpha", "=", "str", "(", "self", ".", "alpha", ")", "\n", "if", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "        ", "alpha", "=", "\"'\"", "+", "alpha", "+", "\"'\"", "\n", "", "flags", ".", "append", "(", "\"alpha=\"", "+", "alpha", ")", "\n", "", "if", "self", ".", "threshold", "is", "not", "None", ":", "\n", "      ", "flags", ".", "append", "(", "\"threshold=\"", "+", "str", "(", "self", ".", "threshold", ")", ")", "\n", "", "if", "self", ".", "use_stochastic_rounding", ":", "\n", "      ", "flags", ".", "append", "(", "\n", "\"use_stochastic_rounding=\"", "+", "str", "(", "int", "(", "self", ".", "use_stochastic_rounding", ")", ")", ")", "\n", "", "if", "self", ".", "number_of_unrolls", "!=", "5", ":", "\n", "      ", "flags", ".", "append", "(", "\n", "\"number_of_unrolls=\"", "+", "str", "(", "int", "(", "self", ".", "number_of_unrolls", ")", ")", ")", "\n", "", "return", "\"ternary(\"", "+", "\",\"", ".", "join", "(", "flags", ")", "+", "\")\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.ternary.__call__": [[885, 952], ["isinstance", "isinstance", "isinstance", "isinstance", "tensorflow.max", "tensorflow.max", "six.moves.range", "tensorflow.tanh", "tensorflow.tanh", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "isinstance", "float", "len", "tensorflow.abs", "tensorflow.abs", "tensorflow.pow", "tensorflow.pow", "quantizers._get_scale", "tensorflow.cast", "tensorflow.cast", "tensorflow.sign", "tensorflow.sign", "tensorflow.tanh.shape.as_list", "len", "tensorflow.image_data_format", "tensorflow.image_data_format", "list", "list", "tensorflow.math.round", "tensorflow.math.round", "quantizers._round_through", "tensorflow.cast", "tensorflow.cast", "tensorflow.sign", "tensorflow.sign", "tensorflow.floatx", "tensorflow.floatx", "list", "six.moves.range", "six.moves.range", "tensorflow.floatx", "tensorflow.floatx", "tensorflow.abs", "tensorflow.abs", "tensorflow.log", "tensorflow.log", "numpy.log", "tensorflow.abs", "tensorflow.abs", "tensorflow.epsilon", "tensorflow.epsilon"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_scale", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._round_through", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "    ", "if", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "# parameters", "\n", "      ", "assert", "self", ".", "alpha", "in", "[", "\"auto\"", ",", "\"auto_po2\"", "]", "\n", "assert", "self", ".", "threshold", "is", "None", "\n", "", "else", ":", "\n", "# activations", "\n", "      ", "assert", "not", "self", ".", "use_stochastic_rounding", "\n", "assert", "not", "isinstance", "(", "self", ".", "threshold", ",", "six", ".", "string_types", ")", "\n", "\n", "", "if", "self", ".", "alpha", "is", "None", "or", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "      ", "scale", "=", "1.0", "\n", "", "elif", "isinstance", "(", "self", ".", "alpha", ",", "np", ".", "ndarray", ")", ":", "\n", "      ", "scale", "=", "self", ".", "alpha", "\n", "", "else", ":", "\n", "      ", "scale", "=", "float", "(", "self", ".", "alpha", ")", "\n", "\n", "# This is an approximiation from https://arxiv.org/abs/1605.04711", "\n", "# We consider channels_last only for now.", "\n", "", "if", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "# It is for parameters", "\n", "# first, compute which asix corresponds to the channels.", "\n", "# TODO(hzhuang): support channels_first", "\n", "      ", "try", ":", "\n", "        ", "len_axis", "=", "len", "(", "x", ".", "shape", ".", "as_list", "(", ")", ")", "\n", "", "except", "AttributeError", ":", "\n", "        ", "len_axis", "=", "len", "(", "list", "(", "x", ".", "shape", ")", ")", "\n", "\n", "", "if", "len_axis", "==", "1", ":", "\n", "        ", "axis", "=", "None", "\n", "", "elif", "K", ".", "image_data_format", "(", ")", "==", "\"channels_last\"", ":", "\n", "        ", "axis", "=", "list", "(", "range", "(", "len_axis", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "        ", "axis", "=", "list", "(", "range", "(", "1", ",", "len_axis", ")", ")", "\n", "\n", "# This approximation is exact if x ~ U[-m, m]. For x ~ N(0, m)", "\n", "# we need to iterate a few times before we can coverge", "\n", "", "m", "=", "K", ".", "max", "(", "tf", ".", "abs", "(", "x", ")", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", "\n", "scale", "=", "2", "*", "m", "/", "3.0", "\n", "if", "\"po2\"", "in", "self", ".", "alpha", ":", "\n", "        ", "scale", "=", "K", ".", "pow", "(", "2.0", ",", "\n", "tf", ".", "math", ".", "round", "(", "K", ".", "log", "(", "scale", "+", "K", ".", "epsilon", "(", ")", ")", "/", "np", ".", "log", "(", "2.0", ")", ")", ")", "\n", "\n", "", "for", "_", "in", "range", "(", "self", ".", "number_of_unrolls", ")", ":", "\n", "        ", "thres", "=", "scale", "/", "2.0", "\n", "# once we scale the number precision == 0.33 works", "\n", "# well for Uniform and Normal distribution of input", "\n", "v", "=", "scale", "*", "_round_through", "(", "\n", "x", "/", "scale", ",", "\n", "use_stochastic_rounding", "=", "self", ".", "use_stochastic_rounding", ",", "\n", "precision", "=", "1.", "/", "3.", ")", "\n", "q", "=", "K", ".", "cast", "(", "tf", ".", "abs", "(", "v", ")", ">=", "thres", ",", "K", ".", "floatx", "(", ")", ")", "*", "tf", ".", "sign", "(", "x", ")", "\n", "scale", "=", "_get_scale", "(", "self", ".", "alpha", ",", "x", ",", "q", ")", "\n", "", "", "else", ":", "\n", "      ", "if", "self", ".", "threshold", "is", "None", ":", "\n", "        ", "thres", "=", "self", ".", "default_threshold", "\n", "", "else", ":", "\n", "        ", "thres", "=", "self", ".", "threshold", "\n", "", "q", "=", "K", ".", "cast", "(", "tf", ".", "abs", "(", "x", ")", ">=", "thres", ",", "K", ".", "floatx", "(", ")", ")", "*", "tf", ".", "sign", "(", "x", ")", "\n", "\n", "# ternary ranges from -1 to +1, so we use tanh(x) to be a differentiable", "\n", "# version of that.", "\n", "", "if", "self", ".", "alpha", "is", "None", ":", "\n", "      ", "x", "=", "K", ".", "tanh", "(", "x", ")", "\n", "\n", "", "self", ".", "scale", "=", "scale", "\n", "return", "x", "+", "tf", ".", "stop_gradient", "(", "-", "x", "+", "scale", "*", "q", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.ternary._set_trainable_parameter": [[953, 956], ["None"], "methods", ["None"], ["", "def", "_set_trainable_parameter", "(", "self", ")", ":", "\n", "    ", "if", "self", ".", "alpha", "is", "None", ":", "\n", "      ", "self", ".", "alpha", "=", "\"auto_po2\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.ternary.max": [[957, 963], ["isinstance", "quantizers.ternary.max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "", "def", "max", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get the maximum value that ternary can respresent.\"\"\"", "\n", "if", "self", ".", "alpha", "is", "None", "or", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "      ", "return", "1.0", "\n", "", "else", ":", "\n", "      ", "return", "max", "(", "1.0", ",", "self", ".", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.ternary.min": [[964, 970], ["isinstance", "quantizers.ternary.max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "", "def", "min", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get the minimum value that ternary can respresent.\"\"\"", "\n", "if", "self", ".", "alpha", "is", "None", "or", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "      ", "return", "-", "1.0", "\n", "", "else", ":", "\n", "      ", "return", "-", "max", "(", "1.0", ",", "self", ".", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.ternary.from_config": [[971, 974], ["cls"], "methods", ["None"], ["", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "config", ")", ":", "\n", "    ", "return", "cls", "(", "**", "config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.ternary.get_config": [[975, 983], ["None"], "methods", ["None"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "\"alpha\"", ":", "self", ".", "alpha", ",", "\n", "\"threshold\"", ":", "self", ".", "threshold", ",", "\n", "\"use_stochastic_rounding\"", ":", "self", ".", "use_stochastic_rounding", ",", "\n", "\"number_of_unrolls\"", ":", "self", ".", "number_of_unrolls", "\n", "}", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_ternary.__init__": [[1005, 1022], ["quantizers.ternary.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "alpha", "=", "None", ",", "threshold", "=", "None", ",", "temperature", "=", "8.0", ",", "\n", "use_real_sigmoid", "=", "True", ",", "number_of_unrolls", "=", "5", ")", ":", "\n", "    ", "super", "(", "stochastic_ternary", ",", "self", ")", ".", "__init__", "(", "\n", "alpha", "=", "alpha", ",", "\n", "threshold", "=", "threshold", ",", "\n", "number_of_unrolls", "=", "number_of_unrolls", ")", "\n", "\n", "self", ".", "bits", "=", "2", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "threshold", "=", "threshold", "\n", "assert", "threshold", "!=", "1.0", "\n", "self", ".", "default_alpha", "=", "1.0", "\n", "self", ".", "default_threshold", "=", "0.33", "\n", "self", ".", "temperature", "=", "temperature", "\n", "self", ".", "use_real_sigmoid", "=", "use_real_sigmoid", "\n", "self", ".", "number_of_unrolls", "=", "number_of_unrolls", "\n", "self", ".", "scale", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_ternary.__str__": [[1023, 1039], ["str", "isinstance", "flags.append", "flags.append", "flags.append", "flags.append", "flags.append", "str", "str", "str"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "    ", "flags", "=", "[", "]", "\n", "if", "self", ".", "alpha", "is", "not", "None", ":", "\n", "      ", "alpha", "=", "str", "(", "self", ".", "alpha", ")", "\n", "if", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "        ", "alpha", "=", "\"'\"", "+", "alpha", "+", "\"'\"", "\n", "", "flags", ".", "append", "(", "\"alpha=\"", "+", "alpha", ")", "\n", "", "if", "self", ".", "threshold", "is", "not", "None", ":", "\n", "      ", "flags", ".", "append", "(", "\"threshold=\"", "+", "str", "(", "self", ".", "threshold", ")", ")", "\n", "", "if", "self", ".", "temperature", "!=", "8.0", ":", "\n", "      ", "flags", ".", "append", "(", "\"temperature=\"", "+", "str", "(", "self", ".", "temperature", ")", ")", "\n", "", "if", "not", "self", ".", "use_real_sigmoid", ":", "\n", "      ", "flags", ".", "append", "(", "\"use_real_sigmoid=0\"", ")", "\n", "", "if", "self", ".", "number_of_unrolls", "!=", "5", ":", "\n", "      ", "flags", ".", "append", "(", "\"number_of_unrolls=\"", "+", "str", "(", "self", ".", "number_of_unrolls", ")", ")", "\n", "", "return", "\"stochastic_ternary(\"", "+", "\",\"", ".", "join", "(", "flags", ")", "+", "\")\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_ternary.__call__": [[1040, 1102], ["tensorflow.python.framework.smart_cond.smart_cond", "tensorflow.python.framework.smart_cond.smart_cond", "isinstance", "len", "tensorflow.std", "tensorflow.std", "tensorflow.max", "tensorflow.max", "six.moves.range", "tensorflow.random.uniform", "tensorflow.random.uniform", "tensorflow.random.uniform", "tensorflow.random.uniform", "tensorflow.sign", "tensorflow.sign", "tensorflow.sign", "tensorflow.sign", "tensorflow.learning_phase", "tensorflow.learning_phase", "isinstance", "tensorflow.abs", "tensorflow.abs", "tensorflow.pow", "tensorflow.pow", "quantizers._get_scale", "tensorflow.keras.backend.sigmoid", "tensorflow.keras.backend.sigmoid", "tensorflow.keras.backend.sigmoid", "tensorflow.keras.backend.sigmoid", "_sigmoid", "_sigmoid", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape", "tensorflow.abs", "tensorflow.abs", "tensorflow.abs", "tensorflow.abs", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "quantizers.ternary.__call__", "float", "tensorflow.image_data_format", "tensorflow.image_data_format", "list", "list", "tensorflow.math.round", "tensorflow.math.round", "tensorflow.cast", "tensorflow.cast", "tensorflow.sign", "tensorflow.sign", "tensorflow.epsilon", "tensorflow.epsilon", "six.moves.range", "six.moves.range", "tensorflow.floatx", "tensorflow.floatx", "tensorflow.epsilon", "tensorflow.epsilon", "tensorflow.log", "tensorflow.log", "numpy.log", "tensorflow.abs", "tensorflow.abs", "tensorflow.epsilon", "tensorflow.epsilon"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_scale", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.Clip.__call__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "    ", "def", "stochastic_output", "(", ")", ":", "\n", "# right now we only accept alpha = \"auto\" or \"auto_po2\"", "\n", "\n", "      ", "assert", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", "\n", "assert", "self", ".", "alpha", "in", "[", "\"auto\"", ",", "\"auto_po2\"", "]", "\n", "\n", "if", "self", ".", "alpha", "is", "None", ":", "\n", "        ", "scale", "=", "self", ".", "default_alpha", "\n", "", "elif", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "        ", "scale", "=", "1.0", "\n", "assert", "self", ".", "alpha", "in", "[", "\"auto\"", ",", "\"auto_po2\"", "]", "\n", "", "else", ":", "\n", "        ", "assert", "self", ".", "alpha", ">=", "0.0", "\n", "scale", "=", "float", "(", "self", ".", "alpha", ")", "\n", "\n", "", "len_axis", "=", "len", "(", "x", ".", "shape", ")", "\n", "if", "len_axis", ">", "1", ":", "\n", "        ", "if", "K", ".", "image_data_format", "(", ")", "==", "\"channels_last\"", ":", "\n", "          ", "axis", "=", "list", "(", "range", "(", "len_axis", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "          ", "axis", "=", "list", "(", "range", "(", "1", ",", "len_axis", ")", ")", "\n", "", "", "else", ":", "\n", "        ", "axis", "=", "[", "0", "]", "\n", "\n", "", "x_std", "=", "K", ".", "std", "(", "x", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", "\n", "\n", "m", "=", "K", ".", "max", "(", "tf", ".", "abs", "(", "x", ")", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", "\n", "scale", "=", "2.", "*", "m", "/", "3.", "\n", "if", "self", ".", "alpha", "==", "\"auto_po2\"", ":", "\n", "        ", "scale", "=", "K", ".", "pow", "(", "2.0", ",", "\n", "tf", ".", "math", ".", "round", "(", "K", ".", "log", "(", "scale", "+", "K", ".", "epsilon", "(", ")", ")", "/", "np", ".", "log", "(", "2.0", ")", ")", ")", "\n", "", "for", "_", "in", "range", "(", "self", ".", "number_of_unrolls", ")", ":", "\n", "        ", "T", "=", "scale", "/", "2.0", "\n", "q_ns", "=", "K", ".", "cast", "(", "tf", ".", "abs", "(", "x", ")", ">=", "T", ",", "K", ".", "floatx", "(", ")", ")", "*", "K", ".", "sign", "(", "x", ")", "\n", "scale", "=", "_get_scale", "(", "self", ".", "alpha", ",", "x", ",", "q_ns", ")", "\n", "\n", "", "x_norm", "=", "x", "/", "(", "x_std", "+", "K", ".", "epsilon", "(", ")", ")", "\n", "T", "=", "scale", "/", "(", "2.0", "*", "(", "x_std", "+", "K", ".", "epsilon", "(", ")", ")", ")", "\n", "\n", "if", "self", ".", "use_real_sigmoid", ":", "\n", "        ", "p0", "=", "tf", ".", "keras", ".", "backend", ".", "sigmoid", "(", "self", ".", "temperature", "*", "(", "x_norm", "-", "T", ")", ")", "\n", "p1", "=", "tf", ".", "keras", ".", "backend", ".", "sigmoid", "(", "self", ".", "temperature", "*", "(", "x_norm", "+", "T", ")", ")", "\n", "", "else", ":", "\n", "        ", "p0", "=", "_sigmoid", "(", "self", ".", "temperature", "*", "(", "x_norm", "-", "T", ")", ")", "\n", "p1", "=", "_sigmoid", "(", "self", ".", "temperature", "*", "(", "x_norm", "+", "T", ")", ")", "\n", "", "r0", "=", "tf", ".", "random", ".", "uniform", "(", "tf", ".", "shape", "(", "p0", ")", ")", "\n", "r1", "=", "tf", ".", "random", ".", "uniform", "(", "tf", ".", "shape", "(", "p1", ")", ")", "\n", "q0", "=", "tf", ".", "sign", "(", "p0", "-", "r0", ")", "\n", "q0", "+=", "(", "1.0", "-", "tf", ".", "abs", "(", "q0", ")", ")", "\n", "q1", "=", "tf", ".", "sign", "(", "p1", "-", "r1", ")", "\n", "q1", "+=", "(", "1.0", "-", "tf", ".", "abs", "(", "q1", ")", ")", "\n", "\n", "q", "=", "(", "q0", "+", "q1", ")", "/", "2.0", "\n", "self", ".", "scale", "=", "scale", "\n", "return", "x", "+", "tf", ".", "stop_gradient", "(", "-", "x", "+", "scale", "*", "q", ")", "\n", "\n", "", "output", "=", "tf_utils", ".", "smart_cond", "(", "\n", "K", ".", "learning_phase", "(", ")", ",", "\n", "stochastic_output", ",", "\n", "lambda", ":", "ternary", ".", "__call__", "(", "self", ",", "x", ")", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_ternary._set_trainable_parameter": [[1103, 1106], ["None"], "methods", ["None"], ["", "def", "_set_trainable_parameter", "(", "self", ")", ":", "\n", "    ", "if", "self", ".", "alpha", "is", "None", ":", "\n", "      ", "self", ".", "alpha", "=", "\"auto_po2\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_ternary.max": [[1107, 1113], ["isinstance", "quantizers.stochastic_ternary.max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "", "def", "max", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get the maximum value that stochastic_ternary can respresent.\"\"\"", "\n", "if", "self", ".", "alpha", "is", "None", "or", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "      ", "return", "1.0", "\n", "", "else", ":", "\n", "      ", "return", "max", "(", "1.0", ",", "self", ".", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_ternary.min": [[1114, 1120], ["isinstance", "quantizers.stochastic_ternary.max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "", "def", "min", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get the minimum value that stochastic_ternary can respresent.\"\"\"", "\n", "if", "self", ".", "alpha", "is", "None", "or", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "      ", "return", "-", "1.0", "\n", "", "else", ":", "\n", "      ", "return", "-", "max", "(", "1.0", ",", "self", ".", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_ternary.from_config": [[1121, 1124], ["cls"], "methods", ["None"], ["", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "config", ")", ":", "\n", "    ", "return", "cls", "(", "**", "config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_ternary.get_config": [[1125, 1134], ["None"], "methods", ["None"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "\"alpha\"", ":", "self", ".", "alpha", ",", "\n", "\"threshold\"", ":", "self", ".", "threshold", ",", "\n", "\"temperature\"", ":", "self", ".", "temperature", ",", "\n", "\"use_real_sigmoid\"", ":", "self", ".", "use_real_sigmoid", ",", "\n", "\"number_of_unrolls\"", ":", "self", ".", "number_of_unrolls", "\n", "}", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.binary.__init__": [[1156, 1164], ["quantizers.BaseQuantizer.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "use_01", "=", "False", ",", "alpha", "=", "None", ",", "use_stochastic_rounding", "=", "False", ")", ":", "\n", "    ", "super", "(", "binary", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "use_01", "=", "use_01", "\n", "self", ".", "bits", "=", "1", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "use_stochastic_rounding", "=", "use_stochastic_rounding", "\n", "self", ".", "default_alpha", "=", "1.0", "\n", "self", ".", "scale", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.binary.__str__": [[1165, 1178], ["flags.append", "str", "isinstance", "flags.append", "flags.append", "str", "str", "int"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "    ", "flags", "=", "[", "]", "\n", "if", "self", ".", "use_01", ":", "\n", "      ", "flags", ".", "append", "(", "\"use_01=\"", "+", "str", "(", "int", "(", "self", ".", "use_01", ")", ")", ")", "\n", "", "if", "self", ".", "alpha", "is", "not", "None", ":", "\n", "      ", "alpha", "=", "str", "(", "self", ".", "alpha", ")", "\n", "if", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "        ", "alpha", "=", "\"'\"", "+", "alpha", "+", "\"'\"", "\n", "", "flags", ".", "append", "(", "\"alpha=\"", "+", "alpha", ")", "\n", "", "if", "self", ".", "use_stochastic_rounding", ":", "\n", "      ", "flags", ".", "append", "(", "\n", "\"use_stochastic_rounding=\"", "+", "str", "(", "self", ".", "use_stochastic_rounding", ")", ")", "\n", "", "return", "\"binary(\"", "+", "\",\"", ".", "join", "(", "flags", ")", "+", "\")\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.binary.__call__": [[1179, 1236], ["isinstance", "tensorflow.sign", "tensorflow.sign", "quantizers._get_scale", "isinstance", "tensorflow.max", "tensorflow.max", "tensorflow.where", "tensorflow.where", "tensorflow.python.framework.smart_cond.smart_cond", "tensorflow.python.framework.smart_cond.smart_cond", "tensorflow.abs", "tensorflow.abs", "tensorflow.tanh", "tensorflow.tanh", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "isinstance", "len", "tensorflow.abs", "tensorflow.abs", "tensorflow.ones_like", "tensorflow.ones_like", "tensorflow.learning_phase", "tensorflow.learning_phase", "tensorflow.python.framework.smart_cond.smart_cond", "tensorflow.python.framework.smart_cond.smart_cond", "float", "tensorflow.tanh.shape.as_list", "len", "tensorflow.image_data_format", "tensorflow.image_data_format", "list", "list", "tensorflow.abs", "tensorflow.abs", "tensorflow.learning_phase", "tensorflow.learning_phase", "list", "six.moves.range", "six.moves.range", "quantizers._round_through", "tensorflow.ones_like", "tensorflow.ones_like", "tensorflow.shape", "tensorflow.shape", "tensorflow.round", "tensorflow.round", "tensorflow.floatx", "tensorflow.floatx", "tensorflow.random.uniform", "tensorflow.random.uniform", "tensorflow.shape", "tensorflow.shape"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_scale", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._round_through"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "    ", "if", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "      ", "assert", "self", ".", "alpha", "in", "[", "\"auto\"", ",", "\"auto_po2\"", "]", "\n", "", "if", "self", ".", "alpha", "is", "None", ":", "\n", "      ", "scale", "=", "self", ".", "default_alpha", "\n", "", "elif", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "      ", "scale", "=", "1.0", "\n", "", "elif", "isinstance", "(", "self", ".", "alpha", ",", "np", ".", "ndarray", ")", ":", "\n", "      ", "scale", "=", "self", ".", "alpha", "\n", "", "else", ":", "\n", "      ", "scale", "=", "float", "(", "self", ".", "alpha", ")", "\n", "\n", "", "if", "self", ".", "use_stochastic_rounding", ":", "\n", "      ", "try", ":", "\n", "        ", "len_axis", "=", "len", "(", "x", ".", "shape", ".", "as_list", "(", ")", ")", "\n", "", "except", "AttributeError", ":", "\n", "        ", "len_axis", "=", "len", "(", "list", "(", "x", ".", "shape", ")", ")", "\n", "", "if", "len_axis", "==", "1", ":", "\n", "        ", "axis", "=", "None", "\n", "", "elif", "K", ".", "image_data_format", "(", ")", "==", "\"channels_last\"", ":", "\n", "        ", "axis", "=", "list", "(", "range", "(", "len_axis", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "        ", "axis", "=", "list", "(", "range", "(", "1", ",", "len_axis", ")", ")", "\n", "\n", "# if stochastic_round is through, we need to scale", "\n", "# number so that the precision is small enough.", "\n", "# This is especially important if range of x is very", "\n", "# small, which occurs during initialization of weights.", "\n", "", "m", "=", "K", ".", "max", "(", "tf", ".", "abs", "(", "x", ")", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", "\n", "m", "=", "tf", ".", "where", "(", "m", ">", "1.0", ",", "tf", ".", "ones_like", "(", "m", ")", ",", "m", ")", "\n", "f", "=", "2", "*", "m", "\n", "\n", "x", "=", "tf_utils", ".", "smart_cond", "(", "\n", "K", ".", "learning_phase", "(", ")", ",", "\n", "lambda", ":", "f", "*", "_round_through", "(", "\n", "x", "/", "f", ",", "use_stochastic_rounding", "=", "True", ",", "precision", "=", "0.125", ")", ",", "\n", "lambda", ":", "x", ")", "\n", "\n", "", "k_sign", "=", "tf", ".", "sign", "(", "x", ")", "\n", "if", "self", ".", "use_stochastic_rounding", ":", "\n", "# in inference, we use a biased \"1\" for stochastic rounding right now", "\n", "      ", "k_sign", "+=", "(", "1.0", "-", "tf", ".", "abs", "(", "k_sign", ")", ")", "*", "tf_utils", ".", "smart_cond", "(", "\n", "K", ".", "learning_phase", "(", ")", ",", "\n", "lambda", ":", "2.0", "*", "tf", ".", "round", "(", "tf", ".", "random", ".", "uniform", "(", "tf", ".", "shape", "(", "x", ")", ")", ")", "-", "1.0", ",", "\n", "lambda", ":", "tf", ".", "ones_like", "(", "tf", ".", "shape", "(", "x", ")", ",", "dtype", "=", "K", ".", "floatx", "(", ")", ")", ")", "\n", "# if something still remains, just make it positive for now.", "\n", "", "k_sign", "+=", "(", "1.0", "-", "tf", ".", "abs", "(", "k_sign", ")", ")", "\n", "if", "self", ".", "use_01", ":", "\n", "      ", "k_sign", "=", "(", "k_sign", "+", "1.0", ")", "/", "2.0", "\n", "\n", "# approximate binary by tanh(x) as it has limited range between -1 and +1.", "\n", "", "if", "self", ".", "alpha", "is", "None", ":", "\n", "      ", "x", "=", "K", ".", "tanh", "(", "x", ")", "\n", "\n", "", "scale", "=", "_get_scale", "(", "self", ".", "alpha", ",", "x", ",", "k_sign", ")", "\n", "self", ".", "scale", "=", "scale", "\n", "return", "x", "+", "tf", ".", "stop_gradient", "(", "-", "x", "+", "scale", "*", "k_sign", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.binary._set_trainable_parameter": [[1237, 1240], ["None"], "methods", ["None"], ["", "def", "_set_trainable_parameter", "(", "self", ")", ":", "\n", "    ", "if", "self", ".", "alpha", "is", "None", ":", "\n", "      ", "self", ".", "alpha", "=", "\"auto_po2\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.binary.max": [[1241, 1247], ["isinstance", "quantizers.binary.max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "", "def", "max", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get maximum value that binary class can respresent.\"\"\"", "\n", "if", "self", ".", "alpha", "is", "None", "or", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "      ", "return", "1.0", "\n", "", "else", ":", "\n", "      ", "return", "max", "(", "1.0", ",", "self", ".", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.binary.min": [[1248, 1256], ["isinstance", "quantizers.binary.max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "", "def", "min", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get minimum value that binary class can respresent.\"\"\"", "\n", "if", "self", ".", "use_01", ":", "\n", "      ", "return", "0.0", "\n", "", "elif", "self", ".", "alpha", "is", "None", "or", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "      ", "return", "-", "1.0", "\n", "", "else", ":", "\n", "      ", "return", "-", "max", "(", "1.0", ",", "self", ".", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.binary.from_config": [[1257, 1260], ["cls"], "methods", ["None"], ["", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "config", ")", ":", "\n", "    ", "return", "cls", "(", "**", "config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.binary.get_config": [[1261, 1268], ["None"], "methods", ["None"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "\"use_01\"", ":", "self", ".", "use_01", ",", "\n", "\"alpha\"", ":", "self", ".", "alpha", ",", "\n", "\"use_stochastic_rounding\"", ":", "self", ".", "use_stochastic_rounding", "\n", "}", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary.__init__": [[1288, 1296], ["quantizers.binary.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "alpha", "=", "None", ",", "temperature", "=", "6.0", ",", "use_real_sigmoid", "=", "True", ")", ":", "\n", "    ", "super", "(", "stochastic_binary", ",", "self", ")", ".", "__init__", "(", "alpha", "=", "alpha", ")", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "bits", "=", "1", "\n", "self", ".", "temperature", "=", "temperature", "\n", "self", ".", "use_real_sigmoid", "=", "use_real_sigmoid", "\n", "self", ".", "default_alpha", "=", "1.0", "\n", "self", ".", "scale", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary.__str__": [[1297, 1309], ["str", "isinstance", "flags.append", "flags.append", "flags.append", "str", "str", "int"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "    ", "flags", "=", "[", "]", "\n", "if", "self", ".", "alpha", "is", "not", "None", ":", "\n", "      ", "alpha", "=", "str", "(", "self", ".", "alpha", ")", "\n", "if", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "        ", "alpha", "=", "\"'\"", "+", "alpha", "+", "\"'\"", "\n", "", "flags", ".", "append", "(", "\"alpha=\"", "+", "alpha", ")", "\n", "", "if", "self", ".", "temperature", "!=", "6.0", ":", "\n", "      ", "flags", ".", "append", "(", "\"temperature=\"", "+", "str", "(", "self", ".", "temperature", ")", ")", "\n", "", "if", "not", "self", ".", "use_real_sigmoid", ":", "\n", "      ", "flags", ".", "append", "(", "\"use_real_sigmoid=\"", "+", "str", "(", "int", "(", "self", ".", "use_real_sigmoid", ")", ")", ")", "\n", "", "return", "\"stochastic_binary(\"", "+", "\",\"", ".", "join", "(", "flags", ")", "+", "\")\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary.__call__": [[1310, 1343], ["tensorflow.python.framework.smart_cond.smart_cond", "tensorflow.python.framework.smart_cond.smart_cond", "isinstance", "tensorflow.random.uniform", "tensorflow.random.uniform", "tensorflow.sign", "tensorflow.sign", "tensorflow.sign", "tensorflow.sign", "quantizers._get_scale", "tensorflow.learning_phase", "tensorflow.learning_phase", "len", "tensorflow.keras.backend.sigmoid", "tensorflow.keras.backend.sigmoid", "_sigmoid", "tensorflow.shape", "tensorflow.shape", "tensorflow.abs", "tensorflow.abs", "tensorflow.abs", "tensorflow.abs", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "quantizers.binary.__call__", "tensorflow.std", "tensorflow.std", "tensorflow.epsilon", "tensorflow.epsilon", "tensorflow.image_data_format", "tensorflow.image_data_format", "list", "list", "six.moves.range", "six.moves.range"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_scale", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.Clip.__call__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "    ", "def", "stochastic_output", "(", ")", ":", "\n", "      ", "if", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "        ", "assert", "self", ".", "alpha", "in", "[", "\"auto\"", ",", "\"auto_po2\"", "]", "\n", "len_axis", "=", "len", "(", "x", ".", "shape", ")", "\n", "if", "len_axis", ">", "1", ":", "\n", "          ", "if", "K", ".", "image_data_format", "(", ")", "==", "\"channels_last\"", ":", "\n", "            ", "axis", "=", "list", "(", "range", "(", "len_axis", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "            ", "axis", "=", "list", "(", "range", "(", "1", ",", "len_axis", ")", ")", "\n", "", "", "else", ":", "\n", "          ", "axis", "=", "[", "0", "]", "\n", "", "std", "=", "K", ".", "std", "(", "x", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", "+", "K", ".", "epsilon", "(", ")", "\n", "", "else", ":", "\n", "        ", "std", "=", "1.0", "\n", "\n", "", "if", "self", ".", "use_real_sigmoid", ":", "\n", "        ", "p", "=", "tf", ".", "keras", ".", "backend", ".", "sigmoid", "(", "self", ".", "temperature", "*", "x", "/", "std", ")", "\n", "", "else", ":", "\n", "        ", "p", "=", "_sigmoid", "(", "self", ".", "temperature", "*", "x", "/", "std", ")", "\n", "\n", "", "r", "=", "tf", ".", "random", ".", "uniform", "(", "tf", ".", "shape", "(", "x", ")", ")", "\n", "q", "=", "tf", ".", "sign", "(", "p", "-", "r", ")", "\n", "q", "+=", "(", "1.0", "-", "tf", ".", "abs", "(", "q", ")", ")", "\n", "q_non_stochastic", "=", "tf", ".", "sign", "(", "x", ")", "\n", "q_non_stochastic", "+=", "(", "1.0", "-", "tf", ".", "abs", "(", "q_non_stochastic", ")", ")", "\n", "scale", "=", "_get_scale", "(", "self", ".", "alpha", ",", "x", ",", "q_non_stochastic", ")", "\n", "self", ".", "scale", "=", "scale", "\n", "return", "x", "+", "tf", ".", "stop_gradient", "(", "-", "x", "+", "scale", "*", "q", ")", "\n", "\n", "", "output", "=", "tf_utils", ".", "smart_cond", "(", "\n", "K", ".", "learning_phase", "(", ")", ",", "stochastic_output", ",", "lambda", ":", "binary", ".", "__call__", "(", "self", ",", "x", ")", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary._set_trainable_parameter": [[1344, 1347], ["None"], "methods", ["None"], ["", "def", "_set_trainable_parameter", "(", "self", ")", ":", "\n", "    ", "if", "self", ".", "alpha", "is", "None", ":", "\n", "      ", "self", ".", "alpha", "=", "\"auto_po2\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary.max": [[1348, 1354], ["isinstance", "quantizers.stochastic_binary.max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "", "def", "max", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get the maximum value that stochastic_binary can respresent.\"\"\"", "\n", "if", "self", ".", "alpha", "is", "None", "or", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "      ", "return", "1.0", "\n", "", "else", ":", "\n", "      ", "return", "max", "(", "1.0", ",", "self", ".", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary.min": [[1355, 1361], ["isinstance", "quantizers.stochastic_binary.max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "", "def", "min", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get the minimum value that stochastic_binary can respresent.\"\"\"", "\n", "if", "self", ".", "alpha", "is", "None", "or", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "      ", "return", "-", "1.0", "\n", "", "else", ":", "\n", "      ", "return", "-", "max", "(", "1.0", ",", "self", ".", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary.from_config": [[1362, 1365], ["cls"], "methods", ["None"], ["", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "config", ")", ":", "\n", "    ", "return", "cls", "(", "**", "config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary.get_config": [[1366, 1373], ["None"], "methods", ["None"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "\"alpha\"", ":", "self", ".", "alpha", ",", "\n", "\"temperature\"", ":", "self", ".", "temperature", ",", "\n", "\"use_real_sigmoid\"", ":", "self", ".", "use_real_sigmoid", ",", "\n", "}", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.__init__": [[1426, 1453], ["quantizers.BaseQuantizer.__init__", "numpy.mod", "numpy.log2"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "\n", "bits", "=", "8", ",", "\n", "integer", "=", "0", ",", "\n", "use_sigmoid", "=", "0", ",", "\n", "negative_slope", "=", "0.0", ",", "\n", "use_stochastic_rounding", "=", "False", ",", "\n", "relu_upper_bound", "=", "None", ",", "\n", "is_quantized_clip", "=", "True", ",", "\n", "qnoise_factor", "=", "1.0", ",", "\n", "var_name", "=", "None", ",", "\n", "use_ste", "=", "True", ",", "\n", "use_variables", "=", "False", ")", ":", "\n", "    ", "super", "(", "quantized_relu", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "bits", "=", "bits", "\n", "self", ".", "integer", "=", "integer", "\n", "self", ".", "use_sigmoid", "=", "use_sigmoid", "\n", "self", ".", "negative_slope", "=", "negative_slope", "\n", "self", ".", "use_stochastic_rounding", "=", "use_stochastic_rounding", "\n", "self", ".", "relu_upper_bound", "=", "relu_upper_bound", "\n", "self", ".", "is_quantized_clip", "=", "is_quantized_clip", "\n", "self", ".", "qnoise_factor", "=", "qnoise_factor", "\n", "self", ".", "use_ste", "=", "use_ste", "\n", "assert", "negative_slope", ">=", "0.0", "\n", "if", "negative_slope", "!=", "0.0", ":", "\n", "      ", "assert", "np", ".", "mod", "(", "np", ".", "log2", "(", "negative_slope", ")", ",", "1", ")", "==", "0", "\n", "", "self", ".", "var_name", "=", "var_name", "\n", "self", ".", "use_variables", "=", "use_variables", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.__str__": [[1454, 1470], ["re.sub", "str", "str", "flags.append", "flags.append", "flags.append", "str", "str", "str", "isinstance", "quantizers.quantized_relu.integer.numpy", "int", "int"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "# Converts Tensors to printable strings by converting to a numpy array and", "\n", "# then using regex to remove brackets when there is only one integer bit", "\n", "    ", "integer_bits", "=", "re", ".", "sub", "(", "\n", "r\"\\[(\\d)\\]\"", ",", "r\"\\g<1>\"", ",", "\n", "str", "(", "self", ".", "integer", ".", "numpy", "(", ")", "if", "isinstance", "(", "self", ".", "integer", ",", "tf", ".", "Variable", "\n", ")", "else", "self", ".", "integer", ")", ")", "\n", "\n", "flags", "=", "[", "str", "(", "self", ".", "bits", ")", ",", "integer_bits", "]", "\n", "if", "self", ".", "use_sigmoid", "or", "self", ".", "use_stochastic_rounding", ":", "\n", "      ", "flags", ".", "append", "(", "str", "(", "int", "(", "self", ".", "use_sigmoid", ")", ")", ")", "\n", "", "if", "self", ".", "negative_slope", ":", "\n", "      ", "flags", ".", "append", "(", "str", "(", "self", ".", "negative_slope", ")", ")", "\n", "", "if", "self", ".", "use_stochastic_rounding", ":", "\n", "      ", "flags", ".", "append", "(", "str", "(", "int", "(", "self", ".", "use_stochastic_rounding", ")", ")", ")", "\n", "", "return", "\"quantized_relu(\"", "+", "\",\"", ".", "join", "(", "flags", ")", "+", "\")\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.__call__": [[1471, 1530], ["tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "quantizers.quantized_relu.build", "tensorflow.pow", "tensorflow.pow", "tensorflow.pow", "tensorflow.pow", "tensorflow.pow", "tensorflow.pow", "tensorflow.where", "tensorflow.where", "tensorflow.where", "tensorflow.where", "tensorflow.constant", "tensorflow.constant", "tensorflow.relu", "tensorflow.relu", "tensorflow.where", "tensorflow.where", "tensorflow.relu", "tensorflow.relu", "_sigmoid", "tensorflow.keras.backend.clip", "tensorflow.keras.backend.clip", "tensorflow.keras.backend.clip", "tensorflow.keras.backend.clip", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "tensorflow.cast", "tensorflow.cast", "tensorflow.ones_like", "tensorflow.ones_like", "tensorflow.relu", "tensorflow.relu", "tensorflow.ones_like", "tensorflow.ones_like", "tensorflow.ones_like", "tensorflow.ones_like", "tensorflow.keras.backend.clip", "tensorflow.keras.backend.clip", "quantizers._round_through", "tensorflow.keras.backend.clip", "tensorflow.keras.backend.clip", "quantizers._round_through", "quantizers._round_through", "quantizers._round_through"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.networks.conv_block.ConvBlockNetwork.build", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._round_through", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._round_through", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._round_through", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._round_through"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "    ", "if", "not", "self", ".", "built", ":", "\n", "      ", "self", ".", "build", "(", "var_name", "=", "self", ".", "var_name", ",", "use_variables", "=", "self", ".", "use_variables", ")", "\n", "\n", "", "non_sign_bits", "=", "self", ".", "bits", "-", "(", "self", ".", "negative_slope", "!=", "0.0", ")", "\n", "x", "=", "K", ".", "cast", "(", "x", ",", "dtype", "=", "\"float32\"", ")", "\n", "m", "=", "K", ".", "cast", "(", "K", ".", "pow", "(", "2", ",", "non_sign_bits", ")", ",", "dtype", "=", "\"float32\"", ")", "\n", "m_i", "=", "K", ".", "cast", "(", "K", ".", "pow", "(", "2", ",", "self", ".", "integer", ")", ",", "dtype", "=", "\"float32\"", ")", "\n", "\n", "# is_quantized_clip has precedence over relu_upper_bound for backward", "\n", "# compatibility.", "\n", "m_f", "=", "K", ".", "cast", "(", "\n", "K", ".", "pow", "(", "\n", "tf", ".", "constant", "(", "2.", ",", "tf", ".", "float32", ")", ",", "\n", "K", ".", "cast", "(", "self", ".", "integer", ",", "dtype", "=", "\"float32\"", ")", "-", "non_sign_bits", ")", ",", "\n", "dtype", "=", "\"float32\"", ")", "\n", "if", "self", ".", "is_quantized_clip", ":", "\n", "      ", "x_u", "=", "tf", ".", "where", "(", "x", "<=", "m_i", "-", "m_f", ",", "K", ".", "relu", "(", "x", ",", "alpha", "=", "self", ".", "negative_slope", ")", ",", "\n", "tf", ".", "ones_like", "(", "x", ")", "*", "(", "m_i", "-", "m_f", ")", ")", "\n", "", "elif", "self", ".", "relu_upper_bound", "is", "not", "None", ":", "\n", "      ", "x_u", "=", "tf", ".", "where", "(", "x", "<=", "self", ".", "relu_upper_bound", ",", "\n", "K", ".", "relu", "(", "x", ",", "alpha", "=", "self", ".", "negative_slope", ")", ",", "\n", "tf", ".", "ones_like", "(", "x", ")", "*", "self", ".", "relu_upper_bound", ")", "\n", "", "else", ":", "\n", "      ", "x_u", "=", "K", ".", "relu", "(", "x", ",", "alpha", "=", "self", ".", "negative_slope", ")", "\n", "\n", "", "if", "self", ".", "use_sigmoid", ":", "\n", "      ", "p", "=", "_sigmoid", "(", "x", "/", "m_i", ")", "*", "m", "\n", "xq", "=", "m_i", "*", "tf", ".", "keras", ".", "backend", ".", "clip", "(", "\n", "2.0", "*", "(", "_round_through", "(", "p", ",", "self", ".", "use_stochastic_rounding", ")", "/", "m", ")", "-", "1.0", ",", "\n", "0.0", ",", "1.0", "-", "1.0", "/", "m", ")", "\n", "if", "self", ".", "negative_slope", ">", "0", ":", "\n", "        ", "neg_factor", "=", "1", "/", "(", "self", ".", "negative_slope", "*", "m", ")", "\n", "xq", "=", "xq", "+", "m_i", "*", "self", ".", "negative_slope", "*", "tf", ".", "keras", ".", "backend", ".", "clip", "(", "\n", "2.0", "*", "(", "_round_through", "(", "p", "*", "self", ".", "negative_slope", ",", "\n", "self", ".", "use_stochastic_rounding", ")", "*", "neg_factor", ")", "-", "\n", "1.0", ",", "-", "1.0", ",", "0.0", ")", "\n", "", "", "else", ":", "\n", "      ", "p", "=", "x", "*", "m", "/", "m_i", "\n", "xq", "=", "m_i", "*", "tf", ".", "keras", ".", "backend", ".", "clip", "(", "\n", "_round_through", "(", "p", ",", "self", ".", "use_stochastic_rounding", ")", "/", "m", ",", "0.0", ",", "\n", "1.0", "-", "1.0", "/", "m", ")", "\n", "if", "self", ".", "negative_slope", ">", "0", ":", "\n", "        ", "neg_factor", "=", "1", "/", "(", "self", ".", "negative_slope", "*", "m", ")", "\n", "xq", "=", "xq", "+", "m_i", "*", "self", ".", "negative_slope", "*", "(", "\n", "tf", ".", "keras", ".", "backend", ".", "clip", "(", "\n", "_round_through", "(", "p", "*", "self", ".", "negative_slope", ",", "\n", "self", ".", "use_stochastic_rounding", ")", "*", "neg_factor", ",", "-", "1.0", ",", "\n", "0.0", ")", ")", "\n", "\n", "", "", "if", "self", ".", "relu_upper_bound", "and", "not", "self", ".", "is_quantized_clip", ":", "\n", "      ", "xq", "=", "tf", ".", "where", "(", "xq", "<=", "self", ".", "relu_upper_bound", ",", "xq", ",", "\n", "tf", ".", "ones_like", "(", "xq", ")", "*", "self", ".", "relu_upper_bound", ")", "\n", "\n", "", "if", "self", ".", "use_ste", ":", "\n", "      ", "return", "x_u", "+", "tf", ".", "stop_gradient", "(", "self", ".", "qnoise_factor", "*", "(", "-", "x_u", "+", "xq", ")", ")", "\n", "", "else", ":", "\n", "      ", "return", "(", "1", "-", "self", ".", "qnoise_factor", ")", "*", "x_u", "+", "tf", ".", "stop_gradient", "(", "\n", "self", ".", "qnoise_factor", "*", "xq", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.max": [[1531, 1543], ["quantizers.quantized_relu.max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "", "def", "max", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get the maximum value that quantized_relu can represent.\"\"\"", "\n", "unsigned_bits", "=", "self", ".", "bits", "-", "(", "self", ".", "negative_slope", "!=", "0.0", ")", "\n", "\n", "if", "unsigned_bits", ">", "0", ":", "\n", "      ", "return", "max", "(", "\n", "1.0", ",", "\n", "np", ".", "array", "(", "\n", "K", ".", "pow", "(", "2.0", ",", "K", ".", "cast", "(", "self", ".", "integer", ",", "dtype", "=", "\"float32\"", ")", ")", ",", "\n", "dtype", "=", "\"float32\"", ")", ")", "\n", "", "else", ":", "\n", "      ", "return", "1.0", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.min": [[1544, 1557], ["quantizers.quantized_relu.min"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min"], ["", "", "def", "min", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get the minimum value that quantized_relu can represent.\"\"\"", "\n", "if", "self", ".", "negative_slope", "==", "0.0", ":", "\n", "      ", "return", "0.0", "\n", "\n", "", "unsigned_bits", "=", "self", ".", "bits", "-", "1", "\n", "if", "unsigned_bits", ">", "0", ":", "\n", "      ", "return", "min", "(", "\n", "-", "0.0", ",", "-", "self", ".", "negative_slope", "*", "np", ".", "array", "(", "\n", "K", ".", "pow", "(", "2.0", ",", "K", ".", "cast", "(", "self", ".", "integer", ",", "dtype", "=", "\"float32\"", ")", ")", ",", "\n", "dtype", "=", "\"float32\"", ")", ")", "\n", "", "else", ":", "\n", "      ", "return", "-", "1.0", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range": [[1558, 1569], ["numpy.asarray", "six.moves.range", "numpy.array", "tensorflow.pow", "tensorflow.pow", "tensorflow.cast", "tensorflow.cast"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "", "def", "range", "(", "self", ")", ":", "\n", "    ", "\"\"\"Returns a list of all values that quantized_relu can represent\n\n      ordered by their binary representation ascending.\n    \"\"\"", "\n", "assert", "self", ".", "use_sigmoid", "==", "0", "# current unsupported", "\n", "assert", "self", ".", "negative_slope", "==", "0", "# # unsupported unsupported", "\n", "x", "=", "np", ".", "asarray", "(", "range", "(", "2", "**", "self", ".", "bits", ")", ")", "\n", "return", "x", "*", "np", ".", "array", "(", "\n", "K", ".", "pow", "(", "2.0", ",", "-", "self", ".", "bits", "+", "K", ".", "cast", "(", "self", ".", "integer", ",", "dtype", "=", "\"float32\"", ")", ")", ",", "\n", "dtype", "=", "\"float32\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.from_config": [[1570, 1573], ["cls"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "config", ")", ":", "\n", "    ", "return", "cls", "(", "**", "config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.get_config": [[1574, 1594], ["isinstance", "quantizers.quantized_relu.integer.numpy", "isinstance", "quantizers.quantized_relu.qnoise_factor.numpy"], "methods", ["None"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "\"bits\"", ":", "\n", "self", ".", "bits", ",", "\n", "\"integer\"", ":", "\n", "self", ".", "integer", ".", "numpy", "(", ")", "if", "isinstance", "(", "self", ".", "integer", ",", "tf", ".", "Variable", ")", "else", "\n", "self", ".", "integer", ",", "\n", "\"use_sigmoid\"", ":", "\n", "self", ".", "use_sigmoid", ",", "\n", "\"negative_slope\"", ":", "\n", "self", ".", "negative_slope", ",", "\n", "\"use_stochastic_rounding\"", ":", "\n", "self", ".", "use_stochastic_rounding", ",", "\n", "\"relu_upper_bound\"", ":", "\n", "self", ".", "relu_upper_bound", ",", "\n", "\"qnoise_factor\"", ":", "\n", "self", ".", "qnoise_factor", ".", "numpy", "(", ")", "if", "isinstance", "(", "\n", "self", ".", "qnoise_factor", ",", "tf", ".", "Variable", ")", "else", "self", ".", "qnoise_factor", "\n", "}", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_ulaw.__init__": [[1612, 1618], ["quantizers.BaseQuantizer.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "bits", "=", "8", ",", "integer", "=", "0", ",", "symmetric", "=", "0", ",", "u", "=", "255.0", ")", ":", "\n", "    ", "super", "(", "quantized_ulaw", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "bits", "=", "bits", "\n", "self", ".", "integer", "=", "integer", "\n", "self", ".", "symmetric", "=", "symmetric", "\n", "self", ".", "u", "=", "u", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_ulaw.__str__": [[1619, 1626], ["str", "str", "flags.append", "flags.append", "str", "str", "int"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "    ", "flags", "=", "[", "str", "(", "self", ".", "bits", ")", ",", "str", "(", "self", ".", "integer", ")", "]", "\n", "if", "self", ".", "symmetric", "or", "self", ".", "u", "!=", "255.0", ":", "\n", "      ", "flags", ".", "append", "(", "str", "(", "int", "(", "self", ".", "symmetric", ")", ")", ")", "\n", "", "if", "self", ".", "u", "!=", "255.0", ":", "\n", "      ", "flags", ".", "append", "(", "str", "(", "self", ".", "u", ")", ")", "\n", "", "return", "\"quantized_ulaw(\"", "+", "\",\"", ".", "join", "(", "flags", ")", "+", "\")\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_ulaw.__call__": [[1627, 1638], ["pow", "pow", "_sigmoid", "tensorflow.keras.backend.log", "tensorflow.keras.backend.log", "tensorflow.keras.backend.clip", "tensorflow.keras.backend.clip", "tensorflow.sign", "tensorflow.sign", "tensorflow.keras.backend.log", "tensorflow.keras.backend.log", "quantizers._round_through", "tensorflow.abs", "tensorflow.abs"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._round_through"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "    ", "non_sign_bits", "=", "self", ".", "bits", "-", "1", "\n", "m", "=", "pow", "(", "2", ",", "non_sign_bits", ")", "\n", "m_i", "=", "pow", "(", "2", ",", "self", ".", "integer", ")", "\n", "p", "=", "_sigmoid", "(", "x", "/", "m_i", ")", "*", "m", "\n", "rp", "=", "2.0", "*", "(", "_round_through", "(", "p", ")", "/", "m", ")", "-", "1.0", "\n", "u_law_p", "=", "tf", ".", "sign", "(", "rp", ")", "*", "tf", ".", "keras", ".", "backend", ".", "log", "(", "\n", "1", "+", "self", ".", "u", "*", "tf", ".", "abs", "(", "rp", ")", ")", "/", "tf", ".", "keras", ".", "backend", ".", "log", "(", "1", "+", "self", ".", "u", ")", "\n", "xq", "=", "m_i", "*", "tf", ".", "keras", ".", "backend", ".", "clip", "(", "u_law_p", ",", "-", "1.0", "+", "\n", "(", "1.0", "*", "self", ".", "symmetric", ")", "/", "m", ",", "1.0", "-", "1.0", "/", "m", ")", "\n", "return", "xq", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_ulaw.max": [[1639, 1647], ["quantizers.quantized_ulaw.max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "def", "max", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get the maximum value that quantized_ulaw can represent.\"\"\"", "\n", "unsigned_bits", "=", "self", ".", "bits", "-", "1", "\n", "\n", "if", "unsigned_bits", ">", "0", ":", "\n", "      ", "return", "max", "(", "1.0", ",", "np", ".", "power", "(", "2.0", ",", "self", ".", "integer", ")", ")", "\n", "", "else", ":", "\n", "      ", "return", "1.0", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_ulaw.min": [[1648, 1656], ["quantizers.quantized_ulaw.max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "", "def", "min", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get the minimum value that quantized_ulaw can represent.\"\"\"", "\n", "unsigned_bits", "=", "self", ".", "bits", "-", "1", "\n", "\n", "if", "unsigned_bits", ">", "0", ":", "\n", "      ", "return", "-", "max", "(", "1.0", ",", "np", ".", "power", "(", "2.0", ",", "self", ".", "integer", ")", ")", "\n", "", "else", ":", "\n", "      ", "return", "-", "1.0", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_ulaw.from_config": [[1657, 1660], ["cls"], "methods", ["None"], ["", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "config", ")", ":", "\n", "    ", "return", "cls", "(", "**", "config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_ulaw.get_config": [[1661, 1669], ["None"], "methods", ["None"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "\"bits\"", ":", "self", ".", "bits", ",", "\n", "\"integer\"", ":", "self", ".", "integer", ",", "\n", "\"symmetric\"", ":", "self", ".", "symmetric", ",", "\n", "\"u\"", ":", "self", ".", "u", "\n", "}", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_tanh.__init__": [[1690, 1697], ["quantizers.BaseQuantizer.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "bits", "=", "8", ",", "use_stochastic_rounding", "=", "False", ",", "\n", "symmetric", "=", "False", ",", "use_real_tanh", "=", "False", ")", ":", "\n", "    ", "super", "(", "quantized_tanh", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "bits", "=", "bits", "\n", "self", ".", "symmetric", "=", "symmetric", "\n", "self", ".", "use_stochastic_rounding", "=", "use_stochastic_rounding", "\n", "self", ".", "use_real_tanh", "=", "use_real_tanh", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_tanh.__str__": [[1698, 1707], ["str", "flags.append", "flags.append", "flags.append", "str", "str", "str", "int", "int", "int"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "    ", "flags", "=", "[", "str", "(", "self", ".", "bits", ")", "]", "\n", "if", "self", ".", "use_stochastic_rounding", ":", "\n", "      ", "flags", ".", "append", "(", "str", "(", "int", "(", "self", ".", "use_stochastic_rounding", ")", ")", ")", "\n", "", "if", "self", ".", "symmetric", ":", "\n", "      ", "flags", ".", "append", "(", "str", "(", "int", "(", "self", ".", "symmetric", ")", ")", ")", "\n", "", "if", "self", ".", "use_real_tanh", ":", "\n", "      ", "flags", ".", "append", "(", "str", "(", "int", "(", "self", ".", "use_real_tanh", ")", ")", ")", "\n", "", "return", "\"quantized_tanh(\"", "+", "\",\"", ".", "join", "(", "flags", ")", "+", "\")\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_tanh.__call__": [[1708, 1717], ["tensorflow.cast_to_floatx", "tensorflow.cast_to_floatx", "tensorflow.cast_to_floatx", "tensorflow.cast_to_floatx", "tensorflow.keras.backend.clip", "tensorflow.keras.backend.clip", "tensorflow.pow", "tensorflow.pow", "tensorflow.tanh", "tensorflow.tanh", "quantizers._round_through", "_sigmoid"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._round_through"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "    ", "non_sign_bits", "=", "self", ".", "bits", "-", "1", "\n", "x", "=", "K", ".", "cast_to_floatx", "(", "x", ")", "\n", "m", "=", "K", ".", "cast_to_floatx", "(", "K", ".", "pow", "(", "2", ",", "non_sign_bits", ")", ")", "\n", "p", "=", "K", ".", "tanh", "(", "x", ")", "if", "self", ".", "use_real_tanh", "else", "2.0", "*", "_sigmoid", "(", "x", ")", "-", "1.0", "\n", "return", "tf", ".", "keras", ".", "backend", ".", "clip", "(", "\n", "(", "_round_through", "(", "p", "*", "m", ",", "self", ".", "use_stochastic_rounding", ")", "/", "m", ")", ",", "\n", "-", "1.0", "+", "(", "1.0", "*", "self", ".", "symmetric", ")", "/", "m", ",", "\n", "1.0", "-", "1.0", "/", "m", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_tanh.max": [[1718, 1721], ["pow"], "methods", ["None"], ["", "def", "max", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get the maximum value that quantized_tanh can represent.\"\"\"", "\n", "return", "1.0", "-", "1.0", "/", "pow", "(", "2", ",", "self", ".", "bits", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_tanh.min": [[1722, 1725], ["pow"], "methods", ["None"], ["", "def", "min", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get the minimum value that quantized_tanh can represent.\"\"\"", "\n", "return", "-", "1.0", "+", "(", "1.0", "*", "self", ".", "symmetric", ")", "/", "pow", "(", "2", ",", "self", ".", "bits", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_tanh.from_config": [[1726, 1729], ["cls"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "config", ")", ":", "\n", "    ", "return", "cls", "(", "**", "config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_tanh.get_config": [[1730, 1738], ["None"], "methods", ["None"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "\"bits\"", ":", "self", ".", "bits", ",", "\n", "\"symmetric\"", ":", "self", ".", "symmetric", ",", "\n", "\"use_stochastic_rounding\"", ":", "self", ".", "use_stochastic_rounding", ",", "\n", "\"use_real_tanh\"", ":", "self", ".", "use_real_tanh", "\n", "}", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_sigmoid.__init__": [[1754, 1762], ["quantizers.BaseQuantizer.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "bits", "=", "8", ",", "symmetric", "=", "False", ",", "\n", "use_real_sigmoid", "=", "False", ",", "\n", "use_stochastic_rounding", "=", "False", ")", ":", "\n", "    ", "super", "(", "quantized_sigmoid", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "bits", "=", "bits", "\n", "self", ".", "symmetric", "=", "symmetric", "\n", "self", ".", "use_real_sigmoid", "=", "use_real_sigmoid", "\n", "self", ".", "use_stochastic_rounding", "=", "use_stochastic_rounding", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_sigmoid.__str__": [[1763, 1772], ["str", "flags.append", "flags.append", "flags.append", "str", "str", "str", "int", "int", "int"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "    ", "flags", "=", "[", "str", "(", "self", ".", "bits", ")", "]", "\n", "if", "self", ".", "symmetric", ":", "\n", "      ", "flags", ".", "append", "(", "str", "(", "int", "(", "self", ".", "symmetric", ")", ")", ")", "\n", "", "if", "self", ".", "use_real_sigmoid", ":", "\n", "      ", "flags", ".", "append", "(", "str", "(", "int", "(", "self", ".", "use_real_sigmoid", ")", ")", ")", "\n", "", "if", "self", ".", "use_stochastic_rounding", ":", "\n", "      ", "flags", ".", "append", "(", "str", "(", "int", "(", "self", ".", "use_stochastic_rounding", ")", ")", ")", "\n", "", "return", "\"quantized_sigmoid(\"", "+", "\",\"", ".", "join", "(", "flags", ")", "+", "\")\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_sigmoid.__call__": [[1773, 1782], ["tensorflow.cast_to_floatx", "tensorflow.cast_to_floatx", "tensorflow.cast_to_floatx", "tensorflow.cast_to_floatx", "tensorflow.keras.backend.clip", "tensorflow.keras.backend.clip", "tensorflow.pow", "tensorflow.pow", "tensorflow.sigmoid", "tensorflow.sigmoid", "_sigmoid", "quantizers._round_through"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._round_through"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "    ", "x", "=", "K", ".", "cast_to_floatx", "(", "x", ")", "\n", "m", "=", "K", ".", "cast_to_floatx", "(", "K", ".", "pow", "(", "2", ",", "self", ".", "bits", ")", ")", "\n", "\n", "p", "=", "K", ".", "sigmoid", "(", "x", ")", "if", "self", ".", "use_real_sigmoid", "else", "_sigmoid", "(", "x", ")", "\n", "\n", "return", "tf", ".", "keras", ".", "backend", ".", "clip", "(", "(", "_round_through", "(", "p", "*", "m", ",", "self", ".", "use_stochastic_rounding", ")", "/", "m", ")", ",", "\n", "(", "1.0", "*", "self", ".", "symmetric", ")", "/", "m", ",", "\n", "1.0", "-", "1.0", "/", "m", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_sigmoid.max": [[1783, 1786], ["pow"], "methods", ["None"], ["", "def", "max", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get the maximum value that quantized_sigmoid can represent.\"\"\"", "\n", "return", "1.0", "-", "1.0", "/", "pow", "(", "2", ",", "self", ".", "bits", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_sigmoid.min": [[1787, 1790], ["pow"], "methods", ["None"], ["", "def", "min", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get the minimum value that quantized_sigmoid can represent.\"\"\"", "\n", "return", "(", "1.0", "*", "self", ".", "symmetric", ")", "/", "pow", "(", "2", ",", "self", ".", "bits", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_sigmoid.from_config": [[1791, 1794], ["cls"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "config", ")", ":", "\n", "    ", "return", "cls", "(", "**", "config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_sigmoid.get_config": [[1795, 1803], ["None"], "methods", ["None"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "\"bits\"", ":", "self", ".", "bits", ",", "\n", "\"symmetric\"", ":", "self", ".", "symmetric", ",", "\n", "\"use_real_sigmoid\"", ":", "self", ".", "use_real_sigmoid", ",", "\n", "\"use_stochastic_rounding\"", ":", "self", ".", "use_stochastic_rounding", "\n", "}", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_po2.__init__": [[1954, 1981], ["quantizers.BaseQuantizer.__init__", "quantizers._need_exponent_sign_bit_check", "quantizers._get_min_max_exponents"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._need_exponent_sign_bit_check", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_min_max_exponents"], ["def", "__init__", "(", "self", ",", "\n", "bits", "=", "8", ",", "\n", "max_value", "=", "None", ",", "\n", "use_stochastic_rounding", "=", "False", ",", "\n", "quadratic_approximation", "=", "False", ",", "\n", "log2_rounding", "=", "\"rnd\"", ",", "\n", "qnoise_factor", "=", "1.0", ",", "\n", "var_name", "=", "None", ",", "\n", "use_ste", "=", "True", ",", "\n", "use_variables", "=", "False", ")", ":", "\n", "    ", "super", "(", "quantized_po2", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "bits", "=", "bits", "\n", "self", ".", "max_value", "=", "max_value", "\n", "self", ".", "use_stochastic_rounding", "=", "use_stochastic_rounding", "\n", "self", ".", "log2_rounding", "=", "log2_rounding", "\n", "# if True, round to the exponent for sqrt(x),", "\n", "# so that the return value can be divided by two without remainder.", "\n", "self", ".", "quadratic_approximation", "=", "quadratic_approximation", "\n", "need_exponent_sign_bit", "=", "_need_exponent_sign_bit_check", "(", "self", ".", "max_value", ")", "\n", "non_sign_bits", "=", "self", ".", "bits", "-", "1", "\n", "self", ".", "_min_exp", ",", "self", ".", "_max_exp", "=", "_get_min_max_exponents", "(", "\n", "non_sign_bits", ",", "need_exponent_sign_bit", ",", "self", ".", "quadratic_approximation", ")", "\n", "# qnoise_factor related attributes", "\n", "self", ".", "qnoise_factor", "=", "qnoise_factor", "\n", "self", ".", "use_ste", "=", "use_ste", "\n", "self", ".", "var_name", "=", "var_name", "\n", "self", ".", "use_variables", "=", "use_variables", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_po2.__str__": [[1982, 1992], ["str", "flags.append", "flags.append", "flags.append", "str", "str", "int", "int", "str", "int"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "    ", "flags", "=", "[", "str", "(", "self", ".", "bits", ")", "]", "\n", "if", "self", ".", "max_value", "is", "not", "None", "or", "self", ".", "use_stochastic_rounding", ":", "\n", "      ", "flags", ".", "append", "(", "str", "(", "int", "(", "self", ".", "max_value", ")", ")", ")", "\n", "", "if", "self", ".", "use_stochastic_rounding", ":", "\n", "      ", "flags", ".", "append", "(", "str", "(", "int", "(", "self", ".", "use_stochastic_rounding", ")", ")", ")", "\n", "", "if", "self", ".", "quadratic_approximation", ":", "\n", "      ", "flags", ".", "append", "(", "\n", "\"quadratic_approximation=\"", "+", "str", "(", "int", "(", "self", ".", "quadratic_approximation", ")", ")", ")", "\n", "", "return", "\"quantized_po2(\"", "+", "\",\"", ".", "join", "(", "flags", ")", "+", "\")\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_po2.__call__": [[1993, 2012], ["tensorflow.sign", "tensorflow.sign", "tensorflow.abs", "tensorflow.abs", "quantizers._clip_power_of_two", "quantizers.quantized_po2.build", "tensorflow.abs", "tensorflow.abs", "pow", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "tensorflow.stop_gradient"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._clip_power_of_two", "home.repos.pwc.inspect_result.google_qkeras.networks.conv_block.ConvBlockNetwork.build"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "    ", "if", "not", "self", ".", "built", ":", "\n", "      ", "self", ".", "build", "(", "var_name", "=", "self", ".", "var_name", ",", "use_variables", "=", "self", ".", "use_variables", ")", "\n", "\n", "", "x_sign", "=", "tf", ".", "sign", "(", "x", ")", "\n", "x_sign", "+=", "(", "1.0", "-", "tf", ".", "abs", "(", "x_sign", ")", ")", "\n", "x_abs", "=", "tf", ".", "abs", "(", "x", ")", "\n", "x_clipped", "=", "_clip_power_of_two", "(", "x_abs", ",", "self", ".", "_min_exp", ",", "self", ".", "_max_exp", ",", "\n", "self", ".", "max_value", ",", "\n", "self", ".", "quadratic_approximation", ",", "\n", "self", ".", "use_stochastic_rounding", ",", "\n", "self", ".", "log2_rounding", ")", "\n", "xq", "=", "x_sign", "*", "pow", "(", "2.0", ",", "x_clipped", ")", "\n", "\n", "if", "self", ".", "use_ste", ":", "\n", "      ", "return", "x", "+", "tf", ".", "stop_gradient", "(", "self", ".", "qnoise_factor", "*", "(", "-", "x", "+", "xq", ")", ")", "\n", "", "else", ":", "\n", "      ", "return", "(", "1", "-", "self", ".", "qnoise_factor", ")", "*", "x", "+", "tf", ".", "stop_gradient", "(", "\n", "self", ".", "qnoise_factor", "*", "xq", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_po2.max": [[2013, 2019], ["quantizers.quantized_po2.max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "", "def", "max", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get the maximum value that quantized_po2 can represent.\"\"\"", "\n", "if", "self", ".", "max_value", ":", "\n", "      ", "return", "max", "(", "1.0", ",", "self", ".", "max_value", ")", "\n", "", "else", ":", "\n", "      ", "return", "max", "(", "1.0", ",", "2", "**", "self", ".", "_max_exp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_po2.min": [[2020, 2026], ["quantizers.quantized_po2.max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "", "def", "min", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get the minimum value that quantized_po2 can represent.\"\"\"", "\n", "if", "self", ".", "max_value", ":", "\n", "      ", "return", "-", "max", "(", "1.0", ",", "self", ".", "max_value", ")", "\n", "", "else", ":", "\n", "      ", "return", "-", "max", "(", "1.0", ",", "2", "**", "self", ".", "_max_exp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_po2.from_config": [[2027, 2030], ["cls"], "methods", ["None"], ["", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "config", ")", ":", "\n", "    ", "return", "cls", "(", "**", "config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_po2.get_config": [[2031, 2062], ["isinstance", "quantizers.quantized_po2.qnoise_factor.numpy"], "methods", ["None"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "\"\"\"Gets configugration of the quantizer.\n\n    Returns:\n      A dict mapping quantization configuration, including\n        bits: bitwidth for exponents.\n        max_value: the maximum value of this quantized_po2 can represent.\n        use_stochastic_rounding:\n          if True, stochastic rounding is used.\n        quadratic_approximation:\n          if True, the exponent is enforced to be even number, which is\n          the closest one to x.\n        log2_rounding:\n          A string, Log2 rounding mode\n    \"\"\"", "\n", "config", "=", "{", "\n", "\"bits\"", ":", "\n", "self", ".", "bits", ",", "\n", "\"max_value\"", ":", "\n", "self", ".", "max_value", ",", "\n", "\"use_stochastic_rounding\"", ":", "\n", "self", ".", "use_stochastic_rounding", ",", "\n", "\"quadratic_approximation\"", ":", "\n", "self", ".", "quadratic_approximation", ",", "\n", "\"qnoise_factor\"", ":", "\n", "self", ".", "qnoise_factor", ".", "numpy", "(", ")", "if", "isinstance", "(", "\n", "self", ".", "qnoise_factor", ",", "tf", ".", "Variable", ")", "else", "self", ".", "qnoise_factor", ",", "\n", "\"log2_rounding\"", ":", "\n", "self", ".", "log2_rounding", "\n", "}", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.__init__": [[2090, 2124], ["quantizers.BaseQuantizer.__init__", "quantizers._need_exponent_sign_bit_check", "numpy.mod", "numpy.log2"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._need_exponent_sign_bit_check"], ["def", "__init__", "(", "self", ",", "\n", "bits", "=", "8", ",", "\n", "max_value", "=", "None", ",", "\n", "negative_slope", "=", "0", ",", "\n", "use_stochastic_rounding", "=", "False", ",", "\n", "quadratic_approximation", "=", "False", ",", "\n", "log2_rounding", "=", "\"rnd\"", ",", "\n", "qnoise_factor", "=", "1.0", ",", "\n", "var_name", "=", "None", ",", "\n", "use_ste", "=", "True", ",", "\n", "use_variables", "=", "False", ")", ":", "\n", "    ", "super", "(", "quantized_relu_po2", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "bits", "=", "bits", "\n", "self", ".", "max_value", "=", "max_value", "\n", "self", ".", "negative_slope", "=", "negative_slope", "\n", "self", ".", "use_stochastic_rounding", "=", "use_stochastic_rounding", "\n", "self", ".", "log2_rounding", "=", "log2_rounding", "\n", "# if True, round to the exponent for sqrt(x),", "\n", "# so that the return value can be divided by two without remainder.", "\n", "self", ".", "quadratic_approximation", "=", "quadratic_approximation", "\n", "need_exponent_sign_bit", "=", "_need_exponent_sign_bit_check", "(", "self", ".", "max_value", ")", "\n", "self", ".", "_min_exp", "=", "-", "2", "**", "(", "self", ".", "bits", "-", "need_exponent_sign_bit", ")", "\n", "self", ".", "_max_exp", "=", "2", "**", "(", "self", ".", "bits", "-", "need_exponent_sign_bit", ")", "-", "1", "\n", "if", "self", ".", "quadratic_approximation", ":", "\n", "      ", "self", ".", "_max_exp", "=", "2", "*", "(", "self", ".", "_max_exp", "//", "2", ")", "\n", "\n", "", "assert", "negative_slope", ">=", "0.0", "\n", "if", "negative_slope", "!=", "0", ":", "\n", "      ", "assert", "np", ".", "mod", "(", "np", ".", "log2", "(", "negative_slope", ")", ",", "1", ")", "==", "0", "\n", "# qnoise_factor related attributes", "\n", "", "self", ".", "qnoise_factor", "=", "qnoise_factor", "\n", "self", ".", "use_ste", "=", "use_ste", "\n", "self", ".", "var_name", "=", "var_name", "\n", "self", ".", "use_variables", "=", "use_variables", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.__str__": [[2125, 2137], ["str", "flags.append", "flags.append", "flags.append", "flags.append", "str", "str", "str", "int", "int", "str", "int"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "    ", "flags", "=", "[", "str", "(", "self", ".", "bits", ")", "]", "\n", "if", "self", ".", "max_value", "is", "not", "None", "or", "self", ".", "use_stochastic_rounding", ":", "\n", "      ", "flags", ".", "append", "(", "str", "(", "int", "(", "self", ".", "max_value", ")", ")", ")", "\n", "", "if", "self", ".", "negative_slope", ":", "\n", "      ", "flags", ".", "append", "(", "str", "(", "self", ".", "negative_slope", ")", ")", "\n", "", "if", "self", ".", "use_stochastic_rounding", ":", "\n", "      ", "flags", ".", "append", "(", "str", "(", "int", "(", "self", ".", "use_stochastic_rounding", ")", ")", ")", "\n", "", "if", "self", ".", "quadratic_approximation", ":", "\n", "      ", "flags", ".", "append", "(", "\n", "\"quadratic_approximation=\"", "+", "str", "(", "int", "(", "self", ".", "quadratic_approximation", ")", ")", ")", "\n", "", "return", "\"quantized_relu_po2(\"", "+", "\",\"", ".", "join", "(", "flags", ")", "+", "\")\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.__call__": [[2138, 2177], ["quantizers._clip_power_of_two", "quantizers._clip_power_of_two", "tensorflow.where", "tensorflow.where", "quantizers.quantized_relu_po2.build", "tensorflow.relu", "tensorflow.relu", "tensorflow.where", "tensorflow.where", "tensorflow.relu", "tensorflow.relu", "tensorflow.logical_or", "tensorflow.logical_or", "pow", "tensorflow.relu", "tensorflow.relu", "tensorflow.relu", "tensorflow.relu", "pow", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "tensorflow.ones_like", "tensorflow.ones_like"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._clip_power_of_two", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._clip_power_of_two", "home.repos.pwc.inspect_result.google_qkeras.networks.conv_block.ConvBlockNetwork.build"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "    ", "if", "not", "self", ".", "built", ":", "\n", "      ", "self", ".", "build", "(", "var_name", "=", "self", ".", "var_name", ",", "use_variables", "=", "self", ".", "use_variables", ")", "\n", "\n", "", "x_original", "=", "x", "\n", "\n", "if", "self", ".", "max_value", "is", "None", ":", "\n", "      ", "x", "=", "K", ".", "relu", "(", "x", ",", "self", ".", "negative_slope", ")", "\n", "", "else", ":", "\n", "      ", "x", "=", "tf", ".", "where", "(", "\n", "x", "<=", "self", ".", "max_value", ",", "\n", "K", ".", "relu", "(", "x", ",", "self", ".", "negative_slope", ")", ",", "\n", "tf", ".", "ones_like", "(", "x", ")", "*", "self", ".", "max_value", ")", "\n", "\n", "", "x_pos_clipped", "=", "_clip_power_of_two", "(", "\n", "K", ".", "relu", "(", "x_original", ")", ",", "\n", "self", ".", "_min_exp", ",", "self", ".", "_max_exp", ",", "\n", "self", ".", "max_value", ",", "\n", "self", ".", "quadratic_approximation", ",", "\n", "self", ".", "use_stochastic_rounding", ",", "\n", "self", ".", "log2_rounding", ")", "\n", "\n", "x_neg_clipped", "=", "_clip_power_of_two", "(", "\n", "K", ".", "relu", "(", "-", "x_original", ")", "*", "self", ".", "negative_slope", ",", "\n", "self", ".", "_min_exp", ",", "self", ".", "_max_exp", ",", "\n", "self", ".", "max_value", ",", "\n", "self", ".", "quadratic_approximation", ",", "\n", "self", ".", "use_stochastic_rounding", ",", "\n", "self", ".", "log2_rounding", ")", "\n", "\n", "xq", "=", "tf", ".", "where", "(", "\n", "tf", ".", "logical_or", "(", "x_original", ">=", "0.0", ",", "self", ".", "negative_slope", "==", "0.0", ")", ",", "\n", "pow", "(", "2.0", ",", "x_pos_clipped", ")", ",", "-", "pow", "(", "2.0", ",", "x_neg_clipped", ")", ")", "\n", "\n", "if", "self", ".", "use_ste", ":", "\n", "      ", "return", "x", "+", "tf", ".", "stop_gradient", "(", "self", ".", "qnoise_factor", "*", "(", "-", "x", "+", "xq", ")", ")", "\n", "", "else", ":", "\n", "      ", "return", "(", "1", "-", "self", ".", "qnoise_factor", ")", "*", "x", "+", "tf", ".", "stop_gradient", "(", "\n", "self", ".", "qnoise_factor", "*", "xq", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max": [[2178, 2184], ["quantizers.quantized_relu_po2.max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "", "def", "max", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get the maximum value that quantized_relu_po2 can represent.\"\"\"", "\n", "if", "self", ".", "max_value", ":", "\n", "      ", "return", "max", "(", "1.0", ",", "self", ".", "max_value", ")", "\n", "", "else", ":", "\n", "      ", "return", "max", "(", "1.0", ",", "2", "**", "self", ".", "_max_exp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.min": [[2185, 2195], ["quantizers.quantized_relu_po2.min"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min"], ["", "", "def", "min", "(", "self", ")", ":", "\n", "    ", "\"\"\"Get the minimum value that quantized_relu_po2 can represent.\"\"\"", "\n", "if", "self", ".", "negative_slope", "==", "0.0", ":", "\n", "      ", "return", "2", "**", "self", ".", "_min_exp", "\n", "\n", "", "unsigned_bits", "=", "self", ".", "bits", "-", "1", "\n", "if", "unsigned_bits", ">", "0", ":", "\n", "      ", "return", "min", "(", "2", "**", "self", ".", "_min_exp", ",", "-", "self", ".", "negative_slope", "*", "np", ".", "power", "(", "2.0", ",", "unsigned_bits", ")", ")", "\n", "", "else", ":", "\n", "      ", "return", "2", "**", "self", ".", "_min_exp", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.from_config": [[2196, 2199], ["cls"], "methods", ["None"], ["", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "config", ")", ":", "\n", "    ", "return", "cls", "(", "**", "config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.get_config": [[2200, 2235], ["isinstance", "quantizers.quantized_relu_po2.qnoise_factor.numpy"], "methods", ["None"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "\"\"\"Gets configugration of the quantizer.\n\n    Returns:\n      A dict mapping quantization configuration, including\n        bits: bitwidth for exponents.\n        max_value: the maximum value of this quantized_relu_po2 can represent.\n        use_stochastic_rounding:\n          if True, stochastic rounding is used.\n        quadratic_approximation:\n          if True, the exponent is enforced to be even number, which is\n          the closest one to x.\n        log2_rounding:\n          A string, Log2 rounding mode\n\n    \"\"\"", "\n", "\n", "config", "=", "{", "\n", "\"bits\"", ":", "\n", "self", ".", "bits", ",", "\n", "\"max_value\"", ":", "\n", "self", ".", "max_value", ",", "\n", "\"negative_slope\"", ":", "\n", "self", ".", "negative_slope", ",", "\n", "\"use_stochastic_rounding\"", ":", "\n", "self", ".", "use_stochastic_rounding", ",", "\n", "\"quadratic_approximation\"", ":", "\n", "self", ".", "quadratic_approximation", ",", "\n", "\"qnoise_factor\"", ":", "\n", "self", ".", "qnoise_factor", ".", "numpy", "(", ")", "if", "isinstance", "(", "\n", "self", ".", "qnoise_factor", ",", "tf", ".", "Variable", ")", "else", "self", ".", "qnoise_factor", ",", "\n", "\"log2_rounding\"", ":", "\n", "self", ".", "log2_rounding", "\n", "}", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.__init__": [[2278, 2306], ["quantizers.quantized_bits.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "\n", "bits", "=", "8", ",", "\n", "integer", "=", "0", ",", "\n", "symmetric", "=", "0", ",", "\n", "alpha", "=", "None", ",", "\n", "use_stochastic_rounding", "=", "False", ",", "\n", "scale_axis", "=", "None", ",", "\n", "qnoise_factor", "=", "1.0", ",", "\n", "var_name", "=", "None", ",", "\n", "use_ste", "=", "True", ",", "\n", "use_variables", "=", "False", ",", "\n", "relu_shift", ":", "int", "=", "3", ",", "\n", "relu_upper_bound", ":", "int", "=", "6", ")", ":", "\n", "    ", "super", "(", "quantized_hswish", ",", "self", ")", ".", "__init__", "(", "\n", "bits", "=", "bits", ",", "\n", "integer", "=", "integer", ",", "\n", "symmetric", "=", "symmetric", ",", "\n", "keep_negative", "=", "True", ",", "\n", "alpha", "=", "alpha", ",", "\n", "use_stochastic_rounding", "=", "use_stochastic_rounding", ",", "\n", "scale_axis", "=", "scale_axis", ",", "\n", "qnoise_factor", "=", "qnoise_factor", ",", "\n", "var_name", "=", "var_name", ",", "\n", "use_ste", "=", "use_ste", ",", "\n", "use_variables", "=", "use_variables", ")", "\n", "\n", "self", ".", "relu_shift", "=", "relu_shift", "\n", "self", ".", "relu_upper_bound", "=", "relu_upper_bound", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.__str__": [[2307, 2334], ["re.sub", "isinstance", "str", "str", "str", "flags.append", "str", "isinstance", "flags.append", "flags.append", "int", "str", "str", "isinstance", "quantizers.quantized_hswish.integer.numpy", "str", "int"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "    ", "\"\"\" Converts Tensors to printable strings.\"\"\"", "\n", "\n", "integer_bits", "=", "(", "\n", "re", ".", "sub", "(", "r\"\\[(\\d)\\]\"", ",", "r\"\\g<1>\"", ",", "\n", "str", "(", "self", ".", "integer", ".", "numpy", "(", ")", "if", "isinstance", "(", "self", ".", "integer", ",", "tf", ".", "Variable", ")", "\n", "else", "self", ".", "integer", ")", ")", ")", "\n", "assert", "isinstance", "(", "integer_bits", ",", "int", ")", "\n", "\n", "flags", "=", "[", "str", "(", "self", ".", "bits", ")", ",", "\n", "integer_bits", ",", "\n", "str", "(", "int", "(", "self", ".", "symmetric", ")", ")", ",", "\n", "\"relu_shift=\"", "+", "str", "(", "self", ".", "relu_shift", ")", ",", "\n", "\"relu_upper_bound=\"", "+", "str", "(", "self", ".", "relu_upper_bound", ")", "\n", "]", "\n", "\n", "if", "not", "self", ".", "keep_negative", ":", "\n", "      ", "flags", ".", "append", "(", "\"keep_negative=False\"", ")", "\n", "", "if", "self", ".", "alpha", ":", "\n", "      ", "alpha", "=", "str", "(", "self", ".", "alpha", ")", "\n", "if", "isinstance", "(", "self", ".", "alpha", ",", "six", ".", "string_types", ")", ":", "\n", "        ", "alpha", "=", "\"'\"", "+", "alpha", "+", "\"'\"", "\n", "", "flags", ".", "append", "(", "\"alpha=\"", "+", "alpha", ")", "\n", "", "if", "self", ".", "use_stochastic_rounding", ":", "\n", "      ", "flags", ".", "append", "(", "\"use_stochastic_rounding=\"", "+", "\n", "str", "(", "int", "(", "self", ".", "use_stochastic_rounding", ")", ")", ")", "\n", "", "return", "\"quantized_hswish(\"", "+", "\",\"", ".", "join", "(", "flags", ")", "+", "\")\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.__call__": [[2335, 2350], ["tensorflow.cast_to_floatx", "tensorflow.cast_to_floatx", "tensorflow.where", "tensorflow.where", "quantizers.quantized_bits.__call__", "tensorflow.relu", "tensorflow.relu", "tensorflow.math.multiply", "tensorflow.math.multiply", "tensorflow.ones_like", "tensorflow.ones_like"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.Clip.__call__"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "    ", "assert", "self", ".", "relu_upper_bound", ">", "0", ",", "(", "\n", "f\"relu_upper_bound must be a positive value, \"", "\n", "f\"found {self.relu_upper_bound} instead\"", ")", "\n", "assert", "self", ".", "relu_shift", ">", "0", ",", "(", "\n", "f\"relu_shift must be a positive value, \"", "\n", "f\"found {self.relu_shift} instead\"", ")", "\n", "x", "=", "K", ".", "cast_to_floatx", "(", "x", ")", "\n", "shift_x", "=", "x", "+", "self", ".", "relu_shift", "\n", "relu_x", "=", "tf", ".", "where", "(", "shift_x", "<=", "self", ".", "relu_upper_bound", ",", "\n", "K", ".", "relu", "(", "shift_x", ",", "alpha", "=", "False", ")", ",", "\n", "tf", ".", "ones_like", "(", "shift_x", ")", "*", "self", ".", "relu_upper_bound", ")", "\n", "\n", "hswish_x", "=", "tf", ".", "math", ".", "multiply", "(", "x", ",", "relu_x", ")", "/", "self", ".", "relu_upper_bound", "\n", "return", "super", "(", "quantized_hswish", ",", "self", ")", ".", "__call__", "(", "hswish_x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min": [[2351, 2368], ["quantizers.quantized_bits.min", "super().call"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.call"], ["", "def", "min", "(", "self", ")", ":", "\n", "    ", "\"\"\"Gets the minimum value that quantized_hswish can represent.\"\"\"", "\n", "\n", "# get the minimum value that the number of bits can represent", "\n", "min_quant", "=", "super", "(", "quantized_hswish", ",", "self", ")", ".", "min", "(", ")", "\n", "# In the negative end, the hswish function becomes", "\n", "# x * (x + relu_shift) / relu_upper_bound", "\n", "# the min value of this parabolic function is", "\n", "# - relu_shift^2 / (4 * relu_upper_bound)", "\n", "denom", "=", "4", "*", "self", ".", "relu_upper_bound", "\n", "min_parabolic", "=", "-", "self", ".", "relu_shift", "*", "self", ".", "relu_shift", "/", "denom", "\n", "\n", "if", "min_quant", ">=", "min_parabolic", ":", "\n", "      ", "return", "min_quant", "\n", "\n", "# get the quantized value of min_parabolic", "\n", "", "return", "super", "(", "quantized_hswish", ",", "self", ")", ".", "call", "(", "min_parabolic", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.get_config": [[2369, 2382], ["quantizers.quantized_bits.get_config", "dict", "list", "list", "super().get_config.items", "config.items"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "\"\"\"Add relu_shift and relu_upper_bound to the config file.\"\"\"", "\n", "\n", "base_config", "=", "super", "(", "quantized_hswish", ",", "self", ")", ".", "get_config", "(", ")", "\n", "\n", "config", "=", "{", "\n", "\"relu_shift\"", ":", "self", ".", "relu_shift", ",", "\n", "\"relu_upper_bound\"", ":", "self", ".", "relu_upper_bound", "\n", "}", "\n", "\n", "out_config", "=", "dict", "(", "\n", "list", "(", "base_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "return", "out_config", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_weight_scale": [[38, 52], ["hasattr", "tensorflow.eval"], "function", ["None"], ["def", "get_weight_scale", "(", "quantizer", ",", "x", "=", "None", ")", ":", "\n", "  ", "\"\"\"Gets the scales of weights for (stochastic_)binary and ternary quantizers.\n\n  Arguments:\n    quantizer: A binary or teneray quantizer class.\n    x: A weight tensor.  We keep it here for now for backward compatibility.\n\n  Returns:\n    Weight scale per channel for binary and ternary\n    quantizers with auto or auto_po2 alpha/threshold.\n  \"\"\"", "\n", "if", "hasattr", "(", "quantizer", ",", "\"scale\"", ")", "and", "quantizer", ".", "scale", "is", "not", "None", ":", "\n", "    ", "return", "K", ".", "eval", "(", "quantizer", ".", "scale", ")", "\n", "", "return", "1.0", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_integer_bits": [[54, 120], ["tensorflow.cast", "tensorflow.minimum", "tensorflow.maximum", "tensorflow.maximum", "tensorflow.log", "numpy.log", "tensorflow.log", "numpy.log", "tensorflow.math.round", "tensorflow.math.round", "tensorflow.math.ceil", "tensorflow.math.ceil", "tensorflow.where", "tensorflow.maximum", "tensorflow.abs", "tensorflow.abs", "tensorflow.where", "tensorflow.where", "tensorflow.where", "tensorflow.where", "pow", "pow", "tensorflow.where", "tensorflow.minimum", "pow", "pow", "tensorflow.minimum"], "function", ["None"], ["", "def", "_get_integer_bits", "(", "min_value", ",", "\n", "max_value", ",", "\n", "bits", "=", "8", ",", "\n", "symmetric", "=", "False", ",", "\n", "keep_negative", "=", "False", ",", "\n", "is_clipping", "=", "True", ")", ":", "\n", "  ", "\"\"\"Estimates the integer bit(number of bits to the left of the binary point)\n  satisfying the input argument constraints.\n\n  Args:\n    min_value: A tensor object. Its elements are in float representing the\n      minimum values of ranges.\n    max_value: A tensor object. Its elements are in float representing the\n      maximum values of ranges.\n    bits: number of bits to perform quantization.\n    symmetric: boolean type. if true, it enforces negative and positive ranges\n      to be symmetric.\n    keep_negative: boolean type. if true, we do not clip negative numbers.\n    is_clipping: boolean type. if true, the min_value and max_value are clipped\n      to nearest powers-of-2.\n\n  Returns:\n    integer_bits : number of bits to the left of the binary point.\n  \"\"\"", "\n", "# Max the min and max values positive if only using positive values", "\n", "if", "not", "keep_negative", ":", "\n", "    ", "min_value", "=", "K", ".", "maximum", "(", "min_value", ",", "0", ")", "\n", "max_value", "=", "K", ".", "maximum", "(", "max_value", ",", "0", ")", "\n", "\n", "# The number of bits excluding the sign bit", "\n", "", "unsigned_bits", "=", "bits", "-", "keep_negative", "\n", "\n", "# log2 of absolute min_value and max_value", "\n", "min_value_log2", "=", "K", ".", "log", "(", "K", ".", "abs", "(", "min_value", ")", ")", "/", "np", ".", "log", "(", "2.0", ")", "\n", "max_value_log2", "=", "K", ".", "log", "(", "K", ".", "abs", "(", "max_value", ")", ")", "/", "np", ".", "log", "(", "2.0", ")", "\n", "\n", "# Estimate integer_bits", "\n", "if", "is_clipping", ":", "\n", "    ", "min_int_bits", "=", "tf", ".", "math", ".", "round", "(", "\n", "tf", ".", "where", "(", "min_value_log2", ">", "0", ",", "min_value_log2", ",", "0", ")", ")", "\n", "max_int_bits", "=", "tf", ".", "math", ".", "round", "(", "\n", "tf", ".", "where", "(", "max_value_log2", ">", "0", ",", "max_value_log2", ",", "0", ")", ")", "\n", "", "else", ":", "\n", "    ", "min_int_bits", "=", "tf", ".", "math", ".", "ceil", "(", "tf", ".", "where", "(", "min_value_log2", ">", "0", ",", "min_value_log2", ",", "0", ")", ")", "\n", "max_int_bits", "=", "tf", ".", "math", ".", "ceil", "(", "tf", ".", "where", "(", "max_value_log2", ">", "0", ",", "max_value_log2", ",", "0", ")", ")", "\n", "# Checks max_value is bounded by the maximum positive value of", "\n", "# pow(2,integer_bits) - pow(2,-fractional_bits).", "\n", "max_value_po2", "=", "pow", "(", "2.0", ",", "max_int_bits", ")", "-", "pow", "(", "\n", "2.0", ",", "K", ".", "minimum", "(", "max_int_bits", "-", "unsigned_bits", ",", "0", ")", ")", "\n", "max_int_bits", "=", "tf", ".", "where", "(", "max_value", "<=", "max_value_po2", ",", "max_int_bits", ",", "\n", "max_int_bits", "+", "1", ")", "\n", "if", "symmetric", ":", "\n", "# Checks min_value is bounded by the minimum negative value of", "\n", "# - pow(2,integer_bits) + pow(2,-fractional_bits).", "\n", "      ", "min_value_po2", "=", "-", "pow", "(", "2.0", ",", "min_int_bits", ")", "+", "pow", "(", "\n", "2.0", ",", "K", ".", "minimum", "(", "min_int_bits", "-", "unsigned_bits", ",", "0", ")", ")", "\n", "min_int_bits", "=", "tf", ".", "where", "(", "min_value_po2", "<=", "min_value", ",", "min_int_bits", ",", "\n", "min_int_bits", "+", "1", ")", "\n", "\n", "# To cover both negative and positive ranges with integer_bits.", "\n", "# (For keep_negative=False, min_int_bits is 0.)", "\n", "", "", "integer_bits", "=", "tf", ".", "cast", "(", "K", ".", "maximum", "(", "min_int_bits", ",", "max_int_bits", ")", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "# It assumes that integer_bits cannot be greater than unsigned_bits", "\n", "integer_bits", "=", "K", ".", "minimum", "(", "unsigned_bits", ",", "integer_bits", ")", "\n", "\n", "return", "integer_bits", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_scaling_axis": [[122, 134], ["list", "list", "six.moves.range", "six.moves.range", "tensorflow.image_data_format", "list", "list", "six.moves.range", "six.moves.range"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "_get_scaling_axis", "(", "scale_axis", ",", "len_axis", ")", ":", "\n", "  ", "\"\"\"Get the axis to perform auto scaling with.\"\"\"", "\n", "\n", "if", "scale_axis", "is", "not", "None", ":", "\n", "    ", "axis", "=", "list", "(", "range", "(", "scale_axis", ")", ")", "\n", "axis", "+=", "list", "(", "range", "(", "scale_axis", "+", "1", ",", "len_axis", ")", ")", "\n", "", "else", ":", "\n", "    ", "if", "K", ".", "image_data_format", "(", ")", "==", "\"channels_last\"", ":", "\n", "      ", "axis", "=", "list", "(", "range", "(", "len_axis", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "      ", "axis", "=", "list", "(", "range", "(", "1", ",", "len_axis", ")", ")", "\n", "", "", "return", "axis", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_scale": [[136, 190], ["isinstance", "len", "x.shape.as_list", "tensorflow.mean", "tensorflow.mean", "tensorflow.pow", "isinstance", "list", "quantizers._get_scaling_axis", "tensorflow.mean", "tensorflow.mean", "tensorflow.epsilon", "tensorflow.math.round", "float", "tensorflow.math.multiply", "tensorflow.math.multiply", "tensorflow.log", "numpy.log", "tensorflow.epsilon"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_scaling_axis"], ["", "def", "_get_scale", "(", "alpha", ",", "x", ",", "q", ",", "scale_axis", "=", "None", ",", "per_channel_scale", "=", "True", ")", ":", "\n", "  ", "\"\"\"Gets scaling factor for scaling the tensor per channel.\n  It uses the least squares method to find the scaling factor.\n\n  (https://en.wikipedia.org/wiki/Linear_least_squares)\n\n  Arguments:\n    alpha: A float or string. When it is string, it should be either \"auto\" or\n      \"auto_po2\", and scale = sum(x * q, axis=all but last) / sum(q * q,\n      axis=all but last)\n     x: A tensor object. Its elements are in float.\n     q: A tensor object. Its elements are in quantized format of x.\n     scale_axis: which axis to calculate scale from\n     per_channel_scale: A bool. Whether to perform per-channel scaling or not.\n\n  Returns:\n    A scaling factor tensor or scalar for scaling tensor per channel.\n  \"\"\"", "\n", "\n", "if", "isinstance", "(", "alpha", ",", "six", ".", "string_types", ")", "and", "\"auto\"", "in", "alpha", ":", "\n", "    ", "assert", "alpha", "in", "[", "\"auto\"", ",", "\"auto_po2\"", "]", "\n", "# in different tensorflow version (e.g., 2.4)", "\n", "# x.shape is a tuple which doesn't have as_list() method", "\n", "try", ":", "\n", "      ", "x_shape", "=", "x", ".", "shape", ".", "as_list", "(", ")", "\n", "", "except", "AttributeError", ":", "\n", "      ", "x_shape", "=", "list", "(", "x", ".", "shape", ")", "\n", "\n", "", "len_axis", "=", "len", "(", "x_shape", ")", "\n", "if", "not", "per_channel_scale", ":", "\n", "      ", "qx", "=", "K", ".", "mean", "(", "x", "*", "q", ",", "keepdims", "=", "True", ")", "\n", "qq", "=", "K", ".", "mean", "(", "q", "*", "q", ",", "keepdims", "=", "True", ")", "\n", "", "else", ":", "\n", "      ", "if", "len_axis", ">", "1", ":", "\n", "        ", "axis", "=", "_get_scaling_axis", "(", "scale_axis", ",", "len_axis", ")", "\n", "qx", "=", "K", ".", "mean", "(", "tf", ".", "math", ".", "multiply", "(", "x", ",", "q", ")", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", "\n", "qq", "=", "K", ".", "mean", "(", "tf", ".", "math", ".", "multiply", "(", "q", ",", "q", ")", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", "\n", "", "else", ":", "\n", "# No summing (averaging) along the channel axis to get per-channel", "\n", "# scales.", "\n", "        ", "qx", "=", "x", "*", "q", "\n", "qq", "=", "q", "*", "q", "\n", "\n", "", "", "scale", "=", "qx", "/", "(", "qq", "+", "K", ".", "epsilon", "(", ")", ")", "\n", "if", "alpha", "==", "\"auto_po2\"", ":", "\n", "      ", "scale", "=", "K", ".", "pow", "(", "2.0", ",", "\n", "tf", ".", "math", ".", "round", "(", "K", ".", "log", "(", "scale", "+", "K", ".", "epsilon", "(", ")", ")", "/", "np", ".", "log", "(", "2.0", ")", ")", ")", "\n", "", "", "elif", "alpha", "is", "None", ":", "\n", "    ", "scale", "=", "1.0", "\n", "", "elif", "isinstance", "(", "alpha", ",", "np", ".", "ndarray", ")", ":", "\n", "    ", "scale", "=", "alpha", "\n", "", "else", ":", "\n", "    ", "scale", "=", "float", "(", "alpha", ")", "\n", "", "return", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.smooth_sigmoid": [[192, 200], ["tensorflow.keras.backend.clip"], "function", ["None"], ["", "def", "smooth_sigmoid", "(", "x", ")", ":", "\n", "  ", "\"\"\"Implements a linear approximation of a sigmoid function.\"\"\"", "\n", "\n", "# if we use 2.65 as the clipping point, MSE w.r.t. original sigmoid is", "\n", "# smaller than hard_simoid but the arithmetic for it is (x >> 3) +", "\n", "# (x >> 4) + 0.5, which is also not bad.", "\n", "\n", "return", "tf", ".", "keras", ".", "backend", ".", "clip", "(", "0.1875", "*", "x", "+", "0.5", ",", "0.0", ",", "1.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.hard_sigmoid": [[202, 206], ["tensorflow.keras.backend.clip"], "function", ["None"], ["", "def", "hard_sigmoid", "(", "x", ")", ":", "\n", "  ", "\"\"\"Computes hard_sigmoid function that saturates between 0 and 1.\"\"\"", "\n", "\n", "return", "tf", ".", "keras", ".", "backend", ".", "clip", "(", "0.5", "*", "x", "+", "0.5", ",", "0.0", ",", "1.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.binary_sigmoid": [[208, 212], ["quantizers._round_through", "quantizers.hard_sigmoid"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._round_through", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.hard_sigmoid"], ["", "def", "binary_sigmoid", "(", "x", ")", ":", "\n", "  ", "\"\"\"Computes binary_sigmoid.\"\"\"", "\n", "\n", "return", "_round_through", "(", "hard_sigmoid", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.set_internal_sigmoid": [[221, 235], ["ValueError"], "function", ["None"], ["def", "set_internal_sigmoid", "(", "mode", ")", ":", "\n", "  ", "\"\"\"Sets _sigmoid to either real, hard or smooth.\"\"\"", "\n", "\n", "global", "_sigmoid", "\n", "\n", "if", "mode", "not", "in", "[", "\"real\"", ",", "\"hard\"", ",", "\"smooth\"", "]", ":", "\n", "    ", "raise", "ValueError", "(", "\"mode has to be 'real', 'hard' or 'smooth'.\"", ")", "\n", "\n", "", "if", "mode", "==", "\"hard\"", ":", "\n", "    ", "_sigmoid", "=", "hard_sigmoid", "\n", "", "elif", "mode", "==", "\"smooth\"", ":", "\n", "    ", "_sigmoid", "=", "smooth_sigmoid", "\n", "", "elif", "mode", "==", "\"real\"", ":", "\n", "    ", "_sigmoid", "=", "tf", ".", "keras", ".", "backend", ".", "sigmoid", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.binary_tanh": [[240, 243], ["quantizers.binary_sigmoid"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.binary_sigmoid"], ["def", "binary_tanh", "(", "x", ")", ":", "\n", "  ", "\"\"\"Computes binary_tanh function that outputs -1 and 1.\"\"\"", "\n", "return", "2.0", "*", "binary_sigmoid", "(", "x", ")", "-", "1.0", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.hard_tanh": [[245, 248], ["quantizers.hard_sigmoid"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.hard_sigmoid"], ["", "def", "hard_tanh", "(", "x", ")", ":", "\n", "  ", "\"\"\"Computes hard_tanh function that saturates between -1 and 1.\"\"\"", "\n", "return", "2.0", "*", "hard_sigmoid", "(", "x", ")", "-", "1.0", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.smooth_tanh": [[250, 253], ["quantizers.smooth_sigmoid"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.smooth_sigmoid"], ["", "def", "smooth_tanh", "(", "x", ")", ":", "\n", "  ", "\"\"\"Computes smooth_tanh function that saturates between -1 and 1.\"\"\"", "\n", "return", "2.0", "*", "smooth_sigmoid", "(", "x", ")", "-", "1.0", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_round": [[255, 264], ["tensorflow.where", "tensorflow.floor", "tensorflow.math.floor", "tensorflow.math.ceil", "tensorflow.random.uniform", "tensorflow.shape"], "function", ["None"], ["", "def", "stochastic_round", "(", "x", ",", "precision", "=", "0.5", ")", ":", "\n", "  ", "\"\"\"Performs stochastic rounding to the first decimal point.\"\"\"", "\n", "scale", "=", "1.0", "/", "precision", "\n", "scale_x", "=", "x", "*", "scale", "\n", "fraction", "=", "scale_x", "-", "tf", ".", "floor", "(", "scale_x", ")", "\n", "\n", "result", "=", "tf", ".", "where", "(", "fraction", "<", "tf", ".", "random", ".", "uniform", "(", "tf", ".", "shape", "(", "x", ")", ")", ",", "\n", "tf", ".", "math", ".", "floor", "(", "scale_x", ")", ",", "tf", ".", "math", ".", "ceil", "(", "scale_x", ")", ")", "\n", "return", "result", "/", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_round_po2": [[266, 294], ["tensorflow.abs", "tensorflow.keras.backend.epsilon", "tensorflow.keras.backend.log", "tensorflow.round", "tensorflow.cast", "tensorflow.where", "tensorflow.where", "tensorflow.random.uniform", "tensorflow.where", "pow", "tensorflow.shape", "tensorflow.keras.backend.log", "tensorflow.cast"], "function", ["None"], ["", "def", "stochastic_round_po2", "(", "x", ")", ":", "\n", "  ", "\"\"\"Performs stochastic rounding for the power of two.\"\"\"", "\n", "# TODO(hzhuang): test stochastic_round_po2 and constraint.", "\n", "# because quantizer is applied after constraint.", "\n", "y", "=", "tf", ".", "abs", "(", "x", ")", "\n", "eps", "=", "tf", ".", "keras", ".", "backend", ".", "epsilon", "(", ")", "\n", "log2", "=", "tf", ".", "keras", ".", "backend", ".", "log", "(", "2.0", ")", "\n", "\n", "x_log2", "=", "tf", ".", "round", "(", "tf", ".", "keras", ".", "backend", ".", "log", "(", "y", "+", "eps", ")", "/", "log2", ")", "\n", "po2", "=", "tf", ".", "cast", "(", "pow", "(", "2.0", ",", "tf", ".", "cast", "(", "x_log2", ",", "dtype", "=", "\"float32\"", ")", ")", ",", "dtype", "=", "\"float32\"", ")", "\n", "left_val", "=", "tf", ".", "where", "(", "po2", ">", "y", ",", "x_log2", "-", "1", ",", "x_log2", ")", "\n", "right_val", "=", "tf", ".", "where", "(", "po2", ">", "y", ",", "x_log2", ",", "x_log2", "+", "1", ")", "\n", "# sampling in [2**left_val, 2**right_val].", "\n", "minval", "=", "2", "**", "left_val", "\n", "maxval", "=", "2", "**", "right_val", "\n", "val", "=", "tf", ".", "random", ".", "uniform", "(", "tf", ".", "shape", "(", "y", ")", ",", "minval", "=", "minval", ",", "maxval", "=", "maxval", ")", "\n", "# use y as a threshold to keep the probabliy [2**left_val, y, 2**right_val]", "\n", "# so that the mean value of the sample should be y", "\n", "x_po2", "=", "tf", ".", "where", "(", "y", "<", "val", ",", "left_val", ",", "right_val", ")", "\n", "\"\"\"\n  x_log2 = stochastic_round(tf.keras.backend.log(y + eps) / log2)\n  sign = tf.sign(x)\n  po2 = (\n      tf.sign(x) *\n      tf.cast(pow(2.0, tf.cast(x_log2, dtype=\"float32\")), dtype=\"float32\")\n  )\n  \"\"\"", "\n", "return", "x_po2", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._round_through": [[296, 329], ["tensorflow.python.framework.smart_cond.smart_cond", "tensorflow.learning_phase", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "tensorflow.round", "quantizers.stochastic_round", "tensorflow.round"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_round"], ["", "def", "_round_through", "(", "x", ",", "use_stochastic_rounding", "=", "False", ",", "precision", "=", "0.5", ")", ":", "\n", "  ", "\"\"\"Rounds x but using straight through estimator.\n\n  We use the trick from [Sergey Ioffe](http://stackoverflow.com/a/36480182).\n\n  Straight through estimator is a biased estimator for the rounding\n  operation defined by Hinton\"s Coursera Lecture 9c where dL/dx is made\n  equal to dL/dy for y = f(x) during gradient computation, where f(x) is\n  a non-derivable function. In that case, we assume df/dx = 1 in:\n\n  dL   dL df   dL\n  -- = -- -- = --\n  dx   df dx   dy\n\n  (https://www.youtube.com/watch?v=LN0xtUuJsEI&list=PLoRl3Ht4JOcdU872GhiYWf6jwrk_SNhz9&index=41)\n\n  Arguments:\n    x: tensor to perform round operation with straight through gradient.\n    use_stochastic_rounding: if true, we perform stochastic rounding.\n    precision: by default we will use 0.5 as precision, but that can overriden\n      by the user.\n\n  Returns:\n    Rounded tensor.\n  \"\"\"", "\n", "if", "use_stochastic_rounding", ":", "\n", "    ", "output", "=", "tf_utils", ".", "smart_cond", "(", "\n", "K", ".", "learning_phase", "(", ")", ",", "\n", "lambda", ":", "x", "+", "tf", ".", "stop_gradient", "(", "-", "x", "+", "stochastic_round", "(", "x", ",", "precision", ")", ")", ",", "\n", "lambda", ":", "x", "+", "tf", ".", "stop_gradient", "(", "-", "x", "+", "tf", ".", "round", "(", "x", ")", ")", ")", "\n", "", "else", ":", "\n", "    ", "output", "=", "x", "+", "tf", ".", "stop_gradient", "(", "-", "x", "+", "tf", ".", "round", "(", "x", ")", ")", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._sign_through": [[331, 340], ["tensorflow.sign", "tensorflow.stop_gradient"], "function", ["None"], ["", "def", "_sign_through", "(", "x", ")", ":", "\n", "  ", "\"\"\"Computes the sign operation using the straight through estimator.\"\"\"", "\n", "\n", "# tf.sign generates -1, 0 or +1, so it should not be used when we attempt", "\n", "# to generate -1 and +1.", "\n", "\n", "k_sign", "=", "tf", ".", "sign", "(", "x", ")", "\n", "\n", "return", "x", "+", "tf", ".", "stop_gradient", "(", "-", "x", "+", "k_sign", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._ceil_through": [[342, 346], ["tensorflow.stop_gradient", "tensorflow.ceil"], "function", ["None"], ["", "def", "_ceil_through", "(", "x", ")", ":", "\n", "  ", "\"\"\"Computes the ceiling operation using straight through estimator.\"\"\"", "\n", "\n", "return", "x", "+", "tf", ".", "stop_gradient", "(", "-", "x", "+", "tf", ".", "ceil", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._floor_through": [[348, 352], ["tensorflow.stop_gradient", "tensorflow.floor"], "function", ["None"], ["", "def", "_floor_through", "(", "x", ")", ":", "\n", "  ", "\"\"\"Computes the floor operation using straight through estimator.\"\"\"", "\n", "\n", "return", "x", "+", "tf", ".", "stop_gradient", "(", "-", "x", "+", "tf", ".", "floor", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._create_variable_name": [[354, 371], ["str", "tensorflow.get_uid"], "function", ["None"], ["", "def", "_create_variable_name", "(", "attr_name", ",", "var_name", "=", "None", ")", ":", "\n", "  ", "\"\"\"Creates variable name.\n  Arguments:\n    attr_name: string. attribute name\n    var_name: string. variable name\n\n  Returns:\n    string. variable name\n  \"\"\"", "\n", "\n", "if", "var_name", ":", "\n", "    ", "return", "var_name", "+", "\"/\"", "+", "attr_name", "\n", "\n", "# This naming scheme is to solve a problem of a layer having more than", "\n", "# one quantizer can have multiple qnoise_factor variables with the same", "\n", "# name of \"qnoise_factor\".", "\n", "", "return", "attr_name", "+", "\"_\"", "+", "str", "(", "K", ".", "get_uid", "(", "attr_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._clip_power_of_two": [[1805, 1875], ["numpy.log", "tensorflow.keras.backend.epsilon", "tensorflow.where", "tensorflow.where", "tensorflow.where", "quantizers._clip_power_of_two.power_of_two_clip"], "function", ["None"], ["", "", "def", "_clip_power_of_two", "(", "x_abs", ",", "\n", "min_exp", ",", "\n", "max_exp", ",", "\n", "max_value", ",", "\n", "quadratic_approximation", "=", "False", ",", "\n", "use_stochastic_rounding", "=", "False", ",", "\n", "log2_rounding", "=", "\"rnd\"", ")", ":", "\n", "  ", "\"\"\"Clips a tensor using power-of-two quantizer.\n\n\n  Args:\n    x_abs: A tensor object. Its elements should be non-negative.\n    min_exp: An integer representing the smallest exponent.\n    max_exp: An integer representing the largest exponent.\n    max_value: A float or None. If it is None, we clip the value to max_value.\n    quadratic_approximation: An boolean representing whether the quadratic\n      approximation is applied.\n    use_stochastic_rounding: An boolean representing whether the stochastic\n      rounding method is applied.\n    log2_rounding: log2 rounding mode. \"rnd\" and \"floor\" currently\n      supported, corresponding to tf.round and tf.floor respectively.\n\n  Returns:\n    A tensor object, the values are clipped by min_exp and max_exp.\n  \"\"\"", "\n", "\n", "# if quadratic_approximation is True, round to the exponent for sqrt(x),", "\n", "# so that the return value can be divided by two without remainder.", "\n", "log2", "=", "np", ".", "log", "(", "2.0", ")", "\n", "\n", "# When the elements of x_abs are small than the keras epsilon,", "\n", "# we just overwrite x_abs with eps", "\n", "eps", "=", "tf", ".", "keras", ".", "backend", ".", "epsilon", "(", ")", "\n", "x_filter", "=", "tf", ".", "where", "(", "x_abs", "<", "eps", ",", "eps", ",", "x_abs", ")", "\n", "if", "max_value", "is", "not", "None", ":", "\n", "# If the elements of x_filter has value larger than x_value, clip it.", "\n", "    ", "x_filter", "=", "tf", ".", "where", "(", "x_filter", ">=", "max_value", ",", "\n", "tf", ".", "ones_like", "(", "x_filter", ")", "*", "max_value", ",", "x_filter", ")", "\n", "\n", "", "def", "power_of_two_clip", "(", "x_abs", ",", "min_exp", ",", "max_exp", ",", "quadratic_approximation", ",", "\n", "use_stochastic_rounding", ",", "log2_rounding", ")", ":", "\n", "    ", "assert", "log2_rounding", "in", "[", "\"rnd\"", ",", "\"floor\"", "]", "\n", "\n", "if", "quadratic_approximation", ":", "\n", "      ", "q_factor", "=", "2.0", "\n", "x_input", "=", "tf", ".", "sqrt", "(", "x_abs", ")", "\n", "", "else", ":", "\n", "      ", "q_factor", "=", "1.0", "\n", "x_input", "=", "x_abs", "\n", "\n", "", "if", "log2_rounding", "==", "\"floor\"", ":", "\n", "      ", "x_log2", "=", "_floor_through", "(", "tf", ".", "keras", ".", "backend", ".", "log", "(", "x_input", ")", "/", "log2", ")", "\n", "", "elif", "use_stochastic_rounding", ":", "\n", "      ", "x_log2", "=", "tf_utils", ".", "smart_cond", "(", "\n", "K", ".", "learning_phase", "(", ")", ",", "\n", "lambda", ":", "stochastic_round_po2", "(", "x_input", ")", ",", "\n", "lambda", ":", "_round_through", "(", "tf", ".", "keras", ".", "backend", ".", "log", "(", "x_input", ")", "/", "log2", ")", ")", "\n", "", "else", ":", "\n", "      ", "x_log2", "=", "_round_through", "(", "tf", ".", "keras", ".", "backend", ".", "log", "(", "x_input", ")", "/", "log2", ")", "\n", "\n", "", "x_clipped", "=", "q_factor", "*", "tf", ".", "keras", ".", "backend", ".", "clip", "(", "x_log2", ",", "min_exp", ",", "max_exp", ")", "\n", "return", "x_clipped", "\n", "\n", "", "x_clipped", "=", "tf", ".", "where", "(", "\n", "x_abs", "<", "eps", ",", "\n", "tf", ".", "ones_like", "(", "x_abs", ")", "*", "min_exp", ",", "\n", "power_of_two_clip", "(", "x_filter", ",", "min_exp", ",", "max_exp", ",", "quadratic_approximation", ",", "\n", "use_stochastic_rounding", ",", "log2_rounding", ")", ")", "\n", "\n", "return", "x_clipped", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._need_exponent_sign_bit_check": [[1877, 1904], ["ValueError"], "function", ["None"], ["", "def", "_need_exponent_sign_bit_check", "(", "max_value", ")", ":", "\n", "  ", "\"\"\"Checks whether the sign bit of exponent is needed.\n\n  This is used by quantized_po2 and quantized_relu_po2.\n\n  Args:\n    max_value: the maximum value allowed.\n\n  Returns:\n    An integer. 1: sign_bit is needed. 0: sign_bit is not needed.\n  \"\"\"", "\n", "\n", "if", "max_value", "is", "not", "None", ":", "\n", "    ", "if", "max_value", "<", "0", ":", "\n", "      ", "raise", "ValueError", "(", "\"po2 max_value should be non-negative.\"", ")", "\n", "", "if", "max_value", ">", "1", ":", "\n", "# if max_value is larger than 1,", "\n", "#   the exponent could be positive and negative.", "\n", "#   e.g., log(max_value) > 0 when max_value > 1", "\n", "      ", "need_exponent_sign_bit", "=", "1", "\n", "", "else", ":", "\n", "      ", "need_exponent_sign_bit", "=", "0", "\n", "", "", "else", ":", "\n", "# max_value is not specified, so we cannot decide the range.", "\n", "# Then we need to put sign_bit for exponent to be safe", "\n", "    ", "need_exponent_sign_bit", "=", "1", "\n", "", "return", "need_exponent_sign_bit", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_min_max_exponents": [[1906, 1926], ["None"], "function", ["None"], ["", "def", "_get_min_max_exponents", "(", "non_sign_bits", ",", "need_exponent_sign_bit", ",", "\n", "quadratic_approximation", ")", ":", "\n", "  ", "\"\"\"Given a bitwidth, gets min and max exponents that it can represent.\n\n  Args:\n    non_sign_bits: An integer representing the bitwidth of the exponent.\n    need_exponent_sign_bit: An integer representing whether it needs sign bit\n      in exponent. (1: need sign bit. 0: sign bit is not needed.)\n    quadratic_approximation: A boolean representing whether the quadratic\n      approximiation method is enforced.\n\n  Returns:\n    A tuple of integers: min_exp, max_exp\n  \"\"\"", "\n", "effect_bits", "=", "non_sign_bits", "-", "need_exponent_sign_bit", "\n", "min_exp", "=", "-", "2", "**", "(", "effect_bits", ")", "\n", "max_exp", "=", "2", "**", "(", "effect_bits", ")", "-", "1", "\n", "if", "quadratic_approximation", ":", "\n", "    ", "max_exp", "=", "2", "*", "(", "max_exp", "//", "2", ")", "\n", "", "return", "min_exp", ",", "max_exp", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer": [[2384, 2413], ["isinstance", "tensorflow.keras.utils.deserialize_keras_object", "isinstance", "safe_eval.safe_eval", "callable", "globals", "globals", "ValueError", "str"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.safe_eval"], ["", "", "def", "get_quantizer", "(", "identifier", ")", ":", "\n", "  ", "\"\"\"Gets the quantizer.\n\n  Args:\n    identifier: An quantizer, which could be dict, string, or callable function.\n\n  Returns:\n    A quantizer class or quantization function from this file. For example,\n      Quantizer classes: quantized_bits, quantized_po2, quantized_relu_po2,\n      binary, stochastic_binary, ternary, stochastic_ternary, etc.\n\n      Quantization functions: binary_sigmoid, hard_sigmoid, soft_sigmoid, etc.\n\n  Raises:\n    ValueError: An error occurred when quantizer cannot be interpreted.\n  \"\"\"", "\n", "\n", "if", "identifier", "is", "None", ":", "\n", "    ", "return", "None", "\n", "", "if", "isinstance", "(", "identifier", ",", "dict", ")", ":", "\n", "    ", "return", "deserialize_keras_object", "(", "\n", "identifier", ",", "module_objects", "=", "globals", "(", ")", ",", "printable_module_name", "=", "\"quantizer\"", ")", "\n", "", "elif", "isinstance", "(", "identifier", ",", "six", ".", "string_types", ")", ":", "\n", "    ", "return", "safe_eval", "(", "identifier", ",", "globals", "(", ")", ")", "\n", "", "elif", "callable", "(", "identifier", ")", ":", "\n", "    ", "return", "identifier", "\n", "", "else", ":", "\n", "    ", "raise", "ValueError", "(", "\"Could not interpret quantizer identifier: \"", "+", "\n", "str", "(", "identifier", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantized_initializer": [[2415, 2436], ["isinstance", "tensorflow.keras.initializers.VarianceScaling", "tensorflow.keras.initializers.VarianceScaling", "tensorflow.keras.initializers.VarianceScaling", "tensorflow.keras.initializers.VarianceScaling", "tensorflow.keras.initializers.RandomUniform"], "function", ["None"], ["", "", "def", "get_quantized_initializer", "(", "w_initializer", ",", "w_range", ")", ":", "\n", "  ", "\"\"\"Gets the initializer and scales it by the range.\"\"\"", "\n", "\n", "if", "isinstance", "(", "w_initializer", ",", "six", ".", "string_types", ")", ":", "\n", "\n", "    ", "if", "w_initializer", "==", "\"he_normal\"", ":", "\n", "      ", "return", "initializers", ".", "VarianceScaling", "(", "\n", "scale", "=", "2", "*", "w_range", ",", "mode", "=", "\"fan_in\"", ",", "distribution", "=", "\"normal\"", ",", "seed", "=", "None", ")", "\n", "", "if", "w_initializer", "==", "\"he_uniform\"", ":", "\n", "      ", "return", "initializers", ".", "VarianceScaling", "(", "\n", "scale", "=", "2", "*", "w_range", ",", "mode", "=", "\"fan_in\"", ",", "distribution", "=", "\"uniform\"", ",", "seed", "=", "None", ")", "\n", "", "elif", "w_initializer", "==", "\"glorot_normal\"", ":", "\n", "      ", "return", "initializers", ".", "VarianceScaling", "(", "\n", "scale", "=", "w_range", ",", "mode", "=", "\"fan_avg\"", ",", "distribution", "=", "\"normal\"", ",", "seed", "=", "None", ")", "\n", "", "elif", "w_initializer", "==", "\"glorot_uniform\"", ":", "\n", "      ", "return", "initializers", ".", "VarianceScaling", "(", "\n", "scale", "=", "w_range", ",", "mode", "=", "\"fan_avg\"", ",", "distribution", "=", "\"uniform\"", ",", "seed", "=", "None", ")", "\n", "", "elif", "w_initializer", "==", "\"random_uniform\"", ":", "\n", "      ", "return", "initializers", ".", "RandomUniform", "(", "-", "w_range", ",", "w_range", ")", "\n", "\n", "", "", "return", "w_initializer", "\n", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.Num": [[31, 46], ["int", "float"], "function", ["None"], ["def", "Num", "(", "s", ")", ":", "\n", "  ", "\"\"\"Tries to convert string to either int or float.\"\"\"", "\n", "try", ":", "\n", "    ", "try", ":", "\n", "      ", "return", "int", "(", "s", ")", "\n", "", "except", "ValueError", ":", "\n", "      ", "return", "float", "(", "s", ")", "\n", "", "", "except", "ValueError", ":", "\n", "# this should be always true. if it isn't int or float, it should be str", "\n", "    ", "assert", "(", "\n", "(", "s", "[", "0", "]", "==", "'\"'", "and", "s", "[", "-", "1", "]", "==", "'\"'", ")", "or", "\n", "(", "s", "[", "0", "]", "==", "\"'\"", "and", "s", "[", "-", "1", "]", "==", "\"'\"", ")", "\n", ")", "\n", "s", "=", "s", "[", "1", ":", "-", "1", "]", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.Str": [[47, 49], ["None"], "function", ["None"], ["", "", "def", "Str", "(", "s", ")", ":", "\n", "  ", "return", "s", "[", "1", ":", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.IsNum": [[50, 60], ["int", "float"], "function", ["None"], ["", "def", "IsNum", "(", "s", ")", ":", "\n", "  ", "try", ":", "\n", "    ", "try", ":", "\n", "      ", "int", "(", "s", ")", "\n", "return", "True", "\n", "", "except", "ValueError", ":", "\n", "      ", "float", "(", "s", ")", "\n", "return", "True", "\n", "", "", "except", "ValueError", ":", "\n", "    ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.IsBool": [[61, 66], ["None"], "function", ["None"], ["", "", "def", "IsBool", "(", "s", ")", ":", "\n", "  ", "if", "s", "in", "[", "\"True\"", ",", "\"False\"", "]", ":", "\n", "    ", "return", "True", "\n", "", "else", ":", "\n", "    ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.IsNone": [[67, 69], ["None"], "function", ["None"], ["", "", "def", "IsNone", "(", "s", ")", ":", "\n", "  ", "return", "s", "==", "\"None\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.Bool": [[70, 72], ["None"], "function", ["None"], ["", "def", "Bool", "(", "s", ")", ":", "\n", "  ", "return", "True", "if", "\"True\"", "in", "s", "else", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.GetArg": [[73, 82], ["safe_eval.IsBool", "safe_eval.Bool", "safe_eval.IsNum", "safe_eval.Num", "safe_eval.IsNone", "safe_eval.Str"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.IsBool", "home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.Bool", "home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.IsNum", "home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.Num", "home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.IsNone", "home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.Str"], ["", "def", "GetArg", "(", "s", ")", ":", "\n", "  ", "if", "IsBool", "(", "s", ")", ":", "\n", "    ", "return", "Bool", "(", "s", ")", "\n", "", "elif", "IsNum", "(", "s", ")", ":", "\n", "    ", "return", "Num", "(", "s", ")", "\n", "", "elif", "IsNone", "(", "s", ")", ":", "\n", "    ", "return", "None", "\n", "", "else", ":", "\n", "    ", "return", "Str", "(", "s", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.GetParams": [[84, 114], ["pyparsing.Suppress", "pyparsing.Suppress", "pyparsing.Suppress", "data.parseString().asList", "range", "safe_eval.GetArg", "safe_eval.GetArg", "len", "pyparsing.Optional", "data.parseString", "SyntaxError", "pyparsing.delimitedList", "len", "len", "len", "len", "pyparsing.Group", "str", "pyparsing.Regex", "pyparsing.Optional", "str", "pyparsing.Regex", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.GetArg", "home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.GetArg"], ["", "", "def", "GetParams", "(", "s", ")", ":", "\n", "  ", "\"\"\"Extracts args and kwargs from string.\"\"\"", "\n", "# modified from https://stackoverflow.com/questions/38799223/parse-string-to-identify-kwargs-and-args  # pylint: disable=line-too-long", "\n", "\n", "_lparen", "=", "Suppress", "(", "\"(\"", ")", "# pylint: disable=invalid-name", "\n", "_rparen", "=", "Suppress", "(", "\")\"", ")", "# pylint: disable=invalid-name", "\n", "_eq", "=", "Suppress", "(", "\"=\"", ")", "# pylint: disable=invalid-name", "\n", "\n", "data", "=", "(", "_lparen", "+", "Optional", "(", "\n", "delimitedList", "(", "\n", "Group", "(", "Regex", "(", "r\"[^=,)\\s]+\"", ")", "+", "Optional", "(", "_eq", "+", "Regex", "(", "u\"[^,)]*\"", ")", ")", ")", "\n", ")", "\n", ")", "+", "_rparen", ")", "\n", "\n", "items", "=", "data", ".", "parseString", "(", "s", ")", ".", "asList", "(", ")", "\n", "\n", "# need to make sure that kwargs only happen after args are processed", "\n", "args", "=", "[", "GetArg", "(", "i", "[", "0", "]", ")", "for", "i", "in", "items", "if", "len", "(", "i", ")", "==", "1", "]", "\n", "kwargs", "=", "{", "i", "[", "0", "]", ":", "GetArg", "(", "i", "[", "1", "]", ")", "for", "i", "in", "items", "if", "len", "(", "i", ")", "==", "2", "}", "\n", "\n", "# check for syntax error", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "items", ")", ")", ":", "\n", "    ", "if", "(", "len", "(", "items", "[", "i", "]", ")", "==", "1", ")", "and", "(", "len", "(", "items", "[", "i", "-", "1", "]", ")", "==", "2", ")", ":", "\n", "      ", "raise", "SyntaxError", "(", "(", "\"Error with item \"", "+", "str", "(", "i", ")", "+", "\" \\n\"", "+", "\n", "\"  parsing string \"", "+", "s", "+", "\"\\n\"", "+", "\n", "\"  Items: \"", "+", "str", "(", "items", ")", "+", "\"\\n\"", "+", "\n", "\"  Item[\"", "+", "str", "(", "i", "-", "1", ")", "+", "\"] :\"", "+", "str", "(", "items", "[", "i", "-", "1", "]", ")", "+", "\"\\n\"", "+", "\n", "\"  Item[\"", "+", "str", "(", "i", ")", "+", "\"] :\"", "+", "str", "(", "items", "[", "i", "]", ")", ")", ")", "\n", "\n", "", "", "return", "args", ",", "kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.safe_eval": [[116, 146], ["eval_str.split", "op_dict.get", "len", "safe_eval.GetParams", "list", "logging.info", "tensorflow.keras.activations.get", "keras.activations.get.", "isinstance", "len", "keras.activations.get."], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.safe_eval.GetParams"], ["", "def", "safe_eval", "(", "eval_str", ",", "op_dict", ",", "*", "params", ",", "**", "kwparams", ")", ":", "# pylint: disable=invalid-name", "\n", "  ", "\"\"\"Replaces eval by a safe eval mechanism.\"\"\"", "\n", "\n", "function_split", "=", "eval_str", ".", "split", "(", "\"(\"", ")", "\n", "quantizer", "=", "op_dict", ".", "get", "(", "function_split", "[", "0", "]", ",", "None", ")", "\n", "\n", "if", "len", "(", "function_split", ")", "==", "2", ":", "\n", "    ", "args", ",", "kwargs", "=", "GetParams", "(", "\"(\"", "+", "function_split", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "    ", "args", "=", "[", "]", "\n", "kwargs", "=", "{", "}", "\n", "\n", "", "args", "=", "args", "+", "list", "(", "params", ")", "\n", "for", "k", "in", "kwparams", ":", "\n", "    ", "kwargs", "[", "k", "]", "=", "kwparams", "[", "k", "]", "\n", "\n", "# must be Keras activation object if None", "\n", "", "if", "quantizer", "is", "None", ":", "\n", "    ", "logging", ".", "info", "(", "\"keras dict %s\"", ",", "function_split", "[", "0", "]", ")", "\n", "quantizer", "=", "keras", ".", "activations", ".", "get", "(", "function_split", "[", "0", "]", ")", "\n", "\n", "", "if", "len", "(", "function_split", ")", "==", "2", "or", "args", "or", "kwargs", ":", "\n", "    ", "return", "quantizer", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "    ", "if", "isinstance", "(", "quantizer", ",", "type", ")", ":", "\n", "# Check if quantizer is a class", "\n", "      ", "return", "quantizer", "(", ")", "\n", "", "else", ":", "\n", "# Otherwise it is a function, so just return it", "\n", "      ", "return", "quantizer", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.codebook.create_in_out_table": [[28, 45], ["km.cluster_centers_.flatten", "quantizer.range().reshape().astype", "km.predict().ravel", "quantizer.range().reshape", "km.predict", "quantizer.range"], "function", ["home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["def", "create_in_out_table", "(", "km", ",", "quantizer", ")", ":", "\n", "  ", "\"\"\"Create [in, out] table needed to map compressed activations to codebook\n  values. Given v: in_table[out_table[v]] => codebook value of v\n\n  Arguments:\n    km: KMeans model\n    quantizer: quantizer function to apply to out_table\n\n  Returns\n    in_table: conversion of compressed table indexes to n-bit numbers\n    out_table: conversion of n-bit output activations to compressed table\n      indexes\n  \"\"\"", "\n", "in_table", "=", "km", ".", "cluster_centers_", ".", "flatten", "(", ")", "\n", "qrange", "=", "quantizer", ".", "range", "(", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "out_table", "=", "km", ".", "predict", "(", "qrange", ")", ".", "ravel", "(", ")", "\n", "return", "in_table", ",", "out_table", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.codebook.activation_compression": [[47, 116], ["range", "print", "enumerate", "enumerate", "print", "models[].evaluate", "len", "len", "len", "len", "layer", "print", "model.predict", "tensorflow.keras.layers.Input.flatten().reshape", "km.fit", "getattr", "getattr.numpy", "km.cluster_centers_.sort", "codebook.create_in_out_table", "model.predict", "km.predict", "km.cluster_centers_[].reshape", "print", "sklearn.cluster.KMeans", "print", "models.append", "tensorflow.keras.layers.Input", "models[].compile", "print", "numpy.random.choice", "getattr", "tensorflow.keras.layers.Input.flatten().reshape", "tensorflow.keras.models.Model", "models[].summary", "tensorflow.keras.layers.Input.flatten", "getattr.", "numpy.unique", "len", "int", "tensorflow.keras.layers.Input.flatten", "tensorflow.keras.layers.Input.flatten"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit", "home.repos.pwc.inspect_result.google_qkeras.qkeras.codebook.create_in_out_table", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict"], ["", "def", "activation_compression", "(", "model", ",", "compile_config", ",", "activation_indexes", ",", "bits", ",", "\n", "X_train", ",", "y_train", ",", "X_test", ",", "y_test", ",", "sample_size", "=", "1.0", ")", ":", "\n", "  ", "\"\"\"This function applies clustering based non-uniform quantization inspired by\n  https://arxiv.org/pdf/1911.02079.pdf\n\n  model: Keras model\n  compile_config: Dictionary of arguments to be passed to model.compile()\n    for all submodels\n  activation_indexes: Index list of layers to be quantized. This will\n    used to split the model and create submodels\n  bits: Number of bits to compress activations to. This will\n    results in 2**bits codebook values\n  X_train, y_train: training data used to fit clustering algorithm\n  X_test, y_test: validation data\n  sample_size:\n    fraction of training data activations to be used when computing\n    codebook values\n\n  Returns:\n    cb_tables: [in, out] tables. See create_in_out_table docs\n    models: list of keras submodels\n    km_models: list of KMeans fitted models\n  \"\"\"", "\n", "assert", "len", "(", "activation_indexes", ")", ">", "0", "\n", "assert", "0.0", "<", "sample_size", "<=", "1.0", "\n", "km_models", "=", "[", "KMeans", "(", "2", "**", "bits", ")", "]", "*", "len", "(", "activation_indexes", ")", "\n", "cb_tables", "=", "[", "[", "]", "]", "*", "len", "(", "activation_indexes", ")", "\n", "models", "=", "[", "]", "\n", "x", "=", "x_in", "=", "model", ".", "layers", "[", "0", "]", ".", "output", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "model", ".", "layers", ")", ")", ":", "\n", "    ", "layer", "=", "model", ".", "layers", "[", "i", "]", "\n", "x", "=", "layer", "(", "x", ")", "\n", "if", "i", "in", "activation_indexes", "or", "i", "==", "len", "(", "model", ".", "layers", ")", "-", "1", ":", "\n", "      ", "print", "(", "\"\\nCreating submodel...\"", ")", "\n", "models", ".", "append", "(", "Model", "(", "[", "x_in", "]", ",", "[", "x", "]", ")", ")", "\n", "x", "=", "x_in", "=", "Input", "(", "layer", ".", "output", "[", "0", "]", ".", "shape", ",", "\n", "batch_size", "=", "layer", ".", "output", ".", "shape", "[", "0", "]", ",", "\n", "dtype", "=", "layer", ".", "output", ".", "dtype", ")", "\n", "models", "[", "-", "1", "]", ".", "compile", "(", "**", "compile_config", ")", "\n", "print", "(", "models", "[", "-", "1", "]", ".", "summary", "(", ")", ")", "\n", "", "", "print", "(", "'\\nsample_size: '", ",", "sample_size", ")", "\n", "x", "=", "X_train", "\n", "for", "i", ",", "model", "in", "enumerate", "(", "models", "[", ":", "-", "1", "]", ")", ":", "\n", "    ", "print", "(", "f'fitting km[{i}]...'", ")", "\n", "x", "=", "model", ".", "predict", "(", "x", ")", "\n", "km", "=", "km_models", "[", "i", "]", "\n", "temp", "=", "x", ".", "flatten", "(", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "if", "sample_size", "<", "1.0", ":", "\n", "      ", "idxs", "=", "np", ".", "random", ".", "choice", "(", "x", ".", "shape", "[", "0", "]", ",", "size", "=", "int", "(", "sample_size", "*", "x", ".", "shape", "[", "0", "]", ")", ")", "\n", "temp", "=", "temp", "[", "idxs", "]", "\n", "", "km", ".", "fit", "(", "temp", ")", "\n", "quantizer", "=", "getattr", "(", "model", ".", "layers", "[", "-", "1", "]", ",", "'quantizer'", ",", "\n", "getattr", "(", "model", ".", "layers", "[", "-", "1", "]", ",", "'activation'", ")", ")", "\n", "km", ".", "cluster_centers_", "=", "quantizer", "(", "km", ".", "cluster_centers_", ")", ".", "numpy", "(", ")", "\n", "km", ".", "cluster_centers_", ".", "sort", "(", "axis", "=", "0", ")", "\n", "cb_tables", "[", "i", "]", "=", "create_in_out_table", "(", "km", ",", "quantizer", ")", "\n", "", "x", "=", "X_test", "\n", "for", "i", ",", "model", "in", "enumerate", "(", "models", "[", ":", "-", "1", "]", ")", ":", "\n", "    ", "x", "=", "model", ".", "predict", "(", "x", ")", "\n", "km", "=", "km_models", "[", "i", "]", "\n", "preds", "=", "km", ".", "predict", "(", "x", ".", "flatten", "(", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "x", "=", "km", ".", "cluster_centers_", "[", "preds", "]", ".", "reshape", "(", "x", ".", "shape", ")", "\n", "n_unique", "=", "np", ".", "unique", "(", "x", ".", "flatten", "(", ")", ")", ".", "shape", "[", "0", "]", "\n", "print", "(", "f\"Number of unique activations: {n_unique}\"", ")", "\n", "assert", "n_unique", "<=", "2", "**", "bits", "\n", "\n", "", "print", "(", "'\\nEvaluating...'", ")", "\n", "models", "[", "-", "1", "]", ".", "evaluate", "(", "x", ",", "y_test", ",", "verbose", "=", "2", ")", "\n", "return", "cb_tables", ",", "models", ",", "km_models", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.codebook.weight_compression": [[118, 155], ["numpy.zeros", "tqdm.tqdm", "numpy.concatenate", "enumerate", "w.ravel.ravel", "sklearn.cluster.KMeans", "sklearn.cluster.KMeans.fit", "sklearn.cluster.KMeans.cluster_centers_.sort", "sklearn.cluster.KMeans.cluster_centers_.flatten", "sklearn.cluster.KMeans.predict", "np.concatenate.append", "numpy.split", "w.ravel.reshape", "quantizer().numpy", "w.ravel.reshape", "km.predict.reshape", "quantizer"], "function", ["home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict"], ["", "def", "weight_compression", "(", "weights", ",", "bits", ",", "axis", "=", "0", ",", "quantizer", "=", "None", ")", ":", "\n", "  ", "\"\"\"Creates an in, out table that maps weight values to their codebook values.\n  Based on the idea presented by https://arxiv.org/pdf/1911.02079.pdf\n\n  Arguments:\n    weights: Numpy array\n    bits: Number of bits to compress weights to. This will\n      results in 2**bits codebook values\n    axis: axis to apply quantization by\n    quantizer: quantizer function that will be applied to codebook values\n\n  Returns:\n    index_table: array of indices that maps to codebook values for all weights\n    codebook_table: array of codebook values\n  \"\"\"", "\n", "assert", "bits", "<=", "8", "\n", "n", "=", "2", "**", "bits", "\n", "index_table", "=", "[", "]", "\n", "codebook_table", "=", "np", ".", "zeros", "(", "(", "weights", ".", "shape", "[", "axis", "]", ",", "n", ")", ")", "\n", "km_models", "=", "[", "None", "]", "*", "weights", ".", "shape", "[", "axis", "]", "\n", "\n", "for", "i", ",", "w", "in", "tqdm", "(", "enumerate", "(", "np", ".", "split", "(", "weights", ",", "weights", ".", "shape", "[", "axis", "]", ",", "axis", ")", ")", ")", ":", "\n", "    ", "original_shape", "=", "w", ".", "shape", "\n", "w", "=", "w", ".", "ravel", "(", ")", "\n", "km", "=", "KMeans", "(", "n", ")", "\n", "km", ".", "fit", "(", "w", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "if", "quantizer", ":", "\n", "      ", "km", ".", "cluster_centers_", "=", "quantizer", "(", "km", ".", "cluster_centers_", ")", ".", "numpy", "(", ")", "\n", "", "km", ".", "cluster_centers_", ".", "sort", "(", "axis", "=", "0", ")", "\n", "\n", "km_models", "[", "i", "]", "=", "km", "\n", "codebook_table", "[", "i", ",", ":", "]", "=", "km", ".", "cluster_centers_", ".", "flatten", "(", ")", "\n", "preds", "=", "km", ".", "predict", "(", "w", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "index_table", ".", "append", "(", "preds", ".", "reshape", "(", "original_shape", ")", ")", "\n", "\n", "", "index_table", "=", "np", ".", "concatenate", "(", "index_table", ",", "axis", ")", "\n", "return", "index_table", ",", "codebook_table", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.codebook.two_tier_embedding_compression": [[157, 207], ["embeddings.copy", "numpy.zeros", "numpy.zeros", "numpy.zeros", "sklearn.cluster.KMeans", "sklearn.cluster.KMeans.fit", "sklearn.cluster.KMeans.predict", "tqdm.tqdm", "print", "range", "sklearn.cluster.KMeans", "sklearn.cluster.KMeans.fit", "sklearn.cluster.KMeans.cluster_centers_.sort", "sklearn.cluster.KMeans.cluster_centers_.flatten", "numpy.arange", "block.flatten().reshape", "quantizer().numpy", "sklearn.cluster.KMeans.predict", "sklearn.cluster.KMeans.cluster_centers_[].flatten", "embeddings[].reshape", "block.flatten", "quantizer"], "function", ["home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict"], ["", "def", "two_tier_embedding_compression", "(", "embeddings", ",", "bits", ",", "quantizer", "=", "None", ")", ":", "\n", "  ", "\"\"\" Creates tables that maps embedding values to their codebook values.\n  Based on the idea presented by https://arxiv.org/pdf/1911.02079.pdf\n\n  Arguments:\n    weights: Numpy array\n    bits: Number of bits to compress weights to. This will\n      results in 2**bits codebook values\n    quantizer: quantizer function that will be applied to codebook values\n\n  Returns:\n    index_table: array of indices that maps to codebook values\n    cluster_index_table: array that maps each row to the codebook table\n      index\n    codebook_table: array of codebook values\n    quantized_embeddings: Numpy array MxN of quantized weights\n  \"\"\"", "\n", "assert", "bits", "<=", "8", "\n", "n", "=", "2", "**", "bits", "\n", "quantized_embeddings", "=", "embeddings", ".", "copy", "(", ")", "\n", "index_table", "=", "np", ".", "zeros", "(", "embeddings", ".", "shape", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "cluster_index_table", "=", "np", ".", "zeros", "(", "index_table", ".", "shape", "[", "0", "]", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "codebook_table", "=", "np", ".", "zeros", "(", "(", "n", ",", "n", ")", ")", "\n", "\n", "km1", "=", "KMeans", "(", "n", ")", "\n", "km1", ".", "fit", "(", "embeddings", ")", "\n", "tier1", "=", "km1", ".", "predict", "(", "embeddings", ")", "\n", "\n", "km_models", "=", "[", "0", "]", "*", "n", "\n", "block_sizes", "=", "[", "0", "]", "*", "n", "\n", "for", "block_label", "in", "tqdm", "(", "range", "(", "n", ")", ")", ":", "\n", "    ", "mask", "=", "block_label", "==", "tier1", "\n", "indices", "=", "np", ".", "arange", "(", "embeddings", ".", "shape", "[", "0", "]", ")", "[", "mask", "]", "\n", "block", "=", "embeddings", "[", "mask", "]", "\n", "km2", "=", "KMeans", "(", "n", ")", "\n", "km2", ".", "fit", "(", "block", ".", "flatten", "(", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "if", "quantizer", ":", "\n", "      ", "km2", ".", "cluster_centers_", "=", "quantizer", "(", "km2", ".", "cluster_centers_", ")", ".", "numpy", "(", ")", "\n", "", "km2", ".", "cluster_centers_", ".", "sort", "(", "axis", "=", "0", ")", "\n", "\n", "km_models", "[", "block_label", "]", "=", "km2", "\n", "codebook_table", "[", "block_label", ",", ":", "]", "=", "km2", ".", "cluster_centers_", ".", "flatten", "(", ")", "\n", "cluster_index_table", "[", "indices", "]", "=", "block_label", "\n", "block_sizes", "[", "block_label", "]", "=", "block", ".", "shape", "[", "0", "]", "\n", "for", "i", "in", "indices", ":", "\n", "      ", "preds", "=", "km2", ".", "predict", "(", "embeddings", "[", "i", ",", ":", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "index_table", "[", "indices", ",", ":", "]", "=", "preds", "\n", "quantized_embeddings", "[", "i", ",", ":", "]", "=", "km2", ".", "cluster_centers_", "[", "preds", "]", ".", "flatten", "(", ")", "\n", "", "", "print", "(", "'block_sizes:'", ",", "block_sizes", ")", "\n", "return", "index_table", ",", "cluster_index_table", ",", "codebook_table", ",", "quantized_embeddings", "\n", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qnormalization.QBatchNormalization.__init__": [[54, 176], ["qlayers.get_quantizer", "qlayers.get_quantizer", "qlayers.get_quantizer", "qlayers.get_quantizer", "qlayers.get_quantizer", "hasattr", "hasattr", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "tensorflow.keras.layers.BatchNormalization.__init__", "warnings.warn", "warnings.warn", "qnormalization.QBatchNormalization.gamma_quantizer_internal._set_trainable_parameter", "qnormalization.QBatchNormalization.variance_quantizer_internal._set_trainable_parameter", "qlayers.get_auto_range_constraint_initializer", "qlayers.get_auto_range_constraint_initializer", "warnings.warn", "warnings.warn", "warnings.warn", "warnings.warn"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary._set_trainable_parameter", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary._set_trainable_parameter", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer"], ["def", "__init__", "(", "\n", "self", ",", "\n", "axis", "=", "-", "1", ",", "\n", "momentum", "=", "0.99", ",", "\n", "epsilon", "=", "1e-3", ",", "\n", "center", "=", "True", ",", "\n", "scale", "=", "True", ",", "\n", "activation", "=", "None", ",", "\n", "beta_initializer", "=", "'zeros'", ",", "\n", "gamma_initializer", "=", "'ones'", ",", "\n", "moving_mean_initializer", "=", "'zeros'", ",", "\n", "moving_variance_initializer", "=", "'ones'", ",", "\n", "beta_regularizer", "=", "None", ",", "\n", "gamma_regularizer", "=", "None", ",", "\n", "beta_quantizer", "=", "'quantized_po2(5)'", ",", "\n", "gamma_quantizer", "=", "'quantized_relu_po2(6, 2048)'", ",", "\n", "mean_quantizer", "=", "'quantized_po2(5)'", ",", "\n", "variance_quantizer", "=", "'quantized_relu_po2(6, quadratic_approximation=True)'", ",", "\n", "inverse_quantizer", "=", "None", ",", "\n", "gamma_constraint", "=", "None", ",", "\n", "beta_constraint", "=", "None", ",", "\n", "# use quantized_po2 and enforce quadratic approximation", "\n", "# to get an even exponent for sqrt", "\n", "beta_range", "=", "None", ",", "\n", "gamma_range", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "    ", "if", "gamma_range", "is", "not", "None", ":", "\n", "      ", "warnings", ".", "warn", "(", "'gamma_range is deprecated in QBatchNormalization layer.'", ")", "\n", "\n", "", "if", "beta_range", "is", "not", "None", ":", "\n", "      ", "warnings", ".", "warn", "(", "'beta_range is deprecated in QBatchNormalization layer.'", ")", "\n", "\n", "", "self", ".", "gamma_range", "=", "gamma_range", "\n", "self", ".", "beta_range", "=", "beta_range", "\n", "self", ".", "activation", "=", "activation", "\n", "\n", "self", ".", "beta_quantizer", "=", "beta_quantizer", "\n", "self", ".", "gamma_quantizer", "=", "gamma_quantizer", "\n", "self", ".", "mean_quantizer", "=", "mean_quantizer", "\n", "self", ".", "variance_quantizer", "=", "variance_quantizer", "\n", "self", ".", "inverse_quantizer", "=", "inverse_quantizer", "\n", "\n", "if", "self", ".", "inverse_quantizer", "is", "not", "None", ":", "\n", "      ", "assert", "self", ".", "variance_quantizer", "is", "None", "and", "self", ".", "gamma_quantizer", "is", "None", ",", "(", "\n", "'If using the inverse quantizer, the gamma and variance quantizers '", "\n", "'should not be used in order to avoid quantizing a value twice.'", ")", "\n", "\n", "", "self", ".", "beta_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "beta_quantizer", ")", "\n", "self", ".", "gamma_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "gamma_quantizer", ")", "\n", "self", ".", "mean_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "mean_quantizer", ")", "\n", "self", ".", "variance_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "variance_quantizer", ")", "\n", "self", ".", "inverse_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "inverse_quantizer", ")", "\n", "\n", "if", "hasattr", "(", "self", ".", "gamma_quantizer_internal", ",", "'_set_trainable_parameter'", ")", ":", "\n", "      ", "self", ".", "gamma_quantizer_internal", ".", "_set_trainable_parameter", "(", ")", "\n", "", "if", "hasattr", "(", "self", ".", "variance_quantizer_internal", ",", "'_set_trainable_parameter'", ")", ":", "\n", "      ", "self", ".", "variance_quantizer_internal", ".", "_set_trainable_parameter", "(", ")", "\n", "\n", "", "self", ".", "quantizers", "=", "[", "\n", "self", ".", "gamma_quantizer_internal", ",", "\n", "self", ".", "beta_quantizer_internal", ",", "\n", "self", ".", "mean_quantizer_internal", ",", "\n", "self", ".", "variance_quantizer_internal", ",", "\n", "self", ".", "inverse_quantizer_internal", "\n", "]", "\n", "\n", "if", "scale", "and", "self", ".", "gamma_quantizer", ":", "\n", "      ", "gamma_constraint", ",", "gamma_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "\n", "self", ".", "gamma_quantizer_internal", ",", "\n", "gamma_constraint", ",", "\n", "gamma_initializer", ")", "\n", ")", "\n", "\n", "", "if", "center", "and", "self", ".", "beta_quantizer", ":", "\n", "      ", "beta_constraint", ",", "beta_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "\n", "self", ".", "beta_quantizer_internal", ",", "\n", "beta_constraint", ",", "\n", "beta_initializer", ")", "\n", ")", "\n", "\n", "", "if", "kwargs", ".", "get", "(", "'fused'", ",", "None", ")", ":", "\n", "      ", "warnings", ".", "warn", "(", "'batch normalization fused is disabled '", "\n", "'in qkeras qnormalization.py.'", ")", "\n", "del", "kwargs", "[", "'fused'", "]", "\n", "\n", "", "if", "kwargs", ".", "get", "(", "'renorm'", ",", "None", ")", ":", "\n", "      ", "warnings", ".", "warn", "(", "'batch normalization renorm is disabled '", "\n", "'in qkeras qnormalization.py.'", ")", "\n", "del", "kwargs", "[", "'renorm'", "]", "\n", "\n", "", "if", "kwargs", ".", "get", "(", "'virtual_batch_size'", ",", "None", ")", ":", "\n", "      ", "warnings", ".", "warn", "(", "'batch normalization virtual_batch_size is disabled '", "\n", "'in qkeras qnormalization.py.'", ")", "\n", "del", "kwargs", "[", "'virtual_batch_size'", "]", "\n", "\n", "", "if", "kwargs", ".", "get", "(", "'adjustment'", ",", "None", ")", ":", "\n", "      ", "warnings", ".", "warn", "(", "'batch normalization adjustment is disabled '", "\n", "'in qkeras qnormalization.py.'", ")", "\n", "del", "kwargs", "[", "'adjustment'", "]", "\n", "\n", "", "super", "(", "QBatchNormalization", ",", "self", ")", ".", "__init__", "(", "\n", "axis", "=", "axis", ",", "\n", "momentum", "=", "momentum", ",", "\n", "epsilon", "=", "epsilon", ",", "\n", "center", "=", "center", ",", "\n", "scale", "=", "scale", ",", "\n", "beta_initializer", "=", "beta_initializer", ",", "\n", "gamma_initializer", "=", "gamma_initializer", ",", "\n", "moving_mean_initializer", "=", "moving_mean_initializer", ",", "\n", "moving_variance_initializer", "=", "moving_variance_initializer", ",", "\n", "beta_regularizer", "=", "beta_regularizer", ",", "\n", "gamma_regularizer", "=", "gamma_regularizer", ",", "\n", "beta_constraint", "=", "beta_constraint", ",", "\n", "gamma_constraint", "=", "gamma_constraint", ",", "\n", "fused", "=", "False", ",", "\n", "renorm", "=", "False", ",", "\n", "virtual_batch_size", "=", "None", ",", "\n", "adjustment", "=", "None", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qnormalization.QBatchNormalization.call": [[177, 302], ["qnormalization.QBatchNormalization._get_training_value", "len", "tensorflow.python.framework.smart_cond.smart_constant_value", "qnormalization.QBatchNormalization.call._broadcast"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "inputs", ",", "training", "=", "None", ")", ":", "\n", "    ", "if", "self", ".", "scale", "and", "self", ".", "gamma_quantizer", ":", "\n", "      ", "quantized_gamma", "=", "self", ".", "gamma_quantizer_internal", "(", "self", ".", "gamma", ")", "\n", "", "else", ":", "\n", "      ", "quantized_gamma", "=", "self", ".", "gamma", "\n", "\n", "", "if", "self", ".", "center", "and", "self", ".", "beta_quantizer", ":", "\n", "      ", "quantized_beta", "=", "self", ".", "beta_quantizer_internal", "(", "self", ".", "beta", ")", "\n", "", "else", ":", "\n", "      ", "quantized_beta", "=", "self", ".", "beta", "\n", "\n", "", "if", "self", ".", "mean_quantizer", ":", "\n", "      ", "quantized_moving_mean", "=", "self", ".", "mean_quantizer_internal", "(", "self", ".", "moving_mean", ")", "\n", "", "else", ":", "\n", "      ", "quantized_moving_mean", "=", "self", ".", "moving_mean", "\n", "\n", "", "if", "self", ".", "variance_quantizer", ":", "\n", "      ", "quantized_moving_variance", "=", "self", ".", "variance_quantizer_internal", "(", "\n", "self", ".", "moving_variance", ")", "\n", "", "else", ":", "\n", "      ", "quantized_moving_variance", "=", "self", ".", "moving_variance", "\n", "\n", "", "training", "=", "self", ".", "_get_training_value", "(", "training", ")", "\n", "\n", "# Compute the axes along which to reduce the mean / variance", "\n", "input_shape", "=", "inputs", ".", "shape", "\n", "ndims", "=", "len", "(", "input_shape", ")", "\n", "reduction_axes", "=", "[", "i", "for", "i", "in", "range", "(", "ndims", ")", "if", "i", "not", "in", "self", ".", "axis", "]", "\n", "\n", "# Broadcasting only necessary for single-axis batch norm where the axis is", "\n", "# not the last dimension", "\n", "broadcast_shape", "=", "[", "1", "]", "*", "ndims", "\n", "broadcast_shape", "[", "self", ".", "axis", "[", "0", "]", "]", "=", "input_shape", ".", "dims", "[", "self", ".", "axis", "[", "0", "]", "]", ".", "value", "\n", "def", "_broadcast", "(", "v", ")", ":", "\n", "      ", "if", "(", "v", "is", "not", "None", "and", "len", "(", "v", ".", "shape", ")", "!=", "ndims", "and", "\n", "reduction_axes", "!=", "list", "(", "range", "(", "ndims", "-", "1", ")", ")", ")", ":", "\n", "        ", "return", "array_ops", ".", "reshape", "(", "v", ",", "broadcast_shape", ")", "\n", "", "return", "v", "\n", "\n", "", "scale", ",", "offset", "=", "_broadcast", "(", "quantized_gamma", ")", ",", "_broadcast", "(", "quantized_beta", ")", "\n", "\n", "# Determine a boolean value for `training`: could be True, False, or None.", "\n", "training_value", "=", "tf_utils", ".", "smart_constant_value", "(", "training", ")", "\n", "if", "training_value", "==", "False", ":", "# pylint: disable=singleton-comparison,g-explicit-bool-comparison", "\n", "      ", "quantized_mean", ",", "quantized_variance", "=", "(", "quantized_moving_mean", ",", "\n", "quantized_moving_variance", ")", "\n", "", "else", ":", "\n", "# Some of the computations here are not necessary when training==False", "\n", "# but not a constant. However, this makes the code simpler.", "\n", "      ", "keep_dims", "=", "len", "(", "self", ".", "axis", ")", ">", "1", "\n", "mean", ",", "variance", "=", "self", ".", "_moments", "(", "\n", "math_ops", ".", "cast", "(", "inputs", ",", "self", ".", "_param_dtype", ")", ",", "\n", "reduction_axes", ",", "\n", "keep_dims", "=", "keep_dims", ")", "\n", "\n", "moving_mean", "=", "self", ".", "moving_mean", "\n", "moving_variance", "=", "self", ".", "moving_variance", "\n", "\n", "mean", "=", "tf_utils", ".", "smart_cond", "(", "\n", "training", ",", "lambda", ":", "mean", ",", "lambda", ":", "ops", ".", "convert_to_tensor", "(", "moving_mean", ")", ")", "\n", "variance", "=", "tf_utils", ".", "smart_cond", "(", "\n", "training", ",", "\n", "lambda", ":", "variance", ",", "\n", "lambda", ":", "ops", ".", "convert_to_tensor", "(", "moving_variance", ")", ")", "\n", "\n", "new_mean", ",", "new_variance", "=", "mean", ",", "variance", "\n", "\n", "if", "self", ".", "mean_quantizer", ":", "\n", "        ", "quantized_mean", "=", "self", ".", "mean_quantizer_internal", "(", "mean", ")", "\n", "", "else", ":", "\n", "        ", "quantized_mean", "=", "mean", "\n", "\n", "", "if", "self", ".", "variance_quantizer", ":", "\n", "        ", "quantized_variance", "=", "self", ".", "variance_quantizer_internal", "(", "variance", ")", "\n", "", "else", ":", "\n", "        ", "quantized_variance", "=", "variance", "\n", "\n", "", "if", "self", ".", "_support_zero_size_input", "(", ")", ":", "\n", "        ", "inputs_size", "=", "array_ops", ".", "size", "(", "inputs", ")", "\n", "", "else", ":", "\n", "        ", "inputs_size", "=", "None", "\n", "\n", "", "def", "_do_update", "(", "var", ",", "value", ")", ":", "\n", "        ", "\"\"\"Compute the updates for mean and variance.\"\"\"", "\n", "return", "self", ".", "_assign_moving_average", "(", "var", ",", "value", ",", "self", ".", "momentum", ",", "\n", "inputs_size", ")", "\n", "\n", "", "def", "mean_update", "(", ")", ":", "\n", "        ", "true_branch", "=", "lambda", ":", "_do_update", "(", "self", ".", "moving_mean", ",", "new_mean", ")", "\n", "false_branch", "=", "lambda", ":", "self", ".", "moving_mean", "\n", "return", "tf_utils", ".", "smart_cond", "(", "training", ",", "true_branch", ",", "false_branch", ")", "\n", "\n", "", "def", "variance_update", "(", ")", ":", "\n", "        ", "\"\"\"Update the moving variance.\"\"\"", "\n", "true_branch", "=", "lambda", ":", "_do_update", "(", "self", ".", "moving_variance", ",", "new_variance", ")", "\n", "false_branch", "=", "lambda", ":", "self", ".", "moving_variance", "\n", "return", "tf_utils", ".", "smart_cond", "(", "training", ",", "true_branch", ",", "false_branch", ")", "\n", "\n", "", "self", ".", "add_update", "(", "mean_update", ")", "\n", "self", ".", "add_update", "(", "variance_update", ")", "\n", "\n", "", "quantized_mean", "=", "_broadcast", "(", "math_ops", ".", "cast", "(", "quantized_mean", ",", "inputs", ".", "dtype", ")", ")", "\n", "quantized_variance", "=", "_broadcast", "(", "\n", "math_ops", ".", "cast", "(", "quantized_variance", ",", "inputs", ".", "dtype", ")", ")", "\n", "if", "offset", "is", "not", "None", ":", "\n", "      ", "offset", "=", "math_ops", ".", "cast", "(", "offset", ",", "inputs", ".", "dtype", ")", "\n", "", "if", "scale", "is", "not", "None", ":", "\n", "      ", "scale", "=", "math_ops", ".", "cast", "(", "scale", ",", "inputs", ".", "dtype", ")", "\n", "\n", "# Calculate and quantize the inverse", "\n", "", "inv", "=", "math_ops", ".", "rsqrt", "(", "quantized_variance", "+", "self", ".", "epsilon", ")", "\n", "if", "scale", "is", "not", "None", ":", "\n", "      ", "inv", "*=", "scale", "\n", "", "if", "self", ".", "inverse_quantizer_internal", "is", "not", "None", ":", "\n", "      ", "inv", "=", "self", ".", "inverse_quantizer_internal", "(", "inv", ")", "\n", "\n", "# Calculate the forward pass of the BN", "\n", "", "outputs", "=", "inputs", "*", "math_ops", ".", "cast", "(", "inv", ",", "inputs", ".", "dtype", ")", "+", "math_ops", ".", "cast", "(", "\n", "offset", "-", "quantized_mean", "*", "inv", "\n", "if", "offset", "is", "not", "None", "else", "-", "quantized_mean", "*", "inv", ",", "inputs", ".", "dtype", ")", "\n", "\n", "# If some components of the shape got lost due to adjustments, fix that.", "\n", "outputs", ".", "set_shape", "(", "input_shape", ")", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qnormalization.QBatchNormalization.get_config": [[303, 335], ["super().get_config", "dict", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "list", "list", "super().get_config.items", "config.items"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "'axis'", ":", "self", ".", "axis", ",", "\n", "'momentum'", ":", "self", ".", "momentum", ",", "\n", "'epsilon'", ":", "self", ".", "epsilon", ",", "\n", "'center'", ":", "self", ".", "center", ",", "\n", "'scale'", ":", "self", ".", "scale", ",", "\n", "'beta_quantizer'", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "beta_quantizer_internal", ")", ",", "\n", "'gamma_quantizer'", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "gamma_quantizer_internal", ")", ",", "\n", "'mean_quantizer'", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "mean_quantizer_internal", ")", ",", "\n", "'variance_quantizer'", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "variance_quantizer_internal", ")", ",", "\n", "'beta_initializer'", ":", "initializers", ".", "serialize", "(", "self", ".", "beta_initializer", ")", ",", "\n", "'gamma_initializer'", ":", "initializers", ".", "serialize", "(", "self", ".", "gamma_initializer", ")", ",", "\n", "'moving_mean_initializer'", ":", "\n", "initializers", ".", "serialize", "(", "self", ".", "moving_mean_initializer", ")", ",", "\n", "'moving_variance_initializer'", ":", "\n", "initializers", ".", "serialize", "(", "self", ".", "moving_variance_initializer", ")", ",", "\n", "'inverse_quantizer'", ":", "\n", "initializers", ".", "serialize", "(", "self", ".", "inverse_quantizer_internal", ")", ",", "\n", "'beta_regularizer'", ":", "regularizers", ".", "serialize", "(", "self", ".", "beta_regularizer", ")", ",", "\n", "'gamma_regularizer'", ":", "regularizers", ".", "serialize", "(", "self", ".", "gamma_regularizer", ")", ",", "\n", "'beta_constraint'", ":", "constraints", ".", "serialize", "(", "self", ".", "beta_constraint", ")", ",", "\n", "'gamma_constraint'", ":", "constraints", ".", "serialize", "(", "self", ".", "gamma_constraint", ")", ",", "\n", "'beta_range'", ":", "self", ".", "beta_range", ",", "\n", "'gamma_range'", ":", "self", ".", "gamma_range", ",", "\n", "}", "\n", "base_config", "=", "super", "(", "QBatchNormalization", ",", "self", ")", ".", "get_config", "(", ")", "\n", "return", "dict", "(", "list", "(", "base_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qnormalization.QBatchNormalization.compute_output_shape": [[336, 338], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "    ", "return", "input_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qnormalization.QBatchNormalization.get_quantizers": [[339, 341], ["None"], "methods", ["None"], ["", "def", "get_quantizers", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "quantizers", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qnormalization.QBatchNormalization.get_prunable_weights": [[342, 344], ["None"], "methods", ["None"], ["", "def", "get_prunable_weights", "(", "self", ")", ":", "\n", "    ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QInitializer.__init__": [[92, 101], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "initializer", ",", "use_scale", ",", "quantizer", ")", ":", "\n", "    ", "self", ".", "initializer", "=", "initializer", "\n", "self", ".", "use_scale", "=", "use_scale", "\n", "self", ".", "quantizer", "=", "quantizer", "\n", "\n", "try", ":", "\n", "      ", "self", ".", "is_po2", "=", "\"po2\"", "in", "quantizer", ".", "__class__", ".", "__name__", "\n", "", "except", ":", "\n", "      ", "self", ".", "is_po2", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QInitializer.__call__": [[102, 128], ["qlayers.QInitializer.initializer", "numpy.max", "numpy.std", "numpy.clip", "abs", "qlayers.QInitializer.quantizer.max", "hasattr", "qlayers.QInitializer.quantizer", "numpy.max", "max", "qlayers.QInitializer.initializer", "qlayers.QInitializer.quantizer.max", "abs", "numpy.mean", "numpy.sum", "numpy.sum", "qlayers.QInitializer.quantizer.max", "qlayers.QInitializer.quantizer.max", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "", "def", "__call__", "(", "self", ",", "shape", ",", "dtype", "=", "None", ")", ":", "\n", "    ", "x", "=", "self", ".", "initializer", "(", "shape", ",", "dtype", ")", "\n", "\n", "max_x", "=", "np", ".", "max", "(", "abs", "(", "x", ")", ")", "\n", "std_x", "=", "np", ".", "std", "(", "x", ")", "\n", "delta", "=", "self", ".", "quantizer", ".", "max", "(", ")", "*", "2", "**", "-", "self", ".", "quantizer", ".", "bits", "\n", "\n", "# delta is the minimum resolution of the number system.", "\n", "# we want to make sure we have enough values.", "\n", "if", "delta", ">", "std_x", "and", "hasattr", "(", "self", ".", "initializer", ",", "\"scale\"", ")", ":", "\n", "      ", "q", "=", "self", ".", "quantizer", "(", "x", ")", "\n", "max_q", "=", "np", ".", "max", "(", "abs", "(", "q", ")", ")", "\n", "scale", "=", "1.0", "\n", "if", "max_q", "==", "0.0", ":", "\n", "        ", "xx", "=", "np", ".", "mean", "(", "x", "*", "x", ")", "\n", "scale", "=", "self", ".", "quantizer", ".", "max", "(", ")", "/", "np", ".", "sqrt", "(", "xx", ")", "\n", "", "else", ":", "\n", "        ", "qx", "=", "np", ".", "sum", "(", "q", "*", "x", ")", "\n", "qq", "=", "np", ".", "sum", "(", "q", "*", "q", ")", "\n", "\n", "scale", "=", "qq", "/", "qx", "\n", "\n", "", "self", ".", "initializer", ".", "scale", "*=", "max", "(", "scale", ",", "1", ")", "\n", "x", "=", "self", ".", "initializer", "(", "shape", ",", "dtype", ")", "\n", "\n", "", "return", "np", ".", "clip", "(", "x", ",", "-", "self", ".", "quantizer", ".", "max", "(", ")", ",", "self", ".", "quantizer", ".", "max", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QInitializer.get_config": [[129, 134], ["None"], "methods", ["None"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "return", "{", "\n", "\"initializer\"", ":", "self", ".", "initializer", ",", "\n", "\"use_scale\"", ":", "self", ".", "use_scale", ",", "\n", "\"quantizer\"", ":", "self", ".", "quantizer", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QInitializer.from_config": [[136, 143], ["cls", "qlayers.get_initializer", "quantizers.get_quantizer"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_initializer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "config", ")", ":", "\n", "    ", "config", "=", "{", "\n", "'initializer'", ":", "get_initializer", "(", "config", "[", "'initializer'", "]", ")", ",", "\n", "'use_scale'", ":", "config", "[", "'use_scale'", "]", ",", "\n", "'quantizer'", ":", "get_quantizer", "(", "config", "[", "'quantizer'", "]", ")", "}", "\n", "return", "cls", "(", "**", "config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QActivation.__init__": [[153, 175], ["tensorflow.keras.layers.Layer.__init__", "isinstance", "hasattr", "quantizers.get_quantizer", "hasattr", "ValueError", "hasattr"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer"], ["def", "__init__", "(", "self", ",", "activation", ",", "**", "kwargs", ")", ":", "\n", "\n", "    ", "super", "(", "QActivation", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n", "self", ".", "activation", "=", "activation", "\n", "\n", "if", "not", "isinstance", "(", "activation", ",", "six", ".", "string_types", ")", ":", "\n", "      ", "self", ".", "quantizer", "=", "activation", "\n", "if", "hasattr", "(", "self", ".", "quantizer", ",", "\"__name__\"", ")", ":", "\n", "        ", "self", ".", "__name__", "=", "self", ".", "quantizer", ".", "__name__", "\n", "", "elif", "hasattr", "(", "self", ".", "quantizer", ",", "\"name\"", ")", ":", "\n", "        ", "self", ".", "__name__", "=", "self", ".", "quantizer", ".", "name", "\n", "", "elif", "hasattr", "(", "self", ".", "quantizer", ",", "\"__class__\"", ")", ":", "\n", "        ", "self", ".", "__name__", "=", "self", ".", "quantizer", ".", "__class__", ".", "__name__", "\n", "", "return", "\n", "\n", "", "self", ".", "__name__", "=", "activation", "\n", "\n", "try", ":", "\n", "      ", "self", ".", "quantizer", "=", "get_quantizer", "(", "activation", ")", "\n", "", "except", "KeyError", ":", "\n", "      ", "raise", "ValueError", "(", "\"invalid activation '{}'\"", ".", "format", "(", "activation", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QActivation.call": [[176, 178], ["qlayers.QActivation.quantizer"], "methods", ["None"], ["", "", "def", "call", "(", "self", ",", "inputs", ")", ":", "\n", "    ", "return", "self", ".", "quantizer", "(", "inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QActivation.get_config": [[179, 183], ["super().get_config", "dict", "list", "list", "super().get_config.items", "config.items"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\"activation\"", ":", "self", ".", "activation", "}", "\n", "base_config", "=", "super", "(", "QActivation", ",", "self", ")", ".", "get_config", "(", ")", "\n", "return", "dict", "(", "list", "(", "base_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QActivation.get_quantization_config": [[184, 186], ["str"], "methods", ["None"], ["", "def", "get_quantization_config", "(", "self", ")", ":", "\n", "    ", "return", "str", "(", "self", ".", "activation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QActivation.compute_output_shape": [[187, 189], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "    ", "return", "input_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QActivation.get_prunable_weights": [[190, 192], ["None"], "methods", ["None"], ["", "def", "get_prunable_weights", "(", "self", ")", ":", "\n", "    ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.__init__": [[202, 325], ["tensorflow.keras.layers.Layer.__init__", "isinstance", "ValueError", "quantizers.get_quantizer", "ValueError", "print", "tensorflow.Variable", "tensorflow.Variable", "print", "tensorflow.Variable", "tensorflow.Variable", "print", "ValueError"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer"], ["def", "__init__", "(", "self", ",", "\n", "activation", ",", "\n", "total_bits", ",", "\n", "current_step", "=", "None", ",", "\n", "symmetric", "=", "True", ",", "\n", "quantization_delay", "=", "0", ",", "\n", "ema_freeze_delay", "=", "None", ",", "\n", "ema_decay", "=", "0.9999", ",", "\n", "per_channel", "=", "False", ",", "\n", "po2_rounding", "=", "False", ",", "\n", "relu_neg_slope", "=", "0.0", ",", "\n", "relu_upper_bound", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Initializes this QAdaptiveActivation layer.\n\n    Args:\n      activation: Str. The activation quantizer type to use for this activation\n        layer, such as 'quantized_relu'. Should be a string with no params.\n      total_bits: Int. The total bits that can be used by the quantizer\n      current_step: tf.Variable specifying the current step in training.\n        You can find this by passing model.optimizer.iterations\n        (see tf.keras.optimizers.Optimizer.iterations). If set to None, the\n        layer will attempt to estimate the current step itself, but please note\n        that this number may not always match the optimizer step.\n      symmetric: Bool. If to enforce symmetry about the origin in the quantized\n        bit representation of the value. When using linear activation, this\n        should be True for best results.\n      quantization_delay: Int. How many training steps to wait until quantizing\n        the activation values.\n      ema_freeze_delay: Int. Steps to wait until stopping the update of the\n        exponential moving average values. Set to None for an infinite delay.\n      ema_decay: Float. The decay value used for exponential moving average (see\n        tf.keras.backend.moving_average_update)\n      per_channel: Bool. If to quantize the activation values on a\n        per-channel basis.\n      po2_rounding: Bool. If true, the EMA max value is rounded to the nearest\n        power-of-2. If false, the EMA max value is rounded up (with ceil) to a\n        power-of-two. These power-of-two operations are necessary to calculate\n        the number of integer bits used in the quantizer, and the difference\n        between using round and ceil trade off the quantizer's range and\n        precision.\n      relu_neg_slope: Float. Slope of the negative values in relu to enable the\n        use of leaky relu. This parameter will only be used with the quantizer\n        type quantized_relu. Set to 0.0 to use normal relu.\n      relu_upper_bound: Float. The upper bound to use if the activation is set\n        to relu. Set to None to not artificially set an upper bound. Pease note\n        that this param is ignored if the activation is not quantized_relu\n      **kwargs: Args passed to the Layer class.\n    \"\"\"", "\n", "super", "(", "QAdaptiveActivation", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n", "self", ".", "total_bits", "=", "total_bits", "\n", "self", ".", "symmetric", "=", "symmetric", "\n", "self", ".", "is_estimating_step_count", "=", "False", "# If the layer should estimate its", "\n", "# own step count by incrementing it", "\n", "# every call.", "\n", "if", "isinstance", "(", "current_step", ",", "tf", ".", "Variable", ")", ":", "\n", "      ", "self", ".", "step", "=", "current_step", "\n", "", "elif", "current_step", "is", "None", ":", "\n", "      ", "self", ".", "step", "=", "tf", ".", "Variable", "(", "-", "1", ",", "dtype", "=", "tf", ".", "int64", ")", "\n", "self", ".", "is_estimating_step_count", "=", "True", "\n", "print", "(", "\"[WARNING] QAdaptiveActivation is estimating it's own training \"", "\n", "\"step count, which may not always be the same as the true optimizer\"", "\n", "\" training step. To mitigate this, please set the current_step \"", "\n", "\"parameter when initializing QAdaptiveActivation\"", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "", "else", ":", "\n", "      ", "self", ".", "step", "=", "tf", ".", "Variable", "(", "current_step", ",", "dtype", "=", "tf", ".", "int64", ")", "\n", "print", "(", "\"[WARNING] QAdaptiveActivation is disconnected from the optimizer \"", "\n", "\"current step, which may lead to incorrect training. If you wish to\"", "\n", "\" resume training, set this layer's self.step to the optimizer's \"", "\n", "\"tf.Variable current step\"", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "", "self", ".", "quantization_delay", "=", "quantization_delay", "\n", "self", ".", "ema_freeze_delay", "=", "ema_freeze_delay", "\n", "self", ".", "will_ema_freeze", "=", "True", "if", "ema_freeze_delay", "else", "False", "\n", "self", ".", "ema_decay", "=", "ema_decay", "\n", "self", ".", "per_channel", "=", "per_channel", "\n", "self", ".", "po2_rounding", "=", "po2_rounding", "\n", "self", ".", "ema_min", "=", "None", "\n", "self", ".", "ema_max", "=", "None", "\n", "self", ".", "relu_neg_slope", "=", "relu_neg_slope", "\n", "self", ".", "relu_upper_bound", "=", "relu_upper_bound", "\n", "\n", "# Verify quantizer type is correct", "\n", "self", ".", "supported_quantizers", "=", "[", "\"quantized_bits\"", ",", "\"quantized_relu\"", "]", "\n", "if", "activation", "not", "in", "self", ".", "supported_quantizers", ":", "\n", "      ", "raise", "ValueError", "(", "(", "\"Invalid activation {}. Activation quantizer may NOT \"", "\n", "\"contain any parameters (they will be set automatically\"", "\n", "\" by this layer), and only the quantizer types {} are \"", "\n", "\"supported.\"", ")", ".", "format", "(", "activation", ",", "\n", "self", ".", "supported_quantizers", ")", ")", "\n", "\n", "# Get the quantizer associated with the activation", "\n", "", "try", ":", "\n", "      ", "self", ".", "quantizer", "=", "get_quantizer", "(", "activation", ")", "\n", "", "except", "KeyError", ":", "\n", "      ", "raise", "ValueError", "(", "\"Invalid activation '{}'\"", ".", "format", "(", "activation", ")", ")", "\n", "\n", "# Check that the quantizer is supported", "\n", "", "if", "self", ".", "quantizer", ".", "__class__", ".", "__name__", "not", "in", "self", ".", "supported_quantizers", ":", "\n", "      ", "raise", "ValueError", "(", "\"Unsupported activation quantizer '{}'\"", ".", "format", "(", "\n", "self", ".", "quantizer", ".", "__class__", ".", "__name__", ")", ")", "\n", "\n", "# Set keep_negative", "\n", "", "if", "self", ".", "quantizer", ".", "__class__", ".", "__name__", "==", "\"quantized_relu\"", ":", "\n", "      ", "self", ".", "quantizer", ".", "is_quantized_clip", "=", "False", "# Use relu_upper_bound instead", "\n", "if", "self", ".", "relu_upper_bound", ":", "\n", "        ", "self", ".", "quantizer", ".", "relu_upper_bound", "=", "self", ".", "relu_upper_bound", "\n", "", "self", ".", "quantizer", ".", "negative_slope", "=", "relu_neg_slope", "\n", "self", ".", "keep_negative", "=", "relu_neg_slope", "!=", "0.0", "\n", "self", ".", "quantizer", ".", "is_quantized_clip", "=", "False", "# Use normal relu when qnoise=0", "\n", "", "elif", "self", ".", "quantizer", ".", "__class__", ".", "__name__", "==", "\"quantized_bits\"", ":", "\n", "      ", "self", ".", "keep_negative", "=", "True", "\n", "self", ".", "quantizer", ".", "keep_negative", "=", "True", "\n", "\n", "# If not using quantization delay, then print warning", "\n", "", "if", "self", ".", "quantization_delay", "<", "1", ":", "\n", "      ", "print", "(", "\"[WARNING] If QAdaptiveActivation has the quantization_delay set \"", "\n", "\"to 0, then the moving averages will be heavily biased towards the \"", "\n", "\"initial quantizer configuration, which will likely prevent the \"", "\n", "\"model from converging. Consider a larger quantization_delay.\"", ",", "\n", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "", "self", ".", "activation", "=", "self", ".", "quantizer", "# self.activation is used by QTools", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.build": [[326, 371], ["tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.Variable", "tensorflow.Variable", "quantizers._get_integer_bits", "qlayers.QAdaptiveActivation.quantizer.integer.assign", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.zeros", "tensorflow.zeros", "tensorflow.image_data_format", "tensorflow.image_data_format", "isinstance", "list", "input_shape.as_list", "tensorflow.zeros", "tensorflow.zeros", "tensorflow.zeros", "tensorflow.zeros"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_integer_bits"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "    ", "if", "self", ".", "will_ema_freeze", ":", "\n", "      ", "self", ".", "ema_freeze_delay", "=", "tf", ".", "constant", "(", "self", ".", "ema_freeze_delay", ",", "dtype", "=", "tf", ".", "int64", ")", "\n", "\n", "", "self", ".", "ema_decay", "=", "tf", ".", "constant", "(", "self", ".", "ema_decay", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "self", ".", "is_estimating_step_count", "=", "tf", ".", "constant", "(", "self", ".", "is_estimating_step_count", ",", "\n", "dtype", "=", "tf", ".", "bool", ")", "\n", "\n", "# Calculate the number of channels", "\n", "channel_index", "=", "-", "1", "if", "K", ".", "image_data_format", "(", ")", "==", "\"channels_last\"", "else", "1", "\n", "if", "self", ".", "per_channel", ":", "\n", "      ", "input_shape_list", "=", "list", "(", "input_shape", ")", "if", "isinstance", "(", "\n", "input_shape", ",", "tuple", ")", "else", "input_shape", ".", "as_list", "(", ")", "\n", "num_channels", "=", "tf", ".", "constant", "(", "input_shape_list", "[", "channel_index", "]", ",", "\n", "shape", "=", "(", "1", ")", ",", "dtype", "=", "tf", ".", "int64", ")", "\n", "", "else", ":", "\n", "      ", "num_channels", "=", "tf", ".", "constant", "(", "1", ",", "shape", "=", "(", "1", ")", ",", "dtype", "=", "tf", ".", "int64", ")", "\n", "\n", "# Initialize the moving mins and max", "\n", "", "if", "self", ".", "ema_min", "is", "None", "or", "self", ".", "ema_max", "is", "None", ":", "\n", "      ", "self", ".", "ema_min", "=", "tf", ".", "Variable", "(", "tf", ".", "zeros", "(", "num_channels", ")", ",", "name", "=", "\"ema_min\"", ",", "\n", "trainable", "=", "False", ")", "\n", "self", ".", "ema_max", "=", "tf", ".", "Variable", "(", "tf", ".", "zeros", "(", "num_channels", ")", ",", "name", "=", "\"ema_max\"", ",", "\n", "trainable", "=", "False", ")", "\n", "\n", "# Determine the parameters for the quantizer", "\n", "", "self", ".", "quantizer", ".", "bits", "=", "self", ".", "total_bits", "\n", "\n", "# Set up the initial integer bits and quantizer params", "\n", "self", ".", "quantizer", ".", "integer", "=", "tf", ".", "Variable", "(", "tf", ".", "zeros", "(", "num_channels", ",", "\n", "dtype", "=", "tf", ".", "int32", ")", ",", "\n", "name", "=", "\"quantizer_integer_bits\"", ",", "\n", "trainable", "=", "False", ")", "\n", "integer_bits", "=", "_get_integer_bits", "(", "min_value", "=", "self", ".", "ema_min", ",", "\n", "max_value", "=", "self", ".", "ema_max", ",", "\n", "bits", "=", "self", ".", "total_bits", ",", "\n", "symmetric", "=", "self", ".", "symmetric", ",", "\n", "keep_negative", "=", "self", ".", "keep_negative", ",", "\n", "is_clipping", "=", "self", ".", "po2_rounding", ")", "\n", "self", ".", "quantizer", ".", "integer", ".", "assign", "(", "integer_bits", ")", "\n", "self", ".", "quantizer", ".", "alpha", "=", "1.0", "# Setting alpha to 1.0 allows the integer bits", "\n", "# to serve as the scale", "\n", "self", ".", "quantizer", ".", "symmetric", "=", "self", ".", "symmetric", "\n", "self", ".", "quantization_delay", "=", "tf", ".", "constant", "(", "self", ".", "quantization_delay", ",", "\n", "dtype", "=", "tf", ".", "int64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.call": [[372, 452], ["qlayers.QAdaptiveActivation.step.assign_add", "len", "tensorflow.constant", "tensorflow.constant", "tensorflow.python.framework.smart_cond.smart_cond", "tensorflow.python.framework.smart_cond.smart_cond", "quantizers._get_integer_bits", "qlayers.QAdaptiveActivation.quantizer.integer.assign", "tensorflow.switch", "tensorflow.switch", "tensorflow.switch", "tensorflow.switch", "qlayers.QAdaptiveActivation.quantizer.update_qnoise_factor", "qlayers.QAdaptiveActivation.quantizer", "qlayers.QAdaptiveActivation.quantizer.update_qnoise_factor", "qlayers.QAdaptiveActivation.quantizer", "tensorflow.cond", "tensorflow.cond", "tensorflow.identity", "tensorflow.identity", "qlayers.QAdaptiveActivation.quantizer.update_qnoise_factor", "qlayers.QAdaptiveActivation.quantizer", "tensorflow.squeeze", "tensorflow.squeeze", "tensorflow.moving_average_update", "tensorflow.moving_average_update", "tensorflow.squeeze", "tensorflow.squeeze", "tensorflow.moving_average_update", "tensorflow.moving_average_update", "qlayers.QAdaptiveActivation.quantizer.update_qnoise_factor", "tensorflow.math.logical_and", "tensorflow.math.logical_and", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.greater_equal", "tensorflow.greater_equal", "tensorflow.constant", "tensorflow.constant", "list", "tensorflow.greater", "tensorflow.greater", "tensorflow.constant", "tensorflow.constant", "tensorflow.min", "tensorflow.min", "tensorflow.max", "tensorflow.max", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.image_data_format", "tensorflow.image_data_format", "list", "list", "range", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "range", "range"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers._get_integer_bits", "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor", "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor", "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor", "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "call", "(", "self", ",", "inputs", ",", "training", "=", "False", ")", ":", "\n", "    ", "x", "=", "inputs", "\n", "training", "=", "training", "and", "self", ".", "trainable", "\n", "self", ".", "will_ema_freeze", "=", "self", ".", "will_ema_freeze", "and", "self", ".", "trainable", "\n", "\n", "# Update the step count if the optimizer step count is unknown", "\n", "self", ".", "step", ".", "assign_add", "(", "K", ".", "switch", "(", "\n", "tf", ".", "math", ".", "logical_and", "(", "self", ".", "is_estimating_step_count", ",", "training", ")", ",", "\n", "tf", ".", "constant", "(", "1", ",", "tf", ".", "int64", ")", ",", "tf", ".", "constant", "(", "0", ",", "tf", ".", "int64", ")", ")", ")", "\n", "\n", "# Perform the quantization", "\n", "if", "training", ":", "\n", "# Calculate the qnoise, a scalar from 0 to 1 that represents the level of", "\n", "# quantization noise to use. At training start, we want no quantization,", "\n", "# so qnoise_factor = 0.0. After quantization_delay steps, we want normal", "\n", "# quantization, so qnoise_factor = 1.0.", "\n", "      ", "qnoise_factor", "=", "K", ".", "switch", "(", "\n", "tf", ".", "greater_equal", "(", "self", ".", "step", ",", "self", ".", "quantization_delay", ")", ",", "\n", "lambda", ":", "tf", ".", "constant", "(", "1.0", ")", ",", "lambda", ":", "tf", ".", "constant", "(", "0.0", ")", ")", "\n", "self", ".", "quantizer", ".", "update_qnoise_factor", "(", "qnoise_factor", ")", "\n", "qx", "=", "self", ".", "quantizer", "(", "x", ")", "\n", "\n", "", "else", ":", "# If not training, we always want to use full quantization", "\n", "      ", "self", ".", "quantizer", ".", "update_qnoise_factor", "(", "tf", ".", "constant", "(", "1.0", ")", ")", "\n", "qx", "=", "self", ".", "quantizer", "(", "x", ")", "\n", "\n", "# Calculate the axis along where to find the min and max EMAs", "\n", "", "len_axis", "=", "len", "(", "x", ".", "shape", ")", "\n", "if", "len_axis", ">", "1", ":", "\n", "      ", "if", "self", ".", "per_channel", ":", "\n", "        ", "if", "K", ".", "image_data_format", "(", ")", "==", "\"channels_last\"", ":", "\n", "          ", "axis", "=", "list", "(", "range", "(", "len_axis", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "          ", "axis", "=", "list", "(", "range", "(", "1", ",", "len_axis", ")", ")", "\n", "", "", "else", ":", "\n", "        ", "axis", "=", "list", "(", "range", "(", "len_axis", ")", ")", "\n", "", "", "else", ":", "\n", "      ", "axis", "=", "[", "0", "]", "\n", "\n", "# Determine if freezing the EMA", "\n", "", "is_ema_training", "=", "tf", ".", "constant", "(", "training", ",", "dtype", "=", "tf", ".", "bool", ")", "\n", "if", "self", ".", "will_ema_freeze", ":", "\n", "      ", "is_ema_training", "=", "tf", ".", "cond", "(", "\n", "tf", ".", "greater", "(", "self", ".", "step", ",", "self", ".", "ema_freeze_delay", ")", ",", "\n", "lambda", ":", "tf", ".", "constant", "(", "False", ")", ",", "lambda", ":", "tf", ".", "constant", "(", "True", ")", ")", "\n", "\n", "", "def", "update_branch", "(", ")", ":", "\n", "      ", "\"\"\" Update the moving average when is_ema_training is True.\"\"\"", "\n", "\n", "# Set the qnoise factor to 0 to update the EMA using the unquantized input", "\n", "prev_qnoise_factor", "=", "tf", ".", "identity", "(", "self", ".", "quantizer", ".", "qnoise_factor", ")", "\n", "self", ".", "quantizer", ".", "update_qnoise_factor", "(", "tf", ".", "constant", "(", "0.0", ")", ")", "\n", "\n", "# Update the EMA", "\n", "act_x", "=", "self", ".", "quantizer", "(", "x", ")", "# act_x is the input after the activation", "\n", "# function, but before the quantizer. This is", "\n", "# done by using a qnoise_factor of 0", "\n", "new_min", "=", "tf", ".", "squeeze", "(", "K", ".", "min", "(", "act_x", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", ")", "\n", "K", ".", "moving_average_update", "(", "self", ".", "ema_min", ",", "new_min", ",", "self", ".", "ema_decay", ")", "\n", "new_max", "=", "tf", ".", "squeeze", "(", "K", ".", "max", "(", "act_x", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", ")", "\n", "K", ".", "moving_average_update", "(", "self", ".", "ema_max", ",", "new_max", ",", "self", ".", "ema_decay", ")", "\n", "\n", "# Reset the qnoise factor to the previous value", "\n", "self", ".", "quantizer", ".", "update_qnoise_factor", "(", "prev_qnoise_factor", ")", "\n", "\n", "# Update the moving average when is_ema_training is True", "\n", "", "tf_utils", ".", "smart_cond", "(", "\n", "is_ema_training", ",", "true_fn", "=", "update_branch", ",", "false_fn", "=", "lambda", ":", "None", ")", "\n", "\n", "# Set the integer bits for the quantizer", "\n", "integer_bits", "=", "_get_integer_bits", "(", "\n", "min_value", "=", "self", ".", "ema_min", ",", "\n", "max_value", "=", "self", ".", "ema_max", ",", "\n", "bits", "=", "self", ".", "total_bits", ",", "\n", "symmetric", "=", "self", ".", "symmetric", ",", "\n", "keep_negative", "=", "self", ".", "keep_negative", ",", "\n", "is_clipping", "=", "self", ".", "po2_rounding", ")", "\n", "self", ".", "quantizer", ".", "integer", ".", "assign", "(", "integer_bits", ")", "\n", "\n", "return", "qx", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.get_weights": [[454, 456], ["None"], "methods", ["None"], ["", "def", "get_weights", "(", "self", ")", ":", "\n", "    ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights": [[458, 460], ["None"], "methods", ["None"], ["", "def", "set_weights", "(", "self", ",", "weights", ")", ":", "\n", "    ", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.get_config": [[461, 476], ["super().get_config", "dict", "qlayers.QAdaptiveActivation.step.numpy", "numpy.array", "numpy.array", "numpy.array", "list", "list", "super().get_config.items", "config.items"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "\"activation\"", ":", "self", ".", "quantizer", ".", "__class__", ".", "__name__", ",", "\n", "\"total_bits\"", ":", "self", ".", "total_bits", ",", "\n", "\"current_step\"", ":", "self", ".", "step", ".", "numpy", "(", ")", ",", "\n", "\"symmetric\"", ":", "self", ".", "symmetric", ",", "\n", "\"quantization_delay\"", ":", "np", ".", "array", "(", "self", ".", "quantization_delay", ")", ",", "\n", "\"ema_freeze_delay\"", ":", "np", ".", "array", "(", "self", ".", "ema_freeze_delay", ")", ",", "\n", "\"ema_decay\"", ":", "np", ".", "array", "(", "self", ".", "ema_decay", ")", ",", "\n", "\"per_channel\"", ":", "self", ".", "per_channel", ",", "\n", "\"po2_rounding\"", ":", "self", ".", "po2_rounding", ",", "\n", "\"relu_neg_slope\"", ":", "self", ".", "relu_neg_slope", "\n", "}", "\n", "base_config", "=", "super", "(", "QAdaptiveActivation", ",", "self", ")", ".", "get_config", "(", ")", "\n", "return", "dict", "(", "list", "(", "base_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.get_quantization_config": [[477, 480], ["numpy.array", "str"], "methods", ["None"], ["", "def", "get_quantization_config", "(", "self", ")", ":", "\n", "    ", "self", ".", "quantizer", ".", "integer_bits", "=", "np", ".", "array", "(", "self", ".", "quantizer", ")", "\n", "return", "str", "(", "self", ".", "quantizer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.compute_output_shape": [[481, 483], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "    ", "return", "input_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.get_prunable_weights": [[484, 486], ["None"], "methods", ["None"], ["", "def", "get_prunable_weights", "(", "self", ")", ":", "\n", "    ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.Clip.__init__": [[504, 515], ["tensorflow.keras.constraints.get", "tensorflow.keras.constraints.get", "isinstance", "quantizers.get_quantizer"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer"], ["def", "__init__", "(", "self", ",", "min_value", "=", "0.0", ",", "max_value", "=", "1.0", ",", "\n", "constraint", "=", "None", ",", "quantizer", "=", "None", ")", ":", "\n", "    ", "\"\"\"Initializes Clip constraint class.\"\"\"", "\n", "\n", "self", ".", "min_value", "=", "min_value", "\n", "self", ".", "max_value", "=", "max_value", "\n", "self", ".", "constraint", "=", "constraints", ".", "get", "(", "constraint", ")", "\n", "# Don't wrap yourself", "\n", "if", "isinstance", "(", "self", ".", "constraint", ",", "Clip", ")", ":", "\n", "      ", "self", ".", "constraint", "=", "None", "\n", "", "self", ".", "quantizer", "=", "get_quantizer", "(", "quantizer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.Clip.__call__": [[516, 524], ["tensorflow.keras.backend.clip", "tensorflow.keras.backend.clip", "qlayers.Clip.constraint", "qlayers.Clip.quantizer"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "w", ")", ":", "\n", "    ", "\"\"\"Clips values between min and max values.\"\"\"", "\n", "if", "self", ".", "constraint", ":", "\n", "      ", "w", "=", "self", ".", "constraint", "(", "w", ")", "\n", "if", "self", ".", "quantizer", ":", "\n", "        ", "w", "=", "self", ".", "quantizer", "(", "w", ")", "\n", "", "", "w", "=", "tf", ".", "keras", ".", "backend", ".", "clip", "(", "w", ",", "self", ".", "min_value", ",", "self", ".", "max_value", ")", "\n", "return", "w", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.Clip.get_config": [[525, 528], ["None"], "methods", ["None"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "\"\"\"Returns configuration of constraint class.\"\"\"", "\n", "return", "{", "\"min_value\"", ":", "self", ".", "min_value", ",", "\"max_value\"", ":", "self", ".", "max_value", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.Clip.from_config": [[529, 536], ["isinstance", "tensorflow.keras.constraints.get", "tensorflow.keras.constraints.get", "quantizers.get_quantizer", "cls", "config.get", "config.get", "config.get"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "config", ")", ":", "\n", "    ", "if", "isinstance", "(", "config", ".", "get", "(", "'constraint'", ",", "None", ")", ",", "Clip", ")", ":", "\n", "      ", "config", "[", "'constraint'", "]", "=", "None", "\n", "", "config", "[", "'constraint'", "]", "=", "constraints", ".", "get", "(", "config", ".", "get", "(", "'constraint'", ",", "None", ")", ")", "\n", "config", "[", "'quantizer'", "]", "=", "get_quantizer", "(", "config", ".", "get", "(", "'quantizer'", ",", "None", ")", ")", "\n", "return", "cls", "(", "**", "config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QDense.__init__": [[561, 626], ["quantizers.get_quantizer", "quantizers.get_quantizer", "hasattr", "qlayers.get_auto_range_constraint_initializer", "tensorflow.keras.layers.Dense.__init__", "warnings.warn", "warnings.warn", "qlayers.QDense.kernel_quantizer_internal._set_trainable_parameter", "qlayers.get_auto_range_constraint_initializer", "quantizers.get_quantizer"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary._set_trainable_parameter", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer"], ["def", "__init__", "(", "self", ",", "\n", "units", ",", "\n", "activation", "=", "None", ",", "\n", "use_bias", "=", "True", ",", "\n", "kernel_initializer", "=", "\"he_normal\"", ",", "\n", "bias_initializer", "=", "\"zeros\"", ",", "\n", "kernel_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "activity_regularizer", "=", "None", ",", "\n", "kernel_constraint", "=", "None", ",", "\n", "bias_constraint", "=", "None", ",", "\n", "kernel_quantizer", "=", "None", ",", "\n", "bias_quantizer", "=", "None", ",", "\n", "kernel_range", "=", "None", ",", "\n", "bias_range", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "    ", "if", "kernel_range", "is", "not", "None", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"kernel_range is deprecated in QDense layer.\"", ")", "\n", "\n", "", "if", "bias_range", "is", "not", "None", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"bias_range is deprecated in QDense layer.\"", ")", "\n", "\n", "", "self", ".", "kernel_range", "=", "kernel_range", "\n", "self", ".", "bias_range", "=", "bias_range", "\n", "\n", "self", ".", "kernel_quantizer", "=", "kernel_quantizer", "\n", "self", ".", "bias_quantizer", "=", "bias_quantizer", "\n", "\n", "self", ".", "kernel_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "kernel_quantizer", ")", "\n", "self", ".", "bias_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "bias_quantizer", ")", "\n", "\n", "# optimize parameter set to \"auto\" scaling mode if possible", "\n", "if", "hasattr", "(", "self", ".", "kernel_quantizer_internal", ",", "\"_set_trainable_parameter\"", ")", ":", "\n", "      ", "self", ".", "kernel_quantizer_internal", ".", "_set_trainable_parameter", "(", ")", "\n", "\n", "", "self", ".", "quantizers", "=", "[", "\n", "self", ".", "kernel_quantizer_internal", ",", "self", ".", "bias_quantizer_internal", "\n", "]", "\n", "\n", "kernel_constraint", ",", "kernel_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "kernel_quantizer_internal", ",", "\n", "kernel_constraint", ",", "\n", "kernel_initializer", ")", ")", "\n", "\n", "if", "use_bias", ":", "\n", "      ", "bias_constraint", ",", "bias_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "bias_quantizer_internal", ",", "\n", "bias_constraint", ",", "\n", "bias_initializer", ")", ")", "\n", "", "if", "activation", "is", "not", "None", ":", "\n", "      ", "activation", "=", "get_quantizer", "(", "activation", ")", "\n", "\n", "", "super", "(", "QDense", ",", "self", ")", ".", "__init__", "(", "\n", "units", "=", "units", ",", "\n", "activation", "=", "activation", ",", "\n", "use_bias", "=", "use_bias", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "activity_regularizer", "=", "activity_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QDense.call": [[627, 643], ["tensorflow.keras.backend.dot", "tensorflow.keras.backend.dot", "qlayers.QDense.kernel_quantizer_internal", "tensorflow.keras.backend.bias_add", "tensorflow.keras.backend.bias_add", "qlayers.QDense.activation", "qlayers.QDense.bias_quantizer_internal"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.kernel_quantizer_internal", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QBidirectional.activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.bias_quantizer_internal"], ["", "def", "call", "(", "self", ",", "inputs", ")", ":", "\n", "    ", "if", "self", ".", "kernel_quantizer", ":", "\n", "      ", "quantized_kernel", "=", "self", ".", "kernel_quantizer_internal", "(", "self", ".", "kernel", ")", "\n", "", "else", ":", "\n", "      ", "quantized_kernel", "=", "self", ".", "kernel", "\n", "", "output", "=", "tf", ".", "keras", ".", "backend", ".", "dot", "(", "inputs", ",", "quantized_kernel", ")", "\n", "if", "self", ".", "use_bias", ":", "\n", "      ", "if", "self", ".", "bias_quantizer", ":", "\n", "        ", "quantized_bias", "=", "self", ".", "bias_quantizer_internal", "(", "self", ".", "bias", ")", "\n", "", "else", ":", "\n", "        ", "quantized_bias", "=", "self", ".", "bias", "\n", "", "output", "=", "tf", ".", "keras", ".", "backend", ".", "bias_add", "(", "output", ",", "quantized_bias", ",", "\n", "data_format", "=", "\"channels_last\"", ")", "\n", "", "if", "self", ".", "activation", "is", "not", "None", ":", "\n", "      ", "output", "=", "self", ".", "activation", "(", "output", ")", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QDense.compute_output_shape": [[644, 650], ["list", "tuple", "len"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "    ", "assert", "input_shape", "and", "len", "(", "input_shape", ")", ">=", "2", "\n", "assert", "input_shape", "[", "-", "1", "]", "\n", "output_shape", "=", "list", "(", "input_shape", ")", "\n", "output_shape", "[", "-", "1", "]", "=", "self", ".", "units", "\n", "return", "tuple", "(", "output_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QDense.get_config": [[651, 679], ["super().get_config", "dict", "tensorflow.keras.activations.serialize", "tensorflow.keras.activations.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "list", "list", "super().get_config.items", "config.items"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "\"units\"", ":", "self", ".", "units", ",", "\n", "\"activation\"", ":", "activations", ".", "serialize", "(", "self", ".", "activation", ")", ",", "\n", "\"use_bias\"", ":", "self", ".", "use_bias", ",", "\n", "\"kernel_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "kernel_quantizer_internal", ")", ",", "\n", "\"bias_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "bias_quantizer_internal", ")", ",", "\n", "\"kernel_initializer\"", ":", "\n", "initializers", ".", "serialize", "(", "self", ".", "kernel_initializer", ")", ",", "\n", "\"bias_initializer\"", ":", "\n", "initializers", ".", "serialize", "(", "self", ".", "bias_initializer", ")", ",", "\n", "\"kernel_regularizer\"", ":", "\n", "regularizers", ".", "serialize", "(", "self", ".", "kernel_regularizer", ")", ",", "\n", "\"bias_regularizer\"", ":", "\n", "regularizers", ".", "serialize", "(", "self", ".", "bias_regularizer", ")", ",", "\n", "\"activity_regularizer\"", ":", "\n", "regularizers", ".", "serialize", "(", "self", ".", "activity_regularizer", ")", ",", "\n", "\"kernel_constraint\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "kernel_constraint", ")", ",", "\n", "\"bias_constraint\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "bias_constraint", ")", ",", "\n", "\"kernel_range\"", ":", "self", ".", "kernel_range", ",", "\n", "\"bias_range\"", ":", "self", ".", "bias_range", "\n", "}", "\n", "base_config", "=", "super", "(", "QDense", ",", "self", ")", ".", "get_config", "(", ")", "\n", "return", "dict", "(", "list", "(", "base_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QDense.get_quantization_config": [[680, 689], ["str", "str", "str", "str"], "methods", ["None"], ["", "def", "get_quantization_config", "(", "self", ")", ":", "\n", "    ", "return", "{", "\n", "\"kernel_quantizer\"", ":", "\n", "str", "(", "self", ".", "kernel_quantizer_internal", ")", ",", "\n", "\"bias_quantizer\"", ":", "\n", "str", "(", "self", ".", "bias_quantizer_internal", ")", ",", "\n", "\"activation\"", ":", "\n", "str", "(", "self", ".", "activation", ")", ",", "\n", "\"units\"", ":", "str", "(", "self", ".", "units", ")", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QDense.get_quantizers": [[691, 693], ["None"], "methods", ["None"], ["", "def", "get_quantizers", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "quantizers", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QDense.get_prunable_weights": [[694, 696], ["None"], "methods", ["None"], ["", "def", "get_prunable_weights", "(", "self", ")", ":", "\n", "    ", "return", "[", "self", ".", "kernel", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer": [[61, 87], ["qlayers.get_constraint", "qlayers.get_initializer", "qlayers.QInitializer", "hasattr", "isinstance"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_constraint", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_initializer"], ["def", "get_auto_range_constraint_initializer", "(", "quantizer", ",", "constraint", ",", "initializer", ")", ":", "\n", "  ", "\"\"\"Get value range automatically for quantizer.\n\n  Arguments:\n   quantizer: A quantizer class in quantizers.py.\n   constraint: A tf.keras constraint.\n   initializer: A tf.keras initializer.\n\n  Returns:\n    a tuple (constraint, initializer), where\n      constraint is clipped by Clip class in this file, based on the\n      value range of quantizer.\n      initializer is initializer contraint by value range of quantizer.\n  \"\"\"", "\n", "if", "quantizer", "is", "not", "None", ":", "\n", "    ", "constraint", "=", "get_constraint", "(", "constraint", ",", "quantizer", ")", "\n", "initializer", "=", "get_initializer", "(", "initializer", ")", "\n", "\n", "if", "initializer", "and", "initializer", ".", "__class__", ".", "__name__", "not", "in", "[", "\"Ones\"", ",", "\"Zeros\"", ",", "'QInitializer'", "]", ":", "\n", "# we want to get the max value of the quantizer that depends", "\n", "# on the distribution and scale", "\n", "      ", "if", "not", "(", "hasattr", "(", "quantizer", ",", "\"alpha\"", ")", "and", "\n", "isinstance", "(", "quantizer", ".", "alpha", ",", "six", ".", "string_types", ")", ")", ":", "\n", "        ", "initializer", "=", "QInitializer", "(", "\n", "initializer", ",", "use_scale", "=", "True", ",", "quantizer", "=", "quantizer", ")", "\n", "", "", "", "return", "constraint", ",", "initializer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_constraint": [[698, 716], ["qlayers.Clip", "isinstance", "qlayers.Clip.from_config", "tensorflow.keras.constraints.get", "hasattr", "max", "quantizer.max"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.Clip.from_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "", "def", "get_constraint", "(", "identifier", ",", "quantizer", ")", ":", "\n", "  ", "\"\"\"Gets the initializer.\n\n  Args:\n    identifier: A constraint, which could be dict, string, or callable function.\n    quantizer: A quantizer class or quantization function\n\n  Returns:\n    A constraint class\n  \"\"\"", "\n", "if", "identifier", ":", "\n", "    ", "if", "isinstance", "(", "identifier", ",", "dict", ")", "and", "identifier", "[", "'class_name'", "]", "==", "'Clip'", ":", "\n", "      ", "return", "Clip", ".", "from_config", "(", "identifier", "[", "'config'", "]", ")", "\n", "", "else", ":", "\n", "      ", "return", "constraints", ".", "get", "(", "identifier", ")", "\n", "", "", "else", ":", "\n", "    ", "max_value", "=", "max", "(", "1", ",", "quantizer", ".", "max", "(", ")", ")", "if", "hasattr", "(", "quantizer", ",", "\"max\"", ")", "else", "1.0", "\n", "return", "Clip", "(", "-", "max_value", ",", "max_value", ",", "identifier", ",", "quantizer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_initializer": [[717, 743], ["isinstance", "isinstance", "qlayers.QInitializer.from_config", "tensorflow.keras.initializers.get", "tensorflow.keras.initializers.get", "callable", "ValueError", "str"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.Clip.from_config"], ["", "", "def", "get_initializer", "(", "identifier", ")", ":", "\n", "  ", "\"\"\"Gets the initializer.\n\n  Args:\n    identifier: An initializer, which could be dict, string, or callable function.\n\n  Returns:\n    A initializer class\n\n  Raises:\n    ValueError: An error occurred when quantizer cannot be interpreted.\n  \"\"\"", "\n", "if", "identifier", "is", "None", ":", "\n", "    ", "return", "None", "\n", "", "if", "isinstance", "(", "identifier", ",", "dict", ")", ":", "\n", "    ", "if", "identifier", "[", "'class_name'", "]", "==", "'QInitializer'", ":", "\n", "      ", "return", "QInitializer", ".", "from_config", "(", "identifier", "[", "'config'", "]", ")", "\n", "", "else", ":", "\n", "      ", "return", "initializers", ".", "get", "(", "identifier", ")", "\n", "", "", "elif", "isinstance", "(", "identifier", ",", "six", ".", "string_types", ")", ":", "\n", "    ", "return", "initializers", ".", "get", "(", "identifier", ")", "\n", "", "elif", "callable", "(", "identifier", ")", ":", "\n", "    ", "return", "identifier", "\n", "", "else", ":", "\n", "    ", "raise", "ValueError", "(", "\"Could not interpret initializer identifier: \"", "+", "\n", "str", "(", "identifier", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.bn_folding_utils.convert_folded_layer_to_unfolded": [[35, 78], ["layer.get_config", "QDepthwiseConv2D.from_config.get_config", "new_layer.get_config.items", "qconvolutional.QConv2D", "qconvolutional.QConv2D.from_config", "qconvolutional.QDepthwiseConv2D", "layer.get_config.keys", "qconvolutional.QDepthwiseConv2D.from_config", "ValueError"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.Clip.from_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.Clip.from_config"], ["def", "convert_folded_layer_to_unfolded", "(", "layer", ")", ":", "\n", "  ", "\"\"\"Replace a source batchnorm folded layer with a non-folded layer.\n\n  Args:\n    layer: keras/qkeras layer type. Source layer to be replaced with\n\n  Returns:\n    new layer instance\n  \"\"\"", "\n", "\n", "# get layer config from the composite layer", "\n", "config", "=", "layer", ".", "get_config", "(", ")", "\n", "# set layer config for QConv2D layer by first creating a tmp", "\n", "# QConv2D object and generate template for its config", "\n", "if", "layer", ".", "__class__", ".", "__name__", "==", "\"QConv2DBatchnorm\"", ":", "\n", "    ", "new_layer", "=", "QConv2D", "(", "filters", "=", "1", ",", "kernel_size", "=", "(", "2", ",", "2", ")", ",", "use_bias", "=", "True", ")", "\n", "", "elif", "layer", ".", "__class__", ".", "__name__", "==", "\"QDepthwiseConv2DBatchnorm\"", ":", "\n", "    ", "new_layer", "=", "QDepthwiseConv2D", "(", "kernel_size", "=", "(", "2", ",", "2", ")", ",", "use_bias", "=", "True", ")", "\n", "", "else", ":", "\n", "# TODO(lishanok): will extend to QDense in the future", "\n", "    ", "assert", "ValueError", ",", "\"%s is not supported!\"", "%", "layer", ".", "__class__", ".", "__name__", "\n", "\n", "", "new_layer_cfg", "=", "new_layer", ".", "get_config", "(", ")", "\n", "\n", "# set qconv2d config according to the values in the composite layer", "\n", "for", "(", "key", ",", "_", ")", "in", "new_layer_cfg", ".", "items", "(", ")", ":", "\n", "    ", "if", "key", "in", "config", ".", "keys", "(", ")", ":", "\n", "      ", "new_layer_cfg", "[", "key", "]", "=", "config", "[", "key", "]", "\n", "\n", "# in case use_bias is False in the composite layer,", "\n", "#  we need to set it True because we have folded bias", "\n", "", "", "new_layer_cfg", "[", "\"use_bias\"", "]", "=", "True", "\n", "\n", "# create a non-folded, e.g., qconv2d layer from config and replace", "\n", "# old layer with it", "\n", "if", "layer", ".", "__class__", ".", "__name__", "==", "\"QConv2DBatchnorm\"", ":", "\n", "    ", "new_layer", "=", "QConv2D", ".", "from_config", "(", "new_layer_cfg", ")", "\n", "", "elif", "layer", ".", "__class__", ".", "__name__", "==", "\"QDepthwiseConv2DBatchnorm\"", ":", "\n", "    ", "new_layer", "=", "QDepthwiseConv2D", ".", "from_config", "(", "new_layer_cfg", ")", "\n", "", "else", ":", "\n", "    ", "raise", "ValueError", "(", "\"Unsupported layer conversion {}\"", ".", "format", "(", "layer", ".", "name", ")", ")", "\n", "\n", "", "return", "new_layer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.bn_folding_utils.unfold_model": [[80, 141], ["tensorflow.keras.Input", "tensorflow.keras.models.clone_model", "zip", "layer.__class__.from_config.build", "bn_folding_utils.unfold_model._clone_weights"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.clone_model", "home.repos.pwc.inspect_result.google_qkeras.networks.conv_block.ConvBlockNetwork.build"], ["", "def", "unfold_model", "(", "model", ")", ":", "\n", "  ", "\"\"\"Convert a model with batchnorm folded layer to a normal model.\n\n  \"Normal\" here refers to a model without composite folded layer such as\n  QConv2DBatchnorm layer.\n  This function replace the folded layers with a normal QConv/QDense\n  layer. It aslo sets the weights in the normal layer with the folded weights\n  in the folded layer. Model architecture could be either sequential or\n  non-sequential.\n\n  Arguments:\n    model: keras object, model with folded layers.\n\n  Returns:\n    A model that replaces folded layers (e.g., QConv2DBatchnorm) with normal\n      qkeras layers (e.g., QConv2D). This model can be passed on to hardware\n      generator so that hardware doesn't see batch normalization\n      parameters.\n  \"\"\"", "\n", "\n", "def", "_convert_folded_layer", "(", "layer", ")", ":", "\n", "    ", "if", "layer", ".", "__class__", ".", "__name__", "in", "[", "\n", "\"QConv2DBatchnorm\"", ",", "\"QDepthwiseConv2DBatchnorm\"", "]", ":", "\n", "      ", "new_layer", "=", "convert_folded_layer_to_unfolded", "(", "layer", ")", "\n", "", "else", ":", "\n", "      ", "new_layer", "=", "layer", ".", "__class__", ".", "from_config", "(", "layer", ".", "get_config", "(", ")", ")", "\n", "\n", "", "new_layer", ".", "build", "(", "layer", ".", "input_shape", ")", "\n", "return", "new_layer", "\n", "\n", "", "def", "_clone_weights", "(", "src_layer", ",", "new_layer", ")", ":", "\n", "    ", "if", "(", "src_layer", ".", "__class__", ".", "__name__", "==", "\"QConv2DBatchnorm\"", ")", "and", "(", "\n", "new_layer", ".", "__class__", ".", "__name__", "==", "\"QConv2D\"", ")", ":", "\n", "      ", "src_weights", "=", "src_layer", ".", "get_folded_weights", "(", ")", "\n", "# transfer weights from folded layer to the target layer", "\n", "folded_kernel_quantized", "=", "(", "\n", "src_weights", "[", "0", "]", ".", "numpy", "(", ")", ")", "\n", "folded_bias_quantized", "=", "(", "\n", "src_weights", "[", "1", "]", ".", "numpy", "(", ")", ")", "\n", "new_layer", ".", "set_weights", "(", "[", "folded_kernel_quantized", ",", "folded_bias_quantized", "]", ")", "\n", "\n", "", "elif", "(", "src_layer", ".", "__class__", ".", "__name__", "==", "\"QDepthwiseConv2DBatchnorm\"", ")", "and", "(", "\n", "new_layer", ".", "__class__", ".", "__name__", "==", "\"QDepthwiseConv2D\"", ")", ":", "\n", "# transfer weights from folded layer to the target layer", "\n", "      ", "src_weights", "=", "src_layer", ".", "get_folded_weights", "(", ")", "\n", "folded_depthwise_kernel_quantized", "=", "src_weights", "[", "0", "]", ".", "numpy", "(", ")", "\n", "folded_bias_quantized", "=", "src_weights", "[", "1", "]", ".", "numpy", "(", ")", "\n", "new_layer", ".", "set_weights", "(", "\n", "[", "folded_depthwise_kernel_quantized", ",", "folded_bias_quantized", "]", ")", "\n", "", "else", ":", "\n", "      ", "new_layer", ".", "set_weights", "(", "src_layer", ".", "get_weights", "(", ")", ")", "\n", "\n", "", "", "inp", "=", "Input", "(", "shape", "=", "model", ".", "input_shape", "[", "1", ":", "]", ")", "\n", "cloned_model", "=", "clone_model", "(", "\n", "model", ",", "input_tensors", "=", "inp", ",", "clone_function", "=", "_convert_folded_layer", ")", "\n", "\n", "# replace weights", "\n", "for", "(", "src_layer", ",", "new_layer", ")", "in", "zip", "(", "model", ".", "layers", ",", "cloned_model", ".", "layers", ")", ":", "\n", "    ", "_clone_weights", "(", "src_layer", ",", "new_layer", ")", "\n", "\n", "", "return", "cloned_model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.bn_folding_utils.populate_bias_quantizer_from_accumulator": [[143, 206], ["qtools.qgraph.CreateGraph", "qtools.qgraph.GraphPropagateActivationsToEdges", "qtools.generate_layer_data_type_map.generate_layer_data_type_map", "tensorflow.is_tensor", "qtools_bias_quantizer.convert_to_qkeras_quantizer", "qtools_bias_quantizer.int_bits.numpy"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.CreateGraph", "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphPropagateActivationsToEdges", "home.repos.pwc.inspect_result.google_qkeras.qtools.generate_layer_data_type_map.generate_layer_data_type_map", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_to_qkeras_quantizer"], ["", "def", "populate_bias_quantizer_from_accumulator", "(", "model", ",", "source_quantizers", ")", ":", "\n", "  ", "\"\"\"Populate the bias quantizer from accumulator type.\n\n  When user set bias_quantizer=None for layers(e.g.,\n  QConv2DBatchnorm), this function generates the accumulator type of\n  the layer MAC op and set it as the bias quantizer.\n  Such step is skipped if user provided a specific bias quantizer type.\n\n  Args:\n    model: keras/qkeras model object. If the model doesn't contain any batchnorm\n      folded layer or if the bias quanizer type in the folded layer is already\n      given, no operation needed. Else we generate the bias quantizer type and\n      set it in model.\n\n    source_quantizers: list of qkeras quantizers. A list of quantizer types\n      for model inputs.\n\n  Returns:\n    keras model object\n  \"\"\"", "\n", "default_quantizer", "=", "\"quantized_bits(8, 0, 1)\"", "\n", "\n", "# if source_quantizers is None, CreateGraph will use default_quantizer", "\n", "(", "graph", ",", "source_quantizer_list", ")", "=", "qgraph", ".", "CreateGraph", "(", "\n", "model", ",", "source_quantizers", ",", "default_quantizer", ")", "\n", "qgraph", ".", "GraphPropagateActivationsToEdges", "(", "graph", ")", "\n", "\n", "# generate the quantizer types of each layer. For folded layers, if bias", "\n", "# quantizer is not given by user, this function will generate the accumulator", "\n", "# type and set it as the bias quantizer type.", "\n", "is_inference", "=", "False", "\n", "keras_quantizer", "=", "\"quantized_bits(8, 0, 1)\"", "\n", "keras_accumulator", "=", "\"quantized_bits(8, 0, 1)\"", "\n", "for_reference", "=", "False", "\n", "layer_map", "=", "gen_map", ".", "generate_layer_data_type_map", "(", "\n", "graph", ",", "source_quantizer_list", ",", "is_inference", ",", "\n", "keras_quantizer", ",", "keras_accumulator", ",", "for_reference", ")", "\n", "\n", "for", "layer", "in", "model", ".", "layers", ":", "\n", "# TODO(lishanok): extend to other layer types if necessary", "\n", "    ", "if", "layer", ".", "__class__", ".", "__name__", "in", "[", "\n", "\"QConv2DBatchnorm\"", ",", "\"QDepthwiseConv2DBatchnorm\"", "]", ":", "\n", "      ", "if", "not", "layer", ".", "bias_quantizer", ":", "\n", "# if user didn't specify the bias quantizer, we set it as the", "\n", "# MAC accumulator type of the current layer's MAC operation", "\n", "        ", "qtools_bias_quantizer", "=", "layer_map", "[", "\"layer_data_type_map\"", "]", "[", "\n", "layer", "]", ".", "bias_quantizer", "\n", "\n", "if", "tf", ".", "is_tensor", "(", "qtools_bias_quantizer", ".", "int_bits", ")", ":", "\n", "          ", "qtools_bias_quantizer", ".", "int_bits", "=", "(", "\n", "qtools_bias_quantizer", ".", "int_bits", ".", "numpy", "(", ")", ")", "\n", "\n", "", "layer", ".", "bias_quantizer", "=", "(", "\n", "qtools_bias_quantizer", ".", "convert_to_qkeras_quantizer", "(", ")", ")", "\n", "\n", "layer", ".", "bias_quantizer_internal", "=", "layer", ".", "bias_quantizer", "\n", "if", "layer", ".", "__class__", ".", "__name__", "==", "\"QConv2DBatchnorm\"", ":", "\n", "          ", "layer", ".", "quantizers", "=", "[", "layer", ".", "kernel_quantizer_internal", ",", "\n", "layer", ".", "bias_quantizer_internal", "]", "\n", "", "elif", "layer", ".", "__class__", ".", "__name__", "==", "\"QDepthwiseConv2DBatchnorm\"", ":", "\n", "          ", "layer", ".", "quantizers", "=", "[", "layer", ".", "depthwise_quantizer_internal", ",", "\n", "layer", ".", "bias_quantizer_internal", "]", "\n", "", "", "", "", "return", "model", "\n", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qoctave.GetActivationSuffix": [[36, 55], ["re.findall", "len"], "function", ["None"], ["def", "GetActivationSuffix", "(", "activation", ")", ":", "\n", "  ", "\"\"\"Returns suffix for layer name to facilitate debugging.\"\"\"", "\n", "if", "not", "activation", ":", "\n", "    ", "return", "\"linear\"", "\n", "\n", "", "if", "\"po2\"", "in", "activation", ":", "\n", "    ", "return", "\"q2\"", "\n", "", "elif", "\"quantized_relu\"", "in", "activation", ":", "\n", "    ", "suffix", "=", "\"qr\"", "\n", "", "elif", "\"quantized_tanh\"", "in", "activation", ":", "\n", "    ", "suffix", "=", "\"qt\"", "\n", "", "else", ":", "\n", "    ", "suffix", "=", "\"qb\"", "\n", "\n", "", "numbers", "=", "re", ".", "findall", "(", "r\"[0-9]+\"", ",", "activation", ")", "\n", "\n", "numbers", "=", "[", "n", "+", "\"_\"", "if", "len", "(", "n", ")", ">", "1", "else", "n", "for", "n", "in", "numbers", "]", "\n", "\n", "return", "suffix", "+", "\"\"", ".", "join", "(", "numbers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qoctave.QOctaveConv2D": [[57, 367], ["kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "int", "qoctave.GetActivationSuffix", "qoctave.GetActivationSuffix", "x_l.shape.as_list", "tensorflow.keras.layers.Add", "tensorflow.keras.layers.Add", "qlayers.QActivation", "qlayers.QActivation", "qconvolutional.QSeparableConv2D", "qconvolutional.QConv2D", "qlayers.QActivation", "qpooling.QAveragePooling2D", "qconvolutional.QSeparableConv2D", "qconvolutional.QConv2D", "qlayers.QActivation", "qconvolutional.QSeparableConv2D", "qconvolutional.QConv2D", "qlayers.QActivation", "qconvolutional.QSeparableConv2D", "qconvolutional.QConv2D", "qlayers.QActivation", "tensorflow.keras.layers.UpSampling2D", "qconvolutional.QSeparableConv2D", "qconvolutional.QConv2D", "qlayers.QActivation"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qoctave.GetActivationSuffix", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qoctave.GetActivationSuffix"], ["", "def", "QOctaveConv2D", "(", "\n", "filters", ",", "\n", "kernel_size", ",", "\n", "alpha", ",", "\n", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "padding", "=", "\"valid\"", ",", "\n", "kernel_initializer", "=", "\"he_normal\"", ",", "\n", "bias_initializer", "=", "\"zeros\"", ",", "\n", "# NOTE: kernel_regularizer not used with separable convolution", "\n", "kernel_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "kernel_constraint", "=", "None", ",", "\n", "bias_constraint", "=", "None", ",", "\n", "use_separable", "=", "True", ",", "\n", "name", "=", "\"\"", ",", "\n", "**", "kwargs", ")", ":", "\n", "  ", "\"\"\"Implements quantized QOctaveConv2D.\"\"\"", "\n", "\n", "def", "_QOctaveConv2DInternal", "(", "x", ")", ":", "\n", "    ", "\"\"\"Computes QOctaveConv2D on a tensor.\"\"\"", "\n", "\n", "x_h", ",", "x_l", "=", "x", "\n", "\n", "bias_quantizer", "=", "kwargs", ".", "get", "(", "\"bias_quantizer\"", ",", "None", ")", "\n", "kernel_quantizer", "=", "kwargs", ".", "get", "(", "\"kernel_quantizer\"", ",", "None", ")", "\n", "depthwise_quantizer", "=", "kwargs", ".", "get", "(", "\"depthwise_quantizer\"", ",", "None", ")", "\n", "pointwise_quantizer", "=", "kwargs", ".", "get", "(", "\"pointwise_quantizer\"", ",", "None", ")", "\n", "acc_quantizer", "=", "kwargs", ".", "get", "(", "\"acc_quantizer\"", ",", "None", ")", "\n", "pooling_quantizer", "=", "kwargs", ".", "get", "(", "\"pooling_quantizer\"", ",", "None", ")", "\n", "depthwise_activation", "=", "kwargs", ".", "get", "(", "\"depthwise_activation\"", ",", "None", ")", "\n", "activation", "=", "kwargs", ".", "get", "(", "\"activation\"", ",", "None", ")", "\n", "\n", "bias_range", "=", "kwargs", ".", "get", "(", "\"bias_range\"", ",", "1.0", ")", "\n", "kernel_range", "=", "kwargs", ".", "get", "(", "\"kernel_range\"", ",", "1.0", ")", "\n", "depthwise_range", "=", "kwargs", ".", "get", "(", "\"depthwise_range\"", ",", "1.0", ")", "\n", "pointwise_range", "=", "kwargs", ".", "get", "(", "\"pointwise_range\"", ",", "1.0", ")", "\n", "\n", "if", "activation", ":", "\n", "      ", "act_suffix", "=", "\"_\"", "+", "GetActivationSuffix", "(", "activation", ")", "\n", "", "acc_suffix", "=", "\"_\"", "+", "GetActivationSuffix", "(", "acc_quantizer", ")", "\n", "\n", "if", "alpha", "==", "-", "1.0", ":", "\n", "      ", "if", "use_separable", ":", "\n", "        ", "x_h", "=", "QSeparableConv2D", "(", "\n", "filters", ",", "kernel_size", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "\n", "depthwise_regularizer", "=", "kernel_regularizer", ",", "\n", "depthwise_constraint", "=", "kernel_constraint", ",", "\n", "depthwise_initializer", "=", "kernel_initializer", ",", "\n", "pointwise_regularizer", "=", "kernel_regularizer", ",", "\n", "pointwise_constraint", "=", "kernel_constraint", ",", "\n", "pointwise_initializer", "=", "kernel_initializer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "depthwise_quantizer", "=", "depthwise_quantizer", ",", "\n", "pointwise_quantizer", "=", "pointwise_quantizer", ",", "\n", "bias_quantizer", "=", "bias_quantizer", ",", "\n", "depthwise_activation", "=", "depthwise_activation", ",", "\n", "pointwise_range", "=", "pointwise_range", ",", "\n", "depthwise_range", "=", "depthwise_range", ",", "\n", "bias_range", "=", "bias_range", ",", "\n", "name", "=", "name", "+", "\"_c_h_to_h\"", ")", "(", "x_h", ")", "\n", "", "else", ":", "\n", "        ", "x_h", "=", "QConv2D", "(", "\n", "filters", ",", "kernel_size", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "kernel_quantizer", "=", "kernel_quantizer", ",", "\n", "bias_quantizer", "=", "bias_quantizer", ",", "\n", "kernel_range", "=", "kernel_range", ",", "\n", "bias_range", "=", "bias_range", ",", "\n", "name", "=", "name", "+", "\"_c_h_to_h\"", ")", "(", "x_h", ")", "\n", "\n", "", "if", "activation", ":", "\n", "        ", "x_h", "=", "QActivation", "(", "\n", "activation", ",", "name", "=", "name", "+", "\"_c_h_to_h_act\"", "+", "act_suffix", ")", "(", "\n", "x_h", ")", "\n", "\n", "", "return", "[", "x_h", ",", "None", "]", "\n", "\n", "", "co_h", "=", "int", "(", "filters", "*", "(", "1", "-", "alpha", ")", ")", "\n", "co_l", "=", "filters", "-", "co_h", "\n", "\n", "x_h_to_h", "=", "None", "\n", "x_h_to_l", "=", "None", "\n", "x_l_to_l", "=", "None", "\n", "x_l_to_h", "=", "None", "\n", "\n", "if", "co_h", ">", "0", ":", "\n", "      ", "if", "x_h", "is", "not", "None", ":", "\n", "        ", "if", "use_separable", ":", "\n", "          ", "x_h_to_h", "=", "QSeparableConv2D", "(", "\n", "co_h", ",", "kernel_size", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "\n", "depthwise_regularizer", "=", "kernel_regularizer", ",", "\n", "depthwise_constraint", "=", "kernel_constraint", ",", "\n", "depthwise_initializer", "=", "kernel_initializer", ",", "\n", "pointwise_regularizer", "=", "kernel_regularizer", ",", "\n", "pointwise_constraint", "=", "kernel_constraint", ",", "\n", "pointwise_initializer", "=", "kernel_initializer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "depthwise_quantizer", "=", "depthwise_quantizer", ",", "\n", "pointwise_quantizer", "=", "pointwise_quantizer", ",", "\n", "bias_quantizer", "=", "bias_quantizer", ",", "\n", "depthwise_activation", "=", "depthwise_activation", ",", "\n", "pointwise_range", "=", "pointwise_range", ",", "\n", "depthwise_range", "=", "depthwise_range", ",", "\n", "bias_range", "=", "bias_range", ",", "\n", "name", "=", "name", "+", "\"_c_h_to_h\"", ")", "(", "x_h", ")", "\n", "", "else", ":", "\n", "          ", "x_h_to_h", "=", "QConv2D", "(", "\n", "co_h", ",", "kernel_size", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "kernel_quantizer", "=", "kernel_quantizer", ",", "\n", "bias_quantizer", "=", "bias_quantizer", ",", "\n", "kernel_range", "=", "kernel_range", ",", "\n", "bias_range", "=", "bias_range", ",", "\n", "name", "=", "name", "+", "\"_c_h_to_h\"", ")", "(", "x_h", ")", "\n", "\n", "", "if", "acc_quantizer", ":", "\n", "          ", "x_h_to_h", "=", "QActivation", "(", "\n", "acc_quantizer", ",", "\n", "name", "=", "name", "+", "\"_c_h_to_h_act\"", "+", "acc_suffix", ")", "(", "x_h_to_h", ")", "\n", "\n", "", "", "", "if", "co_l", ">", "0", ":", "\n", "      ", "if", "x_h", "is", "not", "None", ":", "\n", "        ", "x_h_to_l", "=", "QAveragePooling2D", "(", "\n", "pool_size", "=", "2", ",", "strides", "=", "2", ",", "\n", "quantizer", "=", "pooling_quantizer", ",", "\n", "name", "=", "name", "+", "\"_avg_h_to_l\"", ")", "(", "x_h", ")", "\n", "\n", "if", "use_separable", ":", "\n", "          ", "x_h_to_l", "=", "QSeparableConv2D", "(", "\n", "co_l", ",", "kernel_size", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "\n", "depthwise_regularizer", "=", "kernel_regularizer", ",", "\n", "depthwise_constraint", "=", "kernel_constraint", ",", "\n", "depthwise_initializer", "=", "kernel_initializer", ",", "\n", "pointwise_regularizer", "=", "kernel_regularizer", ",", "\n", "pointwise_constraint", "=", "kernel_constraint", ",", "\n", "pointwise_initializer", "=", "kernel_initializer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "depthwise_quantizer", "=", "depthwise_quantizer", ",", "\n", "pointwise_quantizer", "=", "pointwise_quantizer", ",", "\n", "bias_quantizer", "=", "bias_quantizer", ",", "\n", "depthwise_activation", "=", "depthwise_activation", ",", "\n", "pointwise_range", "=", "pointwise_range", ",", "\n", "depthwise_range", "=", "depthwise_range", ",", "\n", "bias_range", "=", "bias_range", ",", "\n", "name", "=", "name", "+", "\"_c_h_to_l\"", ")", "(", "x_h_to_l", ")", "\n", "", "else", ":", "\n", "          ", "x_h_to_l", "=", "QConv2D", "(", "\n", "co_l", ",", "kernel_size", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "kernel_quantizer", "=", "kernel_quantizer", ",", "\n", "bias_quantizer", "=", "bias_quantizer", ",", "\n", "kernel_range", "=", "kernel_range", ",", "\n", "bias_range", "=", "bias_range", ",", "\n", "name", "=", "name", "+", "\"_c_h_to_l\"", ")", "(", "x_h_to_l", ")", "\n", "\n", "", "if", "acc_quantizer", ":", "\n", "          ", "x_h_to_l", "=", "QActivation", "(", "\n", "acc_quantizer", ",", "\n", "name", "=", "name", "+", "\"_c_h_to_l_act\"", "+", "acc_suffix", ")", "(", "x_h_to_l", ")", "\n", "\n", "", "", "", "if", "co_h", ">", "0", ":", "\n", "      ", "if", "x_l", "is", "not", "None", ":", "\n", "        ", "_", ",", "height", ",", "width", ",", "_", "=", "x_l", ".", "shape", ".", "as_list", "(", ")", "\n", "if", "height", "==", "1", "and", "width", "==", "1", ":", "\n", "          ", "local_kernel", "=", "1", "\n", "local_strides", "=", "1", "\n", "local_padding", "=", "\"same\"", "\n", "upsampling", "=", "False", "\n", "", "else", ":", "\n", "          ", "local_kernel", "=", "kernel_size", "\n", "local_strides", "=", "strides", "\n", "local_padding", "=", "padding", "\n", "upsampling", "=", "True", "\n", "\n", "", "if", "use_separable", "and", "upsampling", ":", "\n", "          ", "x_l_to_h", "=", "QSeparableConv2D", "(", "\n", "co_h", ",", "kernel_size", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "\n", "depthwise_regularizer", "=", "kernel_regularizer", ",", "\n", "depthwise_constraint", "=", "kernel_constraint", ",", "\n", "depthwise_initializer", "=", "kernel_initializer", ",", "\n", "pointwise_regularizer", "=", "kernel_regularizer", ",", "\n", "pointwise_constraint", "=", "kernel_constraint", ",", "\n", "pointwise_initializer", "=", "kernel_initializer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "depthwise_quantizer", "=", "depthwise_quantizer", ",", "\n", "pointwise_quantizer", "=", "pointwise_quantizer", ",", "\n", "bias_quantizer", "=", "bias_quantizer", ",", "\n", "depthwise_activation", "=", "depthwise_activation", ",", "\n", "pointwise_range", "=", "pointwise_range", ",", "\n", "depthwise_range", "=", "depthwise_range", ",", "\n", "bias_range", "=", "bias_range", ",", "\n", "name", "=", "name", "+", "\"_c_l_to_h\"", ")", "(", "x_l", ")", "\n", "", "else", ":", "\n", "          ", "x_l_to_h", "=", "QConv2D", "(", "\n", "co_h", ",", "local_kernel", ",", "strides", "=", "local_strides", ",", "padding", "=", "local_padding", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "kernel_quantizer", "=", "kernel_quantizer", ",", "\n", "bias_quantizer", "=", "bias_quantizer", ",", "\n", "kernel_range", "=", "kernel_range", ",", "\n", "bias_range", "=", "bias_range", ",", "\n", "name", "=", "name", "+", "\"_c_l_to_h\"", ")", "(", "x_l", ")", "\n", "\n", "", "if", "acc_quantizer", ":", "\n", "          ", "x_l_to_h", "=", "QActivation", "(", "\n", "acc_quantizer", ",", "\n", "name", "=", "name", "+", "\"_c_l_to_h_act\"", "+", "acc_suffix", ")", "(", "x_l_to_h", ")", "\n", "\n", "", "if", "upsampling", ":", "\n", "          ", "x_l_to_h", "=", "UpSampling2D", "(", "\n", "size", "=", "(", "2", ",", "2", ")", ",", "name", "=", "name", "+", "\"_u_l_to_h\"", ")", "(", "x_l_to_h", ")", "\n", "\n", "", "", "", "if", "co_l", ">", "0", ":", "\n", "      ", "if", "x_l", "is", "not", "None", ":", "\n", "        ", "if", "use_separable", ":", "\n", "          ", "x_l_to_l", "=", "QSeparableConv2D", "(", "\n", "co_l", ",", "kernel_size", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "\n", "depthwise_regularizer", "=", "kernel_regularizer", ",", "\n", "depthwise_constraint", "=", "kernel_constraint", ",", "\n", "depthwise_initializer", "=", "kernel_initializer", ",", "\n", "pointwise_regularizer", "=", "kernel_regularizer", ",", "\n", "pointwise_constraint", "=", "kernel_constraint", ",", "\n", "pointwise_initializer", "=", "kernel_initializer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "depthwise_quantizer", "=", "depthwise_quantizer", ",", "\n", "pointwise_quantizer", "=", "depthwise_quantizer", ",", "\n", "bias_quantizer", "=", "bias_quantizer", ",", "\n", "depthwise_activation", "=", "depthwise_activation", ",", "\n", "pointwise_range", "=", "pointwise_range", ",", "\n", "depthwise_range", "=", "depthwise_range", ",", "\n", "bias_range", "=", "bias_range", ",", "\n", "name", "=", "name", "+", "\"_c_l_to_l\"", ")", "(", "x_l", ")", "\n", "", "else", ":", "\n", "          ", "x_l_to_l", "=", "QConv2D", "(", "\n", "co_l", ",", "kernel_size", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "kernel_quantizer", "=", "kernel_quantizer", ",", "\n", "bias_quantizer", "=", "bias_quantizer", ",", "\n", "kernel_range", "=", "kernel_range", ",", "\n", "bias_range", "=", "bias_range", ",", "\n", "name", "=", "name", "+", "\"_c_l_to_l\"", ")", "(", "x_l", ")", "\n", "\n", "", "if", "acc_quantizer", ":", "\n", "          ", "x_l_to_l", "=", "QActivation", "(", "\n", "acc_quantizer", ",", "name", "=", "name", "+", "\"_c_l_to_l_act\"", "+", "acc_suffix", ")", "(", "\n", "x_l_to_l", ")", "\n", "\n", "", "", "", "if", "x_h_to_h", "is", "not", "None", "and", "x_l_to_h", "is", "not", "None", ":", "\n", "      ", "x_h", "=", "Add", "(", "name", "=", "name", "+", "\"_a_h\"", ")", "(", "[", "x_h_to_h", ",", "x_l_to_h", "]", ")", "\n", "", "elif", "x_h_to_h", "is", "not", "None", ":", "\n", "      ", "x_h", "=", "x_h_to_h", "\n", "", "elif", "x_l_to_h", "is", "not", "None", ":", "\n", "      ", "x_h", "=", "x_l_to_h", "\n", "", "else", ":", "\n", "      ", "x_h", "=", "None", "\n", "\n", "", "if", "x_l_to_l", "is", "not", "None", "and", "x_h_to_l", "is", "not", "None", ":", "\n", "      ", "x_l", "=", "Add", "(", "name", "=", "name", "+", "\"_a_l\"", ")", "(", "[", "x_l_to_l", ",", "x_h_to_l", "]", ")", "\n", "", "elif", "x_l_to_l", "is", "not", "None", ":", "\n", "      ", "x_l", "=", "x_l_to_l", "\n", "", "elif", "x_h_to_l", "is", "not", "None", ":", "\n", "      ", "x_l", "=", "x_h_to_l", "\n", "", "else", ":", "\n", "      ", "x_l", "=", "None", "\n", "\n", "", "if", "x_h", "is", "not", "None", "and", "activation", "is", "not", "None", ":", "\n", "      ", "x_h", "=", "QActivation", "(", "activation", ",", "\n", "name", "=", "name", "+", "\"_h_act\"", "+", "act_suffix", ")", "(", "x_h", ")", "\n", "\n", "", "if", "x_l", "is", "not", "None", "and", "activation", "is", "not", "None", ":", "\n", "      ", "x_l", "=", "QActivation", "(", "activation", ",", "\n", "name", "=", "name", "+", "\"_l_act\"", "+", "act_suffix", ")", "(", "x_l", ")", "\n", "\n", "", "return", "[", "x_h", ",", "x_l", "]", "\n", "\n", "", "return", "_QOctaveConv2DInternal", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qoctave.OctaveConv2D": [[369, 594], ["kwargs.get", "int", "x_l.shape.as_list", "tensorflow.keras.layers.Add", "tensorflow.keras.layers.Add", "tensorflow.keras.layers.Activation", "tensorflow.keras.layers.Activation", "tensorflow.keras.layers.SeparableConv2D", "tensorflow.keras.layers.Conv2D", "tensorflow.keras.layers.Activation", "tensorflow.keras.layers.AveragePooling2D", "tensorflow.keras.layers.SeparableConv2D", "tensorflow.keras.layers.Conv2D", "tensorflow.keras.layers.Activation", "tensorflow.keras.layers.SeparableConv2D", "tensorflow.keras.layers.Conv2D", "tensorflow.keras.layers.Activation", "tensorflow.keras.layers.SeparableConv2D", "tensorflow.keras.layers.Conv2D", "tensorflow.keras.layers.Activation", "tensorflow.keras.layers.UpSampling2D", "tensorflow.keras.layers.SeparableConv2D", "tensorflow.keras.layers.Conv2D", "tensorflow.keras.layers.Activation"], "function", ["None"], ["", "def", "OctaveConv2D", "(", "\n", "filters", ",", "kernel_size", ",", "alpha", ",", "\n", "strides", "=", "(", "1", ",", "1", ")", ",", "padding", "=", "\"valid\"", ",", "\n", "kernel_initializer", "=", "\"he_normal\"", ",", "\n", "bias_initializer", "=", "\"zeros\"", ",", "\n", "kernel_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "kernel_constraint", "=", "None", ",", "\n", "bias_constraint", "=", "None", ",", "\n", "activation", "=", "None", ",", "\n", "use_separable", "=", "True", ",", "\n", "name", "=", "\"\"", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "  ", "\"\"\"Implements OctaveConv2D.\"\"\"", "\n", "\n", "def", "_OctaveConv2DInternal", "(", "x", ")", ":", "\n", "\n", "    ", "\"\"\"Computes octave on tensor.\"\"\"", "\n", "\n", "acc_quantizer", "=", "kwargs", ".", "get", "(", "\"acc_quantizer\"", ",", "None", ")", "\n", "\n", "x_h", ",", "x_l", "=", "x", "\n", "\n", "if", "alpha", "==", "-", "1.0", ":", "\n", "      ", "if", "use_separable", ":", "\n", "        ", "x_h", "=", "SeparableConv2D", "(", "\n", "filters", ",", "kernel_size", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "\n", "depthwise_regularizer", "=", "kernel_regularizer", ",", "\n", "depthwise_constraint", "=", "kernel_constraint", ",", "\n", "depthwise_initializer", "=", "kernel_initializer", ",", "\n", "pointwise_regularizer", "=", "kernel_regularizer", ",", "\n", "pointwise_constraint", "=", "kernel_constraint", ",", "\n", "pointwise_initializer", "=", "kernel_initializer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "name", "=", "name", "+", "\"_c_h_to_h\"", ")", "(", "x_h", ")", "\n", "", "else", ":", "\n", "        ", "x_h", "=", "Conv2D", "(", "\n", "filters", ",", "kernel_size", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "name", "=", "name", "+", "\"_c_h_to_h\"", ")", "(", "x_h", ")", "\n", "\n", "", "if", "activation", ":", "\n", "        ", "x_h", "=", "Activation", "(", "activation", ",", "name", "=", "name", "+", "\"_c_h_to_h_act\"", ")", "(", "x_h", ")", "\n", "\n", "", "return", "[", "x_h", ",", "None", "]", "\n", "\n", "", "co_h", "=", "int", "(", "filters", "*", "(", "1", "-", "alpha", ")", ")", "\n", "co_l", "=", "filters", "-", "co_h", "\n", "\n", "x_h_to_h", "=", "None", "\n", "x_h_to_l", "=", "None", "\n", "x_l_to_l", "=", "None", "\n", "x_l_to_h", "=", "None", "\n", "\n", "if", "co_h", ">", "0", ":", "\n", "      ", "if", "x_h", "is", "not", "None", ":", "\n", "        ", "if", "use_separable", ":", "\n", "          ", "x_h_to_h", "=", "SeparableConv2D", "(", "\n", "co_h", ",", "kernel_size", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "\n", "depthwise_regularizer", "=", "kernel_regularizer", ",", "\n", "depthwise_constraint", "=", "kernel_constraint", ",", "\n", "depthwise_initializer", "=", "kernel_initializer", ",", "\n", "pointwise_regularizer", "=", "kernel_regularizer", ",", "\n", "pointwise_constraint", "=", "kernel_constraint", ",", "\n", "pointwise_initializer", "=", "kernel_initializer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "name", "=", "name", "+", "\"_c_h_to_h\"", ")", "(", "x_h", ")", "\n", "", "else", ":", "\n", "          ", "x_h_to_h", "=", "Conv2D", "(", "\n", "co_h", ",", "kernel_size", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "name", "=", "name", "+", "\"_c_h_to_h\"", ")", "(", "x_h", ")", "\n", "\n", "", "if", "activation", ":", "\n", "          ", "x_h_to_h", "=", "Activation", "(", "\n", "acc_quantizer", ",", "name", "=", "name", "+", "\"_c_h_to_h_act\"", ")", "(", "x_h_to_h", ")", "\n", "\n", "", "", "", "if", "co_l", ">", "0", ":", "\n", "      ", "if", "x_h", "is", "not", "None", ":", "\n", "        ", "x_h_to_l", "=", "AveragePooling2D", "(", "pool_size", "=", "2", ",", "strides", "=", "2", ",", "\n", "name", "=", "name", "+", "\"_p_h_to_l\"", ")", "(", "x_h", ")", "\n", "\n", "if", "use_separable", ":", "\n", "          ", "x_h_to_l", "=", "SeparableConv2D", "(", "\n", "co_l", ",", "kernel_size", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "\n", "depthwise_regularizer", "=", "kernel_regularizer", ",", "\n", "depthwise_constraint", "=", "kernel_constraint", ",", "\n", "depthwise_initializer", "=", "kernel_initializer", ",", "\n", "pointwise_regularizer", "=", "kernel_regularizer", ",", "\n", "pointwise_constraint", "=", "kernel_constraint", ",", "\n", "pointwise_initializer", "=", "kernel_initializer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "name", "=", "name", "+", "\"_c_h_to_l\"", ")", "(", "x_h_to_l", ")", "\n", "", "else", ":", "\n", "          ", "x_h_to_l", "=", "Conv2D", "(", "\n", "co_l", ",", "kernel_size", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "name", "=", "name", "+", "\"_c_h_to_l\"", ")", "(", "x_h_to_l", ")", "\n", "\n", "", "if", "activation", ":", "\n", "          ", "x_h_to_l", "=", "Activation", "(", "\n", "acc_quantizer", ",", "name", "=", "name", "+", "\"_c_h_to_l_act\"", ")", "(", "x_h_to_l", ")", "\n", "\n", "", "", "", "if", "co_h", ">", "0", ":", "\n", "      ", "if", "x_l", "is", "not", "None", ":", "\n", "        ", "_", ",", "height", ",", "width", ",", "_", "=", "x_l", ".", "shape", ".", "as_list", "(", ")", "\n", "if", "height", "==", "1", "and", "width", "==", "1", ":", "\n", "          ", "local_kernel", "=", "1", "\n", "local_strides", "=", "1", "\n", "local_padding", "=", "\"same\"", "\n", "upsampling", "=", "False", "\n", "", "else", ":", "\n", "          ", "local_kernel", "=", "kernel_size", "\n", "local_strides", "=", "strides", "\n", "local_padding", "=", "padding", "\n", "upsampling", "=", "True", "\n", "\n", "", "if", "use_separable", "and", "upsampling", ":", "\n", "          ", "x_l_to_h", "=", "SeparableConv2D", "(", "\n", "co_h", ",", "kernel_size", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "\n", "depthwise_regularizer", "=", "kernel_regularizer", ",", "\n", "depthwise_constraint", "=", "kernel_constraint", ",", "\n", "depthwise_initializer", "=", "kernel_initializer", ",", "\n", "pointwise_regularizer", "=", "kernel_regularizer", ",", "\n", "pointwise_constraint", "=", "kernel_constraint", ",", "\n", "pointwise_initializer", "=", "kernel_initializer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "name", "=", "name", "+", "\"_c_l_to_h\"", ")", "(", "x_l", ")", "\n", "", "else", ":", "\n", "          ", "x_l_to_h", "=", "Conv2D", "(", "\n", "co_h", ",", "local_kernel", ",", "strides", "=", "local_strides", ",", "padding", "=", "local_padding", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "name", "=", "name", "+", "\"_c_l_to_h\"", ")", "(", "x_l", ")", "\n", "\n", "", "if", "activation", ":", "\n", "          ", "x_l_to_h", "=", "Activation", "(", "\n", "acc_quantizer", ",", "name", "=", "name", "+", "\"_c_l_to_h_act\"", ")", "(", "x_l_to_h", ")", "\n", "\n", "", "if", "upsampling", ":", "\n", "          ", "x_l_to_h", "=", "UpSampling2D", "(", "\n", "size", "=", "(", "2", ",", "2", ")", ",", "name", "=", "name", "+", "\"_u_l_to_h\"", ")", "(", "x_l_to_h", ")", "\n", "\n", "", "", "", "if", "co_l", ">", "0", ":", "\n", "      ", "if", "x_l", "is", "not", "None", ":", "\n", "        ", "if", "use_separable", ":", "\n", "          ", "x_l_to_l", "=", "SeparableConv2D", "(", "\n", "co_l", ",", "kernel_size", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "name", "=", "name", "+", "\"_c_l_to_l\"", ")", "(", "x_l", ")", "\n", "", "else", ":", "\n", "          ", "x_l_to_l", "=", "Conv2D", "(", "\n", "co_l", ",", "kernel_size", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "name", "=", "name", "+", "\"_c_l_to_l\"", ")", "(", "x_l", ")", "\n", "\n", "", "if", "activation", ":", "\n", "          ", "x_l_to_l", "=", "Activation", "(", "\n", "acc_quantizer", ",", "name", "=", "name", "+", "\"_c_l_to_l_act\"", ")", "(", "x_l_to_l", ")", "\n", "\n", "", "", "", "if", "x_h_to_h", "is", "not", "None", "and", "x_l_to_h", "is", "not", "None", ":", "\n", "      ", "x_h", "=", "Add", "(", "name", "=", "name", "+", "\"_a_h\"", ")", "(", "[", "x_h_to_h", ",", "x_l_to_h", "]", ")", "\n", "", "elif", "x_h_to_h", "is", "not", "None", ":", "\n", "      ", "x_h", "=", "x_h_to_h", "\n", "", "elif", "x_l_to_h", "is", "not", "None", ":", "\n", "      ", "x_h", "=", "x_l_to_h", "\n", "", "else", ":", "\n", "      ", "x_h", "=", "None", "\n", "\n", "", "if", "x_l_to_l", "is", "not", "None", "and", "x_h_to_l", "is", "not", "None", ":", "\n", "      ", "x_l", "=", "Add", "(", "name", "=", "name", "+", "\"_a_l\"", ")", "(", "[", "x_l_to_l", ",", "x_h_to_l", "]", ")", "\n", "", "elif", "x_l_to_l", "is", "not", "None", ":", "\n", "      ", "x_l", "=", "x_l_to_l", "\n", "", "elif", "x_h_to_l", "is", "not", "None", ":", "\n", "      ", "x_l", "=", "x_h_to_l", "\n", "", "else", ":", "\n", "      ", "x_l", "=", "None", "\n", "\n", "", "if", "x_h", "is", "not", "None", ":", "\n", "      ", "x_h", "=", "Activation", "(", "activation", ",", "name", "=", "name", "+", "\"_h_act\"", ")", "(", "x_h", ")", "\n", "\n", "", "if", "x_l", "is", "not", "None", ":", "\n", "      ", "x_l", "=", "Activation", "(", "activation", ",", "name", "=", "name", "+", "\"_l_act\"", ")", "(", "x_l", ")", "\n", "\n", "", "return", "(", "x_h", ",", "x_l", ")", "\n", "\n", "", "return", "_OctaveConv2DInternal", "\n", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconv2d_batchnorm.QConv2DBatchnorm.__init__": [[40, 148], ["qconvolutional.QConv2D.__init__", "tensorflow.keras.layers.BatchNormalization"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "# qconv2d params", "\n", "filters", ",", "\n", "kernel_size", ",", "\n", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "padding", "=", "\"valid\"", ",", "\n", "data_format", "=", "\"channels_last\"", ",", "\n", "dilation_rate", "=", "(", "1", ",", "1", ")", ",", "\n", "activation", "=", "None", ",", "\n", "use_bias", "=", "True", ",", "\n", "kernel_initializer", "=", "\"he_normal\"", ",", "\n", "bias_initializer", "=", "\"zeros\"", ",", "\n", "kernel_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "activity_regularizer", "=", "None", ",", "\n", "kernel_constraint", "=", "None", ",", "\n", "bias_constraint", "=", "None", ",", "\n", "kernel_quantizer", "=", "None", ",", "\n", "bias_quantizer", "=", "None", ",", "\n", "\n", "# batchnorm params", "\n", "axis", "=", "-", "1", ",", "\n", "momentum", "=", "0.99", ",", "\n", "epsilon", "=", "0.001", ",", "\n", "center", "=", "True", ",", "\n", "scale", "=", "True", ",", "\n", "beta_initializer", "=", "\"zeros\"", ",", "\n", "gamma_initializer", "=", "\"ones\"", ",", "\n", "moving_mean_initializer", "=", "\"zeros\"", ",", "\n", "moving_variance_initializer", "=", "\"ones\"", ",", "\n", "beta_regularizer", "=", "None", ",", "\n", "gamma_regularizer", "=", "None", ",", "\n", "beta_constraint", "=", "None", ",", "\n", "gamma_constraint", "=", "None", ",", "\n", "renorm", "=", "False", ",", "\n", "renorm_clipping", "=", "None", ",", "\n", "renorm_momentum", "=", "0.99", ",", "\n", "fused", "=", "None", ",", "\n", "trainable", "=", "True", ",", "\n", "virtual_batch_size", "=", "None", ",", "\n", "adjustment", "=", "None", ",", "\n", "\n", "# other params", "\n", "ema_freeze_delay", "=", "None", ",", "\n", "folding_mode", "=", "\"ema_stats_folding\"", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Initialize a composite layer that folds conv2d and batch normalization.\n\n    The first group of parameters correponds to the initialization parameters\n      of a qconv2d layer. check qkeras.qconvolutional.qconv2d for details.\n\n    The 2nd group of parameters corresponds to the initialization parameters\n      of a BatchNormalization layer. Check keras.layers.normalization.BatchNorma\n      lizationBase for details.\n\n    The 3rd group of parameters corresponds to the initialization parameters\n      specific to this class.\n\n      ema_freeze_delay: int. number of steps before batch normalization mv_mean\n        and mv_variance will be frozen and used in the folded layer.\n      folding_mode: string\n        \"ema_stats_folding\": mimic tflite which uses the ema statistics to\n          fold the kernel to suppress quantization induced jitter then performs\n          the correction to have a similar effect of using the current batch\n          statistics.\n        \"batch_stats_folding\": use batch mean and variance to fold kernel first;\n          after enough training steps switch to moving_mean and moving_variance\n          for kernel folding.\n    \"\"\"", "\n", "\n", "# intialization the qconv2d part of the composite layer", "\n", "super", "(", "QConv2DBatchnorm", ",", "self", ")", ".", "__init__", "(", "\n", "filters", "=", "filters", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "dilation_rate", "=", "dilation_rate", ",", "\n", "activation", "=", "activation", ",", "\n", "use_bias", "=", "use_bias", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "activity_regularizer", "=", "activity_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "kernel_quantizer", "=", "kernel_quantizer", ",", "\n", "bias_quantizer", "=", "bias_quantizer", ",", "\n", "**", "kwargs", ")", "\n", "\n", "# initialization of batchnorm part of the composite layer", "\n", "self", ".", "batchnorm", "=", "layers", ".", "BatchNormalization", "(", "\n", "axis", "=", "axis", ",", "momentum", "=", "momentum", ",", "epsilon", "=", "epsilon", ",", "center", "=", "center", ",", "\n", "scale", "=", "scale", ",", "beta_initializer", "=", "beta_initializer", ",", "\n", "gamma_initializer", "=", "gamma_initializer", ",", "\n", "moving_mean_initializer", "=", "moving_mean_initializer", ",", "\n", "moving_variance_initializer", "=", "moving_variance_initializer", ",", "\n", "beta_regularizer", "=", "beta_regularizer", ",", "\n", "gamma_regularizer", "=", "gamma_regularizer", ",", "\n", "beta_constraint", "=", "beta_constraint", ",", "gamma_constraint", "=", "gamma_constraint", ",", "\n", "renorm", "=", "renorm", ",", "renorm_clipping", "=", "renorm_clipping", ",", "\n", "renorm_momentum", "=", "renorm_momentum", ",", "fused", "=", "fused", ",", "trainable", "=", "trainable", ",", "\n", "virtual_batch_size", "=", "virtual_batch_size", ",", "adjustment", "=", "adjustment", ")", "\n", "\n", "self", ".", "ema_freeze_delay", "=", "ema_freeze_delay", "\n", "assert", "folding_mode", "in", "[", "\"ema_stats_folding\"", ",", "\"batch_stats_folding\"", "]", "\n", "self", ".", "folding_mode", "=", "folding_mode", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconv2d_batchnorm.QConv2DBatchnorm.build": [[149, 158], ["super().build", "tensorflow.Variable"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.networks.conv_block.ConvBlockNetwork.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "    ", "super", "(", "QConv2DBatchnorm", ",", "self", ")", ".", "build", "(", "input_shape", ")", "\n", "\n", "# self._iteration (i.e., training_steps) is initialized with -1. When", "\n", "# loading ckpt, it can load the number of training steps that have been", "\n", "# previously trainied. If start training from scratch.", "\n", "# TODO(lishanok): develop a way to count iterations outside layer", "\n", "self", ".", "_iteration", "=", "tf", ".", "Variable", "(", "-", "1", ",", "trainable", "=", "False", ",", "name", "=", "\"iteration\"", ",", "\n", "dtype", "=", "tf", ".", "int64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconv2d_batchnorm.QConv2DBatchnorm.call": [[159, 301], ["qconv2d_batchnorm.QConv2DBatchnorm.batchnorm._get_training_value", "tensorflow.keras.backend.conv2d", "qconv2d_batchnorm.QConv2DBatchnorm.batchnorm", "qconv2d_batchnorm.QConv2DBatchnorm._iteration.assign_add", "len", "qconv2d_batchnorm.QConv2DBatchnorm.batchnorm._moments", "tensorflow.keras.backend.conv2d", "tensorflow.keras.backend.bias_add", "tensorflow.cast", "tensorflow.math.logical_and", "tensorflow.keras.backend.bias_add", "tensorflow.python.framework.smart_cond.smart_cond", "len", "tensorflow.python.ops.math_ops.cast", "tensorflow.python.framework.smart_cond.smart_cond", "tensorflow.python.framework.smart_cond.smart_cond", "tensorflow.python.ops.math_ops.rsqrt", "qconv2d_batchnorm.QConv2DBatchnorm.kernel_quantizer_internal", "qconv2d_batchnorm.QConv2DBatchnorm.bias_quantizer_internal", "tensorflow.python.ops.math_ops.rsqrt", "tensorflow.python.framework.smart_cond.smart_cond", "tensorflow.python.ops.math_ops.mul", "qconv2d_batchnorm.QConv2DBatchnorm.activation", "tensorflow.math.less_equal", "six.moves.range", "tensorflow.python.ops.math_ops.rsqrt", "tensorflow.python.ops.math_ops.rsqrt", "tensorflow.python.framework.smart_cond.smart_cond", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.python.ops.math_ops.sqrt", "tensorflow.python.ops.math_ops.rsqrt"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.kernel_quantizer_internal", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.bias_quantizer_internal", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QBidirectional.activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "call", "(", "self", ",", "inputs", ",", "training", "=", "None", ")", ":", "\n", "\n", "# numpy value, mark the layer is in training", "\n", "    ", "training", "=", "self", ".", "batchnorm", ".", "_get_training_value", "(", "training", ")", "# pylint: disable=protected-access", "\n", "\n", "# checking if to update batchnorm params", "\n", "if", "(", "self", ".", "ema_freeze_delay", "is", "None", ")", "or", "(", "self", ".", "ema_freeze_delay", "<", "0", ")", ":", "\n", "# if ema_freeze_delay is None or a negative value, do not freeze bn stats", "\n", "      ", "bn_training", "=", "tf", ".", "cast", "(", "training", ",", "dtype", "=", "bool", ")", "\n", "", "else", ":", "\n", "      ", "bn_training", "=", "tf", ".", "math", ".", "logical_and", "(", "training", ",", "tf", ".", "math", ".", "less_equal", "(", "\n", "self", ".", "_iteration", ",", "self", ".", "ema_freeze_delay", ")", ")", "\n", "\n", "", "kernel", "=", "self", ".", "kernel", "\n", "\n", "# run conv to produce output for the following batchnorm", "\n", "conv_outputs", "=", "tf", ".", "keras", ".", "backend", ".", "conv2d", "(", "\n", "inputs", ",", "\n", "kernel", ",", "\n", "strides", "=", "self", ".", "strides", ",", "\n", "padding", "=", "self", ".", "padding", ",", "\n", "data_format", "=", "self", ".", "data_format", ",", "\n", "dilation_rate", "=", "self", ".", "dilation_rate", ")", "\n", "\n", "if", "self", ".", "use_bias", ":", "\n", "      ", "bias", "=", "self", ".", "bias", "\n", "conv_outputs", "=", "tf", ".", "keras", ".", "backend", ".", "bias_add", "(", "\n", "conv_outputs", ",", "bias", ",", "data_format", "=", "self", ".", "data_format", ")", "\n", "", "else", ":", "\n", "      ", "bias", "=", "0", "\n", "\n", "", "_", "=", "self", ".", "batchnorm", "(", "conv_outputs", ",", "training", "=", "bn_training", ")", "\n", "\n", "self", ".", "_iteration", ".", "assign_add", "(", "tf_utils", ".", "smart_cond", "(", "\n", "training", ",", "lambda", ":", "tf", ".", "constant", "(", "1", ",", "tf", ".", "int64", ")", ",", "\n", "lambda", ":", "tf", ".", "constant", "(", "0", ",", "tf", ".", "int64", ")", ")", ")", "\n", "\n", "# calcuate mean and variance from current batch", "\n", "bn_shape", "=", "conv_outputs", ".", "shape", "\n", "ndims", "=", "len", "(", "bn_shape", ")", "\n", "reduction_axes", "=", "[", "i", "for", "i", "in", "range", "(", "ndims", ")", "if", "i", "not", "in", "self", ".", "batchnorm", ".", "axis", "]", "\n", "keep_dims", "=", "len", "(", "self", ".", "batchnorm", ".", "axis", ")", ">", "1", "\n", "mean", ",", "variance", "=", "self", ".", "batchnorm", ".", "_moments", "(", "# pylint: disable=protected-access", "\n", "math_ops", ".", "cast", "(", "conv_outputs", ",", "self", ".", "batchnorm", ".", "_param_dtype", ")", ",", "# pylint: disable=protected-access", "\n", "reduction_axes", ",", "\n", "keep_dims", "=", "keep_dims", ")", "\n", "# get batchnorm weights", "\n", "gamma", "=", "self", ".", "batchnorm", ".", "gamma", "\n", "beta", "=", "self", ".", "batchnorm", ".", "beta", "\n", "moving_mean", "=", "self", ".", "batchnorm", ".", "moving_mean", "\n", "moving_variance", "=", "self", ".", "batchnorm", ".", "moving_variance", "\n", "\n", "if", "self", ".", "folding_mode", "==", "\"batch_stats_folding\"", ":", "\n", "# using batch mean and variance in the initial training stage", "\n", "# after sufficient training, switch to moving mean and variance", "\n", "      ", "new_mean", "=", "tf_utils", ".", "smart_cond", "(", "\n", "bn_training", ",", "lambda", ":", "mean", ",", "lambda", ":", "moving_mean", ")", "\n", "new_variance", "=", "tf_utils", ".", "smart_cond", "(", "\n", "bn_training", ",", "lambda", ":", "variance", ",", "lambda", ":", "moving_variance", ")", "\n", "\n", "# get the inversion factor so that we replace division by multiplication", "\n", "inv", "=", "math_ops", ".", "rsqrt", "(", "new_variance", "+", "self", ".", "batchnorm", ".", "epsilon", ")", "\n", "if", "gamma", "is", "not", "None", ":", "\n", "        ", "inv", "*=", "gamma", "\n", "# fold bias with bn stats", "\n", "", "folded_bias", "=", "inv", "*", "(", "bias", "-", "new_mean", ")", "+", "beta", "\n", "\n", "", "elif", "self", ".", "folding_mode", "==", "\"ema_stats_folding\"", ":", "\n", "# We always scale the weights with a correction factor to the long term", "\n", "# statistics prior to quantization. This ensures that there is no jitter", "\n", "# in the quantized weights due to batch to batch variation. During the", "\n", "# initial phase of training, we undo the scaling of the weights so that", "\n", "# outputs are identical to regular batch normalization. We also modify", "\n", "# the bias terms correspondingly. After sufficient training, switch from", "\n", "# using batch statistics to long term moving averages for batch", "\n", "# normalization.", "\n", "\n", "# use batch stats for calcuating bias before bn freeze, and use moving", "\n", "# stats after bn freeze", "\n", "      ", "mv_inv", "=", "math_ops", ".", "rsqrt", "(", "moving_variance", "+", "self", ".", "batchnorm", ".", "epsilon", ")", "\n", "batch_inv", "=", "math_ops", ".", "rsqrt", "(", "variance", "+", "self", ".", "batchnorm", ".", "epsilon", ")", "\n", "\n", "if", "gamma", "is", "not", "None", ":", "\n", "        ", "mv_inv", "*=", "gamma", "\n", "batch_inv", "*=", "gamma", "\n", "", "folded_bias", "=", "tf_utils", ".", "smart_cond", "(", "\n", "bn_training", ",", "\n", "lambda", ":", "batch_inv", "*", "(", "bias", "-", "mean", ")", "+", "beta", ",", "\n", "lambda", ":", "mv_inv", "*", "(", "bias", "-", "moving_mean", ")", "+", "beta", ")", "\n", "# moving stats is always used to fold kernel in tflite; before bn freeze", "\n", "# an additional correction factor will be applied to the conv2d output", "\n", "inv", "=", "mv_inv", "\n", "", "else", ":", "\n", "      ", "assert", "ValueError", "\n", "\n", "# wrap conv kernel with bn parameters", "\n", "", "folded_kernel", "=", "inv", "*", "kernel", "\n", "# quantize the folded kernel", "\n", "if", "self", ".", "kernel_quantizer", "is", "not", "None", ":", "\n", "      ", "q_folded_kernel", "=", "self", ".", "kernel_quantizer_internal", "(", "folded_kernel", ")", "\n", "", "else", ":", "\n", "      ", "q_folded_kernel", "=", "folded_kernel", "\n", "\n", "# If loaded from a ckpt, bias_quantizer is the ckpt value", "\n", "# Else if bias_quantizer not specified, bias", "\n", "#   quantizer is None and we need to calculate bias quantizer", "\n", "#   type according to accumulator type. User can call", "\n", "#   bn_folding_utils.populate_bias_quantizer_from_accumulator(", "\n", "#      model, input_quantizer_list]) to populate such bias quantizer.", "\n", "", "if", "self", ".", "bias_quantizer_internal", "is", "not", "None", ":", "\n", "      ", "q_folded_bias", "=", "self", ".", "bias_quantizer_internal", "(", "folded_bias", ")", "\n", "", "else", ":", "\n", "      ", "q_folded_bias", "=", "folded_bias", "\n", "\n", "", "applied_kernel", "=", "q_folded_kernel", "\n", "applied_bias", "=", "q_folded_bias", "\n", "\n", "# calculate conv2d output using the quantized folded kernel", "\n", "folded_outputs", "=", "tf", ".", "keras", ".", "backend", ".", "conv2d", "(", "\n", "inputs", ",", "\n", "applied_kernel", ",", "\n", "strides", "=", "self", ".", "strides", ",", "\n", "padding", "=", "self", ".", "padding", ",", "\n", "data_format", "=", "self", ".", "data_format", ",", "\n", "dilation_rate", "=", "self", ".", "dilation_rate", ")", "\n", "if", "training", "is", "True", "and", "self", ".", "folding_mode", "==", "\"ema_stats_folding\"", ":", "\n", "      ", "batch_inv", "=", "math_ops", ".", "rsqrt", "(", "variance", "+", "self", ".", "batchnorm", ".", "epsilon", ")", "\n", "y_corr", "=", "tf_utils", ".", "smart_cond", "(", "\n", "bn_training", ",", "\n", "lambda", ":", "(", "math_ops", ".", "sqrt", "(", "moving_variance", "+", "self", ".", "batchnorm", ".", "epsilon", ")", "*", "\n", "math_ops", ".", "rsqrt", "(", "variance", "+", "self", ".", "batchnorm", ".", "epsilon", ")", ")", ",", "\n", "lambda", ":", "tf", ".", "constant", "(", "1.0", ",", "shape", "=", "moving_variance", ".", "shape", ")", ")", "\n", "folded_outputs", "=", "math_ops", ".", "mul", "(", "folded_outputs", ",", "y_corr", ")", "\n", "\n", "", "folded_outputs", "=", "tf", ".", "keras", ".", "backend", ".", "bias_add", "(", "\n", "folded_outputs", ",", "\n", "applied_bias", ",", "\n", "data_format", "=", "self", ".", "data_format", ")", "\n", "if", "self", ".", "activation", "is", "not", "None", ":", "\n", "      ", "return", "self", ".", "activation", "(", "folded_outputs", ")", "\n", "\n", "", "return", "folded_outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconv2d_batchnorm.QConv2DBatchnorm.get_config": [[302, 316], ["super().get_config", "qconv2d_batchnorm.QConv2DBatchnorm.batchnorm.get_config", "dict", "list", "list", "list", "config.items", "super().get_config.items", "qconv2d_batchnorm.QConv2DBatchnorm.items"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "base_config", "=", "super", "(", ")", ".", "get_config", "(", ")", "\n", "bn_config", "=", "self", ".", "batchnorm", ".", "get_config", "(", ")", "\n", "config", "=", "{", "\"ema_freeze_delay\"", ":", "self", ".", "ema_freeze_delay", ",", "\n", "\"folding_mode\"", ":", "self", ".", "folding_mode", "}", "\n", "name", "=", "base_config", "[", "\"name\"", "]", "\n", "out_config", "=", "dict", "(", "\n", "list", "(", "base_config", ".", "items", "(", ")", ")", "\n", "+", "list", "(", "bn_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n", "# names from different config override each other; use the base layer name", "\n", "# as the this layer's config name", "\n", "out_config", "[", "\"name\"", "]", "=", "name", "\n", "return", "out_config", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconv2d_batchnorm.QConv2DBatchnorm.get_quantization_config": [[317, 323], ["str", "str", "str", "str"], "methods", ["None"], ["", "def", "get_quantization_config", "(", "self", ")", ":", "\n", "    ", "return", "{", "\n", "\"kernel_quantizer\"", ":", "str", "(", "self", ".", "kernel_quantizer_internal", ")", ",", "\n", "\"bias_quantizer\"", ":", "str", "(", "self", ".", "bias_quantizer_internal", ")", ",", "\n", "\"activation\"", ":", "str", "(", "self", ".", "activation", ")", ",", "\n", "\"filters\"", ":", "str", "(", "self", ".", "filters", ")", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconv2d_batchnorm.QConv2DBatchnorm.get_quantizers": [[325, 327], ["None"], "methods", ["None"], ["", "def", "get_quantizers", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "quantizers", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconv2d_batchnorm.QConv2DBatchnorm.get_folded_weights": [[328, 359], ["tensorflow.python.ops.math_ops.rsqrt"], "methods", ["None"], ["", "def", "get_folded_weights", "(", "self", ")", ":", "\n", "    ", "\"\"\"Function to get the batchnorm folded weights.\n\n    This function converts the weights by folding batchnorm parameters into\n    the weight of QConv2D. The high-level equation:\n\n    W_fold = gamma * W / sqrt(variance + epsilon)\n    bias_fold = gamma * (bias - moving_mean) / sqrt(variance + epsilon) + beta\n    \"\"\"", "\n", "\n", "kernel", "=", "self", ".", "kernel", "\n", "if", "self", ".", "use_bias", ":", "\n", "      ", "bias", "=", "self", ".", "bias", "\n", "", "else", ":", "\n", "      ", "bias", "=", "0", "\n", "\n", "# get batchnorm weights and moving stats", "\n", "", "gamma", "=", "self", ".", "batchnorm", ".", "gamma", "\n", "beta", "=", "self", ".", "batchnorm", ".", "beta", "\n", "moving_mean", "=", "self", ".", "batchnorm", ".", "moving_mean", "\n", "moving_variance", "=", "self", ".", "batchnorm", ".", "moving_variance", "\n", "# get the inversion factor so that we replace division by multiplication", "\n", "inv", "=", "math_ops", ".", "rsqrt", "(", "moving_variance", "+", "self", ".", "batchnorm", ".", "epsilon", ")", "\n", "if", "gamma", "is", "not", "None", ":", "\n", "      ", "inv", "*=", "gamma", "\n", "\n", "# wrap conv kernel and bias with bn parameters", "\n", "", "folded_kernel", "=", "inv", "*", "kernel", "\n", "folded_bias", "=", "inv", "*", "(", "bias", "-", "moving_mean", ")", "+", "beta", "\n", "\n", "return", "[", "folded_kernel", ",", "folded_bias", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.__init__": [[35, 83], ["super().__init__", "numpy.array", "ValueError", "ValueError", "tensorflow.summary.create_file_writer"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "\n", "start", ",", "\n", "finish", ",", "\n", "freq_type", "=", "\"epoch\"", ",", "\n", "update_freq", "=", "1", ",", "\n", "initial_step_or_epoch", "=", "0", ",", "\n", "exponent", "=", "3.0", ",", "\n", "use_ste", "=", "True", ",", "\n", "log_dir", "=", "None", ")", ":", "\n", "    ", "\"\"\"Initializes this QNoiseScheduler.\n\n    Args:\n      start: Int. The step (epoch) to start the gradual training.\n      finish: Int. The step (epoch) to finish the gradual training. When the\n        start and the finish are equal, the qnoise_factor will be 1.0 in the\n        beginning of the training.\n      freq_type: Str. \"step\" or \"epoch\". It sets the qnoise_factor update\n        frequency type.\n      update_freq: Int. Updating frequency of the qnoise_factor.\n      initial_step_or_epoch:  Int. Step or epoch at which to start training.\n      exponent: Float. It is the exponent in the qnoise_factor calculation. It\n        controls the rate of the gradual qnoise_factor change.\n      use_ste: Bool. Whether to use \"straight-through estimator\" (STE) method or\n        not.\n      log_dir: Str. log directory to save qnoise_factor every epoch end.\n    \"\"\"", "\n", "super", "(", "QNoiseScheduler", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "start", "=", "start", "\n", "self", ".", "finish", "=", "finish", "\n", "if", "start", ">", "finish", ":", "\n", "      ", "raise", "ValueError", "(", "\n", "(", "\"start {} must be greater than finish {}\"", ")", ".", "format", "(", "start", ",", "finish", ")", ")", "\n", "", "supported_freq_type", "=", "[", "\"step\"", ",", "\"epoch\"", "]", "\n", "if", "freq_type", "not", "in", "supported_freq_type", ":", "\n", "      ", "raise", "ValueError", "(", "(", "\"Invalid frequency type {}. only {} are \"", "\n", "\"supported.\"", ")", ".", "format", "(", "freq_type", ",", "supported_freq_type", ")", ")", "\n", "", "self", ".", "freq_type", "=", "freq_type", "\n", "self", ".", "update_freq", "=", "update_freq", "\n", "self", ".", "initial_step_or_epoch", "=", "initial_step_or_epoch", "\n", "self", ".", "exponent", "=", "exponent", "\n", "self", ".", "qnoise_factor", "=", "None", "\n", "self", ".", "use_ste", "=", "use_ste", "\n", "self", ".", "quantizers", "=", "None", "\n", "self", ".", "summary_writer", "=", "None", "\n", "if", "log_dir", ":", "\n", "      ", "self", ".", "summary_writer", "=", "tf", ".", "summary", ".", "create_file_writer", "(", "log_dir", ")", "\n", "", "self", ".", "num_iters", "=", "np", ".", "array", "(", "0", ",", "dtype", "=", "\"int64\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.calculate_qnoise_factor": [[84, 103], ["float", "float", "numpy.power"], "methods", ["None"], ["", "def", "calculate_qnoise_factor", "(", "self", ",", "freq", ")", ":", "\n", "    ", "\"\"\"Returns calculated qnoise_factor based on the current step (epoch) and\n    the schedule parameters.\n\n    Args:\n      freq: The current step (or epoch) to calculate the qnoise_factor.\n\n    Returns:\n      qnoise_factor : calculated qnoise_factor.\n    \"\"\"", "\n", "if", "freq", "<", "self", ".", "start", ":", "\n", "      ", "qnoise_factor", "=", "0.0", "\n", "", "elif", "freq", "<=", "self", ".", "finish", "and", "self", ".", "start", "!=", "self", ".", "finish", ":", "\n", "      ", "val", "=", "float", "(", "self", ".", "finish", "-", "freq", ")", "/", "float", "(", "self", ".", "finish", "-", "self", ".", "start", ")", "\n", "qnoise_factor", "=", "1.0", "-", "np", ".", "power", "(", "val", ",", "self", ".", "exponent", ")", "\n", "", "else", ":", "\n", "      ", "qnoise_factor", "=", "1.0", "\n", "\n", "", "return", "qnoise_factor", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.set_qnoise_factor": [[104, 111], ["quantizer.update_qnoise_factor"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor"], ["", "def", "set_qnoise_factor", "(", "self", ",", "quantizer", ",", "qnoise_factor", ")", ":", "\n", "    ", "\"\"\"Set self.qnoise_factor and update the qnoise_factor of the quantizer.\"\"\"", "\n", "\n", "# Updating the qnoise_factor of the quantizer.", "\n", "quantizer", ".", "update_qnoise_factor", "(", "qnoise_factor", ")", "\n", "# Updating the qnoise_factor of the callback.", "\n", "self", ".", "qnoise_factor", "=", "qnoise_factor", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.set_quantizers": [[112, 131], ["hasattr", "hasattr", "hasattr", "callbacks.QNoiseScheduler.set_qnoise_factor", "quantizer.build", "isinstance"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.set_qnoise_factor", "home.repos.pwc.inspect_result.google_qkeras.networks.conv_block.ConvBlockNetwork.build"], ["", "def", "set_quantizers", "(", "self", ")", ":", "\n", "    ", "\"\"\"Set quantizers to update the qnoise_factor.\n\n    This must be called before building the quantizers.\n    \"\"\"", "\n", "for", "quantizer", "in", "self", ".", "quantizers", ":", "\n", "      ", "if", "hasattr", "(", "quantizer", ",", "\"use_ste\"", ")", ":", "\n", "        ", "quantizer", ".", "use_ste", "=", "self", ".", "use_ste", "\n", "", "if", "hasattr", "(", "quantizer", ",", "\"use_variables\"", ")", ":", "\n", "        ", "quantizer", ".", "use_variables", "=", "True", "\n", "", "if", "hasattr", "(", "quantizer", ",", "\"built\"", ")", ":", "\n", "# If the quantizer has been built but not using tf.Variable then it", "\n", "# builds again to create tf.Variables.", "\n", "        ", "if", "quantizer", ".", "built", "and", "not", "isinstance", "(", "quantizer", ".", "qnoise_factor", ",", "\n", "tf", ".", "Variable", ")", ":", "\n", "          ", "quantizer", ".", "build", "(", "use_variables", "=", "True", ")", "\n", "\n", "# Set the qnoise_factor to 0.0 to pretrain without quantization.", "\n", "", "", "self", ".", "set_qnoise_factor", "(", "quantizer", ",", "qnoise_factor", "=", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.get_quantizers": [[132, 153], ["hasattr", "getattr", "hasattr", "all_quantizers.append"], "methods", ["None"], ["", "", "def", "get_quantizers", "(", "self", ",", "model", ")", ":", "\n", "    ", "\"\"\"Returns a list of quantizers with qnoise_factor in the model.\n\n    Args:\n      model: model to get a list of quantizers with qnoise_factor.\n\n    Returns:\n      A list of quantizers with the qnoise_factor variable.\n    \"\"\"", "\n", "all_quantizers", "=", "[", "]", "\n", "for", "layer", "in", "model", ".", "layers", ":", "\n", "# A list of attributes holding the quantizer(s).", "\n", "      ", "for", "attr", "in", "[", "\"quantizers\"", ",", "\"quantizer\"", "]", ":", "\n", "        ", "if", "hasattr", "(", "layer", ",", "attr", ")", ":", "\n", "          ", "quantizers", "=", "getattr", "(", "layer", ",", "attr", ")", "\n", "quantizers", "=", "quantizers", "if", "attr", "==", "\"quantizers\"", "else", "[", "quantizers", "]", "\n", "for", "quantizer", "in", "quantizers", ":", "\n", "            ", "if", "hasattr", "(", "quantizer", ",", "\"qnoise_factor\"", ")", ":", "\n", "              ", "all_quantizers", ".", "append", "(", "quantizer", ")", "\n", "\n", "", "", "", "", "", "return", "all_quantizers", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor": [[154, 170], ["callbacks.QNoiseScheduler.calculate_qnoise_factor", "callbacks.QNoiseScheduler.set_qnoise_factor"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.calculate_qnoise_factor", "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.set_qnoise_factor"], ["", "def", "update_qnoise_factor", "(", "self", ",", "freq", ")", ":", "\n", "    ", "\"\"\"Update the qnoise_factor of the model.\n\n    Args:\n      freq: The current step (epoch) to calculate the qnoise_factor.\n    \"\"\"", "\n", "# Update the qnoise_factor at the frequency of self.update_freq.", "\n", "if", "freq", "%", "self", ".", "update_freq", "!=", "0", ":", "\n", "      ", "self", ".", "num_iters", "+=", "1", "\n", "return", "\n", "\n", "", "new_qnoise_factor", "=", "self", ".", "calculate_qnoise_factor", "(", "freq", ")", "\n", "for", "quantizer", "in", "self", ".", "quantizers", ":", "\n", "# Updates the qnoise factors of the quantizers in the model.", "\n", "      ", "self", ".", "set_qnoise_factor", "(", "quantizer", ",", "new_qnoise_factor", ")", "\n", "", "self", ".", "num_iters", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.on_train_begin": [[171, 176], ["callbacks.QNoiseScheduler.get_quantizers", "callbacks.QNoiseScheduler.set_quantizers"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.set_quantizers"], ["", "def", "on_train_begin", "(", "self", ",", "logs", "=", "None", ")", ":", "\n", "    ", "if", "not", "self", ".", "quantizers", ":", "\n", "# Build a list of quantizers which is used for updating qnoise_factor.", "\n", "      ", "self", ".", "quantizers", "=", "self", ".", "get_quantizers", "(", "self", ".", "model", ")", "\n", "self", ".", "set_quantizers", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.on_epoch_begin": [[177, 180], ["callbacks.QNoiseScheduler.update_qnoise_factor"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor"], ["", "", "def", "on_epoch_begin", "(", "self", ",", "epoch", ",", "logs", "=", "None", ")", ":", "\n", "    ", "if", "self", ".", "freq_type", "==", "\"epoch\"", ":", "\n", "      ", "self", ".", "update_qnoise_factor", "(", "self", ".", "initial_step_or_epoch", "+", "self", ".", "num_iters", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.on_epoch_end": [[181, 185], ["callbacks.QNoiseScheduler.summary_writer.as_default", "tensorflow.summary.scalar"], "methods", ["None"], ["", "", "def", "on_epoch_end", "(", "self", ",", "epoch", ",", "logs", "=", "None", ")", ":", "\n", "    ", "if", "self", ".", "summary_writer", ":", "\n", "      ", "with", "self", ".", "summary_writer", ".", "as_default", "(", ")", ":", "\n", "        ", "tf", ".", "summary", ".", "scalar", "(", "\"qnoise_factor\"", ",", "data", "=", "self", ".", "qnoise_factor", ",", "step", "=", "epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.on_train_batch_begin": [[186, 189], ["callbacks.QNoiseScheduler.update_qnoise_factor"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.callbacks.QNoiseScheduler.update_qnoise_factor"], ["", "", "", "def", "on_train_batch_begin", "(", "self", ",", "batch", ",", "logs", "=", "None", ")", ":", "\n", "    ", "if", "self", ".", "freq_type", "==", "\"step\"", ":", "\n", "      ", "self", ".", "update_qnoise_factor", "(", "self", ".", "initial_step_or_epoch", "+", "self", ".", "num_iters", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.find_bn_fusing_layer_pair": [[103, 145], ["utils.clone_model", "qtools.qgraph.GenerateGraphFromModel", "qtools.qgraph.GraphAddSingleSourceSingleSink", "qtools.qgraph.GraphRemoveNodeWithNodeType", "qtools.qgraph.GraphPropagateActivationsToEdges", "set", "networkx.topological_sort", "list", "graph.successors", "len", "set.add"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.clone_model", "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GenerateGraphFromModel", "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphAddSingleSourceSingleSink", "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphRemoveNodeWithNodeType", "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphPropagateActivationsToEdges"], ["      ", "b_sign", "=", "\"0\"", "if", "sign", "else", "\"\"", "\n", "b_str", "=", "b_sign", "+", "bin", "(", "(", "-", "b", ")", "&", "(", "(", "1", "<<", "(", "bits", "-", "sign", "+", "1", ")", ")", "-", "1", ")", ")", "[", "3", ":", "]", "\n", "", "else", ":", "\n", "      ", "b_str", "=", "str", "(", "v", ")", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "if", "b", "<=", "max_exp", ":", "\n", "      ", "v", "=", "np", ".", "power", "(", "2.0", ",", "b", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "        ", "b_str", "=", "bin", "(", "b", ")", "[", "2", ":", "]", "\n", "b_str", "=", "b_sign", "+", "\"0\"", "*", "(", "bits", "-", "sign", "-", "len", "(", "b_str", ")", ")", "+", "b_str", "\n", "", "else", ":", "\n", "        ", "b_str", "=", "str", "(", "v", ")", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "", "if", "sign", ":", "\n", "      ", "v", "=", "-", "np", ".", "power", "(", "2.0", ",", "-", "b", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "        ", "b_sign", "=", "\"1\"", "if", "sign", "else", "\"\"", "\n", "b_str", "=", "b_sign", "+", "bin", "(", "(", "-", "b", ")", "&", "(", "(", "1", "<<", "(", "bits", "-", "sign", "+", "1", ")", ")", "-", "1", ")", ")", "[", "3", ":", "]", "\n", "", "else", ":", "\n", "        ", "b_str", "=", "str", "(", "v", ")", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "if", "b", "<=", "max_exp", ":", "\n", "        ", "v", "=", "-", "np", ".", "power", "(", "2.0", ",", "b", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "          ", "b_str", "=", "bin", "(", "b", ")", "[", "2", ":", "]", "\n", "b_str", "=", "b_sign", "+", "\"0\"", "*", "(", "bits", "-", "sign", "-", "len", "(", "b_str", ")", ")", "+", "b_str", "\n", "", "else", ":", "\n", "          ", "b_str", "=", "str", "(", "v", ")", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "", "", "", "b", "=", "1", "<<", "(", "bits", "-", "sign", "-", "1", ")", "\n", "v", "=", "np", ".", "power", "(", "2.0", ",", "-", "b", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "    ", "b_sign", "=", "\"0\"", "if", "sign", "else", "\"\"", "\n", "b_str", "=", "b_sign", "+", "bin", "(", "(", "-", "b", ")", "&", "(", "(", "1", "<<", "(", "bits", "-", "sign", "+", "1", ")", ")", "-", "1", ")", ")", "[", "3", ":", "]", "\n", "", "else", ":", "\n", "    ", "b_str", "=", "str", "(", "v", ")", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "smaller_mask", "=", "b_str", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.add_bn_fusing_weights": [[147, 220], ["bn_layer.get_weights", "utils.add_bn_fusing_weights.apply_quantizer"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights"], ["if", "sign", ":", "\n", "    ", "v", "=", "-", "np", ".", "power", "(", "2.0", ",", "-", "b", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "      ", "b_sign", "=", "\"1\"", "if", "sign", "else", "\"\"", "\n", "b_str", "=", "b_sign", "+", "bin", "(", "(", "-", "b", ")", "&", "(", "(", "1", "<<", "(", "bits", "-", "sign", "+", "1", ")", ")", "-", "1", ")", ")", "[", "3", ":", "]", "\n", "", "else", ":", "\n", "      ", "b_str", "=", "str", "(", "v", ")", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "", "def", "invert_bit", "(", "bit", ",", "mask", ")", ":", "\n", "    ", "\"\"\"Inverts bits if mask is 1.\"\"\"", "\n", "\n", "if", "mask", "==", "\"0\"", ":", "\n", "      ", "return", "bit", "\n", "", "else", ":", "\n", "      ", "return", "\"0\"", "if", "bit", "==", "\"1\"", "else", "\"1\"", "\n", "\n", "", "", "if", "mode", "==", "\"bin\"", ":", "\n", "    ", "if", "make_smaller_zero", ":", "\n", "      ", "for", "v", "in", "o_dict", ":", "\n", "        ", "o_dict", "[", "v", "]", "=", "\"\"", ".", "join", "(", "\n", "invert_bit", "(", "bit", ",", "mask_bit", ")", "\n", "for", "bit", ",", "mask_bit", "in", "zip", "(", "o_dict", "[", "v", "]", ",", "smaller_mask", ")", ")", "\n", "", "", "", "else", ":", "\n", "    ", "keys_sorted", "=", "list", "(", "sorted", "(", "o_dict", ".", "keys", "(", ")", ")", ")", "\n", "if", "make_smaller_zero", ":", "\n", "      ", "min_positive_key", "=", "min", "(", "[", "abs", "(", "v", ")", "for", "v", "in", "keys_sorted", "]", ")", "\n", "min_positive_index", "=", "keys_sorted", ".", "index", "(", "min_positive_key", ")", "\n", "", "else", ":", "\n", "      ", "min_positive_index", "=", "0", "\n", "", "for", "i", ",", "k", "in", "enumerate", "(", "keys_sorted", ")", ":", "\n", "      ", "o_dict", "[", "k", "]", "=", "str", "(", "i", "-", "min_positive_index", ")", "\n", "\n", "", "", "return", "o_dict", "\n", "\n", "\n", "", "def", "get_ternary_dict", "(", "mode", "=", "\"bin\"", ")", ":", "\n", "  ", "\"\"\"Returns map from floating values to bit encoding.\"\"\"", "\n", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "    ", "return", "{", "-", "1.0", ":", "\"11\"", ",", "0.0", ":", "\"00\"", ",", "1.0", ":", "\"01\"", "}", "\n", "", "else", ":", "\n", "    ", "return", "{", "-", "1.0", ":", "\"-1\"", ",", "0.0", ":", "\"0\"", ",", "1.0", ":", "\"1\"", "}", "\n", "\n", "\n", "", "", "def", "get_binary_dict", "(", "symmetric", "=", "False", ",", "mode", "=", "\"bin\"", ")", ":", "\n", "  ", "\"\"\"Returns map from floating values to bit encoding.\"\"\"", "\n", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "    ", "if", "symmetric", ":", "\n", "      ", "return", "{", "-", "1.0", ":", "\"10\"", ",", "1.0", ":", "\"01\"", "}", "\n", "", "else", ":", "\n", "      ", "return", "{", "0.0", ":", "\"0\"", ",", "1.0", ":", "\"1\"", "}", "\n", "", "", "else", ":", "\n", "    ", "if", "symmetric", ":", "\n", "      ", "return", "{", "-", "1.0", ":", "\"-1\"", ",", "1.0", ":", "\"1\"", "}", "\n", "", "else", ":", "\n", "      ", "return", "{", "0.0", ":", "\"0\"", ",", "1.0", ":", "\"1\"", "}", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_save_quantized_weights": [[223, 407], ["utils.find_bn_fusing_layer_pair", "print", "hasattr", "model.save_weights", "any", "zip", "layer.get_weights", "layer.get_quantizers", "layer.get_folded_weights", "any", "isinstance", "weights.append", "hw_weights.append", "isinstance", "isinstance", "isinstance", "layer.average_quantizer_internal().numpy", "any", "layer.set_weights", "print", "fusing_layer_pair_dict.keys", "print", "utils.add_bn_fusing_weights", "print", "isinstance", "layer.get_weights", "layer.get_quantizers", "layer.get_weights", "tensorflow.constant", "tensorflow.keras.backend.eval", "isinstance", "isinstance", "numpy.sign", "numpy.round", "signs.append", "scales.append", "isinstance", "layer.compute_pooling_area", "isinstance", "layer.get_quantizers", "quantizer", "hasattr", "numpy.abs", "numpy.log2", "isinstance", "tensorflow.cast_to_floatx", "tensorflow.cast_to_floatx", "hasattr", "tensorflow.cast_to_floatx", "numpy.log2", "numpy.all", "scales.append", "signs.append", "scales.append", "numpy.prod", "layer.average_quantizer_internal", "isinstance", "model.get_layer", "hasattr", "numpy.abs", "pow", "tensorflow.pow", "quantizer.scale.numpy", "numpy.round", "hasattr"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.find_bn_fusing_layer_pair", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconv2d_batchnorm.QConv2DBatchnorm.get_folded_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.add_bn_fusing_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qpooling.QGlobalAveragePooling2D.compute_pooling_area", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers"], []], "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.quantize_activation": [[409, 433], ["str", "isinstance", "layer_config.get", "isinstance"], "function", ["None"], []], "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.get_config": [[435, 444], ["quantizer_config.get", "quantizer_config.get", "quantizer.get.get"], "function", ["None"], []], "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.is_TFOpLambda_layer": [[446, 449], ["isinstance"], "function", ["None"], []], "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.get_y_from_TFOpLambda": [[451, 475], ["None"], "function", ["None"], []], "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.convert_to_folded_model": [[477, 571], ["utils.clone_model", "model.get_config", "qtools.qgraph.GenerateGraphFromModel", "qtools.qgraph.GraphAddSingleSourceSingleSink", "qtools.qgraph.GraphRemoveNodeWithNodeType", "qtools.qgraph.GraphPropagateActivationsToEdges", "networkx.topological_sort", "networkx.topological_sort", "tensorflow.keras.models.Model", "qtools.qgraph.GraphRemoveNode", "list", "graph.predecessors", "utils.is_TFOpLambda_layer", "graph.edges", "graph.successors", "len", "bn_nodes_to_delete.append", "layers_to_fold.append", "layer_input_tensors[].deref.append", "len", "layer_input_tensors[].deref", "utils.get_y_from_TFOpLambda", "layer", "layer", "layer.ref", "t.deref", "model_outputs.append"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.clone_model", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GenerateGraphFromModel", "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphAddSingleSourceSingleSink", "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphRemoveNodeWithNodeType", "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphPropagateActivationsToEdges", "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphRemoveNode", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.is_TFOpLambda_layer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.get_y_from_TFOpLambda"], []], "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize": [[573, 1013], ["copy.deepcopy", "copy.deepcopy", "utils.quantized_model_from_json", "utils.convert_to_folded_model", "json.loads", "utils.get_config", "utils.get_config", "utils.get_config", "utils.get_config", "json.dumps", "zip", "len", "model.to_json", "utils.get_config", "utils.quantize_activation", "utils.get_config", "utils.get_config", "utils.get_config", "layer.get_weights", "utils.get_config", "utils.get_config", "utils.get_config", "utils.get_config", "utils.get_config", "utils.quantize_activation", "utils.get_config", "utils.get_config", "qlayer.set_weights", "utils.get_config", "utils.get_config", "utils.get_config", "utils.get_config", "utils.get_config", "utils.quantize_activation", "utils.model_quantize.quantize_rnn"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.quantized_model_from_json", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.convert_to_folded_model", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.quantize_activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.quantize_activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.quantize_activation"], []], "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils._add_supported_quantized_objects": [[1015, 1055], ["None"], "function", ["None"], []], "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.clone_model": [[1057, 1081], ["copy.deepcopy", "utils._add_supported_quantized_objects", "model.to_json", "utils.quantized_model_from_json", "quantized_model_from_json.set_weights", "tensorflow.keras.models.model_from_config", "tf.keras.models.model_from_config.set_weights", "model.get_weights", "model.get_config", "model.get_weights"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.utils._add_supported_quantized_objects", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.quantized_model_from_json", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights"], []], "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.quantized_model_from_json": [[1083, 1095], ["copy.deepcopy", "utils._add_supported_quantized_objects", "tensorflow.keras.models.model_from_json"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.utils._add_supported_quantized_objects"], []], "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.load_qmodel": [[1097, 1129], ["copy.deepcopy", "utils._add_supported_quantized_objects", "tensorflow.keras.models.load_model"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.utils._add_supported_quantized_objects"], []], "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.print_model_sparsity": [[1131, 1157], ["print", "print", "print", "isinstance", "layer.layer.get_prunable_weights", "isinstance", "print", "numpy.count_nonzero", "float", "layer.get_prunable_weights", "tensorflow_model_optimization.python.core.sparsity.keras.prune_registry.PruneRegistry.supports", "tensorflow_model_optimization.python.core.sparsity.keras.prune_registry.PruneRegistry._weight_names", "getattr", "str", "utils.print_model_sparsity._get_sparsity"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_prunable_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_prunable_weights"], []], "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.get_model_sparsity": [[1159, 1226], ["utils.model_save_quantized_weights", "len", "numpy.concatenate", "numpy.mean", "hasattr", "numpy.concatenate", "layer_sparsity.append", "layer.get_folded_weights", "layer.get_weights", "np.concatenate.append", "np.concatenate.append", "weight.ravel", "numpy.mean", "weight.numpy().ravel", "weight.numpy"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_save_quantized_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconv2d_batchnorm.QConv2DBatchnorm.get_folded_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights"], []], "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.quantized_model_debug": [[1228, 1308], ["tensorflow.keras.models.Model", "tensorflow.keras.models.Model.predict", "print", "zip", "model.get_layer", "print", "enumerate", "print", "output_names.append", "outputs.append", "numpy.min", "numpy.max", "quantizers.get_weight_scale", "print", "plt_instance.hist", "plt_instance.title", "plt_instance.show", "model.get_layer.get_weights", "model.get_layer.get_folded_weights", "print", "isinstance", "print", "numpy.min", "numpy.max", "p.flatten", "hasattr", "tensorflow.eval", "numpy.min", "numpy.max", "model.get_layer.get_quantizers", "quantizers.get_weight_scale", "numpy.where", "numpy.min", "numpy.max", "numpy.min", "numpy.max", "tensorflow.constant", "plt_instance.hist", "plt_instance.title", "plt_instance.show", "model.get_layer.get_quantizers", "model.get_layer.get_quantizers", "np.where.flatten"], "function", ["home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_weight_scale", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconv2d_batchnorm.QConv2DBatchnorm.get_folded_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_weight_scale", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers"], []], "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.quantized_model_dump": [[1310, 1349], ["tensorflow.keras.models.Model", "tensorflow.keras.models.Model.predict", "zip", "os.path.exists", "os.makedirs", "print", "os.path.join", "print", "tempfile.TemporaryDirectory", "print", "y_names.append", "outputs.append", "open", "tensor_data.astype().tofile", "tensor_data.astype"], "function", ["home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict"], []], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QConv1D.__init__": [[62, 135], ["quantizers.get_quantizer", "quantizers.get_quantizer", "hasattr", "qlayers.get_auto_range_constraint_initializer", "tensorflow.keras.layers.Conv1D.__init__", "warnings.warn", "warnings.warn", "qconvolutional.QConv1D.kernel_quantizer_internal._set_trainable_parameter", "qlayers.get_auto_range_constraint_initializer", "quantizers.get_quantizer"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary._set_trainable_parameter", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer"], ["def", "__init__", "(", "self", ",", "\n", "filters", ",", "\n", "kernel_size", ",", "\n", "strides", "=", "1", ",", "\n", "padding", "=", "\"valid\"", ",", "\n", "dilation_rate", "=", "1", ",", "\n", "activation", "=", "None", ",", "\n", "use_bias", "=", "True", ",", "\n", "kernel_initializer", "=", "\"he_normal\"", ",", "\n", "bias_initializer", "=", "\"zeros\"", ",", "\n", "kernel_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "activity_regularizer", "=", "None", ",", "\n", "kernel_constraint", "=", "None", ",", "\n", "bias_constraint", "=", "None", ",", "\n", "kernel_quantizer", "=", "None", ",", "\n", "bias_quantizer", "=", "None", ",", "\n", "kernel_range", "=", "None", ",", "\n", "bias_range", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "    ", "if", "kernel_range", "is", "not", "None", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"kernel_range is deprecated in QConv1D layer.\"", ")", "\n", "\n", "", "if", "bias_range", "is", "not", "None", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"bias_range is deprecated in QConv1D layer.\"", ")", "\n", "\n", "", "self", ".", "kernel_range", "=", "kernel_range", "\n", "self", ".", "bias_range", "=", "bias_range", "\n", "\n", "self", ".", "kernel_quantizer", "=", "kernel_quantizer", "\n", "self", ".", "bias_quantizer", "=", "bias_quantizer", "\n", "\n", "self", ".", "kernel_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "kernel_quantizer", ")", "\n", "self", ".", "bias_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "bias_quantizer", ")", "\n", "\n", "# optimize parameter set to \"auto\" scaling mode if possible", "\n", "if", "hasattr", "(", "self", ".", "kernel_quantizer_internal", ",", "\"_set_trainable_parameter\"", ")", ":", "\n", "      ", "self", ".", "kernel_quantizer_internal", ".", "_set_trainable_parameter", "(", ")", "\n", "\n", "", "self", ".", "quantizers", "=", "[", "\n", "self", ".", "kernel_quantizer_internal", ",", "self", ".", "bias_quantizer_internal", "\n", "]", "\n", "\n", "kernel_constraint", ",", "kernel_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "kernel_quantizer_internal", ",", "\n", "kernel_constraint", ",", "\n", "kernel_initializer", ")", ")", "\n", "\n", "if", "use_bias", ":", "\n", "      ", "bias_constraint", ",", "bias_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "bias_quantizer_internal", ",", "\n", "bias_constraint", ",", "\n", "bias_initializer", ")", ")", "\n", "", "if", "activation", "is", "not", "None", ":", "\n", "      ", "activation", "=", "get_quantizer", "(", "activation", ")", "\n", "\n", "", "super", "(", "QConv1D", ",", "self", ")", ".", "__init__", "(", "\n", "filters", "=", "filters", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "dilation_rate", "=", "dilation_rate", ",", "\n", "activation", "=", "activation", ",", "\n", "use_bias", "=", "use_bias", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "activity_regularizer", "=", "activity_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QConv1D.call": [[136, 162], ["tensorflow.keras.backend.conv1d", "qconvolutional.QConv1D.kernel_quantizer_internal", "tensorflow.keras.backend.bias_add", "qconvolutional.QConv1D.activation", "qconvolutional.QConv1D.bias_quantizer_internal"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.kernel_quantizer_internal", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QBidirectional.activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.bias_quantizer_internal"], ["", "def", "call", "(", "self", ",", "inputs", ")", ":", "\n", "    ", "if", "self", ".", "kernel_quantizer", ":", "\n", "      ", "quantized_kernel", "=", "self", ".", "kernel_quantizer_internal", "(", "self", ".", "kernel", ")", "\n", "", "else", ":", "\n", "      ", "quantized_kernel", "=", "self", ".", "kernel", "\n", "\n", "", "outputs", "=", "tf", ".", "keras", ".", "backend", ".", "conv1d", "(", "\n", "inputs", ",", "\n", "quantized_kernel", ",", "\n", "strides", "=", "self", ".", "strides", "[", "0", "]", ",", "\n", "padding", "=", "self", ".", "padding", ",", "\n", "data_format", "=", "self", ".", "data_format", ",", "\n", "dilation_rate", "=", "self", ".", "dilation_rate", "[", "0", "]", ")", "\n", "\n", "if", "self", ".", "use_bias", ":", "\n", "      ", "if", "self", ".", "bias_quantizer", ":", "\n", "        ", "quantized_bias", "=", "self", ".", "bias_quantizer_internal", "(", "self", ".", "bias", ")", "\n", "", "else", ":", "\n", "        ", "quantized_bias", "=", "self", ".", "bias", "\n", "\n", "", "outputs", "=", "tf", ".", "keras", ".", "backend", ".", "bias_add", "(", "\n", "outputs", ",", "quantized_bias", ",", "data_format", "=", "self", ".", "data_format", ")", "\n", "\n", "", "if", "self", ".", "activation", "is", "not", "None", ":", "\n", "      ", "return", "self", ".", "activation", "(", "outputs", ")", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QConv1D.get_config": [[163, 174], ["super().get_config", "dict", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "list", "list", "super().get_config.items", "config.items"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "\"kernel_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "kernel_quantizer_internal", ")", ",", "\n", "\"bias_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "bias_quantizer_internal", ")", ",", "\n", "\"kernel_range\"", ":", "self", ".", "kernel_range", ",", "\n", "\"bias_range\"", ":", "self", ".", "bias_range", "\n", "}", "\n", "base_config", "=", "super", "(", "QConv1D", ",", "self", ")", ".", "get_config", "(", ")", "\n", "return", "dict", "(", "list", "(", "base_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QConv1D.get_quantization_config": [[175, 184], ["str", "str", "str", "str"], "methods", ["None"], ["", "def", "get_quantization_config", "(", "self", ")", ":", "\n", "    ", "return", "{", "\n", "\"kernel_quantizer\"", ":", "\n", "str", "(", "self", ".", "kernel_quantizer_internal", ")", ",", "\n", "\"bias_quantizer\"", ":", "\n", "str", "(", "self", ".", "bias_quantizer_internal", ")", ",", "\n", "\"activation\"", ":", "\n", "str", "(", "self", ".", "activation", ")", ",", "\n", "\"filters\"", ":", "str", "(", "self", ".", "filters", ")", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QConv1D.get_quantizers": [[186, 188], ["None"], "methods", ["None"], ["", "def", "get_quantizers", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "quantizers", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QConv1D.get_prunable_weights": [[189, 191], ["None"], "methods", ["None"], ["", "def", "get_prunable_weights", "(", "self", ")", ":", "\n", "    ", "return", "[", "self", ".", "kernel", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QConv2D.__init__": [[211, 287], ["quantizers.get_quantizer", "quantizers.get_quantizer", "hasattr", "qlayers.get_auto_range_constraint_initializer", "tensorflow.keras.layers.Conv2D.__init__", "warnings.warn", "warnings.warn", "qconvolutional.QConv2D.kernel_quantizer_internal._set_trainable_parameter", "qlayers.get_auto_range_constraint_initializer", "quantizers.get_quantizer"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary._set_trainable_parameter", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer"], ["def", "__init__", "(", "self", ",", "\n", "filters", ",", "\n", "kernel_size", ",", "\n", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "padding", "=", "\"valid\"", ",", "\n", "data_format", "=", "\"channels_last\"", ",", "\n", "dilation_rate", "=", "(", "1", ",", "1", ")", ",", "\n", "activation", "=", "None", ",", "\n", "use_bias", "=", "True", ",", "\n", "kernel_initializer", "=", "\"he_normal\"", ",", "\n", "bias_initializer", "=", "\"zeros\"", ",", "\n", "kernel_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "activity_regularizer", "=", "None", ",", "\n", "kernel_constraint", "=", "None", ",", "\n", "bias_constraint", "=", "None", ",", "\n", "kernel_range", "=", "None", ",", "\n", "bias_range", "=", "None", ",", "\n", "kernel_quantizer", "=", "None", ",", "\n", "bias_quantizer", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "    ", "if", "kernel_range", "is", "not", "None", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"kernel_range is deprecated in QConv2D layer.\"", ")", "\n", "\n", "", "if", "bias_range", "is", "not", "None", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"bias_range is deprecated in QConv2D layer.\"", ")", "\n", "\n", "", "self", ".", "kernel_range", "=", "kernel_range", "\n", "self", ".", "bias_range", "=", "bias_range", "\n", "\n", "self", ".", "kernel_quantizer", "=", "kernel_quantizer", "\n", "self", ".", "bias_quantizer", "=", "bias_quantizer", "\n", "\n", "self", ".", "kernel_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "kernel_quantizer", ")", "\n", "self", ".", "bias_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "bias_quantizer", ")", "\n", "\n", "# optimize parameter set to \"auto\" scaling mode if possible", "\n", "if", "hasattr", "(", "self", ".", "kernel_quantizer_internal", ",", "\"_set_trainable_parameter\"", ")", ":", "\n", "      ", "self", ".", "kernel_quantizer_internal", ".", "_set_trainable_parameter", "(", ")", "\n", "\n", "", "self", ".", "quantizers", "=", "[", "\n", "self", ".", "kernel_quantizer_internal", ",", "self", ".", "bias_quantizer_internal", "\n", "]", "\n", "\n", "kernel_constraint", ",", "kernel_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "kernel_quantizer_internal", ",", "\n", "kernel_constraint", ",", "\n", "kernel_initializer", ")", ")", "\n", "\n", "if", "use_bias", ":", "\n", "      ", "bias_constraint", ",", "bias_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "bias_quantizer_internal", ",", "\n", "bias_constraint", ",", "\n", "bias_initializer", ")", ")", "\n", "\n", "", "if", "activation", "is", "not", "None", ":", "\n", "      ", "activation", "=", "get_quantizer", "(", "activation", ")", "\n", "\n", "", "super", "(", "QConv2D", ",", "self", ")", ".", "__init__", "(", "\n", "filters", "=", "filters", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "data_format", "=", "data_format", ",", "\n", "dilation_rate", "=", "dilation_rate", ",", "\n", "activation", "=", "activation", ",", "\n", "use_bias", "=", "use_bias", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "activity_regularizer", "=", "activity_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QConv2D.call": [[288, 314], ["tensorflow.keras.backend.conv2d", "qconvolutional.QConv2D.kernel_quantizer_internal", "tensorflow.keras.backend.bias_add", "qconvolutional.QConv2D.activation", "qconvolutional.QConv2D.bias_quantizer_internal"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.kernel_quantizer_internal", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QBidirectional.activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.bias_quantizer_internal"], ["", "def", "call", "(", "self", ",", "inputs", ")", ":", "\n", "    ", "if", "self", ".", "kernel_quantizer", ":", "\n", "      ", "quantized_kernel", "=", "self", ".", "kernel_quantizer_internal", "(", "self", ".", "kernel", ")", "\n", "", "else", ":", "\n", "      ", "quantized_kernel", "=", "self", ".", "kernel", "\n", "\n", "", "outputs", "=", "tf", ".", "keras", ".", "backend", ".", "conv2d", "(", "\n", "inputs", ",", "\n", "quantized_kernel", ",", "\n", "strides", "=", "self", ".", "strides", ",", "\n", "padding", "=", "self", ".", "padding", ",", "\n", "data_format", "=", "self", ".", "data_format", ",", "\n", "dilation_rate", "=", "self", ".", "dilation_rate", ")", "\n", "\n", "if", "self", ".", "use_bias", ":", "\n", "      ", "if", "self", ".", "bias_quantizer", ":", "\n", "        ", "quantized_bias", "=", "self", ".", "bias_quantizer_internal", "(", "self", ".", "bias", ")", "\n", "", "else", ":", "\n", "        ", "quantized_bias", "=", "self", ".", "bias", "\n", "\n", "", "outputs", "=", "tf", ".", "keras", ".", "backend", ".", "bias_add", "(", "\n", "outputs", ",", "quantized_bias", ",", "data_format", "=", "self", ".", "data_format", ")", "\n", "\n", "", "if", "self", ".", "activation", "is", "not", "None", ":", "\n", "      ", "return", "self", ".", "activation", "(", "outputs", ")", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QConv2D.get_config": [[315, 326], ["super().get_config", "dict", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "list", "list", "super().get_config.items", "config.items"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "\"kernel_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "kernel_quantizer_internal", ")", ",", "\n", "\"bias_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "bias_quantizer_internal", ")", ",", "\n", "\"kernel_range\"", ":", "self", ".", "kernel_range", ",", "\n", "\"bias_range\"", ":", "self", ".", "bias_range", "\n", "}", "\n", "base_config", "=", "super", "(", "QConv2D", ",", "self", ")", ".", "get_config", "(", ")", "\n", "return", "dict", "(", "list", "(", "base_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QConv2D.get_quantization_config": [[327, 336], ["str", "str", "str", "str"], "methods", ["None"], ["", "def", "get_quantization_config", "(", "self", ")", ":", "\n", "    ", "return", "{", "\n", "\"kernel_quantizer\"", ":", "\n", "str", "(", "self", ".", "kernel_quantizer_internal", ")", ",", "\n", "\"bias_quantizer\"", ":", "\n", "str", "(", "self", ".", "bias_quantizer_internal", ")", ",", "\n", "\"activation\"", ":", "\n", "str", "(", "self", ".", "activation", ")", ",", "\n", "\"filters\"", ":", "str", "(", "self", ".", "filters", ")", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QConv2D.get_quantizers": [[338, 340], ["None"], "methods", ["None"], ["", "def", "get_quantizers", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "quantizers", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QConv2D.get_prunable_weights": [[341, 343], ["None"], "methods", ["None"], ["", "def", "get_prunable_weights", "(", "self", ")", ":", "\n", "    ", "return", "[", "self", ".", "kernel", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QConv2DTranspose.__init__": [[359, 426], ["quantizers.get_quantizer", "quantizers.get_quantizer", "hasattr", "qlayers.get_auto_range_constraint_initializer", "tensorflow.keras.layers.Conv2DTranspose.__init__", "qconvolutional.QConv2DTranspose.kernel_quantizer_internal._set_trainable_parameter", "qlayers.get_auto_range_constraint_initializer", "quantizers.get_quantizer"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary._set_trainable_parameter", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer"], ["def", "__init__", "(", "self", ",", "\n", "filters", ",", "\n", "kernel_size", ",", "\n", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "padding", "=", "'valid'", ",", "\n", "output_padding", "=", "None", ",", "\n", "data_format", "=", "None", ",", "\n", "dilation_rate", "=", "(", "1", ",", "1", ")", ",", "\n", "activation", "=", "None", ",", "\n", "use_bias", "=", "True", ",", "\n", "kernel_initializer", "=", "'glorot_uniform'", ",", "\n", "bias_initializer", "=", "'zeros'", ",", "\n", "kernel_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "activity_regularizer", "=", "None", ",", "\n", "kernel_constraint", "=", "None", ",", "\n", "bias_constraint", "=", "None", ",", "\n", "kernel_quantizer", "=", "None", ",", "\n", "bias_quantizer", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "    ", "self", ".", "kernel_quantizer", "=", "kernel_quantizer", "\n", "self", ".", "bias_quantizer", "=", "bias_quantizer", "\n", "\n", "self", ".", "kernel_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "kernel_quantizer", ")", "\n", "self", ".", "bias_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "bias_quantizer", ")", "\n", "\n", "# optimize parameter set to \"auto\" scaling mode if possible", "\n", "if", "hasattr", "(", "self", ".", "kernel_quantizer_internal", ",", "\"_set_trainable_parameter\"", ")", ":", "\n", "      ", "self", ".", "kernel_quantizer_internal", ".", "_set_trainable_parameter", "(", ")", "\n", "\n", "", "self", ".", "quantizers", "=", "[", "\n", "self", ".", "kernel_quantizer_internal", ",", "self", ".", "bias_quantizer_internal", "\n", "]", "\n", "\n", "kernel_constraint", ",", "kernel_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "kernel_quantizer_internal", ",", "\n", "kernel_constraint", ",", "\n", "kernel_initializer", ")", ")", "\n", "\n", "if", "use_bias", ":", "\n", "      ", "bias_constraint", ",", "bias_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "bias_quantizer_internal", ",", "\n", "bias_constraint", ",", "\n", "bias_initializer", ")", ")", "\n", "\n", "", "if", "activation", "is", "not", "None", ":", "\n", "      ", "activation", "=", "get_quantizer", "(", "activation", ")", "\n", "\n", "", "super", "(", "QConv2DTranspose", ",", "self", ")", ".", "__init__", "(", "\n", "filters", "=", "filters", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "output_padding", "=", "None", ",", "\n", "data_format", "=", "data_format", ",", "\n", "dilation_rate", "=", "dilation_rate", ",", "\n", "activation", "=", "activation", ",", "\n", "use_bias", "=", "use_bias", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "activity_regularizer", "=", "activity_regularizer", ",", "\n", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QConv2DTranspose.call": [[427, 496], ["tensorflow.python.ops.array_ops.shape", "tensorflow.python.keras.utils.conv_utils.deconv_output_length", "tensorflow.python.keras.utils.conv_utils.deconv_output_length", "tensorflow.python.ops.array_ops.stack", "tensorflow.keras.backend.conv2d_transpose", "qconvolutional.QConv2DTranspose.kernel_quantizer_internal", "tensorflow.python.eager.context.executing_eagerly", "qconvolutional.QConv2DTranspose.compute_output_shape", "tensorflow.keras.backend.bias_add.set_shape", "tensorflow.keras.backend.bias_add", "qconvolutional.QConv2DTranspose.activation", "qconvolutional.QConv2DTranspose.bias_quantizer_internal"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.kernel_quantizer_internal", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QDense.compute_output_shape", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QBidirectional.activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.bias_quantizer_internal"], ["", "def", "call", "(", "self", ",", "inputs", ")", ":", "\n", "    ", "inputs_shape", "=", "array_ops", ".", "shape", "(", "inputs", ")", "\n", "batch_size", "=", "inputs_shape", "[", "0", "]", "\n", "if", "self", ".", "data_format", "==", "'channels_first'", ":", "\n", "      ", "h_axis", ",", "w_axis", "=", "2", ",", "3", "\n", "", "else", ":", "\n", "      ", "h_axis", ",", "w_axis", "=", "1", ",", "2", "\n", "\n", "", "height", ",", "width", "=", "inputs_shape", "[", "h_axis", "]", ",", "inputs_shape", "[", "w_axis", "]", "\n", "kernel_h", ",", "kernel_w", "=", "self", ".", "kernel_size", "\n", "stride_h", ",", "stride_w", "=", "self", ".", "strides", "\n", "\n", "if", "self", ".", "output_padding", "is", "None", ":", "\n", "      ", "out_pad_h", "=", "out_pad_w", "=", "None", "\n", "", "else", ":", "\n", "      ", "out_pad_h", ",", "out_pad_w", "=", "self", ".", "output_padding", "\n", "\n", "# Infer the dynamic output shape:", "\n", "", "out_height", "=", "conv_utils", ".", "deconv_output_length", "(", "height", ",", "\n", "kernel_h", ",", "\n", "padding", "=", "self", ".", "padding", ",", "\n", "output_padding", "=", "out_pad_h", ",", "\n", "stride", "=", "stride_h", ",", "\n", "dilation", "=", "self", ".", "dilation_rate", "[", "0", "]", ")", "\n", "out_width", "=", "conv_utils", ".", "deconv_output_length", "(", "width", ",", "\n", "kernel_w", ",", "\n", "padding", "=", "self", ".", "padding", ",", "\n", "output_padding", "=", "out_pad_w", ",", "\n", "stride", "=", "stride_w", ",", "\n", "dilation", "=", "self", ".", "dilation_rate", "[", "1", "]", ")", "\n", "if", "self", ".", "data_format", "==", "'channels_first'", ":", "\n", "      ", "output_shape", "=", "(", "batch_size", ",", "self", ".", "filters", ",", "out_height", ",", "out_width", ")", "\n", "", "else", ":", "\n", "      ", "output_shape", "=", "(", "batch_size", ",", "out_height", ",", "out_width", ",", "self", ".", "filters", ")", "\n", "\n", "", "if", "self", ".", "kernel_quantizer", ":", "\n", "      ", "quantized_kernel", "=", "self", ".", "kernel_quantizer_internal", "(", "self", ".", "kernel", ")", "\n", "", "else", ":", "\n", "      ", "quantized_kernel", "=", "self", ".", "kernel", "\n", "\n", "", "output_shape_tensor", "=", "array_ops", ".", "stack", "(", "output_shape", ")", "\n", "outputs", "=", "tf", ".", "keras", ".", "backend", ".", "conv2d_transpose", "(", "\n", "inputs", ",", "\n", "quantized_kernel", ",", "\n", "output_shape_tensor", ",", "\n", "strides", "=", "self", ".", "strides", ",", "\n", "padding", "=", "self", ".", "padding", ",", "\n", "data_format", "=", "self", ".", "data_format", ",", "\n", "dilation_rate", "=", "self", ".", "dilation_rate", ")", "\n", "\n", "if", "not", "context", ".", "executing_eagerly", "(", ")", ":", "\n", "# Infer the static output shape:", "\n", "      ", "out_shape", "=", "self", ".", "compute_output_shape", "(", "inputs", ".", "shape", ")", "\n", "outputs", ".", "set_shape", "(", "out_shape", ")", "\n", "\n", "", "if", "self", ".", "use_bias", ":", "\n", "      ", "if", "self", ".", "bias_quantizer", ":", "\n", "        ", "quantized_bias", "=", "self", ".", "bias_quantizer_internal", "(", "self", ".", "bias", ")", "\n", "", "else", ":", "\n", "        ", "quantized_bias", "=", "self", ".", "bias", "\n", "\n", "", "outputs", "=", "tf", ".", "keras", ".", "backend", ".", "bias_add", "(", "\n", "outputs", ",", "\n", "quantized_bias", ",", "\n", "data_format", "=", "self", ".", "data_format", ")", "\n", "\n", "", "if", "self", ".", "activation", "is", "not", "None", ":", "\n", "      ", "return", "self", ".", "activation", "(", "outputs", ")", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QConv2DTranspose.get_config": [[497, 506], ["super().get_config", "dict", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "list", "list", "super().get_config.items", "config.items"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "\"kernel_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "kernel_quantizer_internal", ")", ",", "\n", "\"bias_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "bias_quantizer_internal", ")", "\n", "}", "\n", "base_config", "=", "super", "(", "QConv2DTranspose", ",", "self", ")", ".", "get_config", "(", ")", "\n", "return", "dict", "(", "list", "(", "base_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QConv2DTranspose.get_quantizers": [[507, 509], ["None"], "methods", ["None"], ["", "def", "get_quantizers", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "quantizers", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QConv2DTranspose.get_prunable_weights": [[510, 512], ["None"], "methods", ["None"], ["", "def", "get_prunable_weights", "(", "self", ")", ":", "\n", "    ", "return", "[", "self", ".", "kernel", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QSeparableConv1D.__init__": [[529, 614], ["quantizers.get_quantizer", "quantizers.get_quantizer", "quantizers.get_quantizer", "hasattr", "hasattr", "qlayers.get_auto_range_constraint_initializer", "qlayers.get_auto_range_constraint_initializer", "tensorflow.keras.layers.SeparableConv1D.__init__", "qconvolutional.QSeparableConv1D.depthwise_quantizer_internal._set_trainable_parameter", "qconvolutional.QSeparableConv1D.pointwise_quantizer_internal._set_trainable_parameter", "qlayers.get_auto_range_constraint_initializer", "quantizers.get_quantizer", "tensorflow.keras.initializers.get", "tensorflow.keras.initializers.get", "tensorflow.keras.initializers.get", "tensorflow.keras.regularizers.get", "tensorflow.keras.regularizers.get", "tensorflow.keras.regularizers.get", "tensorflow.keras.regularizers.get", "tensorflow.keras.constraints.get", "tensorflow.keras.constraints.get", "tensorflow.keras.constraints.get"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary._set_trainable_parameter", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary._set_trainable_parameter", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer"], ["def", "__init__", "(", "self", ",", "\n", "filters", ",", "\n", "kernel_size", ",", "\n", "strides", "=", "1", ",", "\n", "padding", "=", "'valid'", ",", "\n", "data_format", "=", "None", ",", "\n", "dilation_rate", "=", "1", ",", "\n", "depth_multiplier", "=", "1", ",", "\n", "activation", "=", "None", ",", "\n", "use_bias", "=", "True", ",", "\n", "depthwise_initializer", "=", "'glorot_uniform'", ",", "\n", "pointwise_initializer", "=", "'glorot_uniform'", ",", "\n", "bias_initializer", "=", "'zeros'", ",", "\n", "depthwise_regularizer", "=", "None", ",", "\n", "pointwise_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "activity_regularizer", "=", "None", ",", "\n", "depthwise_constraint", "=", "None", ",", "\n", "pointwise_constraint", "=", "None", ",", "\n", "bias_constraint", "=", "None", ",", "\n", "depthwise_quantizer", "=", "None", ",", "\n", "pointwise_quantizer", "=", "None", ",", "\n", "bias_quantizer", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "    ", "self", ".", "depthwise_quantizer", "=", "depthwise_quantizer", "\n", "self", ".", "pointwise_quantizer", "=", "pointwise_quantizer", "\n", "self", ".", "bias_quantizer", "=", "bias_quantizer", "\n", "\n", "self", ".", "depthwise_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "depthwise_quantizer", ")", "\n", "self", ".", "pointwise_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "pointwise_quantizer", ")", "\n", "self", ".", "bias_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "bias_quantizer", ")", "\n", "\n", "# optimize parameter set to \"auto\" scaling mode if possible", "\n", "if", "hasattr", "(", "self", ".", "depthwise_quantizer_internal", ",", "\"_set_trainable_parameter\"", ")", ":", "\n", "      ", "self", ".", "depthwise_quantizer_internal", ".", "_set_trainable_parameter", "(", ")", "\n", "\n", "", "if", "hasattr", "(", "self", ".", "pointwise_quantizer_internal", ",", "\"_set_trainable_parameter\"", ")", ":", "\n", "      ", "self", ".", "pointwise_quantizer_internal", ".", "_set_trainable_parameter", "(", ")", "\n", "\n", "", "self", ".", "quantizers", "=", "[", "\n", "self", ".", "depthwise_quantizer_internal", ",", "self", ".", "pointwise_quantizer_internal", ",", "\n", "self", ".", "bias_quantizer_internal", "\n", "]", "\n", "\n", "depthwise_constraint", ",", "depthwise_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "depthwise_quantizer_internal", ",", "\n", "depthwise_constraint", ",", "\n", "depthwise_initializer", ")", ")", "\n", "\n", "pointwise_constraint", ",", "pointwise_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "pointwise_quantizer_internal", ",", "\n", "pointwise_constraint", ",", "\n", "pointwise_initializer", ")", ")", "\n", "\n", "if", "use_bias", ":", "\n", "      ", "bias_constraint", ",", "bias_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "bias_quantizer_internal", ",", "\n", "bias_constraint", ",", "\n", "bias_initializer", ")", ")", "\n", "\n", "", "if", "activation", "is", "not", "None", ":", "\n", "      ", "activation", "=", "get_quantizer", "(", "activation", ")", "\n", "\n", "", "super", "(", "QSeparableConv1D", ",", "self", ")", ".", "__init__", "(", "\n", "filters", "=", "filters", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "data_format", "=", "data_format", ",", "\n", "dilation_rate", "=", "dilation_rate", ",", "\n", "depth_multiplier", "=", "depth_multiplier", ",", "\n", "activation", "=", "activation", ",", "\n", "use_bias", "=", "use_bias", ",", "\n", "depthwise_initializer", "=", "initializers", ".", "get", "(", "depthwise_initializer", ")", ",", "\n", "pointwise_initializer", "=", "initializers", ".", "get", "(", "pointwise_initializer", ")", ",", "\n", "bias_initializer", "=", "initializers", ".", "get", "(", "bias_initializer", ")", ",", "\n", "depthwise_regularizer", "=", "regularizers", ".", "get", "(", "depthwise_regularizer", ")", ",", "\n", "pointwise_regularizer", "=", "regularizers", ".", "get", "(", "pointwise_regularizer", ")", ",", "\n", "bias_regularizer", "=", "regularizers", ".", "get", "(", "bias_regularizer", ")", ",", "\n", "activity_regularizer", "=", "regularizers", ".", "get", "(", "activity_regularizer", ")", ",", "\n", "depthwise_constraint", "=", "constraints", ".", "get", "(", "depthwise_constraint", ")", ",", "\n", "pointwise_constraint", "=", "constraints", ".", "get", "(", "pointwise_constraint", ")", ",", "\n", "bias_constraint", "=", "constraints", ".", "get", "(", "bias_constraint", ")", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QSeparableConv1D.call": [[615, 669], ["tensorflow.python.ops.array_ops.expand_dims", "tensorflow.python.ops.array_ops.expand_dims", "tensorflow.python.ops.array_ops.expand_dims", "tensorflow.keras.backend.separable_conv2d", "tensorflow.python.ops.array_ops.squeeze", "tensorflow.python.ops.array_ops.pad", "qconvolutional.QSeparableConv1D.depthwise_quantizer_internal", "qconvolutional.QSeparableConv1D.pointwise_quantizer_internal", "tensorflow.keras.backend.bias_add", "qconvolutional.QSeparableConv1D.activation", "qconvolutional.QSeparableConv1D._compute_causal_padding", "qconvolutional.QSeparableConv1D.bias_quantizer_internal"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QBidirectional.activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.bias_quantizer_internal"], ["", "def", "call", "(", "self", ",", "inputs", ")", ":", "\n", "    ", "if", "self", ".", "padding", "==", "'causal'", ":", "\n", "      ", "inputs", "=", "array_ops", ".", "pad", "(", "inputs", ",", "self", ".", "_compute_causal_padding", "(", ")", ")", "\n", "\n", "", "spatial_start_dim", "=", "1", "if", "self", ".", "data_format", "==", "'channels_last'", "else", "2", "\n", "\n", "# Explicitly broadcast inputs and kernels to 4D.", "\n", "inputs", "=", "array_ops", ".", "expand_dims", "(", "inputs", ",", "spatial_start_dim", ")", "\n", "depthwise_kernel", "=", "array_ops", ".", "expand_dims", "(", "self", ".", "depthwise_kernel", ",", "0", ")", "\n", "pointwise_kernel", "=", "array_ops", ".", "expand_dims", "(", "self", ".", "pointwise_kernel", ",", "0", ")", "\n", "dilation_rate", "=", "(", "1", ",", ")", "+", "self", ".", "dilation_rate", "\n", "\n", "if", "self", ".", "padding", "==", "'causal'", ":", "\n", "      ", "op_padding", "=", "'valid'", "\n", "", "else", ":", "\n", "      ", "op_padding", "=", "self", ".", "padding", "\n", "\n", "", "if", "self", ".", "depthwise_quantizer", ":", "\n", "      ", "quantized_depthwise_kernel", "=", "self", ".", "depthwise_quantizer_internal", "(", "\n", "depthwise_kernel", ")", "\n", "", "else", ":", "\n", "      ", "quantized_depthwise_kernel", "=", "depthwise_kernel", "\n", "\n", "", "if", "self", ".", "pointwise_quantizer", ":", "\n", "      ", "quantized_pointwise_kernel", "=", "self", ".", "pointwise_quantizer_internal", "(", "\n", "pointwise_kernel", ")", "\n", "", "else", ":", "\n", "      ", "quantized_pointwise_kernel", "=", "pointwise_kernel", "\n", "\n", "", "outputs", "=", "tf", ".", "keras", ".", "backend", ".", "separable_conv2d", "(", "\n", "inputs", ",", "\n", "quantized_depthwise_kernel", ",", "\n", "quantized_pointwise_kernel", ",", "\n", "strides", "=", "self", ".", "strides", "*", "2", ",", "\n", "padding", "=", "op_padding", ",", "\n", "dilation_rate", "=", "dilation_rate", ",", "\n", "data_format", "=", "self", ".", "data_format", ")", "\n", "\n", "if", "self", ".", "use_bias", ":", "\n", "      ", "if", "self", ".", "bias_quantizer", ":", "\n", "        ", "quantized_bias", "=", "self", ".", "bias_quantizer_internal", "(", "self", ".", "bias", ")", "\n", "", "else", ":", "\n", "        ", "quantized_bias", "=", "self", ".", "bias", "\n", "\n", "", "outputs", "=", "tf", ".", "keras", ".", "backend", ".", "bias_add", "(", "\n", "outputs", ",", "\n", "quantized_bias", ",", "\n", "data_format", "=", "self", ".", "data_format", ")", "\n", "\n", "", "outputs", "=", "array_ops", ".", "squeeze", "(", "outputs", ",", "[", "spatial_start_dim", "]", ")", "\n", "\n", "if", "self", ".", "activation", "is", "not", "None", ":", "\n", "      ", "return", "self", ".", "activation", "(", "outputs", ")", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QSeparableConv1D.get_config": [[670, 681], ["super().get_config", "dict", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "list", "list", "super().get_config.items", "config.items"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "\"depthwise_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "depthwise_quantizer_internal", ")", ",", "\n", "\"pointwise_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "pointwise_quantizer_internal", ")", ",", "\n", "\"bias_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "bias_quantizer_internal", ")", "\n", "}", "\n", "base_config", "=", "super", "(", "QSeparableConv1D", ",", "self", ")", ".", "get_config", "(", ")", "\n", "return", "dict", "(", "list", "(", "base_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QSeparableConv1D.get_quantizers": [[682, 684], ["None"], "methods", ["None"], ["", "def", "get_quantizers", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "quantizers", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QSeparableConv1D.get_prunable_weights": [[685, 687], ["None"], "methods", ["None"], ["", "def", "get_prunable_weights", "(", "self", ")", ":", "\n", "    ", "return", "[", "self", ".", "depthwise_kernel", ",", "self", ".", "pointwise_kernel", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QSeparableConv2D.__init__": [[704, 789], ["quantizers.get_quantizer", "quantizers.get_quantizer", "quantizers.get_quantizer", "hasattr", "hasattr", "qlayers.get_auto_range_constraint_initializer", "qlayers.get_auto_range_constraint_initializer", "tensorflow.keras.layers.SeparableConv2D.__init__", "qconvolutional.QSeparableConv2D.depthwise_quantizer_internal._set_trainable_parameter", "qconvolutional.QSeparableConv2D.pointwise_quantizer_internal._set_trainable_parameter", "qlayers.get_auto_range_constraint_initializer", "quantizers.get_quantizer", "tensorflow.keras.initializers.get", "tensorflow.keras.initializers.get", "tensorflow.keras.initializers.get", "tensorflow.keras.regularizers.get", "tensorflow.keras.regularizers.get", "tensorflow.keras.regularizers.get", "tensorflow.keras.regularizers.get", "tensorflow.keras.constraints.get", "tensorflow.keras.constraints.get", "tensorflow.keras.constraints.get"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary._set_trainable_parameter", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary._set_trainable_parameter", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer"], ["def", "__init__", "(", "self", ",", "\n", "filters", ",", "\n", "kernel_size", ",", "\n", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "padding", "=", "'valid'", ",", "\n", "data_format", "=", "None", ",", "\n", "dilation_rate", "=", "(", "1", ",", "1", ")", ",", "\n", "depth_multiplier", "=", "1", ",", "\n", "activation", "=", "None", ",", "\n", "use_bias", "=", "True", ",", "\n", "depthwise_initializer", "=", "'glorot_uniform'", ",", "\n", "pointwise_initializer", "=", "'glorot_uniform'", ",", "\n", "bias_initializer", "=", "'zeros'", ",", "\n", "depthwise_regularizer", "=", "None", ",", "\n", "pointwise_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "activity_regularizer", "=", "None", ",", "\n", "depthwise_constraint", "=", "None", ",", "\n", "pointwise_constraint", "=", "None", ",", "\n", "bias_constraint", "=", "None", ",", "\n", "depthwise_quantizer", "=", "None", ",", "\n", "pointwise_quantizer", "=", "None", ",", "\n", "bias_quantizer", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "    ", "self", ".", "depthwise_quantizer", "=", "depthwise_quantizer", "\n", "self", ".", "pointwise_quantizer", "=", "pointwise_quantizer", "\n", "self", ".", "bias_quantizer", "=", "bias_quantizer", "\n", "\n", "self", ".", "depthwise_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "depthwise_quantizer", ")", "\n", "self", ".", "pointwise_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "pointwise_quantizer", ")", "\n", "self", ".", "bias_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "bias_quantizer", ")", "\n", "\n", "# optimize parameter set to \"auto\" scaling mode if possible", "\n", "if", "hasattr", "(", "self", ".", "depthwise_quantizer_internal", ",", "\"_set_trainable_parameter\"", ")", ":", "\n", "      ", "self", ".", "depthwise_quantizer_internal", ".", "_set_trainable_parameter", "(", ")", "\n", "\n", "", "if", "hasattr", "(", "self", ".", "pointwise_quantizer_internal", ",", "\"_set_trainable_parameter\"", ")", ":", "\n", "      ", "self", ".", "pointwise_quantizer_internal", ".", "_set_trainable_parameter", "(", ")", "\n", "\n", "", "self", ".", "quantizers", "=", "[", "\n", "self", ".", "depthwise_quantizer_internal", ",", "self", ".", "pointwise_quantizer_internal", ",", "\n", "self", ".", "bias_quantizer_internal", "\n", "]", "\n", "\n", "depthwise_constraint", ",", "depthwise_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "depthwise_quantizer_internal", ",", "\n", "depthwise_constraint", ",", "\n", "depthwise_initializer", ")", ")", "\n", "\n", "pointwise_constraint", ",", "pointwise_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "pointwise_quantizer_internal", ",", "\n", "pointwise_constraint", ",", "\n", "pointwise_initializer", ")", ")", "\n", "\n", "if", "use_bias", ":", "\n", "      ", "bias_constraint", ",", "bias_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "bias_quantizer_internal", ",", "\n", "bias_constraint", ",", "\n", "bias_initializer", ")", ")", "\n", "\n", "", "if", "activation", "is", "not", "None", ":", "\n", "      ", "activation", "=", "get_quantizer", "(", "activation", ")", "\n", "\n", "", "super", "(", "QSeparableConv2D", ",", "self", ")", ".", "__init__", "(", "\n", "filters", "=", "filters", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "data_format", "=", "data_format", ",", "\n", "dilation_rate", "=", "dilation_rate", ",", "\n", "depth_multiplier", "=", "depth_multiplier", ",", "\n", "activation", "=", "activation", ",", "\n", "use_bias", "=", "use_bias", ",", "\n", "depthwise_initializer", "=", "initializers", ".", "get", "(", "depthwise_initializer", ")", ",", "\n", "pointwise_initializer", "=", "initializers", ".", "get", "(", "pointwise_initializer", ")", ",", "\n", "bias_initializer", "=", "initializers", ".", "get", "(", "bias_initializer", ")", ",", "\n", "depthwise_regularizer", "=", "regularizers", ".", "get", "(", "depthwise_regularizer", ")", ",", "\n", "pointwise_regularizer", "=", "regularizers", ".", "get", "(", "pointwise_regularizer", ")", ",", "\n", "bias_regularizer", "=", "regularizers", ".", "get", "(", "bias_regularizer", ")", ",", "\n", "activity_regularizer", "=", "regularizers", ".", "get", "(", "activity_regularizer", ")", ",", "\n", "depthwise_constraint", "=", "constraints", ".", "get", "(", "depthwise_constraint", ")", ",", "\n", "pointwise_constraint", "=", "constraints", ".", "get", "(", "pointwise_constraint", ")", ",", "\n", "bias_constraint", "=", "constraints", ".", "get", "(", "bias_constraint", ")", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QSeparableConv2D.call": [[790, 827], ["tensorflow.keras.backend.separable_conv2d", "qconvolutional.QSeparableConv2D.depthwise_quantizer_internal", "qconvolutional.QSeparableConv2D.pointwise_quantizer_internal", "tensorflow.keras.backend.bias_add", "qconvolutional.QSeparableConv2D.activation", "qconvolutional.QSeparableConv2D.bias_quantizer_internal"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QBidirectional.activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.bias_quantizer_internal"], ["", "def", "call", "(", "self", ",", "inputs", ")", ":", "\n", "# Apply the actual ops.", "\n", "    ", "if", "self", ".", "depthwise_quantizer", ":", "\n", "      ", "quantized_depthwise_kernel", "=", "self", ".", "depthwise_quantizer_internal", "(", "\n", "self", ".", "depthwise_kernel", ")", "\n", "", "else", ":", "\n", "      ", "quantized_depthwise_kernel", "=", "self", ".", "depthwise_kernel", "\n", "\n", "", "if", "self", ".", "pointwise_quantizer", ":", "\n", "      ", "quantized_pointwise_kernel", "=", "self", ".", "pointwise_quantizer_internal", "(", "\n", "self", ".", "pointwise_kernel", ")", "\n", "", "else", ":", "\n", "      ", "quantized_pointwise_kernel", "=", "self", ".", "pointwise_kernel", "\n", "\n", "", "outputs", "=", "tf", ".", "keras", ".", "backend", ".", "separable_conv2d", "(", "\n", "inputs", ",", "\n", "quantized_depthwise_kernel", ",", "\n", "quantized_pointwise_kernel", ",", "\n", "strides", "=", "self", ".", "strides", ",", "\n", "padding", "=", "self", ".", "padding", ",", "\n", "dilation_rate", "=", "self", ".", "dilation_rate", ",", "\n", "data_format", "=", "self", ".", "data_format", ")", "\n", "\n", "if", "self", ".", "use_bias", ":", "\n", "      ", "if", "self", ".", "bias_quantizer", ":", "\n", "        ", "quantized_bias", "=", "self", ".", "bias_quantizer_internal", "(", "self", ".", "bias", ")", "\n", "", "else", ":", "\n", "        ", "quantized_bias", "=", "self", ".", "bias", "\n", "\n", "", "outputs", "=", "tf", ".", "keras", ".", "backend", ".", "bias_add", "(", "\n", "outputs", ",", "\n", "quantized_bias", ",", "\n", "data_format", "=", "self", ".", "data_format", ")", "\n", "\n", "", "if", "self", ".", "activation", "is", "not", "None", ":", "\n", "      ", "return", "self", ".", "activation", "(", "outputs", ")", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QSeparableConv2D.get_config": [[828, 839], ["super().get_config", "dict", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "list", "list", "super().get_config.items", "config.items"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "{", "\n", "\"depthwise_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "depthwise_quantizer_internal", ")", ",", "\n", "\"pointwise_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "pointwise_quantizer_internal", ")", ",", "\n", "\"bias_quantizer\"", ":", "\n", "constraints", ".", "serialize", "(", "self", ".", "bias_quantizer_internal", ")", "\n", "}", "\n", "base_config", "=", "super", "(", "QSeparableConv2D", ",", "self", ")", ".", "get_config", "(", ")", "\n", "return", "dict", "(", "list", "(", "base_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QSeparableConv2D.get_quantizers": [[840, 842], ["None"], "methods", ["None"], ["", "def", "get_quantizers", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "quantizers", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QSeparableConv2D.get_prunable_weights": [[843, 845], ["None"], "methods", ["None"], ["", "def", "get_prunable_weights", "(", "self", ")", ":", "\n", "    ", "return", "[", "self", ".", "depthwise_kernel", ",", "self", ".", "pointwise_kernel", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.__init__": [[865, 940], ["quantizers.get_quantizer", "quantizers.get_quantizer", "hasattr", "qlayers.get_auto_range_constraint_initializer", "tensorflow.keras.layers.DepthwiseConv2D.__init__", "warnings.warn", "warnings.warn", "qconvolutional.QDepthwiseConv2D.depthwise_quantizer_internal._set_trainable_parameter", "qlayers.get_auto_range_constraint_initializer", "quantizers.get_quantizer"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.stochastic_binary._set_trainable_parameter", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.get_auto_range_constraint_initializer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer"], ["def", "__init__", "(", "self", ",", "\n", "kernel_size", ",", "\n", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "padding", "=", "\"VALID\"", ",", "\n", "depth_multiplier", "=", "1", ",", "\n", "data_format", "=", "None", ",", "\n", "activation", "=", "None", ",", "\n", "use_bias", "=", "True", ",", "\n", "depthwise_initializer", "=", "\"he_normal\"", ",", "\n", "bias_initializer", "=", "\"zeros\"", ",", "\n", "depthwise_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "activity_regularizer", "=", "None", ",", "\n", "depthwise_constraint", "=", "None", ",", "\n", "bias_constraint", "=", "None", ",", "\n", "dilation_rate", "=", "(", "1", ",", "1", ")", ",", "\n", "depthwise_quantizer", "=", "None", ",", "\n", "bias_quantizer", "=", "None", ",", "\n", "depthwise_range", "=", "None", ",", "\n", "bias_range", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "    ", "if", "depthwise_range", "is", "not", "None", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"depthwise_range is deprecated in QDepthwiseConv2D layer.\"", ")", "\n", "\n", "", "if", "bias_range", "is", "not", "None", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"bias_range is deprecated in QDepthwiseConv2D layer.\"", ")", "\n", "\n", "", "self", ".", "depthwise_range", "=", "depthwise_range", "\n", "self", ".", "bias_range", "=", "bias_range", "\n", "\n", "self", ".", "depthwise_quantizer", "=", "depthwise_quantizer", "\n", "self", ".", "bias_quantizer", "=", "bias_quantizer", "\n", "\n", "self", ".", "depthwise_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "depthwise_quantizer", ")", "\n", "self", ".", "bias_quantizer_internal", "=", "get_quantizer", "(", "self", ".", "bias_quantizer", ")", "\n", "\n", "# optimize parameter set to \"auto\" scaling mode if possible", "\n", "if", "hasattr", "(", "self", ".", "depthwise_quantizer_internal", ",", "\"_set_trainable_parameter\"", ")", ":", "\n", "      ", "self", ".", "depthwise_quantizer_internal", ".", "_set_trainable_parameter", "(", ")", "\n", "\n", "", "self", ".", "quantizers", "=", "[", "\n", "self", ".", "depthwise_quantizer_internal", ",", "self", ".", "bias_quantizer_internal", "\n", "]", "\n", "\n", "depthwise_constraint", ",", "depthwise_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "depthwise_quantizer_internal", ",", "\n", "depthwise_constraint", ",", "\n", "depthwise_initializer", ")", ")", "\n", "\n", "if", "use_bias", ":", "\n", "      ", "bias_constraint", ",", "bias_initializer", "=", "(", "\n", "get_auto_range_constraint_initializer", "(", "self", ".", "bias_quantizer_internal", ",", "\n", "bias_constraint", ",", "\n", "bias_initializer", ")", ")", "\n", "", "if", "activation", "is", "not", "None", ":", "\n", "      ", "activation", "=", "get_quantizer", "(", "activation", ")", "\n", "\n", "", "super", "(", "QDepthwiseConv2D", ",", "self", ")", ".", "__init__", "(", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "data_format", "=", "data_format", ",", "\n", "activation", "=", "activation", ",", "\n", "use_bias", "=", "use_bias", ",", "\n", "depthwise_regularizer", "=", "depthwise_regularizer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "activity_regularizer", "=", "activity_regularizer", ",", "\n", "depth_multiplier", "=", "depth_multiplier", ",", "\n", "depthwise_initializer", "=", "depthwise_initializer", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "depthwise_constraint", "=", "depthwise_constraint", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "dilation_rate", "=", "dilation_rate", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.build": [[941, 977], ["int", "qconvolutional.QDepthwiseConv2D.add_weight", "tensorflow.keras.layers.InputSpec", "len", "ValueError", "ValueError", "qconvolutional.QDepthwiseConv2D.add_weight", "str"], "methods", ["None"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "    ", "if", "len", "(", "input_shape", ")", "<", "4", ":", "\n", "      ", "raise", "ValueError", "(", "\n", "\"Inputs to `QDepthwiseConv2D` should have rank 4. \"", "\n", "\"Received input shape:\"", ",", "str", "(", "input_shape", ")", ")", "\n", "", "if", "self", ".", "data_format", "==", "\"channels_first\"", ":", "\n", "      ", "channel_axis", "=", "1", "\n", "", "else", ":", "\n", "      ", "channel_axis", "=", "3", "\n", "", "if", "input_shape", "[", "channel_axis", "]", "is", "None", ":", "\n", "      ", "raise", "ValueError", "(", "\"The channel dimension of the inputs to \"", "\n", "\"`QDepthwiseConv2D` \"", "\n", "\"should be defined. Found `None`.\"", ")", "\n", "", "input_dim", "=", "int", "(", "input_shape", "[", "channel_axis", "]", ")", "\n", "depthwise_kernel_shape", "=", "(", "self", ".", "kernel_size", "[", "0", "]", ",", "self", ".", "kernel_size", "[", "1", "]", ",", "\n", "input_dim", ",", "self", ".", "depth_multiplier", ")", "\n", "\n", "self", ".", "depthwise_kernel", "=", "self", ".", "add_weight", "(", "\n", "shape", "=", "depthwise_kernel_shape", ",", "\n", "initializer", "=", "self", ".", "depthwise_initializer", ",", "\n", "name", "=", "\"depthwise_kernel\"", ",", "\n", "regularizer", "=", "self", ".", "depthwise_regularizer", ",", "\n", "constraint", "=", "self", ".", "depthwise_constraint", ")", "\n", "\n", "if", "self", ".", "use_bias", ":", "\n", "      ", "self", ".", "bias", "=", "self", ".", "add_weight", "(", "\n", "shape", "=", "(", "input_dim", "*", "self", ".", "depth_multiplier", ",", ")", ",", "\n", "initializer", "=", "self", ".", "bias_initializer", ",", "\n", "name", "=", "\"bias\"", ",", "\n", "regularizer", "=", "self", ".", "bias_regularizer", ",", "\n", "constraint", "=", "self", ".", "bias_constraint", ")", "\n", "", "else", ":", "\n", "      ", "self", ".", "bias", "=", "None", "\n", "# Set input spec.", "\n", "", "self", ".", "input_spec", "=", "InputSpec", "(", "ndim", "=", "4", ",", "axes", "=", "{", "channel_axis", ":", "input_dim", "}", ")", "\n", "self", ".", "built", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.call": [[978, 1004], ["tensorflow.keras.backend.depthwise_conv2d", "qconvolutional.QDepthwiseConv2D.depthwise_quantizer_internal", "tensorflow.keras.backend.bias_add", "qconvolutional.QDepthwiseConv2D.activation", "qconvolutional.QDepthwiseConv2D.bias_quantizer_internal"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QBidirectional.activation", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QGRU.bias_quantizer_internal"], ["", "def", "call", "(", "self", ",", "inputs", ",", "training", "=", "None", ")", ":", "\n", "    ", "if", "self", ".", "depthwise_quantizer", ":", "\n", "      ", "quantized_depthwise_kernel", "=", "(", "\n", "self", ".", "depthwise_quantizer_internal", "(", "self", ".", "depthwise_kernel", ")", ")", "\n", "", "else", ":", "\n", "      ", "quantized_depthwise_kernel", "=", "self", ".", "depthwise_kernel", "\n", "", "outputs", "=", "tf", ".", "keras", ".", "backend", ".", "depthwise_conv2d", "(", "\n", "inputs", ",", "\n", "quantized_depthwise_kernel", ",", "\n", "strides", "=", "self", ".", "strides", ",", "\n", "padding", "=", "self", ".", "padding", ",", "\n", "dilation_rate", "=", "self", ".", "dilation_rate", ",", "\n", "data_format", "=", "self", ".", "data_format", ")", "\n", "\n", "if", "self", ".", "use_bias", ":", "\n", "      ", "if", "self", ".", "bias_quantizer", ":", "\n", "        ", "quantized_bias", "=", "self", ".", "bias_quantizer_internal", "(", "self", ".", "bias", ")", "\n", "", "else", ":", "\n", "        ", "quantized_bias", "=", "self", ".", "bias", "\n", "", "outputs", "=", "tf", ".", "keras", ".", "backend", ".", "bias_add", "(", "\n", "outputs", ",", "quantized_bias", ",", "data_format", "=", "self", ".", "data_format", ")", "\n", "\n", "", "if", "self", ".", "activation", "is", "not", "None", ":", "\n", "      ", "return", "self", ".", "activation", "(", "outputs", ")", "\n", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config": [[1005, 1025], ["super().get_config", "super().get_config.pop", "super().get_config.pop", "super().get_config.pop", "super().get_config.pop", "tensorflow.keras.initializers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "config", "=", "super", "(", "QDepthwiseConv2D", ",", "self", ")", ".", "get_config", "(", ")", "\n", "config", ".", "pop", "(", "\"filters\"", ",", "None", ")", "\n", "config", ".", "pop", "(", "\"kernel_initializer\"", ",", "None", ")", "\n", "config", ".", "pop", "(", "\"kernel_regularizer\"", ",", "None", ")", "\n", "config", ".", "pop", "(", "\"kernel_constraint\"", ",", "None", ")", "\n", "config", "[", "\"depth_multiplier\"", "]", "=", "self", ".", "depth_multiplier", "\n", "config", "[", "\"depthwise_initializer\"", "]", "=", "initializers", ".", "serialize", "(", "\n", "self", ".", "depthwise_initializer", ")", "\n", "config", "[", "\"depthwise_regularizer\"", "]", "=", "regularizers", ".", "serialize", "(", "\n", "self", ".", "depthwise_regularizer", ")", "\n", "config", "[", "\"depthwise_constraint\"", "]", "=", "constraints", ".", "serialize", "(", "\n", "self", ".", "depthwise_constraint", ")", "\n", "config", "[", "\"depthwise_quantizer\"", "]", "=", "constraints", ".", "serialize", "(", "\n", "self", ".", "depthwise_quantizer_internal", ")", "\n", "config", "[", "\"bias_quantizer\"", "]", "=", "constraints", ".", "serialize", "(", "\n", "self", ".", "bias_quantizer_internal", ")", "\n", "config", "[", "\"depthwise_range\"", "]", "=", "self", ".", "depthwise_range", "\n", "config", "[", "\"bias_range\"", "]", "=", "self", ".", "bias_range", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantization_config": [[1026, 1035], ["str", "str", "str", "str"], "methods", ["None"], ["", "def", "get_quantization_config", "(", "self", ")", ":", "\n", "    ", "return", "{", "\n", "\"depthwise_quantizer_internal\"", ":", "\n", "str", "(", "self", ".", "depthwise_quantizer_internal", ")", ",", "\n", "\"bias_quantizer\"", ":", "\n", "str", "(", "self", ".", "bias_quantizer_internal", ")", ",", "\n", "\"activation\"", ":", "\n", "str", "(", "self", ".", "activation", ")", ",", "\n", "\"filters\"", ":", "str", "(", "self", ".", "filters", ")", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers": [[1037, 1039], ["None"], "methods", ["None"], ["", "def", "get_quantizers", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "quantizers", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_prunable_weights": [[1040, 1042], ["None"], "methods", ["None"], ["", "def", "get_prunable_weights", "(", "self", ")", ":", "\n", "    ", "return", "[", "self", ".", "depthwise_kernel", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QMobileNetSeparableConv2D": [[1044, 1186], ["qconvolutional.QDepthwiseConv2D", "isinstance", "qconvolutional.QConv2D", "isinstance", "isinstance", "qconvolutional.QConv2D", "activation", "depthwise_activation", "tensorflow.keras.layers.Dropout", "depthwise_activation", "tensorflow.keras.layers.Dropout", "tensorflow.keras.layers.Activation", "qlayers.QActivation", "qlayers.QActivation"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qrecurrent.QBidirectional.activation"], ["", "", "def", "QMobileNetSeparableConv2D", "(", "\n", "filters", ",", "# pylint: disable=invalid-name", "\n", "kernel_size", ",", "\n", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "padding", "=", "\"VALID\"", ",", "\n", "dilation_rate", "=", "(", "1", ",", "1", ")", ",", "\n", "depth_multiplier", "=", "1", ",", "\n", "activation", "=", "None", ",", "\n", "use_bias", "=", "True", ",", "\n", "depthwise_initializer", "=", "\"he_normal\"", ",", "\n", "pointwise_initializer", "=", "\"he_normal\"", ",", "\n", "bias_initializer", "=", "\"zeros\"", ",", "\n", "depthwise_regularizer", "=", "None", ",", "\n", "pointwise_regularizer", "=", "None", ",", "\n", "bias_regularizer", "=", "None", ",", "\n", "activity_regularizer", "=", "None", ",", "\n", "depthwise_constraint", "=", "None", ",", "\n", "pointwise_constraint", "=", "None", ",", "\n", "bias_constraint", "=", "None", ",", "\n", "depthwise_quantizer", "=", "None", ",", "\n", "pointwise_quantizer", "=", "None", ",", "\n", "bias_quantizer", "=", "None", ",", "\n", "depthwise_activation", "=", "None", ",", "\n", "depthwise_range", "=", "None", ",", "\n", "pointwise_range", "=", "None", ",", "\n", "bias_range", "=", "None", ",", "\n", "depthwise_dropout_rate", "=", "0.0", ",", "\n", "pw_first", "=", "False", ",", "\n", "name", "=", "\"\"", ")", ":", "\n", "  ", "\"\"\"Adds a quantized separableconv2d.\"\"\"", "\n", "\n", "# we use here a modified version that appeared in mobilenet that adds", "\n", "# quantization to the network, and possibly an intermediate activation", "\n", "# layer that acts as a quantizer and possible dropout layer between", "\n", "# the depthwise and pointwise convolutions.", "\n", "#", "\n", "# since this implementation expands into depthwise -> pointwise", "\n", "# convolutions, the users will not see a separable convolution operation", "\n", "# in model.summary(), but rather a depthwise convolution followed by a", "\n", "# pointwise convolution.", "\n", "#", "\n", "# depthwise_quantizer: depthwise quantization function", "\n", "# pointwise_quantizer: pointwise quantization function", "\n", "# bias_quantizer: bias quantization function for the pointwise convolution", "\n", "# depthwise_range/pointwise_range/bias_range: ranges to be used if", "\n", "# quantization values can become greater than -1 and +1.", "\n", "# depthwise_dropout_rate: dropout between depthwise and pointwise is added", "\n", "#   if rate > 0.0", "\n", "# pw_first: this may disappear in the future, but as deep quantized networks", "\n", "#   sometimes behave in different ways, if we are using binary or ternary", "\n", "#   quantization, it may be better to apply pointwise before depthwise.", "\n", "#", "\n", "# For the remaining parameters, please refer to Keras implementation of", "\n", "# SeparableConv2D.", "\n", "#", "\n", "\n", "def", "_call", "(", "inputs", ")", ":", "# pylint: disable=invalid-name", "\n", "    ", "\"\"\"Internally builds qseparableconv2d.\"\"\"", "\n", "\n", "x", "=", "inputs", "\n", "\n", "if", "pw_first", ":", "\n", "      ", "x", "=", "QConv2D", "(", "\n", "filters", ",", "(", "1", ",", "1", ")", ",", "\n", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "padding", "=", "\"same\"", ",", "\n", "use_bias", "=", "use_bias", ",", "\n", "kernel_constraint", "=", "pointwise_constraint", ",", "\n", "kernel_initializer", "=", "pointwise_initializer", ",", "\n", "kernel_regularizer", "=", "pointwise_regularizer", ",", "\n", "kernel_quantizer", "=", "pointwise_quantizer", ",", "\n", "bias_quantizer", "=", "bias_quantizer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "activity_regularizer", "=", "activity_regularizer", ",", "\n", "kernel_range", "=", "pointwise_range", ",", "\n", "bias_range", "=", "bias_range", ",", "\n", "name", "=", "name", "+", "\"_pw\"", ")", "(", "\n", "x", ")", "\n", "\n", "if", "depthwise_activation", ":", "\n", "        ", "if", "isinstance", "(", "depthwise_activation", ",", "QActivation", ")", ":", "\n", "          ", "x", "=", "depthwise_activation", "(", "x", ")", "\n", "", "else", ":", "\n", "          ", "x", "=", "QActivation", "(", "depthwise_activation", ",", "name", "=", "name", "+", "\"_dw_act\"", ")", "(", "x", ")", "\n", "\n", "", "", "if", "depthwise_dropout_rate", ">", "0.0", ":", "\n", "        ", "x", "=", "Dropout", "(", "rate", "=", "depthwise_dropout_rate", ",", "name", "=", "name", "+", "\"_dw_dropout\"", ")", "(", "x", ")", "\n", "\n", "", "", "x", "=", "QDepthwiseConv2D", "(", "\n", "kernel_size", ",", "\n", "strides", "=", "strides", ",", "\n", "dilation_rate", "=", "dilation_rate", ",", "\n", "padding", "=", "padding", ",", "\n", "depth_multiplier", "=", "depth_multiplier", ",", "\n", "use_bias", "=", "False", ",", "\n", "depthwise_regularizer", "=", "depthwise_regularizer", ",", "\n", "depthwise_initializer", "=", "depthwise_initializer", ",", "\n", "depthwise_constraint", "=", "depthwise_constraint", ",", "\n", "depthwise_quantizer", "=", "depthwise_quantizer", ",", "\n", "depthwise_range", "=", "depthwise_range", ",", "\n", "name", "=", "name", "+", "\"_dw\"", ")", "(", "\n", "x", ")", "\n", "\n", "if", "not", "pw_first", ":", "\n", "      ", "if", "depthwise_activation", ":", "\n", "        ", "if", "isinstance", "(", "depthwise_activation", ",", "QActivation", ")", ":", "\n", "          ", "x", "=", "depthwise_activation", "(", "x", ")", "\n", "", "else", ":", "\n", "          ", "x", "=", "QActivation", "(", "depthwise_activation", ",", "name", "=", "name", "+", "\"_dw_act\"", ")", "(", "x", ")", "\n", "\n", "", "", "if", "depthwise_dropout_rate", ">", "0.0", ":", "\n", "        ", "x", "=", "Dropout", "(", "rate", "=", "depthwise_dropout_rate", ",", "name", "=", "name", "+", "\"_dw_dropout\"", ")", "(", "x", ")", "\n", "\n", "", "x", "=", "QConv2D", "(", "\n", "filters", ",", "(", "1", ",", "1", ")", ",", "\n", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "padding", "=", "\"same\"", ",", "\n", "use_bias", "=", "use_bias", ",", "\n", "kernel_constraint", "=", "pointwise_constraint", ",", "\n", "kernel_initializer", "=", "pointwise_initializer", ",", "\n", "kernel_regularizer", "=", "pointwise_regularizer", ",", "\n", "kernel_quantizer", "=", "pointwise_quantizer", ",", "\n", "bias_quantizer", "=", "bias_quantizer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "\n", "activity_regularizer", "=", "activity_regularizer", ",", "\n", "kernel_range", "=", "pointwise_range", ",", "\n", "bias_range", "=", "bias_range", ",", "\n", "name", "=", "name", "+", "\"_pw\"", ")", "(", "\n", "x", ")", "\n", "\n", "", "if", "activation", ":", "\n", "      ", "if", "isinstance", "(", "activation", ",", "QActivation", ")", ":", "\n", "        ", "x", "=", "activation", "(", "x", ")", "\n", "", "else", ":", "\n", "        ", "x", "=", "Activation", "(", "activation", ",", "name", "=", "name", "+", "\"_pw_act\"", ")", "(", "x", ")", "\n", "", "", "return", "x", "\n", "\n", "", "return", "_call", "\n", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.analyze_accumulator": [[57, 153], ["bn_folding_utils.unfold_model", "print", "isinstance", "isinstance", "isinstance", "isinstance", "layer.get_weights", "range", "int", "numpy.zeros", "all_bits.append", "numpy.ceil", "print", "print", "print", "print", "print", "print", "print", "numpy.sum", "numpy.sum", "nbits.append", "nbits.append", "numpy.log2", "numpy.amax", "numpy.amin", "numpy.amax", "max", "numpy.amax", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.bn_folding_utils.unfold_model", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["def", "analyze_accumulator", "(", "in_model", ",", "x", ",", "verbose", "=", "False", ")", ":", "\n", "  ", "\"\"\"Analyzes the distribution of weights to specify size of accumulators.\n\n     Computes the maximum number of bits for the accumulator assuming the\n     inputs have a distribution given by the dictionary x.\n\n     for each output channel i:\n       max_positive_value[i] = sum(w[i]) + bias[i] for the positive weights\n       max_negative_value[i] = sum(w[i]) + bias[i] for the negative weights\n\n     max_value = max(\n            max_positive_value[i] * positive(x) +\n            max_negative_value[i] * negative(x),\n\n         - (max_negative_value[i] * positive(x) +\n            max_positive_value[i] * negative(x))\n     )\n\n     accumulator_size = ceil( log2( max_value ) )\n\n     x right now is a dictionary of the form:\n\n     { layer_name: (min_value, max_value) }\n\n     in the future, we want to provide a sample and compute this automatically\n\n  Arguments:\n    in_model: keras model object, model to be evaluated\n    x: dictionary of the form: { layer_name: (min_value, max_value) }\n       input distribution\n    verbose: boolean, if true, print statistics messages\n\n  Returns:\n    dictionary containing { layer_name: accumulator_size }\n  \"\"\"", "\n", "\n", "# this function converts a folded model to a \"normal\" model. It replace folded", "\n", "# layers (e.g., QConv2dBatchnorm) layer with qconv2d layer whenever possible.", "\n", "model", "=", "unfold_model", "(", "in_model", ")", "\n", "\n", "acc_sizes", "=", "{", "}", "\n", "\n", "for", "layer", "in", "model", ".", "layers", ":", "\n", "    ", "if", "(", "isinstance", "(", "layer", ",", "QDepthwiseConv2D", ")", "or", "\n", "isinstance", "(", "layer", ",", "QConv2D", ")", "or", "\n", "isinstance", "(", "layer", ",", "QConv1D", ")", "or", "\n", "isinstance", "(", "layer", ",", "QDense", ")", ")", ":", "\n", "      ", "weights", "=", "layer", ".", "get_weights", "(", ")", "\n", "k", "=", "weights", "[", "0", "]", "\n", "if", "layer", ".", "use_bias", ":", "\n", "        ", "b", "=", "weights", "[", "1", "]", "\n", "", "else", ":", "\n", "        ", "b", "=", "np", ".", "zeros", "(", "(", "k", ".", "shape", "[", "-", "1", "]", ",", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "", "all_bits", "=", "[", "]", "\n", "nbits", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "k", ".", "shape", "[", "1", "]", ")", ":", "\n", "# compute sum of positive weights", "\n", "        ", "npp", "=", "np", ".", "sum", "(", "k", "[", "...", ",", "i", "]", "*", "(", "k", "[", "...", ",", "i", "]", ">", "0", ")", ")", "+", "(", "b", "[", "i", "]", ">", "0", ")", "*", "b", "[", "i", "]", "\n", "\n", "# compute sum of negative weights", "\n", "nnn", "=", "np", ".", "sum", "(", "k", "[", "...", ",", "i", "]", "*", "(", "k", "[", "...", ",", "i", "]", "<", "0", ")", ")", "+", "(", "b", "[", "i", "]", "<", "0", ")", "*", "b", "[", "i", "]", "\n", "\n", "# largest value is", "\n", "#   npp * largest positive - nnn * largest_negative or", "\n", "#   nnn * largest_positive - npp * largest_negative", "\n", "\n", "x_min", "=", "x", "[", "layer", ".", "name", "]", "[", "0", "]", "\n", "x_max", "=", "x", "[", "layer", ".", "name", "]", "[", "1", "]", "\n", "\n", "n1", "=", "npp", "*", "(", "x_max", ">", "0", ")", "*", "x_max", "+", "nnn", "*", "(", "x_min", "<", "0", ")", "*", "x_min", "\n", "n0", "=", "-", "(", "nnn", "*", "(", "x_max", ">", "0", ")", "*", "x_max", "+", "npp", "*", "(", "x_min", "<", "0", ")", "*", "x_min", ")", "\n", "\n", "if", "n1", ">", "n0", ":", "\n", "          ", "nbits", ".", "append", "(", "n1", ")", "\n", "", "else", ":", "\n", "          ", "nbits", ".", "append", "(", "n0", ")", "\n", "\n", "", "all_bits", ".", "append", "(", "(", "n1", ",", "n0", ")", ")", "\n", "\n", "", "max_bits", "=", "int", "(", "np", ".", "ceil", "(", "np", ".", "log2", "(", "max", "(", "nbits", ")", ")", ")", ")", "\n", "acc_sizes", "[", "layer", ".", "name", "]", "=", "max_bits", "\n", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", ")", "\n", "print", "(", "layer", ".", "name", ",", "\"- input range:\"", ",", "x", "[", "layer", ".", "name", "]", ")", "\n", "print", "(", "\"  max value:\"", ",", "np", ".", "amax", "(", "k", ")", ")", "\n", "print", "(", "\"  min value:\"", ",", "np", ".", "amin", "(", "k", ")", ")", "\n", "print", "(", "\"  most positive sum:\"", ",", "np", ".", "amax", "(", "np", ".", "array", "(", "all_bits", ")", "[", ":", ",", "0", "]", ")", ")", "\n", "print", "(", "\"  most negative sum:\"", ",", "-", "np", ".", "amax", "(", "np", ".", "array", "(", "all_bits", ")", "[", ":", ",", "1", "]", ")", ")", "\n", "print", "(", "\"  number of bits:\"", ",", "max_bits", ")", "\n", "\n", "", "", "", "if", "verbose", ":", "\n", "    ", "print", "(", ")", "\n", "\n", "", "return", "acc_sizes", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.analyze_accumulator_from_sample": [[155, 224], ["bn_folding_utils.unfold_model", "tensorflow.keras.models.Model", "tensorflow.keras.models.Model.predict", "zip", "estimate.analyze_accumulator", "ValueError", "tensorflow.keras.models.Model", "tensorflow.keras.models.Model.predict", "zip", "numpy.amax", "tensorflow.keras.layers.Activation", "numpy.amin", "numpy.amax", "isinstance", "isinstance", "isinstance", "isinstance", "numpy.abs", "int", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "numpy.ceil", "numpy.log2"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.bn_folding_utils.unfold_model", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict", "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.analyze_accumulator", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.predict"], ["", "def", "analyze_accumulator_from_sample", "(", "\n", "in_model", ",", "x_sample", ",", "mode", "=", "\"conservative\"", ",", "verbose", "=", "False", ")", ":", "\n", "  ", "\"\"\"Extracts range of inputs of quantized layers from samples.\"\"\"", "\n", "\n", "# mode is one of \"conservative\", \"sampled\"", "\n", "if", "mode", "not", "in", "[", "\"conservative\"", ",", "\"sampled\"", "]", ":", "\n", "    ", "ValueError", "(", "\"'mode' has to be 'conservative' or 'sampled'\"", ")", "\n", "\n", "# this function converts a folded model to a \"normal\" model. It replace folded", "\n", "# layers (e.g., QConv2DBatchnorm) layer with qconv2d layer whenever possible.", "\n", "", "model", "=", "unfold_model", "(", "in_model", ")", "\n", "\n", "# get layer names of quantized layers (QDense and QConv2D)", "\n", "layer_names", "=", "[", "\n", "layer", ".", "name", "for", "layer", "in", "model", ".", "layers", "\n", "if", "(", "isinstance", "(", "layer", ",", "QDepthwiseConv2D", ")", "or", "isinstance", "(", "layer", ",", "QConv2D", ")", "or", "\n", "isinstance", "(", "layer", ",", "QConv1D", ")", "or", "isinstance", "(", "layer", ",", "QDense", ")", ")", "\n", "]", "\n", "\n", "# sampled mode: just apply x_sample and check the outputs", "\n", "\n", "if", "mode", "==", "\"sampled\"", ":", "\n", "\n", "    ", "outputs", "=", "[", "\n", "layer", ".", "output", "for", "layer", "in", "model", ".", "layers", "\n", "if", "(", "isinstance", "(", "layer", ",", "QDepthwiseConv2D", ")", "or", "isinstance", "(", "layer", ",", "QConv2D", ")", "or", "\n", "isinstance", "(", "layer", ",", "QConv1D", ")", "or", "isinstance", "(", "layer", ",", "QDense", ")", ")", "\n", "]", "\n", "\n", "eval_outputs", "=", "Model", "(", "inputs", "=", "model", ".", "inputs", ",", "outputs", "=", "outputs", ")", "\n", "\n", "# predict values for all inputs to quantized layers", "\n", "\n", "values", "=", "eval_outputs", ".", "predict", "(", "x_sample", ")", "\n", "\n", "acc_sizes", "=", "{", "}", "\n", "\n", "for", "name", ",", "value", "in", "zip", "(", "layer_names", ",", "values", ")", ":", "\n", "      ", "max_value", "=", "np", ".", "amax", "(", "np", ".", "abs", "(", "value", ")", ")", "\n", "if", "max_value", "!=", "0", ":", "\n", "        ", "acc_sizes", "[", "name", "]", "=", "int", "(", "np", ".", "ceil", "(", "np", ".", "log2", "(", "max_value", ")", ")", ")", "\n", "", "else", ":", "\n", "        ", "acc_sizes", "[", "name", "]", "=", "0", "\n", "\n", "", "", "return", "acc_sizes", "\n", "\n", "# get inputs of quantized layers (QDense and QConv2D", "\n", "# we use Activation(\"linear\") to trick keras and tensorflow", "\n", "# to avoid direct connections of inputs and any other", "\n", "# artifacts.", "\n", "\n", "", "outputs", "=", "[", "\n", "Activation", "(", "\"linear\"", ")", "(", "layer", ".", "input", ")", "for", "layer", "in", "model", ".", "layers", "\n", "if", "(", "isinstance", "(", "layer", ",", "QDepthwiseConv2D", ")", "or", "isinstance", "(", "layer", ",", "QConv2D", ")", "or", "\n", "isinstance", "(", "layer", ",", "QConv1D", ")", "or", "isinstance", "(", "layer", ",", "QDense", ")", ")", "\n", "]", "\n", "\n", "eval_inputs", "=", "Model", "(", "inputs", "=", "model", ".", "inputs", ",", "outputs", "=", "outputs", ")", "\n", "\n", "# predict values for all inputs to quantized layers", "\n", "\n", "values", "=", "eval_inputs", ".", "predict", "(", "x_sample", ")", "\n", "\n", "x_dict", "=", "{", "}", "\n", "\n", "for", "name", ",", "value", "in", "zip", "(", "layer_names", ",", "values", ")", ":", "\n", "    ", "x_dict", "[", "name", "]", "=", "(", "np", ".", "amin", "(", "value", ")", ",", "np", ".", "amax", "(", "value", ")", ")", "\n", "\n", "", "return", "analyze_accumulator", "(", "model", ",", "x_dict", ",", "verbose", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.get_quant_mode": [[226, 272], ["ValueError", "getattr", "int", "isinstance", "isinstance", "isinstance", "isinstance", "int", "int"], "function", ["None"], ["", "def", "get_quant_mode", "(", "quant", ")", ":", "\n", "  ", "\"\"\"Returns the quantizer mode, number of bits and if it is a signed number.\"\"\"", "\n", "\n", "#  qb(n)[0] +/-,exp[1] t(-1,0,+1)[2] b(-1,+1)[3] b(0,1)[4]", "\n", "#  entry is tuple:", "\n", "#    (instance name, mode #(above), number of bits (-1 means check class),", "\n", "#     sign bit)", "\n", "\n", "modes", "=", "[", "\n", "# depending on the number of bits, quantized_bits may be 2, 2", "\n", "(", "\"quantized_bits\"", ",", "0", ",", "-", "1", ",", "1", ")", ",", "\n", "(", "\"bernoulli\"", ",", "4", ",", "1", ",", "0", ")", ",", "\n", "(", "\"stochastic_ternary\"", ",", "2", ",", "2", ",", "1", ")", ",", "\n", "(", "\"ternary\"", ",", "2", ",", "2", ",", "1", ")", ",", "\n", "(", "\"stochastic_binary\"", ",", "3", ",", "1", ",", "1", ")", ",", "\n", "(", "\"binary\"", ",", "3", ",", "1", ",", "1", ")", ",", "\n", "# depending on the number of bits, quantized_relu may be 4, 1", "\n", "(", "\"quantized_relu\"", ",", "0", ",", "-", "1", ",", "0", ")", ",", "\n", "# depending on the number of bits, quantized_tanh may be 2, 2", "\n", "(", "\"quantized_ulaw\"", ",", "0", ",", "-", "1", ",", "1", ")", ",", "\n", "(", "\"quantized_tanh\"", ",", "0", ",", "-", "1", ",", "1", ")", ",", "\n", "(", "\"quantized_po2\"", ",", "1", ",", "-", "1", ",", "1", ")", ",", "\n", "(", "\"quantized_relu_po2\"", ",", "1", ",", "-", "1", ",", "0", ")", ",", "\n", "(", "\"float\"", ",", "5", ",", "32", ",", "1", ")", "\n", "]", "\n", "\n", "for", "(", "inst", ",", "mode", ",", "bits", ",", "sign", ")", "in", "modes", ":", "\n", "    ", "if", "not", "quant", "or", "getattr", "(", "quant", ",", "\"__name__\"", ",", "None", ")", "==", "\"linear\"", ":", "\n", "# if quantizer not specified or linear, we use float type", "\n", "      ", "if", "inst", "==", "\"float\"", ":", "\n", "        ", "return", "(", "mode", ",", "bits", ",", "sign", ")", "\n", "\n", "", "", "elif", "quant", ".", "__class__", ".", "__name__", "==", "inst", ":", "\n", "      ", "if", "bits", "==", "-", "1", ":", "\n", "        ", "bits", "=", "int", "(", "quant", ".", "bits", ")", "\n", "if", "(", "\n", "isinstance", "(", "quant", ",", "quantized_bits", ")", "or", "\n", "isinstance", "(", "quant", ",", "quantized_tanh", ")", "or", "\n", "isinstance", "(", "quant", ",", "quantized_ulaw", ")", ")", ":", "\n", "          ", "if", "bits", "==", "2", "and", "int", "(", "quant", ".", "integer", ")", "==", "1", ":", "\n", "            ", "mode", "=", "2", "\n", "", "", "elif", "isinstance", "(", "quant", ",", "quantized_relu", ")", ":", "\n", "          ", "if", "bits", "==", "1", "and", "int", "(", "quant", ".", "integer", ")", "==", "1", ":", "\n", "            ", "mode", "=", "4", "\n", "", "", "", "return", "(", "mode", ",", "bits", ",", "sign", ")", "\n", "", "", "raise", "ValueError", "(", "\"Quantizer {} Not Found\"", ".", "format", "(", "quant", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.get_operation_type": [[274, 328], ["hasattr", "ValueError", "estimate.get_quant_mode", "layer.get_quantizers", "absl.logging.warning", "output_cache.get", "estimate.get_quant_mode", "print", "layer.input.experimental_ref", "output_cache.get", "absl.logging.warning", "layer.input.experimental_ref"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.get_quant_mode", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.get_quant_mode"], ["", "def", "get_operation_type", "(", "layer", ",", "output_cache", ")", ":", "\n", "  ", "\"\"\"Checks quantizers around layer and weights to get operation type.\n\n  Determines operator strenght according to the following table.\n                                      x\n                     qb(n)   +/-,exp  t(-1,0,+1) b(-1,+1) b(0,1) float\n      qb(n)            *     << >>,-     ?,-       ?,-       ?    *\n      +/-,exp        << >>,-   +         ?,-        ^      ?,-    *\n    w t(-1,0,+1)      ?,-     ?,-        ?,^       ?,^      ^     *\n      b(-1,+1)        ?,-      ^         ?,^        ^       ^     *\n      b(0,1)           ?      ?,-         ^         ^       ^     *\n      float           *        *          *        *        *     *\n\n  Arguments:\n    layer: layer in Keras to determine the operation strength.\n    output_cache: cache of input tensor bit sizes.\n\n  Returns:\n    One of \"mult\", \"fmult\", \"adder\", \"barrel\", \"mux\", \"xor\".\n    Note: \"mult\" represents quantized bit multiplier, \"fmult\" represents\n          floating point multiplier.\n  \"\"\"", "\n", "\n", "wx_table", "=", "[", "\n", "[", "\"mult\"", ",", "\"barrel\"", ",", "\"mux\"", ",", "\"mux\"", ",", "\"mux\"", ",", "\"fmult\"", "]", ",", "\n", "[", "\"barrel\"", ",", "\"adder\"", ",", "\"mux\"", ",", "\"xor\"", ",", "\"mux\"", ",", "\"fmult\"", "]", ",", "\n", "[", "\"mux\"", ",", "\"mux\"", ",", "\"mux\"", ",", "\"mux\"", ",", "\"xor\"", ",", "\"fmult\"", "]", ",", "\n", "[", "\"mux\"", ",", "\"xor\"", ",", "\"mux\"", ",", "\"xor\"", ",", "\"xor\"", ",", "\"fmult\"", "]", ",", "\n", "[", "\"mux\"", ",", "\"mux\"", ",", "\"xor\"", ",", "\"xor\"", ",", "\"xor\"", ",", "\"fmult\"", "]", ",", "\n", "[", "\"fmult\"", ",", "\"fmult\"", ",", "\"fmult\"", ",", "\"fmult\"", ",", "\"fmult\"", ",", "\"fmult\"", "]", ",", "\n", "]", "\n", "\n", "# check if this is a quantized layers (QDense, QConv, QDepthwise)", "\n", "if", "hasattr", "(", "layer", ",", "\"get_quantizers\"", ")", ":", "\n", "    ", "w_quant", "=", "layer", ".", "get_quantizers", "(", ")", "[", "0", "]", "\n", "w_mode", ",", "w_bits", ",", "w_sign", "=", "get_quant_mode", "(", "w_quant", ")", "\n", "if", "w_mode", "==", "\"float\"", ":", "\n", "      ", "logging", ".", "warning", "(", "\"%s kernel is unquantized!\"", ",", "layer", ".", "name", ")", "\n", "\n", "# for the input, get tensor input and search the cache that associates", "\n", "# the quantizer with a tensor", "\n", "", "if", "output_cache", ".", "get", "(", "layer", ".", "input", ".", "experimental_ref", "(", ")", ",", "None", ")", "is", "not", "None", ":", "\n", "      ", "x_mode", ",", "x_bits", ",", "x_sign", "=", "get_quant_mode", "(", "\n", "output_cache", ".", "get", "(", "layer", ".", "input", ".", "experimental_ref", "(", ")", ")", ")", "\n", "if", "x_mode", "==", "\"float\"", ":", "\n", "        ", "logging", ".", "warning", "(", "\"%s input is unquantized!\"", ",", "layer", ".", "name", ")", "\n", "", "", "else", ":", "\n", "      ", "print", "(", "\"cannot determine presently model for {}\"", ".", "format", "(", "layer", ".", "name", ")", ")", "\n", "return", "\"null\"", ",", "(", "w_mode", ",", "-", "1", ")", ",", "(", "w_bits", ",", "-", "1", ")", ",", "(", "w_sign", ",", "-", "1", ")", "\n", "", "mode", "=", "wx_table", "[", "w_mode", "]", "[", "x_mode", "]", "\n", "return", "mode", ",", "(", "w_mode", ",", "x_mode", ")", ",", "(", "w_bits", ",", "x_bits", ")", ",", "(", "w_sign", ",", "x_sign", ")", "\n", "\n", "", "raise", "ValueError", "(", "\"Cannot find suitable quantization candidates for {}\"", ".", "format", "(", "\n", "layer", ".", "name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.create_activation_cache": [[330, 371], ["quantizers.quantized_relu", "isinstance", "isinstance", "isinstance", "isinstance", "model.layers[].input.experimental_ref", "l.output.experimental_ref", "l.output.experimental_ref", "isinstance", "l.output.experimental_ref", "output_cache.get", "ValueError", "l.output.experimental_ref", "output_cache.get", "l.input.experimental_ref", "l.output.experimental_ref", "l.input[].experimental_ref", "range", "len"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "create_activation_cache", "(", "model", ")", ":", "\n", "  ", "\"\"\"Creates an activation cache for the tensors of a model.\"\"\"", "\n", "\n", "input_quantizer", "=", "quantized_relu", "(", "8", ",", "0", ")", "\n", "\n", "output_cache", "=", "{", "}", "\n", "\n", "# If using a Sequential model, the input layer is hidden. Therefore, add the", "\n", "# input quantization to the cache if the first layer is not an input layer", "\n", "if", "not", "isinstance", "(", "model", ".", "layers", "[", "0", "]", ",", "InputLayer", ")", ":", "\n", "    ", "output_cache", "[", "model", ".", "layers", "[", "0", "]", ".", "input", ".", "experimental_ref", "(", ")", "]", "=", "input_quantizer", "\n", "\n", "# cache graph tensors' activations", "\n", "\n", "", "for", "l", "in", "model", ".", "layers", ":", "\n", "    ", "output_cache", "[", "l", ".", "output", ".", "experimental_ref", "(", ")", "]", "=", "l", "\n", "if", "isinstance", "(", "l", ",", "QActivation", ")", "or", "isinstance", "(", "l", ",", "QAdaptiveActivation", ")", ":", "\n", "      ", "output_cache", "[", "l", ".", "output", ".", "experimental_ref", "(", ")", "]", "=", "l", ".", "quantizer", "\n", "", "elif", "isinstance", "(", "l", ",", "InputLayer", ")", ":", "\n", "# assume the input is 8-bit positive value", "\n", "      ", "output_cache", "[", "l", ".", "output", ".", "experimental_ref", "(", ")", "]", "=", "input_quantizer", "\n", "", "elif", "l", ".", "__class__", ".", "__name__", "in", "[", "\n", "\"QDense\"", ",", "\"QConv2D\"", ",", "\"QConv1D\"", ",", "\"QDepthwiseConv2D\"", "\n", "]", ":", "\n", "      ", "output_cache", "[", "l", ".", "output", ".", "experimental_ref", "(", ")", "]", "=", "l", ".", "activation", "\n", "", "else", ":", "\n", "      ", "if", "isinstance", "(", "l", ".", "input", ",", "list", ")", ":", "\n", "# right now, we just get the first one - we assume this is the leading", "\n", "# one.", "\n", "        ", "all_q", "=", "[", "\n", "output_cache", ".", "get", "(", "l", ".", "input", "[", "i", "]", ".", "experimental_ref", "(", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "l", ".", "input", ")", ")", "\n", "]", "\n", "q", "=", "all_q", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "q", "=", "output_cache", ".", "get", "(", "l", ".", "input", ".", "experimental_ref", "(", ")", ",", "None", ")", "\n", "", "output_cache", "[", "l", ".", "output", ".", "experimental_ref", "(", ")", "]", "=", "q", "\n", "if", "q", "is", "None", ":", "\n", "        ", "raise", "ValueError", "(", "\"Unknown operation in {}\"", ".", "format", "(", "l", ".", "name", ")", ")", "\n", "\n", "", "", "", "return", "output_cache", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.extract_model_operations": [[373, 611], ["bn_folding_utils.unfold_model", "estimate.create_activation_cache", "isinstance", "isinstance", "layer.compute_output_shape", "cache_o.get", "enumerate", "layer.get_quantizers", "estimate.get_quant_mode", "estimate.get_quant_mode", "estimate.get_operation_type", "cache_o.get", "layer.input.experimental_ref", "layer.input.get_shape", "isinstance", "layer.output.experimental_ref", "layer.get_weights", "len", "absl.logging.warning", "absl.logging.warning", "layer.get_quantizers", "estimate.get_quant_mode", "estimate.get_quant_mode", "isinstance", "layer.input[].experimental_ref", "layer.input[].get_shape", "range", "range", "tuple", "layer.get_weights", "layer.get_weights", "len", "absl.logging.warning", "absl.logging.warning", "layer.get_quantizers", "estimate.get_quant_mode", "estimate.get_quant_mode", "len", "len", "shape.append", "layer.get_weights", "layer.get_weights", "len", "absl.logging.warning", "absl.logging.warning", "layer.get_quantizers", "estimate.get_quant_mode", "estimate.get_quant_mode", "estimate.get_quant_mode", "layer.get_weights", "layer.get_weights", "layer.get_weights", "len", "absl.logging.warning", "absl.logging.warning", "absl.logging.warning", "layer.get_quantizers", "estimate.get_quant_mode", "estimate.get_quant_mode", "estimate.get_quant_mode", "isinstance", "layer.get_weights", "layer.get_weights", "layer.get_weights", "len", "absl.logging.warning", "absl.logging.warning", "absl.logging.warning", "layer.get_quantizers", "estimate.get_quant_mode", "estimate.get_quant_mode", "layer.get_weights", "layer.get_weights", "len", "absl.logging.warnings", "absl.logging.warnings", "layer.get_weights", "layer.get_weights", "layer.get_weights", "layer.get_weights"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.bn_folding_utils.unfold_model", "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.create_activation_cache", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QDense.compute_output_shape", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.get_quant_mode", "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.get_quant_mode", "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.get_operation_type", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.get_quant_mode", "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.get_quant_mode", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.get_quant_mode", "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.get_quant_mode", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.get_quant_mode", "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.get_quant_mode", "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.get_quant_mode", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.get_quant_mode", "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.get_quant_mode", "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.get_quant_mode", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.get_quant_mode", "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.get_quant_mode", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights"], ["", "def", "extract_model_operations", "(", "in_model", ")", ":", "\n", "  ", "\"\"\"Determines types of operations for convolutions.\"\"\"", "\n", "\n", "model", "=", "unfold_model", "(", "in_model", ")", "\n", "cache_q", "=", "create_activation_cache", "(", "model", ")", "\n", "cache_o", "=", "{", "}", "\n", "\n", "operations", "=", "{", "}", "\n", "\n", "for", "layer", "in", "model", ".", "layers", ":", "\n", "\n", "    ", "if", "layer", ".", "__class__", ".", "__name__", "==", "\"InputLayer\"", ":", "\n", "      ", "continue", "\n", "\n", "", "if", "isinstance", "(", "layer", ".", "input", ",", "list", ")", ":", "\n", "      ", "input_shape", "=", "[", "\n", "cache_o", ".", "get", "(", "layer", ".", "input", "[", "i", "]", ".", "experimental_ref", "(", ")", ",", "\n", "layer", ".", "input", "[", "i", "]", ".", "get_shape", "(", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "layer", ".", "input", ")", ")", "\n", "]", "\n", "", "else", ":", "\n", "      ", "input_shape", "=", "cache_o", ".", "get", "(", "layer", ".", "input", ".", "experimental_ref", "(", ")", ",", "\n", "layer", ".", "input", ".", "get_shape", "(", ")", ")", "\n", "\n", "# Check if the inputs are a list of Dimensions", "\n", "", "if", "isinstance", "(", "input_shape", ",", "list", ")", ":", "\n", "# Iterate though all of the input shapes and extract the dimension values", "\n", "      ", "for", "i", ",", "dim", "in", "enumerate", "(", "input_shape", ")", ":", "\n", "        ", "if", "isinstance", "(", "dim", "[", "0", "]", ",", "tf", ".", "Dimension", ")", ":", "\n", "          ", "shape", "=", "[", "None", "]", "\n", "for", "j", "in", "range", "(", "1", ",", "len", "(", "dim", ")", ")", ":", "\n", "            ", "shape", ".", "append", "(", "dim", "[", "j", "]", "if", "isinstance", "(", "dim", "[", "j", "]", ",", "int", ")", "else", "dim", "[", "j", "]", ".", "value", ")", "\n", "", "input_shape", "[", "i", "]", "=", "tuple", "(", "shape", ")", "\n", "\n", "", "", "", "output_shape", "=", "layer", ".", "compute_output_shape", "(", "input_shape", ")", "\n", "\n", "cache_o", "[", "layer", ".", "output", ".", "experimental_ref", "(", ")", "]", "=", "output_shape", "\n", "\n", "if", "layer", ".", "__class__", ".", "__name__", "not", "in", "[", "\"QDense\"", ",", "\"QConv2D\"", ",", "\"QConv1D\"", ",", "\n", "\"QDepthwiseConv2D\"", ",", "\"QSeparableConv1D\"", ",", "\n", "\"QSeparableConv2D\"", "]", ":", "\n", "      ", "continue", "\n", "\n", "", "if", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"QConv2D\"", "]", ":", "\n", "\n", "      ", "_", ",", "_", ",", "_", ",", "channels_i", "=", "input_shape", "\n", "\n", "_", ",", "height_o", ",", "width_o", ",", "channels_o", "=", "output_shape", "\n", "\n", "weight", "=", "layer", ".", "get_weights", "(", ")", "[", "0", "]", "\n", "\n", "\n", "kernel_h", ",", "kernel_w", ",", "_", ",", "_", "=", "weight", ".", "shape", "\n", "\n", "number_of_operations", "=", "(", "\n", "height_o", "*", "width_o", "*", "channels_o", "*", "kernel_h", "*", "kernel_w", "*", "channels_i", ")", "\n", "\n", "number_of_weights", "=", "(", "kernel_h", "*", "kernel_w", "*", "channels_o", "*", "channels_i", ")", "\n", "\n", "number_of_bias", "=", "0", "\n", "if", "len", "(", "layer", ".", "get_weights", "(", ")", ")", ">", "1", ":", "\n", "        ", "number_of_bias", "=", "layer", ".", "get_weights", "(", ")", "[", "1", "]", ".", "shape", "[", "0", "]", "\n", "\n", "", "weight_quant", ",", "bias_quant", "=", "layer", ".", "get_quantizers", "(", ")", "\n", "weight_type", "=", "get_quant_mode", "(", "weight_quant", ")", "\n", "bias_type", "=", "get_quant_mode", "(", "bias_quant", ")", "\n", "\n", "if", "weight_type", "[", "0", "]", "==", "\"float\"", ":", "\n", "        ", "logging", ".", "warning", "(", "\"%s kernel is unquantized!\"", ",", "layer", ".", "name", ")", "\n", "", "if", "bias_type", "[", "0", "]", "==", "\"float\"", ":", "\n", "        ", "logging", ".", "warning", "(", "\"%s bias is unquantized!\"", ",", "layer", ".", "name", ")", "\n", "\n", "", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"QConv1D\"", "]", ":", "\n", "\n", "      ", "_", ",", "_", ",", "channels_i", "=", "input_shape", "\n", "\n", "_", ",", "time_o", ",", "channels_o", "=", "output_shape", "\n", "\n", "weight", "=", "layer", ".", "get_weights", "(", ")", "[", "0", "]", "\n", "\n", "kernel_length", ",", "_", ",", "_", "=", "weight", ".", "shape", "\n", "\n", "number_of_operations", "=", "(", "\n", "time_o", "*", "channels_o", "*", "kernel_length", "*", "channels_i", ")", "\n", "\n", "number_of_weights", "=", "(", "kernel_length", "*", "channels_o", "*", "channels_i", ")", "\n", "number_of_bias", "=", "0", "\n", "if", "len", "(", "layer", ".", "get_weights", "(", ")", ")", ">", "1", ":", "\n", "        ", "number_of_bias", "=", "layer", ".", "get_weights", "(", ")", "[", "1", "]", ".", "shape", "[", "0", "]", "\n", "\n", "", "weight_quant", ",", "bias_quant", "=", "layer", ".", "get_quantizers", "(", ")", "\n", "weight_type", "=", "get_quant_mode", "(", "weight_quant", ")", "\n", "bias_type", "=", "get_quant_mode", "(", "bias_quant", ")", "\n", "\n", "if", "weight_type", "[", "0", "]", "==", "\"float\"", ":", "\n", "        ", "logging", ".", "warning", "(", "\"%s kernel is unquantized!\"", ",", "layer", ".", "name", ")", "\n", "", "if", "bias_type", "[", "0", "]", "==", "\"float\"", ":", "\n", "        ", "logging", ".", "warning", "(", "\"%s bias is unquantized!\"", ",", "layer", ".", "name", ")", "\n", "\n", "", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"QDepthwiseConv2D\"", "]", ":", "\n", "\n", "      ", "_", ",", "_", ",", "_", ",", "channels_i", "=", "input_shape", "\n", "\n", "_", ",", "height_o", ",", "width_o", ",", "channels_o", "=", "output_shape", "\n", "\n", "weight_1", "=", "layer", ".", "get_weights", "(", ")", "[", "0", "]", "\n", "\n", "kernel_h", ",", "kernel_w", ",", "_", ",", "_", "=", "weight_1", ".", "shape", "\n", "\n", "number_of_operations", "=", "(", "\n", "kernel_h", "*", "kernel_w", "*", "height_o", "*", "width_o", "*", "channels_i", ")", "\n", "\n", "number_of_weights", "=", "(", "kernel_h", "*", "kernel_w", "*", "channels_o", "*", "channels_i", ")", "\n", "\n", "number_of_bias", "=", "0", "\n", "if", "len", "(", "layer", ".", "get_weights", "(", ")", ")", ">", "1", ":", "\n", "        ", "number_of_bias", "=", "layer", ".", "get_weights", "(", ")", "[", "1", "]", ".", "shape", "[", "0", "]", "\n", "\n", "", "weight_quant", ",", "bias_quant", "=", "layer", ".", "get_quantizers", "(", ")", "\n", "weight_type", "=", "get_quant_mode", "(", "weight_quant", ")", "\n", "bias_type", "=", "get_quant_mode", "(", "bias_quant", ")", "\n", "\n", "if", "weight_type", "[", "0", "]", "==", "\"float\"", ":", "\n", "        ", "logging", ".", "warning", "(", "\"%s kernel is unquantized!\"", ",", "layer", ".", "name", ")", "\n", "", "if", "bias_type", "[", "0", "]", "==", "\"float\"", ":", "\n", "        ", "logging", ".", "warning", "(", "\"%s bias is unquantized!\"", ",", "layer", ".", "name", ")", "\n", "\n", "", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"QSeparableConv1D\"", "]", ":", "\n", "\n", "      ", "_", ",", "_", ",", "channels_i", "=", "input_shape", "\n", "\n", "_", ",", "time_o", ",", "channels_o", "=", "output_shape", "\n", "\n", "weight_1", "=", "layer", ".", "get_weights", "(", ")", "[", "0", "]", "\n", "\n", "kernel_length", ",", "_", ",", "_", "=", "weight_1", ".", "shape", "\n", "\n", "number_of_operations", "=", "(", "\n", "kernel_length", "*", "time_o", "*", "channels_i", "+", "\n", "time_o", "*", "channels_o", ")", "\n", "\n", "number_of_weights", "=", "[", "\n", "kernel_length", "*", "channels_i", ",", "\n", "channels_o", "*", "channels_i", "]", "\n", "\n", "number_of_bias", "=", "0", "\n", "if", "len", "(", "layer", ".", "get_weights", "(", ")", ")", ">", "2", ":", "\n", "        ", "number_of_bias", "=", "layer", ".", "get_weights", "(", ")", "[", "2", "]", ".", "shape", "[", "0", "]", "\n", "\n", "", "depthwise_quant", ",", "pointwise_quant", ",", "bias_quant", "=", "layer", ".", "get_quantizers", "(", ")", "\n", "depthwise_type", "=", "get_quant_mode", "(", "depthwise_quant", ")", "\n", "pointwise_type", "=", "get_quant_mode", "(", "pointwise_quant", ")", "\n", "weight_type", "=", "[", "depthwise_type", ",", "pointwise_type", "]", "\n", "bias_type", "=", "get_quant_mode", "(", "bias_quant", ")", "\n", "\n", "if", "depthwise_type", "[", "0", "]", "==", "\"float\"", ":", "\n", "        ", "logging", ".", "warning", "(", "\"%s depthwise kernel is unquantized!\"", ",", "layer", ".", "name", ")", "\n", "", "if", "pointwise_type", "[", "0", "]", "==", "\"float\"", ":", "\n", "        ", "logging", ".", "warning", "(", "\"%s pointwise kernel is unquantized!\"", ",", "layer", ".", "name", ")", "\n", "", "if", "bias_type", "[", "0", "]", "==", "\"float\"", ":", "\n", "        ", "logging", ".", "warning", "(", "\"%s bias is unquantized!\"", ",", "layer", ".", "name", ")", "\n", "\n", "", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"QSeparableConv2D\"", "]", ":", "\n", "\n", "      ", "_", ",", "_", ",", "_", ",", "channels_i", "=", "input_shape", "\n", "\n", "_", ",", "height_o", ",", "width_o", ",", "channels_o", "=", "output_shape", "\n", "\n", "weight_1", "=", "layer", ".", "get_weights", "(", ")", "[", "0", "]", "\n", "\n", "kernel_h", ",", "kernel_w", ",", "_", ",", "_", "=", "weight_1", ".", "shape", "\n", "\n", "number_of_operations", "=", "(", "\n", "kernel_h", "*", "kernel_w", "*", "height_o", "*", "width_o", "*", "channels_i", "+", "\n", "height_o", "*", "width_o", "*", "channels_o", ")", "\n", "\n", "number_of_weights", "=", "[", "\n", "kernel_h", "*", "kernel_w", "*", "channels_i", ",", "\n", "channels_o", "*", "channels_i", "]", "\n", "\n", "number_of_bias", "=", "0", "\n", "if", "len", "(", "layer", ".", "get_weights", "(", ")", ")", ">", "2", ":", "\n", "        ", "number_of_bias", "=", "layer", ".", "get_weights", "(", ")", "[", "2", "]", ".", "shape", "[", "0", "]", "\n", "\n", "", "depthwise_quant", ",", "pointwise_quant", ",", "bias_quant", "=", "layer", ".", "get_quantizers", "(", ")", "\n", "depthwise_type", "=", "get_quant_mode", "(", "depthwise_quant", ")", "\n", "pointwise_type", "=", "get_quant_mode", "(", "pointwise_quant", ")", "\n", "weight_type", "=", "[", "depthwise_type", ",", "pointwise_type", "]", "\n", "bias_type", "=", "get_quant_mode", "(", "bias_quant", ")", "\n", "\n", "if", "depthwise_type", "[", "0", "]", "==", "\"float\"", ":", "\n", "        ", "logging", ".", "warning", "(", "\"%s depthwise kernel is unquantized!\"", ",", "layer", ".", "name", ")", "\n", "", "if", "pointwise_type", "[", "0", "]", "==", "\"float\"", ":", "\n", "        ", "logging", ".", "warning", "(", "\"%s pointwise kernel is unquantized!\"", ",", "layer", ".", "name", ")", "\n", "", "if", "bias_type", "[", "0", "]", "==", "\"float\"", ":", "\n", "        ", "logging", ".", "warning", "(", "\"%s bias is unquantized!\"", ",", "layer", ".", "name", ")", "\n", "\n", "", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"QDense\"", "]", ":", "\n", "\n", "      ", "_", ",", "size_i", "=", "input_shape", "\n", "_", ",", "size_o", "=", "output_shape", "\n", "\n", "number_of_operations", "=", "(", "size_i", "*", "size_o", ")", "\n", "\n", "number_of_weights", "=", "size_i", "*", "size_o", "\n", "number_of_bias", "=", "0", "\n", "if", "len", "(", "layer", ".", "get_weights", "(", ")", ")", ">", "1", ":", "\n", "        ", "number_of_bias", "=", "layer", ".", "get_weights", "(", ")", "[", "1", "]", ".", "shape", "[", "0", "]", "\n", "\n", "", "weight_quant", ",", "bias_quant", "=", "layer", ".", "get_quantizers", "(", ")", "\n", "weight_type", "=", "get_quant_mode", "(", "weight_quant", ")", "\n", "bias_type", "=", "get_quant_mode", "(", "bias_quant", ")", "\n", "\n", "if", "weight_type", "[", "0", "]", "==", "\"float\"", ":", "\n", "        ", "logging", ".", "warnings", "(", "\"%s kernel is unquantized!\"", ",", "layer", ".", "name", ")", "\n", "", "if", "bias_type", "[", "0", "]", "==", "\"float\"", ":", "\n", "        ", "logging", ".", "warnings", "(", "\"%s bias is unquantized!\"", ",", "layer", ".", "name", ")", "\n", "\n", "# \"number_of_operations\" is tensor_shape.Dimension type", "\n", "", "", "operations", "[", "layer", ".", "name", "]", "=", "{", "\n", "\"type\"", ":", "\n", "get_operation_type", "(", "layer", ",", "cache_q", ")", ",", "\n", "\"number_of_operations\"", ":", "\n", "number_of_operations", "if", "isinstance", "(", "number_of_operations", ",", "int", ")", "else", "\n", "number_of_operations", ".", "value", ",", "\n", "\"number_of_weights\"", ":", "\n", "number_of_weights", ",", "\n", "# if isinstance(number_of_weights, int) else number_of_weights.value,", "\n", "\"number_of_bias\"", ":", "\n", "number_of_bias", ",", "\n", "# if isinstance(number_of_bias, int) else number_of_bias.value,", "\n", "\"type_of_weights\"", ":", "\n", "weight_type", ",", "\n", "\"type_of_bias\"", ":", "\n", "bias_type", ",", "\n", "}", "\n", "\n", "", "return", "operations", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.print_qstats": [[613, 668], ["estimate.extract_model_operations", "collections.defaultdict", "print", "print", "sorted", "print", "print", "sorted", "print", "print", "sorted", "print", "print", "print", "print", "utils.get_model_sparsity", "print", "print", "print", "collections.defaultdict.keys", "isinstance", "print", "print", "str", "print", "enumerate", "print", "sum", "str", "str", "str", "zip", "print", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.estimate.extract_model_operations", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.get_model_sparsity"], ["", "def", "print_qstats", "(", "model", ")", ":", "\n", "  ", "\"\"\"Prints quantization statistics for the model.\"\"\"", "\n", "\n", "model_ops", "=", "extract_model_operations", "(", "model", ")", "\n", "\n", "ops_table", "=", "defaultdict", "(", "lambda", ":", "0", ")", "\n", "\n", "print", "(", "\"\"", ")", "\n", "print", "(", "\"Number of operations in model:\"", ")", "\n", "for", "name", "in", "sorted", "(", "model_ops", ")", ":", "\n", "    ", "mode", ",", "_", ",", "sizes", ",", "signs", "=", "model_ops", "[", "name", "]", "[", "\"type\"", "]", "\n", "number", "=", "model_ops", "[", "name", "]", "[", "\"number_of_operations\"", "]", "\n", "sign", "=", "\"s\"", "if", "sum", "(", "signs", ")", ">", "0", "else", "\"u\"", "\n", "op_name", "=", "sign", "+", "mode", "+", "\"_\"", "+", "str", "(", "sizes", "[", "0", "]", ")", "+", "\"_\"", "+", "str", "(", "sizes", "[", "1", "]", ")", "\n", "ops_table", "[", "op_name", "]", "+=", "number", "\n", "print", "(", "\"    {:30}: {:5} ({})\"", ".", "format", "(", "str", "(", "name", ")", ",", "str", "(", "number", ")", ",", "str", "(", "op_name", ")", ")", ")", "\n", "\n", "", "print", "(", "\"\"", ")", "\n", "print", "(", "\"Number of operation types in model:\"", ")", "\n", "for", "key", "in", "sorted", "(", "ops_table", ".", "keys", "(", ")", ")", ":", "\n", "    ", "if", "ops_table", "[", "key", "]", ">", "0", ":", "\n", "      ", "print", "(", "\"    {:30}: {}\"", ".", "format", "(", "key", ",", "ops_table", "[", "key", "]", ")", ")", "\n", "\n", "", "", "print", "(", "\"\"", ")", "\n", "print", "(", "\"Weight profiling:\"", ")", "\n", "total_bits", "=", "0", "\n", "for", "name", "in", "sorted", "(", "model_ops", ")", ":", "\n", "    ", "weight_type", "=", "model_ops", "[", "name", "]", "[", "\"type_of_weights\"", "]", "\n", "n_weights", "=", "model_ops", "[", "name", "]", "[", "\"number_of_weights\"", "]", "\n", "if", "isinstance", "(", "weight_type", ",", "list", ")", ":", "\n", "      ", "for", "i", ",", "(", "w_type", ",", "w_number", ")", "in", "enumerate", "(", "zip", "(", "weight_type", ",", "n_weights", ")", ")", ":", "\n", "        ", "_", ",", "w_sizes", ",", "_", "=", "w_type", "\n", "total_bits", "+=", "w_number", "*", "w_sizes", "\n", "print", "(", "\"    {:30} : {:5} ({}-bit unit)\"", ".", "format", "(", "\n", "str", "(", "name", ")", "+", "\"_weights_\"", "+", "str", "(", "i", ")", ",", "str", "(", "w_number", ")", ",", "str", "(", "w_sizes", ")", ")", ")", "\n", "", "", "else", ":", "\n", "      ", "_", ",", "w_sizes", ",", "_", "=", "weight_type", "\n", "total_bits", "+=", "n_weights", "*", "w_sizes", "\n", "print", "(", "\"    {:30} : {:5} ({}-bit unit)\"", ".", "format", "(", "\n", "str", "(", "name", ")", "+", "\"_weights\"", ",", "str", "(", "n_weights", ")", ",", "str", "(", "w_sizes", ")", ")", ")", "\n", "", "_", ",", "b_sizes", ",", "_", "=", "model_ops", "[", "name", "]", "[", "\"type_of_bias\"", "]", "\n", "b_number", "=", "model_ops", "[", "name", "]", "[", "\"number_of_bias\"", "]", "\n", "total_bits", "+=", "b_number", "*", "b_sizes", "\n", "print", "(", "\"    {:30} : {:5} ({}-bit unit)\"", ".", "format", "(", "\n", "str", "(", "name", ")", "+", "\"_bias\"", ",", "str", "(", "b_number", ")", ",", "str", "(", "b_sizes", ")", ")", ")", "\n", "", "print", "(", "\"    \"", "+", "(", "\"-\"", "*", "40", ")", ")", "\n", "print", "(", "\"    {:30} : {:5}\"", ".", "format", "(", "\"Total Bits\"", ",", "total_bits", ")", ")", "\n", "\n", "print", "(", "\"\"", ")", "\n", "print", "(", "\"Weight sparsity:\"", ")", "\n", "total_sparsity", ",", "per_layer", "=", "get_model_sparsity", "(", "model", ",", "per_layer", "=", "True", ")", "\n", "for", "layer", "in", "per_layer", ":", "\n", "    ", "print", "(", "\"    {:30} : {:.4f}\"", ".", "format", "(", "str", "(", "layer", "[", "0", "]", ")", ",", "layer", "[", "1", "]", ")", ")", "\n", "", "print", "(", "\"    \"", "+", "(", "\"-\"", "*", "40", ")", ")", "\n", "print", "(", "\"    {:30} : {:.4f}\"", ".", "format", "(", "\"Total Sparsity\"", ",", "total_sparsity", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel.__init__": [[112, 176], ["autoqkeras_internal.AutoQKHyperModel.target.get_reference", "isinstance", "autoqkeras_internal.AutoQKHyperModel._adjust_limit", "print", "re.compile", "autoqkeras_internal.AutoQKHyperModel.limit.get", "json.dumps"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits.get_reference", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel._adjust_limit"], ["def", "__init__", "(", "\n", "self", ",", "model", ",", "metrics", ",", "custom_objects", "=", "None", ",", "target", "=", "None", ",", "\n", "transfer_weights", "=", "False", ",", "frozen_layers", "=", "None", ",", "activation_bits", "=", "4", ",", "limit", "=", "None", ",", "\n", "tune_filters", "=", "\"none\"", ",", "tune_filters_exceptions", "=", "None", ",", "\n", "layer_indexes", "=", "None", ",", "learning_rate_optimizer", "=", "False", ",", "\n", "head_name", "=", "None", ",", "quantization_config", "=", "None", ",", "extend_model_metrics", "=", "True", ",", "\n", ")", ":", "\n", "    ", "self", ".", "model", "=", "model", "\n", "self", ".", "metrics", "=", "metrics", "\n", "self", ".", "custom_objects", "=", "custom_objects", "if", "custom_objects", "else", "{", "}", "\n", "\n", "self", ".", "target", "=", "target", "\n", "\n", "self", ".", "reference_size", "=", "self", ".", "target", ".", "get_reference", "(", "model", ")", "\n", "\n", "self", ".", "transfer_weights", "=", "transfer_weights", "\n", "self", ".", "frozen_layers", "=", "frozen_layers", "if", "frozen_layers", "else", "[", "]", "\n", "self", ".", "activation_bits", "=", "activation_bits", "\n", "self", ".", "head_name", "=", "head_name", "\n", "self", ".", "extend_model_metrics", "=", "extend_model_metrics", "\n", "# make sure we have at least 3 elements in list", "\n", "# first one for kernel, second one for bias and thid one for activations.", "\n", "#", "\n", "# limit is in the format, where default replaces missing values:", "\n", "# '{", "\n", "#      \"Conv2D\":[weight,bias,activation],", "\n", "#      \"RNN\":[weight,bias,recurrent,activation],", "\n", "#      \"Dense\":[weight,bias,activation],", "\n", "#      \"Activation\":[activation]", "\n", "#      \"default\": value", "\n", "#  }'", "\n", "\n", "if", "limit", "is", "None", ":", "\n", "      ", "self", ".", "limit", "=", "{", "}", "\n", "", "else", ":", "\n", "      ", "self", ".", "limit", "=", "limit", "\n", "\n", "", "self", ".", "groups", "=", "{", "}", "\n", "\n", "assert", "isinstance", "(", "self", ".", "limit", ",", "dict", ")", "\n", "\n", "if", "self", ".", "limit", ".", "get", "(", "\"default\"", ",", "None", ")", "is", "None", ":", "\n", "      ", "default", "=", "8", "\n", "", "else", ":", "\n", "      ", "default", "=", "self", ".", "limit", "[", "\"default\"", "]", "\n", "\n", "# make sure we have entries for every type of layer we process", "\n", "", "self", ".", "_adjust_limit", "(", "default", ")", "\n", "\n", "print", "(", "\"Limit configuration:\"", "+", "json", ".", "dumps", "(", "self", ".", "limit", ")", ")", "\n", "\n", "assert", "tune_filters", "in", "[", "\"block\"", ",", "\"layer\"", ",", "\"none\"", "]", "\n", "\n", "self", ".", "tune_filters", "=", "tune_filters", "\n", "self", ".", "tune_filters_exceptions", "=", "re", ".", "compile", "(", "tune_filters_exceptions", ")", "\n", "\n", "self", ".", "layer_indexes", "=", "layer_indexes", "\n", "self", ".", "learning_rate_optimizer", "=", "learning_rate_optimizer", "\n", "\n", "# load quantizer types for each type of quantizer", "\n", "if", "quantization_config", "is", "None", ":", "\n", "      ", "self", ".", "quantization_config", "=", "default_quantization_config", "\n", "", "else", ":", "\n", "      ", "self", ".", "quantization_config", "=", "quantization_config", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel._adjust_limit": [[177, 194], ["isinstance", "len", "len", "len"], "methods", ["None"], ["", "", "def", "_adjust_limit", "(", "self", ",", "default", ")", ":", "\n", "    ", "\"\"\"Makes sure limit has all the fields required.\"\"\"", "\n", "if", "isinstance", "(", "default", ",", "list", ")", ":", "\n", "      ", "assert", "3", "<=", "len", "(", "default", ")", "<=", "4", "\n", "", "else", ":", "\n", "      ", "default", "=", "[", "default", "]", "*", "3", "\n", "\n", "# we consider that if name is not there, we will ignore the layer", "\n", "", "for", "name", "in", "REGISTERED_LAYERS", ":", "\n", "      ", "if", "name", "in", "self", ".", "limit", ":", "\n", "        ", "length", "=", "len", "(", "self", ".", "limit", "[", "name", "]", ")", "\n", "if", "length", "<", "4", "and", "name", "in", "SEQUENCE_LAYERS", ":", "\n", "          ", "assert", "len", "(", "default", ")", "==", "4", "\n", "self", ".", "limit", "[", "name", "]", "=", "self", ".", "limit", "[", "name", "]", "+", "default", "[", "length", ":", "]", "\n", "", "elif", "length", "<", "3", ":", "\n", "# No recurrent limit needed for non recurrent layers", "\n", "          ", "self", ".", "limit", "[", "name", "]", "=", "self", ".", "limit", "[", "name", "]", "+", "default", "[", "length", ":", "2", "]", "+", "default", "[", "-", "1", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel._n": [[195, 198], ["str"], "methods", ["None"], ["", "", "", "", "def", "_n", "(", "self", ",", "name", ",", "s_list", ")", ":", "\n", "    ", "\"\"\"Creates a unique name for the tuner.\"\"\"", "\n", "return", "name", "+", "\"_\"", ".", "join", "(", "[", "str", "(", "v", ")", "for", "v", "in", "s_list", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel._get_quantizer": [[199, 326], ["enumerate", "isinstance", "list", "re.match", "list", "len", "hp.Fixed", "hp.Choice", "kq.keys", "list", "q_dict.keys", "autoqkeras_internal.AutoQKHyperModel._n", "autoqkeras_internal.AutoQKHyperModel._n", "kq.keys", "list", "q_dict.items", "bq.keys", "list", "str", "kq.keys", "list", "kq.keys", "list", "list", "raq.keys", "aq.keys"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel._n", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel._n"], ["", "def", "_get_quantizer", "(", "self", ",", "hp", ",", "head", ",", "layer_name", ",", "layer_class_name", ",", "\n", "i_list", "=", "None", ",", "is_kernel", "=", "True", ",", "is_linear", "=", "False", ")", ":", "\n", "    ", "\"\"\"Gets a quantizer randomly for kernels/bias/activations.\"\"\"", "\n", "\n", "# first pick up which group we belong to.", "\n", "\n", "if", "not", "i_list", ":", "\n", "      ", "i_list", "=", "[", "]", "\n", "\n", "", "if", "is_linear", ":", "\n", "# linear quantizers", "\n", "      ", "field_name", "=", "\"linear\"", "\n", "kq", "=", "self", ".", "quantization_config", "[", "\"linear\"", "]", "\n", "index", "=", "0", "\n", "q_list", "=", "list", "(", "kq", ".", "keys", "(", ")", ")", "\n", "q_dict", "=", "kq", "\n", "", "elif", "\"kernel\"", "in", "head", ":", "\n", "# kernel quantizers", "\n", "      ", "field_name", "=", "\"kernel\"", "\n", "kq", "=", "self", ".", "quantization_config", "[", "\"kernel\"", "]", "\n", "index", "=", "0", "\n", "q_list", "=", "list", "(", "kq", ".", "keys", "(", ")", ")", "\n", "q_dict", "=", "kq", "\n", "", "elif", "\"bias\"", "in", "head", ":", "\n", "# bias quantizers", "\n", "      ", "field_name", "=", "\"bias\"", "\n", "bq", "=", "self", ".", "quantization_config", "[", "\"bias\"", "]", "\n", "index", "=", "1", "\n", "q_list", "=", "list", "(", "bq", ".", "keys", "(", ")", ")", "\n", "q_dict", "=", "bq", "\n", "", "elif", "\"pointwise_kernel\"", "in", "head", ":", "# limit is same as kernel", "\n", "# pointwise kernel quantizers", "\n", "      ", "field_name", "=", "\"pointwise_kernel\"", "\n", "kq", "=", "self", ".", "quantization_config", "[", "\"pointwise_kernel\"", "]", "\n", "index", "=", "2", "\n", "q_list", "=", "list", "(", "kq", ".", "keys", "(", ")", ")", "\n", "q_dict", "=", "kq", "\n", "", "elif", "\"recurrent_kernel\"", "in", "head", ":", "# limit is same as kernel", "\n", "# recurrent kernel quantizers", "\n", "      ", "field_name", "=", "\"recurrent_kernel\"", "\n", "kq", "=", "self", ".", "quantization_config", "[", "\"recurrent_kernel\"", "]", "\n", "index", "=", "2", "\n", "q_list", "=", "list", "(", "kq", ".", "keys", "(", ")", ")", "\n", "q_dict", "=", "kq", "\n", "", "elif", "\"recurrent_activation\"", "in", "head", ":", "# limit is same as kernel", "\n", "# recurrent activation quantizers", "\n", "      ", "field_name", "=", "\"recurrent_activation\"", "\n", "raq", "=", "self", ".", "quantization_config", "[", "\"recurrent_activation\"", "]", "\n", "index", "=", "-", "1", "\n", "q_list", "=", "list", "(", "raq", ".", "keys", "(", ")", ")", "\n", "q_dict", "=", "raq", "\n", "", "else", ":", "\n", "# activation quantizers", "\n", "      ", "field_name", "=", "\"activation\"", "\n", "aq", "=", "self", ".", "quantization_config", "[", "\"activation\"", "]", "\n", "index", "=", "-", "1", "\n", "q_list", "=", "list", "(", "aq", ".", "keys", "(", ")", ")", "\n", "q_dict", "=", "aq", "\n", "\n", "# we first we search for layer name. If it is not there, we switch to", "\n", "# layer class name.", "\n", "\n", "", "found_pattern", "=", "False", "\n", "name", "=", "layer_class_name", "\n", "count", "=", "-", "1", "\n", "for", "i", ",", "pattern", "in", "enumerate", "(", "self", ".", "limit", ")", ":", "\n", "      ", "if", "re", ".", "match", "(", "pattern", ",", "layer_name", ")", ":", "\n", "        ", "found_pattern", "=", "True", "\n", "name", "=", "pattern", "\n", "count", "=", "i", "\n", "break", "\n", "\n", "# for partially quantized networks we may not have", "\n", "# the layer class name in the set.", "\n", "\n", "", "", "if", "name", "==", "layer_class_name", "and", "name", "not", "in", "self", ".", "limit", ":", "\n", "      ", "return", "None", ",", "-", "1", "\n", "\n", "# groups is a dictionary that contains dictionary of the", "\n", "# patterns so that we can group everything together", "\n", "\n", "", "if", "found_pattern", ":", "\n", "      ", "if", "name", "in", "self", ".", "groups", "and", "index", "in", "self", ".", "groups", "[", "name", "]", ":", "\n", "        ", "return", "self", ".", "groups", "[", "name", "]", "[", "index", "]", "\n", "\n", "# not there, let's use a different name for", "\n", "# the head and field", "\n", "", "head", "=", "\"qk_group_\"", "+", "str", "(", "count", ")", "+", "\"_\"", "+", "field_name", "\n", "head", "=", "name", "+", "\"_\"", "+", "field_name", "\n", "\n", "# limit group can be a list of quantizers or a", "\n", "# number that tells us maximum number of bits", "\n", "\n", "", "if", "isinstance", "(", "self", ".", "limit", "[", "name", "]", "[", "index", "]", ",", "list", ")", ":", "\n", "# we assume this is a subset of the q_keys", "\n", "# entry in quantization_config will be like:", "\n", "#   \"Conv2D\": [ [\"q1\", \"q2\", \"q3\"], ... ]", "\n", "#", "\n", "# we always assume this list is a subset of", "\n", "# the original list or we will raise an", "\n", "# error.", "\n", "\n", "      ", "q_list", "=", "self", ".", "limit", "[", "name", "]", "[", "index", "]", "\n", "q_dict", "=", "{", "\n", "key", ":", "q_dict", "[", "key", "]", "for", "key", "in", "q_list", "\n", "}", "\n", "", "else", ":", "\n", "      ", "q_dict", "=", "{", "\n", "key", ":", "value", "for", "(", "key", ",", "value", ")", "in", "q_dict", ".", "items", "(", ")", "\n", "if", "value", "<=", "self", ".", "limit", "[", "name", "]", "[", "index", "]", "\n", "}", "\n", "q_list", "=", "list", "(", "q_dict", ".", "keys", "(", ")", ")", "\n", "\n", "# didn't found a match in groups, create one.", "\n", "\n", "", "if", "len", "(", "q_list", ")", "==", "1", ":", "\n", "      ", "q_name", "=", "hp", ".", "Fixed", "(", "self", ".", "_n", "(", "head", "+", "\"_quantizer\"", ",", "i_list", ")", ",", "q_list", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "      ", "q_name", "=", "hp", ".", "Choice", "(", "self", ".", "_n", "(", "head", "+", "\"_quantizer\"", ",", "i_list", ")", ",", "q_list", ")", "\n", "\n", "", "if", "found_pattern", ":", "\n", "      ", "if", "name", "not", "in", "self", ".", "groups", ":", "\n", "        ", "self", ".", "groups", "[", "name", "]", "=", "{", "index", ":", "(", "q_name", ",", "q_dict", "[", "q_name", "]", ")", "}", "\n", "", "else", ":", "\n", "        ", "self", ".", "groups", "[", "name", "]", "[", "index", "]", "=", "(", "q_name", ",", "q_dict", "[", "q_name", "]", ")", "\n", "\n", "", "", "return", "(", "q_name", ",", "q_dict", "[", "q_name", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel.quantize_model": [[327, 562], ["qkeras.utils.clone_model", "enumerate", "qkeras.utils.model_quantize", "hp.Choice", "autoqkeras_internal.AutoQKHyperModel._get_quantizer", "fanin.append", "autoqkeras_internal.AutoQKHyperModel._get_quantizer", "autoqkeras_internal.AutoQKHyperModel._get_quantizer", "layer.get_weights", "hasattr", "fanin.append", "autoqkeras_internal.AutoQKHyperModel._get_quantizer", "autoqkeras_internal.AutoQKHyperModel._get_quantizer", "autoqkeras_internal.AutoQKHyperModel._get_quantizer", "layer.get_quantizers", "layer.get_weights", "autoqkeras_internal.AutoQKHyperModel.tune_filters_exceptions.search", "hp.Choice", "max", "autoqkeras_internal.AutoQKHyperModel._get_quantizer", "isinstance", "autoqkeras_internal.AutoQKHyperModel._get_quantizer", "autoqkeras_internal.AutoQKHyperModel.tune_filters_exceptions.search", "tensorflow.image_data_format", "tensorflow.image_data_format", "isinstance", "autoqkeras_internal.AutoQKHyperModel.tune_filters_exceptions.search", "layer.get_quantizers", "layer.get_quantizers", "numpy.prod", "int", "max", "autoqkeras_internal.AutoQKHyperModel._get_quantizer", "numpy.prod", "int", "min", "int", "re.match", "int"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.clone_model", "home.repos.pwc.inspect_result.google_qkeras.qkeras.utils.model_quantize", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel._get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel._get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel._get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel._get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel._get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel._get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel._get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel._get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel._get_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min"], ["", "def", "quantize_model", "(", "self", ",", "hp", ")", ":", "\n", "    ", "\"\"\"Quantize model by hyperparameter search and extracting size schema.\"\"\"", "\n", "\n", "# configuration for quantization.", "\n", "q_dict", "=", "{", "}", "\n", "\n", "model", "=", "clone_model", "(", "self", ".", "model", ",", "self", ".", "custom_objects", ")", "\n", "\n", "fanin", "=", "[", "]", "\n", "\n", "filter_range", "=", "[", "0.5", ",", "0.75", ",", "1.0", ",", "1.5", ",", "2.0", "]", "\n", "\n", "# network_filters=hp.Choice(...) should only be defined if we are sure", "\n", "# current blocks has any layer that need filter sweep.", "\n", "# Otherwise, when no layer needs filter sweep and a hp variable is defined,", "\n", "# there will be uneffective trials that loop around the network", "\n", "# filter range, even though none of the filter sweep was ever applied to", "\n", "# any layers. Therfore, we use filter_sweep_enabled to mark if any layer", "\n", "# in current block needs filter sweep.", "\n", "kernel_quantizer_dict", "=", "{", "}", "\n", "filter_sweep_enabled", "=", "False", "\n", "for", "layer", "in", "model", ".", "layers", ":", "\n", "      ", "if", "layer", ".", "__class__", ".", "__name__", "in", "REGISTERED_LAYERS", ":", "\n", "        ", "kernel_quantizer", ",", "bits", "=", "self", ".", "_get_quantizer", "(", "\n", "hp", ",", "layer", ".", "name", "+", "\"_kernel\"", ",", "layer", ".", "name", ",", "layer", ".", "__class__", ".", "__name__", ",", "\n", "is_kernel", "=", "True", ")", "\n", "\n", "kernel_quantizer_dict", "[", "layer", ".", "name", "]", "=", "(", "kernel_quantizer", ",", "bits", ")", "\n", "\n", "# kernel_quantizer is not None ->  layer in the current block need", "\n", "# to be quantized", "\n", "if", "kernel_quantizer", ":", "\n", "          ", "if", "(", "\n", "not", "filter_sweep_enabled", "and", "self", ".", "tune_filters", "in", "\n", "[", "\"layer\"", ",", "\"block\"", "]", "\n", "and", "not", "self", ".", "tune_filters_exceptions", ".", "search", "(", "layer", ".", "name", ")", "and", "\n", "layer", ".", "__class__", ".", "__name__", "in", "\n", "[", "\"Dense\"", ",", "\"Conv1D\"", ",", "\"Conv2D\"", ",", "\"Conv2DTranspose\"", "]", "\n", ")", ":", "\n", "            ", "filter_sweep_enabled", "=", "True", "\n", "\n", "", "", "if", "layer", ".", "__class__", ".", "__name__", "in", "SEQUENCE_LAYERS", ":", "\n", "          ", "recurrent_quantizer", ",", "_", "=", "self", ".", "_get_quantizer", "(", "\n", "hp", ",", "layer", ".", "name", "+", "\"_recurrent_kernel\"", ",", "layer", ".", "name", ",", "layer", ".", "__class__", ".", "__name__", ",", "\n", "is_kernel", "=", "True", ")", "\n", "\n", "", "if", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"SeparableConv1D\"", ",", "\"SeparableConv2D\"", "]", ":", "\n", "          ", "pointwise_quantizer", ",", "_", "=", "self", ".", "_get_quantizer", "(", "\n", "hp", ",", "layer", ".", "name", "+", "\"_pointwise_kernel\"", ",", "layer", ".", "name", ",", "layer", ".", "__class__", ".", "__name__", ",", "\n", "is_kernel", "=", "True", ")", "\n", "\n", "", "", "", "if", "self", ".", "tune_filters", "==", "\"block\"", "and", "filter_sweep_enabled", ":", "\n", "      ", "network_filters", "=", "hp", ".", "Choice", "(", "\n", "\"network_filters\"", ",", "\n", "values", "=", "filter_range", ",", "\n", "default", "=", "1.0", "\n", ")", "\n", "", "else", ":", "\n", "      ", "network_filters", "=", "1.0", "\n", "\n", "", "for", "layer_id", ",", "layer", "in", "enumerate", "(", "model", ".", "layers", ")", ":", "\n", "\n", "# we can use these indexes to disable some layers, like the last", "\n", "# layer", "\n", "\n", "      ", "if", "self", ".", "layer_indexes", "is", "not", "None", "and", "layer_id", "not", "in", "self", ".", "layer_indexes", ":", "\n", "        ", "continue", "\n", "\n", "", "layer_d", "=", "{", "}", "\n", "\n", "if", "layer", ".", "__class__", ".", "__name__", "in", "Q_LAYERS", ":", "\n", "        ", "weights", "=", "layer", ".", "get_weights", "(", ")", "[", "0", "]", "\n", "if", "(", "\n", "layer", ".", "get_quantizers", "(", ")", "[", "0", "]", "and", "\n", "hasattr", "(", "layer", ".", "get_quantizers", "(", ")", "[", "0", "]", ",", "\"bits\"", ")", "\n", ")", ":", "\n", "          ", "bits", "=", "layer", ".", "get_quantizers", "(", ")", "[", "0", "]", ".", "bits", "\n", "", "else", ":", "\n", "          ", "bits", "=", "8", "\n", "", "fanin", ".", "append", "(", "np", ".", "prod", "(", "weights", ".", "shape", "[", ":", "-", "1", "]", ")", "*", "(", "8.", "-", "bits", ")", "/", "8.", ")", "\n", "\n", "", "if", "layer", ".", "__class__", ".", "__name__", "in", "REGISTERED_LAYERS", ":", "\n", "# difference between depthwise and the rest is just the name", "\n", "# of the kernel.", "\n", "        ", "if", "layer", ".", "__class__", ".", "__name__", "in", "[", "\n", "\"DepthwiseConv2D\"", ",", "\"SeparableConv1D\"", ",", "\"SeparableConv2D\"", "\n", "]", ":", "\n", "          ", "kernel_name", "=", "\"depthwise_quantizer\"", "\n", "", "else", ":", "\n", "          ", "kernel_name", "=", "\"kernel_quantizer\"", "\n", "\n", "# sample kernel quantizer.", "\n", "", "(", "kernel_quantizer", ",", "bits", ")", "=", "kernel_quantizer_dict", "[", "layer", ".", "name", "]", "\n", "\n", "if", "not", "kernel_quantizer", ":", "\n", "          ", "continue", "\n", "\n", "# process fanin here", "\n", "\n", "", "if", "bits", "<", "8", ":", "\n", "          ", "weights", "=", "layer", ".", "get_weights", "(", ")", "[", "0", "]", "\n", "fanin", ".", "append", "(", "np", ".", "prod", "(", "weights", ".", "shape", "[", ":", "-", "1", "]", ")", "*", "(", "8.", "-", "bits", ")", "/", "8.", ")", "\n", "\n", "# we only want to do that if we are going to quantize layer", "\n", "", "if", "(", "\n", "self", ".", "tune_filters", "in", "[", "\"layer\"", ",", "\"block\"", "]", "and", "\n", "not", "self", ".", "tune_filters_exceptions", ".", "search", "(", "layer", ".", "name", ")", "and", "\n", "layer", ".", "__class__", ".", "__name__", "in", "[", "\n", "\"Dense\"", ",", "\"Conv1D\"", ",", "\"Conv2D\"", ",", "\"Conv2DTranspose\"", ",", "\n", "\"SeparableConv1D\"", ",", "\"SeparableConv2D\"", "\n", "]", "\n", ")", ":", "\n", "          ", "if", "self", ".", "tune_filters", "==", "\"layer\"", ":", "\n", "            ", "layer_filters", "=", "hp", ".", "Choice", "(", "\n", "\"network_filters_\"", "+", "layer", ".", "name", ",", "\n", "values", "=", "filter_range", ",", "\n", "default", "=", "1.0", "\n", ")", "\n", "", "else", ":", "\n", "            ", "layer_filters", "=", "network_filters", "\n", "\n", "", "if", "layer", ".", "__class__", ".", "__name__", "==", "\"Dense\"", ":", "\n", "            ", "layer", ".", "units", "=", "max", "(", "int", "(", "layer", ".", "units", "*", "layer_filters", ")", ",", "1", ")", "\n", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\n", "\"Conv1D\"", ",", "\"Conv2D\"", ",", "\"Conv2DTranspose\"", ",", "\n", "\"SeparableConv1D\"", ",", "\"SeparableConv2D\"", "\n", "]", ":", "\n", "            ", "layer", ".", "filters", "=", "max", "(", "int", "(", "layer", ".", "filters", "*", "layer_filters", ")", ",", "1", ")", "\n", "\n", "", "", "layer_d", "[", "kernel_name", "]", "=", "kernel_quantizer", "\n", "\n", "if", "layer", ".", "__class__", ".", "__name__", "in", "SEQUENCE_LAYERS", ":", "\n", "          ", "layer_d", "[", "'recurrent_quantizer'", "]", "=", "recurrent_quantizer", "\n", "\n", "", "if", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"SeparableConv1D\"", ",", "\"SeparableConv2D\"", "]", ":", "\n", "          ", "layer_d", "[", "'pointwise_quantizer'", "]", "=", "pointwise_quantizer", "\n", "\n", "", "if", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"LSTM\"", ",", "\"GRU\"", ",", "\"Bidirectional\"", "]", ":", "\n", "          ", "layer_d", "[", "'recurrent_activation'", "]", ",", "_", "=", "self", ".", "_get_quantizer", "(", "\n", "hp", ",", "layer", ".", "name", "+", "\"_recurrent_activation\"", ",", "layer", ".", "name", ",", "\n", "layer", ".", "__class__", ".", "__name__", ",", "is_kernel", "=", "False", ")", "\n", "\n", "# if we use bias, sample quantizer.", "\n", "", "if", "layer", ".", "__class__", ".", "__name__", "==", "\"Bidirectional\"", ":", "\n", "          ", "layer_d", "[", "\"bias_quantizer\"", "]", ",", "bits", "=", "self", ".", "_get_quantizer", "(", "\n", "hp", ",", "layer", ".", "name", "+", "\"_bias\"", ",", "layer", ".", "name", ",", "layer", ".", "__class__", ".", "__name__", ",", "\n", "is_kernel", "=", "False", ")", "\n", "layer_d", "[", "\"activation\"", "]", ",", "bits", "=", "self", ".", "_get_quantizer", "(", "\n", "hp", ",", "layer", ".", "name", "+", "\"_activation\"", ",", "layer", ".", "name", ",", "\n", "layer", ".", "__class__", ".", "__name__", ",", "is_kernel", "=", "False", ")", "\n", "q_dict", "[", "layer", ".", "name", "]", "=", "layer_d", "\n", "", "else", ":", "\n", "          ", "if", "layer", ".", "use_bias", ":", "\n", "            ", "layer_d", "[", "\"bias_quantizer\"", "]", ",", "bits", "=", "self", ".", "_get_quantizer", "(", "\n", "hp", ",", "layer", ".", "name", "+", "\"_bias\"", ",", "layer", ".", "name", ",", "layer", ".", "__class__", ".", "__name__", ",", "\n", "is_kernel", "=", "False", ")", "\n", "\n", "# if activation is not linear/softmax we need to process it.", "\n", "", "if", "layer", ".", "activation", "is", "None", ":", "\n", "            ", "is_softmax", "=", "False", "\n", "is_linear", "=", "False", "\n", "", "else", ":", "\n", "            ", "if", "isinstance", "(", "layer", ".", "activation", ",", "six", ".", "string_types", ")", ":", "\n", "              ", "is_softmax", "=", "layer", ".", "activation", "==", "\"softmax\"", "\n", "is_linear", "=", "layer", ".", "activation", "==", "\"linear\"", "\n", "", "else", ":", "\n", "              ", "is_softmax", "=", "layer", ".", "activation", ".", "__name__", "==", "\"softmax\"", "\n", "is_linear", "=", "layer", ".", "activation", ".", "__name__", "==", "\"linear\"", "\n", "\n", "", "", "if", "not", "is_softmax", "and", "not", "is_linear", ":", "\n", "            ", "layer_d", "[", "\"activation\"", "]", ",", "bits", "=", "self", ".", "_get_quantizer", "(", "\n", "hp", ",", "layer", ".", "name", "+", "\"_activation\"", ",", "layer", ".", "name", ",", "\n", "layer", ".", "__class__", ".", "__name__", ",", "is_kernel", "=", "False", ")", "\n", "\n", "", "q_dict", "[", "layer", ".", "name", "]", "=", "layer_d", "\n", "\n", "", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"Reshape\"", "]", ":", "\n", "# we cannot handle fine tuning filters per layer right now.", "\n", "        ", "assert", "self", ".", "tune_filters", "in", "[", "\"none\"", ",", "\"block\"", "]", "\n", "\n", "# we need to make sure this pattern exists, this should only occur for", "\n", "# \"scheduler\", so the name will be complete and not a pattern.", "\n", "\n", "if", "(", "\n", "self", ".", "tune_filters", "==", "\"none\"", "or", "\n", "layer", ".", "name", "not", "in", "self", ".", "limit", "or", "\n", "self", ".", "tune_filters_exceptions", ".", "search", "(", "layer", ".", "name", ")", "\n", ")", ":", "\n", "          ", "continue", "\n", "\n", "", "if", "K", ".", "image_data_format", "(", ")", "==", "\"channels_last\"", ":", "\n", "          ", "layer", ".", "target_shape", "=", "layer", ".", "target_shape", "[", ":", "-", "1", "]", "+", "(", "\n", "min", "(", "int", "(", "layer", ".", "target_shape", "[", "-", "1", "]", "*", "network_filters", ")", ",", "1", ")", ",", ")", "\n", "", "else", ":", "\n", "          ", "layer", ".", "target_shape", "=", "(", "int", "(", "layer", ".", "target_shape", "[", "0", "]", "*", "network_filters", ")", ",", "\n", ")", "+", "layer", ".", "target_shape", "[", "1", ":", "]", "\n", "\n", "", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"Activation\"", "]", ":", "\n", "        ", "if", "isinstance", "(", "layer", ".", "activation", ",", "six", ".", "string_types", ")", ":", "\n", "          ", "is_linear", "=", "layer", ".", "activation", "==", "\"linear\"", "\n", "is_softmax", "=", "layer", ".", "activation", "==", "\"softmax\"", "\n", "", "else", ":", "\n", "          ", "is_linear", "=", "layer", ".", "activation", ".", "__name__", "==", "\"linear\"", "\n", "is_softmax", "=", "layer", ".", "activation", ".", "__name__", "==", "\"softmax\"", "\n", "\n", "# if it is a linear activation, we will notify the", "\n", "# quantizer we are searching for linear type of", "\n", "# quantizers", "\n", "\n", "", "if", "not", "is_softmax", ":", "\n", "          ", "activation", ",", "bits", "=", "self", ".", "_get_quantizer", "(", "\n", "hp", ",", "layer", ".", "name", "+", "\"_activation\"", ",", "layer", ".", "name", ",", "\n", "layer", ".", "__class__", ".", "__name__", ",", "is_kernel", "=", "False", ",", "\n", "is_linear", "=", "is_linear", ")", "\n", "\n", "if", "not", "activation", ":", "\n", "            ", "continue", "\n", "\n", "# look at documentation on model_quantize", "\n", "", "q_dict", "[", "layer", ".", "name", "]", "=", "activation", "\n", "", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "self", ".", "limit", ":", "\n", "# mark it for conversion", "\n", "        ", "q_dict", "[", "layer", ".", "name", "]", "=", "{", "}", "\n", "", "else", ":", "\n", "        ", "for", "pattern", "in", "self", ".", "limit", ":", "\n", "          ", "if", "re", ".", "match", "(", "pattern", ",", "layer", ".", "name", ")", ":", "\n", "            ", "q_dict", "[", "layer", ".", "name", "]", "=", "{", "}", "\n", "break", "\n", "\n", "", "", "", "", "q_model", "=", "model_quantize", "(", "\n", "model", ",", "q_dict", ",", "self", ".", "activation_bits", ",", "\n", "custom_objects", "=", "self", ".", "custom_objects", ",", "\n", "transfer_weights", "=", "self", ".", "transfer_weights", ")", "\n", "\n", "return", "q_model", ",", "fanin", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel.build": [[563, 692], ["autoqkeras_internal.AutoQKHyperModel.quantize_model", "autoqkeras_internal.AutoQKHyperModel.target.get_trial", "autoqkeras_internal.AutoQKHyperModel.target.delta", "autoqkeras_internal.AutoQKHyperModel.adjusted_score", "autoqkeras_internal.AutoQKHyperModel.target.get_total_factor", "float", "q_model.summary", "q_model.compile", "autoqkeras_internal.AutoQKHyperModel.target.print_stats", "qkeras.autoqkeras.utils.print_qmodel_summary", "print", "isinstance", "autoqkeras_internal.AutoQKHyperModel.model.optimizer.lr.numpy", "list", "hp.Choice", "print", "copy.deepcopy", "isinstance", "autoqkeras_internal.AutoQKHyperModel.model.get_layer().get_weights", "q_model.get_layer", "q_model.get_layer.get_weights", "range", "isinstance", "isinstance", "isinstance", "len", "q_model.get_layer.set_weights", "numpy.linspace", "autoqkeras_internal.AutoQKHyperModel.trial_size_metric", "autoqkeras_internal.AutoQKHyperModel.model.get_layer", "list", "list", "autoqkeras_internal.AutoQKHyperModel.trial_size_metric", "autoqkeras_internal.AutoQKHyperModel.trial_size_metric", "autoqkeras_internal.AutoQKHyperModel.metrics.keys", "copy.deepcopy.keys"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel.quantize_model", "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits.get_trial", "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_factor.ForgivingFactor.delta", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel.adjusted_score", "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits.get_total_factor", "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits.print_stats", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.utils.print_qmodel_summary", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QAdaptiveActivation.set_weights", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel.trial_size_metric", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel.trial_size_metric", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel.trial_size_metric"], ["", "def", "build", "(", "self", ",", "hp", ")", ":", "\n", "    ", "\"\"\"Builds hyperparameterized quantized model.\"\"\"", "\n", "\n", "self", ".", "groups", "=", "{", "}", "\n", "\n", "# we are not using the fanin right now.", "\n", "\n", "q_model", ",", "_", "=", "self", ".", "quantize_model", "(", "hp", ")", "\n", "\n", "# transfer weights from previous run as we know we will not", "\n", "if", "self", ".", "learning_rate_optimizer", ":", "\n", "# if learning_rate_optimizer, we try to transfer weights from previous run", "\n", "      ", "print", "(", "\"... freezing layers {}.\"", ".", "format", "(", "\", \"", ".", "join", "(", "self", ".", "frozen_layers", ")", ")", ")", "\n", "for", "layer_name", "in", "self", ".", "frozen_layers", ":", "\n", "        ", "o_weights", "=", "self", ".", "model", ".", "get_layer", "(", "layer_name", ")", ".", "get_weights", "(", ")", "\n", "layer", "=", "q_model", ".", "get_layer", "(", "layer_name", ")", "\n", "# don't know if setting trainable to False is good or not yet", "\n", "# try to do \"soft-freeze\" by transferring weights. More experiments", "\n", "# needed before we decide what to do.", "\n", "# layer.trainable = False", "\n", "weights", "=", "layer", ".", "get_weights", "(", ")", "\n", "# because we can be changing number of layers, we do not know", "\n", "# if we can really use some of the weights or not.", "\n", "equal_layer", "=", "True", "\n", "for", "w", "in", "range", "(", "len", "(", "o_weights", ")", ")", ":", "\n", "          ", "if", "o_weights", "[", "w", "]", ".", "shape", "!=", "weights", "[", "w", "]", ".", "shape", ":", "\n", "            ", "equal_layer", "=", "False", "\n", "break", "\n", "", "", "if", "equal_layer", ":", "\n", "          ", "layer", ".", "set_weights", "(", "o_weights", ")", "\n", "\n", "", "", "", "self", ".", "trial_size", "=", "self", ".", "target", ".", "get_trial", "(", "q_model", ")", "\n", "\n", "# we will use a boosted accuracy computation", "\n", "\n", "delta", "=", "self", ".", "target", ".", "delta", "(", ")", "\n", "\n", "# by default, we use the first metric specified by the", "\n", "# user to be the target metric.", "\n", "if", "not", "self", ".", "metrics", ":", "\n", "      ", "score_metric", "=", "None", "\n", "", "elif", "isinstance", "(", "self", ".", "metrics", ",", "dict", ")", ":", "\n", "      ", "if", "not", "self", ".", "head_name", ":", "\n", "# if head_name not provided, find the first metric from the dict", "\n", "        ", "score_key", "=", "list", "(", "self", ".", "metrics", ".", "keys", "(", ")", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "# find the metric assoicated with the head_name", "\n", "        ", "score_key", "=", "self", ".", "head_name", "\n", "", "score_metric", "=", "self", ".", "metrics", "[", "score_key", "]", "\n", "if", "isinstance", "(", "score_metric", ",", "list", ")", ":", "\n", "        ", "score_metric", "=", "score_metric", "[", "0", "]", "\n", "", "", "elif", "isinstance", "(", "self", ".", "metrics", ",", "list", ")", ":", "\n", "      ", "score_metric", "=", "self", ".", "metrics", "[", "0", "]", "\n", "\n", "", "self", ".", "score", "=", "AutoQKHyperModel", ".", "adjusted_score", "(", "\n", "self", ",", "delta", ",", "score_metric", ")", "\n", "\n", "# some papers suggest that we use learning_rate * sqrt(fanin) / layer", "\n", "# we cannot do that right now, but we can definitely do that", "\n", "# if we are quantizing one layer at a time", "\n", "#", "\n", "# https://arxiv.org/pdf/1511.00363.pdf", "\n", "\n", "# we use the magic number to smooth out the average", "\n", "total_factor", "=", "self", ".", "target", ".", "get_total_factor", "(", ")", "\n", "delta_lr", "=", "1.0", "+", "(", "total_factor", "<", "0", ")", "*", "total_factor", "\n", "\n", "# we assume model has been compiled at least.", "\n", "\n", "lr", "=", "float", "(", "self", ".", "model", ".", "optimizer", ".", "lr", ".", "numpy", "(", ")", ")", "\n", "\n", "# we assume that delta_lr can lower lr to accommodate", "\n", "# for more quantization", "\n", "#", "\n", "# if learning rate scheduler is used, we assume the callback to manage", "\n", "# learning rate. Just set it to constant.", "\n", "\n", "if", "self", ".", "learning_rate_optimizer", ":", "\n", "      ", "lr_range", "=", "list", "(", "lr", "*", "np", ".", "linspace", "(", "delta_lr", ",", "1.1", ",", "5", ")", ")", "\n", "lr_choice", "=", "hp", ".", "Choice", "(", "\"learning_rate\"", ",", "lr_range", ")", "\n", "self", ".", "model", ".", "optimizer", ".", "learning_rate", "=", "lr_choice", "\n", "", "else", ":", "\n", "      ", "lr_choice", "=", "lr", "\n", "print", "(", "\"learning_rate: {}\"", ".", "format", "(", "lr", ")", ")", "\n", "\n", "", "optimizer", "=", "self", ".", "model", ".", "optimizer", "\n", "\n", "q_model", ".", "summary", "(", ")", "\n", "\n", "metrics", "=", "self", ".", "metrics", "\n", "\n", "# extend metrics by including score and trial_size metrics", "\n", "if", "self", ".", "extend_model_metrics", ":", "\n", "      ", "ext_metrics", "=", "copy", ".", "deepcopy", "(", "metrics", ")", "\n", "if", "isinstance", "(", "ext_metrics", ",", "dict", ")", ":", "\n", "# for dict, add trial_size_metric and score metric to target output", "\n", "        ", "if", "not", "self", ".", "head_name", ":", "\n", "# if head_name not provided, find the first metric from the dict", "\n", "          ", "score_key", "=", "list", "(", "ext_metrics", ".", "keys", "(", ")", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "# find the metric assoicated with the head_name", "\n", "          ", "score_key", "=", "self", ".", "head_name", "\n", "", "score_metric", "=", "ext_metrics", "[", "score_key", "]", "\n", "if", "isinstance", "(", "score_metric", ",", "list", ")", ":", "\n", "          ", "score_metric", "+=", "[", "self", ".", "trial_size_metric", "(", "self", ".", "trial_size", ")", ",", "self", ".", "score", "]", "\n", "", "else", ":", "\n", "          ", "score_metric", "=", "[", "score_metric", "]", "\n", "score_metric", "+=", "[", "self", ".", "trial_size_metric", "(", "self", ".", "trial_size", ")", ",", "self", ".", "score", "]", "\n", "", "ext_metrics", "[", "score_key", "]", "=", "score_metric", "\n", "", "else", ":", "\n", "        ", "ext_metrics", "+=", "[", "\n", "self", ".", "trial_size_metric", "(", "self", ".", "trial_size", ")", ",", "\n", "self", ".", "score", "]", "\n", "", "metrics", "=", "ext_metrics", "\n", "\n", "", "q_model", ".", "compile", "(", "\n", "optimizer", "=", "optimizer", ",", "\n", "loss", "=", "self", ".", "model", ".", "loss", ",", "\n", "metrics", "=", "metrics", "\n", ")", "\n", "self", ".", "q_model", "=", "q_model", "\n", "\n", "# this just prints a summary of the quantization for debugging", "\n", "# purposes", "\n", "\n", "self", ".", "target", ".", "print_stats", "(", ")", "\n", "print_qmodel_summary", "(", "q_model", ")", "\n", "\n", "return", "q_model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel.adjusted_score": [[693, 724], ["len", "len", "isinstance", "tensorflow.cast", "tensorflow.cast", "y_true.shape.as_list", "y_pred.shape.as_list", "y_true.shape.as_list", "y_pred.shape.as_list", "metric_function", "tensorflow.floatx", "tensorflow.floatx", "tensorflow.keras.metrics.categorical_accuracy", "tensorflow.keras.metrics.categorical_accuracy", "tensorflow.keras.metrics.binary_accuracy", "tensorflow.keras.metrics.binary_accuracy", "tensorflow.keras.metrics.sparse_categorical_accuracy", "tensorflow.keras.metrics.sparse_categorical_accuracy", "tensorflow.keras.metrics.categorical_accuracy", "tensorflow.keras.metrics.categorical_accuracy"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "adjusted_score", "(", "hyper_model", ",", "delta", ",", "metric_function", "=", "None", ")", ":", "\n", "    ", "def", "score", "(", "y_true", ",", "y_pred", ")", ":", "\n", "      ", "y_t_rank", "=", "len", "(", "y_true", ".", "shape", ".", "as_list", "(", ")", ")", "\n", "y_p_rank", "=", "len", "(", "y_pred", ".", "shape", ".", "as_list", "(", ")", ")", "\n", "y_t_last_dim", "=", "y_true", ".", "shape", ".", "as_list", "(", ")", "[", "-", "1", "]", "\n", "y_p_last_dim", "=", "y_pred", ".", "shape", ".", "as_list", "(", ")", "[", "-", "1", "]", "\n", "\n", "is_binary", "=", "y_p_last_dim", "==", "1", "\n", "is_sparse_categorical", "=", "(", "\n", "y_t_rank", "<", "y_p_rank", "or", "y_t_last_dim", "==", "1", "and", "y_p_last_dim", ">", "1", ")", "\n", "\n", "if", "isinstance", "(", "metric_function", ",", "six", ".", "string_types", ")", ":", "\n", "        ", "if", "metric_function", "in", "[", "\"accuracy\"", ",", "\"acc\"", "]", ":", "\n", "          ", "if", "is_binary", ":", "\n", "            ", "metric", "=", "binary_accuracy", "(", "y_true", ",", "y_pred", ")", "\n", "", "elif", "is_sparse_categorical", ":", "\n", "            ", "metric", "=", "sparse_categorical_accuracy", "(", "y_true", ",", "y_pred", ")", "\n", "", "else", ":", "\n", "            ", "metric", "=", "categorical_accuracy", "(", "y_true", ",", "y_pred", ")", "\n", "", "", "else", ":", "\n", "          ", "metric", "=", "categorical_accuracy", "(", "y_true", ",", "y_pred", ")", "\n", "", "", "else", ":", "\n", "        ", "metric", "=", "metric_function", "(", "y_true", ",", "y_pred", ")", "\n", "\n", "", "return", "K", ".", "cast", "(", "metric", "*", "(", "1.0", "+", "delta", ")", ",", "K", ".", "floatx", "(", ")", ")", "\n", "\n", "", "if", "not", "metric_function", ":", "\n", "      ", "metric_function", "=", "\"accuracy\"", "\n", "\n", "", "return", "score", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKHyperModel.trial_size_metric": [[725, 730], ["tensorflow.cast", "tensorflow.cast", "tensorflow.floatx", "tensorflow.floatx"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "trial_size_metric", "(", "trial_size", ")", ":", "\n", "    ", "def", "trial", "(", "y_true", ",", "y_pred", ")", ":", "# pylint: disable=unused-argument", "\n", "      ", "return", "K", ".", "cast", "(", "trial_size", ",", "K", ".", "floatx", "(", ")", ")", "\n", "", "return", "trial", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKeras.__init__": [[765, 890], ["locals", "autoqkeras_internal.AutoQKHyperModel", "autoqkeras_internal.AutoQKeras.tuner.search_space_summary", "isinstance", "os.path.exists", "custom_tuner", "keras_tuner.RandomSearch", "str", "keras_tuner.Objective", "keras_tuner.BayesianOptimization", "keras_tuner.Objective", "keras_tuner.Hyperband", "keras_tuner.Objective", "keras_tuner.Objective"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "model", ",", "metrics", "=", "None", ",", "custom_objects", "=", "None", ",", "goal", "=", "None", ",", "\n", "output_dir", "=", "\"result\"", ",", "mode", "=", "\"random\"", ",", "custom_tuner", "=", "None", ",", "\n", "transfer_weights", "=", "False", ",", "frozen_layers", "=", "None", ",", "activation_bits", "=", "4", ",", "\n", "limit", "=", "None", ",", "tune_filters", "=", "\"none\"", ",", "\n", "tune_filters_exceptions", "=", "None", ",", "learning_rate_optimizer", "=", "False", ",", "\n", "layer_indexes", "=", "None", ",", "quantization_config", "=", "None", ",", "overwrite", "=", "True", ",", "\n", "head_name", "=", "None", ",", "score_metric", "=", "None", ",", "**", "tuner_kwargs", ")", ":", "\n", "\n", "# Collect input arguments to AutoQKeras for usage by custom tuner", "\n", "    ", "autoqkeras_input_args", "=", "locals", "(", ")", "\n", "\n", "if", "not", "metrics", ":", "\n", "      ", "metrics", "=", "[", "]", "\n", "\n", "", "if", "not", "custom_objects", ":", "\n", "      ", "custom_objects", "=", "{", "}", "\n", "\n", "# goal: { \"type\": [\"bits\", \"energy\"], \"params\": {...} } or ForgivingFactor", "\n", "#   type", "\n", "# For type == \"bits\":", "\n", "#   delta_p: increment (in %) of the accuracy if trial is smaller.", "\n", "#   delta_n: decrement (in %) of the accuracy if trial is bigger.", "\n", "#   rate: rate of decrease/increase in model size in terms of bits.", "\n", "#   input_bits; size of input tensors.", "\n", "#   output_bits; size of output tensors.", "\n", "#   stress: parameter to reduce reference size to force tuner to", "\n", "#     choose smaller models.", "\n", "#   config: configuration on what to compute for each layer", "\n", "#     minimum configuration is { \"default\": [\"parameters\", \"activations\"] }", "\n", "\n", "# use simplest one - number of bits", "\n", "", "if", "not", "goal", ":", "\n", "      ", "goal", "=", "{", "\n", "\"type\"", ":", "\"bits\"", ",", "\n", "\"params\"", ":", "{", "\n", "\"delta_p\"", ":", "8.0", ",", "\n", "\"delta_n\"", ":", "8.0", ",", "\n", "\"rate\"", ":", "2.0", ",", "\n", "\"stress\"", ":", "1.0", ",", "\n", "\"input_bits\"", ":", "8", ",", "\n", "\"output_bits\"", ":", "8", ",", "\n", "\"ref_bits\"", ":", "8", ",", "\n", "\"config\"", ":", "{", "\n", "\"default\"", ":", "[", "\"parameters\"", ",", "\"activations\"", "]", "\n", "}", "\n", "}", "\n", "}", "\n", "\n", "", "self", ".", "overwrite", "=", "overwrite", "\n", "\n", "# for multi-head model, we need to specify which head(/output) that", "\n", "# score and trial metric needs to calculate from", "\n", "self", ".", "head_name", "=", "head_name", "\n", "\n", "# if we have not created it already, create new one.", "\n", "if", "not", "isinstance", "(", "goal", ",", "ForgivingFactor", ")", ":", "\n", "      ", "target", "=", "forgiving_factor", "[", "goal", "[", "\"type\"", "]", "]", "(", "**", "goal", "[", "\"params\"", "]", ")", "\n", "", "else", ":", "\n", "      ", "target", "=", "goal", "\n", "\n", "# if no metrics were specified, we want to make sure we monitor at least", "\n", "# accuracy.", "\n", "", "if", "not", "metrics", ":", "\n", "      ", "metrics", "=", "[", "\"acc\"", "]", "\n", "\n", "", "self", ".", "hypermodel", "=", "AutoQKHyperModel", "(", "\n", "model", ",", "metrics", ",", "custom_objects", ",", "target", ",", "\n", "transfer_weights", "=", "transfer_weights", ",", "\n", "frozen_layers", "=", "frozen_layers", ",", "\n", "activation_bits", "=", "activation_bits", ",", "\n", "limit", "=", "limit", ",", "\n", "tune_filters", "=", "tune_filters", ",", "\n", "tune_filters_exceptions", "=", "tune_filters_exceptions", ",", "\n", "layer_indexes", "=", "layer_indexes", ",", "\n", "learning_rate_optimizer", "=", "learning_rate_optimizer", ",", "\n", "head_name", "=", "head_name", ",", "\n", "quantization_config", "=", "quantization_config", "\n", ")", "\n", "\n", "# right now we create unique results directory", "\n", "idx", "=", "0", "\n", "name", "=", "output_dir", "\n", "if", "self", ".", "overwrite", ":", "\n", "      ", "while", "os", ".", "path", ".", "exists", "(", "name", ")", ":", "\n", "        ", "idx", "+=", "1", "\n", "name", "=", "output_dir", "+", "\"_\"", "+", "str", "(", "idx", ")", "\n", "", "", "output_dir", "=", "name", "\n", "self", ".", "output_dir", "=", "output_dir", "\n", "\n", "if", "score_metric", "is", "None", ":", "\n", "      ", "if", "self", ".", "head_name", ":", "\n", "        ", "score_metric", "=", "\"val_\"", "+", "self", ".", "head_name", "+", "\"_score\"", "\n", "", "else", ":", "\n", "        ", "score_metric", "=", "\"val_score\"", "\n", "", "", "assert", "mode", "in", "[", "\"random\"", ",", "\"bayesian\"", ",", "\"hyperband\"", "]", "\n", "if", "custom_tuner", "is", "not", "None", ":", "\n", "      ", "self", ".", "tuner", "=", "custom_tuner", "(", "\n", "self", ".", "hypermodel", ",", "\n", "autoqkeras_config", "=", "autoqkeras_input_args", ",", "\n", "objective", "=", "kt", ".", "Objective", "(", "score_metric", ",", "\"max\"", ")", ",", "\n", "project_name", "=", "output_dir", ",", "\n", "**", "tuner_kwargs", ")", "\n", "", "elif", "mode", "==", "\"random\"", ":", "\n", "      ", "self", ".", "tuner", "=", "RandomSearch", "(", "\n", "self", ".", "hypermodel", ",", "\n", "objective", "=", "kt", ".", "Objective", "(", "score_metric", ",", "\"max\"", ")", ",", "\n", "project_name", "=", "output_dir", ",", "\n", "**", "tuner_kwargs", ")", "\n", "", "elif", "mode", "==", "\"bayesian\"", ":", "\n", "      ", "self", ".", "tuner", "=", "BayesianOptimization", "(", "\n", "self", ".", "hypermodel", ",", "\n", "objective", "=", "kt", ".", "Objective", "(", "score_metric", ",", "\"max\"", ")", ",", "\n", "project_name", "=", "output_dir", ",", "\n", "**", "tuner_kwargs", ")", "\n", "", "elif", "mode", "==", "\"hyperband\"", ":", "\n", "      ", "self", ".", "tuner", "=", "Hyperband", "(", "\n", "self", ".", "hypermodel", ",", "\n", "objective", "=", "kt", ".", "Objective", "(", "score_metric", ",", "\"max\"", ")", ",", "\n", "project_name", "=", "output_dir", ",", "\n", "**", "tuner_kwargs", ")", "\n", "", "else", ":", "\n", "      ", "pass", "\n", "\n", "", "self", ".", "tuner", ".", "search_space_summary", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKeras._has_earlystopping": [[891, 900], ["isinstance"], "methods", ["None"], ["", "def", "_has_earlystopping", "(", "self", ",", "callbacks", ")", ":", "\n", "    ", "\"\"\"Check if EarlyStopping has been defined or not.\"\"\"", "\n", "if", "callbacks", "is", "None", ":", "\n", "      ", "return", "False", "\n", "\n", "", "for", "callback", "in", "callbacks", ":", "\n", "      ", "if", "isinstance", "(", "callback", ",", "tf", ".", "keras", ".", "callbacks", ".", "EarlyStopping", ")", ":", "\n", "        ", "return", "True", "\n", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKeras.history": [[901, 946], ["autoqkeras_internal.AutoQKeras.tuner.oracle.get_best_trials", "range", "trial.get_state", "len", "range", "[].keys", "range", "len", "len", "key.startswith", "[].keys", "result.keys", "result[].append", "result[].append"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "history", "(", "self", ",", "number_of_trials", "=", "-", "1", ")", ":", "\n", "    ", "\"\"\"Returns the history of the model search.\"\"\"", "\n", "trials", "=", "self", ".", "tuner", ".", "oracle", ".", "get_best_trials", "(", "number_of_trials", ")", "\n", "state", "=", "[", "trial", ".", "get_state", "(", ")", "for", "trial", "in", "trials", "]", "\n", "\n", "result", "=", "{", "}", "\n", "result", "[", "\"score\"", "]", "=", "[", "\n", "state", "[", "i", "]", "[", "\"score\"", "]", "for", "i", "in", "range", "(", "len", "(", "state", ")", ")", "\n", "if", "trials", "[", "i", "]", ".", "score", "is", "not", "None", "\n", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "state", ")", ")", ":", "\n", "      ", "if", "trials", "[", "i", "]", ".", "score", "is", "not", "None", ":", "\n", "        ", "keys", "=", "state", "[", "i", "]", "[", "\"metrics\"", "]", "[", "\"metrics\"", "]", ".", "keys", "(", ")", "\n", "\n", "for", "key", "in", "keys", ":", "\n", "          ", "if", "key", "!=", "\"score\"", "and", "not", "key", ".", "startswith", "(", "\n", "\"val_\"", ")", "and", "key", "!=", "\"loss\"", "and", "key", "!=", "\"trial\"", ":", "\n", "\n", "            ", "cur_accuracy", "=", "state", "[", "i", "]", "[", "\"metrics\"", "]", "[", "\"metrics\"", "]", "[", "key", "]", "[", "\n", "\"observations\"", "]", "[", "0", "]", "[", "\"value\"", "]", "[", "0", "]", "\n", "if", "\"val_\"", "+", "key", "in", "state", "[", "i", "]", "[", "\"metrics\"", "]", "[", "\"metrics\"", "]", ".", "keys", "(", ")", ":", "\n", "              ", "cur_val_accuracy", "=", "state", "[", "i", "]", "[", "\"metrics\"", "]", "[", "\"metrics\"", "]", "[", "\"val_\"", "+", "key", "]", "[", "\n", "\"observations\"", "]", "[", "0", "]", "[", "\"value\"", "]", "[", "0", "]", "\n", "", "else", ":", "\n", "              ", "cur_val_accuracy", "=", "None", "\n", "\n", "# only update result if both key and val_key exist", "\n", "", "if", "cur_val_accuracy", ":", "\n", "              ", "if", "key", "not", "in", "result", ".", "keys", "(", ")", ":", "\n", "                ", "result", "[", "key", "]", "=", "[", "cur_accuracy", "]", "\n", "result", "[", "\"val_\"", "+", "key", "]", "=", "[", "cur_val_accuracy", "]", "\n", "", "else", ":", "\n", "                ", "result", "[", "key", "]", ".", "append", "(", "cur_accuracy", ")", "\n", "result", "[", "\"val_\"", "+", "key", "]", ".", "append", "(", "cur_val_accuracy", ")", "\n", "\n", "", "", "", "", "", "", "if", "self", ".", "head_name", ":", "\n", "      ", "trial_from_output", "=", "self", ".", "head_name", "+", "\"_trial\"", "\n", "", "else", ":", "\n", "      ", "trial_from_output", "=", "\"trial\"", "\n", "", "result", "[", "\"trial_size\"", "]", "=", "[", "\n", "state", "[", "i", "]", "[", "\"metrics\"", "]", "[", "\"metrics\"", "]", "[", "trial_from_output", "]", "[", "\"observations\"", "]", "[", "0", "]", "\n", "[", "\"value\"", "]", "[", "0", "]", "for", "i", "in", "range", "(", "len", "(", "state", ")", ")", "if", "trials", "[", "i", "]", ".", "score", "is", "not", "None", "\n", "]", "\n", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKeras.fit": [[947, 968], ["fit_kwargs.get", "fit_kwargs.get", "autoqkeras_internal.AutoQKeras.tuner.search", "autoqkeras_internal.AutoQKeras._has_earlystopping", "tensorflow.keras.callbacks.EarlyStopping", "tensorflow.keras.callbacks.EarlyStopping", "min"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKeras._has_earlystopping", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min"], ["", "def", "fit", "(", "self", ",", "*", "fit_args", ",", "**", "fit_kwargs", ")", ":", "\n", "    ", "\"\"\"Invokes tuner fit algorithm.\"\"\"", "\n", "\n", "callbacks", "=", "fit_kwargs", ".", "get", "(", "\"callbacks\"", ",", "None", ")", "\n", "\n", "if", "callbacks", "is", "None", ":", "\n", "      ", "callbacks", "=", "[", "]", "\n", "\n", "", "epochs", "=", "fit_kwargs", ".", "get", "(", "\"epochs\"", ",", "None", ")", "\n", "\n", "if", "epochs", "is", "None", ":", "\n", "      ", "epochs", "=", "10", "\n", "\n", "", "if", "not", "self", ".", "_has_earlystopping", "(", "callbacks", ")", ":", "\n", "      ", "callbacks", "=", "callbacks", "+", "[", "\n", "tf", ".", "keras", ".", "callbacks", ".", "EarlyStopping", "(", "\n", "\"val_loss\"", ",", "patience", "=", "min", "(", "20", ",", "epochs", "//", "5", ")", ")", "\n", "]", "\n", "fit_kwargs", "[", "\"callbacks\"", "]", "=", "callbacks", "\n", "\n", "", "self", ".", "tuner", ".", "search", "(", "*", "fit_args", ",", "**", "fit_kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKeras.get_best_lr": [[969, 973], ["qmodel.optimizer.lr.numpy"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_best_lr", "(", "qmodel", ")", ":", "\n", "    ", "\"\"\"Extracts best lr of model.\"\"\"", "\n", "return", "qmodel", ".", "optimizer", ".", "lr", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKeras.get_best_model": [[974, 982], ["autoqkeras_internal.AutoQKeras.tuner.hypermodel.build", "autoqkeras_internal.AutoQKeras.optimizer.lr.numpy", "autoqkeras_internal.AutoQKeras.tuner.get_best_hyperparameters"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.networks.conv_block.ConvBlockNetwork.build"], ["", "def", "get_best_model", "(", "self", ")", ":", "\n", "    ", "params", "=", "self", ".", "tuner", ".", "get_best_hyperparameters", "(", ")", "[", "0", "]", "\n", "\n", "q_model", "=", "self", ".", "tuner", ".", "hypermodel", ".", "build", "(", "params", ")", "\n", "\n", "self", ".", "learning_rate", "=", "q_model", ".", "optimizer", ".", "lr", ".", "numpy", "(", ")", "\n", "\n", "return", "q_model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKeras.get_learning_rate": [[983, 985], ["None"], "methods", ["None"], ["", "def", "get_learning_rate", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "learning_rate", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.__init__": [[1019, 1114], ["model.optimizer.lr.numpy", "autoqkeras_internal.AutoQKerasScheduler.get_next_block", "os.path.exists", "autoqkeras_internal.AutoQKerasScheduler.tuner_kwargs.get", "print", "tensorflow.keras.models.load_model", "tensorflow.keras.models.load_model", "str", "autoqkeras_internal.AutoQKerasScheduler.scope", "tensorflow.keras.models.load_model", "tensorflow.keras.models.load_model", "os.path.join", "os.path.join", "str", "str"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.get_next_block"], ["def", "__init__", "(", "\n", "self", ",", "model", ",", "metrics", "=", "None", ",", "custom_objects", "=", "None", ",", "goal", "=", "None", ",", "\n", "output_dir", "=", "\"result\"", ",", "mode", "=", "\"random\"", ",", "transfer_weights", "=", "False", ",", "\n", "activation_bits", "=", "4", ",", "limit", "=", "None", ",", "tune_filters", "=", "\"none\"", ",", "\n", "tune_filters_exceptions", "=", "None", ",", "layer_indexes", "=", "None", ",", "\n", "learning_rate_optimizer", "=", "False", ",", "blocks", "=", "None", ",", "schedule_block", "=", "\"sequential\"", ",", "\n", "quantization_config", "=", "None", ",", "overwrite", "=", "True", ",", "debug", "=", "False", ",", "head_name", "=", "None", ",", "\n", "**", "tuner_kwargs", ")", ":", "\n", "\n", "    ", "if", "not", "metrics", ":", "\n", "      ", "metrics", "=", "[", "]", "\n", "\n", "", "if", "not", "custom_objects", ":", "\n", "      ", "custom_objects", "=", "{", "}", "\n", "\n", "# goal: { \"type\": [\"bits\", \"energy\"], \"params\": {...} }", "\n", "# For type == \"bits\":", "\n", "#   delta_p: increment (in %) of the accuracy if trial is smaller.", "\n", "#   delta_n: decrement (in %) of the accuracy if trial is bigger.", "\n", "#   rate: rate of decrease/increase in model size in terms of bits.", "\n", "#   input_bits; size of input tensors.", "\n", "#   output_bits; size of output tensors.", "\n", "#   stress: parameter to reduce reference size to force tuner to", "\n", "#     choose smaller models.", "\n", "#   config: configuration on what to compute for each layer", "\n", "#     minimum configuration is { \"default\": [\"parameters\", \"activations\"] }", "\n", "\n", "# use simplest one - number of bits", "\n", "", "if", "not", "goal", ":", "\n", "      ", "goal", "=", "{", "\n", "\"type\"", ":", "\"bits\"", ",", "\n", "\"params\"", ":", "{", "\n", "\"delta_p\"", ":", "8.0", ",", "\n", "\"delta_n\"", ":", "8.0", ",", "\n", "\"rate\"", ":", "2.0", ",", "\n", "\"stress\"", ":", "1.0", ",", "\n", "\"input_bits\"", ":", "8", ",", "\n", "\"output_bits\"", ":", "8", ",", "\n", "\"ref_bits\"", ":", "8", ",", "\n", "\"config\"", ":", "{", "\n", "\"default\"", ":", "[", "\"parameters\"", ",", "\"activations\"", "]", "\n", "}", "\n", "}", "\n", "}", "\n", "\n", "", "self", ".", "target", "=", "forgiving_factor", "[", "goal", "[", "\"type\"", "]", "]", "(", "**", "goal", "[", "\"params\"", "]", ")", "\n", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "metrics", "=", "metrics", "\n", "self", ".", "custom_objects", "=", "custom_objects", "\n", "self", ".", "mode", "=", "mode", "\n", "self", ".", "transfer_weights", "=", "transfer_weights", "\n", "self", ".", "activation_bits", "=", "activation_bits", "\n", "self", ".", "limit", "=", "limit", "\n", "self", ".", "tune_filters", "=", "tune_filters", "\n", "self", ".", "tune_filters_exceptions", "=", "tune_filters_exceptions", "\n", "self", ".", "layer_indexes", "=", "layer_indexes", "\n", "self", ".", "learning_rate_optimizer", "=", "learning_rate_optimizer", "\n", "self", ".", "blocks", "=", "blocks", "\n", "self", ".", "schedule_block", "=", "schedule_block", "\n", "self", ".", "quantization_config", "=", "quantization_config", "\n", "self", ".", "tuner_kwargs", "=", "tuner_kwargs", "\n", "self", ".", "debug", "=", "debug", "\n", "self", ".", "head_name", "=", "head_name", "\n", "\n", "self", ".", "autoqk", "=", "None", "\n", "self", ".", "learning_rate", "=", "model", ".", "optimizer", ".", "lr", ".", "numpy", "(", ")", "\n", "self", ".", "overwrite", "=", "overwrite", "\n", "\n", "assert", "self", ".", "schedule_block", "in", "[", "\"sequential\"", ",", "\"cost\"", "]", "\n", "\n", "# right now we create unique results directory", "\n", "idx", "=", "0", "\n", "name", "=", "output_dir", "\n", "if", "self", ".", "overwrite", ":", "\n", "      ", "while", "os", ".", "path", ".", "exists", "(", "name", ")", ":", "\n", "        ", "idx", "+=", "1", "\n", "name", "=", "output_dir", "+", "\"_\"", "+", "str", "(", "idx", ")", "\n", "", "", "output_dir", "=", "name", "\n", "self", ".", "output_dir", "=", "output_dir", "\n", "self", ".", "next_block", "=", "self", ".", "get_next_block", "(", "overwrite", ")", "\n", "if", "self", ".", "next_block", ">", "0", ":", "\n", "      ", "strategy", "=", "self", ".", "tuner_kwargs", ".", "get", "(", "\"distribution_strategy\"", ",", "None", ")", "\n", "if", "strategy", ":", "\n", "        ", "with", "strategy", ".", "scope", "(", ")", ":", "\n", "          ", "self", ".", "model", "=", "tf", ".", "keras", ".", "models", ".", "load_model", "(", "\n", "os", ".", "path", ".", "join", "(", "\n", "self", ".", "output_dir", ",", "\"model_block_\"", "+", "str", "(", "self", ".", "next_block", "-", "1", ")", ")", ",", "\n", "custom_objects", "=", "self", ".", "custom_objects", ")", "\n", "", "", "else", ":", "\n", "        ", "self", ".", "model", "=", "tf", ".", "keras", ".", "models", ".", "load_model", "(", "\n", "os", ".", "path", ".", "join", "(", "\n", "self", ".", "output_dir", ",", "\"model_block_\"", "+", "str", "(", "self", ".", "next_block", "-", "1", ")", ")", ",", "\n", "custom_objects", "=", "self", ".", "custom_objects", ")", "\n", "", "print", "(", "\"Load model completed\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.get_next_block": [[1115, 1128], ["json.loads", "tensorflow.io.gfile.GFile", "tensorflow.io.gfile.GFile", "f.read", "os.path.join"], "methods", ["None"], ["", "", "def", "get_next_block", "(", "self", ",", "overwrite", ")", ":", "\n", "    ", "\"\"\"Get the next block id to be worked on.\"\"\"", "\n", "if", "overwrite", ":", "\n", "      ", "return", "0", "\n", "", "else", ":", "\n", "      ", "try", ":", "\n", "        ", "with", "tf", ".", "io", ".", "gfile", ".", "GFile", "(", "os", ".", "path", ".", "join", "(", "self", ".", "output_dir", ",", "\"scheduler.json\"", ")", ",", "\n", "\"r\"", ")", "as", "f", ":", "\n", "          ", "scheduler_json", "=", "f", ".", "read", "(", ")", "\n", "", "scheduler", "=", "json", ".", "loads", "(", "scheduler_json", ")", "\n", "return", "scheduler", "[", "\"next_block\"", "]", "\n", "", "except", ":", "# pylint: disable=bare-except", "\n", "        ", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.get_limit": [[1129, 1159], ["collections.defaultdict", "model.get_layer", "limit.get", "re.match", "new_pattern[].append"], "methods", ["None"], ["", "", "", "def", "get_limit", "(", "self", ",", "model", ",", "pattern", ")", ":", "\n", "    ", "\"\"\"Apply patterned group to limit to obtain new limit set.\"\"\"", "\n", "limit", "=", "self", ".", "limit", "\n", "new_limit", "=", "{", "}", "\n", "new_pattern", "=", "collections", ".", "defaultdict", "(", "list", ")", "\n", "\n", "for", "layer_name", "in", "self", ".", "grouped_patterns", "[", "pattern", "]", ":", "\n", "      ", "layer", "=", "model", ".", "get_layer", "(", "layer_name", ")", "\n", "layer_class_name", "=", "layer", ".", "__class__", ".", "__name__", "\n", "\n", "target_quantizers", "=", "limit", ".", "get", "(", "layer_class_name", ",", "-", "1", ")", "\n", "for", "limit_pattern", "in", "limit", ":", "\n", "        ", "if", "re", ".", "match", "(", "limit_pattern", ",", "layer_name", ")", ":", "\n", "          ", "target_quantizers", "=", "limit", "[", "limit_pattern", "]", "\n", "new_pattern", "[", "limit_pattern", "]", ".", "append", "(", "layer_name", ")", "\n", "layer_name", "=", "limit_pattern", "\n", "break", "\n", "", "", "if", "target_quantizers", "!=", "-", "1", ":", "\n", "        ", "new_limit", "[", "layer_name", "]", "=", "target_quantizers", "\n", "\n", "", "", "for", "key", "in", "new_pattern", ":", "\n", "# grouped pattern in regex need to be ^(word1|word2|...)$ instead of", "\n", "# ^word1|word2|...$; otherwise it cause non-exact match,", "\n", "# e.g., fc.*_0 and fc.*_0_relu were miss-matched", "\n", "      ", "new_key", "=", "\"^\"", "+", "\"(\"", "+", "\"|\"", ".", "join", "(", "new_pattern", "[", "key", "]", ")", "+", "\")\"", "+", "\"$\"", "\n", "new_limit", "[", "new_key", "]", "=", "new_limit", "[", "key", "]", "\n", "if", "new_key", "!=", "key", ":", "\n", "        ", "del", "new_limit", "[", "key", "]", "\n", "\n", "", "", "return", "new_limit", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit": [[1160, 1262], ["autoqkeras_internal.AutoQKerasScheduler.compute_block_costs", "autoqkeras_internal.AutoQKerasScheduler.tuner_kwargs.get", "autoqkeras_internal.AutoQKerasScheduler.model.optimizer.lr.numpy", "enumerate", "float", "autoqkeras_internal.AutoQKerasScheduler.retrieve_max_block", "print", "autoqkeras_internal.AutoQKerasScheduler.tuner_kwargs.get", "autoqkeras_internal.AutoQKerasScheduler.get_limit", "print", "autoqkeras_internal.AutoQKeras", "autoqkeras_internal.AutoQKerasScheduler.autoqk.fit", "autoqkeras_internal.AutoQKerasScheduler.autoqk.tuner.results_summary", "autoqkeras_internal.AutoQKerasScheduler.history.append", "autoqkeras_internal.AutoQKerasScheduler.autoqk.get_best_model", "autoqkeras_internal.AutoQKerasScheduler.optimizer.lr.numpy", "autoqkeras_internal.AutoQKerasScheduler.compile", "autoqkeras_internal.AutoQKerasScheduler.save", "autoqkeras_internal.AutoQKerasScheduler.get_layer", "int", "print", "autoqkeras_internal.AutoQKerasScheduler.autoqk.history", "str", "tensorflow.io.gfile.GFile", "tensorflow.io.gfile.GFile", "f.write", "print", "max", "os.path.join", "json.dumps", "str"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.compute_block_costs", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.retrieve_max_block", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.get_limit", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.fit", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.get_best_model", "home.repos.pwc.inspect_result.google_qkeras.random_forest.random_forest.RandomForest.save", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKeras.history", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "def", "fit", "(", "self", ",", "*", "fit_args", ",", "**", "fit_kwargs", ")", ":", "\n", "    ", "\"\"\"Invokes tuner fit algorithm.\"\"\"", "\n", "\n", "self", ".", "history", "=", "[", "]", "\n", "self", ".", "compute_block_costs", "(", "self", ".", "blocks", ",", "self", ".", "model", ")", "\n", "\n", "if", "self", ".", "tuner_kwargs", ".", "get", "(", "\"max_trials\"", ",", "None", ")", ":", "\n", "      ", "max_trials", "=", "float", "(", "self", ".", "tuner_kwargs", "[", "\"max_trials\"", "]", ")", "\n", "\n", "", "lr", "=", "self", ".", "model", ".", "optimizer", ".", "lr", ".", "numpy", "(", ")", "\n", "\n", "model", "=", "self", ".", "model", "\n", "\n", "frozen_layers", "=", "[", "]", "\n", "\n", "for", "i", ",", "(", "pattern", ",", "cost", ")", "in", "enumerate", "(", "self", ".", "retrieve_max_block", "(", ")", ")", ":", "\n", "\n", "# now create new limit pattern", "\n", "      ", "if", "not", "self", ".", "overwrite", ":", "\n", "        ", "if", "i", "<", "self", ".", "next_block", ":", "\n", "          ", "print", "(", "\"Resume tuning. Skipping block \"", ",", "i", ")", "\n", "continue", "\n", "\n", "", "", "print", "(", "\"... block cost: {:.0f} / {:.0f}\"", ".", "format", "(", "cost", ",", "self", ".", "reference_size", ")", ")", "\n", "\n", "if", "self", ".", "tuner_kwargs", ".", "get", "(", "\"max_trials\"", ",", "None", ")", ":", "\n", "        ", "self", ".", "tuner_kwargs", "[", "\"max_trials\"", "]", "=", "int", "(", "\n", "max", "(", "10", ",", "max_trials", "*", "cost", "/", "self", ".", "reference_size", ")", ")", "\n", "print", "(", "\"... adjusting max_trials for this block to {}\"", ".", "format", "(", "\n", "self", ".", "tuner_kwargs", "[", "\"max_trials\"", "]", ")", ")", "\n", "\n", "", "limit", "=", "self", ".", "get_limit", "(", "model", ",", "pattern", ")", "\n", "new_frozen_layers", "=", "self", ".", "grouped_patterns", "[", "pattern", "]", "\n", "\n", "# if dictionary is empty we did not match anything.", "\n", "# we have a bug in the patterns specified by the", "\n", "# user.", "\n", "\n", "assert", "limit", "\n", "\n", "print", "(", "\"Pattern {} is : {}\"", ".", "format", "(", "i", ",", "limit", ")", ")", "\n", "\n", "if", "self", ".", "debug", ":", "\n", "        ", "frozen_layers", "=", "frozen_layers", "+", "new_frozen_layers", "\n", "continue", "\n", "\n", "", "self", ".", "autoqk", "=", "AutoQKeras", "(", "\n", "model", ",", "self", ".", "metrics", ",", "\n", "custom_objects", "=", "self", ".", "custom_objects", ",", "\n", "goal", "=", "self", ".", "target", ",", "\n", "output_dir", "=", "self", ".", "output_dir", "+", "\"/\"", "+", "str", "(", "i", ")", ",", "\n", "mode", "=", "self", ".", "mode", ",", "\n", "transfer_weights", "=", "self", ".", "transfer_weights", ",", "\n", "frozen_layers", "=", "frozen_layers", ",", "\n", "activation_bits", "=", "self", ".", "activation_bits", ",", "\n", "limit", "=", "limit", ",", "\n", "tune_filters", "=", "self", ".", "tune_filters", ",", "\n", "tune_filters_exceptions", "=", "self", ".", "tune_filters_exceptions", ",", "\n", "layer_indexes", "=", "self", ".", "layer_indexes", ",", "\n", "learning_rate_optimizer", "=", "self", ".", "learning_rate_optimizer", ",", "\n", "quantization_config", "=", "self", ".", "quantization_config", ",", "\n", "overwrite", "=", "self", ".", "overwrite", ",", "\n", "head_name", "=", "self", ".", "head_name", ",", "\n", "**", "self", ".", "tuner_kwargs", ")", "\n", "\n", "self", ".", "autoqk", ".", "fit", "(", "*", "fit_args", ",", "**", "fit_kwargs", ")", "\n", "\n", "self", ".", "autoqk", ".", "tuner", ".", "results_summary", "(", ")", "\n", "\n", "self", ".", "history", ".", "append", "(", "self", ".", "autoqk", ".", "history", "(", ")", ")", "\n", "\n", "model", "=", "self", ".", "autoqk", ".", "get_best_model", "(", ")", "\n", "self", ".", "learning_rate", "=", "model", ".", "optimizer", ".", "lr", ".", "numpy", "(", ")", "\n", "\n", "# restore learning rate", "\n", "# this is just a placeholder for the optimizer.", "\n", "\n", "model", ".", "compile", "(", "\n", "model", ".", "optimizer", ",", "\n", "loss", "=", "self", ".", "model", ".", "loss", ",", "\n", "metrics", "=", "self", ".", "model", ".", "metrics", ")", "\n", "\n", "frozen_layers", "=", "frozen_layers", "+", "new_frozen_layers", "\n", "\n", "filename", "=", "self", ".", "output_dir", "+", "\"/model_block_\"", "+", "str", "(", "i", ")", "\n", "model", ".", "save", "(", "filename", ")", "\n", "self", ".", "next_block", "=", "i", "+", "1", "\n", "\n", "# update scheduler json", "\n", "with", "tf", ".", "io", ".", "gfile", ".", "GFile", "(", "os", ".", "path", ".", "join", "(", "self", ".", "output_dir", ",", "\"scheduler.json\"", ")", ",", "\n", "\"w\"", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "json", ".", "dumps", "(", "{", "\"next_block\"", ":", "self", ".", "next_block", "}", ")", ")", "\n", "\n", "", "", "if", "self", ".", "debug", ":", "\n", "      ", "return", "\n", "\n", "", "self", ".", "best_model", "=", "model", "\n", "\n", "# make all layers trainable again", "\n", "for", "layer_name", "in", "frozen_layers", ":", "\n", "      ", "layer", "=", "model", ".", "get_layer", "(", "layer_name", ")", "\n", "layer", ".", "trainable", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.compute_block_costs": [[1263, 1300], ["autoqkeras_internal.AutoQKerasScheduler.target.get_reference", "autoqkeras_internal.AutoQKerasScheduler.target.get_reference_stats", "enumerate", "autoqkeras_internal.AutoQKerasScheduler.costs.append", "sorted", "re.match", "groups[].append"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits.get_reference", "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits.get_reference_stats"], ["", "", "def", "compute_block_costs", "(", "self", ",", "patterns", ",", "model", ")", ":", "\n", "    ", "\"\"\"Computes costs for each block.\"\"\"", "\n", "\n", "# get block cost for original model", "\n", "self", ".", "reference_size", "=", "self", ".", "target", ".", "get_reference", "(", "model", ")", "\n", "self", ".", "model_size", "=", "self", ".", "target", ".", "get_reference_stats", "(", ")", "\n", "\n", "# first group layers into the patterns", "\n", "\n", "groups", "=", "{", "pattern", ":", "[", "]", "for", "pattern", "in", "patterns", "}", "\n", "\n", "for", "layer_id", ",", "layer", "in", "enumerate", "(", "model", ".", "layers", ")", ":", "\n", "      ", "if", "(", "\n", "self", ".", "layer_indexes", "is", "not", "None", "and", "\n", "layer_id", "not", "in", "self", ".", "layer_indexes", "\n", ")", ":", "\n", "        ", "continue", "\n", "\n", "", "for", "pattern", "in", "groups", ":", "\n", "        ", "if", "re", ".", "match", "(", "pattern", ",", "layer", ".", "name", ")", ":", "\n", "          ", "groups", "[", "pattern", "]", ".", "append", "(", "layer", ".", "name", ")", "\n", "\n", "", "", "", "self", ".", "grouped_patterns", "=", "groups", "\n", "\n", "# now compute cost for each group", "\n", "\n", "self", ".", "costs", "=", "[", "]", "\n", "for", "pattern", "in", "patterns", ":", "# self.grouped_patterns:", "\n", "      ", "total", "=", "0", "\n", "for", "layer", "in", "self", ".", "grouped_patterns", "[", "pattern", "]", ":", "\n", "        ", "if", "layer", "in", "self", ".", "model_size", ":", "\n", "          ", "total", "+=", "self", ".", "model_size", "[", "layer", "]", "[", "\"total\"", "]", "\n", "", "", "self", ".", "costs", ".", "append", "(", "(", "pattern", ",", "total", ")", ")", "\n", "\n", "# the costs will be sorted by the total cost of the group", "\n", "", "if", "self", ".", "schedule_block", "==", "\"cost\"", ":", "\n", "      ", "self", ".", "costs", "=", "sorted", "(", "self", ".", "costs", ",", "key", "=", "lambda", "cost_tuple", ":", "-", "cost_tuple", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.retrieve_max_block": [[1301, 1304], ["None"], "methods", ["None"], ["", "", "def", "retrieve_max_block", "(", "self", ")", ":", "\n", "    ", "for", "cost", "in", "self", ".", "costs", ":", "\n", "      ", "yield", "cost", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.get_history": [[1305, 1308], ["None"], "methods", ["None"], ["", "", "def", "get_history", "(", "self", ")", ":", "\n", "    ", "\"\"\"Returns the history of the model search.\"\"\"", "\n", "return", "self", ".", "history", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.get_best_model": [[1309, 1320], ["autoqkeras_internal.AutoQKerasScheduler.autoqk.hypermodel.target.print_stats", "qkeras.autoqkeras.utils.print_qmodel_summary"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits.print_stats", "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.utils.print_qmodel_summary"], ["", "def", "get_best_model", "(", "self", ")", ":", "\n", "    ", "\"\"\"Returns the best model.\"\"\"", "\n", "\n", "# check if we have run fit first.", "\n", "if", "not", "self", ".", "autoqk", ":", "\n", "      ", "return", "None", "\n", "\n", "", "self", ".", "autoqk", ".", "hypermodel", ".", "target", ".", "print_stats", "(", ")", "\n", "print_qmodel_summary", "(", "self", ".", "best_model", ")", "\n", "\n", "return", "self", ".", "best_model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.autoqkeras_internal.AutoQKerasScheduler.get_learning_rate": [[1321, 1323], ["None"], "methods", ["None"], ["", "def", "get_learning_rate", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "learning_rate", "\n", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.utils.print_qmodel_summary": [[25, 67], ["print", "print", "hasattr", "print", "layer.get_quantizers", "range", "hasattr", "print", "str", "print", "len", "print", "print", "print", "print", "print", "print", "print", "print", "hasattr", "str", "str", "tensorflow.keras.backend.eval"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["    ", "return", "0", "\n", "", "elif", "padding", "==", "\"same\"", ":", "\n", "    ", "return", "kernel", "//", "2", "\n", "", "elif", "padding", "==", "\"full\"", ":", "\n", "    ", "return", "kernel", "-", "1", "\n", "\n", "", "raise", "ValueError", "(", "\"accepted paddings are 'valid', 'same' or 'full', found \"", "+", "\n", "padding", ")", "\n", "\n", "\n", "", "def", "get_quantized_bits_dict", "(", "bits", ",", "ibits", ",", "sign", "=", "False", ",", "mode", "=", "\"bin\"", ")", ":", "\n", "  ", "\"\"\"Returns map from floating values to bit encoding.\"\"\"", "\n", "\n", "o_dict", "=", "{", "}", "\n", "\n", "n_bits", "=", "bits", "\n", "\n", "for", "b", "in", "range", "(", "1", "<<", "(", "bits", "-", "sign", ")", ")", ":", "\n", "    ", "v", "=", "(", "1.0", "*", "b", ")", "*", "(", "1", "<<", "ibits", ")", "/", "(", "1", "<<", "bits", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "      ", "b_str", "=", "bin", "(", "b", ")", "[", "2", ":", "]", "\n", "b_str", "=", "\"0\"", "*", "(", "n_bits", "-", "len", "(", "b_str", ")", ")", "+", "b_str", "\n", "", "else", ":", "# mode == \"dec\":", "\n", "      ", "b_str", "=", "str", "(", "b", ")", "\n", "\n", "", "o_dict", "[", "v", "]", "=", "b_str", "\n", "\n", "if", "b", ">", "0", "and", "sign", ":", "\n", "      ", "if", "mode", "==", "\"bin\"", ":", "\n", "        ", "b_str", "=", "bin", "(", "-", "b", "&", "(", "(", "1", "<<", "n_bits", ")", "-", "1", ")", ")", "[", "2", ":", "]", "\n", "", "else", ":", "# mode == \"dec\"", "\n", "        ", "b_str", "=", "str", "(", "-", "b", ")", "\n", "\n", "", "o_dict", "[", "-", "v", "]", "=", "b_str", "\n", "\n", "", "", "if", "sign", ":", "\n", "    ", "v", "=", "(", "1.0", "*", "(", "1", "<<", "(", "bits", "-", "sign", ")", ")", ")", "*", "(", "1", "<<", "ibits", ")", "/", "(", "1", "<<", "bits", ")", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "      ", "b_str", "=", "bin", "(", "-", "(", "1", "<<", "(", "bits", "-", "sign", ")", ")", "&", "(", "(", "1", "<<", "bits", ")", "-", "1", ")", ")", "[", "2", ":", "]", "\n", "", "else", ":", "\n", "      ", "b_str", "=", "str", "(", "-", "(", "1", "<<", "(", "bits", "-", "sign", ")", ")", ")", "\n", "", "o_dict", "[", "-", "v", "]", "=", "b_str", "\n", "", "return", "o_dict", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.utils.get_quantization_dictionary": [[69, 78], ["hasattr", "layer.get_quantization_config"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantization_config"], ["\n", "", "def", "get_quantized_po2_dict", "(", "\n", "bits", ",", "max_exp", ",", "sign", "=", "False", ",", "make_smaller_zero", "=", "True", ",", "mode", "=", "\"bin\"", ")", ":", "\n", "  ", "\"\"\"Returns map from floating values to bit encoding.\"\"\"", "\n", "\n", "# if make_smaller_zero we will make sure smaller number is 000...0", "\n", "\n", "# mode = \"bin\" |-> make_smaller_zero", "\n", "\n", "assert", "mode", "!=", "\"bin\"", "or", "make_smaller_zero", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.autoqkeras.utils.save_quantization_dict": [[80, 88], ["utils.get_quantization_dictionary", "json.dumps", "open", "open.write", "open.close"], "function", ["home.repos.pwc.inspect_result.google_qkeras.autoqkeras.utils.get_quantization_dictionary"], ["o_dict", "=", "{", "}", "\n", "\n", "if", "max_exp", ">", "0", ":", "\n", "    ", "v", "=", "1.0", "\n", "if", "mode", "==", "\"bin\"", ":", "\n", "      ", "b_str", "=", "\"0\"", "*", "bits", "\n", "", "else", ":", "\n", "      ", "b_str", "=", "\"1\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.run.get_data.get_data": [[24, 68], ["tensorflow_datasets.load", "tensorflow_datasets.load", "tensorflow_datasets.as_numpy", "tensorflow_datasets.as_numpy", "numpy.mean", "tensorflow.keras.utils.to_categorical", "tensorflow.keras.utils.to_categorical", "print", "print", "dataset[].astype", "dataset[].astype", "len", "x_train.reshape.reshape", "x_test.reshape.reshape", "numpy.max", "numpy.arange", "numpy.random.shuffle", "numpy.arange", "numpy.random.shuffle"], "function", ["home.repos.pwc.inspect_result.google_qkeras.table.utils.load", "home.repos.pwc.inspect_result.google_qkeras.table.utils.load", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["def", "get_data", "(", "dataset_name", ",", "fast", "=", "False", ")", ":", "\n", "  ", "\"\"\"Returns dataset from tfds.\"\"\"", "\n", "ds_train", "=", "tfds", ".", "load", "(", "name", "=", "dataset_name", ",", "split", "=", "\"train\"", ",", "batch_size", "=", "-", "1", ")", "\n", "ds_test", "=", "tfds", ".", "load", "(", "name", "=", "dataset_name", ",", "split", "=", "\"test\"", ",", "batch_size", "=", "-", "1", ")", "\n", "\n", "dataset", "=", "tfds", ".", "as_numpy", "(", "ds_train", ")", "\n", "x_train", ",", "y_train", "=", "dataset", "[", "\"image\"", "]", ".", "astype", "(", "np", ".", "float32", ")", ",", "dataset", "[", "\"label\"", "]", "\n", "\n", "dataset", "=", "tfds", ".", "as_numpy", "(", "ds_test", ")", "\n", "x_test", ",", "y_test", "=", "dataset", "[", "\"image\"", "]", ".", "astype", "(", "np", ".", "float32", ")", ",", "dataset", "[", "\"label\"", "]", "\n", "\n", "if", "len", "(", "x_train", ".", "shape", ")", "==", "3", ":", "\n", "    ", "x_train", "=", "x_train", ".", "reshape", "(", "x_train", ".", "shape", "+", "(", "1", ",", ")", ")", "\n", "x_test", "=", "x_test", ".", "reshape", "(", "x_test", ".", "shape", "+", "(", "1", ",", ")", ")", "\n", "\n", "", "x_train", "/=", "256.0", "\n", "x_test", "/=", "256.0", "\n", "\n", "x_mean", "=", "np", ".", "mean", "(", "x_train", ",", "axis", "=", "0", ")", "\n", "\n", "x_train", "-=", "x_mean", "\n", "x_test", "-=", "x_mean", "\n", "\n", "nb_classes", "=", "np", ".", "max", "(", "y_train", ")", "+", "1", "\n", "y_train", "=", "to_categorical", "(", "y_train", ",", "nb_classes", ")", "\n", "y_test", "=", "to_categorical", "(", "y_test", ",", "nb_classes", ")", "\n", "\n", "print", "(", "x_train", ".", "shape", "[", "0", "]", ",", "\"train samples\"", ")", "\n", "print", "(", "x_test", ".", "shape", "[", "0", "]", ",", "\"test samples\"", ")", "\n", "\n", "if", "fast", ":", "\n", "    ", "i_train", "=", "np", ".", "arange", "(", "x_train", ".", "shape", "[", "0", "]", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "i_train", ")", "\n", "i_test", "=", "np", ".", "arange", "(", "x_test", ".", "shape", "[", "0", "]", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "i_test", ")", "\n", "\n", "s_x_train", "=", "x_train", "[", "i_train", "[", "0", ":", "fast", "]", "]", "\n", "s_y_train", "=", "y_train", "[", "i_train", "[", "0", ":", "fast", "]", "]", "\n", "s_x_test", "=", "x_test", "[", "i_test", "[", "0", ":", "fast", "]", "]", "\n", "s_y_test", "=", "y_test", "[", "i_test", "[", "0", ":", "fast", "]", "]", "\n", "return", "(", "(", "s_x_train", ",", "s_y_train", ")", ",", "(", "x_train", ",", "y_train", ")", ",", "(", "s_x_test", ",", "s_y_test", ")", ",", "\n", "(", "x_test", ",", "y_test", ")", ")", "\n", "", "else", ":", "\n", "    ", "return", "(", "x_train", ",", "y_train", ")", ",", "(", "x_test", ",", "y_test", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.run.get_model.get_model": [[20, 83], ["ConvBlockNetwork().build.summary", "qkeras.autoqkeras.examples.run.networks.ConvBlockNetwork().build", "qkeras.autoqkeras.examples.run.networks.ConvBlockNetwork().build", "qkeras.autoqkeras.examples.run.networks.ConvBlockNetwork", "qkeras.autoqkeras.examples.run.networks.ConvBlockNetwork().build", "qkeras.autoqkeras.examples.run.networks.ConvBlockNetwork", "qkeras.autoqkeras.examples.run.networks.ConvBlockNetwork().build", "qkeras.autoqkeras.examples.run.networks.ConvBlockNetwork", "qkeras.autoqkeras.examples.run.networks.ConvBlockNetwork"], "function", ["home.repos.pwc.inspect_result.google_qkeras.networks.conv_block.ConvBlockNetwork.build", "home.repos.pwc.inspect_result.google_qkeras.networks.conv_block.ConvBlockNetwork.build", "home.repos.pwc.inspect_result.google_qkeras.networks.conv_block.ConvBlockNetwork.build", "home.repos.pwc.inspect_result.google_qkeras.networks.conv_block.ConvBlockNetwork.build"], ["def", "get_model", "(", "dataset", ")", ":", "\n", "  ", "\"\"\"Returns a model for the demo of AutoQKeras.\"\"\"", "\n", "if", "dataset", "==", "\"mnist\"", ":", "\n", "    ", "model", "=", "ConvBlockNetwork", "(", "\n", "shape", "=", "(", "28", ",", "28", ",", "1", ")", ",", "\n", "nb_classes", "=", "10", ",", "\n", "kernel_size", "=", "3", ",", "\n", "filters", "=", "[", "16", ",", "32", ",", "48", ",", "64", ",", "128", "]", ",", "\n", "dropout_rate", "=", "0.2", ",", "\n", "with_maxpooling", "=", "False", ",", "\n", "with_batchnorm", "=", "True", ",", "\n", "kernel_initializer", "=", "\"he_uniform\"", ",", "\n", "bias_initializer", "=", "\"zeros\"", ",", "\n", ")", ".", "build", "(", ")", "\n", "\n", "", "elif", "dataset", "==", "\"fashion_mnist\"", ":", "\n", "    ", "model", "=", "ConvBlockNetwork", "(", "\n", "shape", "=", "(", "28", ",", "28", ",", "1", ")", ",", "\n", "nb_classes", "=", "10", ",", "\n", "kernel_size", "=", "3", ",", "\n", "filters", "=", "[", "16", ",", "[", "32", "]", "*", "3", ",", "[", "64", "]", "*", "3", "]", ",", "\n", "dropout_rate", "=", "0.2", ",", "\n", "with_maxpooling", "=", "True", ",", "\n", "with_batchnorm", "=", "True", ",", "\n", "use_separable", "=", "\"mobilenet\"", ",", "\n", "kernel_initializer", "=", "\"he_uniform\"", ",", "\n", "bias_initializer", "=", "\"zeros\"", ",", "\n", "use_xnornet_trick", "=", "True", "\n", ")", ".", "build", "(", ")", "\n", "\n", "", "elif", "dataset", "==", "\"cifar10\"", ":", "\n", "    ", "model", "=", "ConvBlockNetwork", "(", "\n", "shape", "=", "(", "32", ",", "32", ",", "3", ")", ",", "\n", "nb_classes", "=", "10", ",", "\n", "kernel_size", "=", "3", ",", "\n", "filters", "=", "[", "16", ",", "[", "32", "]", "*", "3", ",", "[", "64", "]", "*", "3", ",", "[", "128", "]", "*", "3", "]", ",", "\n", "dropout_rate", "=", "0.2", ",", "\n", "with_maxpooling", "=", "True", ",", "\n", "with_batchnorm", "=", "True", ",", "\n", "use_separable", "=", "\"mobilenet\"", ",", "\n", "kernel_initializer", "=", "\"he_uniform\"", ",", "\n", "bias_initializer", "=", "\"zeros\"", ",", "\n", "use_xnornet_trick", "=", "True", "\n", ")", ".", "build", "(", ")", "\n", "\n", "", "elif", "dataset", "==", "\"cifar100\"", ":", "\n", "    ", "model", "=", "ConvBlockNetwork", "(", "\n", "shape", "=", "(", "32", ",", "32", ",", "3", ")", ",", "\n", "nb_classes", "=", "100", ",", "\n", "kernel_size", "=", "3", ",", "\n", "filters", "=", "[", "16", ",", "[", "32", "]", "*", "3", ",", "[", "64", "]", "*", "3", ",", "[", "128", "]", "*", "3", ",", "[", "256", "]", "*", "3", "]", ",", "\n", "dropout_rate", "=", "0.2", ",", "\n", "with_maxpooling", "=", "True", ",", "\n", "with_batchnorm", "=", "True", ",", "\n", "use_separable", "=", "\"mobilenet\"", ",", "\n", "kernel_initializer", "=", "\"he_uniform\"", ",", "\n", "bias_initializer", "=", "\"zeros\"", ",", "\n", "use_xnornet_trick", "=", "True", "\n", ")", ".", "build", "(", ")", "\n", "\n", "", "model", ".", "summary", "(", ")", "\n", "\n", "return", "model", "\n", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.networks.conv_block.ConvBlockNetwork.__init__": [[37, 81], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "shape", ",", "\n", "nb_classes", ",", "\n", "kernel_size", ",", "\n", "filters", ",", "\n", "dropout_rate", "=", "0.0", ",", "\n", "with_maxpooling", "=", "True", ",", "\n", "with_batchnorm", "=", "True", ",", "\n", "kernel_initializer", "=", "\"he_normal\"", ",", "\n", "bias_initializer", "=", "\"zeros\"", ",", "\n", "use_separable", "=", "False", ",", "\n", "use_xnornet_trick", "=", "False", "\n", ")", ":", "\n", "    ", "\"\"\"Creates class.\n\n    Args:\n      shape: shape of inputs.\n      nb_classes: number of output classes.\n      kernel_size: kernel_size of network.\n      filters: sizes of filters (if entry is a list, we create a block).\n      dropout_rate: dropout rate if > 0.\n      with_maxpooling: if true, use maxpooling.\n      with_batchnorm: with BatchNormalization.\n      kernel_initializer: kernel_initializer.\n      bias_initializer: bias and beta initializer.\n      use_separable: if \"dsp\", do conv's 1x3 + 3x1. If \"mobilenet\",\n        use MobileNet separable convolution. If False or \"none\", perform single\n        conv layer.\n      use_xnornet_trick: use bn+act after max pool to enable binary\n        to avoid saturation to largest value.\n    \"\"\"", "\n", "\n", "self", ".", "shape", "=", "shape", "\n", "self", ".", "nb_classes", "=", "nb_classes", "\n", "self", ".", "kernel_size", "=", "kernel_size", "\n", "self", ".", "filters", "=", "filters", "\n", "self", ".", "dropout_rate", "=", "dropout_rate", "\n", "self", ".", "with_maxpooling", "=", "with_maxpooling", "\n", "self", ".", "with_batchnorm", "=", "with_batchnorm", "\n", "self", ".", "kernel_initializer", "=", "kernel_initializer", "\n", "self", ".", "bias_initializer", "=", "bias_initializer", "\n", "self", ".", "use_separable", "=", "use_separable", "\n", "self", ".", "use_xnornet_trick", "=", "use_xnornet_trick", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.networks.conv_block.ConvBlockNetwork.build": [[82, 178], ["tensorflow.keras.layers.Input", "range", "tensorflow.keras.models.Model", "len", "range", "len", "isinstance", "len", "enumerate", "tensorflow.keras.layers.Input.shape.as_list", "tensorflow.keras.layers.Flatten", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Activation", "tensorflow.keras.layers.Conv2D", "tensorflow.keras.layers.Activation", "tensorflow.keras.layers.Flatten", "str", "len", "tensorflow.keras.layers.MaxPooling2D", "tensorflow.keras.layers.Dropout", "tensorflow.keras.layers.Conv2D", "tensorflow.keras.layers.BatchNormalization", "tensorflow.keras.layers.Activation", "tensorflow.keras.layers.DepthwiseConv2D", "tensorflow.keras.layers.Activation", "tensorflow.keras.layers.Activation", "str", "len", "len", "tensorflow.keras.layers.BatchNormalization", "tensorflow.keras.layers.BatchNormalization", "len", "len", "str", "str"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range"], ["", "def", "build", "(", "self", ")", ":", "\n", "    ", "\"\"\"Builds model.\"\"\"", "\n", "x", "=", "x_in", "=", "Input", "(", "self", ".", "shape", ",", "name", "=", "\"input\"", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "filters", ")", ")", ":", "\n", "      ", "if", "len", "(", "self", ".", "filters", ")", ">", "1", ":", "\n", "        ", "name_suffix_list", "=", "[", "str", "(", "i", ")", "]", "\n", "", "else", ":", "\n", "        ", "name_suffix_list", "=", "[", "]", "\n", "", "if", "not", "isinstance", "(", "self", ".", "filters", "[", "i", "]", ",", "list", ")", ":", "\n", "        ", "filters", "=", "[", "self", ".", "filters", "[", "i", "]", "]", "\n", "", "else", ":", "\n", "        ", "filters", "=", "self", ".", "filters", "[", "i", "]", "\n", "", "for", "j", "in", "range", "(", "len", "(", "filters", ")", ")", ":", "\n", "        ", "if", "len", "(", "filters", ")", ">", "1", ":", "\n", "          ", "name_suffix", "=", "\"_\"", ".", "join", "(", "name_suffix_list", "+", "[", "str", "(", "j", ")", "]", ")", "\n", "", "else", ":", "\n", "          ", "name_suffix", "=", "\"_\"", ".", "join", "(", "name_suffix_list", ")", "\n", "", "if", "self", ".", "use_separable", "==", "\"dsp\"", ":", "\n", "          ", "kernels", "=", "[", "(", "1", ",", "self", ".", "kernel_size", ")", ",", "(", "self", ".", "kernel_size", ",", "1", ")", "]", "\n", "", "else", ":", "\n", "          ", "kernels", "=", "[", "(", "self", ".", "kernel_size", ",", "self", ".", "kernel_size", ")", "]", "\n", "", "for", "k", ",", "kernel", "in", "enumerate", "(", "kernels", ")", ":", "\n", "          ", "strides", "=", "1", "\n", "if", "(", "\n", "not", "self", ".", "with_maxpooling", "and", "j", "==", "len", "(", "filters", ")", "-", "1", "and", "\n", "k", "==", "len", "(", "kernels", ")", "-", "1", "\n", ")", ":", "\n", "            ", "strides", "=", "2", "\n", "", "if", "self", ".", "use_separable", "==", "\"dsp\"", ":", "\n", "            ", "kernel_suffix", "=", "(", "\n", "\"\"", ".", "join", "(", "[", "str", "(", "k", ")", "for", "k", "in", "kernel", "]", ")", "+", "\"_\"", "+", "name_suffix", ")", "\n", "", "elif", "self", ".", "use_separable", "==", "\"mobilenet\"", ":", "\n", "            ", "depth_suffix", "=", "(", "\n", "\"\"", ".", "join", "(", "[", "str", "(", "k", ")", "for", "k", "in", "kernel", "]", ")", "+", "\"_\"", "+", "name_suffix", ")", "\n", "kernel_suffix", "=", "\"11_\"", "+", "name_suffix", "\n", "", "else", ":", "\n", "            ", "kernel_suffix", "=", "name_suffix", "\n", "", "if", "self", ".", "use_separable", "==", "\"mobilenet\"", ":", "\n", "            ", "x", "=", "DepthwiseConv2D", "(", "\n", "kernel", ",", "\n", "padding", "=", "\"same\"", ",", "strides", "=", "strides", ",", "\n", "use_bias", "=", "False", ",", "\n", "name", "=", "\"conv2d_dw_\"", "+", "depth_suffix", ")", "(", "x", ")", "\n", "if", "self", ".", "with_batchnorm", ":", "\n", "              ", "x", "=", "BatchNormalization", "(", "name", "=", "\"conv2d_dw_bn_\"", "+", "depth_suffix", ")", "(", "x", ")", "\n", "", "x", "=", "Activation", "(", "\"relu\"", ",", "name", "=", "\"conv2d_dw_act_\"", "+", "depth_suffix", ")", "(", "x", ")", "\n", "kernel", "=", "(", "1", ",", "1", ")", "\n", "strides", "=", "1", "\n", "", "x", "=", "Conv2D", "(", "\n", "filters", "[", "j", "]", ",", "kernel", ",", "\n", "strides", "=", "strides", ",", "use_bias", "=", "not", "self", ".", "with_batchnorm", ",", "\n", "padding", "=", "\"same\"", ",", "\n", "kernel_initializer", "=", "self", ".", "kernel_initializer", ",", "\n", "bias_initializer", "=", "self", ".", "bias_initializer", ",", "\n", "name", "=", "\"conv2d_\"", "+", "kernel_suffix", ")", "(", "x", ")", "\n", "if", "not", "(", "\n", "self", ".", "with_maxpooling", "and", "self", ".", "use_xnornet_trick", "and", "\n", "j", "==", "len", "(", "filters", ")", "-", "1", "and", "k", "==", "len", "(", "kernels", ")", "-", "1", "\n", ")", ":", "\n", "            ", "if", "self", ".", "with_batchnorm", ":", "\n", "              ", "x", "=", "BatchNormalization", "(", "\n", "beta_initializer", "=", "self", ".", "bias_initializer", ",", "\n", "name", "=", "\"bn_\"", "+", "kernel_suffix", ")", "(", "x", ")", "\n", "", "x", "=", "Activation", "(", "\"relu\"", ",", "name", "=", "\"act_\"", "+", "kernel_suffix", ")", "(", "x", ")", "\n", "", "", "", "if", "self", ".", "with_maxpooling", ":", "\n", "        ", "x", "=", "MaxPooling2D", "(", "2", ",", "2", ",", "name", "=", "\"mp_\"", "+", "name_suffix", ")", "(", "x", ")", "\n", "# this is a trick from xnornet to enable full binary or ternary", "\n", "# networks to be after maxpooling.", "\n", "if", "self", ".", "use_xnornet_trick", ":", "\n", "          ", "x", "=", "BatchNormalization", "(", "\n", "beta_initializer", "=", "self", ".", "bias_initializer", ",", "\n", "name", "=", "\"mp_bn_\"", "+", "name_suffix", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "\"relu\"", ",", "name", "=", "\"mp_act_\"", "+", "name_suffix", ")", "(", "x", ")", "\n", "", "", "if", "self", ".", "dropout_rate", ">", "0", ":", "\n", "        ", "x", "=", "Dropout", "(", "self", ".", "dropout_rate", ",", "name", "=", "\"drop_\"", "+", "name_suffix", ")", "(", "x", ")", "\n", "\n", "", "", "if", "x", ".", "shape", ".", "as_list", "(", ")", "[", "1", "]", ">", "1", ":", "\n", "      ", "x", "=", "Flatten", "(", "name", "=", "\"flatten\"", ")", "(", "x", ")", "\n", "x", "=", "Dense", "(", "\n", "self", ".", "nb_classes", ",", "\n", "kernel_initializer", "=", "self", ".", "kernel_initializer", ",", "\n", "bias_initializer", "=", "self", ".", "bias_initializer", ",", "\n", "name", "=", "\"dense\"", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "\"softmax\"", ",", "name", "=", "\"softmax\"", ")", "(", "x", ")", "\n", "", "else", ":", "\n", "      ", "x", "=", "Conv2D", "(", "\n", "self", ".", "nb_classes", ",", "1", ",", "strides", "=", "1", ",", "padding", "=", "\"same\"", ",", "\n", "kernel_initializer", "=", "self", ".", "kernel_initializer", ",", "\n", "bias_initializer", "=", "self", ".", "bias_initializer", ",", "\n", "name", "=", "\"dense\"", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "\"softmax\"", ",", "name", "=", "\"softmax\"", ")", "(", "x", ")", "\n", "x", "=", "Flatten", "(", "name", "=", "\"flatten\"", ")", "(", "x", ")", "\n", "\n", "", "model", "=", "Model", "(", "inputs", "=", "[", "x_in", "]", ",", "outputs", "=", "[", "x", "]", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_energy.ForgivingFactorPower.__init__": [[29, 106], ["qkeras.autoqkeras.forgiving_metrics.forgiving_factor.ForgivingFactor.__init__", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "delta_p", ",", "delta_n", ",", "rate", ",", "stress", "=", "1.0", ",", "**", "kwargs", ")", ":", "\n", "\n", "# input parameters:", "\n", "# delta_p, delta_n, rate: same as parent class", "\n", "# stress: stress level to shift reference curve", "\n", "# process: technology process to use in configuration (horowitz, ...)", "\n", "# parameters_on_memory: whether to store parameters in dram, sram, or fixed", "\n", "# activations_on_memory: store activations in dram, sram", "\n", "# min_sram_size: minimum sram size in number of bits", "\n", "# rd_wr_on_io: whether load data from dram to sram (consider sram as a cache", "\n", "#   for dram. If false, we will assume data will be already in SRAM", "\n", "# config_json: if None, use qtools/config_json by default", "\n", "#   define default source quantizers;", "\n", "#   default quantizers for intermediate variables if no quantizer provided", "\n", "#   parameters for energy calculation", "\n", "# source_quantizers: quantizer for model input", "\n", "# trained_model: whether model has been trained already, which is", "\n", "#   needed to compute tighter bounds for qBatchNorm Power estimation.", "\n", "# reference_internal: size to use for weight/bias/activation in", "\n", "#   get_reference energy calculation (int8, fp16, fp32)", "\n", "# reference_accumulator: accumulator and multiplier type in get_reference", "\n", "#   energy calculation", "\n", "# keras_layer_quantizer: quantizer for keras layers in hybrid models", "\n", "\n", "    ", "super", "(", "ForgivingFactorPower", ",", "self", ")", ".", "__init__", "(", "delta_p", ",", "delta_n", ",", "rate", ")", "\n", "\n", "self", ".", "stress", "=", "stress", "\n", "# process: horowitz... - must be present in config_json", "\n", "self", ".", "process", "=", "kwargs", ".", "get", "(", "\"process\"", ",", "\"horowitz\"", ")", "\n", "# parameters_on_memory: fixed, sram, dram", "\n", "self", ".", "parameters_on_memory", "=", "kwargs", ".", "get", "(", "\n", "\"parameters_on_memory\"", ",", "[", "\"fixed\"", "]", "*", "2", ")", "\n", "# activations_on_memory: sram, dram", "\n", "self", ".", "activations_on_memory", "=", "kwargs", ".", "get", "(", "\n", "\"activations_on_memory\"", ",", "[", "\"dram\"", "]", "*", "2", "\n", ")", "\n", "self", ".", "min_sram_size", "=", "kwargs", ".", "get", "(", "\"min_sram_size\"", ",", "[", "0", "]", "*", "2", ")", "\n", "# rd_wr_on_io: true/false", "\n", "self", ".", "rd_wr_on_io", "=", "kwargs", ".", "get", "(", "\"rd_wr_on_io\"", ",", "[", "True", "]", "*", "2", ")", "\n", "self", ".", "config_json", "=", "kwargs", ".", "get", "(", "\"config_json\"", ",", "None", ")", "\n", "self", ".", "source_quantizers", "=", "kwargs", ".", "get", "(", "\"source_quantizers\"", ",", "None", ")", "\n", "# trained_model: true/false", "\n", "self", ".", "trained_model", "=", "kwargs", ".", "get", "(", "\"trained_model\"", ",", "False", ")", "\n", "# reference_internal: int8, fp16, fp32", "\n", "self", ".", "reference_internal", "=", "kwargs", ".", "get", "(", "\"reference_internal\"", ",", "\"fp32\"", ")", "\n", "# reference_internal: int8, int16, int32, fp16, fp32", "\n", "self", ".", "reference_accumulator", "=", "kwargs", ".", "get", "(", "\"reference_accumulator\"", ",", "\"fp32\"", ")", "\n", "\n", "self", ".", "reference_size", "=", "None", "\n", "\n", "# energy_dict is a dictionary that lists energy consumption for each layer", "\n", "# format:", "\n", "#  {", "\n", "#     \"layer0_name\":", "\n", "#     {", "\n", "#        \"mem_cost\": 148171,", "\n", "#        \"op_cost\": 0", "\n", "#     },", "\n", "#     \"layer1_name\":", "\n", "#     {", "\n", "#         \"mem_cost\": 179923,", "\n", "#         \"op_cost\": 34", "\n", "#     },", "\n", "#     ...", "\n", "#", "\n", "#     \"total_cost\": 328129", "\n", "#  }", "\n", "\n", "self", ".", "ref_energy_dict", "=", "None", "\n", "self", ".", "trial_energy_dict", "=", "None", "\n", "\n", "assert", "self", ".", "parameters_on_memory", "[", "0", "]", "in", "[", "\"dram\"", ",", "\"sram\"", ",", "\"fixed\"", "]", "\n", "assert", "self", ".", "parameters_on_memory", "[", "1", "]", "in", "[", "\"dram\"", ",", "\"sram\"", ",", "\"fixed\"", "]", "\n", "assert", "self", ".", "activations_on_memory", "[", "0", "]", "in", "[", "\"dram\"", ",", "\"sram\"", ",", "\"fixed\"", "]", "\n", "assert", "self", ".", "activations_on_memory", "[", "1", "]", "in", "[", "\"dram\"", ",", "\"sram\"", ",", "\"fixed\"", "]", "\n", "assert", "self", ".", "reference_internal", "in", "[", "\"fp16\"", ",", "\"fp32\"", ",", "\"int8\"", "]", "\n", "assert", "self", ".", "reference_accumulator", "in", "[", "\"int16\"", ",", "\"int32\"", ",", "\"fp16\"", ",", "\"fp32\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_energy.ForgivingFactorPower.get_reference": [[107, 135], ["qkeras.qtools.run_qtools.QTools", "qkeras.qtools.run_qtools.QTools.pe", "qkeras.qtools.run_qtools.QTools.extract_energy_sum", "qkeras.qtools.run_qtools.QTools.extract_energy_profile"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qtools.run_qtools.QTools.pe", "home.repos.pwc.inspect_result.google_qkeras.qtools.run_qtools.QTools.extract_energy_sum", "home.repos.pwc.inspect_result.google_qkeras.qtools.run_qtools.QTools.extract_energy_profile"], ["", "def", "get_reference", "(", "self", ",", "model", ")", ":", "\n", "# we only want to compute reference once", "\n", "    ", "if", "self", ".", "reference_size", "is", "not", "None", ":", "\n", "      ", "return", "self", ".", "reference_size", "*", "self", ".", "stress", "\n", "\n", "", "q", "=", "run_qtools", ".", "QTools", "(", "\n", "model", ",", "process", "=", "self", ".", "process", ",", "\n", "source_quantizers", "=", "self", ".", "reference_internal", ",", "\n", "is_inference", "=", "self", ".", "trained_model", ",", "\n", "weights_path", "=", "None", ",", "\n", "keras_quantizer", "=", "self", ".", "reference_internal", ",", "\n", "keras_accumulator", "=", "self", ".", "reference_accumulator", ",", "\n", "for_reference", "=", "True", ")", "\n", "\n", "energy_dict", "=", "q", ".", "pe", "(", "\n", "weights_on_memory", "=", "self", ".", "parameters_on_memory", "[", "0", "]", ",", "\n", "activations_on_memory", "=", "self", ".", "activations_on_memory", "[", "0", "]", ",", "\n", "min_sram_size", "=", "self", ".", "min_sram_size", "[", "0", "]", ",", "\n", "rd_wr_on_io", "=", "self", ".", "rd_wr_on_io", "[", "0", "]", ")", "\n", "\n", "self", ".", "ref_energy_dict", "=", "energy_dict", "\n", "self", ".", "reference_size", "=", "q", ".", "extract_energy_sum", "(", "\n", "qtools_settings", ".", "cfg", ".", "include_energy", ",", "energy_dict", ")", "\n", "\n", "self", ".", "reference_energy_profile", "=", "q", ".", "extract_energy_profile", "(", "\n", "qtools_settings", ".", "cfg", ".", "include_energy", ",", "energy_dict", ")", "\n", "\n", "return", "self", ".", "reference_size", "*", "self", ".", "stress", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_energy.ForgivingFactorPower.get_trial": [[136, 163], ["qkeras.qtools.run_qtools.QTools", "qkeras.qtools.run_qtools.QTools.pe", "qkeras.qtools.run_qtools.QTools.extract_energy_sum", "qkeras.qtools.run_qtools.QTools.extract_energy_profile"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qtools.run_qtools.QTools.pe", "home.repos.pwc.inspect_result.google_qkeras.qtools.run_qtools.QTools.extract_energy_sum", "home.repos.pwc.inspect_result.google_qkeras.qtools.run_qtools.QTools.extract_energy_profile"], ["", "def", "get_trial", "(", "self", ",", "model", ")", ":", "\n", "    ", "\"\"\"Computes size of quantization trial.\"\"\"", "\n", "\n", "q", "=", "run_qtools", ".", "QTools", "(", "\n", "model", ",", "process", "=", "self", ".", "process", ",", "\n", "source_quantizers", "=", "self", ".", "source_quantizers", ",", "\n", "is_inference", "=", "self", ".", "trained_model", ",", "\n", "weights_path", "=", "None", ",", "\n", "keras_quantizer", "=", "self", ".", "reference_internal", ",", "\n", "keras_accumulator", "=", "self", ".", "reference_accumulator", ",", "\n", "for_reference", "=", "False", ")", "\n", "\n", "energy_dict", "=", "q", ".", "pe", "(", "\n", "weights_on_memory", "=", "self", ".", "parameters_on_memory", "[", "1", "]", ",", "\n", "activations_on_memory", "=", "self", ".", "activations_on_memory", "[", "1", "]", ",", "\n", "min_sram_size", "=", "self", ".", "min_sram_size", "[", "1", "]", ",", "\n", "rd_wr_on_io", "=", "self", ".", "rd_wr_on_io", "[", "1", "]", ")", "\n", "\n", "self", ".", "trial_energy_dict", "=", "energy_dict", "\n", "# self.trial_size = energy_dict[\"total_cost\"]", "\n", "self", ".", "trial_size", "=", "q", ".", "extract_energy_sum", "(", "\n", "qtools_settings", ".", "cfg", ".", "include_energy", ",", "energy_dict", ")", "\n", "\n", "self", ".", "trial_energy_profile", "=", "q", ".", "extract_energy_profile", "(", "\n", "qtools_settings", ".", "cfg", ".", "include_energy", ",", "energy_dict", ")", "\n", "\n", "return", "self", ".", "trial_size", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_energy.ForgivingFactorPower.get_total_factor": [[164, 167], ["None"], "methods", ["None"], ["", "def", "get_total_factor", "(", "self", ")", ":", "\n", "    ", "\"\"\"we adjust the learning rate by size reduction.\"\"\"", "\n", "return", "(", "self", ".", "trial_size", "-", "self", ".", "reference_size", ")", "/", "self", ".", "reference_size", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_energy.ForgivingFactorPower.get_reference_stats": [[168, 170], ["None"], "methods", ["None"], ["", "def", "get_reference_stats", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "reference_energy_profile", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_energy.ForgivingFactorPower.get_trial_stats": [[171, 173], ["None"], "methods", ["None"], ["", "def", "get_trial_stats", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "trial_energy_profile", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_energy.ForgivingFactorPower.print_stats": [[174, 212], ["forgiving_energy.ForgivingFactorPower.delta", "print", "print", "json.dumps", "print", "print", "json.dumps", "print", "print", "numpy.round", "print", "str_format.format", "int", "int", "int"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_factor.ForgivingFactor.delta"], ["", "def", "print_stats", "(", "self", ",", "verbosity", "=", "0", ")", ":", "\n", "    ", "\"\"\"Prints statistics of current model.\"\"\"", "\n", "\n", "delta", "=", "self", ".", "delta", "(", ")", "\n", "\n", "if", "(", "self", ".", "ref_energy_dict", "and", "self", ".", "trial_energy_dict", ")", ":", "\n", "      ", "str_format", "=", "(", "\n", "\"stats: delta_p={} delta_n={} rate={} trial_size={} \"", "\n", "\"reference_size={}\\n\"", "\n", "\"       delta={:.2f}%\"", "\n", ")", "\n", "\n", "print", "(", "\n", "str_format", ".", "format", "(", "\n", "self", ".", "delta_p", ",", "self", ".", "delta_n", ",", "self", ".", "rate", ",", "self", ".", "trial_size", ",", "\n", "int", "(", "self", ".", "reference_size", ")", ",", "100", "*", "delta", ")", "\n", ")", "\n", "\n", "", "if", "verbosity", ">", "0", "and", "self", ".", "ref_energy_dict", ":", "\n", "      ", "print", "(", "\"Reference Cost Distribution:\"", ")", "\n", "dict_to_json", "=", "json", ".", "dumps", "(", "self", ".", "ref_energy_dict", ",", "indent", "=", "4", ")", "\n", "print", "(", "dict_to_json", ")", "\n", "\n", "", "if", "verbosity", ">", "0", "and", "self", ".", "trial_energy_dict", ":", "\n", "      ", "print", "(", "\"Trial Cost Distribution:\"", ")", "\n", "dict_to_json", "=", "json", ".", "dumps", "(", "self", ".", "trial_energy_dict", ",", "indent", "=", "4", ")", "\n", "print", "(", "dict_to_json", ")", "\n", "\n", "", "if", "(", "self", ".", "ref_energy_dict", "and", "self", ".", "trial_energy_dict", ")", ":", "\n", "      ", "print", "(", "\"Total Cost Reduction:\"", ")", "\n", "reduction_percentage", "=", "np", ".", "round", "(", "\n", "100.0", "*", "(", "self", ".", "trial_size", "-", "self", ".", "reference_size", ")", "/", "\n", "self", ".", "reference_size", ",", "2", ")", "\n", "\n", "print", "(", "\n", "(", "\"       {} vs {} ({:.2f}%)\"", ")", ".", "format", "(", "\n", "int", "(", "self", ".", "trial_size", ")", ",", "int", "(", "self", ".", "reference_size", ")", ",", "\n", "reduction_percentage", "\n", ")", ")", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_factor.ForgivingFactor.__init__": [[25, 29], ["numpy.float32", "numpy.float32", "numpy.float32"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "delta_p", ",", "delta_n", ",", "rate", ")", ":", "\n", "    ", "self", ".", "delta_p", "=", "np", ".", "float32", "(", "delta_p", ")", "/", "100.0", "\n", "self", ".", "delta_n", "=", "np", ".", "float32", "(", "delta_n", ")", "/", "100.0", "\n", "self", ".", "rate", "=", "np", ".", "float32", "(", "rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_factor.ForgivingFactor.get_reference": [[30, 34], ["Exception"], "methods", ["None"], ["", "def", "get_reference", "(", "self", ",", "model", ")", ":", "\n", "    ", "\"\"\"Computes reference size of model.\"\"\"", "\n", "\n", "raise", "Exception", "(", "\"class not implemented.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_factor.ForgivingFactor.get_trial": [[35, 39], ["Exception"], "methods", ["None"], ["", "def", "get_trial", "(", "self", ",", "model", ",", "schema", ")", ":", "\n", "    ", "\"\"\"Computes size of quantization trial.\"\"\"", "\n", "\n", "raise", "Exception", "(", "\"class not implemented.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_factor.ForgivingFactor.delta": [[40, 47], ["numpy.where", "numpy.log", "numpy.log", "numpy.log", "numpy.log"], "methods", ["None"], ["", "def", "delta", "(", "self", ")", ":", "\n", "    ", "return", "np", ".", "where", "(", "\n", "self", ".", "trial_size", "<", "self", ".", "reference_size", ",", "\n", "self", ".", "delta_p", "*", "(", "np", ".", "log", "(", "self", ".", "reference_size", "/", "self", ".", "trial_size", ")", "/", "\n", "np", ".", "log", "(", "self", ".", "rate", ")", ")", ",", "\n", "self", ".", "delta_n", "*", "(", "np", ".", "log", "(", "self", ".", "reference_size", "/", "self", ".", "trial_size", ")", "/", "\n", "np", ".", "log", "(", "self", ".", "rate", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits.__init__": [[28, 39], ["qkeras.autoqkeras.forgiving_metrics.forgiving_factor.ForgivingFactor.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "\n", "self", ",", "delta_p", ",", "delta_n", ",", "rate", ",", "stress", "=", "1.0", ",", "\n", "input_bits", "=", "8", ",", "output_bits", "=", "8", ",", "ref_bits", "=", "8", ",", "config", "=", "None", ")", ":", "\n", "    ", "self", ".", "stress", "=", "stress", "\n", "self", ".", "input_bits", "=", "input_bits", "\n", "self", ".", "output_bits", "=", "output_bits", "\n", "self", ".", "ref_bits", "=", "ref_bits", "\n", "self", ".", "ref_size", "=", "{", "}", "\n", "self", ".", "config", "=", "config", "if", "config", "else", "{", "}", "\n", "\n", "super", "(", "ForgivingFactorBits", ",", "self", ")", ".", "__init__", "(", "delta_p", ",", "delta_n", ",", "rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits._param_size": [[40, 79], ["layer.get_weights", "enumerate", "numpy.prod", "layer.get_weights", "layer.get_quantizers", "numpy.prod", "numpy.prod", "int", "bool", "numpy.prod", "numpy.prod", "int", "layer.get_quantizers", "bool", "numpy.prod", "layer.get_weights", "layer.get_weights", "layer.get_weights", "layer.get_weights"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights"], ["", "def", "_param_size", "(", "self", ",", "layer", ")", ":", "\n", "    ", "\"\"\"Computes size of parameters of a layer in bits.\"\"\"", "\n", "t_size", "=", "self", ".", "ref_bits", "\n", "parameter_size", "=", "0", "\n", "# we only compute parameter sizes for these layers, and BatchNormalization", "\n", "# is a special case because it exports mean and beta that is absorbed by", "\n", "# previous or next layer. As mean and beta will be compressed into a single", "\n", "# value, we actually only need to take care of the shape.", "\n", "if", "layer", ".", "__class__", ".", "__name__", "in", "[", "\n", "\"Dense\"", ",", "\"Conv2D\"", ",", "\"Conv1D\"", ",", "\"DepthwiseConv2D\"", "]", ":", "\n", "      ", "for", "w", "in", "layer", ".", "get_weights", "(", ")", ":", "\n", "        ", "parameter_size", "+=", "t_size", "*", "np", ".", "prod", "(", "w", ".", "shape", ")", "\n", "", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\n", "\"QDense\"", ",", "\"QConv2D\"", ",", "\"QConv1D\"", ",", "\"QDepthwiseConv2D\"", "]", ":", "\n", "      ", "for", "i", ",", "w", "in", "enumerate", "(", "layer", ".", "get_weights", "(", ")", ")", ":", "\n", "        ", "if", "layer", ".", "get_quantizers", "(", ")", "[", "i", "]", ":", "\n", "          ", "bits", "=", "layer", ".", "get_quantizers", "(", ")", "[", "i", "]", ".", "bits", "\n", "", "else", ":", "\n", "          ", "bits", "=", "t_size", "\n", "", "parameter_size", "+=", "bits", "*", "np", ".", "prod", "(", "w", ".", "shape", ")", "\n", "", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"BatchNormalization\"", "]", ":", "\n", "# scale", "\n", "      ", "index", "=", "-", "1", "\n", "parameter_size", "+=", "t_size", "*", "np", ".", "prod", "(", "layer", ".", "get_weights", "(", ")", "[", "index", "]", ".", "shape", ")", "\n", "# center (bias)", "\n", "if", "layer", ".", "center", ":", "\n", "        ", "index", "=", "int", "(", "bool", "(", "layer", ".", "scale", ")", ")", "\n", "parameter_size", "+=", "t_size", "*", "np", ".", "prod", "(", "layer", ".", "get_weights", "(", ")", "[", "index", "]", ".", "shape", ")", "\n", "", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"QBatchNormalization\"", "]", ":", "\n", "# scale", "\n", "      ", "index", "=", "-", "1", "\n", "bits", "=", "6", "\n", "parameter_size", "+=", "bits", "*", "np", ".", "prod", "(", "layer", ".", "get_weights", "(", ")", "[", "index", "]", ".", "shape", ")", "\n", "# center (bias)", "\n", "if", "layer", ".", "center", ":", "\n", "        ", "bits", "=", "5", "\n", "index", "=", "int", "(", "bool", "(", "layer", ".", "scale", ")", ")", "\n", "parameter_size", "+=", "bits", "*", "np", ".", "prod", "(", "layer", ".", "get_weights", "(", ")", "[", "index", "]", ".", "shape", ")", "\n", "", "", "return", "parameter_size", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits._act_size": [[80, 148], ["numpy.prod", "isinstance", "isinstance", "hasattr", "numpy.prod", "hasattr", "isinstance", "hasattr", "isinstance", "layer.output.shape.as_list", "qkeras.get_quantizer"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.get_quantizer"], ["", "def", "_act_size", "(", "self", ",", "layer", ")", ":", "\n", "    ", "\"\"\"Computes size of activations of a layer in bits.\"\"\"", "\n", "i_size", "=", "self", ".", "input_bits", "\n", "o_size", "=", "self", ".", "output_bits", "\n", "t_size", "=", "self", ".", "ref_bits", "\n", "output_size", "=", "np", ".", "prod", "(", "layer", ".", "output", ".", "shape", "[", "1", ":", "]", ")", "\n", "# we compute activation sizes for inputs and outputs", "\n", "if", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"InputLayer\"", "]", ":", "\n", "      ", "return", "i_size", "*", "output_size", "\n", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\n", "\"Dense\"", ",", "\"Conv2D\"", ",", "\"Conv1D\"", ",", "\"DepthwiseConv2D\"", "]", ":", "\n", "      ", "if", "layer", ".", "activation", "is", "not", "None", "and", "layer", ".", "activation", ".", "__name__", "!=", "\"linear\"", ":", "\n", "        ", "return", "t_size", "*", "output_size", "\n", "", "else", ":", "\n", "        ", "return", "0", "\n", "", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\n", "\"QDense\"", ",", "\"QConv2D\"", ",", "\"QConv1D\"", ",", "\"QDepthwiseConv2D\"", "]", ":", "\n", "      ", "if", "layer", ".", "activation", "is", "None", ":", "\n", "        ", "is_softmax", "=", "False", "\n", "is_linear", "=", "False", "\n", "", "else", ":", "\n", "        ", "if", "isinstance", "(", "layer", ".", "activation", ",", "six", ".", "string_types", ")", ":", "\n", "          ", "is_softmax", "=", "layer", ".", "activation", "==", "\"softmax\"", "\n", "is_linear", "=", "layer", ".", "activation", "==", "\"linear\"", "\n", "", "elif", "hasattr", "(", "layer", ".", "activation", ",", "\"__name__\"", ")", ":", "\n", "          ", "is_softmax", "=", "layer", ".", "activation", ".", "__name__", "==", "\"softmax\"", "\n", "is_linear", "=", "layer", ".", "activation", ".", "__name__", "==", "\"linear\"", "\n", "", "else", ":", "\n", "          ", "is_softmax", "=", "False", "\n", "is_linear", "=", "False", "\n", "\n", "", "if", "is_softmax", ":", "\n", "          ", "bits", "=", "o_size", "\n", "", "elif", "is_linear", ":", "\n", "          ", "bits", "=", "0", "\n", "", "else", ":", "\n", "          ", "assert", "not", "isinstance", "(", "layer", ".", "activation", ",", "six", ".", "string_types", ")", "\n", "if", "hasattr", "(", "layer", ".", "activation", ",", "\"bits\"", ")", ":", "\n", "            ", "bits", "=", "layer", ".", "activation", ".", "bits", "\n", "", "else", ":", "\n", "            ", "bits", "=", "t_size", "\n", "\n", "", "", "return", "bits", "*", "np", ".", "prod", "(", "layer", ".", "output", ".", "shape", ".", "as_list", "(", ")", "[", "1", ":", "]", ")", "\n", "", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"QActivation\"", ",", "\"Activation\"", "]", ":", "\n", "      ", "if", "isinstance", "(", "layer", ".", "activation", ",", "six", ".", "string_types", ")", ":", "\n", "        ", "is_linear", "=", "layer", ".", "activation", "==", "\"linear\"", "\n", "is_softmax", "=", "layer", ".", "activation", "==", "\"softmax\"", "\n", "is_sigmoid", "=", "layer", ".", "activation", "==", "\"sigmoid\"", "\n", "", "else", ":", "\n", "        ", "is_linear", "=", "layer", ".", "activation", ".", "__name__", "==", "\"linear\"", "\n", "is_softmax", "=", "layer", ".", "activation", ".", "__name__", "==", "\"softmax\"", "\n", "is_sigmoid", "=", "layer", ".", "activation", ".", "__name__", "==", "\"sigmoid\"", "\n", "\n", "", "if", "is_linear", ":", "\n", "        ", "bits", "=", "0", "\n", "", "elif", "is_softmax", "or", "is_sigmoid", ":", "\n", "        ", "bits", "=", "o_size", "\n", "", "else", ":", "\n", "        ", "if", "isinstance", "(", "layer", ".", "activation", ",", "six", ".", "string_types", ")", ":", "\n", "          ", "activation", "=", "get_quantizer", "(", "layer", ".", "activation", ")", "\n", "", "else", ":", "\n", "          ", "activation", "=", "layer", ".", "activation", "\n", "", "if", "hasattr", "(", "activation", ",", "\"bits\"", ")", ":", "\n", "          ", "bits", "=", "activation", ".", "bits", "\n", "", "else", ":", "\n", "          ", "bits", "=", "t_size", "\n", "", "", "return", "bits", "*", "output_size", "\n", "", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits.compute_model_size": [[149, 176], ["forgiving_bits.ForgivingFactorBits.config.get", "forgiving_bits.ForgivingFactorBits.config.get", "forgiving_bits.ForgivingFactorBits._param_size", "forgiving_bits.ForgivingFactorBits._act_size"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits._param_size", "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits._act_size"], ["", "def", "compute_model_size", "(", "self", ",", "model", ")", ":", "\n", "    ", "\"\"\"Computes size of model.\"\"\"", "\n", "\n", "a_size", "=", "0", "\n", "p_size", "=", "0", "\n", "total_size", "=", "0", "\n", "model_size_dict", "=", "{", "}", "\n", "for", "layer", "in", "model", ".", "layers", ":", "\n", "      ", "layer_name", "=", "layer", ".", "__class__", ".", "__name__", "\n", "layer_config", "=", "self", ".", "config", ".", "get", "(", "\n", "layer_name", ",", "self", ".", "config", ".", "get", "(", "\"default\"", ",", "None", ")", ")", "\n", "if", "layer_config", ":", "\n", "        ", "parameters", "=", "self", ".", "_param_size", "(", "layer", ")", "\n", "activations", "=", "self", ".", "_act_size", "(", "layer", ")", "\n", "p_weight", "=", "(", "\"parameters\"", "in", "layer_config", ")", "\n", "a_weight", "=", "(", "\"activations\"", "in", "layer_config", ")", "\n", "total", "=", "p_weight", "*", "parameters", "+", "a_weight", "*", "activations", "\n", "model_size_dict", "[", "layer", ".", "name", "]", "=", "{", "\n", "\"parameters\"", ":", "parameters", ",", "\n", "\"activations\"", ":", "activations", ",", "\n", "\"total\"", ":", "total", "\n", "}", "\n", "a_size", "+=", "a_weight", "*", "activations", "\n", "p_size", "+=", "p_weight", "*", "parameters", "\n", "total_size", "+=", "total", "\n", "\n", "", "", "return", "(", "total_size", ",", "p_size", ",", "a_size", ",", "model_size_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits.get_reference": [[177, 186], ["hasattr", "forgiving_bits.ForgivingFactorBits.compute_model_size"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits.compute_model_size"], ["", "def", "get_reference", "(", "self", ",", "model", ")", ":", "\n", "    ", "if", "not", "hasattr", "(", "self", ",", "\"reference_size\"", ")", ":", "\n", "      ", "cached_result", "=", "self", ".", "compute_model_size", "(", "model", ")", "\n", "self", ".", "reference_size", "=", "cached_result", "[", "0", "]", "*", "self", ".", "stress", "\n", "self", ".", "ref_p", "=", "cached_result", "[", "1", "]", "\n", "self", ".", "ref_a", "=", "cached_result", "[", "2", "]", "\n", "self", ".", "reference_size_dict", "=", "cached_result", "[", "3", "]", "\n", "\n", "", "return", "self", ".", "reference_size", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits.get_reference_stats": [[187, 189], ["None"], "methods", ["None"], ["", "def", "get_reference_stats", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "reference_size_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits.get_trial": [[190, 200], ["forgiving_bits.ForgivingFactorBits.compute_model_size"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits.compute_model_size"], ["", "def", "get_trial", "(", "self", ",", "model", ")", ":", "\n", "    ", "\"\"\"Computes size of quantization trial.\"\"\"", "\n", "\n", "result", "=", "self", ".", "compute_model_size", "(", "model", ")", "\n", "self", ".", "trial_size", "=", "result", "[", "0", "]", "\n", "self", ".", "total_p_bits", "=", "result", "[", "1", "]", "\n", "self", ".", "total_a_bits", "=", "result", "[", "2", "]", "\n", "self", ".", "trial_size_dict", "=", "result", "[", "3", "]", "\n", "\n", "return", "self", ".", "trial_size", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits.get_total_factor": [[201, 206], ["None"], "methods", ["None"], ["", "def", "get_total_factor", "(", "self", ")", ":", "\n", "    ", "\"\"\"we adjust the learning rate by size reduction.\"\"\"", "\n", "ref_total", "=", "self", ".", "ref_a", "+", "self", ".", "ref_p", "\n", "trial_total", "=", "self", ".", "total_a_bits", "+", "self", ".", "total_p_bits", "\n", "return", "(", "trial_total", "-", "ref_total", ")", "/", "ref_total", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_bits.ForgivingFactorBits.print_stats": [[207, 237], ["print", "numpy.round", "numpy.round", "numpy.round", "print", "str_format.format", "int", "int", "int", "int", "int", "int", "int", "forgiving_bits.ForgivingFactorBits.delta"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.forgiving_metrics.forgiving_factor.ForgivingFactor.delta"], ["", "def", "print_stats", "(", "self", ")", ":", "\n", "    ", "\"\"\"Prints statistics of current model.\"\"\"", "\n", "str_format", "=", "(", "\n", "\"stats: delta_p={} delta_n={} rate={} trial_size={} reference_size={}\\n\"", "\n", "\"       delta={:.2f}%\"", "\n", ")", "\n", "\n", "print", "(", "\n", "str_format", ".", "format", "(", "\n", "self", ".", "delta_p", ",", "self", ".", "delta_n", ",", "self", ".", "rate", ",", "self", ".", "trial_size", ",", "\n", "int", "(", "self", ".", "reference_size", ")", ",", "100", "*", "self", ".", "delta", "(", ")", ")", "\n", ")", "\n", "\n", "a_percentage", "=", "np", ".", "round", "(", "\n", "100.0", "*", "(", "self", ".", "total_a_bits", "-", "self", ".", "ref_a", ")", "/", "self", ".", "ref_a", ",", "2", ")", "\n", "p_percentage", "=", "np", ".", "round", "(", "\n", "100.0", "*", "(", "self", ".", "total_p_bits", "-", "self", ".", "ref_p", ")", "/", "self", ".", "ref_p", ",", "2", ")", "\n", "ref_total", "=", "self", ".", "ref_a", "+", "self", ".", "ref_p", "\n", "trial_total", "=", "self", ".", "total_a_bits", "+", "self", ".", "total_p_bits", "\n", "total_percentage", "=", "np", ".", "round", "(", "\n", "100.0", "*", "(", "trial_total", "-", "ref_total", ")", "/", "ref_total", ",", "2", ")", "\n", "\n", "print", "(", "\n", "(", "\n", "\"       a_bits={}/{} ({:.2f}%) p_bits={}/{} ({:.2f}%)\\n\"", "\n", "\"       total={}/{} ({:.2f}%)\"", "\n", ")", ".", "format", "(", "\n", "int", "(", "self", ".", "total_a_bits", ")", ",", "int", "(", "self", ".", "ref_a", ")", ",", "a_percentage", ",", "\n", "int", "(", "self", ".", "total_p_bits", ")", ",", "int", "(", "self", ".", "ref_p", ")", ",", "p_percentage", ",", "\n", "int", "(", "trial_total", ")", ",", "int", "(", "ref_total", ")", ",", "total_percentage", "\n", ")", ")", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_val": [[30, 37], ["isinstance", "feature.get", "getattr"], "function", ["None"], ["def", "get_val", "(", "feature", ",", "key", ")", ":", "\n", "# Return feature[key] or feature.key", "\n", "  ", "if", "isinstance", "(", "feature", ",", "dict", ")", ":", "\n", "    ", "val", "=", "feature", ".", "get", "(", "key", ",", "None", ")", "\n", "", "else", ":", "\n", "    ", "val", "=", "getattr", "(", "feature", ",", "key", ",", "None", ")", "\n", "", "return", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.is_shape_alternation_layers": [[39, 44], ["None"], "function", ["None"], ["", "def", "is_shape_alternation_layers", "(", "layer", ")", ":", "\n", "  ", "lname", "=", "layer", ".", "__class__", ".", "__name__", "\n", "if", "lname", ":", "\n", "    ", "return", "\"MaxPool\"", "in", "lname", "or", "\"Reshape\"", "in", "lname", "or", "\"Flatten\"", "in", "lname", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.is_merge_layers": [[46, 54], ["None"], "function", ["None"], ["", "def", "is_merge_layers", "(", "layer", ")", ":", "\n", "\n", "  ", "if", "layer", ".", "__class__", ".", "__name__", "in", "[", "\n", "\"Add\"", ",", "\"Multiply\"", ",", "\"Subtract\"", ",", "\"Average\"", ",", "\"Maximum\"", ",", "\"Minimum\"", ",", "\n", "\"Concatenate\"", ",", "\"Dot\"", "]", ":", "\n", "    ", "return", "True", "\n", "", "else", ":", "\n", "    ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_input_quantizers": [[56, 76], ["graph.predecessors", "quantizer_factory.make_quantizer", "output.append", "print", "print"], "function", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer"], ["", "", "def", "get_input_quantizers", "(", "graph", ",", "node_id", ",", "quantizer_factory", ",", "debug", "=", "False", ")", ":", "\n", "  ", "\"\"\"get the current layer's input quantizer.\"\"\"", "\n", "\n", "# in merge layers, therea are more than 1 input", "\n", "\n", "output", "=", "[", "]", "\n", "for", "parent_node_id", "in", "graph", ".", "predecessors", "(", "node_id", ")", ":", "\n", "\n", "    ", "edge", "=", "graph", ".", "edges", "[", "(", "parent_node_id", ",", "node_id", ")", "]", "\n", "\n", "if", "debug", ":", "\n", "      ", "print", "(", "\"parent_node_id:\"", ",", "parent_node_id", ")", "\n", "print", "(", "edge", ")", "\n", "\n", "", "quantizer_on_edge", "=", "edge", "[", "\"quantizer\"", "]", "\n", "input_quantizer", "=", "quantizer_factory", ".", "make_quantizer", "(", "quantizer_on_edge", ")", "\n", "\n", "output", ".", "append", "(", "(", "input_quantizer", ",", "edge", ")", ")", "\n", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_input_quantizers_advanced": [[78, 110], ["graph.predecessors", "quantizer_factory.make_quantizer", "output.append", "print", "print", "quantizer_factory.make_default_quantizer", "quantizer_factory.make_default_quantizer"], "function", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer"], ["", "def", "get_input_quantizers_advanced", "(", "graph", ",", "node_id", ",", "is_input_layer", ",", "quantizer_factory", ",", "\n", "cfg", ",", "debug", "=", "False", ")", ":", "\n", "  ", "\"\"\"get input quantizer, deal with keras layer or lack of input quantizer in qkeras layer.\"\"\"", "\n", "\n", "# in merge layers, therea are more than 1 input", "\n", "default_source_quantizer", "=", "cfg", ".", "default_source_quantizer", "\n", "default_interm_quantizer", "=", "cfg", ".", "default_interm_quantizer", "\n", "\n", "output", "=", "[", "]", "\n", "for", "parent_node_id", "in", "graph", ".", "predecessors", "(", "node_id", ")", ":", "\n", "\n", "    ", "edge", "=", "graph", ".", "edges", "[", "(", "parent_node_id", ",", "node_id", ")", "]", "\n", "\n", "if", "debug", ":", "\n", "      ", "print", "(", "\"parent_node_id:\"", ",", "parent_node_id", ")", "\n", "print", "(", "edge", ")", "\n", "\n", "", "quantizer_on_edge", "=", "edge", "[", "\"quantizer\"", "]", "\n", "input_quantizer", "=", "quantizer_factory", ".", "make_quantizer", "(", "quantizer_on_edge", ")", "\n", "\n", "if", "is_input_layer", "and", "not", "input_quantizer", ":", "\n", "# input layer without input_quantizer specified->use default_source_quantizer", "\n", "      ", "input_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "default_source_quantizer", ")", "\n", "", "elif", "not", "input_quantizer", ":", "\n", "# if no input quantizer is available-> use default quantizer from config.json", "\n", "      ", "input_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "default_interm_quantizer", ")", "\n", "\n", "", "output", ".", "append", "(", "(", "input_quantizer", ",", "edge", ")", ")", "\n", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_operation_count": [[112, 202], ["isinstance", "int", "qtools_util.is_merge_layers", "qtools_util.is_shape_alternation_layers", "numpy.prod", "hasattr", "numpy.prod", "layer.compute_output_shape", "layer.compute_output_shape", "numpy.prod", "numpy.prod", "layer.compute_output_shape", "layer.get_weights", "layer.compute_output_shape", "layer.get_weights", "layer.compute_output_shape", "layer.get_weights", "layer.compute_output_shape", "print"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.is_merge_layers", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.is_shape_alternation_layers", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QDense.compute_output_shape", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QDense.compute_output_shape", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QDense.compute_output_shape", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QDense.compute_output_shape", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QDense.compute_output_shape", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qlayers.QDense.compute_output_shape"], ["", "def", "get_operation_count", "(", "layer", ",", "input_shape", ")", ":", "\n", "  ", "\"\"\"Determines number of multiplier operations in a qkeras layer.\"\"\"", "\n", "\n", "# Check if the inputs are a list of Dimensions", "\n", "if", "isinstance", "(", "input_shape", ",", "list", ")", ":", "\n", "    ", "input_shape", "=", "input_shape", "[", "0", "]", "\n", "\n", "", "operation_count", "=", "0", "\n", "\n", "if", "is_merge_layers", "(", "layer", ")", "or", "is_shape_alternation_layers", "(", "layer", ")", ":", "\n", "    ", "operation_count", "=", "np", ".", "prod", "(", "input_shape", "[", "1", ":", "]", ")", "\n", "\n", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\n", "\"AveragePooling2D\"", ",", "\"AvgPool2D\"", ",", "\"GlobalAvgPool2D\"", ",", "\n", "\"GlobalAveragePooling2D\"", "\n", "]", ":", "\n", "\n", "    ", "if", "hasattr", "(", "layer", ",", "\"pool_size\"", ")", ":", "\n", "      ", "pool_size", "=", "layer", ".", "pool_size", "\n", "", "else", ":", "\n", "      ", "pool_size", "=", "input_shape", "[", "1", ":", "-", "1", "]", "\n", "", "add_ops", "=", "np", ".", "prod", "(", "pool_size", ")", "\n", "\n", "output_shape", "=", "layer", ".", "compute_output_shape", "(", "input_shape", ")", "\n", "channels_o", "=", "output_shape", "[", "-", "1", "]", "\n", "\n", "# total number of add ops", "\n", "operation_count", "=", "channels_o", "*", "add_ops", "\n", "\n", "", "elif", "\"UpSampling\"", "in", "layer", ".", "__class__", ".", "__name__", ":", "\n", "# UpSampling1D/2D/3D", "\n", "    ", "output_shape", "=", "layer", ".", "compute_output_shape", "(", "input_shape", ")", "\n", "operation_count", "=", "np", ".", "prod", "(", "output_shape", "[", "1", ":", "]", ")", "\n", "\n", "", "elif", "(", "\"Activation\"", "in", "layer", ".", "__class__", ".", "__name__", "or", "\n", "\"BatchNormalization\"", "in", "layer", ".", "__class__", ".", "__name__", ")", ":", "\n", "    ", "operation_count", "=", "np", ".", "prod", "(", "input_shape", "[", "1", ":", "]", ")", "\n", "\n", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"QConv2D\"", ",", "\"Conv2D\"", ",", "\"QConv2DBatchnorm\"", "]", ":", "\n", "\n", "    ", "output_shape", "=", "layer", ".", "compute_output_shape", "(", "input_shape", ")", "\n", "_", ",", "_", ",", "_", ",", "channels_i", "=", "input_shape", "\n", "\n", "_", ",", "height_o", ",", "width_o", ",", "channels_o", "=", "output_shape", "\n", "\n", "weight", "=", "layer", ".", "get_weights", "(", ")", "[", "0", "]", "\n", "\n", "kernel_h", ",", "kernel_w", ",", "_", ",", "_", "=", "weight", ".", "shape", "\n", "\n", "operation_count", "=", "(", "\n", "height_o", "*", "width_o", "*", "channels_o", "*", "kernel_h", "*", "kernel_w", "*", "channels_i", ")", "\n", "\n", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"QConv1D\"", ",", "\"Conv1D\"", "]", ":", "\n", "    ", "output_shape", "=", "layer", ".", "compute_output_shape", "(", "input_shape", ")", "\n", "_", ",", "_", ",", "channels_i", "=", "input_shape", "\n", "\n", "_", ",", "time_o", ",", "channels_o", "=", "output_shape", "\n", "\n", "weight", "=", "layer", ".", "get_weights", "(", ")", "[", "0", "]", "\n", "\n", "kernel_length", ",", "_", ",", "_", "=", "weight", ".", "shape", "\n", "\n", "operation_count", "=", "(", "\n", "time_o", "*", "channels_o", "*", "kernel_length", "*", "channels_i", ")", "\n", "\n", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"QDepthwiseConv2D\"", ",", "\"DepthwiseConv2D\"", "]", ":", "\n", "    ", "output_shape", "=", "layer", ".", "compute_output_shape", "(", "input_shape", ")", "\n", "_", ",", "_", ",", "_", ",", "channels_i", "=", "input_shape", "\n", "\n", "_", ",", "height_o", ",", "width_o", ",", "channels_o", "=", "output_shape", "\n", "\n", "weight_1", "=", "layer", ".", "get_weights", "(", ")", "[", "0", "]", "\n", "\n", "kernel_h", ",", "kernel_w", ",", "_", ",", "_", "=", "weight_1", ".", "shape", "\n", "\n", "operation_count", "=", "(", "\n", "kernel_h", "*", "kernel_w", "*", "height_o", "*", "width_o", "*", "channels_i", ")", "\n", "\n", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"QDense\"", ",", "\"Dense\"", "]", ":", "\n", "    ", "output_shape", "=", "layer", ".", "compute_output_shape", "(", "input_shape", ")", "\n", "_", ",", "size_i", "=", "input_shape", "\n", "_", ",", "size_o", "=", "output_shape", "\n", "\n", "operation_count", "=", "(", "size_i", "*", "size_o", ")", "\n", "\n", "", "else", ":", "\n", "    ", "print", "(", "\"operation count for {} is defaulted to 0\"", ".", "format", "(", "\n", "layer", ")", ")", "\n", "\n", "", "return", "int", "(", "operation_count", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights": [[204, 226], ["layer.get_weights", "copy.deepcopy", "enumerate", "hasattr", "tensorflow.eval", "layer.get_quantizers", "tensorflow.constant", "layer.get_quantizers"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers"], ["", "def", "get_weights", "(", "layer", ",", "model_weights_already_quantized", "=", "True", ")", ":", "\n", "  ", "\"\"\"Get layer weights.\n\n  Args:\n    layer: given qkeras/keras layer\n    model_weights_already_quantized: bool. whether the given layer's weights\n      are already quantized. This is necessary because with certain quantizers,\n      eg., quantized_bits(alpha=\"auto_po2\"), we cannot quantize the same\n      weights more than once, as it will lead to different results.\n\n  Return:\n    Quantized layer weights.\n  \"\"\"", "\n", "\n", "weights", "=", "layer", ".", "get_weights", "(", ")", "\n", "out", "=", "copy", ".", "deepcopy", "(", "weights", ")", "\n", "if", "not", "model_weights_already_quantized", ":", "\n", "    ", "for", "j", ",", "weight", "in", "enumerate", "(", "weights", ")", ":", "\n", "      ", "if", "hasattr", "(", "layer", ",", "\"get_quantizers\"", ")", "and", "layer", ".", "get_quantizers", "(", ")", "[", "j", "]", ":", "\n", "        ", "out", "[", "j", "]", "=", "K", ".", "eval", "(", "\n", "layer", ".", "get_quantizers", "(", ")", "[", "j", "]", "(", "K", ".", "constant", "(", "weight", ")", ")", ")", "\n", "", "", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.adjust_multiplier_for_auto_po2": [[228, 280], ["print", "hasattr", "hasattr", "qkeras_weight_quantizer.__str__", "np.squeeze.numpy", "isinstance", "print", "hasattr", "print", "numpy.squeeze", "int", "int", "isinstance", "numpy.log2", "numpy.log2", "int", "ValueError", "numpy.max", "numpy.min", "numpy.log2", "type", "type"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.__str__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min"], ["", "def", "adjust_multiplier_for_auto_po2", "(", "multiplier", ",", "qkeras_weight_quantizer", ")", ":", "\n", "  ", "\"\"\"Adjust multiplier when weight quantizer is auto_po2 type.\n\n  Multiplier_bits = bits_x + bits_w\n  Multiplier_intbits = log2(scale) + intbits_x + intbits_w\n\n  Because we might have different scale for auto_po2 quantizer at different\n  output channels, multiplier will have different integer bits at different\n  output channel accordingly, which is not desirable in hardware implementation.\n  Therefore we set a general multiplier quantizers so that it provides enough\n  fractional bits and integer bits for all output channels.\n  \"\"\"", "\n", "print", "(", "\"adjust multiplier for auto_po2 ...\"", ")", "\n", "output_quantizer", "=", "multiplier", ".", "output", "\n", "if", "(", "hasattr", "(", "qkeras_weight_quantizer", ",", "\"__str__\"", ")", "and", "\n", "\"quantized_bits\"", "in", "qkeras_weight_quantizer", ".", "__str__", "(", ")", "and", "\n", "qkeras_weight_quantizer", ".", "alpha", "==", "\"auto_po2\"", ")", ":", "\n", "    ", "bits", "=", "output_quantizer", ".", "bits", "\n", "int_bits", "=", "output_quantizer", ".", "int_bits", "\n", "scale", "=", "qkeras_weight_quantizer", ".", "scale", "\n", "if", "hasattr", "(", "scale", ",", "\"numpy\"", ")", ":", "\n", "# if scale doesn't have numpy() function, it means the quantizer has", "\n", "# never being called. Therfore we skip the following steps", "\n", "      ", "scale", "=", "scale", ".", "numpy", "(", ")", "\n", "if", "isinstance", "(", "scale", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "scale", "=", "np", ".", "squeeze", "(", "scale", ")", "\n", "max_shift", "=", "int", "(", "np", ".", "log2", "(", "np", ".", "max", "(", "scale", ")", ")", ")", "\n", "min_shift", "=", "int", "(", "np", ".", "log2", "(", "np", ".", "min", "(", "scale", ")", ")", ")", "\n", "", "elif", "isinstance", "(", "scale", ",", "float", ")", ":", "\n", "        ", "max_shift", "=", "int", "(", "np", ".", "log2", "(", "scale", ")", ")", "\n", "min_shift", "=", "max_shift", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"Scale should be either numpy array or float,\"", "\n", "f\"{type(scale)} is found instead!\"", ")", "\n", "\n", "# In order to set a general quantizer for different output channels,", "\n", "# we need to set both fractional bits and integer bits as the max required", "\n", "# bits for different output channels", "\n", "", "max_fractional_bits", "=", "bits", "-", "int_bits", "-", "min_shift", "\n", "max_int_bits", "=", "int_bits", "+", "max_shift", "\n", "total_bits", "=", "max_int_bits", "+", "max_fractional_bits", "\n", "\n", "output_quantizer", ".", "bits", "=", "total_bits", "\n", "output_quantizer", ".", "int_bits", "=", "max_int_bits", "\n", "", "else", ":", "\n", "      ", "print", "(", "\"[WARNING] The weight quantizer is never called even though it has \"", "\n", "\"alpha=auto_po2. In this case we do not adjust the multiplier and \"", "\n", "\"accumulator bit width since we don't know the exact values of \"", "\n", "\"scale\"", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "", "", "elif", "hasattr", "(", "qkeras_weight_quantizer", ",", "\"alpha\"", ")", "and", "(", "\n", "qkeras_weight_quantizer", ".", "alpha", "==", "\"auto_po2\"", ")", ":", "\n", "    ", "print", "(", "\"[WARNING] auto_po2 is detected on a non-quantized_bits quantizer.\"", "\n", "\"Currently in QTools we do not yet support the auto_po2 with the \"", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.adjust_accumulator_for_auto_po2": [[285, 319], ["copy.deepcopy", "qtools_util.adjust_multiplier_for_auto_po2", "layer.get_weights", "qkeras.qtools.quantized_operators.AccumulatorFactory", "quantized_operators.AccumulatorFactory.make_accumulator", "qkeras.qtools.quantized_operators.adder_factory.IAdder", "quantized_operators.adder_factory.IAdder.make_quantizer"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.adjust_multiplier_for_auto_po2", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.accumulator_factory.AccumulatorFactory.make_accumulator", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer"], ["", "", "def", "adjust_accumulator_for_auto_po2", "(", "\n", "layer", ",", "multiplier", ",", "qkeras_weight_quantizer", ",", "bias_quantizer", ")", ":", "\n", "  ", "\"\"\"Adjust accumulator when weight quantizer is auto_po2 type.\"\"\"", "\n", "\n", "fused_multiplier", "=", "copy", ".", "deepcopy", "(", "multiplier", ")", "\n", "adjust_multiplier_for_auto_po2", "(", "fused_multiplier", ",", "qkeras_weight_quantizer", ")", "\n", "weights", "=", "layer", ".", "get_weights", "(", ")", "\n", "kernel", "=", "weights", "[", "0", "]", "\n", "\n", "kernel_shape", "=", "kernel", ".", "shape", "\n", "# depthwise_kernel_shape = kernel_size + (input_dim, depth_multiplier)", "\n", "# When computing accumulator bitwidth for dw conv2d layer, we do not", "\n", "# need to count the last two dimensions", "\n", "if", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"QDepthwiseConv2D\"", ",", "\"DepthwiseConv2D\"", "]", ":", "\n", "    ", "assert", "kernel_shape", "[", "-", "1", "]", "==", "1", ",", "(", "\"depth_multiplier must be 1, \"", "\n", "f\"{kernel_shape[-1]} found instead!\"", ")", "\n", "kernel_shape", "=", "kernel", ".", "shape", "[", ":", "-", "2", "]", "+", "(", "1", ",", "1", ")", "\n", "\n", "", "kernel_accumulator_factory", "=", "quantized_operators", ".", "AccumulatorFactory", "(", ")", "\n", "# Sets use_bias=False so that the accumulator doesn't account for bias", "\n", "# bitwdith.", "\n", "fused_kernel_accumulator", "=", "kernel_accumulator_factory", ".", "make_accumulator", "(", "\n", "kernel_shape", ",", "fused_multiplier", ",", "use_bias", "=", "False", ")", "\n", "\n", "if", "not", "layer", ".", "use_bias", ":", "\n", "    ", "bias_quantizer", "=", "None", "\n", "fused_accumulator", "=", "fused_kernel_accumulator", "\n", "", "else", ":", "\n", "# Add bias quantizer bitwidth to the overall accumulator", "\n", "    ", "bias_accumulator_instance", "=", "quantized_operators", ".", "adder_factory", ".", "IAdder", "(", ")", "\n", "fused_accumulator", "=", "bias_accumulator_instance", ".", "make_quantizer", "(", "\n", "fused_kernel_accumulator", ".", "output", ",", "bias_quantizer", ")", "\n", "\n", "", "return", "fused_accumulator", "\n", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.qtools.generate_layer_data_type_map.get_bn_quantizers": [[70, 163], ["qkeras.qtools.quantized_operators.quantizer_factory.make_default_quantizer", "qkeras.qtools.quantized_operators.quantizer_factory.make_default_quantizer", "qkeras.qtools.quantized_operators.quantizer_factory.make_default_quantizer", "qkeras.qtools.quantized_operators.quantizer_factory.make_default_quantizer", "qkeras.qtools.quantized_operators.quantizer_factory.make_default_quantizer", "layer.get_quantizers", "qkeras.qtools.qtools_util.get_weights", "hasattr", "qkeras.qtools.quantized_operators.quantizer_factory.make_default_quantizer", "qkeras.qtools.quantized_operators.quantizer_factory.make_default_quantizer", "qkeras.qtools.quantized_operators.quantizer_factory.make_default_quantizer", "qkeras.qtools.quantized_operators.quantizer_factory.make_default_quantizer", "qkeras.qtools.quantized_operators.quantizer_factory.make_default_quantizer", "qkeras.qtools.quantized_operators.quantizer_factory.clone_quantizer", "qkeras.qtools.quantized_operators.quantizer_factory.make_quantizer", "qkeras.qtools.quantized_operators.quantizer_factory.clone_quantizer", "qkeras.qtools.quantized_operators.quantizer_factory.make_quantizer", "qkeras.qtools.quantized_operators.quantizer_factory.make_default_quantizer", "qkeras.qtools.quantized_operators.quantizer_factory.make_quantizer", "qkeras.qtools.quantized_operators.quantizer_factory.make_default_quantizer", "qkeras.qtools.quantized_operators.quantizer_factory.make_quantizer", "qkeras.qtools.quantized_operators.quantizer_factory.make_default_quantizer", "qkeras.qtools.quantized_operators.quantizer_factory.make_quantizer", "quantizer_factory.make_quantizer.update_inference_values", "quantizer_factory.make_quantizer.update_inference_values", "qkeras.qtools.quantized_operators.quantizer_factory", "qkeras.qtools.settings.cfg", "qkeras.qtools.quantized_operators.quantizer_factory", "qkeras.qtools.settings.cfg"], "function", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.clone_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.clone_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.PowerOfTwo.update_inference_values", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.PowerOfTwo.update_inference_values"], ["def", "get_bn_quantizers", "(", "layer", ",", "quantizer_factory", ",", "cfg", ",", "keras_quantizer", ",", "\n", "input_quantizer", ",", "is_inference", ",", "for_reference", ",", "\n", "model_weights_already_quantized", ")", ":", "\n", "  ", "\"\"\"Extract quantizers from a given batchnorm layer.\"\"\"", "\n", "\n", "# QKeras layers might be mixed with keras layers.", "\n", "if", "for_reference", "or", "not", "hasattr", "(", "layer", ",", "\"get_quantizers\"", ")", ":", "\n", "# Keras BatchNorm layer mixed with quantized model", "\n", "# -> no reference mode", "\n", "    ", "gamma_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", "\n", "beta_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", "\n", "mean_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", "\n", "variance_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", "\n", "inverse_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", "\n", "\n", "if", "keras_quantizer", ":", "\n", "      ", "gamma_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "keras_quantizer", ")", "\n", "beta_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "keras_quantizer", ")", "\n", "mean_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "keras_quantizer", ")", "\n", "variance_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "keras_quantizer", ")", "\n", "inverse_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "keras_quantizer", ")", "\n", "", "", "else", ":", "\n", "    ", "(", "qkeras_gamma_quantizer", ",", "qkeras_beta_quantizer", ",", "\n", "qkeras_mean_quantizer", ",", "qkeras_variance_quantizer", ",", "\n", "qkeras_inverse_quantizer", ")", "=", "layer", ".", "get_quantizers", "(", ")", "\n", "\n", "if", "not", "qkeras_beta_quantizer", ":", "\n", "      ", "beta_quantizer", "=", "quantizer_factory", ".", "clone_quantizer", "(", "input_quantizer", ")", "\n", "", "else", ":", "\n", "      ", "beta_quantizer", "=", "quantizer_factory", ".", "make_quantizer", "(", "\n", "qkeras_beta_quantizer", ")", "\n", "\n", "", "if", "not", "qkeras_mean_quantizer", ":", "\n", "      ", "mean_quantizer", "=", "quantizer_factory", ".", "clone_quantizer", "(", "input_quantizer", ")", "\n", "", "else", ":", "\n", "      ", "mean_quantizer", "=", "quantizer_factory", ".", "make_quantizer", "(", "\n", "qkeras_mean_quantizer", ")", "\n", "\n", "", "if", "not", "qkeras_variance_quantizer", ":", "\n", "      ", "variance_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", "\n", "", "else", ":", "\n", "# If variance is float, convert to input_quantizer.", "\n", "      ", "variance_quantizer", "=", "quantizer_factory", ".", "make_quantizer", "(", "\n", "qkeras_variance_quantizer", ")", "\n", "\n", "", "if", "not", "qkeras_gamma_quantizer", ":", "\n", "      ", "gamma_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", "\n", "", "else", ":", "\n", "      ", "gamma_quantizer", "=", "quantizer_factory", ".", "make_quantizer", "(", "\n", "qkeras_gamma_quantizer", ")", "\n", "\n", "", "if", "not", "qkeras_inverse_quantizer", ":", "\n", "      ", "inverse_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", "\n", "", "else", ":", "\n", "      ", "inverse_quantizer", "=", "quantizer_factory", ".", "make_quantizer", "(", "\n", "qkeras_inverse_quantizer", ")", "\n", "\n", "# During inference, gamma, beta and variance are constants", "\n", "# if they are po2 quantizers, we need to modify their bits", "\n", "# with actual values and also update graph with the", "\n", "# corresponding output_quantizer on the edge.", "\n", "", "", "if", "is_inference", ":", "\n", "    ", "weights", "=", "qtools_util", ".", "get_weights", "(", "\n", "layer", ",", "model_weights_already_quantized", ")", "\n", "# If no scale(gamma), num_weights --", "\n", "# If no center(beta_quantizer) num_weights --", "\n", "num_weights", "=", "4", "\n", "if", "not", "layer", ".", "scale", ":", "\n", "      ", "num_weights", "-=", "1", "\n", "", "if", "not", "layer", ".", "center", ":", "\n", "      ", "num_weights", "-=", "1", "\n", "\n", "", "if", "(", "layer", ".", "scale", "and", "gamma_quantizer", "is", "not", "None", "and", "gamma_quantizer", ".", "is_po2", ")", ":", "\n", "      ", "gamma_quantizer", ".", "update_inference_values", "(", "weights", "[", "0", "]", ")", "\n", "", "if", "(", "variance_quantizer", "is", "not", "None", "and", "variance_quantizer", ".", "is_po2", ")", ":", "\n", "      ", "variance_quantizer", ".", "update_inference_values", "(", "\n", "weights", "[", "num_weights", "-", "1", "]", ")", "\n", "\n", "", "", "return", "(", "gamma_quantizer", ",", "beta_quantizer", ",", "mean_quantizer", ",", "variance_quantizer", ",", "\n", "inverse_quantizer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.generate_layer_data_type_map.update_output_quantizer_in_graph": [[165, 185], ["qkeras.qtools.quantized_operators.quantizer_factory.make_quantizer", "qkeras.qtools.qgraph.GraphUpdateEdge", "qkeras.qtools.quantized_operators.quantizer_factory.is_quantizer_supported", "qkeras.qtools.quantized_operators.quantizer_factory", "qkeras.qtools.quantized_operators.quantizer_factory", "qkeras.qtools.quantized_operators.quantizer_factory", "qkeras.qtools.quantized_operators.quantizer_factory", "qkeras.qtools.quantized_operators.quantizer_factory", "qkeras.qtools.quantized_operators.quantizer_factory", "qkeras.qtools.quantized_operators.quantizer_factory", "qkeras.qtools.quantized_operators.quantizer_factory", "qkeras.qtools.quantized_operators.quantizer_factory", "qkeras.qtools.quantized_operators.quantizer_factory"], "function", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphUpdateEdge", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.is_quantizer_supported"], ["", "def", "update_output_quantizer_in_graph", "(", "graph", ",", "node_id", ",", "quantizer_factory", ",", "\n", "new_quantizer", ",", "for_reference", ")", ":", "\n", "  ", "\"\"\"update the edge with output quantizer type.\"\"\"", "\n", "\n", "node", "=", "graph", ".", "nodes", "[", "node_id", "]", "\n", "qkeras_output_quantizer", "=", "node", "[", "\"out_quantizer\"", "]", "\n", "\n", "# If existing graph doesn't have a valid output quantizer", "\n", "# update graph with the new quantizer", "\n", "if", "(", "for_reference", "or", "not", "qkeras_output_quantizer", "or", "\n", "not", "quantizer_factory", ".", "is_quantizer_supported", "(", "qkeras_output_quantizer", ")", ")", ":", "\n", "    ", "qkeras_output_quantizer", "=", "new_quantizer", "\n", "qgraph", ".", "GraphUpdateEdge", "(", "graph", ",", "node_id", ",", "qkeras_output_quantizer", ")", "\n", "\n", "# If activation specified, convert activation quantizer to qtools quantizer", "\n", "# If activation not secified, convert the new quantizer to qtools quantizer", "\n", "", "output_quantizer", "=", "quantizer_factory", ".", "make_quantizer", "(", "qkeras_output_quantizer", ")", "\n", "\n", "# Output_quantizer is used for updating dictionary in json", "\n", "return", "output_quantizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.generate_layer_data_type_map.generate_layer_data_type_map": [[187, 929], ["qkeras.qtools.quantized_operators.quantizer_factory.QuantizerFactory", "collections.OrderedDict", "list", "list", "networkx.topological_sort", "graph.predecessors", "graph.successors", "output_layers.append", "input_layers.append", "hasattr", "hasattr", "qkeras.qtools.qtools_util.get_input_quantizers_advanced", "qkeras.qtools.qtools_util.is_merge_layers", "layer.get_weights", "print", "qkeras.qtools.qtools_util.get_operation_count", "qkeras.qtools.quantized_operators.MergeFactory", "quantized_operators.MergeFactory.make_quantizer", "generate_layer_data_type_map.update_output_quantizer_in_graph", "LayerDataType", "len", "print", "print", "input_quantizer_list.append", "len", "enumerate", "qkeras.qtools.qtools_util.is_shape_alternation_layers", "generate_layer_data_type_map.update_output_quantizer_in_graph", "LayerDataType", "numpy.prod", "quantizer_factory_module.QuantizerFactory.make_default_quantizer", "quantizer_factory_module.QuantizerFactory.make_default_quantizer", "qkeras.qtools.quantized_operators.MultiplierFactory", "quantized_operators.MultiplierFactory.make_multiplier", "qkeras.qtools.quantized_operators.AccumulatorFactory", "quantized_operators.AccumulatorFactory.make_accumulator", "generate_layer_data_type_map.update_output_quantizer_in_graph", "layer.get_weights", "tuple", "tuple", "quantizer_factory_module.QuantizerFactory.make_quantizer", "quantized_operators.MultiplierFactory.make_multiplier", "print", "generate_layer_data_type_map.update_output_quantizer_in_graph", "LayerDataType", "layer.get_quantizers", "quantizer_factory_module.QuantizerFactory.make_default_quantizer", "quantizer_factory_module.QuantizerFactory.make_default_quantizer", "quantizer_factory_module.QuantizerFactory.make_default_quantizer", "list", "quantizer_factory_module.QuantizerFactory.make_default_quantizer", "quantizer_factory_module.QuantizerFactory.make_default_quantizer", "hasattr", "quantizer_factory_module.QuantizerFactory.make_default_quantizer", "quantizer_factory_module.QuantizerFactory.is_quantizer_supported", "generate_layer_data_type_map.TagMissingError", "quantizer_factory_module.QuantizerFactory.make_default_quantizer", "generate_layer_data_type_map.update_output_quantizer_in_graph", "generate_layer_data_type_map.get_bn_quantizers", "qkeras.qtools.quantized_operators.QBNFactory", "quantized_operators.QBNFactory.make_quantizer", "hasattr", "hasattr", "generate_layer_data_type_map.update_output_quantizer_in_graph", "qkeras.qtools.quantized_operators.MultiplierFactory", "quantized_operators.MultiplierFactory.make_multiplier", "layer.get_weights", "qkeras.qtools.quantized_operators.AccumulatorFactory", "quantized_operators.AccumulatorFactory.make_accumulator", "list", "quantizer_factory_module.QuantizerFactory.make_default_quantizer", "generate_layer_data_type_map.generate_layer_data_type_map.set_output"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_input_quantizers_advanced", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.is_merge_layers", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_operation_count", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qtools.generate_layer_data_type_map.update_output_quantizer_in_graph", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.is_shape_alternation_layers", "home.repos.pwc.inspect_result.google_qkeras.qtools.generate_layer_data_type_map.update_output_quantizer_in_graph", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_factory.MultiplierFactory.make_multiplier", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.accumulator_factory.AccumulatorFactory.make_accumulator", "home.repos.pwc.inspect_result.google_qkeras.qtools.generate_layer_data_type_map.update_output_quantizer_in_graph", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_factory.MultiplierFactory.make_multiplier", "home.repos.pwc.inspect_result.google_qkeras.qtools.generate_layer_data_type_map.update_output_quantizer_in_graph", "home.repos.pwc.inspect_result.google_qkeras.qkeras.qconvolutional.QDepthwiseConv2D.get_quantizers", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.is_quantizer_supported", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qtools.generate_layer_data_type_map.update_output_quantizer_in_graph", "home.repos.pwc.inspect_result.google_qkeras.qtools.generate_layer_data_type_map.get_bn_quantizers", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qtools.generate_layer_data_type_map.update_output_quantizer_in_graph", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_factory.MultiplierFactory.make_multiplier", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.accumulator_factory.AccumulatorFactory.make_accumulator", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer"], ["", "def", "generate_layer_data_type_map", "(", "\n", "graph", ",", "source_quantizer_list", ",", "is_inference", ",", "\n", "keras_quantizer", "=", "None", ",", "keras_accumulator", "=", "None", ",", "\n", "for_reference", "=", "False", ",", "debug", "=", "False", ",", "\n", "model_weights_already_quantized", "=", "True", ",", "\n", "hw_weight_dict", "=", "None", ")", ":", "\n", "  ", "\"\"\"main funciton to generate datatype for each layer.\n\n  For each type of layer, this function calculates the sizes and minimum\n  number of bits required to represent the parameters and variables (e.g.,\n  weights, bias, multiplier and accumulator - MAC, etc.) embedded in\n  these layers.\n\n  Args:\n    graph: input graph that traverses the model\n    source_quantizer_list: a list of quantizers for model inputs\n    is_inference: whether model is pre-trained with weights available\n    keras_quantizer: default quantizer used to quantize weights and bias\n    keras_accumulator: default MAC quantizer to quantize multiplier,\n      accumulator and output\n    for_reference: whether to generate a map for a baseline model\n    debug: whether to print debug messages\n    model_weights_already_quantized: bool. If model weights are already\n      quantized, no need to apply quantizer to weights here in this function.\n    hw_weight_dict: weight dictonary for hardware inference. For example, fused\n      bn op inference in hardware will need additional fused weights, which\n      can be extracted from this dictionary. This dictionary is the output from\n      utils.py/model_save_quantized_weights function.\n\n  Returns:\n    a result containing the following fields:\n    source_quantizer_list similar as input\n    output_layers: names of the layers that are output layers\n    input_layers: names of the layers that are input_layers,\n    layer_data_type_map: data type map of each layer\n  \"\"\"", "\n", "\n", "quantizer_factory", "=", "quantizer_factory_module", ".", "QuantizerFactory", "(", ")", "\n", "layer_data_type_map", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "\n", "# get the output layers", "\n", "\n", "output_layers", "=", "[", "]", "\n", "input_layers", "=", "[", "]", "\n", "predecessors", "=", "list", "(", "graph", ".", "predecessors", "(", "qgraph", ".", "SINK", ")", ")", "\n", "successors", "=", "list", "(", "graph", ".", "successors", "(", "qgraph", ".", "SOURCE", ")", ")", "\n", "\n", "for", "u", "in", "predecessors", ":", "\n", "    ", "if", "u", "==", "qgraph", ".", "SOURCE", "or", "u", "==", "qgraph", ".", "SINK", ":", "\n", "      ", "continue", "\n", "", "output_layers", ".", "append", "(", "graph", ".", "nodes", "[", "u", "]", "[", "\"layer\"", "]", "[", "0", "]", ")", "\n", "\n", "", "for", "u", "in", "successors", ":", "\n", "    ", "if", "u", "==", "qgraph", ".", "SOURCE", "or", "u", "==", "qgraph", ".", "SINK", ":", "\n", "      ", "continue", "\n", "", "input_layers", ".", "append", "(", "graph", ".", "nodes", "[", "u", "]", "[", "\"layer\"", "]", "[", "0", "]", ")", "\n", "\n", "", "for", "node_id", "in", "nx", ".", "topological_sort", "(", "graph", ")", ":", "\n", "    ", "node", "=", "graph", ".", "nodes", "[", "node_id", "]", "\n", "node_type", "=", "node", "[", "\"type\"", "]", "[", "-", "1", "]", "\n", "layer", "=", "node", "[", "\"layer\"", "]", "[", "0", "]", "\n", "is_input_layer", "=", "layer", "in", "input_layers", "\n", "\n", "w_shapes", "=", "None", "\n", "b_shapes", "=", "None", "\n", "output_shapes", "=", "None", "\n", "qkeras_weight_quantizer", "=", "None", "\n", "\n", "if", "hasattr", "(", "layer", ",", "\"output_shape\"", ")", ":", "\n", "      ", "output_shapes", "=", "layer", ".", "output_shape", "\n", "\n", "", "if", "hasattr", "(", "layer", ",", "\"get_weights\"", ")", ":", "\n", "      ", "weights", "=", "layer", ".", "get_weights", "(", ")", "\n", "if", "len", "(", "weights", ")", "!=", "0", ":", "\n", "        ", "w_shapes", "=", "layer", ".", "get_weights", "(", ")", "[", "0", "]", ".", "shape", "\n", "b_shapes", "=", "weights", "[", "0", "]", ".", "shape", "[", "-", "1", "]", "\n", "\n", "", "", "if", "debug", ":", "\n", "      ", "print", "(", "\"########\"", ")", "\n", "if", "layer", "is", "not", "None", ":", "\n", "        ", "print", "(", "layer", ".", "name", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "\"None\"", ")", "\n", "\n", "# Deals with keras layer or lack of input quantizer in qkeras layer.", "\n", "", "", "input_qe_list", "=", "qtools_util", ".", "get_input_quantizers_advanced", "(", "\n", "graph", ",", "node_id", ",", "is_input_layer", ",", "quantizer_factory", ",", "cfg", ")", "\n", "\n", "if", "input_qe_list", "and", "node_id", "!=", "qgraph", ".", "SINK", ":", "\n", "      ", "input_quantizer_list", "=", "[", "]", "\n", "for", "node", "in", "input_qe_list", ":", "\n", "        ", "input_quantizer_list", ".", "append", "(", "node", "[", "0", "]", ")", "\n", "\n", "# Calculates number of operations (multiplication/accumulation).", "\n", "# Previously Merge layers's inputs all have the same shape, however, in", "\n", "# MobilenetV3 we found that there is shape broadcast in the keras", "\n", "# Multiply layer. Therefore we use the shape with max size as the", "\n", "# input shape", "\n", "", "if", "len", "(", "input_qe_list", ")", ">", "0", ":", "\n", "        ", "maxsize", "=", "-", "1", "\n", "max_id", "=", "0", "\n", "for", "(", "idx", ",", "item", ")", "in", "enumerate", "(", "input_qe_list", ")", ":", "\n", "          ", "shape", "=", "item", "[", "1", "]", "[", "\"shape\"", "]", "\n", "size", "=", "np", ".", "prod", "(", "shape", "[", "1", ":", "]", ")", "\n", "if", "size", ">", "maxsize", ":", "\n", "            ", "maxsize", "=", "size", "\n", "max_id", "=", "idx", "\n", "", "", "input_shape", "=", "input_qe_list", "[", "max_id", "]", "[", "1", "]", "[", "\"shape\"", "]", "\n", "", "else", ":", "\n", "        ", "(", "_", ",", "edge_0", ")", "=", "input_qe_list", "[", "0", "]", "\n", "input_shape", "=", "edge_0", "[", "\"shape\"", "]", "\n", "\n", "", "operation_count", "=", "qtools_util", ".", "get_operation_count", "(", "\n", "layer", ",", "input_shape", ")", "\n", "\n", "# Merges layers with multiple inputs.", "\n", "", "if", "qtools_util", ".", "is_merge_layers", "(", "layer", ")", ":", "\n", "\n", "# merge_factory.make_quantizer automatically calculates the merge output", "\n", "# quantizer bitwidth according to input quantizer type.", "\n", "      ", "merge_factory", "=", "quantized_operators", ".", "MergeFactory", "(", ")", "\n", "merge_quantizer", "=", "merge_factory", ".", "make_quantizer", "(", "\n", "input_qe_list", ",", "layer", ".", "__class__", ".", "__name__", ")", "\n", "\n", "if", "for_reference", ":", "\n", "# The for_reference option overwrites the auto-calculated merge output", "\n", "# quantizer", "\n", "        ", "if", "keras_accumulator", ":", "\n", "# gate_factor and gate_bits remain the same as previously", "\n", "# calculated; only change output quantizer as the keras_accumulator", "\n", "          ", "merge_quantizer", ".", "output", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "keras_accumulator", ")", "\n", "", "else", ":", "\n", "          ", "merge_quantizer", ".", "output", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", "\n", "\n", "", "", "output_quantizer", "=", "update_output_quantizer_in_graph", "(", "\n", "graph", ",", "node_id", ",", "quantizer_factory", ",", "merge_quantizer", ".", "output", ",", "\n", "for_reference", ")", "\n", "\n", "layer_data_type_map", "[", "layer", "]", "=", "LayerDataType", "(", "\n", "input_quantizer_list", ",", "\n", "merge_quantizer", ",", "\n", "None", ",", "\n", "\n", "None", ",", "\n", "None", ",", "\n", "\n", "None", ",", "\n", "None", ",", "\n", "\n", "output_quantizer", ",", "\n", "output_shapes", ",", "\n", "\n", "operation_count", "\n", ")", "\n", "\n", "# MaxPooling/reshape/flatten/UpSampling1D/2D/3D", "\n", "", "elif", "(", "qtools_util", ".", "is_shape_alternation_layers", "(", "layer", ")", "or", "\n", "\"UpSampling\"", "in", "layer", ".", "__class__", ".", "__name__", ")", ":", "\n", "      ", "input_quantizer", "=", "input_quantizer_list", "[", "0", "]", "\n", "\n", "# Output quantizer", "\n", "output_quantizer", "=", "update_output_quantizer_in_graph", "(", "\n", "graph", ",", "node_id", ",", "quantizer_factory", ",", "input_quantizer", ",", "for_reference", ")", "\n", "\n", "layer_data_type_map", "[", "layer", "]", "=", "LayerDataType", "(", "\n", "input_quantizer_list", ",", "\n", "None", ",", "\n", "None", ",", "\n", "\n", "None", ",", "\n", "None", ",", "\n", "\n", "None", ",", "\n", "None", ",", "\n", "\n", "output_quantizer", ",", "\n", "output_shapes", ",", "\n", "\n", "operation_count", "\n", ")", "\n", "\n", "# AveragePooling and GlobalAveragePooling", "\n", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\n", "\"AveragePooling2D\"", ",", "\"AvgPool2D\"", ",", "\"GlobalAvgPool2D\"", ",", "\n", "\"GlobalAveragePooling2D\"", ",", "\"QAveragePooling2D\"", ",", "\n", "\"QGlobalAveragePooling2D\"", "]", ":", "\n", "      ", "(", "input_quantizer", ",", "_", ")", "=", "input_qe_list", "[", "0", "]", "\n", "qtools_average_quantizer", "=", "None", "\n", "# This is a hack. We don't want to implement a new accumulator class", "\n", "# just for averagpooling. So we re-use accumulator type in conv/dense", "\n", "# layers which need multiplier and kernel as input parameters.", "\n", "# In order to do so, we fake a multiplier which treat the pool_size as", "\n", "# the kernel. since kernel needs 4 dimension, k_h, k_w, C_in, C_out,", "\n", "# we set the last two dimension as [1, 1]", "\n", "if", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"AveragePooling2D\"", ",", "\"AvgPool2D\"", ",", "\n", "\"QAveragePooling2D\"", "]", ":", "\n", "        ", "pool_size", "=", "tuple", "(", "list", "(", "layer", ".", "pool_size", ")", "+", "[", "1", ",", "1", "]", ")", "\n", "", "else", ":", "\n", "        ", "pool_size", "=", "tuple", "(", "list", "(", "input_shape", ")", "[", "1", ":", "-", "1", "]", "+", "[", "1", ",", "1", "]", ")", "\n", "\n", "# Automatically calculates the accumulator bitwidth according to input", "\n", "# quantizer type for both quantized pooling and regular pooling layers", "\n", "", "multiplier_factory", "=", "quantized_operators", ".", "MultiplierFactory", "(", ")", "\n", "fake_multiplier", "=", "multiplier_factory", ".", "make_multiplier", "(", "\n", "input_quantizer", ",", "input_quantizer", ")", "\n", "fake_multiplier", ".", "output", "=", "input_quantizer", "\n", "accumulator_factory", "=", "quantized_operators", ".", "AccumulatorFactory", "(", ")", "\n", "accumulator", "=", "accumulator_factory", ".", "make_accumulator", "(", "\n", "pool_size", ",", "fake_multiplier", ",", "use_bias", "=", "False", ")", "\n", "\n", "# For quantized pooling layers, we also need to consider the division", "\n", "# precision, which is controlled by the average quantizer", "\n", "if", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"QAveragePooling2D\"", ",", "\n", "\"QGlobalAveragePooling2D\"", "]", ":", "\n", "# For the quantized layer, there is an average_quantizer used for", "\n", "# the inverse of division operation.", "\n", "        ", "qkeras_average_quantizer", "=", "layer", ".", "get_quantizers", "(", ")", "[", "0", "]", "\n", "qtools_average_quantizer", "=", "quantizer_factory", ".", "make_quantizer", "(", "\n", "qkeras_average_quantizer", ")", "\n", "multiplier", "=", "multiplier_factory", ".", "make_multiplier", "(", "\n", "accumulator", ".", "output", ",", "qtools_average_quantizer", ")", "\n", "", "else", ":", "\n", "        ", "multiplier", "=", "None", "\n", "", "if", "debug", ":", "\n", "        ", "print", "(", "\"accumulator:\"", ",", "accumulator", ".", "output", ".", "bits", ")", "\n", "\n", "# Re-calcualte accumulator/multiplier type when it's using", "\n", "# for_reference option", "\n", "", "if", "for_reference", ":", "\n", "        ", "if", "keras_accumulator", ":", "\n", "# If keras_accumulator exists, use keras_accumulator as multiplier", "\n", "# or accumulator type", "\n", "          ", "if", "multiplier", ":", "\n", "# Quantized layers need to define multiplier type", "\n", "            ", "multiplier", ".", "output", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "keras_accumulator", ")", "\n", "", "accumulator", ".", "output", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "keras_accumulator", ")", "\n", "", "else", ":", "\n", "# If user didn't provide keras_accumulator, use the default settings", "\n", "# in cfg to define multiplier/accumulator type", "\n", "          ", "if", "multiplier", ":", "\n", "            ", "multiplier", ".", "output", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", "\n", "", "accumulator", ".", "output", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", "\n", "", "layer_quantizer", "=", "accumulator", ".", "output", "\n", "\n", "# set the output quantizer", "\n", "", "if", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"QAveragePooling2D\"", ",", "\n", "\"QGlobalAveragePooling2D\"", "]", ":", "\n", "# If is quantized layer, last operation is multiply (averaging).", "\n", "        ", "layer_quantizer", "=", "multiplier", ".", "output", "\n", "", "else", ":", "\n", "        ", "layer_quantizer", "=", "accumulator", ".", "output", "\n", "", "output_quantizer", "=", "update_output_quantizer_in_graph", "(", "\n", "graph", ",", "node_id", ",", "quantizer_factory", ",", "layer_quantizer", ",", "for_reference", ")", "\n", "\n", "layer_data_type_map", "[", "layer", "]", "=", "{", "\n", "\"input_quantizer_list\"", ":", "input_quantizer_list", ",", "\n", "\"average_quantizer\"", ":", "qtools_average_quantizer", ",", "\n", "\"pool_sum_accumulator\"", ":", "accumulator", ",", "\n", "\"pool_avg_multiplier\"", ":", "multiplier", ",", "\n", "\"output_quantizer\"", ":", "output_quantizer", ",", "\n", "\"output_shapes\"", ":", "output_shapes", ",", "\n", "\"operation_count\"", ":", "operation_count", "\n", "}", "\n", "\n", "# If it's a Quantized Activation layer.", "\n", "", "elif", "node_type", "in", "[", "\"QActivation\"", ",", "\"QAdaptiveActivation\"", ",", "\"Activation\"", "]", ":", "\n", "\n", "      ", "if", "for_reference", "or", "not", "hasattr", "(", "layer", ",", "\"quantizer\"", ")", ":", "\n", "# Keras activation layer -> use default_interm_quantizer", "\n", "        ", "layer_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", "\n", "\n", "if", "keras_accumulator", ":", "\n", "          ", "layer_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "keras_accumulator", ")", "\n", "", "", "else", ":", "\n", "        ", "layer_quantizer", "=", "layer", ".", "quantizer", "\n", "\n", "if", "not", "quantizer_factory", ".", "is_quantizer_supported", "(", "layer_quantizer", ")", ":", "\n", "          ", "raise", "TagMissingError", "(", "\n", "\"Unsupported activation quantizer {} on this layer: {}\"", ".", "format", "(", "\n", "layer_quantizer", ",", "layer", ")", ")", "\n", "\n", "", "if", "not", "layer_quantizer", ":", "\n", "          ", "layer_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", "\n", "\n", "", "", "output_quantizer", "=", "update_output_quantizer_in_graph", "(", "\n", "graph", ",", "node_id", ",", "quantizer_factory", ",", "layer_quantizer", ",", "for_reference", ")", "\n", "\n", "layer_data_type_map", "[", "layer", "]", "=", "LayerDataType", "(", "\n", "input_quantizer_list", ",", "\n", "None", ",", "\n", "None", ",", "\n", "None", ",", "\n", "w_shapes", ",", "\n", "None", ",", "\n", "b_shapes", ",", "\n", "output_quantizer", ",", "\n", "output_shapes", ",", "\n", "operation_count", "\n", ")", "\n", "\n", "", "elif", "node_type", "in", "[", "\"QBatchNormalization\"", ",", "\"BatchNormalization\"", "]", ":", "\n", "# If this batchnorm layer needs to be fused with the previous layer,", "\n", "# we pass the input quantizer type as the output type in qraph.", "\n", "\n", "      ", "(", "input_quantizer", ",", "_", ")", "=", "input_qe_list", "[", "0", "]", "\n", "\n", "if", "(", "hw_weight_dict", "is", "not", "None", "and", "\n", "hw_weight_dict", "[", "layer", ".", "name", "]", "[", "\"enable_bn_fusing\"", "]", ")", ":", "\n", "        ", "if", "for_reference", "and", "keras_accumulator", "and", "not", "is_input_layer", ":", "\n", "          ", "input_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "keras_accumulator", ")", "\n", "", "output_quantizer", "=", "update_output_quantizer_in_graph", "(", "\n", "graph", ",", "node_id", ",", "quantizer_factory", ",", "input_quantizer", ",", "for_reference", ")", "\n", "layer_data_type_map", "[", "layer", "]", "=", "{", "\n", "\"input_quantizer_list\"", ":", "input_quantizer_list", ",", "\n", "\"output_quantizer\"", ":", "output_quantizer", ",", "\n", "\"output_shapes\"", ":", "input_shape", ",", "\n", "\"operation_count\"", ":", "operation_count", "\n", "}", "\n", "", "else", ":", "\n", "        ", "(", "gamma_quantizer", ",", "beta_quantizer", ",", "mean_quantizer", ",", "variance_quantizer", ",", "\n", "_", ")", "=", "get_bn_quantizers", "(", "layer", ",", "quantizer_factory", ",", "cfg", ",", "keras_quantizer", ",", "\n", "input_quantizer", ",", "is_inference", ",", "for_reference", ",", "\n", "model_weights_already_quantized", ")", "\n", "\n", "qbn", "=", "quantized_operators", ".", "QBNFactory", "(", ")", "\n", "qbn", ".", "make_quantizer", "(", "\n", "input_quantizer", ",", "gamma_quantizer", ",", "beta_quantizer", ",", "\n", "mean_quantizer", ",", "variance_quantizer", ",", "layer", ".", "scale", ",", "layer", ".", "center", "\n", ")", "\n", "\n", "def", "set_output", "(", "op", ",", "output", ")", ":", "\n", "          ", "if", "op", ":", "\n", "            ", "op", ".", "output", "=", "output", "\n", "\n", "", "", "if", "for_reference", "or", "not", "hasattr", "(", "layer", ",", "\"get_quantizers\"", ")", ":", "\n", "          ", "set_output", "(", "\n", "qbn", ".", "internal_divide_quantizer", ",", "\n", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", ")", "\n", "\n", "set_output", "(", "\n", "qbn", ".", "internal_multiplier", ",", "\n", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", ")", "\n", "\n", "set_output", "(", "\n", "qbn", ".", "internal_accumulator", ",", "\n", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", ")", "\n", "\n", "set_output", "(", "\n", "qbn", ".", "internal_output", ",", "\n", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", ")", "\n", "\n", "if", "keras_accumulator", ":", "\n", "            ", "set_output", "(", "\n", "qbn", ".", "internal_divide_quantizer", ",", "\n", "quantizer_factory", ".", "make_default_quantizer", "(", "mode", "=", "keras_accumulator", ")", ")", "\n", "\n", "set_output", "(", "\n", "qbn", ".", "internal_multiplier", ",", "\n", "quantizer_factory", ".", "make_default_quantizer", "(", "mode", "=", "keras_accumulator", ")", ")", "\n", "\n", "set_output", "(", "\n", "qbn", ".", "internal_accumulator", ",", "\n", "quantizer_factory", ".", "make_default_quantizer", "(", "mode", "=", "keras_accumulator", ")", ")", "\n", "\n", "set_output", "(", "\n", "qbn", ".", "internal_output", ".", "output", ",", "\n", "quantizer_factory", ".", "make_default_quantizer", "(", "mode", "=", "keras_accumulator", ")", ")", "\n", "\n", "", "", "gamma_range", "=", "None", "\n", "if", "hasattr", "(", "layer", ",", "\"gamma_range\"", ")", ":", "\n", "          ", "gamma_range", "=", "layer", ".", "gamma_range", "\n", "\n", "", "beta_range", "=", "None", "\n", "if", "hasattr", "(", "layer", ",", "\"beta_range\"", ")", ":", "\n", "          ", "beta_range", "=", "layer", ".", "beta_range", "\n", "\n", "", "if", "not", "layer", ".", "center", ":", "\n", "          ", "qbn", ".", "beta_quantizer", "=", "None", "\n", "\n", "", "if", "not", "layer", ".", "scale", ":", "\n", "          ", "qbn", ".", "gamma_quantizer", "=", "None", "\n", "\n", "", "layer_quantizer", "=", "qbn", ".", "internal_output", ".", "output", "\n", "output_quantizer", "=", "update_output_quantizer_in_graph", "(", "\n", "graph", ",", "node_id", ",", "quantizer_factory", ",", "layer_quantizer", ",", "for_reference", ")", "\n", "layer_data_type_map", "[", "layer", "]", "=", "{", "\n", "\"input_quantizer_list\"", ":", "input_quantizer_list", ",", "\n", "\"gamma_quantizer\"", ":", "gamma_quantizer", ",", "\n", "\"beta_quantizer\"", ":", "beta_quantizer", ",", "\n", "\"mean_quantizer\"", ":", "mean_quantizer", ",", "\n", "\"variance_quantizer\"", ":", "variance_quantizer", ",", "\n", "\"gamma_range\"", ":", "gamma_range", ",", "\n", "\"beta_range\"", ":", "beta_range", ",", "\n", "\"internal_divide_quantizer\"", ":", "qbn", ".", "internal_divide_quantizer", ",", "\n", "\"internal_multiplier\"", ":", "qbn", ".", "internal_multiplier", ",", "\n", "\"internal_accumulator\"", ":", "qbn", ".", "internal_accumulator", ",", "\n", "\"output_quantizer\"", ":", "output_quantizer", ",", "\n", "\"output_shapes\"", ":", "input_shape", ",", "\n", "\"operation_count\"", ":", "operation_count", "\n", "}", "\n", "# If qdense, qconv, qpool, qoctave", "\n", "", "", "elif", "node_type", "in", "QKERAS_LAYERS", "or", "node_type", "in", "KERAS_LAYERS", ":", "\n", "      ", "(", "input_quantizer", ",", "_", ")", "=", "input_qe_list", "[", "0", "]", "\n", "\n", "if", "for_reference", "or", "not", "hasattr", "(", "layer", ",", "\"get_quantizers\"", ")", ":", "\n", "# for_reference: force all quantizers to keras_quantizer", "\n", "        ", "weight_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", "\n", "bias_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", "\n", "\n", "if", "keras_quantizer", ":", "\n", "          ", "weight_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "keras_quantizer", ")", "\n", "bias_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "keras_quantizer", ")", "\n", "", "", "else", ":", "\n", "# qkeras layer", "\n", "        ", "qkeras_weight_quantizer", "=", "layer", ".", "get_quantizers", "(", ")", "[", "0", "]", "\n", "qkeras_bias_quantizer", "=", "layer", ".", "get_quantizers", "(", ")", "[", "1", "]", "\n", "\n", "if", "not", "quantizer_factory", ".", "is_quantizer_supported", "(", "\n", "qkeras_weight_quantizer", ")", ":", "\n", "          ", "raise", "TagMissingError", "(", "\n", "\"Unsupported weight quantizer {} on this layer: {}\"", ".", "format", "(", "\n", "qkeras_weight_quantizer", ",", "layer", ")", ")", "\n", "\n", "", "if", "not", "quantizer_factory", ".", "is_quantizer_supported", "(", "\n", "qkeras_bias_quantizer", ")", ":", "\n", "          ", "raise", "TagMissingError", "(", "\n", "\"Unsupported bias quantizer {} on this layer: {}\"", ".", "format", "(", "\n", "qkeras_bias_quantizer", ",", "layer", ")", ")", "\n", "\n", "", "weight_quantizer", "=", "quantizer_factory", ".", "make_quantizer", "(", "\n", "qkeras_weight_quantizer", ")", "\n", "bias_quantizer", "=", "quantizer_factory", ".", "make_quantizer", "(", "\n", "qkeras_bias_quantizer", ")", "\n", "\n", "# TODO(lishanok): During inference, if weight and bias is po2,", "\n", "#  need to update corresponding quantizer type with min and max", "\n", "#  of the constant values.", "\n", "", "if", "is_inference", ":", "\n", "        ", "weights", "=", "qtools_util", ".", "get_weights", "(", "\n", "layer", ",", "model_weights_already_quantized", ")", "\n", "if", "weight_quantizer", ".", "is_po2", ":", "\n", "          ", "weight_quantizer", ".", "update_inference_values", "(", "weights", "[", "0", "]", ")", "\n", "\n", "", "if", "bias_quantizer", ".", "is_po2", ":", "\n", "          ", "bias_quantizer", ".", "update_inference_values", "(", "weights", "[", "1", "]", ")", "\n", "\n", "", "", "multiplier_factory", "=", "quantized_operators", ".", "MultiplierFactory", "(", ")", "\n", "multiplier", "=", "multiplier_factory", ".", "make_multiplier", "(", "\n", "weight_quantizer", ",", "input_quantizer", ")", "\n", "\n", "enable_bn_fusing", "=", "(", "\n", "hw_weight_dict", "is", "not", "None", "and", "hw_weight_dict", ".", "get", "(", "layer", ".", "name", ",", "None", ")", "\n", "and", "hw_weight_dict", "[", "layer", ".", "name", "]", ".", "get", "(", "\"enable_bn_fusing\"", ",", "None", ")", ")", "\n", "\n", "if", "enable_bn_fusing", "and", "qkeras_weight_quantizer", ":", "\n", "# When conv layer is fused wiht bn, multiplier bitwidth is ajusted by", "\n", "# kernel quantizer scale values (for auto_po2 type of quantizer only).", "\n", "# For conv layer without fusing, multiplier bitwidth is not adjusted", "\n", "# even if auto_po2 is used in quantizer. Instead, we directly adjusted", "\n", "# the accumulator and store that in fused_accumulator.", "\n", "        ", "qtools_util", ".", "adjust_multiplier_for_auto_po2", "(", "\n", "multiplier", ",", "qkeras_weight_quantizer", ")", "\n", "\n", "", "weights", "=", "layer", ".", "get_weights", "(", ")", "\n", "kernel", "=", "weights", "[", "0", "]", "\n", "\n", "kernel_shape", "=", "kernel", ".", "shape", "\n", "# depthwise_kernel_shape = kernel_size + (input_dim, depth_multiplier)", "\n", "# When computing accumulator bitwidth for dw conv2d layer, we do not", "\n", "# need to count the last two dimensions", "\n", "if", "node_type", "in", "[", "\"QDepthwiseConv2D\"", ",", "\"DepthwiseConv2D\"", "]", ":", "\n", "        ", "kernel_shape", "=", "kernel", ".", "shape", "[", ":", "-", "2", "]", "+", "(", "1", ",", "1", ")", "\n", "\n", "", "kernel_accumulator_factory", "=", "quantized_operators", ".", "AccumulatorFactory", "(", ")", "\n", "# Sets use_bias=False so that the accumulator doesn't account for bias", "\n", "# bitwdith.", "\n", "kernel_accumulator", "=", "kernel_accumulator_factory", ".", "make_accumulator", "(", "\n", "kernel_shape", ",", "multiplier", ",", "use_bias", "=", "False", ")", "\n", "\n", "if", "not", "layer", ".", "use_bias", ":", "\n", "        ", "bias_quantizer", "=", "None", "\n", "accumulator", "=", "kernel_accumulator", "\n", "", "else", ":", "\n", "# Add bias quantizer bitwidth to the overall accumulator", "\n", "        ", "bias_accumulator_instance", "=", "adder_factory", ".", "IAdder", "(", ")", "\n", "accumulator", "=", "bias_accumulator_instance", ".", "make_quantizer", "(", "\n", "kernel_accumulator", ".", "output", ",", "bias_quantizer", ")", "\n", "", "if", "debug", ":", "\n", "        ", "print", "(", "layer", ".", "name", "or", "\"None\"", ")", "\n", "print", "(", "\"weight_quantizer:\"", ",", "weight_quantizer", ".", "bits", ")", "\n", "print", "(", "\"input_quantizer:\"", ",", "input_quantizer", ".", "bits", ")", "\n", "print", "(", "\"multiplier_quantizer:\"", ",", "multiplier", ".", "output", ".", "bits", ")", "\n", "print", "(", "\"multiplier_gate_bits:\"", ",", "multiplier", ".", "gate_bits", ")", "\n", "print", "(", "\"accumulator:\"", ",", "accumulator", ".", "output", ".", "bits", ")", "\n", "\n", "", "if", "for_reference", "or", "not", "hasattr", "(", "layer", ",", "\"get_quantizers\"", ")", ":", "\n", "        ", "accumulator", ".", "output", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", "\n", "multiplier", ".", "output", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", "\n", "\n", "if", "keras_accumulator", ":", "\n", "          ", "accumulator", ".", "output", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "keras_accumulator", ")", "\n", "multiplier", ".", "output", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "keras_accumulator", ")", "\n", "\n", "", "", "if", "enable_bn_fusing", ":", "\n", "        ", "bn_layer_name", "=", "hw_weight_dict", "[", "layer", ".", "name", "]", "[", "\"fused_bn_layer_name\"", "]", "\n", "successor_ids", "=", "list", "(", "graph", ".", "successors", "(", "node_id", ")", ")", "\n", "bn_layer", "=", "graph", ".", "nodes", "[", "successor_ids", "[", "0", "]", "]", "[", "\"layer\"", "]", "[", "0", "]", "\n", "assert", "bn_layer", ".", "name", "==", "bn_layer_name", ",", "(", "\n", "\"Batchnorm layer in the graph has different name from hw_weight\"", "\n", "f\"_dict: {layer.name} vs {bn_layer_name}. Check both places to \"", "\n", "\"ensure they are matching.\"", ")", "\n", "\n", "# Add additional datatype for bn fused weights", "\n", "(", "gamma_quantizer", ",", "beta_quantizer", ",", "mean_quantizer", ",", "variance_quantizer", ",", "\n", "inverse_quantizer", ")", "=", "get_bn_quantizers", "(", "\n", "bn_layer", ",", "quantizer_factory", ",", "cfg", ",", "keras_quantizer", ",", "input_quantizer", ",", "\n", "is_inference", ",", "for_reference", ",", "model_weights_already_quantized", ")", "\n", "\n", "qkeras_inverse_quantizer", "=", "bn_layer", ".", "inverse_quantizer_internal", "\n", "fused_bn", "=", "FusedBNFactory", "(", ")", "\n", "fused_bn", ".", "make_quantizer", "(", "\n", "prev_output_quantizer", "=", "kernel_accumulator", ".", "output", ",", "\n", "prev_bias_quantizer", "=", "bias_quantizer", ",", "\n", "beta_quantizer", "=", "beta_quantizer", ",", "\n", "mean_quantizer", "=", "mean_quantizer", ",", "\n", "inverse_quantizer", "=", "inverse_quantizer", ",", "\n", "use_beta", "=", "bn_layer", ".", "center", ",", "\n", "use_bias", "=", "layer", ".", "use_bias", ",", "\n", "qkeras_inverse_quantizer", "=", "qkeras_inverse_quantizer", "\n", ")", "\n", "if", "for_reference", "or", "not", "hasattr", "(", "layer", ",", "\"get_quantizers\"", ")", ":", "\n", "          ", "fused_bn", ".", "internal_accumulator", ".", "output", "=", "(", "\n", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", ")", "\n", "if", "keras_accumulator", ":", "\n", "            ", "fused_bn", ".", "internal_accumulator", ".", "output", "=", "(", "\n", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "keras_accumulator", ")", ")", "\n", "", "fused_bn", ".", "internal_output", ".", "output", "=", "fused_bn", ".", "internal_accumulator", ".", "output", "\n", "\n", "", "layer_quantizer", "=", "fused_bn", ".", "internal_accumulator", ".", "output", "\n", "output_quantizer", "=", "update_output_quantizer_in_graph", "(", "\n", "graph", ",", "node_id", ",", "quantizer_factory", ",", "layer_quantizer", ",", "for_reference", ")", "\n", "layer_data_type_map", "[", "layer", "]", "=", "{", "\n", "\"input_quantizer_list\"", ":", "input_quantizer_list", ",", "\n", "\"multiplier\"", ":", "multiplier", ",", "\n", "\"accumulator\"", ":", "accumulator", ",", "\n", "\"weight_quantizer\"", ":", "weight_quantizer", ",", "\n", "\"w_shapes\"", ":", "w_shapes", ",", "\n", "\"bias_quantizer\"", ":", "bias_quantizer", ",", "\n", "\"b_shapes\"", ":", "b_shapes", ",", "\n", "\"bn_inverse_quantizer\"", ":", "inverse_quantizer", ",", "\n", "\"bn_mean_quantizer\"", ":", "mean_quantizer", ",", "\n", "\"bn_beta_quantizer\"", ":", "beta_quantizer", ",", "\n", "\"fused_accumulator\"", ":", "fused_bn", ".", "internal_accumulator", ",", "\n", "\"output_quantizer\"", ":", "output_quantizer", ",", "\n", "\"output_shapes\"", ":", "output_shapes", ",", "\n", "\"operation_count\"", ":", "operation_count", "\n", "}", "\n", "", "else", ":", "\n", "# Correct accumulator bitwith with the scale values from", "\n", "# auto-po2 type of quantizers and store them in fused_accumulator.", "\n", "        ", "if", "(", "\n", "hasattr", "(", "qkeras_weight_quantizer", ",", "\"__str__\"", ")", "and", "\n", "\"quantized_bits\"", "in", "qkeras_weight_quantizer", ".", "__str__", "(", ")", "and", "\n", "qkeras_weight_quantizer", ".", "alpha", "==", "\"auto_po2\"", ")", ":", "\n", "          ", "fused_accumulator", "=", "qtools_util", ".", "adjust_accumulator_for_auto_po2", "(", "\n", "layer", ",", "multiplier", ",", "qkeras_weight_quantizer", ",", "bias_quantizer", ")", "\n", "", "else", ":", "\n", "          ", "fused_accumulator", "=", "accumulator", "\n", "\n", "", "layer_quantizer", "=", "accumulator", ".", "output", "\n", "output_quantizer", "=", "update_output_quantizer_in_graph", "(", "\n", "graph", ",", "node_id", ",", "quantizer_factory", ",", "layer_quantizer", ",", "for_reference", ")", "\n", "\n", "layer_data_type_map", "[", "layer", "]", "=", "{", "\n", "\"input_quantizer_list\"", ":", "input_quantizer_list", ",", "\n", "\"multiplier\"", ":", "multiplier", ",", "\n", "\"accumulator\"", ":", "accumulator", ",", "\n", "\"weight_quantizer\"", ":", "weight_quantizer", ",", "\n", "\"w_shapes\"", ":", "w_shapes", ",", "\n", "\"bias_quantizer\"", ":", "bias_quantizer", ",", "\n", "\"b_shapes\"", ":", "b_shapes", ",", "\n", "\"fused_accumulator\"", ":", "fused_accumulator", ",", "\n", "\"output_quantizer\"", ":", "output_quantizer", ",", "\n", "\"output_shapes\"", ":", "output_shapes", ",", "\n", "\"operation_count\"", ":", "operation_count", "\n", "}", "\n", "", "", "elif", "node_type", "in", "[", "\"QConv2DBatchnorm\"", ",", "\"QDepthwiseConv2DBatchnorm\"", "]", ":", "\n", "# Datatype for Folded Conv/DepthwiseConv layer", "\n", "# TODO(lishanok): Add additional support for Folded Dense layer", "\n", "      ", "(", "input_quantizer", ",", "_", ")", "=", "input_qe_list", "[", "0", "]", "\n", "if", "for_reference", "or", "not", "hasattr", "(", "layer", ",", "\"get_quantizers\"", ")", ":", "\n", "# For_reference: force all quantizers to keras_quantizer.", "\n", "        ", "weight_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", "\n", "bias_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", "\n", "\n", "if", "keras_quantizer", ":", "\n", "          ", "weight_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "keras_quantizer", ")", "\n", "bias_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "keras_quantizer", ")", "\n", "", "", "else", ":", "\n", "# QKeras layer", "\n", "        ", "qkeras_weight_quantizer", "=", "layer", ".", "get_quantizers", "(", ")", "[", "0", "]", "\n", "qkeras_bias_quantizer", "=", "layer", ".", "get_quantizers", "(", ")", "[", "1", "]", "\n", "if", "not", "quantizer_factory", ".", "is_quantizer_supported", "(", "\n", "qkeras_weight_quantizer", ")", ":", "\n", "          ", "raise", "TagMissingError", "(", "\n", "\"Unsupported weight quantizer {} on this layer: {}\"", ".", "format", "(", "\n", "qkeras_weight_quantizer", ",", "layer", ")", ")", "\n", "\n", "", "if", "not", "quantizer_factory", ".", "is_quantizer_supported", "(", "\n", "qkeras_bias_quantizer", ")", ":", "\n", "          ", "raise", "TagMissingError", "(", "\n", "\"Unsupported bias quantizer {} on this layer: {}\"", ".", "format", "(", "\n", "qkeras_bias_quantizer", ",", "layer", ")", ")", "\n", "\n", "", "weight_quantizer", "=", "quantizer_factory", ".", "make_quantizer", "(", "\n", "qkeras_weight_quantizer", ")", "\n", "\n", "if", "qkeras_bias_quantizer", ":", "\n", "          ", "bias_quantizer", "=", "quantizer_factory", ".", "make_quantizer", "(", "\n", "qkeras_bias_quantizer", ")", "\n", "", "else", ":", "\n", "          ", "bias_quantizer", "=", "None", "\n", "\n", "# TODO(lishanok): During inference, if weight and bias is po2,", "\n", "#  need to update corresponding quantizer type with min and max", "\n", "#  of the constant values", "\n", "", "", "if", "is_inference", ":", "\n", "        ", "weights", "=", "qtools_util", ".", "get_weights", "(", "\n", "layer", ",", "model_weights_already_quantized", ")", "\n", "if", "weight_quantizer", ".", "is_po2", ":", "\n", "          ", "weight_quantizer", ".", "update_inference_values", "(", "weights", "[", "0", "]", ")", "\n", "\n", "", "if", "bias_quantizer", "and", "bias_quantizer", ".", "is_po2", ":", "\n", "          ", "bias_quantizer", ".", "update_inference_values", "(", "weights", "[", "1", "]", ")", "\n", "\n", "", "", "multiplier_factory", "=", "quantized_operators", ".", "MultiplierFactory", "(", ")", "\n", "multiplier", "=", "multiplier_factory", ".", "make_multiplier", "(", "\n", "weight_quantizer", ",", "input_quantizer", ")", "\n", "if", "qkeras_weight_quantizer", ":", "\n", "        ", "qtools_util", ".", "adjust_multiplier_for_auto_po2", "(", "\n", "multiplier", ",", "qkeras_weight_quantizer", ")", "\n", "", "weights", "=", "layer", ".", "get_weights", "(", ")", "\n", "kernel", "=", "weights", "[", "0", "]", "\n", "\n", "accumulator_factory", "=", "quantized_operators", ".", "AccumulatorFactory", "(", ")", "\n", "accumulator", "=", "accumulator_factory", ".", "make_accumulator", "(", "\n", "kernel", ".", "shape", ",", "multiplier", ",", "use_bias", "=", "True", "if", "bias_quantizer", "else", "False", ")", "\n", "\n", "if", "not", "bias_quantizer", ":", "\n", "# Set bias the same as accumulator type.", "\n", "        ", "bias_quantizer", "=", "copy", ".", "deepcopy", "(", "accumulator", ".", "output", ")", "\n", "if", "not", "accumulator", ".", "output", ".", "is_floating_point", ":", "\n", "# For fixed point accumulator, needs to add 1 to its bits to avoid", "\n", "# possible satuation.", "\n", "          ", "accumulator", ".", "output", ".", "bits", "+=", "1", "\n", "accumulator", ".", "output", ".", "int_bits", "+=", "1", "\n", "", "", "if", "for_reference", "or", "not", "hasattr", "(", "layer", ",", "\"get_quantizers\"", ")", ":", "\n", "        ", "accumulator", ".", "output", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", "\n", "multiplier", ".", "output", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "cfg", ".", "default_interm_quantizer", ")", "\n", "\n", "if", "keras_accumulator", ":", "\n", "          ", "accumulator", ".", "output", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "keras_accumulator", ")", "\n", "multiplier", ".", "output", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "keras_accumulator", ")", "\n", "\n", "", "", "layer_quantizer", "=", "accumulator", ".", "output", "\n", "output_quantizer", "=", "update_output_quantizer_in_graph", "(", "\n", "graph", ",", "node_id", ",", "quantizer_factory", ",", "layer_quantizer", ",", "for_reference", ")", "\n", "\n", "layer_data_type_map", "[", "layer", "]", "=", "LayerDataType", "(", "\n", "input_quantizer_list", ",", "\n", "multiplier", ",", "\n", "accumulator", ",", "\n", "weight_quantizer", ",", "\n", "w_shapes", ",", "\n", "bias_quantizer", ",", "\n", "b_shapes", ",", "\n", "output_quantizer", ",", "\n", "output_shapes", ",", "\n", "operation_count", "\n", ")", "\n", "\n", "", "elif", "node_type", ":", "\n", "# Any other unsupported layer types -> pass the input quantizer", "\n", "# type to output in qraph", "\n", "      ", "print", "(", "f\"[WARNING] QTools cannot parse {node_type}. The input quatnizer\"", "\n", "\" of this layer is directly passed through to the output!\"", ",", "\n", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "(", "input_quantizer", ",", "_", ")", "=", "input_qe_list", "[", "0", "]", "\n", "\n", "if", "for_reference", "and", "keras_accumulator", "and", "not", "is_input_layer", ":", "\n", "        ", "input_quantizer", "=", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "keras_accumulator", ")", "\n", "\n", "", "output_quantizer", "=", "update_output_quantizer_in_graph", "(", "\n", "graph", ",", "node_id", ",", "quantizer_factory", ",", "input_quantizer", ",", "for_reference", ")", "\n", "\n", "layer_data_type_map", "[", "layer", "]", "=", "LayerDataType", "(", "input_quantizer_list", ",", "None", ",", "\n", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "\n", "output_quantizer", ",", "\n", "output_shapes", ",", "operation_count", ")", "\n", "\n", "", "", "result", "=", "{", "\n", "\"source_quantizer_list\"", ":", "source_quantizer_list", ",", "\n", "\"output_layers\"", ":", "output_layers", ",", "\n", "\"input_layers\"", ":", "input_layers", ",", "\n", "\"layer_data_type_map\"", ":", "layer_data_type_map", "\n", "}", "\n", "\n", "return", "result", "\n", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.qtools.interface.print_qstats": [[27, 60], ["qkeras.qtools.generate_layer_data_type_map", "collections.Counter", "print", "print", "qkeras.qtools.generate_layer_data_type_map.items", "print", "print", "collections.Counter.items", "print", "print", "multiplier.implemented_as"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qtools.generate_layer_data_type_map.generate_layer_data_type_map", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.divider_impl.Subtractor.implemented_as"], ["def", "print_qstats", "(", "graph", ")", ":", "\n", "  ", "\"\"\"Prints quantization statistics for the model.\"\"\"", "\n", "\n", "layer_data_type_map", "=", "generate_layer_data_type_map", "(", "graph", ")", "\n", "\n", "multipliers_counter", "=", "collections", ".", "Counter", "(", ")", "\n", "\n", "print", "(", "\"\"", ")", "\n", "print", "(", "\"Number of operations in model:\"", ")", "\n", "for", "layer", ",", "data_type", "in", "layer_data_type_map", ".", "items", "(", ")", ":", "\n", "    ", "multiplier", "=", "data_type", ".", "multiplier", "\n", "multiplier_detail_str", "=", "\"{}_{}, total_bits:{}, int_bits:{}\"", ".", "format", "(", "\n", "\"signed\"", "if", "multiplier", ".", "output", ".", "is_signed", "==", "1", "else", "\"unsigned\"", ",", "\n", "multiplier", ".", "implemented_as", "(", ")", ",", "\n", "multiplier", ".", "output", ".", "bits", ",", "\n", "multiplier", ".", "output", ".", "int_bits", ",", "\n", ")", "\n", "\n", "print", "(", "\"{}: {} x {}\"", ".", "format", "(", "\n", "layer", ".", "name", ",", "\n", "data_type", ".", "operation_count", ",", "\n", "multiplier_detail_str", ",", "\n", ")", ")", "\n", "\n", "multipliers_counter", "[", "\n", "multiplier_detail_str", "]", "+=", "data_type", ".", "operation_count", "\n", "\n", "", "print", "(", "\"\"", ")", "\n", "print", "(", "\"Number of operation types in model:\"", ")", "\n", "for", "(", "multiplier_detail_str", ",", "\n", "total_multiplier_operation_count", ")", "in", "multipliers_counter", ".", "items", "(", ")", ":", "\n", "    ", "print", "(", "\"{}, x {}\"", ".", "format", "(", "multiplier_detail_str", ",", "\n", "total_multiplier_operation_count", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.interface.populate_quantizer": [[62, 115], ["collections.OrderedDict", "isinstance", "list", "tuple"], "function", ["None"], ["", "", "def", "populate_quantizer", "(", "quantizer", ",", "shape", "=", "None", ",", "implemented_as", "=", "None", ")", ":", "\n", "  ", "\"\"\"write all the needed fields in the quantizer to dictionary.\"\"\"", "\n", "\n", "mydict", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "\n", "if", "quantizer", "is", "not", "None", ":", "\n", "    ", "mydict", "[", "\"quantizer_type\"", "]", "=", "quantizer", ".", "name", "\n", "\n", "# floats", "\n", "if", "quantizer", ".", "is_floating_point", ":", "\n", "      ", "mydict", "[", "\"bits\"", "]", "=", "quantizer", ".", "bits", "\n", "\n", "# po2", "\n", "", "elif", "quantizer", ".", "is_po2", ":", "\n", "      ", "mydict", "[", "\"bits\"", "]", "=", "quantizer", ".", "bits", "\n", "mydict", "[", "\"is_signed\"", "]", "=", "quantizer", ".", "is_signed", "\n", "mydict", "[", "\"max_value\"", "]", "=", "quantizer", ".", "max_val_po2", "\n", "\n", "# binary", "\n", "", "elif", "quantizer", ".", "mode", "in", "[", "3", ",", "4", "]", ":", "\n", "\n", "      ", "mydict", "[", "\"bits\"", "]", "=", "quantizer", ".", "bits", "\n", "mydict", "[", "\"int_bits\"", "]", "=", "quantizer", ".", "int_bits", "\n", "mydict", "[", "\"is_signed\"", "]", "=", "quantizer", ".", "is_signed", "\n", "if", "quantizer", ".", "mode", "==", "4", ":", "\n", "        ", "mydict", "[", "\"values\"", "]", "=", "[", "0", ",", "1", "]", "\n", "", "else", ":", "\n", "        ", "mydict", "[", "\"values\"", "]", "=", "[", "-", "1", ",", "1", "]", "\n", "\n", "# ternary(-1, 0, 1)", "\n", "", "", "elif", "quantizer", ".", "mode", "==", "2", ":", "\n", "      ", "mydict", "[", "\"bits\"", "]", "=", "2", "\n", "mydict", "[", "\"int_bits\"", "]", "=", "2", "\n", "mydict", "[", "\"is_signed\"", "]", "=", "1", "\n", "mydict", "[", "\"values\"", "]", "=", "[", "0", ",", "-", "1", ",", "1", "]", "\n", "\n", "# quantized_bits", "\n", "", "elif", "quantizer", ".", "mode", "==", "0", ":", "\n", "      ", "mydict", "[", "\"bits\"", "]", "=", "quantizer", ".", "bits", "\n", "mydict", "[", "\"int_bits\"", "]", "=", "quantizer", ".", "int_bits", "+", "quantizer", ".", "is_signed", "\n", "mydict", "[", "\"is_signed\"", "]", "=", "quantizer", ".", "is_signed", "\n", "\n", "", "if", "shape", "is", "not", "None", ":", "\n", "      ", "if", "isinstance", "(", "shape", ",", "tuple", ")", "and", "shape", "[", "0", "]", "is", "None", ":", "\n", "        ", "shape", "=", "list", "(", "shape", ")", "\n", "shape", "[", "0", "]", "=", "-", "1", "\n", "mydict", "[", "\"shape\"", "]", "=", "tuple", "(", "shape", ")", "\n", "", "else", ":", "\n", "        ", "mydict", "[", "\"shape\"", "]", "=", "shape", "\n", "\n", "", "", "if", "implemented_as", "is", "not", "None", ":", "\n", "      ", "mydict", "[", "\"op_type\"", "]", "=", "implemented_as", "\n", "", "", "return", "mydict", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.interface.map_to_json": [[117, 234], ["collections.OrderedDict", "bool", "layer_data_type_map.items", "interface.populate_quantizer", "q_list.append", "qkeras.qtools.qtools_util.get_val", "collections.OrderedDict", "interface.map_to_json.set_layer_item"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qtools.interface.populate_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_val"], ["", "def", "map_to_json", "(", "mydict", ")", ":", "\n", "  ", "\"\"\"write the dictionary to json format.\"\"\"", "\n", "\n", "source_quantizer_list", "=", "mydict", "[", "\"source_quantizer_list\"", "]", "\n", "layer_data_type_map", "=", "mydict", "[", "\"layer_data_type_map\"", "]", "\n", "\n", "output_dict", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "\n", "q_list", "=", "[", "]", "\n", "for", "source_quantizer", "in", "source_quantizer_list", ":", "\n", "    ", "tmp", "=", "populate_quantizer", "(", "source_quantizer", ")", "\n", "q_list", ".", "append", "(", "tmp", ")", "\n", "\n", "", "if", "bool", "(", "q_list", ")", ":", "\n", "    ", "output_dict", "[", "\"source_quantizers\"", "]", "=", "q_list", "\n", "\n", "", "def", "set_layer_item", "(", "layer_item", ",", "key", ",", "feature", ",", "shape", "=", "None", ",", "\n", "is_compound_datatype", "=", "False", ",", "output_key_name", "=", "None", ")", ":", "\n", "    ", "\"\"\"Generates the quantizer entry to a given layer_item.\n\n    This function extracts relevanant quantizer fields using the key (\n    quantizer name) from a given feature (layer entry from layer_data_type_map).\n\n    Args:\n      layer_item: Layer entry in the output dictionary. It includes the\n        info such as quantizers, output shape, etc. of each layer\n      key: Quantizer, such as kernel/bias quantizer, etc. If feature\n      feature: layer_data_type_map entry of each layer. This feature will be\n        parsed and converted to layer_item for the output dictionary.\n      shape: quantizer input shape\n      is_compound_datatype: Bool. Wether the quantizer is a compound\n        or unitary quantizer type. For example, kernel quantizer and bias\n        quantizer are unitary quantizer types, multiplier and accumulator\n        are compound quantizer types.\n      output_key_name: str. Change key to output_key_name in layer_item. If\n        None, will use the existing key.\n\n    Return:\n      None\n    \"\"\"", "\n", "val", "=", "qtools_util", ".", "get_val", "(", "feature", ",", "key", ")", "\n", "if", "val", "is", "not", "None", ":", "\n", "      ", "quantizer", "=", "val", "\n", "implemented_as", "=", "None", "\n", "if", "is_compound_datatype", ":", "\n", "        ", "quantizer", "=", "val", ".", "output", "\n", "implemented_as", "=", "val", ".", "implemented_as", "(", ")", "\n", "", "if", "output_key_name", "is", "None", ":", "\n", "        ", "key_name", "=", "key", "\n", "", "else", ":", "\n", "        ", "key_name", "=", "output_key_name", "\n", "", "tmp", "=", "populate_quantizer", "(", "\n", "quantizer", ",", "shape", "=", "shape", ",", "implemented_as", "=", "implemented_as", ")", "\n", "if", "bool", "(", "tmp", ")", ":", "\n", "        ", "layer_item", "[", "key_name", "]", "=", "tmp", "\n", "\n", "", "", "", "for", "layer", ",", "feature", "in", "layer_data_type_map", ".", "items", "(", ")", ":", "\n", "    ", "layer_item", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "layer_item", "[", "\"layer_type\"", "]", "=", "layer", ".", "__class__", ".", "__name__", "\n", "layer_item", "[", "\"input_quantizer_list\"", "]", "=", "[", "\n", "populate_quantizer", "(", "q", ")", "for", "q", "in", "qtools_util", ".", "get_val", "(", "\n", "feature", ",", "\"input_quantizer_list\"", ")", "]", "\n", "\n", "set_layer_item", "(", "layer_item", ",", "key", "=", "\"output_quantizer\"", ",", "feature", "=", "feature", ",", "\n", "shape", "=", "qtools_util", ".", "get_val", "(", "feature", ",", "\"output_shapes\"", ")", ")", "\n", "\n", "if", "layer_item", "[", "\"layer_type\"", "]", "in", "[", "\n", "\"QBatchNormalization\"", ",", "\"BatchNormalization\"", "]", ":", "\n", "\n", "      ", "for", "key", "in", "[", "\"gamma_quantizer\"", ",", "\"beta_quantizer\"", ",", "\"mean_quantizer\"", ",", "\n", "\"variance_quantizer\"", ",", "\"variance_quantizer\"", "]", ":", "\n", "        ", "set_layer_item", "(", "layer_item", ",", "key", "=", "key", ",", "feature", "=", "feature", ")", "\n", "\n", "", "for", "key", "in", "[", "\"internal_divide_quantizer\"", ",", "\n", "\"internal_multiplier\"", ",", "\"internal_accumulator\"", "]", ":", "\n", "        ", "set_layer_item", "(", "layer_item", ",", "key", "=", "key", ",", "feature", "=", "feature", ",", "\n", "is_compound_datatype", "=", "True", ")", "\n", "\n", "", "", "elif", "layer_item", "[", "\"layer_type\"", "]", "in", "[", "\n", "\"AveragePooling2D\"", ",", "\"AvgPool2D\"", ",", "\"GlobalAvgPool2D\"", ",", "\n", "\"GlobalAveragePooling2D\"", ",", "\"QAveragePooling2D\"", ",", "\n", "\"QGlobalAveragePooling2D\"", "]", ":", "\n", "      ", "set_layer_item", "(", "layer_item", ",", "key", "=", "\"average_quantizer\"", ",", "feature", "=", "feature", ")", "\n", "for", "key", "in", "[", "\"pool_sum_accumulator\"", ",", "\"pool_avg_multiplier\"", "]", ":", "\n", "        ", "set_layer_item", "(", "layer_item", ",", "key", "=", "key", ",", "feature", "=", "feature", ",", "\n", "is_compound_datatype", "=", "True", ")", "\n", "\n", "", "", "else", ":", "\n", "# populate the feature to dictionary", "\n", "      ", "set_layer_item", "(", "layer_item", ",", "key", "=", "\"weight_quantizer\"", ",", "feature", "=", "feature", ",", "\n", "shape", "=", "qtools_util", ".", "get_val", "(", "feature", ",", "\"w_shapes\"", ")", ")", "\n", "set_layer_item", "(", "layer_item", ",", "key", "=", "\"bias_quantizer\"", ",", "feature", "=", "feature", ",", "\n", "shape", "=", "qtools_util", ".", "get_val", "(", "feature", ",", "\"b_shapes\"", ")", ")", "\n", "\n", "output_key_name", "=", "None", "\n", "if", "qtools_util", ".", "is_merge_layers", "(", "layer", ")", ":", "\n", "        ", "output_key_name", "=", "layer", ".", "__class__", ".", "__name__", "+", "\"_quantizer\"", "\n", "", "set_layer_item", "(", "layer_item", ",", "key", "=", "\"multiplier\"", ",", "feature", "=", "feature", ",", "\n", "is_compound_datatype", "=", "True", ",", "\n", "output_key_name", "=", "output_key_name", ")", "\n", "set_layer_item", "(", "layer_item", ",", "key", "=", "\"accumulator\"", ",", "feature", "=", "feature", ",", "\n", "is_compound_datatype", "=", "True", ")", "\n", "\n", "if", "qtools_util", ".", "get_val", "(", "feature", ",", "\"fused_accumulator\"", ")", ":", "\n", "# Add fused weights to the dictionary", "\n", "        ", "for", "key", "in", "[", "\"bn_beta_quantizer\"", ",", "\"bn_mean_quantizer\"", ",", "\n", "\"bn_inverse_quantizer\"", "]", ":", "\n", "          ", "set_layer_item", "(", "layer_item", ",", "key", "=", "key", ",", "feature", "=", "feature", ")", "\n", "\n", "", "set_layer_item", "(", "layer_item", ",", "key", "=", "\"fused_accumulator\"", ",", "feature", "=", "feature", ",", "\n", "is_compound_datatype", "=", "True", ")", "\n", "\n", "", "", "layer_item", "[", "\"operation_count\"", "]", "=", "qtools_util", ".", "get_val", "(", "\n", "feature", ",", "\"operation_count\"", ")", "\n", "output_dict", "[", "layer", ".", "name", "]", "=", "layer_item", "\n", "\n", "", "return", "output_dict", "\n", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.qtools.settings.ConfigClass.__init__": [[28, 58], ["numpy.poly1d", "numpy.poly1d", "numpy.poly1d", "numpy.poly1d", "numpy.poly1d", "numpy.poly1d", "numpy.poly1d", "numpy.poly1d"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "\n", "    ", "self", ".", "default_source_quantizer", "=", "\"quantized_bits(8, 0, 1)\"", "\n", "self", ".", "default_interm_quantizer", "=", "\"fp32\"", "\n", "\n", "# Horowitz estimates from ISSCC 2014", "\n", "\n", "self", ".", "fpm_add", "=", "np", ".", "poly1d", "(", "[", "0.003125", ",", "0", "]", ")", "\n", "self", ".", "fpm_mul", "=", "np", ".", "poly1d", "(", "[", "0.002994791667", ",", "0.001041666667", ",", "0", "]", ")", "\n", "self", ".", "fp16_add", "=", "np", ".", "poly1d", "(", "[", "0.4", "]", ")", "\n", "self", ".", "fp16_mul", "=", "np", ".", "poly1d", "(", "[", "1.1", "]", ")", "\n", "self", ".", "fp32_add", "=", "np", ".", "poly1d", "(", "[", "0.9", "]", ")", "\n", "self", ".", "fp32_mul", "=", "np", ".", "poly1d", "(", "[", "3.7", "]", ")", "\n", "\n", "self", ".", "sram_rd", "=", "np", ".", "poly1d", "(", "[", "0.02455", ",", "-", "0.2656", ",", "0.8661", "]", ")", "\n", "self", ".", "dram_rd", "=", "np", ".", "poly1d", "(", "[", "20.3125", ",", "0", "]", ")", "\n", "self", ".", "sram_mul_factor", "=", "1", "/", "64.", "\n", "self", ".", "dram_mul_factor", "=", "1.0", "\n", "\n", "self", ".", "include_energy", "=", "{", "}", "\n", "self", ".", "include_energy", "[", "\"default\"", "]", "=", "[", "\"inputs\"", ",", "\"parameters\"", ",", "\"op_cost\"", "]", "\n", "self", ".", "include_energy", "[", "\"QActivation\"", "]", "=", "[", "\"outputs\"", "]", "\n", "self", ".", "include_energy", "[", "\"QAdaptiveActivation\"", "]", "=", "[", "\"outputs\"", "]", "\n", "self", ".", "include_energy", "[", "\"Activation\"", "]", "=", "[", "\"outputs\"", "]", "\n", "self", ".", "include_energy", "[", "\"QBatchNormalization\"", "]", "=", "[", "\"parameters\"", "]", "\n", "self", ".", "include_energy", "[", "\"BatchNormalization\"", "]", "=", "[", "\"parameters\"", "]", "\n", "self", ".", "include_energy", "[", "\"Add\"", "]", "=", "[", "\"op_cost\"", "]", "\n", "self", ".", "include_energy", "[", "\"Subtract\"", "]", "=", "[", "\"op_cost\"", "]", "\n", "self", ".", "include_energy", "[", "\"MaxPooling2D\"", "]", "=", "[", "\"op_cost\"", "]", "\n", "self", ".", "include_energy", "[", "\"default\"", "]", "=", "[", "\"inputs\"", ",", "\"parameters\"", ",", "\"op_cost\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.settings.ConfigClass.update": [[59, 123], ["numpy.poly1d", "numpy.poly1d", "numpy.poly1d", "numpy.poly1d", "numpy.poly1d", "numpy.poly1d", "numpy.poly1d", "numpy.poly1d"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "process", ",", "cfg_setting", ")", ":", "\n", "    ", "\"\"\"update config.\"\"\"", "\n", "\n", "# pylint: disable=bare-except", "\n", "try", ":", "\n", "      ", "self", ".", "default_source_quantizer", "=", "cfg_setting", "[", "\n", "\"default_source_quantizer\"", "]", "\n", "", "except", ":", "\n", "      ", "pass", "\n", "\n", "", "try", ":", "\n", "      ", "self", ".", "default_interm_quantizer", "=", "cfg_setting", "[", "\n", "\"default_interm_quantizer\"", "]", "\n", "", "except", ":", "\n", "      ", "pass", "\n", "\n", "", "try", ":", "\n", "      ", "self", ".", "fpm_add", "=", "np", ".", "poly1d", "(", "cfg_setting", "[", "process", "]", "[", "\"fpm_add\"", "]", ")", "\n", "", "except", ":", "\n", "      ", "pass", "\n", "\n", "", "try", ":", "\n", "      ", "self", ".", "fpm_mul", "=", "np", ".", "poly1d", "(", "cfg_setting", "[", "process", "]", "[", "\"fpm_mul\"", "]", ")", "\n", "", "except", ":", "\n", "      ", "pass", "\n", "\n", "", "try", ":", "\n", "      ", "self", ".", "fp16_add", "=", "np", ".", "poly1d", "(", "cfg_setting", "[", "process", "]", "[", "\"fp16_add\"", "]", ")", "\n", "", "except", ":", "\n", "      ", "pass", "\n", "\n", "", "try", ":", "\n", "      ", "self", ".", "fp16_mul", "=", "np", ".", "poly1d", "(", "cfg_setting", "[", "process", "]", "[", "\"fp16_mul\"", "]", ")", "\n", "", "except", ":", "\n", "      ", "pass", "\n", "\n", "", "try", ":", "\n", "      ", "self", ".", "fp32_add", "=", "np", ".", "poly1d", "(", "cfg_setting", "[", "process", "]", "[", "\"fp32_add\"", "]", ")", "\n", "", "except", ":", "\n", "      ", "pass", "\n", "\n", "", "try", ":", "\n", "      ", "self", ".", "fp32_mul", "=", "np", ".", "poly1d", "(", "cfg_setting", "[", "process", "]", "[", "\"fp32_mul\"", "]", ")", "\n", "", "except", ":", "\n", "      ", "pass", "\n", "\n", "", "try", ":", "\n", "      ", "self", ".", "sram_rd", "=", "np", ".", "poly1d", "(", "cfg_setting", "[", "process", "]", "[", "\"sram_rd\"", "]", ")", "\n", "", "except", ":", "\n", "      ", "pass", "\n", "\n", "", "try", ":", "\n", "      ", "self", ".", "dram_rd", "=", "np", ".", "poly1d", "(", "cfg_setting", "[", "process", "]", "[", "\"dram_rd\"", "]", ")", "\n", "", "except", ":", "# pylint: disable=broad-except", "\n", "      ", "pass", "\n", "\n", "", "try", ":", "\n", "      ", "for", "key", "in", "cfg_setting", "[", "\"include_energy\"", "]", ":", "\n", "        ", "self", ".", "include_energy", "[", "key", "]", "=", "cfg_setting", "[", "\"include_energy\"", "]", "[", "key", "]", "\n", "if", "\"Q\"", "==", "key", "[", "0", "]", ":", "\n", "# use the same rule for keras layer and qkeras layer", "\n", "          ", "self", ".", "include_energy", "[", "key", "[", "1", ":", "]", "]", "=", "cfg_setting", "[", "\"include_energy\"", "]", "[", "key", "]", "\n", "", "", "", "except", ":", "\n", "      ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphRemoveNode": [[39, 56], ["graph.remove_node", "graph.predecessors", "graph.successors", "graph.add_edges_from", "list", "list"], "function", ["None"], ["", "def", "GraphRemoveNode", "(", "graph", ",", "v", ")", ":", "\n", "  ", "\"\"\"Removes node \"v\" from u -> v -> w, connecting u -> w.\"\"\"", "\n", "\n", "incoming", "=", "[", "u", "for", "u", "in", "graph", ".", "predecessors", "(", "v", ")", "if", "u", "!=", "v", "]", "\n", "outgoing", "=", "[", "w", "for", "w", "in", "graph", ".", "successors", "(", "v", ")", "if", "w", "!=", "v", "]", "\n", "\n", "# add incoming edges", "\n", "for", "u", "in", "incoming", ":", "\n", "    ", "for", "w", "in", "outgoing", ":", "\n", "      ", "in_attr", "=", "graph", "[", "u", "]", "[", "v", "]", "\n", "out_attr", "=", "graph", "[", "v", "]", "[", "w", "]", "\n", "\n", "assert", "list", "(", "in_attr", "[", "\"shape\"", "]", ")", "==", "list", "(", "out_attr", "[", "\"shape\"", "]", ")", "\n", "\n", "graph", ".", "add_edges_from", "(", "[", "(", "u", ",", "w", ",", "out_attr", ")", "]", ")", "\n", "\n", "", "", "graph", ".", "remove_node", "(", "v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphRemoveNodeWithNodeType": [[58, 67], ["qgraph.GraphRemoveNode"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphRemoveNode"], ["", "def", "GraphRemoveNodeWithNodeType", "(", "graph", ",", "node_type", ")", ":", "\n", "  ", "\"\"\"Removes node with attribute node_type, reconnecting network.\"\"\"", "\n", "\n", "nodes_to_remove", "=", "[", "v", "for", "v", "in", "graph", ".", "nodes", "\n", "if", "graph", ".", "nodes", "[", "v", "]", "[", "\"type\"", "]", "[", "-", "1", "]", "==", "node_type", "]", "\n", "\n", "for", "v", "in", "nodes_to_remove", ":", "\n", "\n", "    ", "GraphRemoveNode", "(", "graph", ",", "v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphAddHiddenInputLayer": [[69, 114], ["graph.nodes.items", "tensorflow.keras.layers.InputLayer", "graph.add_nodes_from", "input_quantizer_map.items", "graph.add_edges_from", "list", "len", "graph.predecessors", "first_layer_nodes.append"], "function", ["None"], ["", "", "def", "GraphAddHiddenInputLayer", "(", "model", ",", "graph", ",", "input_quantizer_map", ")", ":", "\n", "  ", "\"\"\"For Keras Sequential model api, input layer is hidden. Need to add it.\"\"\"", "\n", "\n", "node_id", "=", "-", "1", "\n", "for", "(", "u", ",", "_", ")", "in", "graph", ".", "nodes", ".", "items", "(", ")", ":", "\n", "    ", "if", "u", ">=", "node_id", ":", "\n", "      ", "node_id", "=", "u", "\n", "", "if", "u", "==", "SOURCE", "or", "u", "==", "SINK", ":", "\n", "      ", "continue", "\n", "\n", "", "if", "graph", ".", "nodes", "[", "u", "]", "[", "\"type\"", "]", "[", "-", "1", "]", "==", "\"InputLayer\"", ":", "\n", "      ", "return", "\n", "\n", "# determine a node id for the newly added input layer", "\n", "", "", "node_id", "+=", "1", "\n", "\n", "# find the first layer of the sequential model", "\n", "first_layer_nodes", "=", "[", "]", "\n", "for", "u", "in", "graph", ".", "nodes", ":", "\n", "    ", "if", "u", "==", "SOURCE", "or", "u", "==", "SINK", ":", "\n", "      ", "continue", "\n", "", "predecessors", "=", "list", "(", "graph", ".", "predecessors", "(", "u", ")", ")", "\n", "# find the first layer which doesn't have a parent", "\n", "if", "not", "predecessors", ":", "\n", "      ", "first_layer_nodes", ".", "append", "(", "u", ")", "\n", "", "", "assert", "len", "(", "first_layer_nodes", ")", "==", "1", "\n", "# since it is a sequential model, there is only one first layer", "\n", "v_id", "=", "first_layer_nodes", "[", "0", "]", "\n", "\n", "# create a input layer node", "\n", "node_type", "=", "\"InputLayer\"", "\n", "input_shape", "=", "model", ".", "layers", "[", "0", "]", ".", "input_shape", "\n", "layer", "=", "InputLayer", "(", "input_shape", "=", "input_shape", "[", "1", ":", "]", ")", "\n", "o_shape", "=", "input_shape", "\n", "node", "=", "(", "node_id", ",", "{", "\"layer\"", ":", "[", "layer", "]", ",", "\"type\"", ":", "[", "node_type", "]", ",", "\n", "\"out_quantizer\"", ":", "None", "}", ")", "\n", "graph", ".", "add_nodes_from", "(", "[", "node", "]", ")", "\n", "\n", "# insert input_quantizers on the edge between input layer and its next layer", "\n", "for", "(", "a", ",", "_", ")", "in", "input_quantizer_map", ".", "items", "(", ")", ":", "\n", "    ", "edge", "=", "(", "node_id", ",", "v_id", ",", "{", "\n", "\"shape\"", ":", "[", "o_shape", "]", ",", "\"tensor\"", ":", "a", ",", "\n", "\"quantizer\"", ":", "input_quantizer_map", "[", "a", "]", "}", ")", "\n", "\n", "", "graph", ".", "add_edges_from", "(", "[", "edge", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphAddSingleSourceSingleSink": [[116, 145], ["graph.add_edges_from", "[].get_output_at", "tuple", "edge_list.append", "graph.out_degree", "[].get_output_at", "edge_list.append", "[].get_output_at.get_shape().as_list", "[].get_output_at.get_shape"], "function", ["None"], ["", "def", "GraphAddSingleSourceSingleSink", "(", "graph", ")", ":", "\n", "\n", "  ", "\"\"\"Connects graph to source and sink nodes.\"\"\"", "\n", "\n", "edge_list", "=", "[", "]", "\n", "\n", "for", "u", "in", "graph", ".", "nodes", ":", "\n", "\n", "    ", "if", "u", "==", "SOURCE", "or", "u", "==", "SINK", ":", "\n", "      ", "continue", "\n", "\n", "", "if", "graph", ".", "nodes", "[", "u", "]", "[", "\"type\"", "]", "[", "-", "1", "]", "==", "\"InputLayer\"", ":", "\n", "# If the layer has multiple nodes, you can use get_output_at(node_index)", "\n", "      ", "tensor", "=", "graph", ".", "nodes", "[", "u", "]", "[", "\"layer\"", "]", "[", "-", "1", "]", ".", "get_output_at", "(", "0", ")", "\n", "# if tf 1.0+, we can do tensor.shape with the same effect", "\n", "shape", "=", "tuple", "(", "tensor", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", ")", "\n", "shape", "=", "[", "shape", "]", "\n", "\n", "edge_list", ".", "append", "(", "(", "SOURCE", ",", "u", ",", "{", "\n", "\"shape\"", ":", "shape", ",", "\"tensor\"", ":", "tensor", ",", "\"quantizer\"", ":", "None", "}", ")", ")", "\n", "\n", "", "if", "graph", ".", "out_degree", "(", "u", ")", "==", "0", ":", "\n", "      ", "tensor", "=", "graph", ".", "nodes", "[", "u", "]", "[", "\"layer\"", "]", "[", "-", "1", "]", ".", "get_output_at", "(", "0", ")", "\n", "shape", "=", "tensor", ".", "shape", "\n", "\n", "edge_list", ".", "append", "(", "(", "u", ",", "SINK", ",", "{", "\n", "\"shape\"", ":", "shape", ",", "\"tensor\"", ":", "tensor", ",", "\"quantizer\"", ":", "None", "}", ")", ")", "\n", "\n", "", "", "graph", ".", "add_edges_from", "(", "edge_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GenerateInputQuantizerList": [[147, 179], ["qkeras.qtools.quantized_operators.quantizer_factory.QuantizerFactory", "logging.warning", "range", "input_quantizer_list.append", "len", "quantizer_factory_module.QuantizerFactory.make_default_quantizer", "input_quantizer_list.append", "isinstance", "range", "qgraph.WrongInputQuantizerError", "quantizer_factory_module.QuantizerFactory.make_quantizer", "input_quantizer_list.append", "quantizer_factory_module.QuantizerFactory.make_quantizer", "len"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu.range", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer"], ["", "def", "GenerateInputQuantizerList", "(", "input_quantizers", ",", "\n", "inputs_length", ",", "\n", "default_source_quantizer", ")", ":", "\n", "  ", "\"\"\"Generates the list of input quantizers.\"\"\"", "\n", "# generate a list of input quantizers", "\n", "input_quantizer_list", "=", "[", "]", "\n", "quantizer_factory", "=", "quantizer_factory_module", ".", "QuantizerFactory", "(", ")", "\n", "if", "input_quantizers", "is", "None", ":", "\n", "    ", "logging", ".", "warning", "(", "\n", "\"************ SOURCE has no quantizer type.\"", "\n", "\" Use default quantizer instead\"", ")", "\n", "\n", "for", "_", "in", "range", "(", "inputs_length", ")", ":", "\n", "      ", "input_quantizer_list", ".", "append", "(", "\n", "quantizer_factory", ".", "make_default_quantizer", "(", "\n", "mode", "=", "default_source_quantizer", ")", ")", "\n", "", "", "else", ":", "\n", "    ", "if", "inputs_length", "==", "len", "(", "input_quantizers", ")", ":", "\n", "      ", "for", "quantizer", "in", "input_quantizers", ":", "\n", "        ", "input_quantizer_list", ".", "append", "(", "quantizer_factory", ".", "make_quantizer", "(", "\n", "quantizer", ")", ")", "\n", "# pass a single quantizer which will be used for all q list.", "\n", "", "", "elif", "not", "isinstance", "(", "input_quantizers", ",", "list", ")", ":", "\n", "      ", "for", "_", "in", "range", "(", "inputs_length", ")", ":", "\n", "        ", "input_quantizer_list", ".", "append", "(", "quantizer_factory", ".", "make_quantizer", "(", "\n", "input_quantizers", ")", ")", "\n", "", "", "else", ":", "\n", "      ", "raise", "WrongInputQuantizerError", "(", "\n", "\"ERROR: Numer of input (%d) must be the same as number of source\"", "\n", "\" quantizers (%d)\"", "%", "(", "inputs_length", ",", "len", "(", "input_quantizers", ")", ")", ")", "\n", "\n", "", "", "return", "input_quantizer_list", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.AddToNodeDict": [[181, 197], ["isinstance", "i_list.ref", "tmp.ref", "nodes_dict.keys", "nodes_dict[].append"], "function", ["None"], ["", "def", "AddToNodeDict", "(", "layer_items", ",", "\n", "layer", ",", "\n", "nodes_dict", ")", ":", "\n", "  ", "\"\"\"Adds layer to a node_dict, indexed by layer.(input or output).ref\"\"\"", "\n", "i_list", "=", "layer_items", "\n", "if", "not", "isinstance", "(", "layer_items", ",", "list", ")", ":", "\n", "    ", "i_list", "=", "[", "i_list", ".", "ref", "(", ")", "]", "\n", "", "else", ":", "\n", "    ", "i_list", "=", "[", "tmp", ".", "ref", "(", ")", "for", "tmp", "in", "i_list", "]", "\n", "\n", "", "for", "i", "in", "i_list", ":", "\n", "# dict: tensor -> layers have this tensor as input", "\n", "    ", "if", "i", "not", "in", "nodes_dict", ".", "keys", "(", ")", ":", "\n", "      ", "nodes_dict", "[", "i", "]", "=", "[", "layer", "]", "\n", "", "else", ":", "\n", "      ", "nodes_dict", "[", "i", "]", ".", "append", "(", "layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GenerateGraphFromModel": [[199, 287], ["qgraph.GenerateInputQuantizerList", "enumerate", "networkx.DiGraph", "enumerate", "nx.DiGraph.add_nodes_from", "nx.DiGraph.add_edges_from", "qgraph.GraphAddHiddenInputLayer", "len", "node_list.append", "qgraph.AddToNodeDict", "qgraph.AddToNodeDict", "set", "set", "out_nodes.get", "in_nodes.get", "enumerate", "in_nodes.keys", "out_nodes.keys", "tensor.ref", "input_quantizer_map.keys", "edge_list.append", "edge_list.append"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GenerateInputQuantizerList", "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphAddHiddenInputLayer", "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.AddToNodeDict", "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.AddToNodeDict"], ["", "", "", "def", "GenerateGraphFromModel", "(", "model", ",", "\n", "input_quantizers", ",", "\n", "default_source_quantizer", ")", ":", "\n", "  ", "\"\"\"Generates single source, single sink graph from model.\"\"\"", "\n", "\n", "# node represents layers with attributes [layer, type(class_name)]", "\n", "# edge represents the tensor flowing between two layers,", "\n", "# attributes is [tensor, output_shape, QA(activation quantizer]", "\n", "\n", "# input_quantizers are tagged on the edge between input", "\n", "# layer and the following layer", "\n", "\n", "# generate a list of input quantizers", "\n", "input_quantizer_list", "=", "GenerateInputQuantizerList", "(", "input_quantizers", ",", "\n", "len", "(", "model", ".", "inputs", ")", ",", "\n", "default_source_quantizer", ")", "\n", "\n", "# dict that map input_tensor to its quantizer", "\n", "input_quantizer_map", "=", "{", "}", "\n", "for", "(", "idx", ",", "tensor", ")", "in", "enumerate", "(", "model", ".", "inputs", ")", ":", "\n", "    ", "input_quantizer_map", "[", "tensor", ".", "ref", "(", ")", "]", "=", "input_quantizer_list", "[", "idx", "]", "\n", "\n", "", "graph", "=", "nx", ".", "DiGraph", "(", ")", "\n", "\n", "source", "=", "SOURCE", "\n", "sink", "=", "SINK", "\n", "\n", "node_list", "=", "[", "\n", "(", "source", ",", "{", "\"layer\"", ":", "[", "None", "]", ",", "\"type\"", ":", "[", "None", "]", ",", "\"out_quantizer\"", ":", "None", "}", ")", ",", "\n", "(", "sink", ",", "{", "\"layer\"", ":", "[", "None", "]", ",", "\"type\"", ":", "[", "None", "]", ",", "\"out_quantizer\"", ":", "None", "}", ")", "\n", "]", "\n", "\n", "for", "i", ",", "layer", "in", "enumerate", "(", "model", ".", "layers", ")", ":", "\n", "\n", "    ", "node_type", "=", "layer", ".", "__class__", ".", "__name__", "\n", "\n", "node", "=", "(", "i", ",", "{", "\"layer\"", ":", "[", "layer", "]", ",", "\"type\"", ":", "[", "node_type", "]", ",", "\"out_quantizer\"", ":", "None", "}", ")", "\n", "node_list", ".", "append", "(", "node", ")", "\n", "\n", "", "node_dict", "=", "{", "layer", ":", "i", "for", "i", ",", "layer", "in", "enumerate", "(", "model", ".", "layers", ")", "}", "\n", "\n", "graph", ".", "add_nodes_from", "(", "node_list", ")", "\n", "\n", "# nodes = tensors", "\n", "in_nodes", "=", "{", "}", "\n", "out_nodes", "=", "{", "}", "\n", "for", "layer", "in", "model", ".", "layers", ":", "\n", "    ", "AddToNodeDict", "(", "layer", ".", "input", ",", "layer", ",", "in_nodes", ")", "\n", "AddToNodeDict", "(", "layer", ".", "output", ",", "layer", ",", "out_nodes", ")", "\n", "\n", "# union of all tensors; non-redundant", "\n", "", "attr_set", "=", "set", "(", "in_nodes", ".", "keys", "(", ")", ")", "|", "set", "(", "out_nodes", ".", "keys", "(", ")", ")", "\n", "\n", "# add edges. we want edges annotated with tensors and shapes", "\n", "edge_list", "=", "[", "]", "\n", "\n", "for", "a", "in", "attr_set", ":", "\n", "# for a given tensor a, find the layer u that outputs this tensor", "\n", "# and the layer v that has this tensor as input", "\n", "    ", "u_list", "=", "out_nodes", ".", "get", "(", "a", ",", "[", "None", "]", ")", "\n", "v_list", "=", "in_nodes", ".", "get", "(", "a", ",", "[", "None", "]", ")", "\n", "\n", "for", "u", "in", "u_list", ":", "\n", "      ", "for", "v", "in", "v_list", ":", "\n", "        ", "if", "not", "u", "or", "not", "v", ":", "\n", "          ", "continue", "\n", "\n", "", "o_shape", "=", "u", ".", "output_shape", "\n", "\n", "# layer -> layer_id", "\n", "u_id", "=", "node_dict", "[", "u", "]", "\n", "v_id", "=", "node_dict", "[", "v", "]", "\n", "\n", "# insert input_quantizers on the edge between", "\n", "# input layer and its next layer", "\n", "if", "a", "in", "input_quantizer_map", ".", "keys", "(", ")", ":", "\n", "          ", "edge_list", ".", "append", "(", "(", "u_id", ",", "v_id", ",", "{", "\n", "\"shape\"", ":", "o_shape", ",", "\"tensor\"", ":", "a", ",", "\n", "\"quantizer\"", ":", "input_quantizer_map", "[", "a", "]", "}", ")", ")", "\n", "", "else", ":", "\n", "          ", "edge_list", ".", "append", "(", "(", "u_id", ",", "v_id", ",", "{", "\n", "\"shape\"", ":", "o_shape", ",", "\"tensor\"", ":", "a", ",", "\n", "\"quantizer\"", ":", "None", "}", ")", ")", "\n", "\n", "", "", "", "", "graph", ".", "add_edges_from", "(", "edge_list", ")", "\n", "GraphAddHiddenInputLayer", "(", "model", ",", "graph", ",", "input_quantizer_map", ")", "\n", "\n", "return", "(", "graph", ",", "input_quantizer_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphGetInputs": [[289, 305], ["list", "graph.successors", "input_tensors.append"], "function", ["None"], ["", "def", "GraphGetInputs", "(", "graph", ")", ":", "\n", "\n", "  ", "\"\"\"Returns edges SOURCE->u that are inputs.\"\"\"", "\n", "\n", "successors", "=", "list", "(", "graph", ".", "successors", "(", "SOURCE", ")", ")", "\n", "\n", "input_tensors", "=", "[", "]", "\n", "\n", "for", "u", "in", "successors", ":", "\n", "\n", "    ", "if", "u", "==", "SOURCE", "or", "u", "==", "SINK", ":", "\n", "      ", "continue", "\n", "\n", "", "input_tensors", ".", "append", "(", "graph", "[", "SOURCE", "]", "[", "u", "]", ")", "\n", "\n", "", "return", "input_tensors", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphGetOutputs": [[307, 323], ["list", "graph.predecessors", "output_tensors.append"], "function", ["None"], ["", "def", "GraphGetOutputs", "(", "graph", ")", ":", "\n", "\n", "  ", "\"\"\"Returns edges u->SINK that are outputs.\"\"\"", "\n", "\n", "predecessors", "=", "list", "(", "graph", ".", "predecessors", "(", "SINK", ")", ")", "\n", "\n", "output_tensors", "=", "[", "]", "\n", "\n", "for", "u", "in", "predecessors", ":", "\n", "\n", "    ", "if", "u", "==", "SOURCE", "or", "u", "==", "SINK", ":", "\n", "      ", "continue", "\n", "\n", "", "output_tensors", ".", "append", "(", "graph", "[", "u", "]", "[", "SINK", "]", ")", "\n", "\n", "", "return", "output_tensors", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphPropagateActivationsToEdges": [[325, 393], ["list", "networkx.topological_sort", "graph.edges", "print", "print", "print", "hasattr", "print", "hasattr", "hasattr", "print", "print", "print", "print", "hasattr"], "function", ["None"], ["", "def", "GraphPropagateActivationsToEdges", "(", "graph", ",", "debug", "=", "False", ")", ":", "\n", "  ", "\"\"\"Traverses graph and move activations to edges.\n\n  1.If current dense/conv layer is specified with QA:\n    outgoing edge (output data type) will be QA type\n  2.If current dense/conv layer has no QA:\n    default type (float32) is used as output\n  3.If current layer is QA layer:\n    float32 is used by default as output type on the edge\n\n  Args:\n    graph: graph to inject activations to.\n    debug: debug mode\n\n  Returns:\n    None\n  \"\"\"", "\n", "\n", "scheduler", "=", "list", "(", "nx", ".", "topological_sort", "(", "graph", ")", ")", "\n", "\n", "for", "vertex", "in", "scheduler", "[", "1", ":", "-", "1", "]", ":", "\n", "# get rid of source and sink vertex", "\n", "    ", "if", "debug", ":", "\n", "      ", "print", "(", "\"########### GraphPropagateActivationsToEdges ############\"", ")", "\n", "print", "(", "\"vertex:\"", ",", "vertex", ")", "\n", "\n", "", "for", "u", ",", "v", "in", "graph", ".", "edges", "(", "vertex", ")", ":", "\n", "# u=vertex, v: outgoing edge vertex", "\n", "\n", "      ", "if", "debug", ":", "\n", "        ", "print", "(", "\"  outgoing ->\"", ",", "v", ",", "graph", ".", "nodes", "[", "v", "]", "[", "\"layer\"", "]", "[", "0", "]", ".", "name", ")", "\n", "\n", "", "layer", "=", "graph", ".", "nodes", "[", "u", "]", "[", "\"layer\"", "]", "[", "0", "]", "\n", "result", "=", "None", "\n", "# if current layer has no QA specified", "\n", "if", "not", "hasattr", "(", "layer", ",", "\"activation\"", ")", ":", "\n", "        ", "result", "=", "None", "\n", "", "else", ":", "\n", "        ", "activation_name", "=", "layer", ".", "activation", ".", "__name__", "if", "hasattr", "(", "\n", "layer", ".", "activation", ",", "\"__name__\"", ")", "else", "None", "\n", "q_activation_class_name", "=", "layer", ".", "activation", ".", "__class__", ".", "__name__", "if", "hasattr", "(", "\n", "layer", ".", "activation", ",", "\"__class__\"", ")", "else", "None", "\n", "\n", "if", "debug", ":", "\n", "          ", "print", "(", "\"  layer type:\"", ",", "layer", ".", "__class__", ".", "__name__", ")", "\n", "print", "(", "\"  activation object:\"", ",", "layer", ".", "activation", ")", "\n", "print", "(", "\"  activation_name:\"", ",", "activation_name", ")", "\n", "print", "(", "\"  q_activation_class_name:\"", ",", "q_activation_class_name", ")", "\n", "\n", "# if current layer is QA", "\n", "", "if", "(", "graph", ".", "nodes", "[", "u", "]", "[", "\"type\"", "]", "[", "0", "]", "in", "[", "\"QActivation\"", "]", "or", "\n", "graph", ".", "nodes", "[", "u", "]", "[", "\"type\"", "]", "[", "0", "]", "in", "[", "\"QAdaptiveActivation\"", "]", ")", ":", "\n", "          ", "result", "=", "layer", ".", "quantizer", "\n", "\n", "# if current layer is not QA layer but has QA specified within", "\n", "", "elif", "hasattr", "(", "layer", ",", "\"activation\"", ")", ":", "\n", "          ", "if", "activation_name", "==", "\"linear\"", ":", "\n", "            ", "result", "=", "None", "\n", "", "else", ":", "\n", "            ", "result", "=", "layer", ".", "activation", "\n", "\n", "", "", "", "if", "debug", ":", "\n", "        ", "print", "(", "\"  {}->{}: {}\"", ".", "format", "(", "u", ",", "v", ",", "result", ")", ")", "\n", "\n", "", "graph", "[", "u", "]", "[", "v", "]", "[", "\"quantizer\"", "]", "=", "result", "\n", "# all edge_quantizer is the same for all edges starting", "\n", "# from current vertex to different nodes", "\n", "graph", ".", "nodes", "[", "vertex", "]", "[", "\"out_quantizer\"", "]", "=", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.PrintGraph": [[395, 409], ["print", "print", "print", "print", "print", "print"], "function", ["None"], ["", "", "", "def", "PrintGraph", "(", "graph", ",", "msg", "=", "\"\"", ")", ":", "\n", "  ", "\"\"\"Print graph structure.\"\"\"", "\n", "\n", "print", "(", ")", "\n", "print", "(", "msg", ")", "\n", "print", "(", ")", "\n", "print", "(", "\"nodes:\"", ",", "\n", "[", "(", "u", ",", "graph", ".", "nodes", "[", "u", "]", "[", "\"layer\"", "]", "[", "\n", "0", "]", ".", "name", "if", "graph", ".", "nodes", "[", "u", "]", "[", "\"layer\"", "]", "[", "0", "]", "is", "not", "None", "else", "\"\"", ",", "\n", "graph", ".", "nodes", "[", "u", "]", "[", "\"type\"", "]", ")", "for", "u", "in", "graph", ".", "nodes", "]", ")", "\n", "print", "(", ")", "\n", "print", "(", "\"edges:\"", ",", "\n", "[", "(", "u", ",", "v", ",", "graph", "[", "u", "]", "[", "v", "]", "[", "\"shape\"", "]", ",", "\n", "graph", "[", "u", "]", "[", "v", "]", "[", "\"quantizer\"", "]", ")", "for", "u", ",", "v", "in", "graph", ".", "edges", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.CreateGraph": [[411, 435], ["tensorflow.set_image_data_format", "qgraph.GenerateGraphFromModel", "qgraph.GraphAddSingleSourceSingleSink", "qgraph.GraphRemoveNodeWithNodeType", "qgraph.GraphRemoveNodeWithNodeType", "list", "networkx.topological_sort", "graph.edges", "print"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GenerateGraphFromModel", "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphAddSingleSourceSingleSink", "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphRemoveNodeWithNodeType", "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphRemoveNodeWithNodeType"], ["", "def", "CreateGraph", "(", "model", ",", "input_quantizers", "=", "None", ",", "\n", "default_source_quantizer", "=", "cfg", ".", "default_source_quantizer", ",", "\n", "debug", "=", "False", ")", ":", "\n", "  ", "\"\"\"create graph.\"\"\"", "\n", "\n", "K", ".", "set_image_data_format", "(", "\"channels_last\"", ")", "\n", "\n", "(", "graph", ",", "source_quantizer_list", ")", "=", "GenerateGraphFromModel", "(", "\n", "model", ",", "input_quantizers", ",", "default_source_quantizer", ")", "\n", "GraphAddSingleSourceSingleSink", "(", "graph", ")", "\n", "GraphRemoveNodeWithNodeType", "(", "graph", ",", "\"Dropout\"", ")", "\n", "GraphRemoveNodeWithNodeType", "(", "graph", ",", "\"InputLayer\"", ")", "\n", "\n", "scheduler", "=", "list", "(", "nx", ".", "topological_sort", "(", "graph", ")", ")", "\n", "\n", "if", "debug", ":", "\n", "    ", "for", "vertex", "in", "scheduler", "[", "1", ":", "-", "1", "]", ":", "\n", "      ", "for", "_", ",", "v", "in", "graph", ".", "edges", "(", "vertex", ")", ":", "\n", "        ", "if", "v", "==", "SINK", ":", "\n", "          ", "continue", "\n", "", "print", "(", "\"... calling\"", ",", "graph", ".", "nodes", "[", "v", "]", "[", "\n", "\"layer\"", "]", "[", "0", "]", ".", "name", ",", "graph", ".", "nodes", "[", "v", "]", "[", "\"type\"", "]", ")", "\n", "\n", "", "", "", "return", "(", "graph", ",", "source_quantizer_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphUpdateEdge": [[437, 442], ["graph.edges"], "function", ["None"], ["", "def", "GraphUpdateEdge", "(", "graph", ",", "node_id", ",", "quantizer_on_edge", ")", ":", "\n", "  ", "\"\"\"update the graph edges outgoing from node_id with new quantizer.\"\"\"", "\n", "\n", "for", "u", ",", "v", "in", "graph", ".", "edges", "(", "node_id", ")", ":", "\n", "    ", "graph", "[", "u", "]", "[", "v", "]", "[", "\"quantizer\"", "]", "=", "quantizer_on_edge", "\n", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.qtools.run_qtools.QTools.__init__": [[35, 64], ["qkeras.qtools.settings.cfg.update", "qkeras.qtools.qgraph.CreateGraph", "qkeras.qtools.qgraph.GraphPropagateActivationsToEdges", "qkeras.qtools.generate_layer_data_type_map.generate_layer_data_type_map", "qkeras.qtools.interface.map_to_json", "run_qtools.QTools._model.load_weights"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qtools.settings.ConfigClass.update", "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.CreateGraph", "home.repos.pwc.inspect_result.google_qkeras.qtools.qgraph.GraphPropagateActivationsToEdges", "home.repos.pwc.inspect_result.google_qkeras.qtools.generate_layer_data_type_map.generate_layer_data_type_map", "home.repos.pwc.inspect_result.google_qkeras.qtools.interface.map_to_json"], ["def", "__init__", "(", "self", ",", "model", ",", "process", ",", "source_quantizers", "=", "None", ",", "\n", "is_inference", "=", "False", ",", "weights_path", "=", "None", ",", "\n", "keras_quantizer", "=", "None", ",", "keras_accumulator", "=", "None", ",", "\n", "for_reference", "=", "False", ",", "\n", "model_weights_already_quantized", "=", "True", ",", "\n", "hw_weight_dict", "=", "None", ")", ":", "\n", "\n", "    ", "if", "model", "is", "not", "None", ":", "\n", "      ", "self", ".", "_model", "=", "model", "\n", "\n", "", "if", "weights_path", "is", "not", "None", ":", "\n", "      ", "self", ".", "_model", ".", "load_weights", "(", "weights_path", ")", "\n", "\n", "", "cfg", ".", "update", "(", "process", ",", "config_settings", ")", "\n", "\n", "# if source_quantizers is None, CreateGraph will use", "\n", "# default_source_quantizers defined in cfg", "\n", "(", "graph", ",", "source_quantizer_list", ")", "=", "qgraph", ".", "CreateGraph", "(", "\n", "model", ",", "source_quantizers", ",", "cfg", ".", "default_source_quantizer", ")", "\n", "\n", "# qgraph.PrintGraph(graph)", "\n", "qgraph", ".", "GraphPropagateActivationsToEdges", "(", "graph", ")", "\n", "self", ".", "_layer_map", "=", "generate_layer_data_type_map", ".", "generate_layer_data_type_map", "(", "\n", "graph", ",", "source_quantizer_list", ",", "is_inference", ",", "\n", "keras_quantizer", ",", "keras_accumulator", ",", "for_reference", ",", "\n", "model_weights_already_quantized", "=", "model_weights_already_quantized", ",", "\n", "hw_weight_dict", "=", "hw_weight_dict", ")", "\n", "\n", "self", ".", "_output_dict", "=", "interface", ".", "map_to_json", "(", "self", ".", "_layer_map", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.run_qtools.QTools.qtools_stats_to_json": [[65, 70], ["open", "json.dump"], "methods", ["None"], ["", "def", "qtools_stats_to_json", "(", "self", ",", "json_name", ")", ":", "\n", "    ", "\"\"\"dump the layer stats to a json file.\"\"\"", "\n", "\n", "with", "open", "(", "json_name", ",", "\"w\"", ")", "as", "outfile", ":", "\n", "      ", "json", ".", "dump", "(", "self", ".", "_output_dict", ",", "outfile", ",", "indent", "=", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.run_qtools.QTools.qtools_stats_print": [[71, 76], ["json.dumps", "print"], "methods", ["None"], ["", "", "def", "qtools_stats_print", "(", "self", ")", ":", "\n", "    ", "\"\"\"print out the layer stats.\"\"\"", "\n", "\n", "dict_to_json", "=", "json", ".", "dumps", "(", "self", ".", "_output_dict", ",", "indent", "=", "4", ")", "\n", "print", "(", "dict_to_json", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.run_qtools.QTools.pe": [[77, 96], ["qkeras.qtools.qenergy.qenergy.energy_estimate", "print", "json.dumps", "print"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qenergy.qenergy.energy_estimate"], ["", "def", "pe", "(", "self", ",", "weights_on_memory", "=", "\"dram\"", ",", "\n", "activations_on_memory", "=", "\"dram\"", ",", "\n", "min_sram_size", "=", "0", ",", "\n", "rd_wr_on_io", "=", "True", ",", "\n", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"energy consumption calculation.\"\"\"", "\n", "\n", "assert", "weights_on_memory", "in", "[", "\"dram\"", ",", "\"sram\"", ",", "\"fixed\"", "]", "\n", "energy_dict", "=", "qenergy", ".", "energy_estimate", "(", "\n", "self", ".", "_model", ",", "self", ".", "_layer_map", ",", "weights_on_memory", ",", "\n", "activations_on_memory", ",", "min_sram_size", ",", "\n", "rd_wr_on_io", ")", "\n", "\n", "if", "verbose", ":", "\n", "      ", "print", "(", "\"COST:\"", ")", "\n", "dict_to_json", "=", "json", ".", "dumps", "(", "energy_dict", ",", "indent", "=", "4", ")", "\n", "print", "(", "dict_to_json", ")", "\n", "\n", "", "return", "energy_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.run_qtools.QTools.extract_energy_sum": [[97, 110], ["energy_dict.keys", "int", "cfg_setting.get", "sum", "cfg_setting.get"], "methods", ["None"], ["", "def", "extract_energy_sum", "(", "self", ",", "cfg_setting", ",", "energy_dict", ")", ":", "\n", "    ", "\"\"\"extracted energy needed in caculating sum.\"\"\"", "\n", "\n", "value", "=", "0", "\n", "for", "layer", "in", "energy_dict", ".", "keys", "(", ")", ":", "\n", "      ", "if", "layer", "==", "\"total_cost\"", ":", "\n", "        ", "continue", "\n", "\n", "", "class_name", "=", "energy_dict", "[", "layer", "]", "[", "\"class_name\"", "]", "\n", "keys", "=", "cfg_setting", ".", "get", "(", "class_name", ",", "cfg_setting", ".", "get", "(", "\"default\"", ",", "[", "]", ")", ")", "\n", "value", "+=", "sum", "(", "[", "energy_dict", "[", "layer", "]", "[", "\"energy\"", "]", "[", "key", "]", "for", "key", "in", "keys", "]", ")", "\n", "\n", "", "return", "int", "(", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qtools.run_qtools.QTools.extract_energy_profile": [[111, 127], ["energy_dict.keys", "cfg_setting.get", "sum", "cfg_setting.get"], "methods", ["None"], ["", "def", "extract_energy_profile", "(", "self", ",", "cfg_setting", ",", "energy_dict", ")", ":", "\n", "    ", "\"\"\"extract energy consumption in each layer.\"\"\"", "\n", "\n", "energy", "=", "{", "}", "\n", "for", "layer", "in", "energy_dict", ".", "keys", "(", ")", ":", "\n", "      ", "if", "layer", "==", "\"total_cost\"", ":", "\n", "        ", "continue", "\n", "\n", "", "class_name", "=", "energy_dict", "[", "layer", "]", "[", "\"class_name\"", "]", "\n", "keys", "=", "cfg_setting", ".", "get", "(", "class_name", ",", "cfg_setting", ".", "get", "(", "\"default\"", ",", "[", "]", ")", ")", "\n", "energy", "[", "layer", "]", "=", "{", "}", "\n", "energy", "[", "layer", "]", "[", "\"energy\"", "]", "=", "energy_dict", "[", "layer", "]", "[", "\"energy\"", "]", "\n", "energy", "[", "layer", "]", "[", "\"total\"", "]", "=", "sum", "(", "\n", "[", "energy_dict", "[", "layer", "]", "[", "\"energy\"", "]", "[", "key", "]", "for", "key", "in", "keys", "]", ")", "\n", "\n", "", "return", "energy", "\n", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.accumulator_impl.IAccumulator.implemented_as": [[47, 51], ["None"], "methods", ["None"], ["@", "staticmethod", "\n", "@", "abc", ".", "abstractmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.accumulator_impl.FloatingPointAccumulator.__init__": [[56, 70], ["abc.ABC.__init__", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "multiplier", ":", "multiplier_impl", ".", "IMultiplier", "\n", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "multiplier", "=", "multiplier", "\n", "self", ".", "output", "=", "quantizer_impl", ".", "FloatingPoint", "(", "\n", "bits", "=", "self", ".", "multiplier", ".", "output", ".", "bits", ")", "\n", "self", ".", "output", ".", "bits", "=", "self", ".", "multiplier", ".", "output", ".", "bits", "\n", "self", ".", "output", ".", "int_bits", "=", "-", "1", "\n", "self", ".", "output", ".", "is_signed", "=", "self", ".", "multiplier", ".", "output", ".", "is_signed", "\n", "self", ".", "output", ".", "is_floating_point", "=", "True", "\n", "self", ".", "output", ".", "op_type", "=", "\"accumulator\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.accumulator_impl.FloatingPointAccumulator.implemented_as": [[71, 74], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "    ", "return", "\"add\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.accumulator_impl.FixedPointAccumulator.__init__": [[79, 114], ["abc.ABC.__init__", "numpy.prod", "int", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits", "len", "absl.logging.fatal", "numpy.ceil", "numpy.log2"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "kernel_shape", ",", "\n", "multiplier", ":", "multiplier_impl", ".", "IMultiplier", ",", "\n", "use_bias", "=", "True", "\n", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "len", "(", "kernel_shape", ")", "not", "in", "(", "\n", "2", ",", "\n", "4", ",", "\n", ")", ":", "\n", "      ", "logging", ".", "fatal", "(", "\n", "\"unsupported kernel shape, \"", "\n", "\"it is neither a dense kernel of length 2,\"", "\n", "\" nor a convolution kernel of length 4\"", ")", "\n", "\n", "", "kernel_shape_excluding_output_dim", "=", "kernel_shape", "[", ":", "-", "1", "]", "\n", "kernel_add_ops", "=", "np", ".", "prod", "(", "kernel_shape_excluding_output_dim", ")", "\n", "\n", "# bias are associate with filters; each filter adds 1 bias", "\n", "bias_add", "=", "1", "if", "use_bias", "else", "0", "\n", "\n", "add_ops", "=", "kernel_add_ops", "+", "bias_add", "\n", "self", ".", "log_add_ops", "=", "int", "(", "np", ".", "ceil", "(", "np", ".", "log2", "(", "add_ops", ")", ")", ")", "\n", "\n", "self", ".", "multiplier", "=", "multiplier", "\n", "self", ".", "output", "=", "quantizer_impl", ".", "QuantizedBits", "(", ")", "\n", "self", ".", "output", ".", "bits", "=", "self", ".", "log_add_ops", "+", "self", ".", "multiplier", ".", "output", ".", "bits", "\n", "self", ".", "output", ".", "int_bits", "=", "self", ".", "log_add_ops", "+", "self", ".", "multiplier", ".", "output", ".", "int_bits", "\n", "self", ".", "output", ".", "is_signed", "=", "self", ".", "multiplier", ".", "output", ".", "is_signed", "\n", "self", ".", "output", ".", "op_type", "=", "\"accumulator\"", "\n", "\n", "assert", "not", "self", ".", "multiplier", ".", "output", ".", "is_floating_point", "\n", "self", ".", "output", ".", "is_floating_point", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.accumulator_impl.FixedPointAccumulator.implemented_as": [[115, 118], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "    ", "return", "\"add\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.accumulator_impl.Po2Accumulator.__init__": [[126, 142], ["accumulator_impl.FixedPointAccumulator.__init__", "accumulator_impl.po2_to_qbits", "int", "int"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.accumulator_impl.po2_to_qbits"], ["def", "__init__", "(", "\n", "self", ",", "\n", "kernel_shape", ",", "\n", "multiplier", ":", "multiplier_impl", ".", "IMultiplier", ",", "\n", "use_bias", "=", "True", "\n", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "kernel_shape", ",", "multiplier", ",", "use_bias", ")", "\n", "\n", "assert", "multiplier", ".", "output", ".", "is_po2", "\n", "# convert multiplier output from po2 to quantized_bits", "\n", "(", "bits_from_po2multiplier", ",", "int_bits_from_po2multiplier", ")", "=", "po2_to_qbits", "(", "\n", "multiplier", ".", "output", ")", "\n", "\n", "self", ".", "output", ".", "bits", "=", "self", ".", "log_add_ops", "+", "int", "(", "bits_from_po2multiplier", ")", "\n", "self", ".", "output", ".", "int_bits", "=", "self", ".", "log_add_ops", "+", "int", "(", "int_bits_from_po2multiplier", ")", "\n", "self", ".", "output", ".", "op_type", "=", "\"accumulator\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.accumulator_impl.Po2Accumulator.implemented_as": [[143, 146], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "    ", "return", "\"add\"", "\n", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.accumulator_impl.po2_to_qbits": [[30, 42], ["quantizer.get_min_max_exp", "int", "int"], "function", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.PowerOfTwo.get_min_max_exp"], ["def", "po2_to_qbits", "(", "quantizer", ":", "quantizer_impl", ".", "IQuantizer", ")", ":", "\n", "  ", "\"\"\"convert po2 type to qbits type.\"\"\"", "\n", "\n", "(", "min_exp", ",", "max_exp", ")", "=", "quantizer", ".", "get_min_max_exp", "(", ")", "\n", "# min_exp is number of bits needed on the right in qbits", "\n", "# max_exp is number of bits needed on the left in qbits", "\n", "unsigned_bits", "=", "min_exp", "+", "max_exp", "\n", "int_bits", "=", "max_exp", "\n", "sign_bit", "=", "quantizer", ".", "is_signed", "\n", "bits", "=", "sign_bit", "+", "unsigned_bits", "\n", "\n", "return", "(", "int", "(", "bits", ")", ",", "int", "(", "int_bits", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.IMultiplier.__init__": [[34, 41], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "weight_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "input_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "output_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ")", ":", "\n", "    ", "self", ".", "input", "=", "input_quantizer", "\n", "self", ".", "weights", "=", "weight_quantizer", "\n", "self", ".", "output", "=", "output_quantizer", "\n", "self", ".", "output", ".", "op_type", "=", "\"multiplier\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.IMultiplier.implemented_as": [[42, 46], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "abc", ".", "abstractmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.IMultiplier.name": [[47, 49], ["None"], "methods", ["None"], ["", "def", "name", "(", "self", ")", "->", "str", ":", "\n", "    ", "return", "self", ".", "output", ".", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.IMultiplier.output_quantizer": [[50, 52], ["None"], "methods", ["None"], ["", "def", "output_quantizer", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.Mux.__init__": [[66, 113], ["multiplier_impl.IMultiplier.__init__", "any"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "weight_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "input_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "output_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "weight_quantizer", ",", "input_quantizer", ",", "\n", "output_quantizer", ")", "\n", "self", ".", "output", ".", "is_signed", "=", "self", ".", "input", ".", "is_signed", "|", "self", ".", "weights", ".", "is_signed", "\n", "\n", "if", "any", "(", "s", "in", "weight_quantizer", ".", "name", "for", "s", "in", "[", "\"binary\"", ",", "\"ternary\"", "]", ")", ":", "\n", "      ", "self", ".", "output", ".", "bits", "=", "input_quantizer", ".", "bits", "\n", "self", ".", "output", ".", "int_bits", "=", "input_quantizer", ".", "int_bits", "\n", "if", "not", "input_quantizer", ".", "is_signed", "and", "weight_quantizer", ".", "is_signed", ":", "\n", "        ", "self", ".", "output", ".", "bits", "+=", "1", "\n", "\n", "# multiplier factor for gate counts", "\n", "# gate_factor is the relative energy of given gate comparing", "\n", "# to an Add gate, giving that Add gate is 1", "\n", "", "if", "\"binary\"", "in", "weight_quantizer", ".", "name", ":", "\n", "        ", "self", ".", "gate_factor", "=", "0.3", "\n", "", "else", ":", "\n", "        ", "self", ".", "gate_factor", "=", "2", "*", "0.3", "\n", "", "self", ".", "gate_bits", "=", "input_quantizer", ".", "bits", "\n", "\n", "", "else", ":", "\n", "      ", "self", ".", "output", ".", "bits", "=", "weight_quantizer", ".", "bits", "\n", "self", ".", "output", ".", "int_bits", "=", "weight_quantizer", ".", "int_bits", "\n", "if", "not", "weight_quantizer", ".", "is_signed", "and", "input_quantizer", ".", "is_signed", ":", "\n", "        ", "self", ".", "output", ".", "bits", "+=", "1", "\n", "\n", "# multiplier factor for gate counts", "\n", "", "if", "input_quantizer", ".", "name", "==", "\"binary\"", ":", "\n", "        ", "self", ".", "gate_factor", "=", "0.3", "\n", "", "else", ":", "\n", "        ", "self", ".", "gate_factor", "=", "2", "*", "0.3", "\n", "", "self", ".", "gate_bits", "=", "weight_quantizer", ".", "bits", "\n", "\n", "", "if", "\"po2\"", "in", "output_quantizer", ".", "name", ":", "\n", "      ", "if", "self", ".", "output", ".", "is_signed", ":", "\n", "        ", "output_quantizer", ".", "name", "=", "\"quantized_po2\"", "\n", "", "else", ":", "\n", "        ", "output_quantizer", ".", "name", "=", "\"quantized_relu_po2\"", "\n", "\n", "", "if", "\"po2\"", "in", "weight_quantizer", ".", "name", ":", "\n", "        ", "self", ".", "output", ".", "max_val_po2", "=", "weight_quantizer", ".", "max_val_po2", "\n", "", "else", ":", "\n", "        ", "self", ".", "output", ".", "max_val_po2", "=", "input_quantizer", ".", "max_val_po2", "\n", "\n", "", "self", ".", "output", ".", "int_bits", "=", "self", ".", "output", ".", "bits", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.Mux.implemented_as": [[114, 117], ["None"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "    ", "return", "\"mux\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.XorGate.__init__": [[122, 136], ["multiplier_impl.IMultiplier.__init__", "max", "max", "multiplier_impl.assert_neither_input_and_weights_is_floating_point"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.assert_neither_input_and_weights_is_floating_point"], ["def", "__init__", "(", "self", ",", "weight_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "input_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "output_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "weight_quantizer", ",", "input_quantizer", ",", "output_quantizer", ")", "\n", "\n", "if", "output_quantizer", ".", "name", "!=", "\"ternary\"", ":", "\n", "      ", "self", ".", "output", ".", "bits", "=", "max", "(", "self", ".", "input", ".", "bits", ",", "self", ".", "weights", ".", "bits", ")", "\n", "self", ".", "output", ".", "int_bits", "=", "max", "(", "self", ".", "input", ".", "int_bits", ",", "self", ".", "weights", ".", "int_bits", ")", "\n", "self", ".", "output", ".", "is_signed", "=", "self", ".", "input", ".", "is_signed", "|", "self", ".", "weights", ".", "is_signed", "\n", "assert_neither_input_and_weights_is_floating_point", "(", "self", ")", "\n", "self", ".", "output", ".", "is_floating_point", "=", "False", "\n", "\n", "", "self", ".", "gate_factor", "=", "0.3", "\n", "self", ".", "gate_bits", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.XorGate.implemented_as": [[137, 140], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "    ", "return", "\"xor\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.Shifter.__init__": [[183, 226], ["multiplier_impl.IMultiplier.__init__", "po2_quantizer.get_min_max_exp", "int", "int", "multiplier_impl.assert_neither_input_and_weights_is_floating_point", "numpy.sqrt", "numpy.log10"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.PowerOfTwo.get_min_max_exp", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.assert_neither_input_and_weights_is_floating_point"], ["def", "__init__", "(", "\n", "self", ",", "weight_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "input_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "output_quantizer", ":", "quantizer_impl", ".", "IQuantizer", "\n", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "weight_quantizer", ",", "input_quantizer", ",", "output_quantizer", ")", "\n", "\n", "# locate the po2 quantizer", "\n", "mode_w", "=", "weight_quantizer", ".", "mode", "\n", "if", "mode_w", "==", "1", ":", "\n", "      ", "po2_quantizer", "=", "weight_quantizer", "\n", "qbit_quantizer", "=", "input_quantizer", "\n", "", "else", ":", "\n", "      ", "po2_quantizer", "=", "input_quantizer", "\n", "qbit_quantizer", "=", "weight_quantizer", "\n", "\n", "# find min_exp and max_exp of po2 quantizer", "\n", "", "(", "min_exp", ",", "max_exp", ")", "=", "po2_quantizer", ".", "get_min_max_exp", "(", ")", "\n", "qbits_bits", "=", "qbit_quantizer", ".", "bits", "\n", "qbits_int_bits", "=", "qbit_quantizer", ".", "int_bits", "\n", "\n", "self", ".", "output", ".", "bits", "=", "int", "(", "qbits_bits", "+", "max_exp", "+", "min_exp", ")", "\n", "if", "(", "not", "qbit_quantizer", ".", "is_signed", ")", "and", "po2_quantizer", ".", "is_signed", ":", "\n", "# if qbit is signed, qbits_bits already has the sign_bit, no need to +1", "\n", "# if qbit is un_signed, po2 is unsigned, no need to +1", "\n", "# if qbit is un_signed, po2 is signed, min_exp and max_exp", "\n", "# didnot include sign_bit,", "\n", "# therefore need to +1", "\n", "      ", "self", ".", "output", ".", "bits", "+=", "1", "\n", "\n", "", "self", ".", "output", ".", "int_bits", "=", "int", "(", "qbits_int_bits", "+", "max_exp", ")", "\n", "self", ".", "output", ".", "is_signed", "=", "qbit_quantizer", ".", "is_signed", "|", "po2_quantizer", ".", "is_signed", "\n", "\n", "assert_neither_input_and_weights_is_floating_point", "(", "self", ")", "\n", "self", ".", "output", ".", "is_floating_point", "=", "False", "\n", "\n", "if", "po2_quantizer", ".", "inference_value_counts", ">", "0", ":", "\n", "      ", "self", ".", "gate_factor", "=", "po2_quantizer", ".", "inference_value_counts", "*", "0.3", "\n", "self", ".", "gate_bits", "=", "qbits_bits", "\n", "", "else", ":", "\n", "      ", "self", ".", "gate_factor", "=", "1", "\n", "b", "=", "np", ".", "sqrt", "(", "2", "**", "po2_quantizer", ".", "bits", "*", "qbits_bits", ")", "\n", "self", ".", "gate_bits", "=", "b", "*", "np", ".", "log10", "(", "b", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.Shifter.implemented_as": [[227, 230], ["None"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "    ", "return", "\"shifter\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.AndGate.__init__": [[236, 271], ["multiplier_impl.IMultiplier.__init__", "max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["def", "__init__", "(", "\n", "self", ",", "weight_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "input_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "output_quantizer", ":", "quantizer_impl", ".", "IQuantizer", "\n", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "weight_quantizer", ",", "input_quantizer", ",", "output_quantizer", ")", "\n", "\n", "# if output is ternary, no need for further computation", "\n", "if", "self", ".", "output", ".", "name", "!=", "\"ternary\"", ":", "\n", "      ", "self", ".", "output", ".", "bits", "=", "max", "(", "self", ".", "input", ".", "bits", ",", "self", ".", "weights", ".", "bits", ")", "\n", "\n", "self", ".", "output", ".", "is_signed", "=", "self", ".", "input", ".", "is_signed", "|", "self", ".", "weights", ".", "is_signed", "\n", "self", ".", "output", ".", "is_floating_point", "=", "self", ".", "input", ".", "is_floating_point", "|", "self", ".", "weights", ".", "is_floating_point", "\n", "\n", "if", "weight_quantizer", ".", "name", "==", "\"binary\"", "and", "weight_quantizer", ".", "use_01", ":", "\n", "# binary(0,1) * datatype -> int_bits = datatype.int_bits", "\n", "        ", "self", ".", "output", ".", "int_bits", "=", "input_quantizer", ".", "int_bits", "\n", "", "else", ":", "\n", "        ", "self", ".", "output", ".", "int_bits", "=", "weight_quantizer", ".", "int_bits", "\n", "\n", "", "if", "\"po2\"", "in", "output_quantizer", ".", "name", ":", "\n", "# binary * po2", "\n", "        ", "if", "self", ".", "output", ".", "is_signed", ":", "\n", "          ", "output_quantizer", ".", "name", "=", "\"quantized_po2\"", "\n", "", "else", ":", "\n", "          ", "output_quantizer", ".", "name", "=", "\"quantized_relu_po2\"", "\n", "\n", "", "if", "\"po2\"", "in", "weight_quantizer", ".", "name", ":", "\n", "          ", "self", ".", "output", ".", "max_val_po2", "=", "weight_quantizer", ".", "max_val_po2", "\n", "", "else", ":", "\n", "          ", "self", ".", "output", ".", "max_val_po2", "=", "input_quantizer", ".", "max_val_po2", "\n", "\n", "", "", "", "self", ".", "gate_bits", "=", "self", ".", "output", ".", "bits", "\n", "self", ".", "gate_factor", "=", "0.1", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.AndGate.implemented_as": [[272, 275], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "    ", "return", "\"and\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.Adder.__init__": [[280, 308], ["multiplier_impl.IMultiplier.__init__", "multiplier_impl.assert_neither_input_and_weights_is_floating_point", "max", "max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.assert_neither_input_and_weights_is_floating_point", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["def", "__init__", "(", "self", ",", "weight_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "input_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "output_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "weight_quantizer", ",", "input_quantizer", ",", "\n", "output_quantizer", ")", "\n", "self", ".", "output", ".", "bits", "=", "max", "(", "self", ".", "input", ".", "bits", ",", "self", ".", "weights", ".", "bits", ")", "+", "1", "\n", "self", ".", "output", ".", "int_bits", "=", "max", "(", "self", ".", "input", ".", "int_bits", ",", "\n", "self", ".", "weights", ".", "int_bits", ")", "+", "1", "\n", "self", ".", "output", ".", "is_signed", "=", "self", ".", "input", ".", "is_signed", "|", "self", ".", "weights", ".", "is_signed", "\n", "assert_neither_input_and_weights_is_floating_point", "(", "self", ")", "\n", "self", ".", "output", ".", "is_floating_point", "=", "False", "\n", "self", ".", "output", ".", "is_po2", "=", "1", "\n", "\n", "if", "self", ".", "input", ".", "max_val_po2", "==", "-", "1", "or", "self", ".", "weights", ".", "max_val_po2", "==", "-", "1", ":", "\n", "      ", "self", ".", "output", ".", "max_val_po2", "=", "-", "1", "\n", "", "else", ":", "\n", "# Adder is two po2_value multiply with each other", "\n", "      ", "self", ".", "output", ".", "max_val_po2", "=", "self", ".", "input", ".", "max_val_po2", "*", "self", ".", "weights", ".", "max_val_po2", "\n", "\n", "", "if", "\"po2\"", "in", "output_quantizer", ".", "name", ":", "\n", "# po2 * po2", "\n", "      ", "if", "self", ".", "output", ".", "is_signed", ":", "\n", "        ", "output_quantizer", ".", "name", "=", "\"quantized_po2\"", "\n", "", "else", ":", "\n", "        ", "output_quantizer", ".", "name", "=", "\"quantized_relu_po2\"", "\n", "\n", "", "", "self", ".", "gate_bits", "=", "self", ".", "output", ".", "bits", "\n", "self", ".", "gate_factor", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.Adder.implemented_as": [[309, 312], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "    ", "return", "\"add\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.FloatingPointMultiplier.__init__": [[317, 335], ["multiplier_impl.IMultiplier.__init__", "max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["def", "__init__", "(", "self", ",", "weight_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "input_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "output_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "weight_quantizer", ",", "input_quantizer", ",", "\n", "output_quantizer", ")", "\n", "\n", "self", ".", "output", ".", "bits", "=", "max", "(", "\n", "self", ".", "input", ".", "bits", "*", "self", ".", "input", ".", "is_floating_point", ",", "\n", "self", ".", "weights", ".", "bits", "*", "self", ".", "weights", ".", "is_floating_point", ",", "\n", ")", "\n", "self", ".", "output", ".", "int_bits", "=", "-", "1", "\n", "self", ".", "output", ".", "is_signed", "=", "1", "\n", "\n", "assert", "self", ".", "input", ".", "is_floating_point", "|", "self", ".", "weights", ".", "is_floating_point", "\n", "self", ".", "output", ".", "is_floating_point", "=", "True", "\n", "\n", "self", ".", "gate_factor", "=", "1", "\n", "self", ".", "gate_bits", "=", "self", ".", "output", ".", "bits", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.FloatingPointMultiplier.implemented_as": [[336, 339], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "    ", "return", "\"mul\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.FixedPointMultiplier.__init__": [[344, 371], ["multiplier_impl.IMultiplier.__init__", "multiplier_impl.assert_neither_input_and_weights_is_floating_point", "numpy.sqrt", "int", "int", "int"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.assert_neither_input_and_weights_is_floating_point"], ["def", "__init__", "(", "self", ",", "weight_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "input_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "output_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "weight_quantizer", ",", "input_quantizer", ",", "\n", "output_quantizer", ")", "\n", "\n", "# Total int bits is the sum of individual int bits.", "\n", "self", ".", "output", ".", "int_bits", "=", "self", ".", "input", ".", "int_bits", "+", "self", ".", "weights", ".", "int_bits", "\n", "\n", "# Total fractional bits is the sum of individual fractional bits", "\n", "fractional_bits1", "=", "(", "self", ".", "input", ".", "bits", "-", "int", "(", "self", ".", "input", ".", "is_signed", ")", "\n", "-", "self", ".", "input", ".", "int_bits", ")", "\n", "fractional_bits2", "=", "(", "self", ".", "weights", ".", "bits", "-", "int", "(", "self", ".", "weights", ".", "is_signed", ")", "\n", "-", "self", ".", "weights", ".", "int_bits", ")", "\n", "fractional_bits", "=", "fractional_bits1", "+", "fractional_bits2", "\n", "\n", "self", ".", "output", ".", "is_signed", "=", "self", ".", "input", ".", "is_signed", "|", "self", ".", "weights", ".", "is_signed", "\n", "\n", "# Total bits is the sum of int bits, fractional bits and sign bit", "\n", "self", ".", "output", ".", "bits", "=", "self", ".", "output", ".", "int_bits", "+", "fractional_bits", "+", "int", "(", "\n", "self", ".", "output", ".", "is_signed", ")", "\n", "\n", "assert_neither_input_and_weights_is_floating_point", "(", "self", ")", "\n", "self", ".", "output", ".", "is_floating_point", "=", "False", "\n", "\n", "self", ".", "gate_factor", "=", "1", "\n", "self", ".", "gate_bits", "=", "np", ".", "sqrt", "(", "self", ".", "input", ".", "bits", "*", "self", ".", "weights", ".", "bits", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.FixedPointMultiplier.implemented_as": [[372, 375], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "    ", "return", "\"mul\"", "\n", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_impl.assert_neither_input_and_weights_is_floating_point": [[54, 60], ["None"], "function", ["None"], ["", "", "def", "assert_neither_input_and_weights_is_floating_point", "(", "\n", "multiplier", ":", "IMultiplier", ")", ":", "\n", "  ", "\"\"\"assert non float type.\"\"\"", "\n", "\n", "assert", "not", "multiplier", ".", "input", ".", "is_floating_point", "\n", "assert", "not", "multiplier", ".", "weights", ".", "is_floating_point", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.IQuantizer.__init__": [[70, 80], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "    ", "self", ".", "mode", "=", "-", "1", "\n", "self", ".", "bits", "=", "-", "1", "\n", "self", ".", "int_bits", "=", "-", "1", "\n", "self", ".", "is_signed", "=", "0", "\n", "self", ".", "is_floating_point", "=", "False", "\n", "self", ".", "max_val_po2", "=", "-", "1", "\n", "self", ".", "is_po2", "=", "0", "\n", "self", ".", "name", "=", "None", "\n", "self", ".", "op_type", "=", "\"quantizer\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.QuantizedBits.__init__": [[94, 99], ["quantizer_impl.IQuantizer.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "mode", "=", "0", "\n", "self", ".", "is_signed", "=", "1", "\n", "self", ".", "name", "=", "\"quantized_bits\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.QuantizedBits.convert_qkeras_quantizer": [[100, 106], ["quantizer_impl.get_np_value"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.get_np_value"], ["", "def", "convert_qkeras_quantizer", "(", "\n", "self", ",", "quantizer", ":", "quantizers", ".", "quantized_bits", ")", ":", "\n", "    ", "self", ".", "mode", "=", "0", "\n", "self", ".", "bits", "=", "quantizer", ".", "bits", "\n", "self", ".", "int_bits", "=", "get_np_value", "(", "quantizer", ".", "integer", ")", "\n", "self", ".", "is_signed", "=", "quantizer", ".", "keep_negative", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.QuantizedBits.convert_to_qkeras_quantizer": [[107, 117], ["qkeras.quantizers.quantized_bits"], "methods", ["None"], ["", "def", "convert_to_qkeras_quantizer", "(", "\n", "self", ",", "symmetric", "=", "1", ",", "alpha", "=", "None", ",", "use_stochastic_rounding", "=", "False", ",", "\n", "scale_axis", "=", "None", ",", "qnoise_factor", "=", "1.0", ")", ":", "\n", "    ", "\"\"\"convert qtools quantizer to qkeras quantizer.\"\"\"", "\n", "\n", "return", "quantizers", ".", "quantized_bits", "(", "\n", "bits", "=", "self", ".", "bits", ",", "integer", "=", "self", ".", "int_bits", ",", "keep_negative", "=", "self", ".", "is_signed", ",", "\n", "symmetric", "=", "symmetric", ",", "alpha", "=", "alpha", ",", "\n", "use_stochastic_rounding", "=", "use_stochastic_rounding", ",", "\n", "scale_axis", "=", "scale_axis", ",", "qnoise_factor", "=", "qnoise_factor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.QuantizedTanh.__init__": [[122, 125], ["quantizer_impl.QuantizedBits.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "name", "=", "\"quantized_tanh\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.QuantizedTanh.convert_qkeras_quantizer": [[126, 131], ["None"], "methods", ["None"], ["", "def", "convert_qkeras_quantizer", "(", "\n", "self", ",", "quantizer", ":", "quantizers", ".", "quantized_tanh", ")", ":", "\n", "    ", "self", ".", "mode", "=", "0", "\n", "self", ".", "bits", "=", "quantizer", ".", "bits", "\n", "self", ".", "is_signed", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.QuantizedTanh.convert_to_qkeras_quantizer": [[132, 139], ["qkeras.quantizers.quantized_tanh"], "methods", ["None"], ["", "def", "convert_to_qkeras_quantizer", "(", "\n", "self", ",", "symmetric", "=", "False", ",", "use_stochastic_rounding", "=", "False", ")", ":", "\n", "    ", "\"\"\"convert qtools quantizer to qkeras quantizer.\"\"\"", "\n", "\n", "return", "quantizers", ".", "quantized_tanh", "(", "\n", "bits", "=", "self", ".", "bits", ",", "use_stochastic_rounding", "=", "use_stochastic_rounding", ",", "\n", "symmetric", "=", "symmetric", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.QuantizedUlaw.__init__": [[145, 148], ["quantizer_impl.QuantizedBits.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "name", "=", "\"quantized_ulaw\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.QuantizedUlaw.convert_qkeras_quantizer": [[149, 155], ["quantizer_impl.get_np_value"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.get_np_value"], ["", "def", "convert_qkeras_quantizer", "(", "\n", "self", ",", "quantizer", ":", "quantizers", ".", "quantized_ulaw", ")", ":", "\n", "    ", "self", ".", "mode", "=", "0", "\n", "self", ".", "bits", "=", "quantizer", ".", "bits", "\n", "self", ".", "int_bits", "=", "get_np_value", "(", "quantizer", ".", "integer", ")", "\n", "self", ".", "is_signed", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.QuantizedUlaw.convert_to_qkeras_quantizer": [[156, 161], ["qkeras.quantizers.quantized_ulaw"], "methods", ["None"], ["", "def", "convert_to_qkeras_quantizer", "(", "self", ",", "symmetric", "=", "0", ",", "u", "=", "255.0", ")", ":", "\n", "    ", "\"\"\"convert qtools quantizer to qkeras quantizer.\"\"\"", "\n", "\n", "return", "quantizers", ".", "quantized_ulaw", "(", "\n", "bits", "=", "self", ".", "bits", ",", "integer", "=", "self", ".", "int_bits", ",", "symmetric", "=", "symmetric", ",", "u", "=", "u", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.Binary.__init__": [[166, 179], ["quantizer_impl.IQuantizer.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "use_01", "=", "False", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "use_01", ":", "\n", "      ", "self", ".", "mode", "=", "4", "\n", "self", ".", "is_signed", "=", "0", "\n", "", "else", ":", "\n", "      ", "self", ".", "mode", "=", "3", "\n", "self", ".", "is_signed", "=", "1", "\n", "\n", "", "self", ".", "bits", "=", "1", "\n", "self", ".", "int_bits", "=", "1", "\n", "self", ".", "use_01", "=", "use_01", "\n", "self", ".", "name", "=", "\"binary\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.Binary.convert_qkeras_quantizer": [[180, 189], ["None"], "methods", ["None"], ["", "def", "convert_qkeras_quantizer", "(", "self", ",", "quantizer", ":", "quantizers", ".", "binary", ")", ":", "\n", "    ", "if", "quantizer", ".", "use_01", ":", "\n", "      ", "self", ".", "mode", "=", "4", "\n", "self", ".", "is_signed", "=", "0", "\n", "", "else", ":", "\n", "      ", "self", ".", "mode", "=", "3", "\n", "self", ".", "is_signed", "=", "1", "\n", "\n", "", "self", ".", "use_01", "=", "quantizer", ".", "use_01", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.Binary.convert_to_qkeras_quantizer": [[190, 196], ["qkeras.quantizers.binary"], "methods", ["None"], ["", "def", "convert_to_qkeras_quantizer", "(", "self", ",", "alpha", "=", "None", ",", "\n", "use_stochastic_rounding", "=", "False", ")", ":", "\n", "    ", "\"\"\"convert qtools quantizer to qkeras quantizer.\"\"\"", "\n", "\n", "return", "quantizers", ".", "binary", "(", "use_01", "=", "self", ".", "use_01", ",", "alpha", "=", "alpha", ",", "\n", "use_stochastic_rounding", "=", "use_stochastic_rounding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.StochasticBinary.__init__": [[202, 205], ["quantizer_impl.Binary.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "use_01", "=", "False", ")", "\n", "self", ".", "name", "=", "\"stochastic_binary\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.StochasticBinary.convert_qkeras_quantizer": [[206, 211], ["None"], "methods", ["None"], ["", "def", "convert_qkeras_quantizer", "(", "\n", "self", ",", "quantizer", ":", "quantizers", ".", "stochastic_binary", ")", ":", "\n", "    ", "\"\"\"convert qkeras quantizer to qtools quantizer.\"\"\"", "\n", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.StochasticBinary.convert_to_qkeras_quantizer": [[212, 218], ["qkeras.quantizers.stochastic_binary"], "methods", ["None"], ["", "def", "convert_to_qkeras_quantizer", "(", "self", ",", "alpha", "=", "None", ",", "temperature", "=", "6.0", ",", "\n", "use_real_sigmoid", "=", "True", ")", ":", "\n", "    ", "\"\"\"convert qtools quantizer to qkeras quantizer.\"\"\"", "\n", "\n", "return", "quantizers", ".", "stochastic_binary", "(", "alpha", "=", "alpha", ",", "temperature", "=", "temperature", ",", "\n", "use_real_sigmoid", "=", "use_real_sigmoid", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.Bernoulli.__init__": [[223, 226], ["quantizer_impl.Binary.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "use_01", "=", "True", ")", "\n", "self", ".", "name", "=", "\"bernoulli\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.Bernoulli.convert_qkeras_quantizer": [[227, 229], ["None"], "methods", ["None"], ["", "def", "convert_qkeras_quantizer", "(", "self", ",", "quantizer", ":", "quantizers", ".", "bernoulli", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.Bernoulli.convert_to_qkeras_quantizer": [[230, 236], ["qkeras.quantizers.bernoulli"], "methods", ["None"], ["", "def", "convert_to_qkeras_quantizer", "(", "self", ",", "alpha", "=", "None", ",", "temperature", "=", "6.0", ",", "\n", "use_real_sigmoid", "=", "True", ")", ":", "\n", "    ", "\"\"\"convert qtools quantizer to qkeras quantizer.\"\"\"", "\n", "\n", "return", "quantizers", ".", "bernoulli", "(", "alpha", "=", "alpha", ",", "temperature", "=", "temperature", ",", "\n", "use_real_sigmoid", "=", "use_real_sigmoid", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.QuantizedRelu.__init__": [[241, 245], ["quantizer_impl.IQuantizer.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "is_signed", "=", "0", "\n", "self", ".", "name", "=", "\"quantized_relu\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.QuantizedRelu.convert_qkeras_quantizer": [[246, 263], ["quantizer_impl.get_np_value", "hasattr"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.get_np_value"], ["", "def", "convert_qkeras_quantizer", "(", "\n", "self", ",", "quantizer", ":", "quantizers", ".", "quantized_relu", ")", ":", "\n", "    ", "\"\"\"convert from qkeras quantizer.\"\"\"", "\n", "\n", "bits", "=", "quantizer", ".", "bits", "\n", "int_bits", "=", "get_np_value", "(", "quantizer", ".", "integer", ")", "\n", "\n", "if", "bits", "==", "1", "and", "int_bits", "==", "1", ":", "\n", "      ", "mode", "=", "4", "\n", "", "else", ":", "\n", "      ", "mode", "=", "0", "\n", "\n", "", "self", ".", "mode", "=", "mode", "\n", "self", ".", "bits", "=", "bits", "\n", "self", ".", "int_bits", "=", "int_bits", "\n", "if", "hasattr", "(", "quantizer", ",", "\"negative_slope\"", ")", "and", "quantizer", ".", "negative_slope", "!=", "0", ":", "\n", "      ", "self", ".", "is_signed", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.QuantizedRelu.convert_to_qkeras_quantizer": [[264, 276], ["qkeras.quantizers.quantized_relu"], "methods", ["None"], ["", "", "def", "convert_to_qkeras_quantizer", "(", "\n", "self", ",", "use_sigmoid", "=", "0", ",", "negative_slope", "=", "0.0", ",", "use_stochastic_rounding", "=", "False", ",", "\n", "relu_upper_bound", "=", "None", ",", "is_quantized_clip", "=", "True", ",", "qnoise_factor", "=", "1.0", ")", ":", "\n", "    ", "\"\"\"convert qtools quantizer to qkeras quantizer.\"\"\"", "\n", "\n", "return", "quantizers", ".", "quantized_relu", "(", "\n", "bits", "=", "self", ".", "bits", ",", "integer", "=", "self", ".", "int_bits", ",", "use_sigmoid", "=", "use_sigmoid", ",", "\n", "negative_slope", "=", "negative_slope", ",", "\n", "use_stochastic_rounding", "=", "use_stochastic_rounding", ",", "\n", "relu_upper_bound", "=", "relu_upper_bound", ",", "\n", "is_quantized_clip", "=", "is_quantized_clip", ",", "\n", "qnoise_factor", "=", "qnoise_factor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.Ternary.__init__": [[281, 288], ["quantizer_impl.IQuantizer.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "mode", "=", "2", "\n", "self", ".", "bits", "=", "2", "\n", "self", ".", "int_bits", "=", "2", "\n", "self", ".", "is_signed", "=", "1", "\n", "self", ".", "name", "=", "\"ternary\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.Ternary.convert_qkeras_quantizer": [[289, 292], ["None"], "methods", ["None"], ["", "def", "convert_qkeras_quantizer", "(", "\n", "self", ",", "quantizer", ":", "quantizers", ".", "ternary", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.Ternary.convert_to_qkeras_quantizer": [[293, 302], ["qkeras.quantizers.ternary"], "methods", ["None"], ["", "def", "convert_to_qkeras_quantizer", "(", "\n", "self", ",", "alpha", "=", "None", ",", "threshold", "=", "None", ",", "use_stochastic_rounding", "=", "False", ",", "\n", "number_of_unrolls", "=", "5", ")", ":", "\n", "    ", "\"\"\"convert qtools quantizer to qkeras quantizer.\"\"\"", "\n", "\n", "return", "quantizers", ".", "ternary", "(", "\n", "alpha", "=", "alpha", ",", "threshold", "=", "threshold", ",", "\n", "use_stochastic_rounding", "=", "use_stochastic_rounding", ",", "\n", "number_of_unrolls", "=", "number_of_unrolls", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.StochasticTernary.__init__": [[307, 310], ["quantizer_impl.Ternary.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "name", "=", "\"stochastic_ternary\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.StochasticTernary.convert_qkeras_quantizer": [[312, 315], ["None"], "methods", ["None"], ["", "def", "convert_qkeras_quantizer", "(", "\n", "self", ",", "quantizer", ":", "quantizers", ".", "stochastic_ternary", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.StochasticTernary.convert_to_qkeras_quantizer": [[316, 325], ["qkeras.quantizers.stochastic_ternary"], "methods", ["None"], ["", "def", "convert_to_qkeras_quantizer", "(", "\n", "self", ",", "alpha", "=", "None", ",", "threshold", "=", "None", ",", "temperature", "=", "8.0", ",", "\n", "use_real_sigmoid", "=", "True", ",", "number_of_unrolls", "=", "5", ")", ":", "\n", "    ", "\"\"\"convert qtools quantizer to qkeras quantizer.\"\"\"", "\n", "\n", "return", "quantizers", ".", "stochastic_ternary", "(", "\n", "alpha", "=", "alpha", ",", "threshold", "=", "threshold", ",", "temperature", "=", "temperature", ",", "\n", "use_real_sigmoid", "=", "use_real_sigmoid", ",", "\n", "number_of_unrolls", "=", "number_of_unrolls", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.FloatingPoint.__init__": [[330, 338], ["quantizer_impl.IQuantizer.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "bits", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "mode", "=", "5", "\n", "self", ".", "bits", "=", "bits", "\n", "self", ".", "int_bits", "=", "-", "1", "\n", "self", ".", "is_signed", "=", "1", "\n", "self", ".", "is_floating_point", "=", "True", "\n", "self", ".", "name", "=", "\"floating_point\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.FloatingPoint.convert_qkeras_quantizer": [[339, 341], ["None"], "methods", ["None"], ["", "def", "convert_qkeras_quantizer", "(", "self", ",", "bits", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.FloatingPoint.convert_to_qkeras_quantizer": [[342, 344], ["None"], "methods", ["None"], ["", "def", "convert_to_qkeras_quantizer", "(", "self", ",", "bits", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.PowerOfTwo.__init__": [[349, 360], ["quantizer_impl.IQuantizer.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "is_signed", "=", "True", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "mode", "=", "1", "\n", "self", ".", "is_po2", "=", "1", "\n", "self", ".", "is_signed", "=", "is_signed", "\n", "self", ".", "inference_value_counts", "=", "-", "1", "\n", "\n", "if", "is_signed", ":", "\n", "      ", "self", ".", "name", "=", "\"quantized_po2\"", "\n", "", "else", ":", "\n", "      ", "self", ".", "name", "=", "\"quantized_relu_po2\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.PowerOfTwo.convert_qkeras_quantizer": [[361, 383], ["quantizer_impl.IQuantizer.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["", "", "def", "convert_qkeras_quantizer", "(", "self", ",", "quantizer", ")", ":", "\n", "    ", "\"\"\"convert qkeras quantizer to qtools quantizer.\"\"\"", "\n", "\n", "assert", "\"po2\"", "in", "quantizer", ".", "__class__", ".", "__name__", "\n", "\n", "if", "quantizer", ".", "__class__", ".", "__name__", "==", "\"quantized_po2\"", ":", "\n", "      ", "self", ".", "is_signed", "=", "1", "\n", "self", ".", "name", "=", "\"quantized_po2\"", "\n", "\n", "", "elif", "quantizer", ".", "__class__", ".", "__name__", "==", "\"quantized_relu_po2\"", ":", "\n", "      ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "is_signed", "=", "0", "\n", "self", ".", "name", "=", "\"quantized_relu_po2\"", "\n", "\n", "", "bits", "=", "quantizer", ".", "bits", "\n", "max_val_po2", "=", "quantizer", ".", "max_value", "\n", "if", "not", "max_val_po2", ":", "\n", "      ", "self", ".", "max_val_po2", "=", "-", "1", "\n", "", "else", ":", "\n", "      ", "self", ".", "max_val_po2", "=", "max_val_po2", "\n", "", "self", ".", "bits", "=", "bits", "\n", "self", ".", "int_bits", "=", "bits", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.PowerOfTwo.convert_to_qkeras_quantizer": [[384, 404], ["qkeras.quantizers.quantized_po2", "qkeras.quantizers.quantized_relu_po2"], "methods", ["None"], ["", "def", "convert_to_qkeras_quantizer", "(", "\n", "self", ",", "negative_slope", "=", "0", ",", "use_stochastic_rounding", "=", "False", ",", "\n", "quadratic_approximation", "=", "False", ")", ":", "\n", "    ", "\"\"\"convert qtools quantizer to qkeras quantizer.\"\"\"", "\n", "\n", "if", "self", ".", "is_signed", ":", "\n", "# quantized_po2", "\n", "      ", "return", "quantizers", ".", "quantized_po2", "(", "\n", "bits", "=", "self", ".", "bits", ",", "\n", "max_value", "=", "self", ".", "max_val_po2", "if", "self", ".", "max_val_po2", ">=", "0", "else", "None", ",", "\n", "use_stochastic_rounding", "=", "use_stochastic_rounding", ",", "\n", "quadratic_approximation", "=", "quadratic_approximation", ")", "\n", "", "else", ":", "\n", "# quantized_relu_po2", "\n", "      ", "return", "quantizers", ".", "quantized_relu_po2", "(", "\n", "bits", "=", "self", ".", "bits", ",", "\n", "max_value", "=", "self", ".", "max_val_po2", "if", "self", ".", "max_val_po2", ">=", "0", "else", "None", ",", "\n", "negative_slope", "=", "negative_slope", ",", "\n", "use_stochastic_rounding", "=", "use_stochastic_rounding", ",", "\n", "quadratic_approximation", "=", "quadratic_approximation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.PowerOfTwo.get_min_max_exp": [[405, 407], ["quantizer_impl.get_exp"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.get_exp"], ["", "", "def", "get_min_max_exp", "(", "self", ")", ":", "\n", "    ", "return", "get_exp", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.PowerOfTwo.quantizer_bits_calculator": [[408, 447], ["abs", "numpy.log2", "int", "abs", "ValueError", "numpy.round", "math.ceil", "math.floor", "numpy.log2", "numpy.log2", "abs"], "methods", ["None"], ["", "def", "quantizer_bits_calculator", "(", "self", ",", "val", ")", ":", "\n", "    ", "\"\"\"calculate how many bits needed.\"\"\"", "\n", "\n", "# calculate how many bits are required to represent a po2 value.", "\n", "# val can be +/- values, can be integer or franctional number.", "\n", "# needs to be dealt seperately.", "\n", "\n", "sign_bit", "=", "val", "<", "0", "\n", "\n", "# get rid of sign", "\n", "val", "=", "abs", "(", "val", ")", "\n", "\n", "if", "val", "==", "0", ":", "\n", "# val of 0 is special case; qkeras uses mininmum", "\n", "# number to represent 0", "\n", "      ", "non_sign_bits", "=", "self", ".", "bits", "-", "sign_bit", "\n", "", "else", ":", "\n", "      ", "exp_value", "=", "np", ".", "log2", "(", "val", ")", "\n", "\n", "# exp_value should be integer", "\n", "if", "abs", "(", "np", ".", "round", "(", "exp_value", ")", "-", "exp_value", ")", ">", "0", ":", "\n", "        ", "raise", "ValueError", "(", "\"ERROR: {} is not a po2 value!\"", ".", "format", "(", "val", ")", ")", "\n", "\n", "", "exp_value", "=", "int", "(", "exp_value", ")", "\n", "\n", "# for n bits, the range of values it can represent is:", "\n", "# min_val = -2 ** (n - 1)", "\n", "# max_val = 2 ** (n - 1) - 1", "\n", "if", "exp_value", "==", "0", ":", "\n", "        ", "non_sign_bits", "=", "1", "\n", "", "elif", "exp_value", ">", "0", ":", "\n", "# e.g., 16 needs 5 bits + 1 exp sign bit,", "\n", "# 15 needs 4 bits + 1 exp sign bit", "\n", "        ", "non_sign_bits", "=", "math", ".", "floor", "(", "np", ".", "log2", "(", "exp_value", ")", ")", "+", "1", "+", "1", "\n", "", "else", ":", "\n", "# e.g., -16 needs 4 bits + 1 exp sign bit", "\n", "        ", "non_sign_bits", "=", "math", ".", "ceil", "(", "np", ".", "log2", "(", "abs", "(", "exp_value", ")", ")", ")", "+", "1", "\n", "\n", "", "", "return", "(", "sign_bit", ",", "non_sign_bits", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.PowerOfTwo.update_quantizer": [[448, 478], ["quantizer_impl.PowerOfTwo.quantizer_bits_calculator", "min", "min"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.PowerOfTwo.quantizer_bits_calculator", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min"], ["", "def", "update_quantizer", "(", "self", ",", "val", ",", "reset", "=", "False", ")", ":", "\n", "    ", "\"\"\"update quantizer bits according to the input value.\n\n    Args:\n      val: input value\n      reset: True->disregard current quantizer bits and reset\n        it according to the given value; False-> update the quantizer\n        bits with given value.\n        quantizer.bits = min(existing_bits, bits required by val)\n\n    Returns:\n      Update existing po2 quantizer bits by val.\n       quantizer.bits = min(existing_bits, bits required by val)\n    \"\"\"", "\n", "(", "sign_bit", ",", "non_sign_bits", ")", "=", "self", ".", "quantizer_bits_calculator", "(", "val", ")", "\n", "\n", "if", "reset", ":", "\n", "      ", "self", ".", "bits", "=", "sign_bit", "+", "non_sign_bits", "\n", "", "else", ":", "\n", "# avoid input value exceeding quantizer limit", "\n", "      ", "self", ".", "bits", "=", "min", "(", "self", ".", "bits", ",", "sign_bit", "+", "non_sign_bits", ")", "\n", "\n", "", "self", ".", "int_bits", "=", "self", ".", "bits", "\n", "self", ".", "max_val_po2", "=", "min", "(", "val", ",", "self", ".", "max_val_po2", ")", "\n", "self", ".", "is_signed", "=", "sign_bit", "\n", "\n", "if", "sign_bit", ":", "\n", "      ", "self", ".", "name", "=", "\"quantized_po2\"", "\n", "", "else", ":", "\n", "      ", "self", ".", "name", "=", "\"quantized_relu_po2\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.PowerOfTwo.update_inference_values": [[479, 484], ["len", "set", "weights.flatten"], "methods", ["None"], ["", "", "def", "update_inference_values", "(", "self", ",", "weights", ")", ":", "\n", "    ", "\"\"\"find how many different values in weights in the po2 quantizer.\"\"\"", "\n", "\n", "inference_value_counts", "=", "len", "(", "set", "(", "weights", ".", "flatten", "(", ")", ")", ")", "\n", "self", ".", "inference_value_counts", "=", "inference_value_counts", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.__init__": [[489, 495], ["quantizer_impl.PowerOfTwo.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "mode", "=", "1", "\n", "self", ".", "is_po2", "=", "1", "\n", "self", ".", "is_signed", "=", "0", "\n", "self", ".", "name", "=", "\"quantized_relu_po2\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_qkeras_quantizer": [[496, 505], ["None"], "methods", ["None"], ["", "def", "convert_qkeras_quantizer", "(", "\n", "self", ",", "quantizer", ":", "quantizers", ".", "quantized_relu_po2", ")", ":", "\n", "\n", "    ", "self", ".", "bits", "=", "quantizer", ".", "bits", "\n", "self", ".", "int_bits", "=", "quantizer", ".", "bits", "\n", "if", "not", "quantizer", ".", "max_value", ":", "\n", "      ", "self", ".", "max_val_po2", "=", "-", "1", "\n", "", "else", ":", "\n", "      ", "self", ".", "max_val_po2", "=", "quantizer", ".", "max_value", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_to_qkeras_quantizer": [[506, 518], ["qkeras.quantizers.quantized_relu_po2"], "methods", ["None"], ["", "", "def", "convert_to_qkeras_quantizer", "(", "\n", "self", ",", "negative_slope", "=", "0", ",", "use_stochastic_rounding", "=", "False", ",", "\n", "quadratic_approximation", "=", "False", ")", ":", "\n", "    ", "\"\"\"convert qtools quantizer to qkeras quantizer.\"\"\"", "\n", "\n", "# quantized_relu_po2", "\n", "return", "quantizers", ".", "quantized_relu_po2", "(", "\n", "bits", "=", "self", ".", "bits", ",", "\n", "max_value", "=", "self", ".", "max_val_po2", "if", "self", ".", "max_val_po2", ">=", "0", "else", "None", ",", "\n", "negative_slope", "=", "negative_slope", ",", "\n", "use_stochastic_rounding", "=", "use_stochastic_rounding", ",", "\n", "quadratic_approximation", "=", "quadratic_approximation", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.get_np_value": [[30, 39], ["hasattr", "val.numpy.numpy", "isinstance", "len"], "function", ["None"], ["def", "get_np_value", "(", "val", ")", ":", "\n", "  ", "if", "hasattr", "(", "val", ",", "\"numpy\"", ")", ":", "\n", "    ", "val", "=", "val", ".", "numpy", "(", ")", "\n", "if", "isinstance", "(", "val", ",", "np", ".", "ndarray", ")", "and", "len", "(", "val", ")", "==", "1", ":", "\n", "      ", "return", "val", "[", "0", "]", "\n", "", "else", ":", "\n", "      ", "return", "val", "\n", "", "", "else", ":", "\n", "    ", "return", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.get_exp": [[41, 65], ["max", "math.ceil", "min", "numpy.log2"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_hswish.min"], ["", "", "def", "get_exp", "(", "quantizer", ")", ":", "\n", "  ", "\"\"\"get max/min exp value for relu_po2 or quantized_po2.\"\"\"", "\n", "\n", "if", "quantizer", ".", "is_signed", ":", "\n", "    ", "non_sign_bits", "=", "quantizer", ".", "bits", "-", "1", "\n", "", "else", ":", "\n", "    ", "non_sign_bits", "=", "quantizer", ".", "bits", "\n", "\n", "", "min_exp", "=", "-", "2", "**", "(", "non_sign_bits", "-", "1", ")", "\n", "max_exp_orig", "=", "2", "**", "(", "non_sign_bits", "-", "1", ")", "-", "1", "\n", "\n", "max_exp", "=", "max_exp_orig", "\n", "# max_value caps how many int_bits actually allowed", "\n", "if", "quantizer", ".", "max_val_po2", "!=", "-", "1", ":", "\n", "    ", "if", "quantizer", ".", "max_val_po2", "<=", "0", ":", "\n", "      ", "max_exp", "=", "0", "\n", "", "else", ":", "\n", "      ", "max_exp", "=", "math", ".", "ceil", "(", "np", ".", "log2", "(", "quantizer", ".", "max_val_po2", ")", ")", "\n", "max_exp", "=", "min", "(", "max_exp", ",", "max_exp_orig", ")", "\n", "\n", "# if max_exp<0. no need to expand int_bits", "\n", "", "", "max_exp", "=", "max", "(", "0", ",", "max_exp", ")", "\n", "\n", "return", "(", "-", "min_exp", ",", "max_exp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.divider_factory.IDivider.__init__": [[37, 103], ["qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.PowerOfTwo", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.PowerOfTwo", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.PowerOfTwo", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "# also attached the output datatype in the table", "\n", "    ", "self", ".", "divider_impl_table", "=", "[", "\n", "[", "\n", "# when qbits is denominator, use default bits for float result", "\n", "(", "divider_impl", ".", "FloatingPointDivider", ",", "quantizer_impl", ".", "FloatingPoint", "(", "\n", "bits", "=", "quantizer_impl", ".", "FLOATINGPOINT_BITS", ")", ")", ",", "\n", "(", "divider_impl", ".", "Shifter", ",", "quantizer_impl", ".", "QuantizedBits", "(", ")", ")", ",", "\n", "(", "None", ",", "None", ")", ",", "\n", "(", "None", ",", "None", ")", ",", "\n", "(", "None", ",", "None", ")", ",", "\n", "# when bits sets to None, will decide f16/f32 according", "\n", "# to input quantizer", "\n", "(", "divider_impl", ".", "FloatingPointDivider", ",", "quantizer_impl", ".", "FloatingPoint", "(", "\n", "bits", "=", "None", ")", ")", "\n", "]", ",", "\n", "[", "\n", "(", "divider_impl", ".", "FloatingPointDivider", ",", "quantizer_impl", ".", "FloatingPoint", "(", "\n", "bits", "=", "quantizer_impl", ".", "FLOATINGPOINT_BITS", ")", ")", ",", "\n", "(", "divider_impl", ".", "Subtractor", ",", "quantizer_impl", ".", "PowerOfTwo", "(", ")", ")", ",", "\n", "(", "None", ",", "None", ")", ",", "\n", "(", "None", ",", "None", ")", ",", "\n", "(", "None", ",", "None", ")", ",", "\n", "(", "divider_impl", ".", "FloatingPointDivider", ",", "quantizer_impl", ".", "FloatingPoint", "(", "\n", "bits", "=", "None", ")", ")", "\n", "]", ",", "\n", "[", "\n", "(", "divider_impl", ".", "FloatingPointDivider", ",", "quantizer_impl", ".", "FloatingPoint", "(", "\n", "bits", "=", "quantizer_impl", ".", "FLOATINGPOINT_BITS", ")", ")", ",", "\n", "(", "divider_impl", ".", "Shifter", ",", "quantizer_impl", ".", "QuantizedBits", "(", ")", ")", ",", "\n", "(", "None", ",", "None", ")", ",", "\n", "(", "None", ",", "None", ")", ",", "\n", "(", "None", ",", "None", ")", ",", "\n", "(", "divider_impl", ".", "FloatingPointDivider", ",", "quantizer_impl", ".", "FloatingPoint", "(", "\n", "bits", "=", "None", ")", ")", "\n", "]", ",", "\n", "[", "\n", "(", "divider_impl", ".", "FloatingPointDivider", ",", "quantizer_impl", ".", "FloatingPoint", "(", "\n", "bits", "=", "quantizer_impl", ".", "FLOATINGPOINT_BITS", ")", ")", ",", "\n", "(", "divider_impl", ".", "Shifter", ",", "quantizer_impl", ".", "PowerOfTwo", "(", ")", ")", ",", "\n", "(", "None", ",", "None", ")", ",", "\n", "(", "None", ",", "None", ")", ",", "\n", "(", "None", ",", "None", ")", ",", "\n", "(", "divider_impl", ".", "FloatingPointDivider", ",", "quantizer_impl", ".", "FloatingPoint", "(", "\n", "bits", "=", "None", ")", ")", "\n", "]", ",", "\n", "[", "\n", "(", "divider_impl", ".", "FloatingPointDivider", ",", "quantizer_impl", ".", "FloatingPoint", "(", "\n", "bits", "=", "quantizer_impl", ".", "FLOATINGPOINT_BITS", ")", ")", ",", "\n", "(", "divider_impl", ".", "Shifter", ",", "quantizer_impl", ".", "PowerOfTwo", "(", ")", ")", ",", "\n", "(", "None", ",", "None", ")", ",", "\n", "(", "None", ",", "None", ")", ",", "\n", "(", "None", ",", "None", ")", ",", "\n", "(", "divider_impl", ".", "FloatingPointDivider", ",", "quantizer_impl", ".", "FloatingPoint", "(", "\n", "bits", "=", "None", ")", ")", "\n", "]", ",", "\n", "[", "\n", "(", "divider_impl", ".", "FloatingPointDivider", ",", "quantizer_impl", ".", "FloatingPoint", "(", "\n", "bits", "=", "None", ")", ")", ",", "\n", "(", "divider_impl", ".", "FloatingPointDivider", ",", "quantizer_impl", ".", "FloatingPoint", "(", "\n", "bits", "=", "None", ")", ")", ",", "\n", "(", "None", ",", "None", ")", ",", "\n", "(", "None", ",", "None", ")", ",", "\n", "(", "None", ",", "None", ")", ",", "\n", "(", "divider_impl", ".", "FloatingPointDivider", ",", "quantizer_impl", ".", "FloatingPoint", "(", "\n", "bits", "=", "None", ")", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.divider_factory.IDivider.make_quantizer": [[106, 135], ["copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "absl.logging.debug", "divider_impl_class", "divider_factory.UnacceptedQuantizerError", "divider_impl_class.implemented_as"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.divider_impl.Subtractor.implemented_as"], ["", "def", "make_quantizer", "(", "self", ",", "numerator_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "denominator_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ")", ":", "\n", "    ", "\"\"\"make the quantizer.\"\"\"", "\n", "\n", "# Create a local copy so that the changes made here won't change the input", "\n", "local_numerator_quantizer", "=", "copy", ".", "deepcopy", "(", "numerator_quantizer", ")", "\n", "local_denominator_quantizer", "=", "copy", ".", "deepcopy", "(", "denominator_quantizer", ")", "\n", "\n", "mode1", "=", "local_numerator_quantizer", ".", "mode", "\n", "mode2", "=", "local_denominator_quantizer", ".", "mode", "\n", "\n", "(", "divider_impl_class", ",", "output_quantizer", ")", "=", "self", ".", "divider_impl_table", "[", "\n", "mode1", "]", "[", "mode2", "]", "\n", "\n", "local_output_quantizer", "=", "copy", ".", "deepcopy", "(", "output_quantizer", ")", "\n", "\n", "if", "divider_impl_class", "is", "None", ":", "\n", "      ", "raise", "UnacceptedQuantizerError", "(", "\n", "\"denominator quantizer {} not accepted!\"", ".", "format", "(", "\n", "denominator_quantizer", ".", "name", ")", ")", "\n", "\n", "", "logging", ".", "debug", "(", "\n", "\"qbn adder implemented as class %s\"", ",", "\n", "divider_impl_class", ".", "implemented_as", "(", ")", ")", "\n", "\n", "return", "divider_impl_class", "(", "\n", "local_numerator_quantizer", ",", "\n", "local_denominator_quantizer", ",", "\n", "local_output_quantizer", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.adder_factory.IAdder.__init__": [[33, 82], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "    ", "self", ".", "adder_impl_table", "=", "[", "\n", "[", "\n", "adder_impl", ".", "FixedPointAdder", ",", "\n", "adder_impl", ".", "Po2FixedPointAdder", ",", "\n", "adder_impl", ".", "FixedPointAdder", ",", "\n", "adder_impl", ".", "FixedPointAdder", ",", "\n", "adder_impl", ".", "FixedPointAdder", ",", "\n", "adder_impl", ".", "FloatingPointAdder", "\n", "]", ",", "\n", "[", "\n", "adder_impl", ".", "Po2FixedPointAdder", ",", "\n", "adder_impl", ".", "Po2Adder", ",", "\n", "adder_impl", ".", "Po2FixedPointAdder", ",", "\n", "adder_impl", ".", "Po2FixedPointAdder", ",", "\n", "adder_impl", ".", "FixedPointAdder", ",", "\n", "adder_impl", ".", "FloatingPointAdder", "\n", "]", ",", "\n", "[", "\n", "adder_impl", ".", "FixedPointAdder", ",", "\n", "adder_impl", ".", "Po2FixedPointAdder", ",", "\n", "adder_impl", ".", "FixedPointAdder", ",", "\n", "adder_impl", ".", "FixedPointAdder", ",", "\n", "adder_impl", ".", "FixedPointAdder", ",", "\n", "adder_impl", ".", "FloatingPointAdder", "\n", "]", ",", "\n", "[", "\n", "adder_impl", ".", "FixedPointAdder", ",", "\n", "adder_impl", ".", "Po2FixedPointAdder", ",", "\n", "adder_impl", ".", "FixedPointAdder", ",", "\n", "adder_impl", ".", "FixedPointAdder", ",", "\n", "adder_impl", ".", "FixedPointAdder", ",", "\n", "adder_impl", ".", "FloatingPointAdder", "\n", "]", ",", "\n", "[", "\n", "adder_impl", ".", "FixedPointAdder", ",", "\n", "adder_impl", ".", "Po2FixedPointAdder", ",", "\n", "adder_impl", ".", "FixedPointAdder", ",", "\n", "adder_impl", ".", "FixedPointAdder", ",", "\n", "adder_impl", ".", "FixedPointAdder", ",", "\n", "adder_impl", ".", "FloatingPointAdder", "\n", "]", ",", "\n", "[", "\n", "adder_impl", ".", "FloatingPointAdder", ",", "\n", "adder_impl", ".", "FloatingPointAdder", ",", "\n", "adder_impl", ".", "FloatingPointAdder", ",", "\n", "adder_impl", ".", "FloatingPointAdder", ",", "\n", "adder_impl", ".", "FloatingPointAdder", ",", "\n", "adder_impl", ".", "FloatingPointAdder", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.adder_factory.IAdder.make_quantizer": [[85, 103], ["copy.deepcopy", "copy.deepcopy", "absl.logging.debug", "adder_impl_class", "adder_impl_class.implemented_as"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.divider_impl.Subtractor.implemented_as"], ["", "def", "make_quantizer", "(", "self", ",", "quantizer_1", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "quantizer_2", ":", "quantizer_impl", ".", "IQuantizer", ")", ":", "\n", "    ", "\"\"\"make adder quantizer.\"\"\"", "\n", "\n", "local_quantizer_1", "=", "copy", ".", "deepcopy", "(", "quantizer_1", ")", "\n", "local_quantizer_2", "=", "copy", ".", "deepcopy", "(", "quantizer_2", ")", "\n", "\n", "mode1", "=", "local_quantizer_1", ".", "mode", "\n", "mode2", "=", "local_quantizer_2", ".", "mode", "\n", "\n", "adder_impl_class", "=", "self", ".", "adder_impl_table", "[", "mode1", "]", "[", "mode2", "]", "\n", "logging", ".", "debug", "(", "\n", "\"qbn adder implemented as class %s\"", ",", "\n", "adder_impl_class", ".", "implemented_as", "(", ")", ")", "\n", "\n", "return", "adder_impl_class", "(", "\n", "local_quantizer_1", ",", "\n", "local_quantizer_2", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.accumulator_factory.AccumulatorFactory.make_accumulator": [[31, 62], ["copy.deepcopy", "qkeras.qtools.quantized_operators.accumulator_impl.FloatingPointAccumulator", "qkeras.qtools.quantized_operators.accumulator_impl.Po2Accumulator", "qkeras.qtools.quantized_operators.accumulator_impl.FixedPointAccumulator"], "methods", ["None"], ["def", "make_accumulator", "(", "\n", "self", ",", "kernel_shape", ",", "\n", "multiplier", ":", "multiplier_impl", ".", "IMultiplier", ",", "\n", "use_bias", "=", "True", "\n", ")", "->", "accumulator_impl", ".", "IAccumulator", ":", "\n", "    ", "\"\"\"Create an accumulator instance.\"\"\"", "\n", "\n", "# Creates a local deep copy so that any changes we made to the multiplier", "\n", "# will not impact the input multiplier type. This is necessary in case", "\n", "# we call this function multiple times to get different multipliers.", "\n", "local_multiplier", "=", "copy", ".", "deepcopy", "(", "multiplier", ")", "\n", "\n", "# The type and bit width of the accumulator is deteremined from the", "\n", "# multiplier implementation, and the shape of both kernel and bias", "\n", "\n", "if", "local_multiplier", ".", "output", ".", "is_floating_point", ":", "\n", "      ", "accumulator", "=", "accumulator_impl", ".", "FloatingPointAccumulator", "(", "\n", "local_multiplier", ")", "\n", "\n", "# po2*po2 is implemented as Adder; output type is po2", "\n", "# in multiplier, po2 needs to be converted to FixedPoint", "\n", "", "elif", "local_multiplier", ".", "output", ".", "is_po2", ":", "\n", "      ", "accumulator", "=", "accumulator_impl", ".", "Po2Accumulator", "(", "\n", "kernel_shape", ",", "local_multiplier", ",", "use_bias", ")", "\n", "\n", "# fixed point", "\n", "", "else", ":", "\n", "      ", "accumulator", "=", "accumulator_impl", ".", "FixedPointAccumulator", "(", "\n", "kernel_shape", ",", "local_multiplier", ",", "use_bias", ")", "\n", "\n", "", "return", "accumulator", "\n", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.adder_impl.IAdderImpl.implemented_as": [[44, 48], ["None"], "methods", ["None"], ["@", "staticmethod", "\n", "@", "abc", ".", "abstractmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.adder_impl.FixedPointAdder.__init__": [[53, 68], ["qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits", "max", "max", "int", "int", "int"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["def", "__init__", "(", "self", ",", "quantizer_1", ",", "quantizer_2", ")", ":", "\n", "    ", "self", ".", "output", "=", "quantizer_impl", ".", "QuantizedBits", "(", ")", "\n", "self", ".", "output", ".", "int_bits", "=", "max", "(", "quantizer_1", ".", "int_bits", ",", "\n", "quantizer_2", ".", "int_bits", ")", "+", "1", "\n", "fractional_bits1", "=", "(", "quantizer_1", ".", "bits", "-", "int", "(", "quantizer_1", ".", "is_signed", ")", "\n", "-", "quantizer_1", ".", "int_bits", ")", "\n", "fractional_bits2", "=", "(", "quantizer_2", ".", "bits", "-", "int", "(", "quantizer_2", ".", "is_signed", ")", "\n", "-", "quantizer_2", ".", "int_bits", ")", "\n", "fractional_bits", "=", "max", "(", "fractional_bits1", ",", "fractional_bits2", ")", "\n", "self", ".", "output", ".", "is_signed", "=", "quantizer_1", ".", "is_signed", "|", "quantizer_2", ".", "is_signed", "\n", "self", ".", "output", ".", "bits", "=", "(", "self", ".", "output", ".", "int_bits", "+", "int", "(", "self", ".", "output", ".", "is_signed", ")", "+", "\n", "fractional_bits", ")", "\n", "self", ".", "output", ".", "mode", "=", "0", "\n", "self", ".", "output", ".", "is_floating_point", "=", "False", "\n", "self", ".", "output", ".", "is_po2", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.adder_impl.FixedPointAdder.implemented_as": [[69, 72], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "    ", "return", "\"add\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.adder_impl.FloatingPointAdder.__init__": [[77, 81], ["max", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["def", "__init__", "(", "self", ",", "quantizer_1", ",", "quantizer_2", ")", ":", "\n", "    ", "bits", "=", "max", "(", "quantizer_1", ".", "bits", ",", "quantizer_2", ".", "bits", ")", "\n", "self", ".", "output", "=", "quantizer_impl", ".", "FloatingPoint", "(", "\n", "bits", "=", "bits", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.adder_impl.FloatingPointAdder.implemented_as": [[82, 85], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "    ", "return", "\"add\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.adder_impl.Po2FixedPointAdder.__init__": [[90, 105], ["adder_impl.po2_qbits_converter", "adder_impl.FixedPointAdder"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.adder_impl.po2_qbits_converter"], ["def", "__init__", "(", "self", ",", "quantizer_1", ",", "quantizer_2", ")", ":", "\n", "\n", "    ", "if", "quantizer_1", ".", "is_po2", ":", "\n", "      ", "po2_quantizer", "=", "quantizer_1", "\n", "fixedpoint_quantizer", "=", "quantizer_2", "\n", "", "else", ":", "\n", "      ", "po2_quantizer", "=", "quantizer_2", "\n", "fixedpoint_quantizer", "=", "quantizer_1", "\n", "\n", "# convert po2 to qbits first", "\n", "", "po2_qbits_quantizer", "=", "po2_qbits_converter", "(", "po2_quantizer", ")", "\n", "\n", "# qbits + qbits -> FixedPointAdder", "\n", "self", ".", "output", "=", "FixedPointAdder", "(", "po2_qbits_quantizer", ",", "\n", "fixedpoint_quantizer", ")", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.adder_impl.Po2FixedPointAdder.implemented_as": [[106, 109], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "    ", "return", "\"add\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.adder_impl.Po2Adder.__init__": [[114, 119], ["adder_impl.po2_qbits_converter", "adder_impl.po2_qbits_converter", "adder_impl.FixedPointAdder"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.adder_impl.po2_qbits_converter", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.adder_impl.po2_qbits_converter"], ["def", "__init__", "(", "self", ",", "quantizer_1", ",", "quantizer_2", ")", ":", "\n", "    ", "qbits_quantizer_1", "=", "po2_qbits_converter", "(", "quantizer_1", ")", "\n", "qbits_quantizer_2", "=", "po2_qbits_converter", "(", "quantizer_2", ")", "\n", "self", ".", "output", "=", "FixedPointAdder", "(", "qbits_quantizer_1", ",", "\n", "qbits_quantizer_2", ")", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.adder_impl.Po2Adder.implemented_as": [[120, 123], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "    ", "return", "\"add\"", "\n", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.adder_impl.po2_qbits_converter": [[28, 39], ["qkeras.qtools.quantized_operators.accumulator_impl.po2_to_qbits", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits"], "function", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.accumulator_impl.po2_to_qbits"], ["def", "po2_qbits_converter", "(", "po2_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ")", ":", "\n", "  ", "\"\"\"convert a po2 quantizer to fixedpoint quantizer.\"\"\"", "\n", "\n", "(", "bits_from_po2", ",", "int_bits_from_po2", ")", "=", "accumulator_impl", ".", "po2_to_qbits", "(", "\n", "po2_quantizer", ")", "\n", "qbits_quantizer", "=", "quantizer_impl", ".", "QuantizedBits", "(", ")", "\n", "qbits_quantizer", ".", "bits", "=", "bits_from_po2", "\n", "qbits_quantizer", ".", "int_bits", "=", "int_bits_from_po2", "\n", "qbits_quantizer", ".", "is_signed", "=", "po2_quantizer", ".", "is_signed", "\n", "\n", "return", "qbits_quantizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_factory.MultiplierFactory.__init__": [[31, 114], ["qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits", "qkeras.qtools.quantized_operators.quantizer_impl.PowerOfTwo", "qkeras.qtools.quantized_operators.quantizer_impl.PowerOfTwo", "qkeras.qtools.quantized_operators.quantizer_impl.PowerOfTwo", "qkeras.qtools.quantized_operators.quantizer_impl.PowerOfTwo", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits", "qkeras.qtools.quantized_operators.quantizer_impl.PowerOfTwo", "qkeras.qtools.quantized_operators.quantizer_impl.Ternary", "qkeras.qtools.quantized_operators.quantizer_impl.Ternary", "qkeras.qtools.quantized_operators.quantizer_impl.Ternary", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits", "qkeras.qtools.quantized_operators.quantizer_impl.PowerOfTwo", "qkeras.qtools.quantized_operators.quantizer_impl.Ternary", "qkeras.qtools.quantized_operators.quantizer_impl.Binary", "qkeras.qtools.quantized_operators.quantizer_impl.Ternary", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits", "qkeras.qtools.quantized_operators.quantizer_impl.PowerOfTwo", "qkeras.qtools.quantized_operators.quantizer_impl.Ternary", "qkeras.qtools.quantized_operators.quantizer_impl.Ternary", "qkeras.qtools.quantized_operators.quantizer_impl.Binary", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "# the table below is found in this slides:", "\n", "# https://docs.google.com/presentation/d/1pcmoB6ZpX0IqjhSwgzO-oQwpMRYwIcDe/edit#slide=id.p40", "\n", "# also attached the output datatype in the table", "\n", "    ", "self", ".", "multiplier_impl_table", "=", "[", "\n", "[", "\n", "(", "\n", "multiplier_impl", ".", "FixedPointMultiplier", ",", "\n", "quantizer_impl", ".", "QuantizedBits", "(", ")", "\n", ")", ",", "\n", "(", "multiplier_impl", ".", "Shifter", ",", "quantizer_impl", ".", "QuantizedBits", "(", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "Mux", ",", "quantizer_impl", ".", "QuantizedBits", "(", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "Mux", ",", "quantizer_impl", ".", "QuantizedBits", "(", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "AndGate", ",", "quantizer_impl", ".", "QuantizedBits", "(", ")", ")", ",", "\n", "(", "\n", "multiplier_impl", ".", "FloatingPointMultiplier", ",", "\n", "quantizer_impl", ".", "FloatingPoint", "(", "\n", "bits", "=", "None", ")", "\n", ")", "\n", "]", ",", "\n", "[", "\n", "(", "multiplier_impl", ".", "Shifter", ",", "quantizer_impl", ".", "QuantizedBits", "(", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "Adder", ",", "quantizer_impl", ".", "PowerOfTwo", "(", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "Mux", ",", "quantizer_impl", ".", "PowerOfTwo", "(", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "Mux", ",", "quantizer_impl", ".", "PowerOfTwo", "(", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "AndGate", ",", "quantizer_impl", ".", "PowerOfTwo", "(", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "FloatingPointMultiplier", ",", "\n", "quantizer_impl", ".", "FloatingPoint", "(", "bits", "=", "None", ")", "\n", ")", "\n", "]", ",", "\n", "[", "\n", "(", "multiplier_impl", ".", "Mux", ",", "quantizer_impl", ".", "QuantizedBits", "(", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "Mux", ",", "quantizer_impl", ".", "PowerOfTwo", "(", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "Mux", ",", "quantizer_impl", ".", "Ternary", "(", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "Mux", ",", "quantizer_impl", ".", "Ternary", "(", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "AndGate", ",", "quantizer_impl", ".", "Ternary", "(", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "FloatingPointMultiplier", ",", "\n", "quantizer_impl", ".", "FloatingPoint", "(", "bits", "=", "None", ")", ")", "\n", "]", ",", "\n", "[", "\n", "(", "multiplier_impl", ".", "Mux", ",", "quantizer_impl", ".", "QuantizedBits", "(", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "Mux", ",", "quantizer_impl", ".", "PowerOfTwo", "(", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "Mux", ",", "quantizer_impl", ".", "Ternary", "(", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "XorGate", ",", "quantizer_impl", ".", "Binary", "(", "\n", "use_01", "=", "False", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "AndGate", ",", "quantizer_impl", ".", "Ternary", "(", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "FloatingPointMultiplier", ",", "\n", "quantizer_impl", ".", "FloatingPoint", "(", "bits", "=", "None", ")", ")", "\n", "]", ",", "\n", "[", "\n", "(", "multiplier_impl", ".", "AndGate", ",", "quantizer_impl", ".", "QuantizedBits", "(", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "AndGate", ",", "quantizer_impl", ".", "PowerOfTwo", "(", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "AndGate", ",", "quantizer_impl", ".", "Ternary", "(", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "AndGate", ",", "quantizer_impl", ".", "Ternary", "(", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "AndGate", ",", "quantizer_impl", ".", "Binary", "(", "\n", "use_01", "=", "True", ")", ")", ",", "\n", "(", "multiplier_impl", ".", "FloatingPointMultiplier", ",", "\n", "quantizer_impl", ".", "FloatingPoint", "(", "bits", "=", "None", ")", ")", "\n", "]", ",", "\n", "[", "\n", "(", "\n", "multiplier_impl", ".", "FloatingPointMultiplier", ",", "\n", "quantizer_impl", ".", "FloatingPoint", "(", "bits", "=", "None", ")", "\n", ")", ",", "\n", "(", "\n", "multiplier_impl", ".", "FloatingPointMultiplier", ",", "\n", "quantizer_impl", ".", "FloatingPoint", "(", "bits", "=", "None", ")", "\n", ")", ",", "\n", "(", "\n", "multiplier_impl", ".", "FloatingPointMultiplier", ",", "\n", "quantizer_impl", ".", "FloatingPoint", "(", "bits", "=", "None", ")", "\n", ")", ",", "\n", "(", "\n", "multiplier_impl", ".", "FloatingPointMultiplier", ",", "\n", "quantizer_impl", ".", "FloatingPoint", "(", "bits", "=", "None", ")", "\n", ")", ",", "\n", "(", "\n", "multiplier_impl", ".", "FloatingPointMultiplier", ",", "\n", "quantizer_impl", ".", "FloatingPoint", "(", "bits", "=", "None", ")", "\n", ")", ",", "\n", "(", "\n", "multiplier_impl", ".", "FloatingPointMultiplier", ",", "\n", "quantizer_impl", ".", "FloatingPoint", "(", "bits", "=", "None", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_factory.MultiplierFactory.make_multiplier": [[118, 169], ["copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "absl.logging.debug", "issubclass", "multiplier_impl_class", "multiplier_impl_class.implemented_as"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.divider_impl.Subtractor.implemented_as"], ["", "def", "make_multiplier", "(", "\n", "self", ",", "weight_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "input_quantizer", ":", "quantizer_impl", ".", "IQuantizer", "\n", ")", "->", "multiplier_impl", ".", "IMultiplier", ":", "\n", "    ", "\"\"\"Create a multiplier instance.\n\n    The type and bit width of the multiplier is deteremined from the\n    quantizer type of both the kernel (weight) and input tensor.\n\n    The table below illustrates the rule of inferring multiplier type from the\n    quantizer type of both the kernel (weight) and input tensor\n\n                                        x\n                      qb(n)   +/-,exp  t(-1,0,+1) b(-1,+1) b(0,1) float32\n        qb(n)            *     << >>,-     ?,-       ?,-       ?\n        +/-,exp        << >>,-   +         ?,-        ^      ?,-\n      w t(-1,0,+1)      ?,-     ?,-        ?,^       ?,^      ^\n        b(-1,+1)        ?,-      ^         ?,^        ^       ^\n        b(0,1)           ?      ?,-         ^         ^       ^      &\n        float32\n\n    Args:\n      weight_quantizer: weight quantizer type\n      input_quantizer: input quantizer type\n\n    Returns:\n      An IMultiplier instance.\n    \"\"\"", "\n", "\n", "assert", "weight_quantizer", "is", "not", "None", "\n", "assert", "input_quantizer", "is", "not", "None", "\n", "\n", "(", "multiplier_impl_class", ",", "output_quantizer", ")", "=", "self", ".", "multiplier_impl_table", "[", "\n", "weight_quantizer", ".", "mode", "]", "[", "input_quantizer", ".", "mode", "]", "\n", "\n", "# Need to create local copies becuase different multiplier instances", "\n", "# created from the factory might make changes to these quantizers.", "\n", "\n", "local_weight_quantizer", "=", "copy", ".", "deepcopy", "(", "weight_quantizer", ")", "\n", "local_input_quantizer", "=", "copy", ".", "deepcopy", "(", "input_quantizer", ")", "\n", "local_output_quantizer", "=", "copy", ".", "deepcopy", "(", "output_quantizer", ")", "\n", "logging", ".", "debug", "(", "\n", "\"multiplier implemented as class %s\"", ",", "\n", "multiplier_impl_class", ".", "implemented_as", "(", ")", ")", "\n", "\n", "assert", "issubclass", "(", "multiplier_impl_class", ",", "multiplier_impl", ".", "IMultiplier", ")", "\n", "\n", "return", "multiplier_impl_class", "(", "\n", "local_weight_quantizer", ",", "\n", "local_input_quantizer", ",", "\n", "local_output_quantizer", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.merge_factory.MergeFactory.make_quantizer": [[32, 49], ["merge_factory.Add", "merge_factory.Multiply", "merge_factory.Maximum", "merge_factory.Minimum", "merge_factory.Average", "merge_factory.Concatenate", "merge_factory.Dot"], "methods", ["None"], ["def", "make_quantizer", "(", "self", ",", "input_qe_list", ",", "layer_type", ")", ":", "\n", "    ", "\"\"\"make quantier.\"\"\"", "\n", "\n", "if", "layer_type", "==", "\"Add\"", ":", "\n", "      ", "return", "Add", "(", "input_qe_list", ")", "\n", "", "elif", "layer_type", "==", "\"Multiply\"", ":", "\n", "      ", "return", "Multiply", "(", "input_qe_list", ")", "\n", "", "elif", "layer_type", "==", "\"Maximum\"", ":", "\n", "      ", "return", "Maximum", "(", "input_qe_list", ")", "\n", "", "elif", "layer_type", "==", "\"Minimum\"", ":", "\n", "      ", "return", "Minimum", "(", "input_qe_list", ")", "\n", "", "elif", "layer_type", "==", "\"Average\"", ":", "\n", "      ", "return", "Average", "(", "input_qe_list", ")", "\n", "", "elif", "layer_type", "==", "\"Concatenate\"", ":", "\n", "      ", "return", "Concatenate", "(", "input_qe_list", ")", "\n", "", "elif", "layer_type", "==", "\"Dot\"", ":", "\n", "      ", "return", "Dot", "(", "input_qe_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.merge_factory.IMerger.__init__": [[54, 61], ["merge_factory.IMerger.input_quantizers.append", "merge_factory.IMerger.edges.append"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "input_qe_list", ")", ":", "\n", "    ", "self", ".", "input_quantizers", "=", "[", "]", "\n", "self", ".", "edges", "=", "[", "]", "\n", "\n", "for", "node", "in", "input_qe_list", ":", "\n", "      ", "self", ".", "input_quantizers", ".", "append", "(", "node", "[", "0", "]", ")", "\n", "self", ".", "edges", ".", "append", "(", "node", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.merge_factory.Add.__init__": [[69, 111], ["merge_factory.IMerger.__init__", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits", "max", "qkeras.qtools.quantized_operators.adder_impl.po2_qbits_converter"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.adder_impl.po2_qbits_converter"], ["def", "__init__", "(", "self", ",", "input_qe_list", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "input_qe_list", ")", "\n", "\n", "max_bits", "=", "-", "1", "\n", "max_int_bits", "=", "-", "1", "\n", "is_signed", "=", "False", "\n", "\n", "bits", "=", "0", "\n", "is_floating_point", "=", "False", "\n", "for", "quantizer", "in", "self", ".", "input_quantizers", ":", "\n", "      ", "if", "quantizer", ".", "is_floating_point", ":", "\n", "        ", "is_floating_point", "=", "True", "\n", "bits", "=", "max", "(", "bits", ",", "quantizer", ".", "bits", ")", "\n", "", "else", ":", "\n", "        ", "if", "quantizer", ".", "is_po2", ":", "\n", "          ", "qbits_quantizer", "=", "adder_impl", ".", "po2_qbits_converter", "(", "\n", "quantizer", ")", "\n", "", "else", ":", "\n", "          ", "qbits_quantizer", "=", "quantizer", "\n", "\n", "", "if", "qbits_quantizer", ".", "bits", ">", "max_bits", ":", "\n", "          ", "max_bits", "=", "qbits_quantizer", ".", "bits", "\n", "\n", "", "if", "qbits_quantizer", ".", "int_bits", ">", "max_int_bits", ":", "\n", "          ", "max_int_bits", "=", "qbits_quantizer", ".", "int_bits", "\n", "\n", "", "", "is_signed", "|=", "quantizer", ".", "is_signed", "\n", "\n", "", "if", "is_floating_point", ":", "\n", "      ", "self", ".", "output", "=", "quantizer_impl", ".", "FloatingPoint", "(", "\n", "bits", "=", "bits", ")", "\n", "", "else", ":", "\n", "      ", "self", ".", "output", "=", "quantizer_impl", ".", "QuantizedBits", "(", ")", "\n", "self", ".", "output", ".", "bits", "=", "max_bits", "+", "1", "\n", "self", ".", "output", ".", "int_bits", "=", "max_int_bits", "+", "1", "\n", "self", ".", "output", ".", "is_signed", "=", "is_signed", "\n", "self", ".", "output", ".", "mode", "=", "0", "\n", "self", ".", "output", ".", "is_floating_point", "=", "False", "\n", "self", ".", "output", ".", "is_po2", "=", "0", "\n", "\n", "", "self", ".", "gate_factor", "=", "1", "\n", "self", ".", "gate_bits", "=", "self", ".", "output", ".", "bits", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.merge_factory.Add.implemented_as": [[112, 114], ["None"], "methods", ["None"], ["", "def", "implemented_as", "(", "self", ")", ":", "\n", "    ", "return", "\"add\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.merge_factory.Multiply.__init__": [[122, 137], ["merge_factory.IMerger.__init__", "qkeras.qtools.quantized_operators.multiplier_factory.MultiplierFactory", "qkeras.qtools.quantized_operators.multiplier_factory.MultiplierFactory.make_multiplier"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_factory.MultiplierFactory.make_multiplier"], ["def", "__init__", "(", "self", ",", "input_qe_list", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "input_qe_list", ")", "\n", "multiplier_instance", "=", "multiplier_factory", ".", "MultiplierFactory", "(", ")", "\n", "\n", "quantizer", "=", "self", ".", "input_quantizers", "[", "0", "]", "\n", "for", "cur", "in", "self", ".", "input_quantizers", "[", "1", ":", "]", ":", "\n", "      ", "tmp", "=", "multiplier_instance", ".", "make_multiplier", "(", "quantizer", ",", "cur", ")", "\n", "quantizer", "=", "tmp", ".", "output", "\n", "\n", "", "self", ".", "output", "=", "quantizer", "\n", "\n", "# TODO(lishanok): only use the last multiplier here", "\n", "self", ".", "impl_class", "=", "tmp", "\n", "self", ".", "gate_factor", "=", "tmp", ".", "gate_factor", "\n", "self", ".", "gate_bits", "=", "tmp", ".", "gate_bits", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.merge_factory.Multiply.implemented_as": [[138, 140], ["merge_factory.Multiply.impl_class.implemented_as"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.divider_impl.Subtractor.implemented_as"], ["", "def", "implemented_as", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "impl_class", ".", "implemented_as", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.merge_factory.Maximum.__init__": [[148, 202], ["merge_factory.IMerger.__init__", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits", "max", "qkeras.qtools.quantized_operators.adder_impl.po2_qbits_converter"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.adder_impl.po2_qbits_converter"], ["def", "__init__", "(", "self", ",", "input_qe_list", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "input_qe_list", ")", "\n", "\n", "is_same", "=", "True", "\n", "is_floating_point", "=", "False", "\n", "bits", "=", "0", "\n", "\n", "quantizer", "=", "self", ".", "input_quantizers", "[", "0", "]", "\n", "for", "cur", "in", "self", ".", "input_quantizers", "[", "1", ":", "]", ":", "\n", "      ", "if", "(", "quantizer", ".", "name", "!=", "cur", ".", "name", "or", "quantizer", ".", "bits", "!=", "cur", ".", "bits", "or", "\n", "quantizer", ".", "int_bits", "!=", "cur", ".", "int_bits", "or", "\n", "quantizer", ".", "is_signed", "!=", "cur", ".", "is_signed", ")", ":", "\n", "        ", "is_same", "=", "False", "\n", "break", "\n", "\n", "", "", "if", "is_same", ":", "\n", "      ", "self", ".", "output", "=", "quantizer", "\n", "", "else", ":", "\n", "      ", "max_bits", "=", "-", "1", "\n", "max_int_bits", "=", "-", "1", "\n", "is_signed", "=", "False", "\n", "for", "quantizer", "in", "self", ".", "input_quantizers", ":", "\n", "        ", "if", "quantizer", ".", "is_floating_point", ":", "\n", "          ", "is_floating_point", "=", "True", "\n", "bits", "=", "max", "(", "bits", ",", "quantizer", ".", "bits", ")", "\n", "", "else", ":", "\n", "          ", "if", "quantizer", ".", "is_po2", ":", "\n", "            ", "qbits_quantizer", "=", "adder_impl", ".", "po2_qbits_converter", "(", "\n", "quantizer", ")", "\n", "", "else", ":", "\n", "            ", "qbits_quantizer", "=", "quantizer", "\n", "\n", "", "if", "qbits_quantizer", ".", "bits", ">", "max_bits", ":", "\n", "            ", "max_bits", "=", "qbits_quantizer", ".", "bits", "\n", "\n", "", "if", "qbits_quantizer", ".", "int_bits", ">", "max_int_bits", ":", "\n", "            ", "max_int_bits", "=", "qbits_quantizer", ".", "int_bits", "\n", "\n", "", "", "is_signed", "|=", "quantizer", ".", "is_signed", "\n", "\n", "", "if", "is_floating_point", ":", "\n", "        ", "self", ".", "output", "=", "quantizer_impl", ".", "FloatingPoint", "(", "\n", "bits", "=", "bits", ")", "\n", "", "else", ":", "\n", "        ", "self", ".", "output", "=", "quantizer_impl", ".", "QuantizedBits", "(", ")", "\n", "self", ".", "output", ".", "bits", "=", "max_bits", "\n", "self", ".", "output", ".", "int_bits", "=", "max_int_bits", "\n", "self", ".", "output", ".", "is_signed", "=", "is_signed", "\n", "self", ".", "output", ".", "mode", "=", "0", "\n", "self", ".", "output", ".", "is_floating_point", "=", "False", "\n", "self", ".", "output", ".", "is_po2", "=", "0", "\n", "\n", "", "", "self", ".", "gate_factor", "=", "0.2", "\n", "self", ".", "gate_bits", "=", "self", ".", "output", ".", "bits", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.merge_factory.Maximum.implemented_as": [[203, 206], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "    ", "return", "\"add\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.merge_factory.Average.__init__": [[221, 226], ["merge_factory.Maximum.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "input_qe_list", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "input_qe_list", ")", "\n", "\n", "self", ".", "gate_factor", "=", "1", "\n", "self", ".", "gate_bits", "=", "self", ".", "output", ".", "bits", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.merge_factory.Concatenate.__init__": [[234, 239], ["merge_factory.Maximum.__init__"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__"], ["def", "__init__", "(", "self", ",", "input_qe_list", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "input_qe_list", ")", "\n", "\n", "self", ".", "gate_factor", "=", "0", "\n", "self", ".", "gate_bits", "=", "self", ".", "output", ".", "bits", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.subtractor_factory.ISubtractor.make_quantizer": [[33, 56], ["super().make_quantizer", "isinstance"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer"], ["def", "make_quantizer", "(", "self", ",", "quantizer_1", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "quantizer_2", ":", "quantizer_impl", ".", "IQuantizer", ")", ":", "\n", "    ", "\"\"\"make an ISubtractor instance.\n\n    if quantizer1 and quantizer2 are both non-signed, result should change\n    to signed; else since a sign bit is already present,\n    no need to add extra sign bit\n\n    Args:\n      quantizer_1: first operand\n      quantizer_2: second operand\n\n    Returns:\n      An ISubtractor instance\n    \"\"\"", "\n", "quantizer", "=", "super", "(", ")", ".", "make_quantizer", "(", "quantizer_1", ",", "quantizer_2", ")", "\n", "\n", "if", "not", "isinstance", "(", "quantizer", ",", "adder_impl", ".", "FloatingPoint_Adder", ")", ":", "\n", "      ", "if", "not", "quantizer_1", ".", "is_signed", "and", "not", "quantizer_2", ".", "is_signed", ":", "\n", "        ", "quantizer", ".", "output", ".", "is_signed", "=", "1", "\n", "quantizer", ".", "output", ".", "bits", "+=", "1", "\n", "\n", "", "", "return", "quantizer", "\n", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.qbn_factory.QBNFactory.make_quantizer": [[40, 117], ["copy.deepcopy", "qkeras.qtools.quantized_operators.divider_factory.IDivider", "qkeras.qtools.quantized_operators.divider_factory.IDivider.make_quantizer", "qkeras.qtools.quantized_operators.multiplier_factory.MultiplierFactory", "qkeras.qtools.quantized_operators.multiplier_factory.MultiplierFactory.make_multiplier", "qkeras.qtools.quantized_operators.divider_factory.IDivider.make_quantizer", "qkeras.qtools.quantized_operators.adder_factory.IAdder", "qkeras.qtools.quantized_operators.adder_factory.IAdder.make_quantizer", "numpy.round", "math.sqrt"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_factory.MultiplierFactory.make_multiplier", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer"], ["def", "make_quantizer", "(", "\n", "self", ",", "input_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "gamma_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "beta_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "mean_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "variance_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "use_scale", ",", "\n", "use_center", "\n", ")", ":", "\n", "    ", "\"\"\"make a qbn quantizer.\"\"\"", "\n", "\n", "self", ".", "input_quantizer", "=", "input_quantizer", "\n", "self", ".", "gamma_quantizer", "=", "gamma_quantizer", "\n", "self", ".", "beta_quantizer", "=", "beta_quantizer", "\n", "self", ".", "mean_quantizer", "=", "mean_quantizer", "\n", "self", ".", "variance_quantizer", "=", "variance_quantizer", "\n", "self", ".", "use_scale", "=", "use_scale", "\n", "self", ".", "use_center", "=", "use_center", "\n", "\n", "multiplier", "=", "None", "\n", "accumulator", "=", "None", "\n", "\n", "# convert variance po2 quantizer to stddev po2 quantizer", "\n", "stddev_quantizer", "=", "copy", ".", "deepcopy", "(", "variance_quantizer", ")", "\n", "if", "stddev_quantizer", ".", "is_po2", ":", "\n", "      ", "if", "variance_quantizer", ".", "max_val_po2", ">=", "0", ":", "\n", "        ", "stddev_quantizer", ".", "max_val_po2", "=", "np", ".", "round", "(", "math", ".", "sqrt", "(", "\n", "variance_quantizer", ".", "max_val_po2", ")", ")", "\n", "", "else", ":", "\n", "        ", "stddev_quantizer", ".", "max_val_po2", "=", "variance_quantizer", ".", "max_val_po2", "\n", "\n", "", "stddev_quantizer", ".", "bits", "=", "variance_quantizer", ".", "bits", "-", "1", "\n", "stddev_quantizer", ".", "int_bits", "=", "stddev_quantizer", ".", "bits", "\n", "\n", "", "divider_instance", "=", "divider_factory", ".", "IDivider", "(", ")", "\n", "\n", "if", "use_scale", ":", "\n", "# gamma/var", "\n", "      ", "divider", "=", "divider_instance", ".", "make_quantizer", "(", "\n", "gamma_quantizer", ",", "stddev_quantizer", ")", "\n", "\n", "# update the actual number of values in divider quantizer during inference", "\n", "count", "=", "-", "1", "\n", "if", "gamma_quantizer", ".", "is_po2", "and", "gamma_quantizer", ".", "inference_value_counts", ">", "0", ":", "\n", "        ", "count", "=", "gamma_quantizer", ".", "inference_value_counts", "\n", "if", "stddev_quantizer", ".", "is_po2", "and", "stddev_quantizer", ".", "inference_value_counts", ">", "0", ":", "\n", "          ", "count", "*=", "stddev_quantizer", ".", "inference_value_counts", "\n", "", "else", ":", "\n", "          ", "count", "=", "-", "1", "\n", "", "", "if", "count", ">", "0", ":", "\n", "        ", "divider", ".", "output", ".", "inference_value_counts", "=", "count", "\n", "\n", "# gamma/var * x", "\n", "", "multiplier_instance", "=", "multiplier_factory", ".", "MultiplierFactory", "(", ")", "\n", "multiplier", "=", "multiplier_instance", ".", "make_multiplier", "(", "\n", "divider", ".", "output", ",", "input_quantizer", ")", "\n", "accumulator_input", "=", "multiplier", "\n", "\n", "", "else", ":", "\n", "# x/var", "\n", "      ", "divider", "=", "divider_instance", ".", "make_quantizer", "(", "\n", "input_quantizer", ",", "stddev_quantizer", ")", "\n", "accumulator_input", "=", "divider", "\n", "\n", "", "if", "use_center", ":", "\n", "# y = gamma/var * x + beta", "\n", "      ", "accumulator_instance", "=", "adder_factory", ".", "IAdder", "(", ")", "\n", "accumulator", "=", "accumulator_instance", ".", "make_quantizer", "(", "\n", "accumulator_input", ".", "output", ",", "beta_quantizer", ")", "\n", "output_q", "=", "accumulator", "\n", "", "else", ":", "\n", "      ", "output_q", "=", "accumulator_input", "\n", "\n", "", "self", ".", "internal_divide_quantizer", "=", "divider", "\n", "self", ".", "internal_multiplier", "=", "multiplier", "\n", "self", ".", "internal_accumulator", "=", "accumulator", "\n", "self", ".", "internal_output", "=", "output_q", "\n", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.divider_impl.IDividerImpl.__init__": [[29, 34], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "numerator_quantizer", ",", "denominator_quantizer", ",", "\n", "output_quantizer", ")", ":", "\n", "    ", "self", ".", "numerator_quantizier", "=", "numerator_quantizer", "\n", "self", ".", "denominator_quantizer", "=", "denominator_quantizer", "\n", "self", ".", "output", "=", "output_quantizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.divider_impl.IDividerImpl.implemented_as": [[35, 39], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "abc", ".", "abstractmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.divider_impl.FloatingPointDivider.__init__": [[44, 61], ["divider_impl.IDividerImpl.__init__", "max", "max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["def", "__init__", "(", "self", ",", "numerator_quantizer", ",", "denominator_quantizer", ",", "\n", "output_quantizer", ")", ":", "\n", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "numerator_quantizer", ",", "denominator_quantizer", ",", "\n", "output_quantizer", ")", "\n", "if", "self", ".", "output", ".", "bits", "is", "None", ":", "\n", "# decide f16/f32 according to numerator/denominator type", "\n", "      ", "bits", "=", "0", "\n", "if", "numerator_quantizer", ".", "is_floating_point", ":", "\n", "        ", "bits", "=", "max", "(", "bits", ",", "numerator_quantizer", ".", "bits", ")", "\n", "", "if", "denominator_quantizer", ".", "is_floating_point", ":", "\n", "        ", "bits", "=", "max", "(", "bits", ",", "denominator_quantizer", ".", "bits", ")", "\n", "\n", "", "self", ".", "output", ".", "bits", "=", "bits", "\n", "\n", "", "self", ".", "gate_bits", "=", "self", ".", "output", ".", "bits", "\n", "self", ".", "gate_factor", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.divider_impl.FloatingPointDivider.implemented_as": [[62, 66], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "# TODO(lishanok): change cost from \"mul\" to \"divide\"", "\n", "    ", "return", "\"mul\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.divider_impl.Shifter.__init__": [[72, 115], ["divider_impl.IDividerImpl.__init__", "po2_quantizer.get_min_max_exp", "int", "int", "numpy.sqrt", "numpy.log10"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.PowerOfTwo.get_min_max_exp"], ["def", "__init__", "(", "self", ",", "numerator_quantizer", ",", "denominator_quantizer", ",", "\n", "output_quantizer", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "numerator_quantizer", ",", "denominator_quantizer", ",", "\n", "output_quantizer", ")", "\n", "\n", "qbit_quantizer", "=", "numerator_quantizer", "\n", "po2_quantizer", "=", "denominator_quantizer", "\n", "\n", "(", "min_exp", ",", "max_exp", ")", "=", "po2_quantizer", ".", "get_min_max_exp", "(", ")", "\n", "\n", "# since it's a divider, min_exp and max_exp swap", "\n", "# for calculating right and left shift", "\n", "tmp", "=", "min_exp", "\n", "min_exp", "=", "max_exp", "\n", "max_exp", "=", "tmp", "\n", "\n", "qbits_bits", "=", "qbit_quantizer", ".", "bits", "\n", "qbits_int_bits", "=", "qbit_quantizer", ".", "int_bits", "\n", "\n", "self", ".", "output", ".", "bits", "=", "int", "(", "qbits_bits", "+", "max_exp", "+", "min_exp", ")", "\n", "if", "(", "not", "qbit_quantizer", ".", "is_signed", ")", "and", "po2_quantizer", ".", "is_signed", ":", "\n", "# if qbit is signed, qbits_bits already has the sign_bit,", "\n", "# no need to +1,", "\n", "# if qbit is un_signed, po2 is unsigned, no need to +1", "\n", "# if qbit is un_signed, po2 is signed, min_exp and max_exp", "\n", "# didnot include sign_bit,", "\n", "# therefore need to +1", "\n", "      ", "self", ".", "output", ".", "bits", "+=", "1", "\n", "\n", "", "self", ".", "output", ".", "int_bits", "=", "int", "(", "qbits_int_bits", "+", "max_exp", ")", "\n", "self", ".", "output", ".", "is_signed", "=", "qbit_quantizer", ".", "is_signed", "|", "po2_quantizer", ".", "is_signed", "\n", "self", ".", "output", ".", "is_floating_point", "=", "False", "\n", "\n", "if", "po2_quantizer", ".", "inference_value_counts", ">", "0", ":", "\n", "# during qbn inference, count number of unique values", "\n", "      ", "self", ".", "gate_factor", "=", "po2_quantizer", ".", "inference_value_counts", "*", "0.3", "\n", "self", ".", "gate_bits", "=", "qbits_bits", "\n", "", "else", ":", "\n", "# programmable shifter, similar to sum gate", "\n", "      ", "self", ".", "gate_factor", "=", "1", "\n", "b", "=", "np", ".", "sqrt", "(", "2", "**", "po2_quantizer", ".", "bits", "*", "qbits_bits", ")", "\n", "self", ".", "gate_bits", "=", "b", "*", "np", ".", "log10", "(", "b", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.divider_impl.Shifter.implemented_as": [[116, 119], ["None"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "    ", "return", "\"shifter\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.divider_impl.Subtractor.__init__": [[127, 157], ["divider_impl.IDividerImpl.__init__", "max", "max"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max", "home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["def", "__init__", "(", "self", ",", "numerator_quantizer", ",", "denominator_quantizer", ",", "\n", "output_quantizer", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "numerator_quantizer", ",", "denominator_quantizer", ",", "\n", "output_quantizer", ")", "\n", "\n", "self", ".", "output", ".", "bits", "=", "max", "(", "numerator_quantizer", ".", "bits", ",", "\n", "denominator_quantizer", ".", "bits", ")", "+", "1", "\n", "self", ".", "output", ".", "int_bits", "=", "max", "(", "numerator_quantizer", ".", "int_bits", ",", "\n", "denominator_quantizer", ".", "int_bits", ")", "+", "1", "\n", "self", ".", "output", ".", "is_signed", "=", "1", "\n", "self", ".", "output", ".", "is_floating_point", "=", "False", "\n", "self", ".", "output", ".", "is_po2", "=", "1", "\n", "\n", "if", "(", "numerator_quantizer", ".", "max_val_po2", "==", "-", "1", "or", "\n", "denominator_quantizer", ".", "max_val_po2", "==", "-", "1", ")", ":", "\n", "      ", "self", ".", "output", ".", "max_val_po2", "=", "-", "1", "\n", "", "else", ":", "\n", "# Adder is two po2_value multiply with each other", "\n", "      ", "self", ".", "output", ".", "max_val_po2", "=", "numerator_quantizer", ".", "max_val_po2", "/", "denominator_quantizer", ".", "max_val_po2", "\n", "\n", "", "if", "\"po2\"", "in", "output_quantizer", ".", "name", ":", "\n", "# po2 * po2", "\n", "      ", "if", "self", ".", "output", ".", "is_signed", ":", "\n", "        ", "output_quantizer", ".", "name", "=", "\"quantized_po2\"", "\n", "", "else", ":", "\n", "        ", "output_quantizer", ".", "name", "=", "\"quantized_relu_po2\"", "\n", "\n", "", "", "self", ".", "gate_bits", "=", "self", ".", "output", ".", "bits", "\n", "self", ".", "gate_factor", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.divider_impl.Subtractor.implemented_as": [[158, 161], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "implemented_as", "(", ")", ":", "\n", "    ", "return", "\"add\"", "\n", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.fused_bn_factory.FusedBNFactory.make_quantizer": [[50, 127], ["qkeras.qtools.quantized_operators.multiplier_factory.MultiplierFactory", "qkeras.qtools.quantized_operators.multiplier_factory.MultiplierFactory.make_multiplier", "qkeras.qtools.qtools_util.adjust_multiplier_for_auto_po2", "qkeras.qtools.quantized_operators.multiplier_factory.MultiplierFactory.make_multiplier", "qkeras.qtools.qtools_util.adjust_multiplier_for_auto_po2", "qkeras.qtools.quantized_operators.adder_factory.IAdder", "qkeras.qtools.quantized_operators.adder_factory.IAdder.make_quantizer", "isinstance", "qkeras.qtools.quantized_operators.multiplier_factory.MultiplierFactory.make_multiplier", "qkeras.qtools.qtools_util.adjust_multiplier_for_auto_po2", "qkeras.qtools.quantized_operators.adder_factory.IAdder.make_quantizer", "qkeras.qtools.quantized_operators.adder_factory.IAdder.make_quantizer"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_factory.MultiplierFactory.make_multiplier", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.adjust_multiplier_for_auto_po2", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_factory.MultiplierFactory.make_multiplier", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.adjust_multiplier_for_auto_po2", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.multiplier_factory.MultiplierFactory.make_multiplier", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.adjust_multiplier_for_auto_po2", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer"], ["def", "make_quantizer", "(", "\n", "self", ",", "prev_output_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "beta_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "mean_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "inverse_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "prev_bias_quantizer", ":", "quantizer_impl", ".", "IQuantizer", ",", "\n", "use_beta", ":", "bool", ",", "\n", "use_bias", ":", "bool", ",", "\n", "qkeras_inverse_quantizer", ":", "quantizers", ".", "BaseQuantizer", "\n", ")", ":", "\n", "    ", "\"\"\"Makes a fused_bn quantizer.\n\n    Args:\n      prev_output_quantizer: IQuantizer type. Previous layer output quantizer\n      beta_quantizer: IQuantizer type. bn layer beta quantizer\n      mean_quantizer: IQuantizer type.  layer mean quantizer\n      inverse_quantizer: IQuantizer type. bn layer inverse quantizer\n      prev_bias_quantizer: IQuantizer type. conv layer bias quantizer\n      use_beta: Bool. whether enabling beta in batch_normalization layer\n      use_bias: Bool. Whether bias is used in conv layer.\n      qkeras_inverse_quantizer: QKeras quantizer type. bn layer inverse\n        quantizer with QKeras quantizer type\n    Returns:\n      None\n    \"\"\"", "\n", "\n", "assert", "not", "isinstance", "(", "inverse_quantizer", ",", "quantizer_impl", ".", "FloatingPoint", ")", ",", "(", "\n", "\"inverse_quantizer in batchnorm layer has to be set for \"", "\n", "\"fused bn inference in hardware!\"", ")", "\n", "\n", "# bn_inv * x", "\n", "multiplier_instance", "=", "multiplier_factory", ".", "MultiplierFactory", "(", ")", "\n", "multiplier_x", "=", "multiplier_instance", ".", "make_multiplier", "(", "\n", "inverse_quantizer", ",", "prev_output_quantizer", ")", "\n", "\n", "qtools_util", ".", "adjust_multiplier_for_auto_po2", "(", "\n", "multiplier_x", ",", "qkeras_inverse_quantizer", ")", "\n", "\n", "# fused_bias = bn_inv * bias + beta - bn_inv*mean", "\n", "# This step derives the datatype for bn_inv * mean", "\n", "multiplier_mean", "=", "multiplier_instance", ".", "make_multiplier", "(", "\n", "inverse_quantizer", ",", "mean_quantizer", ")", "\n", "\n", "qtools_util", ".", "adjust_multiplier_for_auto_po2", "(", "\n", "multiplier_mean", ",", "qkeras_inverse_quantizer", ")", "\n", "\n", "adder_instance", "=", "adder_factory", ".", "IAdder", "(", ")", "\n", "if", "use_bias", ":", "\n", "# Derives datatype of bn_inv*bias", "\n", "      ", "multiplier_bias", "=", "multiplier_instance", ".", "make_multiplier", "(", "\n", "inverse_quantizer", ",", "prev_bias_quantizer", ")", "\n", "\n", "qtools_util", ".", "adjust_multiplier_for_auto_po2", "(", "\n", "multiplier_bias", ",", "qkeras_inverse_quantizer", ")", "\n", "\n", "# Derives datatype of bn_inv*bias - bn_inv*mean", "\n", "adder_1", "=", "adder_instance", ".", "make_quantizer", "(", "\n", "multiplier_bias", ".", "output", ",", "multiplier_mean", ".", "output", ")", "\n", "", "else", ":", "\n", "# There is no bias from the previous layer,", "\n", "# therefore datatype of bn_inv*bias - bn_inv*mean is the same", "\n", "# as bn_inv*mean", "\n", "      ", "adder_1", "=", "multiplier_mean", "\n", "\n", "", "if", "use_beta", ":", "\n", "# Derives datatype of fused_bias = bn_inv * bias + beta - bn_inv*mean", "\n", "      ", "adder_bias", "=", "adder_instance", ".", "make_quantizer", "(", "\n", "adder_1", ".", "output", ",", "beta_quantizer", ")", "\n", "", "else", ":", "\n", "# Since beta is not used, fused_bias = bn_inv * bias - bn_inv*mean", "\n", "      ", "adder_bias", "=", "adder_1", "\n", "\n", "# bn_inv * x - fused_bias", "\n", "", "adder", "=", "adder_instance", ".", "make_quantizer", "(", "\n", "multiplier_x", ".", "output", ",", "adder_bias", ".", "output", ")", "\n", "self", ".", "internal_accumulator", "=", "adder", "\n", "self", ".", "internal_output", "=", "adder", "\n", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.__init__": [[32, 93], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "    ", "self", ".", "quantizer_lookup", "=", "{", "\n", "quantizers", ".", "quantized_bits", ":", "\n", "quantizer_impl", ".", "QuantizedBits", ",", "\n", "quantizers", ".", "binary", ":", "\n", "quantizer_impl", ".", "Binary", ",", "\n", "quantizers", ".", "quantized_relu", ":", "\n", "quantizer_impl", ".", "QuantizedRelu", ",", "\n", "quantizers", ".", "ternary", ":", "\n", "quantizer_impl", ".", "Ternary", ",", "\n", "quantizers", ".", "quantized_relu_po2", ":", "\n", "quantizer_impl", ".", "ReluPowerOfTwo", ",", "\n", "quantizers", ".", "quantized_po2", ":", "\n", "quantizer_impl", ".", "PowerOfTwo", ",", "\n", "quantizers", ".", "stochastic_ternary", ":", "\n", "quantizer_impl", ".", "StochasticTernary", ",", "\n", "quantizers", ".", "stochastic_binary", ":", "\n", "quantizer_impl", ".", "StochasticBinary", ",", "\n", "quantizers", ".", "bernoulli", ":", "\n", "quantizer_impl", ".", "Bernoulli", ",", "\n", "quantizers", ".", "quantized_tanh", ":", "\n", "quantizer_impl", ".", "QuantizedTanh", ",", "\n", "quantizers", ".", "quantized_ulaw", ":", "\n", "quantizer_impl", ".", "QuantizedUlaw", ",", "\n", "\n", "\n", "\n", "\n", "\n", "# add following quantizer types for the use in GraphUpdateEdge", "\n", "quantizer_impl", ".", "QuantizedBits", ":", "\n", "quantizer_impl", ".", "QuantizedBits", ",", "\n", "quantizer_impl", ".", "Binary", ":", "\n", "quantizer_impl", ".", "Binary", ",", "\n", "quantizer_impl", ".", "QuantizedRelu", ":", "\n", "quantizer_impl", ".", "QuantizedRelu", ",", "\n", "quantizer_impl", ".", "Ternary", ":", "\n", "quantizer_impl", ".", "Ternary", ",", "\n", "quantizer_impl", ".", "ReluPowerOfTwo", ":", "\n", "quantizer_impl", ".", "ReluPowerOfTwo", ",", "\n", "quantizer_impl", ".", "PowerOfTwo", ":", "\n", "quantizer_impl", ".", "PowerOfTwo", ",", "\n", "quantizer_impl", ".", "FloatingPoint", ":", "\n", "quantizer_impl", ".", "FloatingPoint", ",", "\n", "quantizer_impl", ".", "StochasticTernary", ":", "\n", "quantizer_impl", ".", "StochasticTernary", ",", "\n", "quantizer_impl", ".", "StochasticBinary", ":", "\n", "quantizer_impl", ".", "StochasticTernary", ",", "\n", "quantizer_impl", ".", "Bernoulli", ":", "\n", "quantizer_impl", ".", "StochasticTernary", ",", "\n", "quantizer_impl", ".", "QuantizedTanh", ":", "\n", "quantizer_impl", ".", "StochasticTernary", ",", "\n", "quantizer_impl", ".", "QuantizedUlaw", ":", "\n", "quantizer_impl", ".", "StochasticTernary", ",", "\n", "\n", "\n", "\n", "\n", "}", "\n", "\n", "self", ".", "_default_interm_quantizer", "=", "cfg", ".", "default_interm_quantizer", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory._make_quantizer_util": [[94, 109], ["quantizer_factory.QuantizerFactory.make_default_quantizer", "isinstance", "tuple", "quantizer_factory.QuantizerFactory.quantizer_lookup.keys", "type", "quantizer_factory.QuantizerFactory.clone_quantizer", "quantizer_class", "quantizer_class.convert_qkeras_quantizer", "type"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.clone_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_qkeras_quantizer"], ["", "def", "_make_quantizer_util", "(", "self", ",", "quantizer", ")", "->", "quantizer_impl", ".", "IQuantizer", ":", "\n", "    ", "\"\"\"make quantizer util function.\"\"\"", "\n", "if", "quantizer", "in", "[", "\"int8\"", ",", "\"int16\"", ",", "\"int32\"", ",", "\"fp16\"", ",", "\"fp32\"", "]", ":", "\n", "      ", "return", "self", ".", "make_default_quantizer", "(", "mode", "=", "quantizer", ")", "\n", "\n", "", "elif", "isinstance", "(", "quantizer", ",", "tuple", "(", "self", ".", "quantizer_lookup", ".", "keys", "(", ")", ")", ")", ":", "\n", "      ", "quantizer_class", "=", "self", ".", "quantizer_lookup", "[", "type", "(", "quantizer", ")", "]", "\n", "if", "quantizer_class", "==", "type", "(", "quantizer", ")", ":", "\n", "        ", "return", "self", ".", "clone_quantizer", "(", "quantizer", ")", "\n", "", "else", ":", "\n", "        ", "q", "=", "quantizer_class", "(", ")", "\n", "q", ".", "convert_qkeras_quantizer", "(", "quantizer", ")", "\n", "return", "q", "\n", "\n", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_quantizer": [[110, 122], ["quantizer_factory.QuantizerFactory._make_quantizer_util", "quantizer_factory.QuantizerFactory.make_default_quantizer"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory._make_quantizer_util", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer"], ["", "def", "make_quantizer", "(", "self", ",", "quantizer", ")", "->", "quantizer_impl", ".", "IQuantizer", ":", "\n", "    ", "\"\"\"create quantizer according to input qkeras quantizer.\"\"\"", "\n", "\n", "q", "=", "None", "\n", "if", "quantizer", "is", "not", "None", ":", "\n", "      ", "q", "=", "self", ".", "_make_quantizer_util", "(", "quantizer", ")", "\n", "\n", "", "if", "q", "is", "None", ":", "\n", "      ", "return", "self", ".", "make_default_quantizer", "(", "\n", "mode", "=", "self", ".", "_default_interm_quantizer", ")", "\n", "\n", "", "return", "q", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.is_quantizer_supported": [[123, 129], ["isinstance", "tuple", "quantizer_factory.QuantizerFactory.quantizer_lookup.keys"], "methods", ["None"], ["", "def", "is_quantizer_supported", "(", "self", ",", "quantizer", ")", "->", "bool", ":", "\n", "    ", "if", "quantizer", "is", "None", ":", "\n", "# if None, will use default quantizer defined in config.json", "\n", "      ", "return", "True", "\n", "\n", "", "return", "isinstance", "(", "quantizer", ",", "tuple", "(", "self", ".", "quantizer_lookup", ".", "keys", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.make_default_quantizer": [[130, 161], ["qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.FloatingPoint", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits.convert_qkeras_quantizer", "qkeras.quantizers.quantized_bits", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits.convert_qkeras_quantizer", "qkeras.quantizers.quantized_bits", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits", "qkeras.qtools.quantized_operators.quantizer_impl.QuantizedBits.convert_qkeras_quantizer", "qkeras.quantizers.quantized_bits", "eval", "quantizer_factory.QuantizerFactory._make_quantizer_util", "ValueError"], "methods", ["home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_qkeras_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_qkeras_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_impl.ReluPowerOfTwo.convert_qkeras_quantizer", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory._make_quantizer_util"], ["", "def", "make_default_quantizer", "(", "self", ",", "mode", ")", "->", "quantizer_impl", ".", "IQuantizer", ":", "\n", "    ", "\"\"\"make quantizer given qkeras quantizer type.\"\"\"", "\n", "if", "mode", "==", "\"fp32\"", ":", "\n", "      ", "return", "quantizer_impl", ".", "FloatingPoint", "(", "\n", "bits", "=", "32", ")", "\n", "", "elif", "mode", "==", "\"fp16\"", ":", "\n", "      ", "return", "quantizer_impl", ".", "FloatingPoint", "(", "\n", "bits", "=", "16", ")", "\n", "", "elif", "mode", "==", "\"int8\"", ":", "\n", "      ", "qbits", "=", "quantizer_impl", ".", "QuantizedBits", "(", ")", "\n", "qbits", ".", "convert_qkeras_quantizer", "(", "\n", "quantizers", ".", "quantized_bits", "(", "8", ",", "0", ",", "1", ")", ")", "\n", "return", "qbits", "\n", "", "elif", "mode", "==", "\"int16\"", ":", "\n", "      ", "qbits", "=", "quantizer_impl", ".", "QuantizedBits", "(", ")", "\n", "qbits", ".", "convert_qkeras_quantizer", "(", "\n", "quantizers", ".", "quantized_bits", "(", "16", ",", "7", ",", "1", ")", ")", "\n", "return", "qbits", "\n", "", "elif", "mode", "==", "\"int32\"", ":", "\n", "      ", "qbits", "=", "quantizer_impl", ".", "QuantizedBits", "(", ")", "\n", "qbits", ".", "convert_qkeras_quantizer", "(", "\n", "quantizers", ".", "quantized_bits", "(", "32", ",", "10", ",", "1", ")", ")", "\n", "return", "qbits", "\n", "", "else", ":", "\n", "      ", "try", ":", "\n", "# string to quantizer object", "\n", "        ", "q_name", "=", "\"quantizers.\"", "+", "mode", "\n", "qkeras_object", "=", "eval", "(", "q_name", ")", "# pylint: disable=eval-used", "\n", "return", "self", ".", "_make_quantizer_util", "(", "qkeras_object", ")", "\n", "", "except", ":", "# pylint: disable=bare-except", "\n", "        ", "raise", "ValueError", "(", "\"unaccepted quantizer {}!\"", ".", "format", "(", "mode", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.quantizer_factory.QuantizerFactory.clone_quantizer": [[162, 166], ["copy.deepcopy"], "methods", ["None"], ["", "", "", "def", "clone_quantizer", "(", "\n", "self", ",", "quantizer", ":", "quantizer_impl", ".", "IQuantizer", ")", "->", "quantizer_impl", ".", "IQuantizer", ":", "\n", "    ", "\"\"\"clone the given quantizer.\"\"\"", "\n", "return", "copy", ".", "deepcopy", "(", "quantizer", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.google_qkeras.qenergy.qenergy.get_op_type": [[65, 72], ["isinstance", "str"], "function", ["None"], ["def", "get_op_type", "(", "quantizer", ")", ":", "\n", "  ", "assert", "isinstance", "(", "quantizer", ",", "IQuantizer", ")", "\n", "\n", "if", "quantizer", ".", "is_floating_point", ":", "\n", "    ", "return", "\"fp\"", "+", "str", "(", "quantizer", ".", "bits", ")", "\n", "", "else", ":", "\n", "    ", "return", "\"fpm\"", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qenergy.qenergy.memory_read_energy": [[74, 116], ["numpy.log2", "numpy.prod", "max", "numpy.ceil", "numpy.ceil"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "", "def", "memory_read_energy", "(", "is_input_layer", ",", "tensor_shape", ",", "mode", ",", "min_sram_size", ",", "\n", "rd_wr_on_io", ",", "quantizer_bits", ",", "is_tensor", "=", "True", ")", ":", "\n", "  ", "\"\"\"compute energy to bring tensors from DRAM to SRAM.\"\"\"", "\n", "\n", "if", "is_input_layer", ":", "\n", "    ", "if", "rd_wr_on_io", ":", "\n", "      ", "mode", "=", "\"dram\"", "\n", "", "else", ":", "\n", "      ", "mode", "=", "\"sram\"", "\n", "\n", "", "", "energy_mem", "=", "0", "\n", "\n", "if", "is_tensor", ":", "\n", "    ", "tensor_shape", "=", "tensor_shape", "[", "1", ":", "]", "\n", "\n", "", "total_bits", "=", "np", ".", "prod", "(", "tensor_shape", ")", "*", "quantizer_bits", "\n", "total_bits_log2", "=", "np", ".", "log2", "(", "max", "(", "total_bits", ",", "min_sram_size", ")", ")", "\n", "\n", "if", "mode", "==", "\"dram\"", ":", "\n", "# load input from dram; wx_sizes[1]-> input x quantizer bits", "\n", "# total_bits * 20", "\n", "    ", "energy_mem", "+=", "OP", "[", "\"dram\"", "]", "[", "\"rd\"", "]", "(", "total_bits", ")", "\n", "if", "rd_wr_on_io", ":", "\n", "# write input to sram", "\n", "# total_bits * sqrt(data_size/2^18)*0.3125", "\n", "# bits1 = total_bits * OP[\"sram\"][\"mul_factor\"](np.prod(tensor_shape))", "\n", "# energy_mem += OP[\"sram\"][\"wr\"](bits1)", "\n", "      ", "energy_mem", "+=", "(", "\n", "np", ".", "ceil", "(", "total_bits", "*", "OP", "[", "\"sram\"", "]", "[", "\"mul_factor\"", "]", ")", "*", "\n", "OP", "[", "\"sram\"", "]", "[", "\"wr\"", "]", "(", "total_bits_log2", ")", "\n", ")", "\n", "", "", "elif", "mode", "==", "\"sram\"", ":", "\n", "# read input from sram", "\n", "# total_bits * sqrt(data_size/2^18)*0.3125", "\n", "# bits1 = total_bits * OP[\"sram\"][\"mul_factor\"](np.prod(tensor_shape))", "\n", "# energy_mem += OP[\"sram\"][\"rd\"](bits1)", "\n", "    ", "energy_mem", "+=", "(", "\n", "np", ".", "ceil", "(", "total_bits", "*", "OP", "[", "\"sram\"", "]", "[", "\"mul_factor\"", "]", ")", "*", "\n", "OP", "[", "\"sram\"", "]", "[", "\"rd\"", "]", "(", "total_bits_log2", ")", "\n", ")", "\n", "\n", "", "return", "energy_mem", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qenergy.qenergy.parameter_read_energy": [[118, 160], ["layer.get_weights", "len", "qkeras.qtools.qtools_util.get_val", "qkeras.qtools.qtools_util.get_val", "qkeras.qtools.qtools_util.get_val", "qkeras.qtools.qtools_util.get_val", "qenergy.memory_read_energy", "qenergy.memory_read_energy", "qenergy.memory_read_energy"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_weights", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_val", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_val", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_val", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_val", "home.repos.pwc.inspect_result.google_qkeras.qenergy.qenergy.memory_read_energy", "home.repos.pwc.inspect_result.google_qkeras.qenergy.qenergy.memory_read_energy", "home.repos.pwc.inspect_result.google_qkeras.qenergy.qenergy.memory_read_energy"], ["", "def", "parameter_read_energy", "(", "\n", "layer", ",", "layer_item", ",", "weights_on_memory", ",", "min_sram_size", ",", "rd_wr_on_io", ")", ":", "\n", "  ", "\"\"\"read weights/bias from memory.\"\"\"", "\n", "\n", "node_type", "=", "layer", ".", "__class__", ".", "__name__", "\n", "rd_energy", "=", "0", "\n", "if", "node_type", "in", "[", "\"QBatchNormalization\"", ",", "\"BatchNormalization\"", "]", ":", "\n", "    ", "gamma_quantizer", "=", "layer_item", "[", "\"gamma_quantizer\"", "]", "\n", "beta_quantizer", "=", "layer_item", "[", "\"beta_quantizer\"", "]", "\n", "mean_quantizer", "=", "layer_item", "[", "\"mean_quantizer\"", "]", "\n", "variance_quantizer", "=", "layer_item", "[", "\"variance_quantizer\"", "]", "\n", "\n", "# gamma, beta, mean, stddev", "\n", "weights", "=", "layer", ".", "get_weights", "(", ")", "\n", "s", "=", "len", "(", "weights", "[", "0", "]", ")", "\n", "for", "q", "in", "[", "gamma_quantizer", ",", "beta_quantizer", ",", "mean_quantizer", ",", "\n", "variance_quantizer", "]", ":", "\n", "      ", "if", "q", ":", "\n", "        ", "rd_energy", "+=", "memory_read_energy", "(", "\n", "False", ",", "(", "s", ")", ",", "weights_on_memory", ",", "min_sram_size", ",", "rd_wr_on_io", ",", "\n", "q", ".", "bits", ",", "is_tensor", "=", "False", ")", "\n", "\n", "", "", "", "elif", "node_type", "in", "QKERAS_LAYERS", "or", "node_type", "in", "KERAS_LAYERS", ":", "\n", "    ", "weight_quantizer", "=", "qtools_util", ".", "get_val", "(", "layer_item", ",", "\"weight_quantizer\"", ")", "\n", "w_shapes", "=", "qtools_util", ".", "get_val", "(", "layer_item", ",", "\"w_shapes\"", ")", "\n", "bias_quantizer", "=", "qtools_util", ".", "get_val", "(", "layer_item", ",", "\"bias_quantizer\"", ")", "\n", "b_shapes", "=", "qtools_util", ".", "get_val", "(", "layer_item", ",", "\"b_shapes\"", ")", "\n", "\n", "rd_energy", "+=", "memory_read_energy", "(", "\n", "False", ",", "w_shapes", ",", "weights_on_memory", ",", "min_sram_size", ",", "rd_wr_on_io", ",", "\n", "weight_quantizer", ".", "bits", ",", "is_tensor", "=", "False", "\n", ")", "\n", "\n", "if", "bias_quantizer", ":", "\n", "# if use_bias=0, no bias", "\n", "      ", "bias_shapes", "=", "(", "b_shapes", ")", "\n", "rd_energy", "+=", "memory_read_energy", "(", "\n", "False", ",", "bias_shapes", ",", "weights_on_memory", ",", "min_sram_size", ",", "rd_wr_on_io", ",", "\n", "bias_quantizer", ".", "bits", ",", "is_tensor", "=", "False", "\n", ")", "\n", "\n", "", "", "return", "rd_energy", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qenergy.qenergy.memory_write_energy": [[162, 203], ["numpy.log2", "numpy.prod", "max", "numpy.ceil", "numpy.ceil"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qkeras.quantizers.quantized_relu_po2.max"], ["", "def", "memory_write_energy", "(", "is_output_layer", ",", "tensor_shape", ",", "mode", ",", "min_sram_size", ",", "\n", "rd_wr_on_io", ",", "quantizer_bits", ")", ":", "\n", "  ", "\"\"\"compute energy to bring tensors from SRAM to DRAM.\"\"\"", "\n", "if", "is_output_layer", ":", "\n", "    ", "if", "rd_wr_on_io", ":", "\n", "      ", "mode", "=", "\"dram\"", "\n", "", "else", ":", "\n", "      ", "mode", "=", "\"sram\"", "\n", "\n", "", "", "energy_mem", "=", "0", "\n", "\n", "tensor_shape", "=", "tensor_shape", "[", "1", ":", "]", "\n", "\n", "total_bits", "=", "np", ".", "prod", "(", "tensor_shape", ")", "*", "quantizer_bits", "\n", "total_bits_log2", "=", "np", ".", "log2", "(", "max", "(", "total_bits", ",", "min_sram_size", ")", ")", "\n", "\n", "if", "mode", "==", "\"dram\"", ":", "\n", "# load input from dram; wx_sizes[1]-> input x quantizer bits", "\n", "    ", "if", "rd_wr_on_io", ":", "\n", "# read input from sram", "\n", "# total_bits * sqrt(data_size/2^18)*0.3125", "\n", "# bits1 = total_bits * OP[\"sram\"][\"mul_factor\"](np.prod(tensor_shape))", "\n", "# energy_mem += OP[\"sram\"][\"rd\"](bits1)", "\n", "      ", "energy_mem", "+=", "(", "\n", "np", ".", "ceil", "(", "total_bits", "*", "OP", "[", "\"sram\"", "]", "[", "\"mul_factor\"", "]", ")", "*", "\n", "OP", "[", "\"sram\"", "]", "[", "\"rd\"", "]", "(", "total_bits_log2", ")", "\n", ")", "\n", "# write output to dram", "\n", "", "energy_mem", "+=", "OP", "[", "\"dram\"", "]", "[", "\"wr\"", "]", "(", "total_bits", ")", "\n", "\n", "", "elif", "mode", "==", "\"sram\"", ":", "\n", "# write to sram", "\n", "# total_bits * sqrt(data_size/2^18)*0.3125", "\n", "# bits1 = total_bits * OP[\"sram\"][\"mul_factor\"](np.prod(tensor_shape))", "\n", "# energy_mem +=  OP[\"sram\"][\"wr\"](bits1)", "\n", "    ", "energy_mem", "+=", "(", "\n", "np", ".", "ceil", "(", "total_bits", "*", "OP", "[", "\"sram\"", "]", "[", "\"mul_factor\"", "]", ")", "*", "\n", "OP", "[", "\"sram\"", "]", "[", "\"wr\"", "]", "(", "total_bits_log2", ")", "\n", ")", "\n", "\n", "", "return", "energy_mem", "\n", "\n"]], "home.repos.pwc.inspect_result.google_qkeras.qenergy.qenergy.energy_estimate": [[205, 341], ["int", "qkeras.qtools.qtools_util.get_val", "qkeras.qtools.qtools_util.get_val", "qkeras.qtools.qtools_util.get_val", "qkeras.qtools.qtools_util.get_val", "zip", "qenergy.parameter_read_energy", "qenergy.memory_write_energy", "layer_data_type_map.keys", "isinstance", "qenergy.memory_read_energy", "float", "float", "float", "float", "divider.implemented_as", "qtools_util.get_val.implemented_as", "qkeras.qtools.qtools_util.get_val", "qtools_util.get_val.implemented_as", "len", "qenergy.get_op_type", "qkeras.qtools.qtools_util.get_val", "qkeras.qtools.qtools_util.get_val", "qkeras.qtools.qtools_util.get_val", "qkeras.qtools.qtools_util.get_val", "qtools_util.get_val.implemented_as", "qenergy.get_op_type", "qenergy.get_op_type", "qenergy.get_op_type", "qenergy.get_op_type", "qenergy.get_op_type"], "function", ["home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_val", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_val", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_val", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_val", "home.repos.pwc.inspect_result.google_qkeras.qenergy.qenergy.parameter_read_energy", "home.repos.pwc.inspect_result.google_qkeras.qenergy.qenergy.memory_write_energy", "home.repos.pwc.inspect_result.google_qkeras.qenergy.qenergy.memory_read_energy", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.divider_impl.Subtractor.implemented_as", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.divider_impl.Subtractor.implemented_as", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_val", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.divider_impl.Subtractor.implemented_as", "home.repos.pwc.inspect_result.google_qkeras.qenergy.qenergy.get_op_type", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_val", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_val", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_val", "home.repos.pwc.inspect_result.google_qkeras.qtools.qtools_util.get_val", "home.repos.pwc.inspect_result.google_qkeras.quantized_operators.divider_impl.Subtractor.implemented_as", "home.repos.pwc.inspect_result.google_qkeras.qenergy.qenergy.get_op_type", "home.repos.pwc.inspect_result.google_qkeras.qenergy.qenergy.get_op_type", "home.repos.pwc.inspect_result.google_qkeras.qenergy.qenergy.get_op_type", "home.repos.pwc.inspect_result.google_qkeras.qenergy.qenergy.get_op_type", "home.repos.pwc.inspect_result.google_qkeras.qenergy.qenergy.get_op_type"], ["", "def", "energy_estimate", "(", "model", ",", "layer_map", ",", "weights_on_memory", ",", "\n", "activations_on_memory", ",", "min_sram_size", ",", "\n", "rd_wr_on_io", ")", ":", "\n", "  ", "\"\"\"estimate energy.\"\"\"", "\n", "\n", "output_layers", "=", "layer_map", "[", "\"output_layers\"", "]", "\n", "input_layers", "=", "layer_map", "[", "\"input_layers\"", "]", "\n", "layer_data_type_map", "=", "layer_map", "[", "\"layer_data_type_map\"", "]", "\n", "\n", "result", "=", "{", "}", "\n", "total_energy", "=", "0", "\n", "\n", "# compute MAC and memory access energy for intermediate layers", "\n", "for", "layer", "in", "model", ".", "layers", ":", "\n", "    ", "if", "layer", "not", "in", "layer_data_type_map", ".", "keys", "(", ")", ":", "\n", "      ", "continue", "\n", "\n", "", "layer_item", "=", "layer_data_type_map", "[", "layer", "]", "\n", "input_quantizer_list", "=", "qtools_util", ".", "get_val", "(", "\n", "layer_item", ",", "\"input_quantizer_list\"", ")", "\n", "operation_count", "=", "qtools_util", ".", "get_val", "(", "layer_item", ",", "\"operation_count\"", ")", "\n", "output_shapes", "=", "qtools_util", ".", "get_val", "(", "layer_item", ",", "\"output_shapes\"", ")", "\n", "output_quantizer", "=", "qtools_util", ".", "get_val", "(", "layer_item", ",", "\"output_quantizer\"", ")", "\n", "\n", "is_input_layer", "=", "layer", "in", "input_layers", "\n", "is_output_layer", "=", "layer", "in", "output_layers", "\n", "\n", "input_rd_energy", "=", "0", "\n", "energy_op", "=", "0", "\n", "input_shape", "=", "layer", ".", "input_shape", "\n", "if", "not", "isinstance", "(", "input_shape", ",", "list", ")", ":", "\n", "      ", "input_shape", "=", "[", "input_shape", "]", "\n", "\n", "", "for", "(", "input_shape", ",", "input_quantizer", ")", "in", "zip", "(", "\n", "input_shape", ",", "input_quantizer_list", ")", ":", "\n", "      ", "input_rd_energy", "+=", "memory_read_energy", "(", "\n", "is_input_layer", ",", "input_shape", ",", "\n", "activations_on_memory", ",", "min_sram_size", ",", "rd_wr_on_io", ",", "\n", "input_quantizer", ".", "bits", ")", "\n", "\n", "", "parameter_rd_energy", "=", "parameter_read_energy", "(", "\n", "layer", ",", "layer_item", ",", "weights_on_memory", ",", "min_sram_size", ",", "\n", "rd_wr_on_io", ")", "\n", "\n", "output_wr_energy", "=", "memory_write_energy", "(", "\n", "is_output_layer", ",", "output_shapes", ",", "\n", "activations_on_memory", ",", "min_sram_size", ",", "rd_wr_on_io", ",", "\n", "output_quantizer", ".", "bits", ")", "\n", "# QActivation Layer", "\n", "if", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"QActivation\"", ",", "\"QAdaptiveActivation\"", ",", "\n", "\"Activation\"", "]", ":", "\n", "      ", "pass", "\n", "\n", "# QBN Layer", "\n", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\n", "\"QBatchNormalization\"", ",", "\"BatchNormalization\"", "]", ":", "\n", "# assume QBN is embedded with conv/dense layers", "\n", "# -> no memory read/write cost", "\n", "\n", "      ", "divider", "=", "layer_item", "[", "\"internal_divide_quantizer\"", "]", "\n", "if", "divider", ":", "\n", "        ", "gate_factor", "=", "divider", ".", "gate_factor", "\n", "mode", "=", "divider", ".", "implemented_as", "(", ")", "\n", "energy_op", "+=", "gate_factor", "*", "OP", "[", "\n", "get_op_type", "(", "divider", ".", "output", ")", "]", "[", "mode", "]", "(", "divider", ".", "gate_bits", ")", "\n", "\n", "", "multiplier", "=", "layer_item", "[", "\"internal_multiplier\"", "]", "\n", "if", "multiplier", ":", "\n", "        ", "gate_factor", "=", "multiplier", ".", "gate_factor", "\n", "mode", "=", "multiplier", ".", "implemented_as", "(", ")", "\n", "energy_op", "+=", "gate_factor", "*", "OP", "[", "\n", "get_op_type", "(", "multiplier", ".", "output", ")", "]", "[", "mode", "]", "(", "multiplier", ".", "gate_bits", ")", "\n", "\n", "", "energy_op", "*=", "operation_count", "\n", "\n", "# Merge layer", "\n", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"Add\"", ",", "\"Multiply\"", ",", "\"Subtract\"", "]", ":", "\n", "\n", "# multiply or add operation energy", "\n", "# TODO(lishanok): check energy for concatenate", "\n", "      ", "merge_quantizer", "=", "qtools_util", ".", "get_val", "(", "layer_item", ",", "\"multiplier\"", ")", "\n", "mode", "=", "merge_quantizer", ".", "implemented_as", "(", ")", "\n", "number_of_inputs", "=", "len", "(", "qtools_util", ".", "get_val", "(", "\n", "layer_item", ",", "\"input_quantizer_list\"", ")", ")", "\n", "gate_factor", "=", "merge_quantizer", ".", "gate_factor", "\n", "\n", "q", "=", "get_op_type", "(", "merge_quantizer", ".", "output", ")", "\n", "b", "=", "merge_quantizer", ".", "gate_bits", "\n", "energy_op", "=", "(", "number_of_inputs", "-", "1", ")", "*", "operation_count", "*", "gate_factor", "*", "OP", "[", "\n", "q", "]", "[", "mode", "]", "(", "b", ")", "\n", "\n", "# AveragePooling and GlobalAveragePooling", "\n", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\n", "\"AveragePooling2D\"", ",", "\"AvgPool2D\"", ",", "\"GlobalAvgPool2D\"", ",", "\n", "\"GlobalAveragePooling2D\"", "]", ":", "\n", "# accumulation operation energy", "\n", "      ", "accumulator", "=", "qtools_util", ".", "get_val", "(", "layer_item", ",", "\"accumulator\"", ")", "\n", "add_energy", "=", "OP", "[", "get_op_type", "(", "accumulator", ".", "output", ")", "]", "[", "\"add\"", "]", "(", "\n", "accumulator", ".", "output", ".", "bits", ")", "\n", "energy_op", "=", "operation_count", "*", "add_energy", "\n", "\n", "# MAC energy calculation", "\n", "", "elif", "layer", ".", "__class__", ".", "__name__", "in", "[", "\"QConv2D\"", ",", "\"QConv1D\"", ",", "\"QDepthwiseConv2D\"", ",", "\n", "\"QDense\"", ",", "\"Conv2D\"", ",", "\"Conv1D\"", ",", "\n", "\"DepthwiseConv2D\"", ",", "\"Dense\"", "]", ":", "\n", "      ", "multiplier", "=", "qtools_util", ".", "get_val", "(", "layer_item", ",", "\"multiplier\"", ")", "\n", "accumulator", "=", "qtools_util", ".", "get_val", "(", "layer_item", ",", "\"accumulator\"", ")", "\n", "\n", "# implementation mode: xor/andgate/shift etc.", "\n", "mode", "=", "multiplier", ".", "implemented_as", "(", ")", "\n", "gate_factor", "=", "multiplier", ".", "gate_factor", "\n", "\n", "op", "=", "get_op_type", "(", "multiplier", ".", "output", ")", "\n", "bits", "=", "multiplier", ".", "gate_bits", "\n", "c1", "=", "gate_factor", "*", "OP", "[", "op", "]", "[", "mode", "]", "(", "bits", ")", "\n", "c2", "=", "OP", "[", "get_op_type", "(", "accumulator", ".", "output", ")", "]", "[", "\"add\"", "]", "(", "accumulator", ".", "output", ".", "bits", ")", "\n", "energy_op", "=", "operation_count", "*", "(", "c1", "+", "c2", ")", "\n", "\n", "", "else", ":", "\n", "      ", "pass", "\n", "\n", "", "result", "[", "layer", ".", "name", "]", "=", "{", "\n", "\"class_name\"", ":", "layer", ".", "__class__", ".", "__name__", ",", "\n", "\"energy\"", ":", "{", "\n", "\"inputs\"", ":", "float", "(", "\"{0:.2f}\"", ".", "format", "(", "input_rd_energy", ")", ")", ",", "\n", "\"outputs\"", ":", "float", "(", "\"{0:.2f}\"", ".", "format", "(", "output_wr_energy", ")", ")", ",", "\n", "\"parameters\"", ":", "float", "(", "\"{0:.2f}\"", ".", "format", "(", "parameter_rd_energy", ")", ")", ",", "\n", "\"op_cost\"", ":", "float", "(", "\"{0:.2f}\"", ".", "format", "(", "energy_op", ")", ")", "\n", "}", "\n", "}", "\n", "total_energy", "+=", "(", "input_rd_energy", "+", "output_wr_energy", "+", "\n", "parameter_rd_energy", "+", "energy_op", ")", "\n", "\n", "", "result", "[", "\"total_cost\"", "]", "=", "int", "(", "total_energy", ")", "\n", "\n", "return", "result", "\n", "", ""]]}