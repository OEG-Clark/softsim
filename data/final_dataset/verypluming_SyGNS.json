{"home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.instantiate_sp.load_vocab": [[12, 18], ["open", "yaml.load", "ValueError"], "function", ["None"], ["def", "load_vocab", "(", "file", ")", ":", "\n", "    ", "with", "open", "(", "file", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", "as", "infile", ":", "\n", "        ", "loaded", "=", "yaml", ".", "load", "(", "infile", ",", "Loader", "=", "yaml", ".", "SafeLoader", ")", "\n", "", "if", "not", "loaded", ":", "\n", "        ", "raise", "ValueError", "(", "\"couldn't load file: \"", "+", "file", ")", "\n", "", "return", "loaded", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.instantiate_sp.schematize": [[20, 31], ["sentence.split", "sent.append", "word.replace.replace", "str"], "function", ["None"], ["", "def", "schematize", "(", "sentence", ",", "cat", ")", ":", "\n", "    ", "count", "=", "0", "\n", "sent", "=", "[", "]", "\n", "for", "word", "in", "sentence", ".", "split", "(", "' '", ")", ":", "\n", "        ", "if", "word", "==", "cat", ":", "\n", "            ", "var", "=", "'{0['", "+", "str", "(", "count", ")", "+", "']}'", "\n", "word", "=", "word", ".", "replace", "(", "cat", ",", "var", ")", "\n", "count", "+=", "1", "\n", "", "sent", ".", "append", "(", "word", ")", "\n", "", "out", "=", "' '", ".", "join", "(", "sent", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.instantiate_sp.instantiate": [[33, 65], ["sentence.count", "output.append", "math.ceil", "random.sample", "len", "list", "list", "schematize().format", "output.append", "itertools.permutations", "itertools.permutations", "len", "instantiate_sp.schematize", "len"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.instantiate_sp.schematize"], ["", "def", "instantiate", "(", "cat", ",", "items", ",", "sentences", ",", "depth", ")", ":", "\n", "    ", "output", "=", "[", "]", "\n", "for", "sentence", "in", "sentences", ":", "\n", "        ", "num_occur", "=", "sentence", ".", "count", "(", "cat", ")", "\n", "if", "num_occur", "==", "0", ":", "\n", "            ", "output", ".", "append", "(", "sentence", ")", "\n", "", "else", ":", "\n", "            ", "if", "len", "(", "items", ")", "<", "num_occur", ":", "\n", "                ", "items", "=", "items", "*", "num_occur", "\n", "perms", "=", "list", "(", "itertools", ".", "permutations", "(", "items", ",", "num_occur", ")", ")", "\n", "", "else", ":", "\n", "                ", "perms", "=", "list", "(", "itertools", ".", "permutations", "(", "items", ",", "num_occur", ")", ")", "\n", "\n", "", "if", "depth", "==", "'depth0'", ":", "\n", "                ", "rate", "=", "4", "/", "5", "\n", "", "elif", "depth", "==", "'depth1'", ":", "\n", "                ", "rate", "=", "1", "/", "5", "\n", "", "elif", "depth", "==", "'depth2'", ":", "\n", "                ", "rate", "=", "1", "/", "35", "\n", "", "elif", "depth", "==", "'depth3'", ":", "\n", "                ", "rate", "=", "1", "/", "700", "\n", "", "elif", "depth", "==", "'depth4'", ":", "\n", "                ", "rate", "=", "1", "/", "3000", "\n", "", "else", ":", "\n", "                ", "rate", "=", "1", "/", "len", "(", "perms", ")", "\n", "\n", "", "par", "=", "math", ".", "ceil", "(", "len", "(", "perms", ")", "*", "rate", ")", "\n", "perms", "=", "random", ".", "sample", "(", "perms", ",", "k", "=", "par", ")", "\n", "for", "perm", "in", "perms", ":", "\n", "                ", "res", "=", "schematize", "(", "sentence", ",", "cat", ")", ".", "format", "(", "perm", ")", "\n", "output", ".", "append", "(", "res", ")", "\n", "", "", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.instantiate_sp.perm_count": [[67, 69], ["math.factorial", "math.factorial"], "function", ["None"], ["", "def", "perm_count", "(", "n", ",", "m", ")", ":", "\n", "    ", "return", "math", ".", "factorial", "(", "n", ")", "//", "math", ".", "factorial", "(", "n", "-", "m", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.instantiate_sp.estimate": [[71, 84], ["collections.Counter", "sentence.count", "len", "collections.Counter.update", "pow"], "function", ["None"], ["", "def", "estimate", "(", "sentences", ",", "vocabs", ")", ":", "\n", "    ", "estimated_num", "=", "0", "\n", "data", "=", "collections", ".", "Counter", "(", ")", "\n", "for", "sentence", "in", "sentences", ":", "\n", "        ", "sum", "=", "1", "\n", "for", "vocab", "in", "vocabs", ":", "\n", "            ", "cat", "=", "vocab", "[", "'category'", "]", "\n", "occur", "=", "sentence", ".", "count", "(", "cat", ")", "\n", "size", "=", "len", "(", "vocab", "[", "'surf'", "]", ")", "\n", "sum", "=", "sum", "*", "pow", "(", "size", ",", "occur", ")", "\n", "data", ".", "update", "(", "[", "(", "cat", ",", "occur", ")", "]", ")", "\n", "", "estimated_num", "+=", "sum", "\n", "", "return", "estimated_num", ",", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.instantiate_sp.main": [[86, 137], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "instantiate_sp.load_vocab", "sorted", "os.path.exists", "os.mkdir", "glob.glob", "os.path.basename", "print", "os.path.basename.replace", "os.path.basename.split", "open", "instantiate_sp.estimate", "print", "len", "print", "print", "random.sample", "s.rstrip", "instantiate_sp.instantiate", "open", "f.write", "f.readlines", "len"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.instantiate_sp.load_vocab", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.instantiate_sp.estimate", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.instantiate_sp.instantiate"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "''", ")", "\n", "parser", ".", "add_argument", "(", "'DIRNAME'", ",", "\n", "help", "=", "'the directory name for \\\n                              sentence schema'", ",", "type", "=", "str", ")", "\n", "parser", ".", "add_argument", "(", "'TOTAL'", ",", "\n", "help", "=", "'the total number of sentences \\\n                              generated for each depth'", ",", "type", "=", "int", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "dir", "=", "args", ".", "DIRNAME", "\n", "res_dir", "=", "dir", "+", "\"_results\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "res_dir", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "res_dir", ")", "\n", "\n", "", "vocabs", "=", "load_vocab", "(", "'vocab.yaml'", ")", "\n", "total", "=", "args", ".", "TOTAL", "\n", "\n", "for", "file", "in", "sorted", "(", "glob", ".", "glob", "(", "dir", "+", "\"/*.scheme.txt\"", ")", ")", ":", "\n", "        ", "basename", "=", "os", ".", "path", ".", "basename", "(", "file", ")", "\n", "print", "(", "'Processing {0}'", ".", "format", "(", "basename", ")", ")", "\n", "depth", "=", "basename", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "resname", "=", "basename", ".", "replace", "(", "'scheme.'", ",", "''", ")", "\n", "fout", "=", "res_dir", "+", "'/'", "+", "resname", "\n", "\n", "if", "depth", "==", "'depth0'", ":", "\n", "            ", "num", "=", "total", "\n", "", "elif", "depth", "==", "'depth1'", ":", "\n", "            ", "num", "=", "total", "\n", "", "else", ":", "\n", "#num = total // 10", "\n", "            ", "num", "=", "total", "\n", "\n", "", "with", "open", "(", "file", ")", "as", "f", ":", "\n", "            ", "sentences", "=", "[", "s", ".", "rstrip", "(", ")", "for", "s", "in", "f", ".", "readlines", "(", ")", "]", "\n", "\n", "_", ",", "data", "=", "estimate", "(", "sentences", ",", "vocabs", ")", "\n", "print", "(", "'number of schema: {0}'", ".", "format", "(", "len", "(", "sentences", ")", ")", ")", "\n", "\n", "for", "vocab", "in", "vocabs", ":", "\n", "                ", "cat", "=", "vocab", "[", "'category'", "]", "\n", "items", "=", "vocab", "[", "'surf'", "]", "\n", "sentences", "=", "instantiate", "(", "cat", ",", "items", ",", "sentences", ",", "depth", ")", "\n", "", "max_num", "=", "len", "(", "sentences", ")", "\n", "print", "(", "'max number of sentences: {:,}'", ".", "format", "(", "max_num", ")", ")", "\n", "print", "(", "'************************'", ")", "\n", "sentences", "=", "random", ".", "sample", "(", "sentences", ",", "k", "=", "num", ")", "\n", "output", "=", "'\\n'", ".", "join", "(", "sentences", ")", "+", "'\\n'", "\n", "with", "open", "(", "fout", ",", "'a'", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.rev_pol": [[11, 17], ["None"], "function", ["None"], ["def", "rev_pol", "(", "value", ")", ":", "\n", "    ", "if", "value", "==", "0", ":", "\n", "        ", "out", "=", "1", "\n", "", "else", ":", "\n", "        ", "out", "=", "0", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.calculate_polarity": [[19, 22], ["nltk2pol.polarity_expr"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_expr"], ["", "def", "calculate_polarity", "(", "expression", ")", ":", "\n", "    ", "pols", "=", "polarity_expr", "(", "expression", ",", "1", ")", "\n", "return", "pols", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_expr": [[24, 42], ["isinstance", "nltk2pol.polarity_application_expr", "isinstance", "nltk2pol.polarity_and_expr", "isinstance", "nltk2pol.polarity_or_expr", "isinstance", "nltk2pol.polarity_imp_expr", "isinstance", "nltk2pol.polarity_not_expr", "isinstance", "nltk2pol.polarity_exists_expr", "isinstance", "nltk2pol.polarity_all_expr"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_application_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_and_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_or_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_imp_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_not_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_exists_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_all_expr"], ["", "def", "polarity_expr", "(", "expression", ",", "value", ")", ":", "\n", "    ", "if", "isinstance", "(", "expression", ",", "ApplicationExpression", ")", ":", "\n", "        ", "pols", "=", "polarity_application_expr", "(", "expression", ",", "value", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "AndExpression", ")", ":", "\n", "        ", "pols", "=", "polarity_and_expr", "(", "expression", ",", "value", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "OrExpression", ")", ":", "\n", "        ", "pols", "=", "polarity_or_expr", "(", "expression", ",", "value", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "ImpExpression", ")", ":", "\n", "        ", "pols", "=", "polarity_imp_expr", "(", "expression", ",", "value", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "NegatedExpression", ")", ":", "\n", "        ", "pols", "=", "polarity_not_expr", "(", "expression", ",", "value", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "ExistsExpression", ")", ":", "\n", "        ", "pols", "=", "polarity_exists_expr", "(", "expression", ",", "value", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "AllExpression", ")", ":", "\n", "        ", "pols", "=", "polarity_all_expr", "(", "expression", ",", "value", ")", "\n", "", "else", ":", "\n", "        ", "pols", "=", "[", "]", "\n", "", "return", "pols", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_application_expr": [[44, 48], ["expression.uncurry", "str"], "function", ["None"], ["", "def", "polarity_application_expr", "(", "expression", ",", "value", ")", ":", "\n", "    ", "fun", ",", "args", "=", "expression", ".", "uncurry", "(", ")", "\n", "res", "=", "[", "(", "str", "(", "fun", ")", ",", "value", ")", "]", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_and_expr": [[50, 55], ["nltk2pol.polarity_expr", "nltk2pol.polarity_expr"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_expr"], ["", "def", "polarity_and_expr", "(", "expression", ",", "value", ")", ":", "\n", "    ", "left", "=", "polarity_expr", "(", "expression", ".", "first", ",", "value", ")", "\n", "right", "=", "polarity_expr", "(", "expression", ".", "second", ",", "value", ")", "\n", "pols", "=", "left", "+", "right", "\n", "return", "pols", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_or_expr": [[57, 62], ["nltk2pol.polarity_expr", "nltk2pol.polarity_expr"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_expr"], ["", "def", "polarity_or_expr", "(", "expression", ",", "value", ")", ":", "\n", "    ", "left", "=", "polarity_expr", "(", "expression", ".", "first", ",", "value", ")", "\n", "right", "=", "polarity_expr", "(", "expression", ".", "second", ",", "value", ")", "\n", "pols", "=", "left", "+", "right", "\n", "return", "pols", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_imp_expr": [[64, 69], ["nltk2pol.polarity_expr", "nltk2pol.polarity_expr", "nltk2pol.rev_pol"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.rev_pol"], ["", "def", "polarity_imp_expr", "(", "expression", ",", "value", ")", ":", "\n", "    ", "left", "=", "polarity_expr", "(", "expression", ".", "first", ",", "rev_pol", "(", "value", ")", ")", "\n", "right", "=", "polarity_expr", "(", "expression", ".", "second", ",", "value", ")", "\n", "pols", "=", "left", "+", "right", "\n", "return", "pols", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_not_expr": [[71, 74], ["nltk2pol.polarity_expr", "nltk2pol.rev_pol"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.rev_pol"], ["", "def", "polarity_not_expr", "(", "expression", ",", "value", ")", ":", "\n", "    ", "pols", "=", "polarity_expr", "(", "expression", ".", "term", ",", "rev_pol", "(", "value", ")", ")", "\n", "return", "pols", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_exists_expr": [[76, 79], ["nltk2pol.polarity_expr"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_expr"], ["", "def", "polarity_exists_expr", "(", "expression", ",", "value", ")", ":", "\n", "    ", "pols", "=", "polarity_expr", "(", "expression", ".", "term", ",", "value", ")", "\n", "return", "pols", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_all_expr": [[81, 84], ["nltk2pol.polarity_expr"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.polarity_expr"], ["", "def", "polarity_all_expr", "(", "expression", ",", "value", ")", ":", "\n", "    ", "pols", "=", "polarity_expr", "(", "expression", ".", "term", ",", "value", ")", "\n", "return", "pols", "\n", "", ""]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.evaluate.compute_f": [[14, 27], ["round", "round", "ValueError", "round", "float", "float", "float", "float"], "function", ["None"], ["def", "compute_f", "(", "match_num", ",", "test_num", ",", "gold_num", ")", ":", "\n", "    ", "if", "test_num", "==", "0", "or", "gold_num", "==", "0", ":", "\n", "            ", "return", "0.00", ",", "0.00", ",", "0.00", "\n", "", "precision", "=", "round", "(", "float", "(", "match_num", ")", "/", "float", "(", "test_num", ")", ",", "2", ")", "\n", "recall", "=", "round", "(", "float", "(", "match_num", ")", "/", "float", "(", "gold_num", ")", ",", "2", ")", "\n", "if", "precision", "<", "0.0", "or", "precision", ">", "1.0", "or", "recall", "<", "0.0", "or", "recall", ">", "1.0", ":", "\n", "        ", "raise", "ValueError", "(", "\"Precision and recall should never be outside (0.0-1.0), now {0} and {1}\"", ".", "format", "(", "precision", ",", "recall", ")", ")", "\n", "\n", "", "if", "(", "precision", "+", "recall", ")", "!=", "0", ":", "\n", "        ", "f_score", "=", "round", "(", "2", "*", "precision", "*", "recall", "/", "(", "precision", "+", "recall", ")", ",", "2", ")", "\n", "return", "precision", ",", "recall", ",", "f_score", "\n", "", "else", ":", "\n", "        ", "return", "precision", ",", "recall", ",", "0.00", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.evaluate.form_tags": [[28, 39], ["enumerate", "fir.append", "fir.append", "sec.append", "tmp.replace", "tmp.replace", "tuple"], "function", ["None"], ["", "", "def", "form_tags", "(", "a", ")", ":", "\n", "    ", "fir", "=", "[", "]", "\n", "sec", "=", "[", "]", "\n", "for", "i", ",", "tmp", "in", "enumerate", "(", "a", ")", ":", "\n", "        ", "if", "i", "%", "2", "==", "0", ":", "\n", "            ", "fir", ".", "append", "(", "tmp", ".", "replace", "(", "' '", ",", "''", ")", ")", "\n", "", "else", ":", "\n", "            ", "fir", ".", "append", "(", "tmp", ".", "replace", "(", "' '", ",", "''", ")", ")", "\n", "sec", ".", "append", "(", "tuple", "(", "fir", ")", ")", "\n", "fir", "=", "[", "]", "\n", "", "", "return", "sec", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.evaluate.select_elem": [[40, 50], ["newtaga.append", "words.append", "newtagb.append"], "function", ["None"], ["", "def", "select_elem", "(", "taga", ",", "tagb", ",", "pol", "=", "\"1\"", ")", ":", "\n", "    ", "newtaga", ",", "newtagb", ",", "words", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "tmp", "in", "taga", ":", "\n", "        ", "if", "tmp", "[", "1", "]", "==", "pol", ":", "\n", "            ", "newtaga", ".", "append", "(", "tmp", ")", "\n", "words", ".", "append", "(", "tmp", "[", "0", "]", ")", "\n", "", "", "for", "tmp", "in", "tagb", ":", "\n", "        ", "if", "tmp", "[", "0", "]", "in", "words", ":", "\n", "            ", "newtagb", ".", "append", "(", "tmp", ")", "\n", "", "", "return", "newtaga", ",", "newtagb", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.evaluate.phenomena": [[51, 84], ["test.query", "test.query", "test.query", "test.query", "test.query", "test.query"], "function", ["None"], ["", "def", "phenomena", "(", "test", ",", "pheno", ")", ":", "\n", "    ", "if", "pheno", "==", "\"adj\"", ":", "\n", "        ", "return", "test", ".", "query", "(", "'phenomena_tags.str.contains(\"adjective:yes\") and \\\n                               phenomena_tags.str.contains(\"adverb:no\") and \\\n                               phenomena_tags.str.contains(\"conjunction:no\") and \\\n                               phenomena_tags.str.contains(\"disjunction:no\") and \\\n                               phenomena_tags.str.contains(\"negation:no\")'", ")", "\n", "", "elif", "pheno", "==", "\"adj_neg\"", ":", "\n", "        ", "return", "test", ".", "query", "(", "'phenomena_tags.str.contains(\"adjective:yes\") and \\\n                                   phenomena_tags.str.contains(\"adverb:no\") and \\\n                                   phenomena_tags.str.contains(\"conjunction:no\") and \\\n                                   phenomena_tags.str.contains(\"disjunction:no\") and \\\n                                   phenomena_tags.str.contains(\"negation:yes\")'", ")", "\n", "", "elif", "pheno", "==", "\"adv\"", ":", "\n", "        ", "return", "test", ".", "query", "(", "'phenomena_tags.str.contains(\"adjective:no\") and \\\n                               phenomena_tags.str.contains(\"adverb:yes\") and \\\n                               phenomena_tags.str.contains(\"conjunction:no\") and \\\n                               phenomena_tags.str.contains(\"disjunction:no\") and \\\n                               phenomena_tags.str.contains(\"negation:no\")'", ")", "\n", "", "elif", "pheno", "==", "\"adv_neg\"", ":", "\n", "        ", "return", "test", ".", "query", "(", "'phenomena_tags.str.contains(\"adjective:no\") and \\\n                                   phenomena_tags.str.contains(\"adverb:yes\") and \\\n                                   phenomena_tags.str.contains(\"conjunction:no\") and \\\n                                   phenomena_tags.str.contains(\"disjunction:no\") and \\\n                                   phenomena_tags.str.contains(\"negation:yes\")'", ")", "\n", "", "elif", "pheno", "==", "\"conj_disj\"", ":", "\n", "        ", "return", "test", ".", "query", "(", "'phenomena_tags.str.contains(\"adjective:no\") and \\\n                                phenomena_tags.str.contains(\"adverb:no\") and \\\n                                phenomena_tags.str.contains(\"negation:no\")'", ")", "\n", "", "elif", "pheno", "==", "\"conj_disj_neg\"", ":", "\n", "        ", "return", "test", ".", "query", "(", "'phenomena_tags.str.contains(\"adjective:no\") and \\\n                                    phenomena_tags.str.contains(\"adverb:no\") and \\\n                                    phenomena_tags.str.contains(\"negation:yes\")'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.evaluate.main": [[85, 175], ["glob.glob", "print", "print", "print", "print", "print", "pandas.read_csv", "tmp.query.query", "tmp.query.query", "tmp.query.query", "uniave.append", "exiave.append", "numave.append", "open", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "glob.glob", "range", "glob.glob", "print", "pandas.read_csv", "evaluate.phenomena", "totave.append", "open", "f.write", "f.write", "print", "print", "tsv.iterrows", "aveprec.append", "averec.append", "avef1.append", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "statistics.stdev", "statistics.stdev", "statistics.stdev", "print", "pandas.read_csv", "pd.read_csv.query", "totave.append", "re.sub().split", "evaluate.form_tags", "re.sub().split", "evaluate.form_tags", "evaluate.select_elem", "evaluate.compute_f", "tprec.append", "trec.append", "tf1.append", "len", "len", "len", "len", "len", "len", "len", "statistics.stdev", "len", "set", "set", "len", "len", "len", "sum", "sum", "sum", "sum", "len", "sum", "len", "sum", "len", "len", "len", "len", "len", "statistics.stdev", "re.sub", "re.sub", "sum", "len", "sum", "len", "sum", "len", "sum", "len", "sum", "len", "sum", "len", "sum", "len", "sum", "len", "sum", "len"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.deformation_tsv.phenomena", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.evaluate.form_tags", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.evaluate.form_tags", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.evaluate.select_elem", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.compute_f"], ["", "", "def", "main", "(", ")", ":", "\n", "    ", "tsvs", "=", "glob", ".", "glob", "(", "args", ".", "outdir", "+", "\"/prediction_eval[1-5].tsv\"", ")", "\n", "phenos", "=", "[", "\"adj\"", ",", "\"adj_neg\"", ",", "\"adv\"", ",", "\"adv_neg\"", ",", "\"conj_disj\"", ",", "\"conj_disj_neg\"", "]", "\n", "uniave", ",", "exiave", ",", "numave", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "pheno", "in", "phenos", ":", "\n", "        ", "print", "(", "f'phenomena: {pheno}'", ")", "\n", "totave", "=", "[", "]", "\n", "for", "tsv", "in", "tsvs", ":", "\n", "            ", "totacc", "=", "0", "\n", "tmptsv", "=", "pd", ".", "read_csv", "(", "tsv", ",", "sep", "=", "\"\\t\"", ")", "\n", "etsv", "=", "phenomena", "(", "tmptsv", ",", "pheno", ")", "\n", "if", "args", ".", "format", "==", "\"fol\"", "or", "args", ".", "format", "==", "\"free\"", "or", "args", ".", "format", "==", "\"clf\"", ":", "\n", "                ", "totacc", "=", "len", "(", "etsv", "[", "etsv", "[", "'sentence_fol_gold'", "]", "==", "etsv", "[", "'sentence_fol_pred'", "]", "]", ")", "/", "len", "(", "etsv", ")", "\n", "", "else", ":", "\n", "                ", "totacc", "=", "len", "(", "etsv", "[", "etsv", "[", "'sentence'", "]", "==", "etsv", "[", "'pred'", "]", "]", ")", "/", "len", "(", "etsv", ")", "\n", "", "totave", ".", "append", "(", "totacc", ")", "\n", "", "print", "(", "f'total ave: {sum(totave)/len(totave)*100:.1f}, stdev: {stdev(totave):.1f}'", ")", "\n", "with", "open", "(", "args", ".", "outdir", "+", "\"/pheno.txt\"", ",", "\"a\"", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "f'{sum(totave)/len(totave)*100:.1f}'", ")", "\n", "f", ".", "write", "(", "'\\n'", ")", "\n", "", "", "for", "tsv", "in", "tsvs", ":", "\n", "        ", "uniacc", ",", "exiacc", ",", "numacc", "=", "0", ",", "0", ",", "0", "\n", "etsv", "=", "pd", ".", "read_csv", "(", "tsv", ",", "sep", "=", "\"\\t\"", ")", "\n", "uni", "=", "etsv", ".", "query", "(", "'sentence.str.contains(\"every \") or sentence.str.startswith(\"all \") or sentence.str.contains(\" all \")'", ")", "\n", "exi", "=", "etsv", ".", "query", "(", "'sentence.str.contains(\"one \") or sentence.str.contains(\"a \")'", ")", "\n", "num", "=", "etsv", ".", "query", "(", "'sentence.str.contains(\"two \") or sentence.str.contains(\"three \")'", ")", "\n", "if", "args", ".", "format", "==", "\"fol\"", "or", "args", ".", "format", "==", "\"free\"", "or", "args", ".", "format", "==", "\"clf\"", ":", "\n", "            ", "uniacc", "=", "len", "(", "uni", "[", "uni", "[", "'sentence_fol_gold'", "]", "==", "uni", "[", "'sentence_fol_pred'", "]", "]", ")", "/", "len", "(", "uni", ")", "\n", "exiacc", "=", "len", "(", "exi", "[", "exi", "[", "'sentence_fol_gold'", "]", "==", "exi", "[", "'sentence_fol_pred'", "]", "]", ")", "/", "len", "(", "exi", ")", "\n", "numacc", "=", "len", "(", "num", "[", "num", "[", "'sentence_fol_gold'", "]", "==", "num", "[", "'sentence_fol_pred'", "]", "]", ")", "/", "len", "(", "num", ")", "\n", "", "else", ":", "\n", "            ", "uniacc", "=", "len", "(", "uni", "[", "uni", "[", "'sentence'", "]", "==", "uni", "[", "'pred'", "]", "]", ")", "/", "len", "(", "uni", ")", "\n", "exiacc", "=", "len", "(", "exi", "[", "exi", "[", "'sentence'", "]", "==", "exi", "[", "'pred'", "]", "]", ")", "/", "len", "(", "exi", ")", "\n", "numacc", "=", "len", "(", "num", "[", "num", "[", "'sentence'", "]", "==", "num", "[", "'pred'", "]", "]", ")", "/", "len", "(", "num", ")", "\n", "", "uniave", ".", "append", "(", "uniacc", ")", "\n", "exiave", ".", "append", "(", "exiacc", ")", "\n", "numave", ".", "append", "(", "numacc", ")", "\n", "", "print", "(", "f'existential ave: {sum(exiave)/len(exiave)*100:.1f}, stdev: {stdev(exiave):.1f}'", ")", "\n", "print", "(", "f'numeral ave: {sum(numave)/len(numave)*100:.1f}, stdev: {stdev(numave):.1f}'", ")", "\n", "print", "(", "f'universal ave: {sum(uniave)/len(uniave)*100:.1f}, stdev: {stdev(uniave):.1f}'", ")", "\n", "with", "open", "(", "args", ".", "outdir", "+", "\"/quant.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "f'{sum(exiave)/len(exiave)*100:.1f}'", ")", "\n", "f", ".", "write", "(", "'\\n'", ")", "\n", "f", ".", "write", "(", "f'{sum(numave)/len(numave)*100:.1f}'", ")", "\n", "f", ".", "write", "(", "'\\n'", ")", "\n", "f", ".", "write", "(", "f'{sum(uniave)/len(uniave)*100:.1f}'", ")", "\n", "f", ".", "write", "(", "'\\n'", ")", "\n", "\n", "\n", "", "if", "args", ".", "setting", "==", "\"depth\"", ":", "\n", "        ", "tsvs", "=", "glob", ".", "glob", "(", "outdir", "+", "\"/\"", "+", "setting", "+", "\"/prediction_eval[1-5].tsv\"", ")", "\n", "for", "i", "in", "range", "(", "2", ",", "5", ")", ":", "\n", "            ", "totave", "=", "[", "]", "\n", "print", "(", "i", ")", "\n", "for", "tsv", "in", "tsvs", ":", "\n", "                ", "print", "(", "tsv", ")", "\n", "tmp", "=", "pd", ".", "read_csv", "(", "tsv", ",", "sep", "=", "\"\\t\"", ")", "\n", "etsv", "=", "tmp", ".", "query", "(", "\"depth==@i\"", ")", "\n", "if", "args", ".", "format", "==", "\"fol\"", "or", "args", ".", "format", "==", "\"free\"", "or", "args", ".", "format", "==", "\"clf\"", ":", "\n", "                    ", "totacc", "=", "len", "(", "etsv", "[", "etsv", "[", "'sentence_fol_gold'", "]", "==", "etsv", "[", "'sentence_fol_pred'", "]", "]", ")", "/", "len", "(", "etsv", ")", "\n", "", "else", ":", "\n", "                    ", "totacc", "=", "len", "(", "etsv", "[", "etsv", "[", "'sentence'", "]", "==", "etsv", "[", "'pred'", "]", "]", ")", "/", "len", "(", "etsv", ")", "\n", "", "totave", ".", "append", "(", "totacc", ")", "\n", "", "print", "(", "f'total ave: {sum(totave)/len(totave)*100:.2f}, stdev: {stdev(totave):.2f}'", ")", "\n", "\n", "", "", "if", "setting", "==", "\"polarity\"", ":", "\n", "        ", "tsvs", "=", "glob", ".", "glob", "(", "outdir", "+", "\"/\"", "+", "setting", "+", "\"/prediction_eval[1-5]_polacc.tsv\"", ")", "\n", "aveprec", ",", "averec", ",", "avef1", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "tsv", "in", "tsvs", ":", "\n", "            ", "tprec", ",", "trec", ",", "tf1", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "idx", ",", "row", "in", "tsv", ".", "iterrows", "(", ")", ":", "\n", "                ", "a", "=", "re", ".", "sub", "(", "\"\\[|\\]|\\(|\\)|\\'\"", ",", "\"\"", ",", "row", "[", "'gold'", "]", ")", ".", "split", "(", "\",\"", ")", "\n", "taga", "=", "form_tags", "(", "a", ")", "\n", "b", "=", "re", ".", "sub", "(", "\"\\[|\\]|\\(|\\)|\\'\"", ",", "\"\"", ",", "row", "[", "'pred'", "]", ")", ".", "split", "(", "\",\"", ")", "\n", "tagb", "=", "form_tags", "(", "b", ")", "\n", "taga", ",", "tagb", "=", "select_elem", "(", "taga", ",", "tagb", ",", "\"0\"", ")", "\n", "if", "len", "(", "taga", ")", "==", "0", ":", "\n", "                    ", "continue", "\n", "", "pmatch", "=", "set", "(", "tagb", ")", "&", "set", "(", "taga", ")", "\n", "prec", ",", "rec", ",", "f1", "=", "compute_f", "(", "len", "(", "pmatch", ")", ",", "len", "(", "tagb", ")", ",", "len", "(", "taga", ")", ")", "\n", "tprec", ".", "append", "(", "prec", ")", "\n", "trec", ".", "append", "(", "rec", ")", "\n", "tf1", ".", "append", "(", "f1", ")", "\n", "", "aprec", "=", "sum", "(", "tprec", ")", "*", "100", "/", "len", "(", "tprec", ")", "\n", "arec", "=", "sum", "(", "trec", ")", "*", "100", "/", "len", "(", "trec", ")", "\n", "af1", "=", "sum", "(", "tf1", ")", "*", "100", "/", "len", "(", "tf1", ")", "\n", "aveprec", ".", "append", "(", "aprec", ")", "\n", "averec", ".", "append", "(", "arec", ")", "\n", "avef1", ".", "append", "(", "af1", ")", "\n", "", "print", "(", "f'{sum(aveprec)/len(aveprec)*100:.2f}, {sum(averec)/len(averec)*100:.2f}, {sum(avef1)/len(avef1)*100:.2f}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.deformation_tsv.extract_formula": [[17, 21], ["expr.lower.lower", "logic_parser.lexpr"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.logic_parser.lexpr"], ["def", "extract_formula", "(", "expr", ")", ":", "\n", "    ", "expr", "=", "expr", ".", "lower", "(", ")", "\n", "formula", "=", "lexpr", "(", "expr", ")", "\n", "return", "formula", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.deformation_tsv.compute_f": [[22, 35], ["round", "round", "ValueError", "round", "float", "float", "float", "float"], "function", ["None"], ["", "def", "compute_f", "(", "match_num", ",", "test_num", ",", "gold_num", ")", ":", "\n", "    ", "if", "test_num", "==", "0", "or", "gold_num", "==", "0", ":", "\n", "            ", "return", "0.00", ",", "0.00", ",", "0.00", "\n", "", "precision", "=", "round", "(", "float", "(", "match_num", ")", "/", "float", "(", "test_num", ")", ",", "2", ")", "\n", "recall", "=", "round", "(", "float", "(", "match_num", ")", "/", "float", "(", "gold_num", ")", ",", "2", ")", "\n", "if", "precision", "<", "0.0", "or", "precision", ">", "1.0", "or", "recall", "<", "0.0", "or", "recall", ">", "1.0", ":", "\n", "        ", "raise", "ValueError", "(", "\"Precision and recall should never be outside (0.0-1.0), now {0} and {1}\"", ".", "format", "(", "precision", ",", "recall", ")", ")", "\n", "\n", "", "if", "(", "precision", "+", "recall", ")", "!=", "0", ":", "\n", "        ", "f_score", "=", "round", "(", "2", "*", "precision", "*", "recall", "/", "(", "precision", "+", "recall", ")", ",", "2", ")", "\n", "return", "precision", ",", "recall", ",", "f_score", "\n", "", "else", ":", "\n", "        ", "return", "precision", ",", "recall", ",", "0.00", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.deformation_tsv.format_clf": [[36, 57], ["open", "open", "df.iterrows", "pp.write", "pg.write", "pp.write", "row[].split", "pg.write", "row[].split", "str", "str", "pp.write", "pp.write", "pg.write", "pg.write", "str", "str", "str", "str"], "function", ["None"], ["", "", "def", "format_clf", "(", "idx", ",", "genre", ",", "df", ",", "folder", ")", ":", "\n", "    ", "with", "open", "(", "folder", "+", "\"/pred_\"", "+", "str", "(", "idx", ")", "+", "\"_\"", "+", "str", "(", "genre", ")", "+", "\".clf\"", ",", "\"w\"", ")", "as", "pp", ",", "open", "(", "folder", "+", "\"/gold_\"", "+", "str", "(", "idx", ")", "+", "\"_\"", "+", "str", "(", "genre", ")", "+", "\".clf\"", ",", "\"w\"", ")", "as", "pg", ":", "\n", "        ", "for", "idx", ",", "row", "in", "df", ".", "iterrows", "(", ")", ":", "\n", "            ", "clauses", "=", "[", "]", ",", "\"\"", ",", "\"\"", "\n", "try", ":", "\n", "                ", "pp", ".", "write", "(", "\"%%% \"", "+", "row", "[", "\"phenomena_tags\"", "]", "+", "\" \"", "+", "row", "[", "\"sentence\"", "]", "+", "\" \"", "+", "row", "[", "\"sentence_fol_pred\"", "]", "+", "\"\\n\"", ")", "\n", "clauses", "=", "row", "[", "\"sentence_fol_pred\"", "]", ".", "split", "(", "\" [SEP] \"", ")", "\n", "for", "clause", "in", "clauses", ":", "\n", "                    ", "pp", ".", "write", "(", "clause", "+", "\"\\n\"", ")", "\n", "", "", "except", "Exception", "as", "error", ":", "\n", "                ", "pp", ".", "write", "(", "\"%%% \"", "+", "row", "[", "\"phenomena_tags\"", "]", "+", "\" \"", "+", "row", "[", "\"sentence\"", "]", "+", "\" \"", "+", "row", "[", "\"sentence_fol_pred\"", "]", "+", "\" Error: \"", "+", "str", "(", "error", ")", "+", "\"\\n\"", ")", "\n", "", "pp", ".", "write", "(", "\"\\n\"", ")", "\n", "clauses", ",", "formula", ",", "drs", "=", "[", "]", ",", "\"\"", ",", "\"\"", "\n", "try", ":", "\n", "                ", "pg", ".", "write", "(", "\"%%% \"", "+", "row", "[", "\"phenomena_tags\"", "]", "+", "\" \"", "+", "row", "[", "\"sentence\"", "]", "+", "\" \"", "+", "row", "[", "\"sentence_fol_gold\"", "]", "+", "\"\\n\"", ")", "\n", "clauses", "=", "row", "[", "\"sentence_fol_gold\"", "]", ".", "split", "(", "\" [SEP] \"", ")", "\n", "for", "clause", "in", "clauses", ":", "\n", "                    ", "pg", ".", "write", "(", "clause", "+", "\"\\n\"", ")", "\n", "", "", "except", "Exception", "as", "error", ":", "\n", "                ", "pg", ".", "write", "(", "\"%%% \"", "+", "row", "[", "\"phenomena_tags\"", "]", "+", "\" \"", "+", "row", "[", "\"sentence\"", "]", "+", "\" \"", "+", "row", "[", "\"sentence_fol_gold\"", "]", "+", "\" Error: \"", "+", "str", "(", "error", ")", "+", "\"\\n\"", ")", "\n", "", "pg", ".", "write", "(", "\"\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.deformation_tsv.phenomena": [[58, 91], ["test.query", "test.query", "test.query", "test.query", "test.query", "test.query"], "function", ["None"], ["", "", "", "def", "phenomena", "(", "test", ",", "pheno", ")", ":", "\n", "    ", "if", "pheno", "==", "\"adj\"", ":", "\n", "        ", "return", "test", ".", "query", "(", "'phenomena_tags.str.contains(\"adjective:yes\") and \\\n                               phenomena_tags.str.contains(\"adverb:no\") and \\\n                               phenomena_tags.str.contains(\"conjunction:no\") and \\\n                               phenomena_tags.str.contains(\"disjunction:no\") and \\\n                               phenomena_tags.str.contains(\"negation:no\")'", ")", "\n", "", "elif", "pheno", "==", "\"adj_neg\"", ":", "\n", "        ", "return", "test", ".", "query", "(", "'phenomena_tags.str.contains(\"adjective:yes\") and \\\n                                   phenomena_tags.str.contains(\"adverb:no\") and \\\n                                   phenomena_tags.str.contains(\"conjunction:no\") and \\\n                                   phenomena_tags.str.contains(\"disjunction:no\") and \\\n                                   phenomena_tags.str.contains(\"negation:yes\")'", ")", "\n", "", "elif", "pheno", "==", "\"adv\"", ":", "\n", "        ", "return", "test", ".", "query", "(", "'phenomena_tags.str.contains(\"adjective:no\") and \\\n                               phenomena_tags.str.contains(\"adverb:yes\") and \\\n                               phenomena_tags.str.contains(\"conjunction:no\") and \\\n                               phenomena_tags.str.contains(\"disjunction:no\") and \\\n                               phenomena_tags.str.contains(\"negation:no\")'", ")", "\n", "", "elif", "pheno", "==", "\"adv_neg\"", ":", "\n", "        ", "return", "test", ".", "query", "(", "'phenomena_tags.str.contains(\"adjective:no\") and \\\n                                   phenomena_tags.str.contains(\"adverb:yes\") and \\\n                                   phenomena_tags.str.contains(\"conjunction:no\") and \\\n                                   phenomena_tags.str.contains(\"disjunction:no\") and \\\n                                   phenomena_tags.str.contains(\"negation:yes\")'", ")", "\n", "", "elif", "pheno", "==", "\"conj_disj\"", ":", "\n", "        ", "return", "test", ".", "query", "(", "'phenomena_tags.str.contains(\"adjective:no\") and \\\n                                phenomena_tags.str.contains(\"adverb:no\") and \\\n                                phenomena_tags.str.contains(\"negation:no\")'", ")", "\n", "", "elif", "pheno", "==", "\"conj_disj_neg\"", ":", "\n", "        ", "return", "test", ".", "query", "(", "'phenomena_tags.str.contains(\"adjective:no\") and \\\n                                    phenomena_tags.str.contains(\"adverb:no\") and \\\n                                    phenomena_tags.str.contains(\"negation:yes\")'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.deformation_tsv.main": [[92, 205], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "pandas.read_csv", "re.sub", "range", "pandas.read_csv", "re.sub", "range", "pandas.read_csv", "re.sub", "pd.read_csv.copy", "range", "df.copy.to_csv", "glob.glob", "enumerate", "nltk2pol.calculate_polarity", "pgolds.append", "nltk2pol.calculate_polarity", "ppreds.append", "deformation_tsv.compute_f", "tprec.append", "trec.append", "tf1.append", "sum", "len", "sum", "len", "sum", "len", "open", "f.write", "zip", "f.write", "nltk2pol.calculate_polarity", "pgolds.append", "nltk2pol.calculate_polarity", "ppreds.append", "deformation_tsv.compute_f", "tprec.append", "trec.append", "tf1.append", "sum", "len", "sum", "len", "sum", "len", "open", "f.write", "zip", "f.write", "pandas.read_csv", "deformation_tsv.extract_formula", "deformation_tsv.extract_formula", "set", "set", "len", "len", "len", "df_ph.values.tolist", "f.write", "f.write", "deformation_tsv.extract_formula", "deformation_tsv.extract_formula", "set", "set", "len", "len", "len", "df_ph.values.tolist", "f.write", "f.write", "deformation_tsv.extract_formula", "nltk2tptp.convert_to_tptp", "deformation_tsv.extract_formula", "nltk2tptp.convert_to_tptp", "deformation_tsv.phenomena", "deformation_tsv.format_clf", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.calculate_polarity", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.calculate_polarity", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.compute_f", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.calculate_polarity", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.calculate_polarity", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.compute_f", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.deformation_tsv.extract_formula", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.deformation_tsv.extract_formula", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.deformation_tsv.extract_formula", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.deformation_tsv.extract_formula", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.deformation_tsv.extract_formula", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.deformation_tsv.extract_formula", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.deformation_tsv.phenomena", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.deformation_tsv.format_clf"], ["", "", "def", "main", "(", "args", "=", "None", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "''", ")", "\n", "parser", ".", "add_argument", "(", "\"-i\"", ",", "\"--input\"", ",", "type", "=", "str", ",", "nargs", "=", "\"?\"", ",", "help", "=", "\"Input tsv file\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-f\"", ",", "\"--format\"", ",", "type", "=", "str", ",", "default", "=", "\"drs\"", ",", "\n", "choices", "=", "[", "\"normal\"", ",", "\"plnormal\"", ",", "\"drs\"", ",", "\"drsbox\"", ",", "\"clf\"", ",", "\n", "\"coq\"", ",", "\"tptp\"", ",", "\"pol\"", ",", "\"pol_eval\"", ",", "\"clf_eval\"", "]", ",", "\n", "help", "=", "\"Output format (default: drs).\"", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "if", "args", ".", "format", "==", "\"pol_eval\"", ":", "\n", "        ", "df", "=", "pd", ".", "read_csv", "(", "args", ".", "input", ",", "sep", "=", "\"\\t\"", ")", "\n", "output", "=", "re", ".", "sub", "(", "\".tsv\"", ",", "\"_polacc.tsv\"", ",", "args", ".", "input", ")", "\n", "df_ps", "=", "df", ".", "sentence", "\n", "df_pg", "=", "df", ".", "sentence_fol_gold", "\n", "df_pp", "=", "df", ".", "sentence_fol_pred", "\n", "df_ph", "=", "df", ".", "phenomena_tags", "\n", "tprec", ",", "trec", ",", "tf1", ",", "pgolds", ",", "ppreds", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "idx", "in", "range", "(", "df", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "pol_pgold", ",", "pol_ppred", ",", "pgold", ",", "ppred", "=", "\"\"", ",", "\"\"", ",", "\"\"", ",", "\"\"", "\n", "try", ":", "\n", "                ", "pgold", "=", "extract_formula", "(", "str", "(", "df_pg", ".", "iloc", "[", "idx", "]", ")", ")", "\n", "", "except", ":", "\n", "                ", "pgold", "=", "\"\"", "\n", "", "pol_pgold", "=", "calculate_polarity", "(", "pgold", ")", "\n", "pgolds", ".", "append", "(", "pol_pgold", ")", "\n", "try", ":", "\n", "                ", "ppred", "=", "extract_formula", "(", "str", "(", "df_pp", ".", "iloc", "[", "idx", "]", ")", ")", "\n", "", "except", ":", "\n", "                ", "ppred", "=", "\"\"", "\n", "", "pol_ppred", "=", "calculate_polarity", "(", "ppred", ")", "\n", "ppreds", ".", "append", "(", "pol_ppred", ")", "\n", "pmatch", "=", "set", "(", "pol_ppred", ")", "&", "set", "(", "pol_pgold", ")", "\n", "prec", ",", "rec", ",", "f1", "=", "compute_f", "(", "len", "(", "pmatch", ")", ",", "len", "(", "pol_ppred", ")", ",", "len", "(", "pol_pgold", ")", ")", "\n", "tprec", ".", "append", "(", "prec", ")", "\n", "trec", ".", "append", "(", "rec", ")", "\n", "tf1", ".", "append", "(", "f1", ")", "\n", "", "aprec", "=", "sum", "(", "tprec", ")", "/", "len", "(", "tprec", ")", "\n", "arec", "=", "sum", "(", "trec", ")", "/", "len", "(", "trec", ")", "\n", "af1", "=", "sum", "(", "tf1", ")", "/", "len", "(", "tf1", ")", "\n", "with", "open", "(", "output", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "\"id\\tprec\\trec\\tf1\\tgold\\tpred\\tphenomena_tags\\n\"", ")", "\n", "idx", "=", "1", "\n", "for", "pr", ",", "tr", ",", "fs", ",", "pg", ",", "pp", ",", "ph", "in", "zip", "(", "tprec", ",", "trec", ",", "tf1", ",", "pgolds", ",", "ppreds", ",", "df_ph", ".", "values", ".", "tolist", "(", ")", ")", ":", "\n", "                ", "f", ".", "write", "(", "\"{0}\\t{1:.2f}\\t{2:.2f}\\t{3:.2f}\\t{4}\\t{5}\\t{6}\"", ".", "format", "(", "idx", ",", "pr", ",", "tr", ",", "fs", ",", "str", "(", "pg", ")", ",", "str", "(", "pp", ")", ",", "ph", ")", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "idx", "+=", "1", "\n", "", "f", ".", "write", "(", "\"average: {0:.2f}\\t{1:.2f}\\t{2:.2f}\"", ".", "format", "(", "aprec", ",", "arec", ",", "af1", ")", ")", "\n", "", "", "if", "args", ".", "format", "==", "\"pol_free_eval\"", ":", "\n", "        ", "df", "=", "pd", ".", "read_csv", "(", "args", ".", "input", ",", "sep", "=", "\"\\t\"", ")", "\n", "output", "=", "re", ".", "sub", "(", "\".tsv\"", ",", "\"_polacc.tsv\"", ",", "args", ".", "input", ")", "\n", "df_ps", "=", "df", ".", "sentence", "\n", "df_pg", "=", "df", ".", "sentence_fol_gold", "\n", "df_pp", "=", "df", ".", "sentence_fol_pred", "\n", "df_ph", "=", "df", ".", "phenomena_tags", "\n", "tprec", ",", "trec", ",", "tf1", ",", "pgolds", ",", "ppreds", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "idx", "in", "range", "(", "df", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "pol_pgold", ",", "pol_ppred", ",", "pgold", ",", "ppred", "=", "\"\"", ",", "\"\"", ",", "\"\"", ",", "\"\"", "\n", "try", ":", "\n", "                ", "pgold", "=", "extract_formula", "(", "str", "(", "df_pg", ".", "iloc", "[", "idx", "]", ")", ")", "\n", "", "except", ":", "\n", "                ", "pgold", "=", "\"\"", "\n", "", "pol_pgold", "=", "calculate_polarity", "(", "pgold", ")", "\n", "pgolds", ".", "append", "(", "pol_pgold", ")", "\n", "try", ":", "\n", "                ", "ppred", "=", "extract_formula", "(", "str", "(", "df_pp", ".", "iloc", "[", "idx", "]", ")", ")", "\n", "", "except", ":", "\n", "                ", "ppred", "=", "\"\"", "\n", "", "pol_ppred", "=", "calculate_polarity", "(", "ppred", ")", "\n", "ppreds", ".", "append", "(", "pol_ppred", ")", "\n", "pmatch", "=", "set", "(", "pol_ppred", ")", "&", "set", "(", "pol_pgold", ")", "\n", "prec", ",", "rec", ",", "f1", "=", "compute_f", "(", "len", "(", "pmatch", ")", ",", "len", "(", "pol_ppred", ")", ",", "len", "(", "pol_pgold", ")", ")", "\n", "tprec", ".", "append", "(", "prec", ")", "\n", "trec", ".", "append", "(", "rec", ")", "\n", "tf1", ".", "append", "(", "f1", ")", "\n", "", "aprec", "=", "sum", "(", "tprec", ")", "/", "len", "(", "tprec", ")", "\n", "arec", "=", "sum", "(", "trec", ")", "/", "len", "(", "trec", ")", "\n", "af1", "=", "sum", "(", "tf1", ")", "/", "len", "(", "tf1", ")", "\n", "with", "open", "(", "output", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "\"id\\tprec\\trec\\tf1\\tgold\\tpred\\tphenomena_tags\\n\"", ")", "\n", "idx", "=", "1", "\n", "for", "pr", ",", "tr", ",", "fs", ",", "pg", ",", "pp", ",", "ph", "in", "zip", "(", "tprec", ",", "trec", ",", "tf1", ",", "pgolds", ",", "ppreds", ",", "df_ph", ".", "values", ".", "tolist", "(", ")", ")", ":", "\n", "                ", "f", ".", "write", "(", "\"{0}\\t{1:.2f}\\t{2:.2f}\\t{3:.2f}\\t{4}\\t{5}\\t{6}\"", ".", "format", "(", "idx", ",", "pr", ",", "tr", ",", "fs", ",", "str", "(", "pg", ")", ",", "str", "(", "pp", ")", ",", "ph", ")", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "idx", "+=", "1", "\n", "", "f", ".", "write", "(", "\"average: {0:.2f}\\t{1:.2f}\\t{2:.2f}\"", ".", "format", "(", "aprec", ",", "arec", ",", "af1", ")", ")", "\n", "\n", "", "", "if", "args", ".", "format", "==", "\"tptp\"", ":", "\n", "        ", "df", "=", "pd", ".", "read_csv", "(", "args", ".", "input", ",", "sep", "=", "\"\\t\"", ")", "\n", "output", "=", "re", ".", "sub", "(", "\".tsv\"", ",", "\"_proof.tsv\"", ",", "args", ".", "input", ")", "\n", "df_ps", "=", "df", ".", "sentence_fol_gold", "\n", "df_hs", "=", "df", ".", "sentence_fol_pred", "\n", "new_df", "=", "df", ".", "copy", "(", ")", "\n", "for", "idx", "in", "range", "(", "df", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "formula", "=", "extract_formula", "(", "str", "(", "df_ps", ".", "iloc", "[", "idx", "]", ")", ")", "\n", "new_df", "[", "\"sentence_fol_gold\"", "]", "[", "idx", "]", "=", "convert_to_tptp", "(", "formula", ")", "\n", "formula", "=", "extract_formula", "(", "str", "(", "df_hs", ".", "iloc", "[", "idx", "]", ")", ")", "\n", "new_df", "[", "\"sentence_fol_pred\"", "]", "[", "idx", "]", "=", "convert_to_tptp", "(", "formula", ")", "\n", "", "except", ":", "\n", "                ", "new_df", "[", "\"sentence_fol_gold\"", "]", "[", "idx", "]", "=", "\"\"", "\n", "new_df", "[", "\"sentence_fol_pred\"", "]", "[", "idx", "]", "=", "\"\"", "\n", "", "", "new_df", ".", "to_csv", "(", "output", ",", "sep", "=", "\"\\t\"", ",", "index", "=", "False", ")", "\n", "\n", "", "if", "args", ".", "format", "==", "\"clf_eval\"", ":", "\n", "        ", "results", "=", "glob", ".", "glob", "(", "args", ".", "input", "+", "\"/prediction*eval[1-5].tsv\"", ")", "\n", "folder", "=", "args", ".", "input", "\n", "phenos", "=", "[", "\"adj\"", ",", "\"adj_neg\"", ",", "\"adv\"", ",", "\"adv_neg\"", ",", "\"conj_disj\"", ",", "\"conj_disj_neg\"", "]", "\n", "#phenos = [\"adj_neg\", \"adv_neg\", \"conj_disj_neg\"]", "\n", "for", "i", ",", "res", "in", "enumerate", "(", "results", ")", ":", "\n", "            ", "d", "=", "pd", ".", "read_csv", "(", "res", ",", "sep", "=", "\"\\t\"", ")", "\n", "for", "pheno", "in", "phenos", ":", "\n", "                ", "tsv", "=", "phenomena", "(", "d", ",", "pheno", ")", "\n", "format_clf", "(", "i", "+", "1", ",", "pheno", ",", "tsv", ",", "folder", ")", "\n", "# exi = d.query('sentence.str.contains(\"one \") or sentence.str.contains(\"a \")')", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.deformation_sp.conv_to_nltk": [[11, 18], ["nltk2normal.rename", "logic_parser.lexpr", "print", "expr.lower"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.rename", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.logic_parser.lexpr"], ["def", "conv_to_nltk", "(", "expr", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "formula", "=", "rename", "(", "lexpr", "(", "expr", ".", "lower", "(", ")", ")", ")", "\n", "", "except", "AttributeError", "as", "error", ":", "\n", "        ", "print", "(", "'{0}: {1}'", ".", "format", "(", "error", ",", "expr", ")", ")", "\n", "formula", "=", "\"\"", "\n", "", "return", "formula", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.deformation_sp.conv_to_clf": [[20, 29], ["nltk2drs.convert_to_drs", "drs2clf.convert_to_clausal_forms", "print"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_to_drs", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.drs2clf.convert_to_clausal_forms"], ["", "def", "conv_to_clf", "(", "formula", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "drs", "=", "convert_to_drs", "(", "formula", ")", "\n", "clauses", "=", "convert_to_clausal_forms", "(", "drs", ")", "\n", "clf", "=", "' [SEP] '", ".", "join", "(", "clauses", ")", "\n", "", "except", "AttributeError", "as", "error", ":", "\n", "        ", "print", "(", "'{0}: {1}'", ".", "format", "(", "error", ",", "formula", ")", ")", "\n", "formula", "=", "\"\"", "\n", "", "return", "clf", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.deformation_sp.assign_fol_pol": [[31, 38], ["nltk2pol.calculate_polarity", "print"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2pol.calculate_polarity"], ["", "def", "assign_fol_pol", "(", "formula", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "res", "=", "calculate_polarity", "(", "formula", ")", "\n", "", "except", "AttributeError", "as", "error", ":", "\n", "        ", "print", "(", "'{0}: {1}'", ".", "format", "(", "error", ",", "formula", ")", ")", "\n", "res", "=", "\"\"", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.deformation_sp.main": [[40, 59], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "pandas.read_csv", "pd.read_csv.insert", "tsv_file.replace", "pd.read_csv.to_csv", "deformation_sp.conv_to_nltk", "deformation_sp.conv_to_clf", "deformation_sp.assign_fol_pol"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.deformation_sp.conv_to_nltk", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.deformation_sp.conv_to_clf", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.deformation_sp.assign_fol_pol"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "''", ")", "\n", "parser", ".", "add_argument", "(", "'FILE'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "tsv_file", "=", "args", ".", "FILE", "\n", "df", "=", "pd", ".", "read_csv", "(", "tsv_file", ",", "sep", "=", "\"\\t\"", ")", "\n", "\n", "formulas", "=", "[", "conv_to_nltk", "(", "f", ")", "for", "f", "in", "df", "[", "'fol'", "]", "]", "\n", "df", "[", "'fol'", "]", "=", "formulas", "\n", "\n", "clfs", "=", "[", "conv_to_clf", "(", "f", ")", "for", "f", "in", "df", "[", "'fol'", "]", "]", "\n", "df", "[", "'drs'", "]", "=", "clfs", "\n", "\n", "pols", "=", "[", "assign_fol_pol", "(", "f", ")", "for", "f", "in", "df", "[", "'fol'", "]", "]", "\n", "df", ".", "insert", "(", "4", ",", "'folpol'", ",", "pols", ")", "\n", "\n", "fout", "=", "tsv_file", ".", "replace", "(", "'.tmp'", ",", "''", ")", "\n", "df", ".", "to_csv", "(", "fout", ",", "sep", "=", "\"\\t\"", ",", "index", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.visualize.atoi": [[15, 17], ["text.isdigit", "int"], "function", ["None"], ["def", "atoi", "(", "text", ")", ":", "\n", "    ", "return", "int", "(", "text", ")", "if", "text", ".", "isdigit", "(", ")", "else", "text", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.visualize.natural_keys": [[18, 20], ["visualize.atoi", "re.split"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.visualize.atoi"], ["", "def", "natural_keys", "(", "text", ")", ":", "\n", "    ", "return", "[", "atoi", "(", "c", ")", "for", "c", "in", "re", ".", "split", "(", "r'(\\d+)'", ",", "text", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.visualize.main": [[22, 110], ["glob.glob", "sorted", "matplotlib.figure", "matplotlib.title", "matplotlib.xlabel", "matplotlib.get_cmap", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "matplotlib.fill_between", "matplotlib.fill_between", "matplotlib.fill_between", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.savefig", "glob.glob", "sorted", "matplotlib.figure", "matplotlib.title", "matplotlib.xlabel", "matplotlib.get_cmap", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "matplotlib.fill_between", "matplotlib.fill_between", "matplotlib.fill_between", "matplotlib.fill_between", "matplotlib.fill_between", "matplotlib.fill_between", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.savefig", "re.search().group", "accs[].split", "accs[].split", "accs[].split", "uni_test_scores_mean.append", "uni_test_scores_std.append", "exi_test_scores_mean.append", "exi_test_scores_std.append", "num_test_scores_mean.append", "num_test_scores_std.append", "train_sizes.append", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "re.search().group", "adj_mean.append", "adj_std.append", "adjneg_mean.append", "adjneg_std.append", "adv_mean.append", "adv_std.append", "advneg_mean.append", "advneg_std.append", "conj_mean.append", "conj_std.append", "conjneg_mean.append", "conjneg_std.append", "train_sizes.append", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "open", "f.readlines", "float", "float", "float", "float", "float", "float", "int", "plt.get_cmap.", "plt.get_cmap.", "plt.get_cmap.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "plt.get_cmap.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "plt.get_cmap.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "plt.get_cmap.", "open", "f.readlines", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "int", "plt.get_cmap.", "plt.get_cmap.", "plt.get_cmap.", "plt.get_cmap.", "plt.get_cmap.", "plt.get_cmap.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "plt.get_cmap.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "plt.get_cmap.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "plt.get_cmap.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "plt.get_cmap.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "plt.get_cmap.", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "plt.get_cmap.", "re.search", "re.search", "float", "float", "float", "float", "float", "float", "accs[].split", "accs[].split", "accs[].split", "accs[].split", "accs[].split", "accs[].split", "accs[].split", "accs[].split", "accs[].split", "accs[].split", "accs[].split", "accs[].split", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float"], "function", ["None"], ["", "def", "main", "(", ")", ":", "\n", "    ", "train_sizes", "=", "[", "]", "\n", "exi_test_scores_mean", ",", "uni_test_scores_mean", ",", "num_test_scores_mean", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "exi_test_scores_std", ",", "uni_test_scores_std", ",", "num_test_scores_std", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "txts", "=", "glob", ".", "glob", "(", "args", ".", "outdir", "+", "\"/*/quant.txt\"", ")", "\n", "for", "txt", "in", "sorted", "(", "txts", ",", "key", "=", "natural_keys", ")", ":", "\n", "#print(txt)", "\n", "        ", "size", "=", "re", ".", "search", "(", "\"/([0-9]*)/quant.txt\"", ",", "txt", ")", ".", "group", "(", "1", ")", "\n", "with", "open", "(", "txt", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "accs", "=", "f", ".", "readlines", "(", ")", "\n", "", "uniscore", ",", "unistd", "=", "accs", "[", "2", "]", ".", "split", "(", "\"\\t\"", ")", "\n", "exiscore", ",", "existd", "=", "accs", "[", "0", "]", ".", "split", "(", "\"\\t\"", ")", "\n", "numscore", ",", "numstd", "=", "accs", "[", "1", "]", ".", "split", "(", "\"\\t\"", ")", "\n", "uni_test_scores_mean", ".", "append", "(", "float", "(", "uniscore", ")", ")", "\n", "uni_test_scores_std", ".", "append", "(", "float", "(", "unistd", ")", ")", "\n", "exi_test_scores_mean", ".", "append", "(", "float", "(", "exiscore", ")", ")", "\n", "exi_test_scores_std", ".", "append", "(", "float", "(", "existd", ")", ")", "\n", "num_test_scores_mean", ".", "append", "(", "float", "(", "numscore", ")", ")", "\n", "num_test_scores_std", ".", "append", "(", "float", "(", "numstd", ")", ")", "\n", "train_sizes", ".", "append", "(", "int", "(", "size", ")", ")", "\n", "\n", "", "plt", ".", "rcParams", "[", "\"font.size\"", "]", "=", "18", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "5.0", ",", "4.0", ")", ")", "\n", "plt", ".", "title", "(", "\"Quantifiers (Transformer)\"", ")", "\n", "plt", ".", "xlabel", "(", "\"Training examples\"", ")", "\n", "#plt.ylabel(\"Accuracy\")", "\n", "cmap2", "=", "plt", ".", "get_cmap", "(", "\"plasma\"", ")", "\n", "#plt.plot(train_sizes, train_scores_mean, 'o-', color=\"r\", label=\"Training score\")", "\n", "plt", ".", "plot", "(", "np", ".", "array", "(", "train_sizes", ")", ",", "np", ".", "array", "(", "exi_test_scores_mean", ")", ",", "'o-'", ",", "color", "=", "cmap2", "(", "float", "(", "1", ")", "/", "3", ")", ",", "label", "=", "\"Existential\"", ")", "\n", "plt", ".", "plot", "(", "np", ".", "array", "(", "train_sizes", ")", ",", "np", ".", "array", "(", "uni_test_scores_mean", ")", ",", "'o-'", ",", "color", "=", "cmap2", "(", "float", "(", "2", ")", "/", "3", ")", ",", "label", "=", "\"Universal\"", ")", "\n", "plt", ".", "plot", "(", "np", ".", "array", "(", "train_sizes", ")", ",", "np", ".", "array", "(", "num_test_scores_mean", ")", ",", "'o-'", ",", "color", "=", "cmap2", "(", "float", "(", "3", ")", "/", "3", ")", ",", "label", "=", "\"Numeral\"", ")", "\n", "#plt.fill_between(train_sizes, train_scores_mean - train_scores_std, train_scores_mean + train_scores_std, color=\"r\", alpha=0.2)", "\n", "plt", ".", "fill_between", "(", "np", ".", "array", "(", "train_sizes", ")", ",", "np", ".", "array", "(", "exi_test_scores_mean", ")", "-", "np", ".", "array", "(", "exi_test_scores_std", ")", ",", "np", ".", "array", "(", "exi_test_scores_mean", ")", "+", "np", ".", "array", "(", "exi_test_scores_std", ")", ",", "color", "=", "cmap2", "(", "float", "(", "1", ")", "/", "3", ")", ",", "alpha", "=", "0.2", ")", "\n", "plt", ".", "fill_between", "(", "np", ".", "array", "(", "train_sizes", ")", ",", "np", ".", "array", "(", "uni_test_scores_mean", ")", "-", "np", ".", "array", "(", "uni_test_scores_std", ")", ",", "np", ".", "array", "(", "uni_test_scores_mean", ")", "+", "np", ".", "array", "(", "uni_test_scores_std", ")", ",", "color", "=", "cmap2", "(", "float", "(", "2", ")", "/", "3", ")", ",", "alpha", "=", "0.2", ")", "\n", "plt", ".", "fill_between", "(", "np", ".", "array", "(", "train_sizes", ")", ",", "np", ".", "array", "(", "num_test_scores_mean", ")", "-", "np", ".", "array", "(", "num_test_scores_std", ")", ",", "np", ".", "array", "(", "num_test_scores_mean", ")", "+", "np", ".", "array", "(", "num_test_scores_std", ")", ",", "color", "=", "cmap2", "(", "float", "(", "3", ")", "/", "3", ")", ",", "alpha", "=", "0.2", ")", "\n", "\n", "plt", ".", "xlim", "(", "train_sizes", "[", "0", "]", ",", "train_sizes", "[", "-", "1", "]", ")", "\n", "plt", ".", "ylim", "(", "0", ",", "100", ")", "\n", "#plt.legend(loc=\"best\", markerscale=1, handlelength=0.7).get_frame().set_alpha(0.3)", "\n", "plt", ".", "savefig", "(", "args", ".", "outdir", "+", "'/lc_quant.png'", ",", "bbox_inches", "=", "'tight'", ",", "dpi", "=", "150", ")", "\n", "\n", "train_sizes", "=", "[", "]", "\n", "adj_mean", ",", "adjneg_mean", ",", "adv_mean", ",", "advneg_mean", ",", "conj_mean", ",", "conjneg_mean", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "adj_std", ",", "adjneg_std", ",", "adv_std", ",", "advneg_std", ",", "conj_std", ",", "conjneg_std", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "txts", "=", "glob", ".", "glob", "(", "args", ".", "outdir", "+", "\"/*/pheno.txt\"", ")", "\n", "for", "txt", "in", "sorted", "(", "txts", ",", "key", "=", "natural_keys", ")", ":", "\n", "#print(txt)", "\n", "        ", "size", "=", "re", ".", "search", "(", "\"/([0-9]*)/pheno.txt\"", ",", "txt", ")", ".", "group", "(", "1", ")", "\n", "with", "open", "(", "txt", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "accs", "=", "f", ".", "readlines", "(", ")", "\n", "\n", "", "adj_mean", ".", "append", "(", "float", "(", "accs", "[", "0", "]", ".", "split", "(", "\"\\t\"", ")", "[", "0", "]", ")", ")", "\n", "adj_std", ".", "append", "(", "float", "(", "accs", "[", "0", "]", ".", "split", "(", "\"\\t\"", ")", "[", "1", "]", ")", ")", "\n", "adjneg_mean", ".", "append", "(", "float", "(", "accs", "[", "1", "]", ".", "split", "(", "\"\\t\"", ")", "[", "0", "]", ")", ")", "\n", "adjneg_std", ".", "append", "(", "float", "(", "accs", "[", "1", "]", ".", "split", "(", "\"\\t\"", ")", "[", "1", "]", ")", ")", "\n", "adv_mean", ".", "append", "(", "float", "(", "accs", "[", "2", "]", ".", "split", "(", "\"\\t\"", ")", "[", "0", "]", ")", ")", "\n", "adv_std", ".", "append", "(", "float", "(", "accs", "[", "2", "]", ".", "split", "(", "\"\\t\"", ")", "[", "1", "]", ")", ")", "\n", "advneg_mean", ".", "append", "(", "float", "(", "accs", "[", "3", "]", ".", "split", "(", "\"\\t\"", ")", "[", "0", "]", ")", ")", "\n", "advneg_std", ".", "append", "(", "float", "(", "accs", "[", "3", "]", ".", "split", "(", "\"\\t\"", ")", "[", "1", "]", ")", ")", "\n", "conj_mean", ".", "append", "(", "float", "(", "accs", "[", "4", "]", ".", "split", "(", "\"\\t\"", ")", "[", "0", "]", ")", ")", "\n", "conj_std", ".", "append", "(", "float", "(", "accs", "[", "4", "]", ".", "split", "(", "\"\\t\"", ")", "[", "1", "]", ")", ")", "\n", "conjneg_mean", ".", "append", "(", "float", "(", "accs", "[", "5", "]", ".", "split", "(", "\"\\t\"", ")", "[", "0", "]", ")", ")", "\n", "conjneg_std", ".", "append", "(", "float", "(", "accs", "[", "5", "]", ".", "split", "(", "\"\\t\"", ")", "[", "1", "]", ")", ")", "\n", "train_sizes", ".", "append", "(", "int", "(", "size", ")", ")", "\n", "\n", "\n", "", "plt", ".", "figure", "(", "figsize", "=", "(", "5.0", ",", "4.0", ")", ")", "\n", "plt", ".", "title", "(", "\"Modifiers (Transformer)\"", ")", "\n", "plt", ".", "xlabel", "(", "\"Training examples\"", ")", "\n", "#plt.ylabel(\"Accuracy\")", "\n", "cmap", "=", "plt", ".", "get_cmap", "(", "\"viridis\"", ")", "\n", "plt", ".", "plot", "(", "np", ".", "array", "(", "train_sizes", ")", ",", "np", ".", "array", "(", "adj_mean", ")", ",", "'o-'", ",", "c", "=", "cmap", "(", "float", "(", "1", ")", "/", "6", ")", ",", "label", "=", "\"Adj\"", ")", "\n", "plt", ".", "plot", "(", "np", ".", "array", "(", "train_sizes", ")", ",", "np", ".", "array", "(", "adjneg_mean", ")", ",", "'o-'", ",", "c", "=", "cmap", "(", "float", "(", "2", ")", "/", "6", ")", ",", "label", "=", "\"Adj+Neg\"", ")", "\n", "plt", ".", "plot", "(", "np", ".", "array", "(", "train_sizes", ")", ",", "np", ".", "array", "(", "adv_mean", ")", ",", "'o-'", ",", "c", "=", "cmap", "(", "float", "(", "3", ")", "/", "6", ")", ",", "label", "=", "\"Adv\"", ")", "\n", "plt", ".", "plot", "(", "np", ".", "array", "(", "train_sizes", ")", ",", "np", ".", "array", "(", "advneg_mean", ")", ",", "'o-'", ",", "c", "=", "cmap", "(", "float", "(", "4", ")", "/", "6", ")", ",", "label", "=", "\"Adv+Neg\"", ")", "\n", "plt", ".", "plot", "(", "np", ".", "array", "(", "train_sizes", ")", ",", "np", ".", "array", "(", "conj_mean", ")", ",", "'o-'", ",", "c", "=", "cmap", "(", "float", "(", "5", ")", "/", "6", ")", ",", "label", "=", "\"Con\"", ")", "\n", "plt", ".", "plot", "(", "np", ".", "array", "(", "train_sizes", ")", ",", "np", ".", "array", "(", "conjneg_mean", ")", ",", "'o-'", ",", "c", "=", "cmap", "(", "float", "(", "6", ")", "/", "6", ")", ",", "label", "=", "\"Con+Neg\"", ")", "\n", "plt", ".", "fill_between", "(", "np", ".", "array", "(", "train_sizes", ")", ",", "np", ".", "array", "(", "adj_mean", ")", "-", "np", ".", "array", "(", "adj_std", ")", ",", "np", ".", "array", "(", "adj_mean", ")", "+", "np", ".", "array", "(", "adj_std", ")", ",", "color", "=", "cmap", "(", "float", "(", "1", ")", "/", "6", ")", ",", "alpha", "=", "0.2", ")", "\n", "plt", ".", "fill_between", "(", "np", ".", "array", "(", "train_sizes", ")", ",", "np", ".", "array", "(", "adjneg_mean", ")", "-", "np", ".", "array", "(", "adjneg_std", ")", ",", "np", ".", "array", "(", "adjneg_mean", ")", "+", "np", ".", "array", "(", "adjneg_std", ")", ",", "color", "=", "cmap", "(", "float", "(", "2", ")", "/", "6", ")", ",", "alpha", "=", "0.2", ")", "\n", "plt", ".", "fill_between", "(", "np", ".", "array", "(", "train_sizes", ")", ",", "np", ".", "array", "(", "adv_mean", ")", "-", "np", ".", "array", "(", "adv_std", ")", ",", "np", ".", "array", "(", "adv_mean", ")", "+", "np", ".", "array", "(", "adv_std", ")", ",", "color", "=", "cmap", "(", "float", "(", "3", ")", "/", "6", ")", ",", "alpha", "=", "0.2", ")", "\n", "plt", ".", "fill_between", "(", "np", ".", "array", "(", "train_sizes", ")", ",", "np", ".", "array", "(", "advneg_mean", ")", "-", "np", ".", "array", "(", "advneg_std", ")", ",", "np", ".", "array", "(", "advneg_mean", ")", "+", "np", ".", "array", "(", "advneg_std", ")", ",", "color", "=", "cmap", "(", "float", "(", "4", ")", "/", "6", ")", ",", "alpha", "=", "0.2", ")", "\n", "plt", ".", "fill_between", "(", "np", ".", "array", "(", "train_sizes", ")", ",", "np", ".", "array", "(", "conj_mean", ")", "-", "np", ".", "array", "(", "conj_std", ")", ",", "np", ".", "array", "(", "conj_mean", ")", "+", "np", ".", "array", "(", "conj_std", ")", ",", "color", "=", "cmap", "(", "float", "(", "5", ")", "/", "6", ")", ",", "alpha", "=", "0.2", ")", "\n", "plt", ".", "fill_between", "(", "np", ".", "array", "(", "train_sizes", ")", ",", "np", ".", "array", "(", "conjneg_mean", ")", "-", "np", ".", "array", "(", "conjneg_std", ")", ",", "np", ".", "array", "(", "conjneg_mean", ")", "+", "np", ".", "array", "(", "conjneg_std", ")", ",", "color", "=", "cmap", "(", "float", "(", "6", ")", "/", "6", ")", ",", "alpha", "=", "0.2", ")", "\n", "\n", "plt", ".", "xlim", "(", "train_sizes", "[", "0", "]", ",", "train_sizes", "[", "-", "1", "]", ")", "\n", "plt", ".", "ylim", "(", "0", ",", "100", ")", "\n", "#plt.legend(loc=\"best\", ncol=2, markerscale=1, handlelength=0.7).get_frame().set_alpha(0.3)", "\n", "plt", ".", "savefig", "(", "args", ".", "outdir", "+", "'/lc_pheno.png'", ",", "bbox_inches", "=", "'tight'", ",", "dpi", "=", "150", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.NCounter.reset": [[10, 13], ["None"], "methods", ["None"], ["    ", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_value", "=", "0", "\n", "return", "self", ".", "_value", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.get_atomic_formulas": [[35, 45], ["isinstance", "set", "isinstance", "set", "isinstance", "set", "expression.visit", "reduce", "set"], "function", ["None"], ["def", "get_atomic_formulas", "(", "expression", ")", ":", "\n", "    ", "if", "isinstance", "(", "expression", ",", "ApplicationExpression", ")", ":", "\n", "        ", "return", "set", "(", "[", "expression", "]", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "EqualityExpression", ")", ":", "\n", "        ", "return", "set", "(", "[", "expression", "]", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "AbstractVariableExpression", ")", ":", "\n", "        ", "return", "set", "(", "[", "expression", "]", ")", "\n", "", "else", ":", "\n", "        ", "return", "expression", ".", "visit", "(", "get_atomic_formulas", ",", "\n", "lambda", "parts", ":", "reduce", "(", "operator", ".", "or_", ",", "parts", ",", "set", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.get_role_formulas": [[46, 61], ["isinstance", "isinstance", "isinstance", "isinstance", "set", "set", "expression.visit", "set", "set", "reduce", "set"], "function", ["None"], ["", "", "def", "get_role_formulas", "(", "expression", ")", ":", "\n", "    ", "if", "isinstance", "(", "expression", ",", "EqualityExpression", ")", ":", "\n", "        ", "if", "isinstance", "(", "expression", ".", "first", ",", "ApplicationExpression", ")", ":", "\n", "            ", "variable", "=", "expression", ".", "first", ".", "argument", "\n", "if", "isinstance", "(", "variable", ",", "EventVariableExpression", ")", ":", "\n", "                ", "return", "set", "(", "[", "expression", "]", ")", "\n", "", "else", ":", "\n", "                ", "return", "set", "(", ")", "\n", "", "", "else", ":", "\n", "            ", "return", "set", "(", ")", "\n", "", "", "elif", "isinstance", "(", "expression", ",", "AbstractVariableExpression", ")", ":", "\n", "        ", "return", "set", "(", ")", "\n", "", "else", ":", "\n", "        ", "return", "expression", ".", "visit", "(", "get_role_formulas", ",", "\n", "lambda", "parts", ":", "reduce", "(", "operator", ".", "or_", ",", "parts", ",", "set", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.new_variable": [[62, 75], ["VariableExpression", "isinstance", "Variable", "isinstance", "isinstance", "_counter.get"], "function", ["None"], ["", "", "def", "new_variable", "(", "var", ")", ":", "\n", "    ", "var", "=", "VariableExpression", "(", "var", ")", "\n", "# isinstance(var,EventVariableExpression) must come first", "\n", "if", "isinstance", "(", "var", ",", "EventVariableExpression", ")", ":", "\n", "        ", "prefix", "=", "'x'", "\n", "", "elif", "isinstance", "(", "var", ",", "IndividualVariableExpression", ")", ":", "\n", "        ", "prefix", "=", "'x'", "\n", "", "elif", "isinstance", "(", "var", ",", "FunctionVariableExpression", ")", ":", "\n", "        ", "prefix", "=", "'F'", "\n", "", "else", ":", "\n", "        ", "prefix", "=", "'z'", "\n", "", "v", "=", "Variable", "(", "\"%s%s\"", "%", "(", "prefix", ",", "_counter", ".", "get", "(", ")", ")", ")", "\n", "return", "v", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true": [[78, 148], ["isinstance", "nltk2normal.remove_true", "nltk2normal.remove_true", "ApplicationExpression", "isinstance", "nltk2normal.remove_true", "nltk2normal.remove_true", "EqualityExpression", "isinstance", "str", "str", "isinstance", "nltk2normal.remove_true", "str", "str", "isinstance", "nltk2normal.remove_true", "nltk2normal.remove_true", "nltk2normal.remove_true", "AndExpression", "nltk2normal.remove_true", "str", "isinstance", "nltk2normal.remove_true", "nltk2normal.remove_true", "nltk2normal.remove_true", "OrExpression", "nltk2normal.remove_true", "nltk2normal.remove_true", "nltk2normal.remove_true", "ImpExpression", "nltk2normal.remove_true", "NegatedExpression", "isinstance", "nltk2normal.remove_true", "ExistsExpression", "isinstance", "nltk2normal.remove_true", "AllExpression", "isinstance", "nltk2normal.remove_true", "LambdaExpression"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true"], ["def", "remove_true", "(", "expression", ")", ":", "\n", "# Remove True and TrueP", "\n", "    ", "if", "isinstance", "(", "expression", ",", "ApplicationExpression", ")", ":", "\n", "        ", "function", "=", "remove_true", "(", "expression", ".", "function", ")", "\n", "argument", "=", "remove_true", "(", "expression", ".", "argument", ")", "\n", "expr", "=", "ApplicationExpression", "(", "function", ",", "argument", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "EqualityExpression", ")", ":", "\n", "        ", "left", "=", "remove_true", "(", "expression", ".", "first", ")", "\n", "right", "=", "remove_true", "(", "expression", ".", "second", ")", "\n", "expr", "=", "EqualityExpression", "(", "left", ",", "right", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "AndExpression", ")", ":", "\n", "# True & A <=> A & True <=> A", "\n", "        ", "left", "=", "expression", ".", "first", "\n", "right", "=", "expression", ".", "second", "\n", "left_str", "=", "str", "(", "left", ")", "\n", "right_str", "=", "str", "(", "right", ")", "\n", "if", "left_str", "in", "true_preds", ":", "\n", "            ", "expr", "=", "remove_true", "(", "right", ")", "\n", "", "elif", "right_str", "in", "true_preds", ":", "\n", "            ", "expr", "=", "remove_true", "(", "left", ")", "\n", "", "else", ":", "\n", "            ", "left", "=", "remove_true", "(", "left", ")", "\n", "right", "=", "remove_true", "(", "right", ")", "\n", "expr", "=", "AndExpression", "(", "left", ",", "right", ")", "\n", "", "", "elif", "isinstance", "(", "expression", ",", "OrExpression", ")", ":", "\n", "# True or A <=> A or True <=> True", "\n", "        ", "left", "=", "expression", ".", "first", "\n", "right", "=", "expression", ".", "second", "\n", "left_str", "=", "str", "(", "left", ")", "\n", "right_str", "=", "str", "(", "right", ")", "\n", "if", "left_str", "in", "true_preds", ":", "\n", "            ", "expr", "=", "remove_true", "(", "left", ")", "\n", "", "elif", "right_str", "in", "true_preds", ":", "\n", "            ", "expr", "=", "remove_true", "(", "right", ")", "\n", "", "else", ":", "\n", "            ", "left", "=", "remove_true", "(", "left", ")", "\n", "right", "=", "remove_true", "(", "right", ")", "\n", "expr", "=", "OrExpression", "(", "left", ",", "right", ")", "\n", "", "", "elif", "isinstance", "(", "expression", ",", "ImpExpression", ")", ":", "\n", "# True -> A <=> A", "\n", "        ", "left", "=", "expression", ".", "first", "\n", "right", "=", "expression", ".", "second", "\n", "left_str", "=", "str", "(", "left", ")", "\n", "if", "left_str", "in", "true_preds", ":", "\n", "            ", "expr", "=", "remove_true", "(", "right", ")", "\n", "", "else", ":", "\n", "            ", "left", "=", "remove_true", "(", "expression", ".", "first", ")", "\n", "right", "=", "remove_true", "(", "expression", ".", "second", ")", "\n", "expr", "=", "ImpExpression", "(", "left", ",", "right", ")", "\n", "", "", "elif", "isinstance", "(", "expression", ",", "NegatedExpression", ")", ":", "\n", "        ", "term", "=", "remove_true", "(", "expression", ".", "term", ")", "\n", "expr", "=", "NegatedExpression", "(", "term", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "ExistsExpression", ")", ":", "\n", "        ", "variable", "=", "expression", ".", "variable", "\n", "term", "=", "expression", ".", "term", "\n", "term", "=", "remove_true", "(", "term", ")", "\n", "expr", "=", "ExistsExpression", "(", "variable", ",", "term", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "AllExpression", ")", ":", "\n", "        ", "variable", "=", "expression", ".", "variable", "\n", "term", "=", "expression", ".", "term", "\n", "term", "=", "remove_true", "(", "term", ")", "\n", "expr", "=", "AllExpression", "(", "variable", ",", "term", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "LambdaExpression", ")", ":", "\n", "        ", "variable", "=", "expression", ".", "variable", "\n", "term", "=", "expression", ".", "term", "\n", "term", "=", "remove_true", "(", "term", ")", "\n", "expr", "=", "LambdaExpression", "(", "variable", ",", "term", ")", "\n", "", "else", ":", "\n", "        ", "expr", "=", "expression", "\n", "", "return", "expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true_": [[149, 236], ["isinstance", "nltk2normal.remove_true", "nltk2normal.remove_true", "ApplicationExpression", "isinstance", "nltk2normal.remove_true", "nltk2normal.remove_true", "EqualityExpression", "isinstance", "str", "str", "isinstance", "nltk2normal.remove_true", "str", "str", "isinstance", "nltk2normal.remove_true", "nltk2normal.remove_true", "nltk2normal.remove_true", "AndExpression", "nltk2normal.remove_true", "str", "isinstance", "nltk2normal.remove_true", "nltk2normal.remove_true", "nltk2normal.remove_true", "OrExpression", "nltk2normal.remove_true", "nltk2normal.remove_true", "nltk2normal.remove_true", "ImpExpression", "nltk2normal.remove_true", "NegatedExpression", "isinstance", "nltk2normal.new_variable", "VariableExpression", "remove_true.replace", "nltk2normal.remove_true", "ExistsExpression", "isinstance", "nltk2normal.new_variable", "VariableExpression", "remove_true.replace", "nltk2normal.remove_true", "AllExpression", "isinstance", "nltk2normal.new_variable", "VariableExpression", "remove_true.replace", "nltk2normal.remove_true", "LambdaExpression"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.new_variable", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.new_variable", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.new_variable", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true"], ["", "def", "remove_true_", "(", "expression", ")", ":", "\n", "# Remove True and TrueP", "\n", "    ", "if", "isinstance", "(", "expression", ",", "ApplicationExpression", ")", ":", "\n", "        ", "function", "=", "remove_true", "(", "expression", ".", "function", ")", "\n", "argument", "=", "remove_true", "(", "expression", ".", "argument", ")", "\n", "expr", "=", "ApplicationExpression", "(", "function", ",", "argument", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "EqualityExpression", ")", ":", "\n", "        ", "left", "=", "remove_true", "(", "expression", ".", "first", ")", "\n", "right", "=", "remove_true", "(", "expression", ".", "second", ")", "\n", "expr", "=", "EqualityExpression", "(", "left", ",", "right", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "AndExpression", ")", ":", "\n", "# True & A <=> A & True <=> A", "\n", "        ", "left", "=", "expression", ".", "first", "\n", "right", "=", "expression", ".", "second", "\n", "left_str", "=", "str", "(", "left", ")", "\n", "right_str", "=", "str", "(", "right", ")", "\n", "if", "left_str", "in", "true_preds", ":", "\n", "            ", "expr", "=", "remove_true", "(", "right", ")", "\n", "", "elif", "right_str", "in", "true_preds", ":", "\n", "            ", "expr", "=", "remove_true", "(", "left", ")", "\n", "", "else", ":", "\n", "            ", "left", "=", "remove_true", "(", "left", ")", "\n", "right", "=", "remove_true", "(", "right", ")", "\n", "expr", "=", "AndExpression", "(", "left", ",", "right", ")", "\n", "", "", "elif", "isinstance", "(", "expression", ",", "OrExpression", ")", ":", "\n", "# True or A <=> A or True <=> True", "\n", "        ", "left", "=", "expression", ".", "first", "\n", "right", "=", "expression", ".", "second", "\n", "left_str", "=", "str", "(", "left", ")", "\n", "right_str", "=", "str", "(", "right", ")", "\n", "if", "left_str", "in", "true_preds", ":", "\n", "            ", "expr", "=", "remove_true", "(", "left", ")", "\n", "", "elif", "right_str", "in", "true_preds", ":", "\n", "            ", "expr", "=", "remove_true", "(", "right", ")", "\n", "", "else", ":", "\n", "            ", "left", "=", "remove_true", "(", "left", ")", "\n", "right", "=", "remove_true", "(", "right", ")", "\n", "expr", "=", "OrExpression", "(", "left", ",", "right", ")", "\n", "", "", "elif", "isinstance", "(", "expression", ",", "ImpExpression", ")", ":", "\n", "# True -> A <=> A", "\n", "        ", "left", "=", "expression", ".", "first", "\n", "right", "=", "expression", ".", "second", "\n", "left_str", "=", "str", "(", "left", ")", "\n", "if", "left_str", "in", "true_preds", ":", "\n", "            ", "expr", "=", "remove_true", "(", "right", ")", "\n", "", "else", ":", "\n", "            ", "left", "=", "remove_true", "(", "expression", ".", "first", ")", "\n", "right", "=", "remove_true", "(", "expression", ".", "second", ")", "\n", "expr", "=", "ImpExpression", "(", "left", ",", "right", ")", "\n", "", "", "elif", "isinstance", "(", "expression", ",", "NegatedExpression", ")", ":", "\n", "        ", "term", "=", "remove_true", "(", "expression", ".", "term", ")", "\n", "expr", "=", "NegatedExpression", "(", "term", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "ExistsExpression", ")", ":", "\n", "        ", "variable", "=", "expression", ".", "variable", "\n", "term", "=", "expression", ".", "term", "\n", "newvar", "=", "new_variable", "(", "variable", ")", "\n", "newvar_expr", "=", "VariableExpression", "(", "newvar", ")", "\n", "term", "=", "term", ".", "replace", "(", "variable", ",", "newvar_expr", ")", "\n", "term", "=", "remove_true", "(", "term", ")", "\n", "expr", "=", "ExistsExpression", "(", "newvar", ",", "term", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "AllExpression", ")", ":", "\n", "        ", "variable", "=", "expression", ".", "variable", "\n", "term", "=", "expression", ".", "term", "\n", "newvar", "=", "new_variable", "(", "variable", ")", "\n", "newvar_expr", "=", "VariableExpression", "(", "newvar", ")", "\n", "term", "=", "term", ".", "replace", "(", "variable", ",", "newvar_expr", ")", "\n", "term", "=", "remove_true", "(", "term", ")", "\n", "expr", "=", "AllExpression", "(", "newvar", ",", "term", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "LambdaExpression", ")", ":", "\n", "        ", "variable", "=", "expression", ".", "variable", "\n", "term", "=", "expression", ".", "term", "\n", "newvar", "=", "new_variable", "(", "variable", ")", "\n", "newvar_expr", "=", "VariableExpression", "(", "newvar", ")", "\n", "term", "=", "term", ".", "replace", "(", "variable", ",", "newvar_expr", ")", "\n", "term", "=", "remove_true", "(", "term", ")", "\n", "expr", "=", "LambdaExpression", "(", "newvar", ",", "term", ")", "\n", "# elif isinstance(expression, IndividualVariableExpression):", "\n", "#     expr = expression", "\n", "# elif isinstance(expression, EventVariableExpression):", "\n", "#     expr = expression", "\n", "# elif isinstance(expression, FunctionVariableExpression):", "\n", "#     expr = expression", "\n", "# elif isinstance(expression, ConstantExpression):", "\n", "#     expr = expression", "\n", "", "else", ":", "\n", "        ", "expr", "=", "expression", "\n", "", "return", "expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.rename_variable": [[237, 298], ["isinstance", "nltk2normal.rename_variable", "nltk2normal.rename_variable", "ApplicationExpression", "isinstance", "nltk2normal.rename_variable", "nltk2normal.rename_variable", "EqualityExpression", "isinstance", "nltk2normal.rename_variable", "nltk2normal.rename_variable", "AndExpression", "isinstance", "nltk2normal.rename_variable", "nltk2normal.rename_variable", "OrExpression", "isinstance", "nltk2normal.rename_variable", "nltk2normal.rename_variable", "ImpExpression", "isinstance", "nltk2normal.rename_variable", "NegatedExpression", "isinstance", "nltk2normal.new_variable", "VariableExpression", "rename_variable.replace", "nltk2normal.rename_variable", "ExistsExpression", "isinstance", "nltk2normal.new_variable", "VariableExpression", "rename_variable.replace", "nltk2normal.rename_variable", "AllExpression", "isinstance", "nltk2normal.new_variable", "VariableExpression", "rename_variable.replace", "nltk2normal.rename_variable", "LambdaExpression"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.rename_variable", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.rename_variable", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.rename_variable", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.rename_variable", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.rename_variable", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.rename_variable", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.rename_variable", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.rename_variable", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.rename_variable", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.rename_variable", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.rename_variable", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.new_variable", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.rename_variable", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.new_variable", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.rename_variable", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.new_variable", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.rename_variable"], ["", "def", "rename_variable", "(", "expression", ")", ":", "\n", "# Rename bound variables so that no variable with the same name is bound", "\n", "# by two different quantifiers in different parts of a formula", "\n", "    ", "if", "isinstance", "(", "expression", ",", "ApplicationExpression", ")", ":", "\n", "        ", "function", "=", "rename_variable", "(", "expression", ".", "function", ")", "\n", "argument", "=", "rename_variable", "(", "expression", ".", "argument", ")", "\n", "expr", "=", "ApplicationExpression", "(", "function", ",", "argument", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "EqualityExpression", ")", ":", "\n", "        ", "left", "=", "rename_variable", "(", "expression", ".", "first", ")", "\n", "right", "=", "rename_variable", "(", "expression", ".", "second", ")", "\n", "expr", "=", "EqualityExpression", "(", "left", ",", "right", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "AndExpression", ")", ":", "\n", "        ", "left", "=", "rename_variable", "(", "expression", ".", "first", ")", "\n", "right", "=", "rename_variable", "(", "expression", ".", "second", ")", "\n", "expr", "=", "AndExpression", "(", "left", ",", "right", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "OrExpression", ")", ":", "\n", "        ", "left", "=", "rename_variable", "(", "expression", ".", "first", ")", "\n", "right", "=", "rename_variable", "(", "expression", ".", "second", ")", "\n", "expr", "=", "OrExpression", "(", "left", ",", "right", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "ImpExpression", ")", ":", "\n", "        ", "left", "=", "rename_variable", "(", "expression", ".", "first", ")", "\n", "right", "=", "rename_variable", "(", "expression", ".", "second", ")", "\n", "expr", "=", "ImpExpression", "(", "left", ",", "right", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "NegatedExpression", ")", ":", "\n", "        ", "term", "=", "rename_variable", "(", "expression", ".", "term", ")", "\n", "expr", "=", "NegatedExpression", "(", "term", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "ExistsExpression", ")", ":", "\n", "        ", "variable", "=", "expression", ".", "variable", "\n", "term", "=", "expression", ".", "term", "\n", "newvar", "=", "new_variable", "(", "variable", ")", "\n", "newvar_expr", "=", "VariableExpression", "(", "newvar", ")", "\n", "term", "=", "term", ".", "replace", "(", "variable", ",", "newvar_expr", ")", "\n", "term", "=", "rename_variable", "(", "term", ")", "\n", "expr", "=", "ExistsExpression", "(", "newvar", ",", "term", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "AllExpression", ")", ":", "\n", "        ", "variable", "=", "expression", ".", "variable", "\n", "term", "=", "expression", ".", "term", "\n", "newvar", "=", "new_variable", "(", "variable", ")", "\n", "newvar_expr", "=", "VariableExpression", "(", "newvar", ")", "\n", "term", "=", "term", ".", "replace", "(", "variable", ",", "newvar_expr", ")", "\n", "term", "=", "rename_variable", "(", "term", ")", "\n", "expr", "=", "AllExpression", "(", "newvar", ",", "term", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "LambdaExpression", ")", ":", "\n", "        ", "variable", "=", "expression", ".", "variable", "\n", "term", "=", "expression", ".", "term", "\n", "newvar", "=", "new_variable", "(", "variable", ")", "\n", "newvar_expr", "=", "VariableExpression", "(", "newvar", ")", "\n", "term", "=", "term", ".", "replace", "(", "variable", ",", "newvar_expr", ")", "\n", "term", "=", "rename_variable", "(", "term", ")", "\n", "expr", "=", "LambdaExpression", "(", "newvar", ",", "term", ")", "\n", "# elif isinstance(expression, IndividualVariableExpression):", "\n", "#     expr = expression", "\n", "# elif isinstance(expression, EventVariableExpression):", "\n", "#     expr = expression", "\n", "# elif isinstance(expression, FunctionVariableExpression):", "\n", "#     expr = expression", "\n", "# elif isinstance(expression, ConstantExpression):", "\n", "#     expr = expression", "\n", "", "else", ":", "\n", "        ", "expr", "=", "expression", "\n", "", "return", "expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.rename": [[299, 303], ["nltk2normal.rename_variable", "_counter.reset"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.rename_variable", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.NCounter.reset"], ["", "def", "rename", "(", "f", ")", ":", "\n", "    ", "res", "=", "rename_variable", "(", "f", ")", "\n", "_counter", ".", "reset", "(", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.convert_to_prenex": [[304, 310], ["nltk2normal.remove_true", "nltk2normal.rename_variable", "nltk2normal.prenex_expr"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.rename_variable", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_expr"], ["", "def", "convert_to_prenex", "(", "expression", ")", ":", "\n", "# Convert a formula to one where all existential quantifers come first.", "\n", "    ", "expression", "=", "remove_true", "(", "expression", ")", "\n", "expression", "=", "rename_variable", "(", "expression", ")", "\n", "prenex_form", "=", "prenex_expr", "(", "expression", ")", "\n", "return", "prenex_form", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_expr": [[311, 342], ["isinstance", "nltk2normal.prenex_application_expr", "isinstance", "nltk2normal.prenex_equality_expr", "isinstance", "nltk2normal.prenex_and_expr", "isinstance", "nltk2normal.prenex_or_expr", "isinstance", "nltk2normal.prenex_imp_expr", "isinstance", "nltk2normal.prenex_not_expr", "isinstance", "nltk2normal.prenex_exists_expr", "isinstance", "nltk2normal.prenex_all_expr", "isinstance", "nltk2normal.prenex_lambda_expr", "isinstance", "isinstance", "isinstance", "nltk2normal.normalize_symbols", "ConstantExpression", "Variable"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_application_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_equality_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_and_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_or_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_imp_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_not_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_exists_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_all_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_lambda_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.normalize_symbols"], ["", "def", "prenex_expr", "(", "expression", ")", ":", "\n", "    ", "if", "isinstance", "(", "expression", ",", "ApplicationExpression", ")", ":", "\n", "        ", "expr", "=", "prenex_application_expr", "(", "expression", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "EqualityExpression", ")", ":", "\n", "        ", "expr", "=", "prenex_equality_expr", "(", "expression", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "AndExpression", ")", ":", "\n", "        ", "expr", "=", "prenex_and_expr", "(", "expression", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "OrExpression", ")", ":", "\n", "        ", "expr", "=", "prenex_or_expr", "(", "expression", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "ImpExpression", ")", ":", "\n", "        ", "expr", "=", "prenex_imp_expr", "(", "expression", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "NegatedExpression", ")", ":", "\n", "        ", "expr", "=", "prenex_not_expr", "(", "expression", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "ExistsExpression", ")", ":", "\n", "        ", "expr", "=", "prenex_exists_expr", "(", "expression", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "AllExpression", ")", ":", "\n", "        ", "expr", "=", "prenex_all_expr", "(", "expression", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "LambdaExpression", ")", ":", "\n", "        ", "expr", "=", "prenex_lambda_expr", "(", "expression", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "IndividualVariableExpression", ")", ":", "\n", "        ", "expr", "=", "expression", "\n", "", "elif", "isinstance", "(", "expression", ",", "EventVariableExpression", ")", ":", "\n", "        ", "expr", "=", "expression", "\n", "", "elif", "isinstance", "(", "expression", ",", "ConstantExpression", ")", ":", "\n", "        ", "lexstr", "=", "normalize_symbols", "(", "'%s'", "%", "expression", ")", "\n", "expr", "=", "ConstantExpression", "(", "Variable", "(", "lexstr", ")", ")", "\n", "# elif isinstance(expression, Variable):", "\n", "#     expr = expression", "\n", "", "else", ":", "\n", "        ", "expr", "=", "expression", "\n", "", "return", "expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_application_expr": [[343, 348], ["nltk2normal.prenex_expr", "nltk2normal.prenex_expr", "ApplicationExpression"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_expr"], ["", "def", "prenex_application_expr", "(", "expression", ")", ":", "\n", "    ", "function", "=", "prenex_expr", "(", "expression", ".", "function", ")", "\n", "argument", "=", "prenex_expr", "(", "expression", ".", "argument", ")", "\n", "expr", "=", "ApplicationExpression", "(", "function", ",", "argument", ")", "\n", "return", "expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_equality_expr": [[349, 354], ["nltk2normal.prenex_expr", "nltk2normal.prenex_expr", "EqualityExpression"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_expr"], ["", "def", "prenex_equality_expr", "(", "expression", ")", ":", "\n", "    ", "left", "=", "prenex_expr", "(", "expression", ".", "first", ")", "\n", "right", "=", "prenex_expr", "(", "expression", ".", "second", ")", "\n", "expr", "=", "EqualityExpression", "(", "left", ",", "right", ")", "\n", "return", "expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_and_expr": [[355, 387], ["nltk2normal.prenex_expr", "nltk2normal.prenex_expr", "isinstance", "isinstance", "nltk2normal.prenex_expr", "ExistsExpression", "unique_variable", "VariableExpression", "left_term.replace.replace", "nltk2normal.prenex_expr", "ExistsExpression", "AndExpression", "prenex_expr.free", "AndExpression", "AndExpression", "nltk2normal.prenex_expr", "ExistsExpression", "unique_variable", "VariableExpression", "right_term.replace.replace", "nltk2normal.prenex_expr", "ExistsExpression", "prenex_expr.free", "AndExpression", "AndExpression"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_expr"], ["", "def", "prenex_and_expr", "(", "expression", ")", ":", "\n", "    ", "left", "=", "prenex_expr", "(", "expression", ".", "first", ")", "\n", "right", "=", "prenex_expr", "(", "expression", ".", "second", ")", "\n", "# [(exists x. L) & R] = exists x. [L & R]", "\n", "if", "isinstance", "(", "left", ",", "ExistsExpression", ")", ":", "\n", "        ", "left_variable", "=", "left", ".", "variable", "\n", "left_term", "=", "left", ".", "term", "\n", "if", "not", "left_variable", "in", "right", ".", "free", "(", ")", ":", "\n", "            ", "body", "=", "prenex_expr", "(", "AndExpression", "(", "left_term", ",", "right", ")", ")", "\n", "expr", "=", "ExistsExpression", "(", "left_variable", ",", "body", ")", "\n", "", "else", ":", "\n", "            ", "newvar", "=", "unique_variable", "(", ")", "\n", "var", "=", "VariableExpression", "(", "newvar", ")", "\n", "left_term", "=", "left_term", ".", "replace", "(", "left_variable", ",", "var", ")", "\n", "body", "=", "prenex_expr", "(", "AndExpression", "(", "left_term", ",", "right", ")", ")", "\n", "expr", "=", "ExistsExpression", "(", "newvar", ",", "body", ")", "\n", "# [L & (exists x. R)] = exists x. [L & R]", "\n", "", "", "elif", "isinstance", "(", "right", ",", "ExistsExpression", ")", ":", "\n", "        ", "right_variable", "=", "right", ".", "variable", "\n", "right_term", "=", "right", ".", "term", "\n", "if", "not", "right_variable", "in", "left", ".", "free", "(", ")", ":", "\n", "            ", "body", "=", "prenex_expr", "(", "AndExpression", "(", "left", ",", "right_term", ")", ")", "\n", "expr", "=", "ExistsExpression", "(", "right_variable", ",", "body", ")", "\n", "", "else", ":", "\n", "            ", "newvar", "=", "unique_variable", "(", ")", "\n", "var", "=", "VariableExpression", "(", "newvar", ")", "\n", "right_term", "=", "right_term", ".", "replace", "(", "right_variable", ",", "var", ")", "\n", "body", "=", "prenex_expr", "(", "AndExpression", "(", "left", ",", "right_term", ")", ")", "\n", "expr", "=", "ExistsExpression", "(", "newvar", ",", "body", ")", "\n", "", "", "else", ":", "\n", "        ", "expr", "=", "AndExpression", "(", "left", ",", "right", ")", "\n", "", "return", "expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_or_expr": [[388, 393], ["nltk2normal.prenex_expr", "nltk2normal.prenex_expr", "OrExpression"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_expr"], ["", "def", "prenex_or_expr", "(", "expression", ")", ":", "\n", "    ", "left", "=", "prenex_expr", "(", "expression", ".", "first", ")", "\n", "right", "=", "prenex_expr", "(", "expression", ".", "second", ")", "\n", "expr", "=", "OrExpression", "(", "left", ",", "right", ")", "\n", "return", "expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_imp_expr": [[394, 399], ["nltk2normal.prenex_expr", "nltk2normal.prenex_expr", "ImpExpression"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_expr", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_expr"], ["", "def", "prenex_imp_expr", "(", "expression", ")", ":", "\n", "    ", "left", "=", "prenex_expr", "(", "expression", ".", "first", ")", "\n", "right", "=", "prenex_expr", "(", "expression", ".", "second", ")", "\n", "expr", "=", "ImpExpression", "(", "left", ",", "right", ")", "\n", "return", "expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_not_expr": [[400, 404], ["nltk2normal.prenex_expr", "NegatedExpression"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_expr"], ["", "def", "prenex_not_expr", "(", "expression", ")", ":", "\n", "    ", "term", "=", "prenex_expr", "(", "expression", ".", "term", ")", "\n", "expr", "=", "NegatedExpression", "(", "term", ")", "\n", "return", "expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_exists_expr": [[405, 410], ["nltk2normal.prenex_expr", "ExistsExpression"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_expr"], ["", "def", "prenex_exists_expr", "(", "expression", ")", ":", "\n", "    ", "variable", "=", "expression", ".", "variable", "\n", "term", "=", "prenex_expr", "(", "expression", ".", "term", ")", "\n", "expr", "=", "ExistsExpression", "(", "variable", ",", "term", ")", "\n", "return", "expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_all_expr": [[411, 416], ["nltk2normal.prenex_expr", "AllExpression"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_expr"], ["", "def", "prenex_all_expr", "(", "expression", ")", ":", "\n", "    ", "variable", "=", "expression", ".", "variable", "\n", "term", "=", "prenex_expr", "(", "expression", ".", "term", ")", "\n", "expr", "=", "AllExpression", "(", "variable", ",", "term", ")", "\n", "return", "expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_lambda_expr": [[417, 422], ["nltk2normal.prenex_expr", "LambdaExpression"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.prenex_expr"], ["", "def", "prenex_lambda_expr", "(", "expression", ")", ":", "\n", "    ", "variable", "=", "expression", ".", "variable", "\n", "term", "=", "prenex_expr", "(", "expression", ".", "term", ")", "\n", "expr", "=", "LambdaExpression", "(", "variable", ",", "term", ")", "\n", "return", "expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.normalize_symbols": [[423, 430], ["unicodedata.normalize.replace().replace().replace().replace", "unicodedata.normalize", "unicodedata.normalize.replace().replace().replace", "unicodedata.normalize.replace().replace", "unicodedata.normalize.replace"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize"], ["", "def", "normalize_symbols", "(", "expression", ")", ":", "\n", "  ", "expression", "=", "expression", ".", "replace", "(", "\"\u2019\"", ",", "\"\"", ")", ".", "replace", "(", "\"_\"", ",", "\"\"", ")", ".", "replace", "(", "\"\uff08\"", ",", "\"BracketLeft\"", ")", ".", "replace", "(", "\"\uff09\"", ",", "\"BracketRight\"", ")", "\n", "expression", "=", "unicodedata", ".", "normalize", "(", "'NFKC'", ",", "expression", ")", "\n", "return", "expression", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.demo": [[518, 523], ["function", "print", "print"], "function", ["None"], ["def", "demo", "(", "function", ")", ":", "\n", "    ", "for", "formula", "in", "test", ":", "\n", "        ", "answer", "=", "function", "(", "formula", ")", "\n", "print", "(", "'Formula: {0}'", ".", "format", "(", "formula", ")", ")", "\n", "print", "(", "'Prediction: {0}\\n'", ".", "format", "(", "answer", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_to_drs": [[11, 16], ["nltk2normal.remove_true", "nltk2normal.rename", "nltk2drs.convert_drs", "DRS"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.remove_true", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2normal.rename", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs"], ["def", "convert_to_drs", "(", "expression", ")", ":", "\n", "    ", "expression", "=", "remove_true", "(", "expression", ")", "\n", "expression", "=", "rename", "(", "expression", ")", "\n", "drs_expr", "=", "convert_drs", "(", "DRS", "(", "[", "]", ",", "[", "]", ")", ",", "expression", ")", "\n", "return", "drs_expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs": [[17, 54], ["isinstance", "nltk2drs.convert_drs_application", "isinstance", "nltk2drs.convert_drs_equality", "isinstance", "nltk2drs.convert_drs_and", "isinstance", "nltk2drs.convert_drs_or", "isinstance", "nltk2drs.convert_drs_imp", "isinstance", "nltk2drs.convert_drs_not", "isinstance", "nltk2drs.convert_drs_exists", "isinstance", "nltk2drs.convert_drs_all", "isinstance", "nltk2drs.convert_drs_lambda", "isinstance", "str().lower", "DrtAbstractVariableExpression", "Variable", "Variable", "str"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs_application", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs_equality", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs_and", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs_or", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs_imp", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs_not", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs_exists", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs_all", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs_lambda"], ["", "def", "convert_drs", "(", "contextdrs", ",", "expression", ")", ":", "\n", "    ", "if", "isinstance", "(", "expression", ",", "ApplicationExpression", ")", ":", "\n", "        ", "drs_expr", "=", "convert_drs_application", "(", "contextdrs", ",", "expression", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "EqualityExpression", ")", ":", "\n", "        ", "drs_expr", "=", "convert_drs_equality", "(", "contextdrs", ",", "expression", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "AndExpression", ")", ":", "\n", "        ", "drs_expr", "=", "convert_drs_and", "(", "contextdrs", ",", "expression", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "OrExpression", ")", ":", "\n", "        ", "drs_expr", "=", "convert_drs_or", "(", "contextdrs", ",", "expression", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "ImpExpression", ")", ":", "\n", "        ", "drs_expr", "=", "convert_drs_imp", "(", "contextdrs", ",", "expression", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "NegatedExpression", ")", ":", "\n", "        ", "drs_expr", "=", "convert_drs_not", "(", "contextdrs", ",", "expression", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "ExistsExpression", ")", ":", "\n", "        ", "drs_expr", "=", "convert_drs_exists", "(", "contextdrs", ",", "expression", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "AllExpression", ")", ":", "\n", "        ", "drs_expr", "=", "convert_drs_all", "(", "contextdrs", ",", "expression", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "LambdaExpression", ")", ":", "\n", "        ", "drs_expr", "=", "convert_drs_lambda", "(", "contextdrs", ",", "expression", ")", "\n", "", "elif", "isinstance", "(", "expression", ",", "AbstractVariableExpression", ")", ":", "\n", "        ", "variable_str", "=", "str", "(", "expression", ".", "variable", ")", ".", "lower", "(", ")", "\n", "if", "variable_str", "[", "0", "]", "==", "'_'", ":", "\n", "            ", "variable", "=", "Variable", "(", "variable_str", "[", "1", ":", "]", ")", "\n", "", "else", ":", "\n", "            ", "variable", "=", "Variable", "(", "variable_str", ")", "\n", "", "drs_expr", "=", "DrtAbstractVariableExpression", "(", "variable", ")", "\n", "# elif isinstance(expression, IndividualVariableExpression):", "\n", "#     drs_expr = DrtIndividualVariableExpression(expression.variable)", "\n", "# elif isinstance(expression, EventVariableExpression):", "\n", "#     drs_expr = DrtEventVariableExpression(expression.variable)", "\n", "# elif isinstance(expression, FunctionVariableExpression):", "\n", "#     drs_expr = DrtFunctionVariableExpression(expression.variable)", "\n", "# elif isinstance(expression, ConstantExpression):", "\n", "#     drs_expr = DrtConstantExpression(expression.variable)", "\n", "", "else", ":", "\n", "        ", "drs_expr", "=", "expression", "\n", "", "return", "drs_expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs_application": [[58, 81], ["expression.uncurry", "nltk2drs.convert_drs", "DRS", "nltk2drs.convert_drs", "DrtApplicationExpression", "isinstance", "DRS", "DrtConstantExpression", "conditions.append", "DRS", "nltk2drs.convert_drs", "DrtApplicationExpression", "nltk2drs.convert_drs", "DrtApplicationExpression", "DRS", "DRS"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs"], ["def", "convert_drs_application", "(", "contextdrs", ",", "expression", ")", ":", "\n", "    ", "universe", "=", "contextdrs", ".", "refs", "\n", "conditions", "=", "contextdrs", ".", "conds", "\n", "function", ",", "args", "=", "expression", ".", "uncurry", "(", ")", "\n", "function", "=", "convert_drs", "(", "DRS", "(", "[", "]", ",", "[", "]", ")", ",", "function", ")", "\n", "# functional terms do not form DRSs", "\n", "if", "function", "in", "fterms", ":", "\n", "        ", "argument", "=", "convert_drs", "(", "DRS", "(", "[", "]", ",", "[", "]", ")", ",", "expression", ".", "argument", ")", "\n", "drs_expr", "=", "DrtApplicationExpression", "(", "function", ",", "argument", ")", "\n", "", "elif", "isinstance", "(", "function", ",", "DrtLambdaExpression", ")", ":", "\n", "        ", "expr", "=", "function", "\n", "for", "arg", "in", "args", ":", "\n", "            ", "argument", "=", "convert_drs", "(", "DRS", "(", "[", "]", ",", "[", "]", ")", ",", "arg", ")", "\n", "expr", "=", "DrtApplicationExpression", "(", "expr", ",", "argument", ")", "\n", "", "drs_expr", "=", "expr", "\n", "", "else", ":", "\n", "        ", "expr", "=", "DrtConstantExpression", "(", "function", ".", "variable", ")", "\n", "for", "arg", "in", "args", ":", "\n", "            ", "argument", "=", "convert_drs", "(", "DRS", "(", "[", "]", ",", "[", "]", ")", ",", "arg", ")", "\n", "expr", "=", "DrtApplicationExpression", "(", "expr", ",", "argument", ")", "\n", "", "conditions", ".", "append", "(", "expr", ")", "\n", "drs_expr", "=", "DRS", "(", "universe", ",", "conditions", ")", "\n", "", "return", "drs_expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs_equality": [[82, 91], ["nltk2drs.convert_drs", "nltk2drs.convert_drs", "DrtEqualityExpression", "conditions.append", "DRS", "DRS", "DRS"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs"], ["", "def", "convert_drs_equality", "(", "contextdrs", ",", "expression", ")", ":", "\n", "    ", "universe", "=", "contextdrs", ".", "refs", "\n", "conditions", "=", "contextdrs", ".", "conds", "\n", "first", "=", "convert_drs", "(", "DRS", "(", "[", "]", ",", "[", "]", ")", ",", "expression", ".", "first", ")", "\n", "second", "=", "convert_drs", "(", "DRS", "(", "[", "]", ",", "[", "]", ")", ",", "expression", ".", "second", ")", "\n", "expr", "=", "DrtEqualityExpression", "(", "first", ",", "second", ")", "\n", "conditions", ".", "append", "(", "expr", ")", "\n", "drs_expr", "=", "DRS", "(", "universe", ",", "conditions", ")", "\n", "return", "drs_expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs_and": [[92, 96], ["nltk2drs.convert_drs", "nltk2drs.convert_drs"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs"], ["", "def", "convert_drs_and", "(", "contextdrs", ",", "expression", ")", ":", "\n", "    ", "first", "=", "convert_drs", "(", "contextdrs", ",", "expression", ".", "first", ")", "\n", "drs_expr", "=", "convert_drs", "(", "first", ",", "expression", ".", "second", ")", "\n", "return", "drs_expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs_or": [[97, 106], ["nltk2drs.convert_drs", "nltk2drs.convert_drs", "DrtOrExpression", "conditions.append", "DRS", "DRS", "DRS"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs"], ["", "def", "convert_drs_or", "(", "contextdrs", ",", "expression", ")", ":", "\n", "    ", "universe", "=", "contextdrs", ".", "refs", "\n", "conditions", "=", "contextdrs", ".", "conds", "\n", "first", "=", "convert_drs", "(", "DRS", "(", "[", "]", ",", "[", "]", ")", ",", "expression", ".", "first", ")", "\n", "second", "=", "convert_drs", "(", "DRS", "(", "[", "]", ",", "[", "]", ")", ",", "expression", ".", "second", ")", "\n", "expr", "=", "DrtOrExpression", "(", "first", ",", "second", ")", "\n", "conditions", ".", "append", "(", "expr", ")", "\n", "drs_expr", "=", "DRS", "(", "universe", ",", "conditions", ")", "\n", "return", "drs_expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs_imp": [[107, 116], ["nltk2drs.convert_drs", "nltk2drs.convert_drs", "DRS", "conditions.append", "DRS", "DRS", "DRS"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs"], ["", "def", "convert_drs_imp", "(", "contextdrs", ",", "expression", ")", ":", "\n", "    ", "universe", "=", "contextdrs", ".", "refs", "\n", "conditions", "=", "contextdrs", ".", "conds", "\n", "first", "=", "convert_drs", "(", "DRS", "(", "[", "]", ",", "[", "]", ")", ",", "expression", ".", "first", ")", "\n", "second", "=", "convert_drs", "(", "DRS", "(", "[", "]", ",", "[", "]", ")", ",", "expression", ".", "second", ")", "\n", "expr", "=", "DRS", "(", "first", ".", "refs", ",", "first", ".", "conds", ",", "second", ")", "\n", "conditions", ".", "append", "(", "expr", ")", "\n", "drs_expr", "=", "DRS", "(", "universe", ",", "conditions", ")", "\n", "return", "drs_expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs_not": [[117, 125], ["nltk2drs.convert_drs", "DrtNegatedExpression", "conditions.append", "DRS", "DRS"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs"], ["", "def", "convert_drs_not", "(", "contextdrs", ",", "expression", ")", ":", "\n", "    ", "universe", "=", "contextdrs", ".", "refs", "\n", "conditions", "=", "contextdrs", ".", "conds", "\n", "term", "=", "convert_drs", "(", "DRS", "(", "[", "]", ",", "[", "]", ")", ",", "expression", ".", "term", ")", "\n", "expr", "=", "DrtNegatedExpression", "(", "term", ")", "\n", "conditions", ".", "append", "(", "expr", ")", "\n", "drs_expr", "=", "DRS", "(", "universe", ",", "conditions", ")", "\n", "return", "drs_expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs_exists": [[126, 134], ["universe.append", "DRS", "nltk2drs.convert_drs"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs"], ["", "def", "convert_drs_exists", "(", "contextdrs", ",", "expression", ")", ":", "\n", "    ", "universe", "=", "contextdrs", ".", "refs", "\n", "conditions", "=", "contextdrs", ".", "conds", "\n", "variable", "=", "expression", ".", "variable", "\n", "universe", ".", "append", "(", "variable", ")", "\n", "contextdrs", "=", "DRS", "(", "universe", ",", "conditions", ")", "\n", "drs_expr", "=", "convert_drs", "(", "contextdrs", ",", "expression", ".", "term", ")", "\n", "return", "drs_expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs_all": [[135, 155], ["isinstance", "DRS", "nltk2drs.convert_drs", "nltk2drs.convert_drs", "DRS", "conditions.append", "DRS", "nltk2drs.convert_drs", "DRS", "conditions.append", "DRS", "DRS", "DRS"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs"], ["", "def", "convert_drs_all", "(", "contextdrs", ",", "expression", ")", ":", "\n", "    ", "universe", "=", "contextdrs", ".", "refs", "\n", "conditions", "=", "contextdrs", ".", "conds", "\n", "variable", "=", "expression", ".", "variable", "\n", "body", "=", "expression", ".", "term", "\n", "if", "isinstance", "(", "body", ",", "ImpExpression", ")", ":", "\n", "        ", "antecedent", "=", "body", ".", "first", "\n", "consequent", "=", "body", ".", "second", "\n", "context", "=", "DRS", "(", "[", "variable", "]", ",", "[", "]", ")", "\n", "antecedent_drs", "=", "convert_drs", "(", "context", ",", "antecedent", ")", "\n", "consequent_drs", "=", "convert_drs", "(", "DRS", "(", "[", "]", ",", "[", "]", ")", ",", "consequent", ")", "\n", "expr", "=", "DRS", "(", "antecedent_drs", ".", "refs", ",", "antecedent_drs", ".", "conds", ",", "consequent_drs", ")", "\n", "conditions", ".", "append", "(", "expr", ")", "\n", "drs_expr", "=", "DRS", "(", "universe", ",", "conditions", ")", "\n", "", "else", ":", "\n", "        ", "consequent_drs", "=", "convert_drs", "(", "DRS", "(", "[", "]", ",", "[", "]", ")", ",", "body", ")", "\n", "expr", "=", "DRS", "(", "[", "variable", "]", ",", "[", "]", ",", "consequent_drs", ")", "\n", "conditions", ".", "append", "(", "expr", ")", "\n", "drs_expr", "=", "DRS", "(", "universe", ",", "conditions", ")", "\n", "", "return", "drs_expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs_lambda": [[156, 162], ["nltk2drs.convert_drs", "DrtLambdaExpression", "DRS"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_drs"], ["", "def", "convert_drs_lambda", "(", "contextdrs", ",", "expression", ")", ":", "\n", "    ", "variable", "=", "expression", ".", "variable", "\n", "term", "=", "expression", ".", "term", "\n", "term", "=", "convert_drs", "(", "DRS", "(", "[", "]", ",", "[", "]", ")", ",", "term", ")", "\n", "drs_expr", "=", "DrtLambdaExpression", "(", "variable", ",", "term", ")", "\n", "return", "drs_expr", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.main": [[163, 170], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "nltk2drs.convert_to_drs", "print", "logic_parser.lexpr", "str"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.nltk2drs.convert_to_drs", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.logic_parser.lexpr"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "formatter_class", "=", "argparse", ".", "RawDescriptionHelpFormatter", ")", "\n", "parser", ".", "add_argument", "(", "\"formula\"", ",", "help", "=", "\"FOL formula (nltk format)\"", ")", "\n", "ARGS", "=", "parser", ".", "parse_args", "(", ")", "\n", "results", "=", "convert_to_drs", "(", "lexpr", "(", "ARGS", ".", "formula", ")", ")", "\n", "print", "(", "str", "(", "results", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.Encoder.__init__": [[103, 124], ["torch.Module.__init__", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt().to", "seq2fol_transformer.EncoderLayer", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "range", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.DRS_match.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "input_dim", ",", "\n", "hid_dim", ",", "\n", "n_layers", ",", "\n", "n_heads", ",", "\n", "pf_dim", ",", "\n", "dropout", ",", "\n", "device", ",", "\n", "max_length", "=", "MAX_LENGTH", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "tok_embedding", "=", "nn", ".", "Embedding", "(", "input_dim", ",", "hid_dim", ")", "\n", "self", ".", "pos_embedding", "=", "nn", ".", "Embedding", "(", "max_length", ",", "hid_dim", ")", "\n", "self", ".", "layers", "=", "nn", ".", "ModuleList", "(", "[", "EncoderLayer", "(", "hid_dim", ",", "\n", "n_heads", ",", "\n", "pf_dim", ",", "\n", "dropout", ",", "\n", "device", ")", "\n", "for", "_", "in", "range", "(", "n_layers", ")", "]", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "scale", "=", "torch", ".", "sqrt", "(", "torch", ".", "FloatTensor", "(", "[", "hid_dim", "]", ")", ")", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.Encoder.forward": [[125, 133], ["torch.arange().unsqueeze().repeat().to", "torch.arange().unsqueeze().repeat().to", "torch.arange().unsqueeze().repeat().to", "torch.arange().unsqueeze().repeat().to", "torch.arange().unsqueeze().repeat().to", "torch.arange().unsqueeze().repeat().to", "torch.arange().unsqueeze().repeat().to", "torch.arange().unsqueeze().repeat().to", "torch.arange().unsqueeze().repeat().to", "seq2fol_transformer.Encoder.dropout", "layer", "torch.arange().unsqueeze().repeat", "torch.arange().unsqueeze().repeat", "torch.arange().unsqueeze().repeat", "torch.arange().unsqueeze().repeat", "torch.arange().unsqueeze().repeat", "torch.arange().unsqueeze().repeat", "torch.arange().unsqueeze().repeat", "torch.arange().unsqueeze().repeat", "torch.arange().unsqueeze().repeat", "seq2fol_transformer.Encoder.pos_embedding", "seq2fol_transformer.Encoder.tok_embedding", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "src", ",", "src_mask", ")", ":", "\n", "        ", "batch_size", "=", "src", ".", "shape", "[", "0", "]", "\n", "src_len", "=", "src", ".", "shape", "[", "1", "]", "\n", "pos", "=", "torch", ".", "arange", "(", "0", ",", "src_len", ")", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "batch_size", ",", "1", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "src", "=", "self", ".", "dropout", "(", "(", "self", ".", "tok_embedding", "(", "src", ")", "*", "self", ".", "scale", ")", "+", "self", ".", "pos_embedding", "(", "pos", ")", ")", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "src", "=", "layer", "(", "src", ",", "src_mask", ")", "\n", "", "return", "src", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.EncoderLayer.__init__": [[135, 150], ["torch.Module.__init__", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "seq2fol_transformer.MultiHeadAttentionLayer", "seq2fol_transformer.PositionwiseFeedforwardLayer", "torch.Dropout", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.DRS_match.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "hid_dim", ",", "\n", "n_heads", ",", "\n", "pf_dim", ",", "\n", "dropout", ",", "\n", "device", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "self_attn_layer_norm", "=", "nn", ".", "LayerNorm", "(", "hid_dim", ")", "\n", "self", ".", "ff_layer_norm", "=", "nn", ".", "LayerNorm", "(", "hid_dim", ")", "\n", "self", ".", "self_attention", "=", "MultiHeadAttentionLayer", "(", "hid_dim", ",", "n_heads", ",", "dropout", ",", "device", ")", "\n", "self", ".", "positionwise_feedforward", "=", "PositionwiseFeedforwardLayer", "(", "hid_dim", ",", "\n", "pf_dim", ",", "\n", "dropout", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.EncoderLayer.forward": [[151, 158], ["seq2fol_transformer.EncoderLayer.self_attention", "seq2fol_transformer.EncoderLayer.self_attn_layer_norm", "seq2fol_transformer.EncoderLayer.positionwise_feedforward", "seq2fol_transformer.EncoderLayer.ff_layer_norm", "seq2fol_transformer.EncoderLayer.dropout", "seq2fol_transformer.EncoderLayer.dropout"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "src", ",", "src_mask", ")", ":", "\n", "        ", "_src", ",", "_", "=", "self", ".", "self_attention", "(", "src", ",", "src", ",", "src", ",", "src_mask", ")", "\n", "src", "=", "self", ".", "self_attn_layer_norm", "(", "src", "+", "self", ".", "dropout", "(", "_src", ")", ")", "\n", "_src", "=", "self", ".", "positionwise_feedforward", "(", "src", ")", "\n", "#dropout, residual and layer norm", "\n", "src", "=", "self", ".", "ff_layer_norm", "(", "src", "+", "self", ".", "dropout", "(", "_src", ")", ")", "\n", "return", "src", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.MultiHeadAttentionLayer.__init__": [[160, 172], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.DRS_match.__init__"], ["    ", "def", "__init__", "(", "self", ",", "hid_dim", ",", "n_heads", ",", "dropout", ",", "device", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "hid_dim", "%", "n_heads", "==", "0", "\n", "self", ".", "hid_dim", "=", "hid_dim", "\n", "self", ".", "n_heads", "=", "n_heads", "\n", "self", ".", "head_dim", "=", "hid_dim", "//", "n_heads", "\n", "self", ".", "fc_q", "=", "nn", ".", "Linear", "(", "hid_dim", ",", "hid_dim", ")", "\n", "self", ".", "fc_k", "=", "nn", ".", "Linear", "(", "hid_dim", ",", "hid_dim", ")", "\n", "self", ".", "fc_v", "=", "nn", ".", "Linear", "(", "hid_dim", ",", "hid_dim", ")", "\n", "self", ".", "fc_o", "=", "nn", ".", "Linear", "(", "hid_dim", ",", "hid_dim", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "scale", "=", "torch", ".", "sqrt", "(", "torch", ".", "FloatTensor", "(", "[", "self", ".", "head_dim", "]", ")", ")", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.MultiHeadAttentionLayer.forward": [[173, 190], ["seq2fol_transformer.MultiHeadAttentionLayer.fc_q", "seq2fol_transformer.MultiHeadAttentionLayer.fc_k", "seq2fol_transformer.MultiHeadAttentionLayer.fc_v", "Q.view().permute.view().permute.view().permute", "K.view().permute.view().permute.view().permute", "V.view().permute.view().permute.view().permute", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "seq2fol_transformer.MultiHeadAttentionLayer.permute().contiguous", "seq2fol_transformer.MultiHeadAttentionLayer.view", "seq2fol_transformer.MultiHeadAttentionLayer.fc_o", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "energy.masked_fill.masked_fill.masked_fill", "seq2fol_transformer.MultiHeadAttentionLayer.dropout", "Q.view().permute.view().permute.view", "K.view().permute.view().permute.view", "V.view().permute.view().permute.view", "K.view().permute.view().permute.permute", "seq2fol_transformer.MultiHeadAttentionLayer.permute"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "query", ",", "key", ",", "value", ",", "mask", "=", "None", ")", ":", "\n", "        ", "batch_size", "=", "query", ".", "shape", "[", "0", "]", "\n", "Q", "=", "self", ".", "fc_q", "(", "query", ")", "\n", "K", "=", "self", ".", "fc_k", "(", "key", ")", "\n", "V", "=", "self", ".", "fc_v", "(", "value", ")", "\n", "Q", "=", "Q", ".", "view", "(", "batch_size", ",", "-", "1", ",", "self", ".", "n_heads", ",", "self", ".", "head_dim", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", "\n", "K", "=", "K", ".", "view", "(", "batch_size", ",", "-", "1", ",", "self", ".", "n_heads", ",", "self", ".", "head_dim", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", "\n", "V", "=", "V", ".", "view", "(", "batch_size", ",", "-", "1", ",", "self", ".", "n_heads", ",", "self", ".", "head_dim", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", "\n", "energy", "=", "torch", ".", "matmul", "(", "Q", ",", "K", ".", "permute", "(", "0", ",", "1", ",", "3", ",", "2", ")", ")", "/", "self", ".", "scale", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "energy", "=", "energy", ".", "masked_fill", "(", "mask", "==", "0", ",", "-", "1e10", ")", "\n", "", "attention", "=", "torch", ".", "softmax", "(", "energy", ",", "dim", "=", "-", "1", ")", "\n", "x", "=", "torch", ".", "matmul", "(", "self", ".", "dropout", "(", "attention", ")", ",", "V", ")", "\n", "x", "=", "x", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", ".", "contiguous", "(", ")", "\n", "x", "=", "x", ".", "view", "(", "batch_size", ",", "-", "1", ",", "self", ".", "hid_dim", ")", "\n", "x", "=", "self", ".", "fc_o", "(", "x", ")", "\n", "return", "x", ",", "attention", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.PositionwiseFeedforwardLayer.__init__": [[192, 197], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.DRS_match.__init__"], ["    ", "def", "__init__", "(", "self", ",", "hid_dim", ",", "pf_dim", ",", "dropout", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "fc_1", "=", "nn", ".", "Linear", "(", "hid_dim", ",", "pf_dim", ")", "\n", "self", ".", "fc_2", "=", "nn", ".", "Linear", "(", "pf_dim", ",", "hid_dim", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.PositionwiseFeedforwardLayer.forward": [[198, 202], ["seq2fol_transformer.PositionwiseFeedforwardLayer.dropout", "seq2fol_transformer.PositionwiseFeedforwardLayer.fc_2", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "seq2fol_transformer.PositionwiseFeedforwardLayer.fc_1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "dropout", "(", "torch", ".", "relu", "(", "self", ".", "fc_1", "(", "x", ")", ")", ")", "\n", "x", "=", "self", ".", "fc_2", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.Decoder.__init__": [[204, 226], ["torch.Module.__init__", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt().to", "torch.sqrt().to", "seq2fol_transformer.DecoderLayer", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "range", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.DRS_match.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "output_dim", ",", "\n", "hid_dim", ",", "\n", "n_layers", ",", "\n", "n_heads", ",", "\n", "pf_dim", ",", "\n", "dropout", ",", "\n", "device", ",", "\n", "max_length", "=", "MAX_LENGTH", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "tok_embedding", "=", "nn", ".", "Embedding", "(", "output_dim", ",", "hid_dim", ")", "\n", "self", ".", "pos_embedding", "=", "nn", ".", "Embedding", "(", "max_length", ",", "hid_dim", ")", "\n", "self", ".", "layers", "=", "nn", ".", "ModuleList", "(", "[", "DecoderLayer", "(", "hid_dim", ",", "\n", "n_heads", ",", "\n", "pf_dim", ",", "\n", "dropout", ",", "\n", "device", ")", "\n", "for", "_", "in", "range", "(", "n_layers", ")", "]", ")", "\n", "self", ".", "fc_out", "=", "nn", ".", "Linear", "(", "hid_dim", ",", "output_dim", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "scale", "=", "torch", ".", "sqrt", "(", "torch", ".", "FloatTensor", "(", "[", "hid_dim", "]", ")", ")", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.Decoder.forward": [[227, 236], ["torch.arange().unsqueeze().repeat().to", "torch.arange().unsqueeze().repeat().to", "torch.arange().unsqueeze().repeat().to", "torch.arange().unsqueeze().repeat().to", "torch.arange().unsqueeze().repeat().to", "torch.arange().unsqueeze().repeat().to", "torch.arange().unsqueeze().repeat().to", "torch.arange().unsqueeze().repeat().to", "torch.arange().unsqueeze().repeat().to", "seq2fol_transformer.Decoder.dropout", "seq2fol_transformer.Decoder.fc_out", "layer", "torch.arange().unsqueeze().repeat", "torch.arange().unsqueeze().repeat", "torch.arange().unsqueeze().repeat", "torch.arange().unsqueeze().repeat", "torch.arange().unsqueeze().repeat", "torch.arange().unsqueeze().repeat", "torch.arange().unsqueeze().repeat", "torch.arange().unsqueeze().repeat", "torch.arange().unsqueeze().repeat", "seq2fol_transformer.Decoder.pos_embedding", "seq2fol_transformer.Decoder.tok_embedding", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "trg", ",", "enc_src", ",", "trg_mask", ",", "src_mask", ")", ":", "\n", "        ", "batch_size", "=", "trg", ".", "shape", "[", "0", "]", "\n", "trg_len", "=", "trg", ".", "shape", "[", "1", "]", "\n", "pos", "=", "torch", ".", "arange", "(", "0", ",", "trg_len", ")", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "batch_size", ",", "1", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "trg", "=", "self", ".", "dropout", "(", "(", "self", ".", "tok_embedding", "(", "trg", ")", "*", "self", ".", "scale", ")", "+", "self", ".", "pos_embedding", "(", "pos", ")", ")", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "trg", ",", "attention", "=", "layer", "(", "trg", ",", "enc_src", ",", "trg_mask", ",", "src_mask", ")", "\n", "", "output", "=", "self", ".", "fc_out", "(", "trg", ")", "\n", "return", "output", ",", "attention", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.DecoderLayer.__init__": [[238, 255], ["torch.Module.__init__", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "seq2fol_transformer.MultiHeadAttentionLayer", "seq2fol_transformer.MultiHeadAttentionLayer", "seq2fol_transformer.PositionwiseFeedforwardLayer", "torch.Dropout", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.DRS_match.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "hid_dim", ",", "\n", "n_heads", ",", "\n", "pf_dim", ",", "\n", "dropout", ",", "\n", "device", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "self_attn_layer_norm", "=", "nn", ".", "LayerNorm", "(", "hid_dim", ")", "\n", "self", ".", "enc_attn_layer_norm", "=", "nn", ".", "LayerNorm", "(", "hid_dim", ")", "\n", "self", ".", "ff_layer_norm", "=", "nn", ".", "LayerNorm", "(", "hid_dim", ")", "\n", "self", ".", "self_attention", "=", "MultiHeadAttentionLayer", "(", "hid_dim", ",", "n_heads", ",", "dropout", ",", "device", ")", "\n", "self", ".", "encoder_attention", "=", "MultiHeadAttentionLayer", "(", "hid_dim", ",", "n_heads", ",", "dropout", ",", "device", ")", "\n", "self", ".", "positionwise_feedforward", "=", "PositionwiseFeedforwardLayer", "(", "hid_dim", ",", "\n", "pf_dim", ",", "\n", "dropout", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.DecoderLayer.forward": [[256, 264], ["seq2fol_transformer.DecoderLayer.self_attention", "seq2fol_transformer.DecoderLayer.self_attn_layer_norm", "seq2fol_transformer.DecoderLayer.encoder_attention", "seq2fol_transformer.DecoderLayer.enc_attn_layer_norm", "seq2fol_transformer.DecoderLayer.positionwise_feedforward", "seq2fol_transformer.DecoderLayer.ff_layer_norm", "seq2fol_transformer.DecoderLayer.dropout", "seq2fol_transformer.DecoderLayer.dropout", "seq2fol_transformer.DecoderLayer.dropout"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "trg", ",", "enc_src", ",", "trg_mask", ",", "src_mask", ")", ":", "\n", "        ", "_trg", ",", "_", "=", "self", ".", "self_attention", "(", "trg", ",", "trg", ",", "trg", ",", "trg_mask", ")", "\n", "trg", "=", "self", ".", "self_attn_layer_norm", "(", "trg", "+", "self", ".", "dropout", "(", "_trg", ")", ")", "\n", "_trg", ",", "attention", "=", "self", ".", "encoder_attention", "(", "trg", ",", "enc_src", ",", "enc_src", ",", "src_mask", ")", "\n", "trg", "=", "self", ".", "enc_attn_layer_norm", "(", "trg", "+", "self", ".", "dropout", "(", "_trg", ")", ")", "\n", "_trg", "=", "self", ".", "positionwise_feedforward", "(", "trg", ")", "\n", "trg", "=", "self", ".", "ff_layer_norm", "(", "trg", "+", "self", ".", "dropout", "(", "_trg", ")", ")", "\n", "return", "trg", ",", "attention", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.Seq2Seq.__init__": [[266, 279], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.DRS_match.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "encoder", ",", "\n", "decoder", ",", "\n", "src_pad_idx", ",", "\n", "trg_pad_idx", ",", "\n", "device", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "encoder", "=", "encoder", "\n", "self", ".", "decoder", "=", "decoder", "\n", "self", ".", "src_pad_idx", "=", "src_pad_idx", "\n", "self", ".", "trg_pad_idx", "=", "trg_pad_idx", "\n", "self", ".", "device", "=", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.Seq2Seq.make_src_mask": [[280, 283], ["None"], "methods", ["None"], ["", "def", "make_src_mask", "(", "self", ",", "src", ")", ":", "\n", "        ", "src_mask", "=", "(", "src", "!=", "self", ".", "src_pad_idx", ")", ".", "unsqueeze", "(", "1", ")", ".", "unsqueeze", "(", "2", ")", "\n", "return", "src_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.Seq2Seq.make_trg_mask": [[284, 290], ["torch.tril().bool", "torch.tril().bool", "torch.tril().bool", "torch.tril().bool", "torch.tril().bool", "torch.tril().bool", "torch.tril().bool", "torch.tril().bool", "torch.tril().bool", "torch.tril", "torch.tril", "torch.tril", "torch.tril", "torch.tril", "torch.tril", "torch.tril", "torch.tril", "torch.tril", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["None"], ["", "def", "make_trg_mask", "(", "self", ",", "trg", ")", ":", "\n", "        ", "trg_pad_mask", "=", "(", "trg", "!=", "self", ".", "trg_pad_idx", ")", ".", "unsqueeze", "(", "1", ")", ".", "unsqueeze", "(", "2", ")", "\n", "trg_len", "=", "trg", ".", "shape", "[", "1", "]", "\n", "trg_sub_mask", "=", "torch", ".", "tril", "(", "torch", ".", "ones", "(", "(", "trg_len", ",", "trg_len", ")", ",", "device", "=", "self", ".", "device", ")", ")", ".", "bool", "(", ")", "\n", "trg_mask", "=", "trg_pad_mask", "&", "trg_sub_mask", "\n", "return", "trg_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.Seq2Seq.forward": [[291, 297], ["seq2fol_transformer.Seq2Seq.make_src_mask", "seq2fol_transformer.Seq2Seq.make_trg_mask", "seq2fol_transformer.Seq2Seq.encoder", "seq2fol_transformer.Seq2Seq.decoder"], "methods", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.Seq2Seq.make_src_mask", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.Seq2Seq.make_trg_mask"], ["", "def", "forward", "(", "self", ",", "src", ",", "trg", ")", ":", "\n", "        ", "src_mask", "=", "self", ".", "make_src_mask", "(", "src", ")", "\n", "trg_mask", "=", "self", ".", "make_trg_mask", "(", "trg", ")", "\n", "enc_src", "=", "self", ".", "encoder", "(", "src", ",", "src_mask", ")", "\n", "output", ",", "attention", "=", "self", ".", "decoder", "(", "trg", ",", "enc_src", ",", "trg_mask", ",", "src_mask", ")", "\n", "return", "output", ",", "attention", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.tokenize_sentence": [[48, 50], ["sentence.split"], "function", ["None"], ["def", "tokenize_sentence", "(", "sentence", ")", ":", "\n", "    ", "return", "[", "word", "for", "word", "in", "sentence", ".", "split", "(", "' '", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.tokenize_formula": [[51, 53], ["seq2fol_transformer.split_nltkformula"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.split_nltkformula"], ["", "def", "tokenize_formula", "(", "formula", ")", ":", "\n", "    ", "return", "[", "atom", "for", "atom", "in", "split_nltkformula", "(", "formula", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.tokenize_other": [[54, 56], ["formula.split"], "function", ["None"], ["", "def", "tokenize_other", "(", "formula", ")", ":", "\n", "    ", "return", "[", "atom", "for", "atom", "in", "formula", ".", "split", "(", "' '", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.split_prologformula": [[57, 71], ["list_formula.append", "list_formula.append", "tmp.extend", "len", "list_formula.append"], "function", ["None"], ["", "def", "split_prologformula", "(", "formula", ")", ":", "\n", "    ", "list_formula", "=", "[", "]", "\n", "tmp", "=", "[", "]", "\n", "for", "f", "in", "formula", ":", "\n", "      ", "if", "f", "==", "\"_\"", ":", "\n", "        ", "list_formula", ".", "append", "(", "f", ")", "\n", "", "elif", "f", "==", "\"(\"", "or", "f", "==", "\")\"", "or", "f", "==", "\",\"", ":", "\n", "          ", "if", "len", "(", "tmp", ")", ">=", "1", ":", "\n", "              ", "list_formula", ".", "append", "(", "\"\"", ".", "join", "(", "tmp", ")", ")", "\n", "tmp", "=", "[", "]", "\n", "", "list_formula", ".", "append", "(", "f", ")", "\n", "", "else", ":", "\n", "          ", "tmp", ".", "extend", "(", "f", ")", "\n", "", "", "return", "list_formula", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.split_nltkformula": [[72, 101], ["enumerate", "list_formula.append", "tmp.extend", "list_formula.append", "list_formula.append", "tmp.extend", "len", "tmp.extend", "tmp.extend", "tmp.extend", "list_formula.append", "len"], "function", ["None"], ["", "def", "split_nltkformula", "(", "formula", ")", ":", "\n", "    ", "list_formula", "=", "[", "]", "\n", "tmp", "=", "[", "]", "\n", "for", "i", ",", "f", "in", "enumerate", "(", "formula", ")", ":", "\n", "        ", "if", "f", "==", "\"-\"", ":", "\n", "            ", "if", "formula", "[", "i", "+", "1", "]", "==", "\">\"", ":", "\n", "                ", "tmp", ".", "extend", "(", "f", ")", "\n", "continue", "\n", "#negation", "\n", "", "list_formula", ".", "append", "(", "f", ")", "\n", "", "elif", "f", "==", "\"(\"", "or", "f", "==", "\")\"", "or", "f", "==", "\",\"", "or", "f", "==", "\".\"", "or", "f", "==", "\">\"", ":", "\n", "            ", "if", "len", "(", "tmp", ")", ">=", "1", "and", "f", "!=", "\">\"", ":", "\n", "                ", "list_formula", ".", "append", "(", "\"\"", ".", "join", "(", "tmp", ")", ")", "\n", "tmp", "=", "[", "]", "\n", "", "elif", "len", "(", "tmp", ")", ">=", "1", "and", "f", "==", "\">\"", ":", "\n", "                ", "tmp", ".", "extend", "(", "f", ")", "\n", "continue", "\n", "", "list_formula", ".", "append", "(", "f", ")", "\n", "", "elif", "f", "==", "\" \"", ":", "\n", "            ", "if", "formula", "[", "i", "+", "1", "]", "==", "\"&\"", "or", "formula", "[", "i", "+", "1", "]", "==", "\"|\"", "or", "formula", "[", "i", "+", "2", "]", "==", "\">\"", ":", "\n", "                ", "tmp", ".", "extend", "(", "f", ")", "\n", "continue", "\n", "", "else", ":", "\n", "                ", "tmp", ".", "extend", "(", "f", ")", "\n", "list_formula", ".", "append", "(", "\"\"", ".", "join", "(", "tmp", ")", ")", "\n", "tmp", "=", "[", "]", "\n", "", "", "else", ":", "\n", "            ", "tmp", ".", "extend", "(", "f", ")", "\n", "", "", "return", "list_formula", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.train": [[299, 316], ["model.train", "enumerate", "optimizer.zero_grad", "model", "output.contiguous().view.contiguous().view", "trg[].contiguous().view", "criterion", "criterion.backward", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "optimizer.step", "criterion.item", "len", "model.parameters", "output.contiguous().view.contiguous", "trg[].contiguous"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.train"], ["", "", "def", "train", "(", "model", ",", "iterator", ",", "optimizer", ",", "criterion", ",", "clip", ")", ":", "\n", "    ", "model", ".", "train", "(", ")", "\n", "epoch_loss", "=", "0", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "iterator", ")", ":", "\n", "        ", "src", "=", "batch", ".", "src", "\n", "trg", "=", "batch", ".", "trg", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "output", ",", "_", "=", "model", "(", "src", ",", "trg", "[", ":", ",", ":", "-", "1", "]", ")", "\n", "output_dim", "=", "output", ".", "shape", "[", "-", "1", "]", "\n", "output", "=", "output", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "output_dim", ")", "\n", "trg", "=", "trg", "[", ":", ",", "1", ":", "]", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "loss", "=", "criterion", "(", "output", ",", "trg", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "model", ".", "parameters", "(", ")", ",", "clip", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "epoch_loss", "+=", "loss", ".", "item", "(", ")", "\n", "", "return", "epoch_loss", "/", "len", "(", "iterator", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.epoch_time": [[317, 322], ["int", "int"], "function", ["None"], ["", "def", "epoch_time", "(", "start_time", ",", "end_time", ")", ":", "\n", "    ", "elapsed_time", "=", "end_time", "-", "start_time", "\n", "elapsed_mins", "=", "int", "(", "elapsed_time", "/", "60", ")", "\n", "elapsed_secs", "=", "int", "(", "elapsed_time", "-", "(", "elapsed_mins", "*", "60", ")", ")", "\n", "return", "elapsed_mins", ",", "elapsed_secs", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.trainIters": [[323, 345], ["torch.optim.Adam", "torch.CrossEntropyLoss", "float", "range", "model.parameters", "time.time", "seq2fol_transformer.train", "seq2fol_transformer.evaluate", "time.time", "seq2fol_transformer.epoch_time", "print", "print", "print", "torch.save", "torch.save", "torch.save", "model.state_dict", "math.exp", "math.exp"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.train", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.evaluate", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.epoch_time"], ["", "def", "trainIters", "(", "output_dir", ",", "model", ",", "n_iters", ",", "train_iterator", ",", "valid_iterator", ",", "learning_rate", "=", "0.0005", ")", ":", "\n", "    ", "early", "=", "0", "\n", "optimizer", "=", "optim", ".", "Adam", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "learning_rate", ")", "\n", "criterion", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "best_valid_loss", "=", "float", "(", "'inf'", ")", "\n", "\n", "for", "epoch", "in", "range", "(", "n_iters", ")", ":", "\n", "        ", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "train_loss", "=", "train", "(", "model", ",", "train_iterator", ",", "optimizer", ",", "criterion", ",", "1", ")", "\n", "valid_loss", "=", "evaluate", "(", "model", ",", "valid_iterator", ",", "criterion", ")", "\n", "\n", "end_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "epoch_mins", ",", "epoch_secs", "=", "epoch_time", "(", "start_time", ",", "end_time", ")", "\n", "\n", "print", "(", "f'Epoch: {epoch+1:02} | Time: {epoch_mins}m {epoch_secs}s'", ")", "\n", "print", "(", "f'\\tTrain Loss: {train_loss:.3f} | Train PPL: {math.exp(train_loss):7.3f}'", ")", "\n", "print", "(", "f'\\t Val. Loss: {valid_loss:.3f} |  Val. PPL: {math.exp(valid_loss):7.3f}'", ")", "\n", "if", "valid_loss", "<", "best_valid_loss", ":", "\n", "            ", "best_valid_loss", "=", "valid_loss", "\n", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "output_dir", "+", "'/seq2fol_model.pt'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.evaluate": [[346, 360], ["model.eval", "torch.no_grad", "torch.no_grad", "torch.no_grad", "enumerate", "len", "model", "output.contiguous().view.contiguous().view", "trg[].contiguous().view", "criterion", "criterion.item", "output.contiguous().view.contiguous", "trg[].contiguous"], "function", ["None"], ["", "", "", "def", "evaluate", "(", "model", ",", "iterator", ",", "criterion", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "epoch_loss", "=", "0", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "i", ",", "batch", "in", "enumerate", "(", "iterator", ")", ":", "\n", "            ", "src", "=", "batch", ".", "src", "\n", "trg", "=", "batch", ".", "trg", "\n", "output", ",", "_", "=", "model", "(", "src", ",", "trg", "[", ":", ",", ":", "-", "1", "]", ")", "\n", "output_dim", "=", "output", ".", "shape", "[", "-", "1", "]", "\n", "output", "=", "output", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "output_dim", ")", "\n", "trg", "=", "trg", "[", ":", ",", "1", ":", "]", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "loss", "=", "criterion", "(", "output", ",", "trg", ")", "\n", "epoch_loss", "+=", "loss", ".", "item", "(", ")", "\n", "", "", "return", "epoch_loss", "/", "len", "(", "iterator", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.list_split": [[361, 366], ["res.extend", "seq2fol_transformer.split_nltkformula"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.split_nltkformula"], ["", "def", "list_split", "(", "xlist", ")", ":", "\n", "    ", "res", "=", "[", "]", "\n", "for", "x", "in", "xlist", ":", "\n", "        ", "res", ".", "extend", "(", "split_nltkformula", "(", "x", ")", ")", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.initialize_weights": [[367, 370], ["hasattr", "torch.init.xavier_uniform_", "m.weight.dim"], "function", ["None"], ["", "def", "initialize_weights", "(", "m", ")", ":", "\n", "    ", "if", "hasattr", "(", "m", ",", "'weight'", ")", "and", "m", ".", "weight", ".", "dim", "(", ")", ">", "1", ":", "\n", "        ", "nn", ".", "init", ".", "xavier_uniform_", "(", "m", ".", "weight", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.translate_sentence": [[371, 395], ["model.eval", "isinstance", "torch.LongTensor().unsqueeze().to", "torch.LongTensor().unsqueeze().to", "torch.LongTensor().unsqueeze().to", "model.make_src_mask", "range", "seq2fol_transformer.tokenize_sentence", "torch.no_grad", "torch.no_grad", "torch.no_grad", "model.encoder", "torch.LongTensor().unsqueeze().to", "torch.LongTensor().unsqueeze().to", "torch.LongTensor().unsqueeze().to", "model.make_trg_mask", "[].item", "trg_indexes.append", "torch.LongTensor().unsqueeze", "torch.LongTensor().unsqueeze", "torch.LongTensor().unsqueeze", "torch.no_grad", "torch.no_grad", "torch.no_grad", "model.decoder", "torch.LongTensor().unsqueeze", "torch.LongTensor().unsqueeze", "torch.LongTensor().unsqueeze", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "output.argmax", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.Seq2Seq.make_src_mask", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.tokenize_sentence", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.Seq2Seq.make_trg_mask"], ["", "", "def", "translate_sentence", "(", "sentence", ",", "src_field", ",", "trg_field", ",", "model", ",", "device", ",", "max_len", "=", "MAX_LENGTH", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "if", "isinstance", "(", "sentence", ",", "str", ")", ":", "\n", "        ", "tokens", "=", "tokenize_sentence", "(", "sentence", ")", "\n", "", "else", ":", "\n", "        ", "tokens", "=", "sentence", "\n", "", "tokens", "=", "[", "src_field", ".", "init_token", "]", "+", "tokens", "+", "[", "src_field", ".", "eos_token", "]", "\n", "src_indexes", "=", "[", "src_field", ".", "vocab", ".", "stoi", "[", "token", "]", "for", "token", "in", "tokens", "]", "\n", "src_tensor", "=", "torch", ".", "LongTensor", "(", "src_indexes", ")", ".", "unsqueeze", "(", "0", ")", ".", "to", "(", "device", ")", "\n", "src_mask", "=", "model", ".", "make_src_mask", "(", "src_tensor", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "enc_src", "=", "model", ".", "encoder", "(", "src_tensor", ",", "src_mask", ")", "\n", "", "trg_indexes", "=", "[", "trg_field", ".", "vocab", ".", "stoi", "[", "trg_field", ".", "init_token", "]", "]", "\n", "for", "i", "in", "range", "(", "max_len", ")", ":", "\n", "        ", "trg_tensor", "=", "torch", ".", "LongTensor", "(", "trg_indexes", ")", ".", "unsqueeze", "(", "0", ")", ".", "to", "(", "device", ")", "\n", "trg_mask", "=", "model", ".", "make_trg_mask", "(", "trg_tensor", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "output", ",", "attention", "=", "model", ".", "decoder", "(", "trg_tensor", ",", "enc_src", ",", "trg_mask", ",", "src_mask", ")", "\n", "", "pred_token", "=", "output", ".", "argmax", "(", "2", ")", "[", ":", ",", "-", "1", "]", ".", "item", "(", ")", "\n", "trg_indexes", ".", "append", "(", "pred_token", ")", "\n", "if", "pred_token", "==", "trg_field", ".", "vocab", ".", "stoi", "[", "trg_field", ".", "eos_token", "]", ":", "\n", "            ", "break", "\n", "", "", "trg_tokens", "=", "[", "trg_field", ".", "vocab", ".", "itos", "[", "i", "]", "for", "i", "in", "trg_indexes", "]", "\n", "return", "trg_tokens", "[", "1", ":", "]", ",", "attention", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.seq2fol_transformer.display_attention": [[396, 411], ["matplotlib.figure", "range", "matplotlib.show", "matplotlib.close", "plt.figure.add_subplot", "[].cpu().detach().numpy", "fig.add_subplot.matshow", "fig.add_subplot.tick_params", "fig.add_subplot.set_xticklabels", "fig.add_subplot.set_yticklabels", "fig.add_subplot.xaxis.set_major_locator", "fig.add_subplot.yaxis.set_major_locator", "matplotlib.MultipleLocator", "matplotlib.MultipleLocator", "[].cpu().detach", "[].cpu", "t.lower", "attention.squeeze"], "function", ["None"], ["", "def", "display_attention", "(", "sentence", ",", "translation", ",", "attention", ",", "n_heads", "=", "8", ",", "n_rows", "=", "4", ",", "n_cols", "=", "2", ")", ":", "\n", "    ", "assert", "n_rows", "*", "n_cols", "==", "n_heads", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "15", ",", "25", ")", ")", "\n", "for", "i", "in", "range", "(", "n_heads", ")", ":", "\n", "        ", "ax", "=", "fig", ".", "add_subplot", "(", "n_rows", ",", "n_cols", ",", "i", "+", "1", ")", "\n", "_attention", "=", "attention", ".", "squeeze", "(", "0", ")", "[", "i", "]", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "cax", "=", "ax", ".", "matshow", "(", "_attention", ",", "cmap", "=", "'bone'", ")", "\n", "ax", ".", "tick_params", "(", "labelsize", "=", "12", ")", "\n", "ax", ".", "set_xticklabels", "(", "[", "''", "]", "+", "[", "'<sos>'", "]", "+", "[", "t", ".", "lower", "(", ")", "for", "t", "in", "sentence", "]", "+", "[", "'<eos>'", "]", ",", "\n", "rotation", "=", "45", ")", "\n", "ax", ".", "set_yticklabels", "(", "[", "''", "]", "+", "translation", ")", "\n", "ax", ".", "xaxis", ".", "set_major_locator", "(", "ticker", ".", "MultipleLocator", "(", "1", ")", ")", "\n", "ax", ".", "yaxis", ".", "set_major_locator", "(", "ticker", ".", "MultipleLocator", "(", "1", ")", ")", "\n", "", "plt", ".", "show", "(", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.logic_parser.lexpr": [[7, 14], ["logic_parser.parse", "logging.error"], "function", ["None"], ["def", "lexpr", "(", "formula_str", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "expr", "=", "logic_parser", ".", "parse", "(", "formula_str", ")", "\n", "", "except", "LogicalExpressionException", "as", "e", ":", "\n", "        ", "logging", ".", "error", "(", "'Failed to parse {0}. Error: {1}'", ".", "format", "(", "formula_str", ",", "e", ")", ")", "\n", "raise", "\n", "", "return", "expr", "", "", ""]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.drs2clf.convert_to_clausal_forms": [[28, 31], ["drs2clf.convert_to_clf"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.drs2clf.convert_to_clf"], ["def", "convert_to_clausal_forms", "(", "drs", ")", ":", "\n", "    ", "_", ",", "cls", "=", "convert_to_clf", "(", "1", ",", "[", "]", ",", "drs", ")", "\n", "return", "cls", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.drs2clf.is_variable": [[33, 41], ["len", "drs_str[].isdigit"], "function", ["None"], ["", "def", "is_variable", "(", "drs_str", ")", ":", "\n", "    ", "prefix", "=", "[", "'x'", ",", "'e'", "]", "\n", "if", "len", "(", "drs_str", ")", "<=", "1", ":", "\n", "        ", "return", "False", "\n", "", "elif", "drs_str", "[", "0", "]", "in", "prefix", "and", "drs_str", "[", "1", "]", ".", "isdigit", "(", ")", ":", "\n", "        ", "return", "True", "\n", "", "else", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.drs2clf.check_constant_and_add_quotes": [[43, 48], ["drs2clf.is_variable"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.drs2clf.is_variable"], ["", "", "def", "check_constant_and_add_quotes", "(", "drs_str", ")", ":", "\n", "    ", "if", "is_variable", "(", "drs_str", ")", ":", "\n", "        ", "return", "drs_str", "\n", "", "else", ":", "\n", "        ", "return", "'\"'", "+", "drs_str", "+", "'\"'", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.drs2clf.convert_to_clf": [[50, 137], ["isinstance", "clfs.append", "isinstance", "isinstance", "len", "nltk.sem.drt.DRS", "drs2clf.convert_to_clf", "drs2clf.convert_to_clf", "clfs.insert", "str", "clfs.append", "isinstance", "str", "str", "str", "str", "clfs.append", "drs2clf.convert_to_clf", "drs.uncurry", "drs.uncurry", "str", "len", "isinstance", "len", "isinstance", "clfs.append", "drs2clf.convert_to_clf", "isinstance", "str", "drs2clf.convert_to_clf", "drs2clf.check_constant_and_add_quotes", "drs2clf.check_constant_and_add_quotes", "drs2clf.convert_to_clf", "drs2clf.check_constant_and_add_quotes", "drs2clf.check_constant_and_add_quotes", "str", "str", "len", "drs2clf.convert_to_clf", "drs2clf.convert_to_clf", "clfs.insert", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.drs2clf.convert_to_clf", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.drs2clf.convert_to_clf", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.drs2clf.convert_to_clf", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.drs2clf.convert_to_clf", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.drs2clf.convert_to_clf", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.drs2clf.check_constant_and_add_quotes", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.drs2clf.check_constant_and_add_quotes", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.drs2clf.convert_to_clf", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.drs2clf.check_constant_and_add_quotes", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.drs2clf.check_constant_and_add_quotes", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.drs2clf.convert_to_clf", "home.repos.pwc.inspect_result.verypluming_SyGNS.scripts.drs2clf.convert_to_clf"], ["", "", "def", "convert_to_clf", "(", "idx", ",", "clfs", ",", "drs", ")", ":", "\n", "    ", "if", "isinstance", "(", "drs", ",", "str", ")", ":", "\n", "        ", "clfs", ".", "append", "(", "drs", ")", "\n", "", "elif", "isinstance", "(", "drs", ",", "DRS", ")", ":", "\n", "        ", "refs", "=", "drs", ".", "refs", "\n", "conds", "=", "drs", ".", "conds", "\n", "if", "drs", ".", "consequent", ":", "\n", "            ", "head", "=", "len", "(", "clfs", ")", "\n", "consequent", "=", "drs", ".", "consequent", "\n", "boxvar", "=", "'b'", "+", "str", "(", "idx", ")", "\n", "idx", "=", "idx", "+", "1", "\n", "boxarg1", "=", "'b'", "+", "str", "(", "idx", ")", "\n", "antecedent", "=", "DRS", "(", "refs", ",", "conds", ")", "\n", "idx", ",", "clfs", "=", "convert_to_clf", "(", "idx", ",", "clfs", ",", "antecedent", ")", "\n", "idx", "=", "idx", "+", "1", "\n", "boxarg2", "=", "'b'", "+", "str", "(", "idx", ")", "\n", "idx", ",", "clfs", "=", "convert_to_clf", "(", "idx", ",", "clfs", ",", "consequent", ")", "\n", "res", "=", "boxvar", "+", "' IMP '", "+", "boxarg1", "+", "' '", "+", "boxarg2", "\n", "clfs", ".", "insert", "(", "head", ",", "res", ")", "\n", "return", "idx", ",", "clfs", "\n", "", "else", ":", "\n", "            ", "boxvar", "=", "'b'", "+", "str", "(", "idx", ")", "\n", "for", "ref", "in", "refs", ":", "\n", "                ", "clf", "=", "boxvar", "+", "' REF '", "+", "str", "(", "ref", ")", "\n", "clfs", ".", "append", "(", "clf", ")", "\n", "", "for", "cond", "in", "conds", ":", "\n", "                ", "idx", ",", "clfs", "=", "convert_to_clf", "(", "idx", ",", "clfs", ",", "cond", ")", "\n", "", "return", "idx", ",", "clfs", "\n", "", "", "elif", "isinstance", "(", "drs", ",", "DrtApplicationExpression", ")", ":", "\n", "        ", "predicate", "=", "drs", ".", "uncurry", "(", ")", "[", "0", "]", "\n", "args", "=", "drs", ".", "uncurry", "(", ")", "[", "1", "]", "\n", "op", "=", "str", "(", "predicate", ")", "\n", "boxvar", "=", "'b'", "+", "str", "(", "idx", ")", "\n", "if", "len", "(", "args", ")", "==", "1", ":", "\n", "            ", "arg", "=", "args", "[", "0", "]", "\n", "if", "isinstance", "(", "arg", ",", "DRS", ")", ":", "\n", "                ", "next_idx", "=", "idx", "+", "1", "\n", "boxarg", "=", "'b'", "+", "str", "(", "next_idx", ")", "\n", "res", "=", "boxvar", "+", "' '", "+", "op", "+", "' '", "+", "boxarg", "\n", "idx", ",", "clfs", "=", "convert_to_clf", "(", "next_idx", ",", "clfs", ",", "arg", ")", "\n", "", "else", ":", "\n", "                ", "out", "=", "check_constant_and_add_quotes", "(", "str", "(", "arg", ")", ")", "\n", "res", "=", "boxvar", "+", "' '", "+", "op", "+", "' '", "+", "out", "\n", "# adding dummy synset", "\n", "# res = boxvar + ' ' + op + ' \"n.01\" ' + out", "\n", "", "", "if", "len", "(", "args", ")", "==", "2", ":", "\n", "            ", "arg1", "=", "args", "[", "0", "]", "\n", "arg2", "=", "args", "[", "1", "]", "\n", "if", "isinstance", "(", "arg2", ",", "DRS", ")", ":", "\n", "                ", "out", "=", "check_constant_and_add_quotes", "(", "str", "(", "arg1", ")", ")", "\n", "next_idx", "=", "idx", "+", "1", "\n", "box_arg", "=", "'b'", "+", "str", "(", "next_idx", ")", "\n", "res", "=", "boxvar", "+", "' '", "+", "op", "+", "' '", "+", "out", "+", "' '", "+", "box_arg", "\n", "idx", ",", "clfs", "=", "convert_to_clf", "(", "next_idx", ",", "clfs", ",", "arg2", ")", "\n", "", "else", ":", "\n", "                ", "out1", "=", "check_constant_and_add_quotes", "(", "str", "(", "arg1", ")", ")", "\n", "out2", "=", "check_constant_and_add_quotes", "(", "str", "(", "arg2", ")", ")", "\n", "# if op in roles:", "\n", "res", "=", "'b'", "+", "str", "(", "idx", ")", "+", "' '", "+", "op", "+", "' '", "+", "out1", "+", "' '", "+", "out2", "\n", "", "", "clfs", ".", "append", "(", "res", ")", "\n", "return", "idx", ",", "clfs", "\n", "", "elif", "isinstance", "(", "drs", ",", "DrtNegatedExpression", ")", ":", "\n", "        ", "boxvar", "=", "'b'", "+", "str", "(", "idx", ")", "\n", "idx", "=", "idx", "+", "1", "\n", "drs_var", "=", "'b'", "+", "str", "(", "idx", ")", "\n", "neg", "=", "boxvar", "+", "' NOT '", "+", "drs_var", "\n", "clfs", ".", "append", "(", "neg", ")", "\n", "term", "=", "drs", ".", "term", "\n", "idx", ",", "clfs", "=", "convert_to_clf", "(", "idx", ",", "clfs", ",", "term", ")", "\n", "return", "idx", ",", "clfs", "\n", "", "elif", "isinstance", "(", "drs", ",", "DrtOrExpression", ")", ":", "\n", "        ", "head", "=", "len", "(", "clfs", ")", "\n", "boxvar", "=", "'b'", "+", "str", "(", "idx", ")", "\n", "idx", "=", "idx", "+", "1", "\n", "boxarg1", "=", "'b'", "+", "str", "(", "idx", ")", "\n", "idx", ",", "clfs", "=", "convert_to_clf", "(", "idx", ",", "clfs", ",", "drs", ".", "first", ")", "\n", "idx", "=", "idx", "+", "1", "\n", "boxarg2", "=", "'b'", "+", "str", "(", "idx", ")", "\n", "idx", ",", "clfs", "=", "convert_to_clf", "(", "idx", ",", "clfs", ",", "drs", ".", "second", ")", "\n", "res", "=", "boxvar", "+", "' DIS '", "+", "boxarg1", "+", "' '", "+", "boxarg2", "\n", "clfs", ".", "insert", "(", "head", ",", "res", ")", "\n", "return", "idx", ",", "clfs", "\n", "#     elif isinstance(drs, DrtLambdaExpression):", "\n", "#     elif isinstance(drs, DrtEqualityExpression):", "\n", "", "else", ":", "\n", "        ", "return", "idx", ",", "str", "(", "drs", ")", "\n", "", "return", "idx", ",", "clfs", "\n", "", ""]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.dummy_drs": [[5, 14], ["random.choice", "range"], "function", ["None"], ["def", "dummy_drs", "(", "list_output", "=", "True", ")", ":", "\n", "    ", "'''Return dummy DRS in clause format'''", "\n", "# Add random string so it never matches with anything", "\n", "rand_string", "=", "\"\"", ".", "join", "(", "[", "random", ".", "choice", "(", "[", "'a'", ",", "'b'", ",", "'c'", ",", "'d'", ",", "'e'", ",", "'f'", ",", "'g'", ",", "'h'", "]", ")", "for", "x", "in", "range", "(", "10", ")", "]", ")", "\n", "dummy", "=", "[", "[", "'b1'", ",", "'REF'", ",", "'x1'", "]", ",", "[", "'b1'", ",", "'alwayswrongconcept'", "+", "rand_string", ",", "'\"n.01\"'", ",", "'x1'", "]", "]", "\n", "if", "list_output", ":", "\n", "        ", "return", "dummy", "\n", "", "else", ":", "\n", "        ", "return", "[", "\" \"", ".", "join", "(", "x", ")", "for", "x", "in", "dummy", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.spar_drs": [[15, 36], ["None"], "function", ["None"], ["", "", "def", "spar_drs", "(", "list_output", "=", "True", ")", ":", "\n", "    ", "'''Return the SPAR DRS of \"He bragged about it.\"\n       SPAR for PMB release 3.0.0'''", "\n", "spar", "=", "[", "[", "'b1'", ",", "'REF'", ",", "'x1'", "]", ",", "\n", "[", "'b1'", ",", "'PRESUPPOSITION'", ",", "'b2'", "]", ",", "\n", "[", "'b1'", ",", "'male'", ",", "'\"n.02\"'", ",", "'x1'", "]", ",", "\n", "[", "'b2'", ",", "'REF'", ",", "'e1'", "]", ",", "\n", "[", "'b2'", ",", "'REF'", ",", "'t1'", "]", ",", "\n", "[", "'b2'", ",", "'Agent'", ",", "'e1'", ",", "'x1'", "]", ",", "\n", "[", "'b2'", ",", "'TPR'", ",", "'t1'", ",", "'\"now\"'", "]", ",", "\n", "[", "'b2'", ",", "'Time'", ",", "'e1'", ",", "'t1'", "]", ",", "\n", "[", "'b2'", ",", "'brag'", ",", "'\"v.01\"'", ",", "'e1'", "]", ",", "\n", "[", "'b2'", ",", "'time'", ",", "'\"n.08\"'", ",", "'t1'", "]", ",", "\n", "[", "'b2'", ",", "'Theme'", ",", "'e1'", ",", "'x2'", "]", ",", "\n", "[", "'b3'", ",", "'REF'", ",", "'x2'", "]", ",", "\n", "[", "'b3'", ",", "'PRESUPPOSITION'", ",", "'b2'", "]", ",", "\n", "[", "'b3'", ",", "'entity'", ",", "'\"n.01\"'", ",", "'x2'", "]", "]", "\n", "if", "list_output", ":", "\n", "        ", "return", "spar", "\n", "", "else", ":", "\n", "        ", "return", "[", "\" \"", ".", "join", "(", "x", ")", "for", "x", "in", "spar", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.write_to_file": [[38, 44], ["out_f.close", "open", "out_f.write", "line.strip"], "function", ["None"], ["", "", "def", "write_to_file", "(", "lst", ",", "out_file", ")", ":", "\n", "    ", "'''Write list to file'''", "\n", "with", "open", "(", "out_file", ",", "\"w\"", ")", "as", "out_f", ":", "\n", "        ", "for", "line", "in", "lst", ":", "\n", "            ", "out_f", ".", "write", "(", "line", ".", "strip", "(", ")", "+", "'\\n'", ")", "\n", "", "", "out_f", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.write_list_of_lists": [[46, 55], ["out_f.close", "open", "out_f.write", "out_f.write", "item.strip"], "function", ["None"], ["", "def", "write_list_of_lists", "(", "lst", ",", "out_file", ",", "extra_new_line", "=", "True", ")", ":", "\n", "    ", "'''Write lists of lists to file'''", "\n", "with", "open", "(", "out_file", ",", "\"w\"", ")", "as", "out_f", ":", "\n", "        ", "for", "sub_list", "in", "lst", ":", "\n", "            ", "for", "item", "in", "sub_list", ":", "\n", "                ", "out_f", ".", "write", "(", "item", ".", "strip", "(", ")", "+", "'\\n'", ")", "\n", "", "if", "extra_new_line", ":", "\n", "                ", "out_f", ".", "write", "(", "'\\n'", ")", "\n", "", "", "", "out_f", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.write_list_of_lists_of_lists": [[57, 69], ["out_f.close", "open", "out_f.write", "out_f.write", "out_f.write", "line.strip"], "function", ["None"], ["", "def", "write_list_of_lists_of_lists", "(", "lst", ",", "out_file", ",", "extra_new_line", "=", "True", ")", ":", "\n", "    ", "'''Write list of lists of lists to file'''", "\n", "with", "open", "(", "out_file", ",", "\"w\"", ")", "as", "out_f", ":", "\n", "        ", "for", "sub_list", "in", "lst", ":", "\n", "            ", "for", "item", "in", "sub_list", ":", "\n", "                ", "for", "line", "in", "item", ":", "\n", "                    ", "out_f", ".", "write", "(", "line", ".", "strip", "(", ")", "+", "'\\n'", ")", "\n", "", "if", "extra_new_line", ":", "\n", "                    ", "out_f", ".", "write", "(", "'\\n'", ")", "\n", "", "", "if", "extra_new_line", ":", "\n", "                ", "out_f", ".", "write", "(", "'\\n'", ")", "\n", "", "", "", "out_f", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.compute_f": [[71, 106], ["round", "round", "ValueError", "round", "float", "float", "float", "float"], "function", ["None"], ["", "def", "compute_f", "(", "match_num", ",", "test_num", ",", "gold_num", ",", "significant", ",", "f_only", ")", ":", "\n", "    ", "\"\"\"\n    Compute the f-score based on the matching clause number,\n                                 clause number of DRS set 1,\n                                 clause number of DRS set 2\n    Args:\n        match_num: matching clause number\n        test_num:  clause number of DRS 1 (test file)\n        gold_num:  clause number of DRS 2 (gold file)\n    Returns:\n        precision: match_num/test_num\n        recall: match_num/gold_num\n        f_score: 2*precision*recall/(precision+recall)\n    \"\"\"", "\n", "if", "test_num", "==", "0", "or", "gold_num", "==", "0", ":", "\n", "        ", "if", "f_only", ":", "\n", "            ", "return", "0.00", "\n", "", "else", ":", "\n", "            ", "return", "0.00", ",", "0.00", ",", "0.00", "\n", "", "", "precision", "=", "round", "(", "float", "(", "match_num", ")", "/", "float", "(", "test_num", ")", ",", "significant", ")", "\n", "recall", "=", "round", "(", "float", "(", "match_num", ")", "/", "float", "(", "gold_num", ")", ",", "significant", ")", "\n", "if", "precision", "<", "0.0", "or", "precision", ">", "1.0", "or", "recall", "<", "0.0", "or", "recall", ">", "1.0", ":", "\n", "        ", "raise", "ValueError", "(", "\"Precision and recall should never be outside (0.0-1.0), now {0} and {1}\"", ".", "format", "(", "precision", ",", "recall", ")", ")", "\n", "\n", "", "if", "(", "precision", "+", "recall", ")", "!=", "0", ":", "\n", "        ", "f_score", "=", "round", "(", "2", "*", "precision", "*", "recall", "/", "(", "precision", "+", "recall", ")", ",", "significant", ")", "\n", "if", "f_only", ":", "\n", "            ", "return", "f_score", "\n", "", "else", ":", "\n", "            ", "return", "precision", ",", "recall", ",", "f_score", "\n", "", "", "else", ":", "\n", "        ", "if", "f_only", ":", "\n", "            ", "return", "0.00", "\n", "", "else", ":", "\n", "            ", "return", "precision", ",", "recall", ",", "0.00", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.between_quotes": [[108, 111], ["string.startswith", "string.endswith", "string.startswith", "string.endswith"], "function", ["None"], ["", "", "", "def", "between_quotes", "(", "string", ")", ":", "\n", "    ", "'''Return true if a value is between quotes'''", "\n", "return", "(", "string", ".", "startswith", "(", "'\"'", ")", "and", "string", ".", "endswith", "(", "'\"'", ")", ")", "or", "(", "string", ".", "startswith", "(", "\"'\"", ")", "and", "string", ".", "endswith", "(", "\"'\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.all_upper": [[113, 116], ["all", "x.isupper"], "function", ["None"], ["", "def", "all_upper", "(", "string", ")", ":", "\n", "    ", "'''Checks if all items in a string are uppercase'''", "\n", "return", "all", "(", "x", ".", "isupper", "(", ")", "for", "x", "in", "string", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.is_role": [[118, 121], ["string[].isupper", "any", "all", "x.islower", "x.islower", "x.isupper"], "function", ["None"], ["", "def", "is_role", "(", "string", ")", ":", "\n", "    ", "'''Check if string is in the format of a role'''", "\n", "return", "string", "[", "0", "]", ".", "isupper", "(", ")", "and", "any", "(", "x", ".", "islower", "(", ")", "for", "x", "in", "string", "[", "1", ":", "]", ")", "and", "all", "(", "x", ".", "islower", "(", ")", "or", "x", ".", "isupper", "(", ")", "or", "x", "==", "'-'", "for", "x", "in", "string", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.merge_dicts": [[123, 138], ["utils_counter.compute_f", "zip"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.compute_f"], ["", "def", "merge_dicts", "(", "all_dicts", ",", "args", ")", ":", "\n", "    ", "'''Merge a list of dictionaries in a single dict'''", "\n", "new_dict", "=", "{", "}", "\n", "for", "d", "in", "all_dicts", ":", "\n", "        ", "for", "key", "in", "d", ":", "\n", "            ", "if", "key", "not", "in", "new_dict", ":", "\n", "                ", "new_dict", "[", "key", "]", "=", "d", "[", "key", "]", "\n", "", "else", ":", "\n", "                ", "new_dict", "[", "key", "]", "=", "[", "x", "+", "y", "for", "x", ",", "y", "in", "zip", "(", "new_dict", "[", "key", "]", ",", "d", "[", "key", "]", ")", "]", "\n", "\n", "# Create new dictionary with F-scores so we can easily sort later", "\n", "", "", "", "f_dict", "=", "{", "}", "\n", "for", "key", "in", "new_dict", ":", "\n", "        ", "f_dict", "[", "key", "]", "=", "compute_f", "(", "new_dict", "[", "key", "]", "[", "0", "]", ",", "new_dict", "[", "key", "]", "[", "1", "]", ",", "new_dict", "[", "key", "]", "[", "2", "]", ",", "args", ".", "significant", ",", "True", ")", "\n", "", "return", "new_dict", ",", "f_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.multiply_if_float": [[140, 155], ["first_item.strip().startswith", "float", "first_item.strip", "str", "float", "float", "round", "float"], "function", ["None"], ["", "def", "multiply_if_float", "(", "string", ",", "first_item", ",", "multiplier", "=", "100", ",", "do_round", "=", "4", ")", ":", "\n", "    ", "'''Multiply in string by 100 if it's a float between 0 and 1\n       Return value as a string, not float\n       Hacky fix for not doing for whole numbers: if first item starts with \"#\",\n       we just return the string'''", "\n", "if", "first_item", ".", "strip", "(", ")", ".", "startswith", "(", "\"#\"", ")", ":", "\n", "        ", "return", "string", "\n", "", "try", ":", "\n", "        ", "float", "(", "string", ")", "\n", "if", "float", "(", "string", ")", ">", "0", "and", "float", "(", "string", ")", "<=", "1", "and", "\".\"", "in", "string", ":", "\n", "            ", "return", "str", "(", "round", "(", "float", "(", "string", ")", "*", "multiplier", ",", "do_round", ")", ")", "\n", "", "else", ":", "\n", "            ", "return", "string", "\n", "", "", "except", ":", "\n", "        ", "return", "string", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.create_tab_list": [[157, 184], ["range", "enumerate", "str", "len", "utils_counter.multiply_if_float", "col_widths.append", "return_rows.append", "col_widths.append", "joiner.join", "return_rows.append", "max", "joiner.join", "max", "word.decode().ljust", "len", "enumerate", "word.ljust", "x[].decode", "len", "word.decode", "enumerate"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.multiply_if_float"], ["", "", "def", "create_tab_list", "(", "print_rows", ",", "print_item", ",", "joiner", ",", "do_percentage", "=", "False", ")", ":", "\n", "    ", "'''For multiple rows, return row of strings nicely separated by tabs'''", "\n", "print_rows", "=", "[", "[", "str", "(", "x", ")", "for", "x", "in", "item", "]", "for", "item", "in", "print_rows", "]", "\n", "# Check if we want to change floats between 0 and 1 to their percentage between 0-100", "\n", "# So essentially multiply each float >0 and <1 with 100", "\n", "if", "do_percentage", ":", "\n", "        ", "print_rows", "=", "[", "[", "multiply_if_float", "(", "x", ",", "item", "[", "0", "]", ")", "for", "x", "in", "item", "]", "for", "item", "in", "print_rows", "]", "\n", "", "col_widths", "=", "[", "]", "\n", "if", "print_item", ":", "\n", "        ", "return_rows", "=", "[", "print_item", "]", "\n", "", "else", ":", "\n", "        ", "return_rows", "=", "[", "]", "\n", "", "if", "print_rows", ":", "\n", "        ", "for", "idx", "in", "range", "(", "len", "(", "print_rows", "[", "0", "]", ")", ")", ":", "# for nice printing, calculate max column length", "\n", "            ", "try", ":", "\n", "                ", "col_widths", ".", "append", "(", "max", "(", "[", "len", "(", "x", "[", "idx", "]", ".", "decode", "(", "'utf-8'", ")", ")", "for", "x", "in", "print_rows", "]", ")", "+", "1", ")", "\n", "", "except", "AttributeError", ":", "\n", "# in Python 3 a string is utf8 and has no decode", "\n", "                ", "col_widths", ".", "append", "(", "max", "(", "[", "len", "(", "x", "[", "idx", "]", ")", "for", "x", "in", "print_rows", "]", ")", "+", "1", ")", "\n", "\n", "", "", "for", "idx", ",", "row", "in", "enumerate", "(", "print_rows", ")", ":", "# print rows here, adjusted for column width", "\n", "            ", "try", ":", "\n", "                ", "return_rows", ".", "append", "(", "joiner", ".", "join", "(", "word", ".", "decode", "(", "'utf-8'", ")", ".", "ljust", "(", "col_widths", "[", "col_idx", "]", ")", "for", "col_idx", ",", "word", "in", "enumerate", "(", "row", ")", ")", ")", "\n", "", "except", "AttributeError", ":", "\n", "# in Python 3 a string is utf8 and has no decode", "\n", "                ", "return_rows", ".", "append", "(", "joiner", ".", "join", "(", "word", ".", "ljust", "(", "col_widths", "[", "col_idx", "]", ")", "for", "col_idx", ",", "word", "in", "enumerate", "(", "row", ")", ")", ")", "\n", "", "", "", "return", "return_rows", "\n", "", ""]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.html_results.coda_html": [[8, 55], ["sorted", "enumerate", "len", "html_results.indent", "html_results.lab2num", "map"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.html_results.indent", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.html_results.lab2num"], ["def", "coda_html", "(", "num", ",", "ill_drs_ids", ",", "counts", ",", "measures", ",", "types", ",", "cr_mdict", ")", ":", "\n", "\t", "'''Gets the number of CLFs, ids of ill DRSs, counts for produced, gold and matching clauses,\n\t   evaluation measures like precision, recall and F-scores, the list of detailed metrics, \n\t   and their corresponding evaluation measures.\n\t   Output is an html content representing the input.\n\t'''", "\n", "# unpack tuples", "\n", "(", "prod_cl", ",", "gold_cl", ",", "match_cl", ")", "=", "counts", "\n", "types", "=", "sorted", "(", "types", ",", "key", "=", "lambda", "x", ":", "lab2num", "(", "x", ")", ")", "\n", "# internal css style and other styling", "\n", "style", "=", "(", "\"table, th, td { border: 1px solid black; border-collapse: collapse;}\\n\"", "\n", "\"#tot {background-color: #222; color: #fff; font-weight: bold;}\\n\"", "\n", "\"td {text-align: right;}\\n\"", "\n", "\".ltd {text-align: left;}\\n\"", "\n", "\"th {background-color: #648ca8; color: #fff;}\\n\"", "\n", "\"th, td {padding: 2px 10px 2px 10px;}\\n\"", "\n", "\".oddrow {background-color: #eee;}\\n\"", "\n", "\".evenrow {background-color: #fff;}\\n\"", "\n", "'.mono {font-family: \"Courier New\", Courier, monospace;}\\n'", "\n", ")", "\n", "header", "=", "'<head>\\n<style>\\n{}\\n</style>\\n</head>'", ".", "format", "(", "style", ")", "\n", "tag", "=", "'p'", "\n", "# generating the content", "\n", "body", "=", "'<{0}>Number of system-gold pairs of CLFs: <b>{1}</b></{0}>\\n'", ".", "format", "(", "\n", "tag", ",", "num", ")", "\n", "body", "+=", "'<{0}>Number of ill CLFs (i.e. non-DRSs) produced by the system: <b>{1}</b></{0}>\\n'", ".", "format", "(", "\n", "tag", ",", "len", "(", "ill_drs_ids", ")", ")", "\n", "body", "+=", "'<{0}>Total number of clauses in system / gold CLFs: <b>{1}</b> / <b>{2}</b></{0}>\\n'", ".", "format", "(", "\n", "tag", ",", "prod_cl", ",", "gold_cl", ")", "\n", "body", "+=", "'<{0}>Total number of matching clauses: <b>{1}</b></{0}>\\n'", ".", "format", "(", "\n", "tag", ",", "match_cl", ")", "\n", "# create the table with scores", "\n", "body", "+=", "'<table style=\"width:100%\">\\n'", "\n", "body", "+=", "'<tr>\\n<th>Clause types</th>\\n<th>Precision</th>\\n<th>Recall</th>\\n<th>F-score</th>\\n</tr>\\n'", "\n", "for", "(", "i", ",", "c", ")", "in", "enumerate", "(", "types", ")", ":", "\n", "\t\t", "sty", "=", "'evenrow'", "if", "i", "%", "2", "==", "0", "else", "'oddrow'", "\n", "body", "+=", "'<tr class=\"{}\">\\n<td class=\"ltd\">{}</td>\\n<td>{:.2%}</td>\\n<td>{:.2%}</td>\\n<td>{:.2%}</td>\\n</tr>\\n'", ".", "format", "(", "\n", "sty", ",", "indent", "(", "c", ")", ",", "*", "cr_mdict", "[", "c", "]", ")", "\n", "", "body", "+=", "'<tr id=\"tot\">\\n<td class=\"ltd\">Total</td>\\n<td>{:.2%}</td>\\n<td>{:.2%}</td>\\n<td>{:.2%}</td>\\n</tr>\\n'", ".", "format", "(", "\n", "*", "measures", ")", "\n", "# close the table", "\n", "body", "+=", "'</table>\\n'", "\n", "# print the list of ill-CLF ids ", "\n", "if", "ill_drs_ids", ":", "\n", "\t\t", "body", "+=", "'<p>{}: <span class=\"mono\">{}</span></p>\\n'", ".", "format", "(", "\n", "'IDs of ill CLFs'", ",", "', '", ".", "join", "(", "map", "(", "str", ",", "ill_drs_ids", ")", ")", ")", "\n", "", "return", "'<!DOCTYPE html>\\n<meta charset=utf-8>\\n<html>\\n{}\\n<body>\\n{}\\n</body>\\n</html>'", ".", "format", "(", "header", ",", "body", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.html_results.indent": [[57, 68], ["mapping.get", "label.title"], "function", ["None"], ["", "def", "indent", "(", "label", ",", "n", "=", "4", ")", ":", "\n", "\t", "'''Indent the clause types\n\t   'operators','roles','concepts','nouns','verbs','adjectives','adverbs','events'\n\t'''", "\n", "mapping", "=", "{", "'nouns'", ":", "n", "*", "'&nbsp;'", "+", "'Nouns'", ",", "\n", "'adjectives'", ":", "2", "*", "n", "*", "'&nbsp;'", "+", "'Adjectives'", ",", "\n", "'verbs'", ":", "2", "*", "n", "*", "'&nbsp;'", "+", "'Verbs'", ",", "\n", "'adverbs'", ":", "n", "*", "'&nbsp;'", "+", "'Adverbs'", ",", "\n", "'events'", ":", "n", "*", "'&nbsp;'", "+", "'Events'", "\n", "}", "\n", "return", "mapping", ".", "get", "(", "label", ",", "label", ".", "title", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.html_results.lab2num": [[70, 84], ["None"], "function", ["None"], ["", "def", "lab2num", "(", "label", ")", ":", "\n", "\t", "'''Map the type to a number for the ordering purposes: \n\t   'operators','roles','concepts','nouns','verbs','adjectives','adverbs','events'\n\t'''", "\n", "mapping", "=", "{", "'operators'", ":", "1", ",", "\n", "'roles'", ":", "2", ",", "\n", "'concepts'", ":", "3", ",", "\n", "'events'", ":", "5", ",", "\n", "'nouns'", ":", "4", ",", "\n", "'verbs'", ":", "6", ",", "\n", "'adjectives'", ":", "7", ",", "\n", "'adverbs'", ":", "8", "\n", "}", "\n", "return", "mapping", "[", "label", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.__init__": [[575, 597], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "signature", ")", ":", "\n", "# List of operators who's variables are also boxes, e.g. b0 NOT b1", "\n", "\t\t", "self", ".", "op_boxes", "=", "[", "key", "for", "key", "in", "signature", "if", "signature", "[", "key", "]", "[", "1", "]", "in", "[", "'bb'", ",", "'bbb'", "]", "]", "\n", "# List of operators for which b OP y1 y2 == b1 OP y2 y1", "\n", "self", ".", "inv_boxes", "=", "[", "'APX'", ",", "'NEQ'", ",", "'EQU'", ",", "'TAB'", "]", "\n", "# List for different types of clauses", "\n", "self", ".", "op_two_vars", ",", "self", ".", "op_two_vars_idx", "=", "[", "]", ",", "[", "]", "\n", "self", ".", "op_two_vars_abs1", ",", "self", ".", "op_two_vars_abs_idx1", "=", "[", "]", ",", "[", "]", "\n", "self", ".", "op_two_vars_abs2", ",", "self", ".", "op_two_vars_abs_idx2", "=", "[", "]", ",", "[", "]", "\n", "self", ".", "op_three_vars", ",", "self", ".", "op_three_vars_idx", "=", "[", "]", ",", "[", "]", "\n", "self", ".", "roles_two_abs", ",", "self", ".", "roles_two_abs_idx", "=", "[", "]", ",", "[", "]", "\n", "self", ".", "roles_abs1", ",", "self", ".", "roles_abs_idx1", "=", "[", "]", ",", "[", "]", "\n", "self", ".", "roles_abs2", ",", "self", ".", "roles_abs_idx2", "=", "[", "]", ",", "[", "]", "\n", "self", ".", "roles", ",", "self", ".", "roles_idx", "=", "[", "]", ",", "[", "]", "\n", "self", ".", "concepts", ",", "self", ".", "concepts_idx", "=", "[", "]", ",", "[", "]", "\n", "\n", "# Lists and dicts to keep track of the variable information and rewritten concepts", "\n", "self", ".", "vars_seen", "=", "[", "]", "\n", "self", ".", "type_vars", "=", "{", "}", "\n", "self", ".", "var_map", "=", "{", "}", "\n", "self", ".", "rewritten_concepts", "=", "[", "]", "\n", "self", ".", "added_var_map", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.rename_var": [[598, 608], ["counter.DRS.vars_seen.append", "str", "str", "counter.DRS.vars_seen.index", "len"], "methods", ["None"], ["", "def", "rename_var", "(", "self", ",", "var", ",", "var_type", ",", "args", ")", ":", "\n", "\t\t", "'''Function that renames the variables in a standardized way'''", "\n", "if", "var", "in", "self", ".", "vars_seen", ":", "\n", "\t\t\t", "new_var", "=", "self", ".", "prefix", "+", "str", "(", "self", ".", "vars_seen", ".", "index", "(", "var", ")", ")", "\n", "", "else", ":", "\n", "\t\t\t", "new_var", "=", "self", ".", "prefix", "+", "str", "(", "len", "(", "self", ".", "vars_seen", ")", ")", "\n", "self", ".", "type_vars", "[", "new_var", "]", "=", "var_type", "\n", "self", ".", "vars_seen", ".", "append", "(", "var", ")", "\n", "", "self", ".", "var_map", "[", "new_var", "]", "=", "var", "\n", "return", "new_var", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.add_if_not_exists": [[610, 615], ["list1.append", "list2.append"], "methods", ["None"], ["", "def", "add_if_not_exists", "(", "self", ",", "list1", ",", "list2", ",", "to_add", ",", "to_add2", ")", ":", "\n", "\t\t", "'''Add something to two list of lists if it is not there yet in the first one'''", "\n", "if", "to_add", "not", "in", "list1", ":", "\n", "\t\t\t", "list1", ".", "append", "(", "to_add", ")", "\n", "list2", ".", "append", "(", "to_add2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.add_concept_clauses": [[617, 633], ["counter.DRS.rename_var", "counter.rewrite_concept", "counter.DRS.add_if_not_exists", "counter.DRS.rewritten_concepts.append"], "methods", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.rename_var", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.rewrite_concept", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.add_if_not_exists"], ["", "", "def", "add_concept_clauses", "(", "self", ",", "cur_clause", ",", "val0", ",", "idx", ",", "en_sense_dict", ",", "args", ")", ":", "\n", "\t\t", "'''Add concepts clauses to our list of clauses'''", "\n", "# First rename the variable", "\n", "val3", "=", "self", ".", "rename_var", "(", "cur_clause", "[", "3", "]", ",", "'x'", ",", "args", ")", "\n", "# Then rewrite the concept to its synset ID in WordNet", "\n", "new_concept", ",", "new_sense", ",", "rewritten_values", "=", "rewrite_concept", "(", "cur_clause", "[", "1", "]", ",", "cur_clause", "[", "2", "]", ",", "en_sense_dict", ")", "\n", "# Maybe change concept/sense to a default", "\n", "if", "args", ".", "default_concept", ":", "\n", "\t\t\t", "new_concept", "=", "'work'", "\n", "new_sense", "=", "'\"n.01\"'", "\n", "", "elif", "args", ".", "default_sense", ":", "\n", "\t\t\t", "new_sense", "=", "'\"n.01\"'", "\n", "", "self", ".", "add_if_not_exists", "(", "self", ".", "concepts", ",", "self", ".", "concepts_idx", ",", "(", "val0", ",", "new_concept", ",", "new_sense", ",", "val3", ")", ",", "idx", ")", "\n", "# Save rewritten concepts", "\n", "if", "rewritten_values", ":", "\n", "\t\t\t", "self", ".", "rewritten_concepts", ".", "append", "(", "rewritten_values", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.add_role_clauses": [[635, 656], ["utils_counter.between_quotes", "utils_counter.between_quotes", "counter.DRS.add_if_not_exists", "utils_counter.between_quotes", "counter.DRS.rename_var", "counter.DRS.add_if_not_exists", "utils_counter.between_quotes", "counter.DRS.rename_var", "counter.DRS.add_if_not_exists", "counter.DRS.rename_var", "counter.DRS.rename_var", "counter.DRS.add_if_not_exists"], "methods", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.between_quotes", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.between_quotes", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.add_if_not_exists", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.between_quotes", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.rename_var", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.add_if_not_exists", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.between_quotes", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.rename_var", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.add_if_not_exists", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.rename_var", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.rename_var", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.add_if_not_exists"], ["", "", "def", "add_role_clauses", "(", "self", ",", "cur_clause", ",", "val0", ",", "idx", ",", "args", ")", ":", "\n", "\t\t", "'''Add clauses that have a Role as second item to our list of clauses'''", "\n", "# Check if we want to rewrite the role to a default", "\n", "role", "=", "'Role'", "if", "args", ".", "default_role", "else", "cur_clause", "[", "1", "]", "\n", "\n", "# If second and third item are between quotes it belongs in roles_two_abs (b0 PartOf \"speaker\" \"hearer\")", "\n", "if", "between_quotes", "(", "cur_clause", "[", "2", "]", ")", "and", "between_quotes", "(", "cur_clause", "[", "3", "]", ")", ":", "\n", "\t\t\t", "self", ".", "add_if_not_exists", "(", "self", ".", "roles_two_abs", ",", "self", ".", "roles_two_abs_idx", ",", "(", "val0", ",", "role", ",", "cur_clause", "[", "2", "]", ",", "cur_clause", "[", "3", "]", ")", ",", "idx", ")", "\n", "# If third item is between quotes it belongs in roles_abs1 (b0 PartOf \"speaker\" x2)", "\n", "", "elif", "between_quotes", "(", "cur_clause", "[", "2", "]", ")", ":", "\n", "\t\t\t", "val2", "=", "self", ".", "rename_var", "(", "cur_clause", "[", "3", "]", ",", "'x'", ",", "args", ")", "\n", "self", ".", "add_if_not_exists", "(", "self", ".", "roles_abs1", ",", "self", ".", "roles_abs_idx1", ",", "(", "val0", ",", "role", ",", "cur_clause", "[", "2", "]", ",", "val2", ")", ",", "idx", ")", "\n", "# If last item is between quotes it belongs in roles_abs2 (b0 PartOf x2 \"speaker\")", "\n", "", "elif", "between_quotes", "(", "cur_clause", "[", "3", "]", ")", ":", "\n", "\t\t\t", "val2", "=", "self", ".", "rename_var", "(", "cur_clause", "[", "2", "]", ",", "'x'", ",", "args", ")", "\n", "self", ".", "add_if_not_exists", "(", "self", ".", "roles_abs2", ",", "self", ".", "roles_abs_idx2", ",", "(", "val0", ",", "role", ",", "val2", ",", "cur_clause", "[", "3", "]", ")", ",", "idx", ")", "\n", "# Otherwise it belongs in roles (b1 Patient x1 x2)", "\n", "", "else", ":", "\n", "\t\t\t", "val2", "=", "self", ".", "rename_var", "(", "cur_clause", "[", "2", "]", ",", "'x'", ",", "args", ")", "\n", "val3", "=", "self", ".", "rename_var", "(", "cur_clause", "[", "3", "]", ",", "'x'", ",", "args", ")", "\n", "self", ".", "add_if_not_exists", "(", "self", ".", "roles", ",", "self", ".", "roles_idx", ",", "(", "val0", ",", "role", ",", "val2", ",", "val3", ")", ",", "idx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.add_operator_clauses": [[658, 677], ["utils_counter.between_quotes", "counter.DRS.rename_var", "counter.DRS.add_if_not_exists", "utils_counter.between_quotes", "counter.DRS.rename_var", "counter.DRS.add_if_not_exists", "counter.DRS.rename_var", "counter.DRS.rename_var", "counter.DRS.add_if_not_exists"], "methods", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.between_quotes", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.rename_var", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.add_if_not_exists", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.between_quotes", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.rename_var", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.add_if_not_exists", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.rename_var", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.rename_var", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.add_if_not_exists"], ["", "", "def", "add_operator_clauses", "(", "self", ",", "val0", ",", "cur_clause", ",", "idx", ",", "args", ")", ":", "\n", "\t\t", "'''Add clauses that have an operator as second item to our list of close'''", "\n", "# Get var type of second variable", "\n", "var_type", "=", "'b'", "if", "cur_clause", "[", "1", "]", "in", "self", ".", "op_boxes", "and", "cur_clause", "[", "1", "]", "!=", "'PRP'", "else", "'x'", "\n", "\n", "# If second item between quotes it belongs in op_two_vars_abs1", "\n", "if", "between_quotes", "(", "cur_clause", "[", "2", "]", ")", ":", "\n", "\t\t\t", "val2", "=", "self", ".", "rename_var", "(", "cur_clause", "[", "3", "]", ",", "var_type", ",", "args", ")", "#get renamed variable", "\n", "self", ".", "add_if_not_exists", "(", "self", ".", "op_two_vars_abs1", ",", "self", ".", "op_two_vars_abs_idx1", ",", "(", "val0", ",", "cur_clause", "[", "1", "]", ",", "cur_clause", "[", "2", "]", ",", "val2", ")", ",", "idx", ")", "\n", "# If last item is between quotes it belongs in op_two_vars_abs2 (b2 EQU t1 \"now\")", "\n", "", "elif", "between_quotes", "(", "cur_clause", "[", "3", "]", ")", ":", "\n", "\t\t\t", "val2", "=", "self", ".", "rename_var", "(", "cur_clause", "[", "2", "]", ",", "var_type", ",", "args", ")", "#get renamed variable", "\n", "self", ".", "add_if_not_exists", "(", "self", ".", "op_two_vars_abs2", ",", "self", ".", "op_two_vars_abs_idx2", ",", "(", "val0", ",", "cur_clause", "[", "1", "]", ",", "val2", ",", "cur_clause", "[", "3", "]", ")", ",", "idx", ")", "\n", "# Else it belongs in op_three_vars (b1 LES x1 x2)", "\n", "", "else", ":", "\n", "\t\t\t", "val2", "=", "self", ".", "rename_var", "(", "cur_clause", "[", "2", "]", ",", "var_type", ",", "args", ")", "#get renamed variable", "\n", "var_type", "=", "'b'", "if", "cur_clause", "[", "1", "]", "in", "self", ".", "op_boxes", "else", "'x'", "\n", "val3", "=", "self", ".", "rename_var", "(", "cur_clause", "[", "3", "]", ",", "var_type", ",", "args", ")", "\n", "self", ".", "add_if_not_exists", "(", "self", ".", "op_three_vars", ",", "self", ".", "op_three_vars_idx", ",", "(", "val0", ",", "cur_clause", "[", "1", "]", ",", "val2", ",", "val3", ")", ",", "idx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.get_specific_clauses": [[679, 721], ["enumerate", "len", "len", "len", "len", "len", "len", "len", "counter.DRS.rename_var", "counter.DRS.rename_var", "counter.DRS.add_if_not_exists", "counter.DRS.rename_var", "utils_counter.all_upper", "len", "len", "len", "len", "counter.DRS.add_operator_clauses", "utils_counter.is_role", "counter.DRS.add_role_clauses", "counter.DRS.add_concept_clauses"], "methods", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.rename_var", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.rename_var", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.add_if_not_exists", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.rename_var", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.all_upper", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.add_operator_clauses", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.is_role", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.add_role_clauses", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.add_concept_clauses"], ["", "", "def", "get_specific_clauses", "(", "self", ",", "clause_list", ",", "en_sense_dict", ",", "args", ")", ":", "\n", "\t\t", "'''Function that gets the specific clauses\n\t\t   Also renames them and changes their format to DRS format\n\t\t   Keep track of indices so we can easily print matching DRSs later\n\t\t   Different types:\n\t\t\t\top_two_vars      : b0 REF x1\n\t\t\t\top_two_vars_abs1 : b2 EQU t1 \"now\"\n\t\t\t\top_two_vars_abs2 : b2 EQU \"now\" t1\n\t\t\t\top_three_vars    : b1 LES x1 x2\n\t\t\t\troles_abs1       : b0 PartOf x2 \"speaker\"\n\t\t\t\troles_abs2       : b0 PartOf \"speaker\" x2\n\t\t\t\troles_two_abs    : b0 PartOf \"hearer\" \"speaker\"\n\t\t\t\troles            : b0 Patient x1 x2\n\t\t\t\tconcepts         : b1 work \"v.01\" x2'''", "\n", "\n", "# Operators that have two box variables", "\n", "for", "idx", ",", "cur_clause", "in", "enumerate", "(", "clause_list", ")", ":", "\n", "\t\t\t", "if", "len", "(", "cur_clause", ")", "<", "3", ":", "\n", "                                ", "continue", "\n", "#print(cur_clause)", "\n", "# Clause has three items and belongs in op_two_vars (b0 REF x1 ,  b0 NOT b1)", "\n", "", "elif", "len", "(", "cur_clause", ")", "==", "3", ":", "\n", "\t\t\t\t", "val0", "=", "self", ".", "rename_var", "(", "cur_clause", "[", "0", "]", ",", "'b'", ",", "args", ")", "\n", "var_type", "=", "'b'", "if", "cur_clause", "[", "1", "]", "in", "self", ".", "op_boxes", "else", "'x'", "\n", "val2", "=", "self", ".", "rename_var", "(", "cur_clause", "[", "2", "]", ",", "var_type", ",", "args", ")", "\n", "self", ".", "add_if_not_exists", "(", "self", ".", "op_two_vars", ",", "self", ".", "op_two_vars_idx", ",", "(", "val0", ",", "cur_clause", "[", "1", "]", ",", "val2", ")", ",", "idx", ")", "\n", "# Clause has 4 items", "\n", "", "else", ":", "\n", "# First item always is a box variable", "\n", "\t\t\t\t", "val0", "=", "self", ".", "rename_var", "(", "cur_clause", "[", "0", "]", ",", "'b'", ",", "args", ")", "\n", "if", "all_upper", "(", "cur_clause", "[", "1", "]", ")", ":", "# Second item is an operator", "\n", "\t\t\t\t\t", "self", ".", "add_operator_clauses", "(", "val0", ",", "cur_clause", ",", "idx", ",", "args", ")", "\n", "", "elif", "is_role", "(", "cur_clause", "[", "1", "]", ")", ":", "# Second item is a role", "\n", "\t\t\t\t\t", "self", ".", "add_role_clauses", "(", "cur_clause", ",", "val0", ",", "idx", ",", "args", ")", "\n", "", "else", ":", "# Otherwise it must be a concept (b1 work \"v.01\" x2)", "\n", "\t\t\t\t\t", "self", ".", "add_concept_clauses", "(", "cur_clause", ",", "val0", ",", "idx", ",", "en_sense_dict", ",", "args", ")", "\n", "\n", "# Get number of operator/role/concept clauses", "\n", "", "", "", "self", ".", "num_operators", "=", "len", "(", "self", ".", "op_two_vars", ")", "+", "len", "(", "self", ".", "op_two_vars_abs1", ")", "+", "len", "(", "self", ".", "op_two_vars_abs2", ")", "+", "len", "(", "self", ".", "op_three_vars", ")", "\n", "self", ".", "num_roles", "=", "len", "(", "self", ".", "roles", ")", "+", "len", "(", "self", ".", "roles_abs1", ")", "+", "len", "(", "self", ".", "roles_abs2", ")", "+", "len", "(", "self", ".", "roles_two_abs", ")", "\n", "self", ".", "num_concepts", "=", "len", "(", "self", ".", "concepts", ")", "\n", "self", ".", "total_clauses", "=", "self", ".", "num_operators", "+", "self", ".", "num_roles", "+", "self", ".", "num_concepts", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.build_arg_parser": [[79, 172], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "os.path.exists", "ValueError", "os.path.exists", "ValueError", "NotImplementedError", "ValueError", "print", "time.sleep", "print", "time.sleep", "print", "time.sleep", "NotImplementedError", "print", "time.sleep"], "function", ["None"], ["def", "build_arg_parser", "(", ")", ":", "\n", "\t", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "\"Counter calculator -- arguments\"", ")", "\n", "# Main arguments", "\n", "parser", ".", "add_argument", "(", "'-f1'", ",", "required", "=", "True", ",", "type", "=", "str", ",", "\n", "help", "=", "'First file with DRS clauses, DRSs need to be separated by blank line'", ")", "\n", "parser", ".", "add_argument", "(", "'-f2'", ",", "required", "=", "True", ",", "type", "=", "str", ",", "\n", "help", "=", "'Second file with DRS clauses, DRSs need to be separated by blank line'", ")", "\n", "\n", "# Optimization (memory, speed, restarts, initial mappings)", "\n", "parser", ".", "add_argument", "(", "'-r'", ",", "'--restarts'", ",", "type", "=", "int", ",", "\n", "default", "=", "20", ",", "help", "=", "'Restart number (default: 20)'", ")", "\n", "parser", ".", "add_argument", "(", "'-p'", ",", "'--parallel'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'Number of parallel threads we use (default 1)'", ")", "\n", "parser", ".", "add_argument", "(", "'-mem'", ",", "'--mem_limit'", ",", "type", "=", "int", ",", "default", "=", "1000", ",", "\n", "help", "=", "'Memory limit in MBs (default 1000 -> 1G). Note that this is per parallel thread! If you use -par 4, each thread gets 1000 MB with default settings.'", ")", "\n", "parser", ".", "add_argument", "(", "'-s'", ",", "'--smart'", ",", "default", "=", "'conc'", ",", "action", "=", "'store'", ",", "choices", "=", "[", "\n", "'no'", ",", "'conc'", "]", ",", "help", "=", "'What kind of smart mapping do we use (default concepts)'", ")", "\n", "\n", "# Output settings (often not necessary to add or change), for example printing specific stats to a file, or to the screen", "\n", "parser", ".", "add_argument", "(", "'-prin'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Print very specific output - matching and non-matching clauses and specific F-scores for smart mappings'", ")", "\n", "parser", ".", "add_argument", "(", "'-ms'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "\n", "help", "=", "'Output multiple scores (one pair per score) instead of a single document-level score (Default: false)'", ")", "\n", "parser", ".", "add_argument", "(", "'-ms_file'", ",", "default", "=", "''", ",", "\n", "help", "=", "'The file where we print the individual scores per DRS to -- one score per line (float) -- default empty means do not print to file'", ")", "\n", "parser", ".", "add_argument", "(", "'-al'", ",", "'--all_idv'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Add all idv information in the --ms_file file (match, prod, gold), not just the F-score'", ")", "\n", "parser", ".", "add_argument", "(", "'-sig'", ",", "'--significant'", ",", "type", "=", "int", ",", "\n", "default", "=", "4", ",", "help", "=", "'significant digits to output (default: 4)'", ")", "\n", "parser", ".", "add_argument", "(", "'-st'", ",", "'--stats'", ",", "default", "=", "''", ",", "type", "=", "str", ",", "\n", "help", "=", "'If added this is the file we print a pickled dictionary to with statistics about number of clauses and variables.'", ")", "\n", "parser", ".", "add_argument", "(", "'-ds'", ",", "'--detailed_stats'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'If we add a value > 0 we print statistics about individual types of clauses that match or do not match, e.g. how well do we do on producing Theme, default 0 means do nothing'", ")", "\n", "parser", ".", "add_argument", "(", "'-nm'", ",", "'--no_mapping'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'If added, do not print the mapping of variables in terms of clauses'", ")", "\n", "parser", ".", "add_argument", "(", "'-g'", ",", "'--signature'", ",", "dest", "=", "'sig_file'", ",", "default", "=", "''", ",", "\n", "help", "=", "'If added, this contains a file with all allowed roles otherwise a simple signature is used that\\\n              \t\t\t\t  mainly recognizes operators based on their formatting'", ")", "\n", "parser", ".", "add_argument", "(", "'-coda'", ",", "'--codalab'", ",", "default", "=", "''", ",", "\n", "help", "=", "'a filename for which evaluation results for CodaLab are written in filename.txt and filename.html (default no writing)'", ")", "\n", "\n", "# Experiments with changing the input/output, or the matching algorithm", "\n", "# If you add this the results will differ from the general F-score", "\n", "parser", ".", "add_argument", "(", "'-ill'", ",", "default", "=", "'error'", ",", "choices", "=", "[", "'error'", ",", "'dummy'", ",", "'spar'", ",", "'score'", "]", ",", "\n", "help", "=", "'What to do when encountering an ill-formed DRS. Throw an error (default), input dummy or spar DRS, or give a score anyway (those scores are not official though!)'", ")", "\n", "parser", ".", "add_argument", "(", "'-runs'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'Usually we do 1 run, only for experiments we can increase the number of runs to get a better average'", ")", "\n", "parser", ".", "add_argument", "(", "'-m'", ",", "'--max_clauses'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'Maximum number of clauses for DRS (default 0 means no limit)'", ")", "\n", "parser", ".", "add_argument", "(", "'-b'", ",", "'--baseline'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "\n", "help", "=", "\"Helps in deciding a good baseline DRS. If added, prod-file must be a single DRS, gold file a number of DRSs to compare to (default false)\"", ")", "\n", "parser", ".", "add_argument", "(", "'-pa'", ",", "'--partial'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Do partial matching for the DRSs (experimental!)'", ")", "\n", "parser", ".", "add_argument", "(", "'-dse'", ",", "'--default_sense'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Add a default sense for all word-senses (exclude effect of getting sense correct)'", ")", "\n", "parser", ".", "add_argument", "(", "'-dr'", ",", "'--default_role'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Add a default role for all role clauses (exclude effect of getting role correct)'", ")", "\n", "parser", ".", "add_argument", "(", "'-dc'", ",", "'--default_concept'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Add a default concept + sense for all concept clauses (exclude effect of getting concepts correct)'", ")", "\n", "parser", ".", "add_argument", "(", "'-ic'", ",", "'--include_ref'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Include REF clauses when matching -- will inflate the scores'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "# Check if files exist", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "args", ".", "f1", ")", ":", "\n", "\t\t", "raise", "ValueError", "(", "\"File for -f1 does not exist\"", ")", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "args", ".", "f2", ")", ":", "\n", "\t\t", "raise", "ValueError", "(", "\"File for -f2 does not exist\"", ")", "\n", "\n", "# Check if combination of arguments is valid", "\n", "", "if", "args", ".", "ms", "and", "args", ".", "runs", ">", "1", ":", "\n", "\t\t", "raise", "NotImplementedError", "(", "\"Not implemented to average over individual scores, only use -ms when doing a single run\"", ")", "\n", "", "if", "args", ".", "restarts", "<", "1", ":", "\n", "\t\t", "raise", "ValueError", "(", "'Number of restarts must be larger than 0'", ")", "\n", "\n", "", "if", "args", ".", "ms", "and", "args", ".", "parallel", ">", "1", ":", "\n", "\t\t", "print", "(", "'WARNING: using -ms and -p > 1 messes up printing to screen - not recommended'", ")", "\n", "time", ".", "sleep", "(", "5", ")", "# so people can still read the warning", "\n", "\n", "", "if", "args", ".", "ill", "in", "[", "'dummy'", ",", "'spar'", "]", ":", "\n", "\t\t", "print", "(", "'WARNING: by using -ill {0}, ill-formed DRSs are replaced by a {0} DRS'", ".", "format", "(", "args", ".", "ill", ")", ")", "\n", "time", ".", "sleep", "(", "3", ")", "\n", "", "elif", "args", ".", "ill", "==", "'score'", ":", "\n", "\t\t", "print", "(", "'WARNING: ill-formed DRSs are given a score as if they were valid -- results in unofficial F-scores'", ")", "\n", "time", ".", "sleep", "(", "3", ")", "\n", "\n", "", "if", "args", ".", "runs", ">", "1", "and", "args", ".", "prin", ":", "\n", "\t\t", "print", "(", "'WARNING: we do not print specific information (-prin) for runs > 1, only final averages'", ")", "\n", "time", ".", "sleep", "(", "5", ")", "\n", "\n", "", "if", "args", ".", "partial", ":", "\n", "\t\t", "raise", "NotImplementedError", "(", "'Partial matching currently does not work'", ")", "\n", "", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.remove_refs": [[174, 193], ["enumerate", "enumerate", "final_clauses.append", "final_original.append", "len", "cur_tup.append", "cur_orig.append", "counter.var_occurs", "cur_tup.append", "cur_orig.append"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.var_occurs"], ["", "def", "remove_refs", "(", "clause_list", ",", "original_clauses", ")", ":", "\n", "\t", "'''Remove unneccessary/redundant b REF x clauses, only keep them if x never occurs again in the same box'''", "\n", "final_clauses", ",", "final_original", "=", "[", "]", ",", "[", "]", "\n", "for", "tup_idx", ",", "tup_set", "in", "enumerate", "(", "clause_list", ")", ":", "\n", "\t\t", "cur_tup", "=", "[", "]", "\n", "cur_orig", "=", "[", "]", "\n", "for", "idx", ",", "spl_tup", "in", "enumerate", "(", "tup_set", ")", ":", "\n", "\t\t\t", "if", "len", "(", "spl_tup", ")", "<", "3", ":", "\n", "\t\t\t\t", "continue", "\n", "", "elif", "spl_tup", "[", "1", "]", "==", "'REF'", ":", "\n", "\t\t\t\t", "if", "not", "var_occurs", "(", "tup_set", ",", "spl_tup", "[", "2", "]", ",", "spl_tup", "[", "0", "]", ",", "idx", ")", ":", "# only add if the variable does not occur afterwards", "\n", "\t\t\t\t\t", "cur_tup", ".", "append", "(", "spl_tup", ")", "\n", "cur_orig", ".", "append", "(", "original_clauses", "[", "tup_idx", "]", "[", "idx", "]", ")", "\n", "", "", "else", ":", "\n", "\t\t\t\t", "cur_tup", ".", "append", "(", "spl_tup", ")", "\n", "cur_orig", ".", "append", "(", "original_clauses", "[", "tup_idx", "]", "[", "idx", "]", ")", "\n", "", "", "final_clauses", ".", "append", "(", "cur_tup", ")", "\n", "final_original", ".", "append", "(", "cur_orig", ")", "\n", "", "return", "final_clauses", ",", "final_original", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_clauses": [[195, 263], ["open", "in_f.read().split", "enumerate", "clause_list.append", "original_clauses.append", "counter.DRS", "counter.remove_refs", "line.strip().startswith", "in_f.read", "len", "line.strip", "line.strip", "cur_clauses.append", "cur_orig.append", "utils_counter.is_role", "clause[].endswith", "[].strip().split", "len", "len", "utils_counter.between_quotes", "clause_list.append", "original_clauses.append", "len", "utils_counter.between_quotes", "[].strip", "ValueError", "print", "clause_list.append", "original_clauses.append", "utils_counter.dummy_drs", "print", "clause_list.append", "original_clauses.append", "line.split", "utils_counter.spar_drs", "print", "clause_list.append", "original_clauses.append", "len", "utils_counter.dummy_drs", "len", "utils_counter.spar_drs", "len"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.remove_refs", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.is_role", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.between_quotes", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.between_quotes", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.dummy_drs", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.spar_drs", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.dummy_drs", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.spar_drs"], ["", "def", "get_clauses", "(", "file_name", ",", "signature", ",", "ill_type", ")", ":", "\n", "\t", "'''Function that returns a list of DRSs (that consists of clauses)'''", "\n", "clause_list", ",", "original_clauses", ",", "cur_orig", ",", "cur_clauses", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "with", "open", "(", "file_name", ",", "'r'", ")", "as", "in_f", ":", "\n", "\t\t", "input_lines", "=", "in_f", ".", "read", "(", ")", ".", "split", "(", "'\\n'", ")", "\n", "for", "idx", ",", "line", "in", "enumerate", "(", "input_lines", ")", ":", "\n", "\t\t\t", "if", "line", ".", "strip", "(", ")", ".", "startswith", "(", "'%'", ")", ":", "\n", "\t\t\t\t", "pass", "# skip comments", "\n", "", "elif", "not", "line", ".", "strip", "(", ")", ":", "\n", "\t\t\t\t", "if", "cur_clauses", ":", "# newline, so DRS is finished, add to list. Ignore double/clause newlines", "\n", "# First check if the DRS is valid, will error if invalid", "\n", "\t\t\t\t\t", "try", ":", "\n", "# Deactivate check_if function", "\n", "# check_clf([tuple(c) for c in cur_clauses], signature, v=False)", "\n", "\t\t\t\t\t\t", "clause_list", ".", "append", "(", "cur_clauses", ")", "\n", "original_clauses", ".", "append", "(", "cur_orig", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "\t\t\t\t\t\t", "if", "ill_type", "==", "'error'", ":", "\n", "\t\t\t\t\t\t\t", "raise", "ValueError", "(", "e", ")", "\n", "", "elif", "ill_type", "==", "'dummy'", ":", "\n", "# FIXME: uncomment", "\n", "\t\t\t\t\t\t\t", "print", "(", "'WARNING: DRS {0} is ill-formed and replaced by a dummy DRS'", ".", "format", "(", "len", "(", "clause_list", ")", "+", "1", ")", ")", "\n", "clause_list", ".", "append", "(", "dummy_drs", "(", ")", ")", "\n", "original_clauses", ".", "append", "(", "[", "\" \"", ".", "join", "(", "x", ")", "for", "x", "in", "dummy_drs", "(", ")", "]", ")", "\n", "", "elif", "ill_type", "==", "'spar'", ":", "\n", "\t\t\t\t\t\t\t", "print", "(", "'WARNING: DRS {0} is ill-formed and replaced by the SPAR DRS'", ".", "format", "(", "len", "(", "clause_list", ")", "+", "1", ")", ")", "\n", "clause_list", ".", "append", "(", "spar_drs", "(", ")", ")", "\n", "original_clauses", ".", "append", "(", "[", "\" \"", ".", "join", "(", "x", ")", "for", "x", "in", "spar_drs", "(", ")", "]", ")", "\n", "", "elif", "ill_type", "==", "'score'", ":", "\n", "\t\t\t\t\t\t\t", "print", "(", "'WARNING: DRS {0} is ill-formed, but try to give a score anyway - might still error later'", ".", "format", "(", "len", "(", "clause_list", ")", "+", "1", ")", ")", "\n", "\n", "clause_list", ".", "append", "(", "cur_clauses", ")", "\n", "original_clauses", ".", "append", "(", "cur_orig", ")", "\n", "", "", "", "cur_clauses", "=", "[", "]", "\n", "cur_orig", "=", "[", "]", "\n", "", "else", ":", "\n", "\t\t\t\t", "cur_clauses", ".", "append", "(", "line", ".", "split", "(", "' %'", ",", "1", ")", "[", "0", "]", ".", "strip", "(", ")", ".", "split", "(", ")", ")", "#remove comments", "\n", "cur_orig", ".", "append", "(", "line", ")", "\n", "\n", "", "", "", "if", "cur_clauses", ":", "# no newline at the end, still add the DRS", "\n", "\t\t", "clause_list", ".", "append", "(", "cur_clauses", ")", "\n", "original_clauses", ".", "append", "(", "cur_orig", ")", "\n", "\n", "# Invert -of relations and reorder inv_boxes if they contain a constant between quotes", "\n", "", "inv_boxes", "=", "DRS", "(", "signature", ")", ".", "inv_boxes", "\n", "for", "drs", "in", "clause_list", ":", "\n", "\t\t", "for", "clause", "in", "drs", ":", "\n", "\t\t\t", "if", "len", "(", "clause", ")", "<", "3", ":", "\n", "\t\t\t\t", "continue", "\n", "", "elif", "len", "(", "clause", ")", "==", "4", "and", "is_role", "(", "clause", "[", "1", "]", ")", "and", "clause", "[", "1", "]", ".", "endswith", "(", "'Of'", ")", "and", "len", "(", "clause", "[", "1", "]", ")", ">", "2", ":", "\n", "# Switch clauses and remove the -Of", "\n", "\t\t\t\t", "clause", "[", "2", "]", ",", "clause", "[", "3", "]", "=", "clause", "[", "3", "]", ",", "clause", "[", "2", "]", "\n", "clause", "[", "1", "]", "=", "clause", "[", "1", "]", "[", ":", "-", "2", "]", "\n", "", "elif", "clause", "[", "1", "]", "in", "inv_boxes", "and", "len", "(", "clause", ")", "==", "4", "and", "between_quotes", "(", "clause", "[", "2", "]", ")", "and", "not", "between_quotes", "(", "clause", "[", "3", "]", ")", ":", "\n", "# b1 NEQ x1 x2 is equal to b1 NEQ x2 x1", "\n", "# If one of the two arguments is between quotes, rewrite them in such a way", "\n", "# that it can always match", "\n", "# For example rewrite b1 NEQ \"speaker\" x1 to b1 NEQ x1 \"speaker\"", "\n", "# If there are two variables or two items between quotes, do nothing", "\n", "\t\t\t\t", "clause", "[", "2", "]", ",", "clause", "[", "3", "]", "=", "clause", "[", "3", "]", ",", "clause", "[", "2", "]", "\n", "\n", "# If we want to include REF clauses we are done now", "\n", "", "", "", "if", "args", ".", "include_ref", ":", "\n", "\t\t", "return", "clause_list", ",", "original_clauses", "\n", "", "else", ":", "#else remove redundant REF clauses", "\n", "\t\t", "final_clauses", ",", "final_original", "=", "remove_refs", "(", "clause_list", ",", "original_clauses", ")", "\n", "return", "final_clauses", ",", "final_original", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.var_occurs": [[265, 274], ["range", "len", "len"], "function", ["None"], ["", "", "def", "var_occurs", "(", "clauses", ",", "var", ",", "box", ",", "idx", ")", ":", "\n", "\t", "'''Check if variable occurs with same box in one of the next clauses'''", "\n", "for", "cur_idx", "in", "range", "(", "0", ",", "len", "(", "clauses", ")", ")", ":", "\n", "\t\t", "spl_tup", "=", "clauses", "[", "cur_idx", "]", "\n", "if", "len", "(", "spl_tup", ")", "<", "3", ":", "\n", "\t\t\t ", "continue", "\n", "", "elif", "cur_idx", "!=", "idx", "and", "spl_tup", "[", "0", "]", "==", "box", "and", "(", "var", "==", "spl_tup", "[", "-", "1", "]", "or", "var", "==", "spl_tup", "[", "-", "2", "]", ")", ":", "\n", "\t\t\t", "return", "True", "\n", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.rewrite_concept": [[276, 291], ["sense.replace", "conc_sense.split", "conc_sense.split"], "function", ["None"], ["", "def", "rewrite_concept", "(", "concept", ",", "sense", ",", "en_sense_dict", ")", ":", "\n", "\t", "'''Rewrite concepts to their WordNet 3.0 synset IDs'''", "\n", "fixed_sense", "=", "sense", ".", "replace", "(", "'\"'", ",", "''", ")", "#replace quotes", "\n", "dict_key", "=", "concept", "+", "'.'", "+", "fixed_sense", "\n", "if", "dict_key", "not", "in", "en_sense_dict", ":", "#not in WordNet, return original values", "\n", "\t\t", "return", "concept", ",", "sense", ",", "[", "]", "\n", "", "else", ":", "\n", "\t\t", "conc_sense", "=", "en_sense_dict", "[", "dict_key", "]", "\n", "# Now divide back again in concept + sense with quotes", "\n", "new_concept", "=", "\".\"", ".", "join", "(", "conc_sense", ".", "split", "(", "'.'", ")", "[", "0", ":", "-", "2", "]", ")", "\n", "new_sense", "=", "'\"'", "+", "\".\"", ".", "join", "(", "conc_sense", ".", "split", "(", "'.'", ")", "[", "-", "2", ":", "]", ")", "+", "'\"'", "\n", "if", "dict_key", "==", "conc_sense", ":", "#nothing normalized after all", "\n", "\t\t\t", "return", "new_concept", ",", "new_sense", ",", "[", "]", "\n", "", "else", ":", "\n", "\t\t\t", "return", "new_concept", ",", "new_sense", ",", "[", "dict_key", ",", "conc_sense", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.fill_baseline_list": [[293, 296], ["range", "len"], "function", ["None"], ["", "", "", "def", "fill_baseline_list", "(", "baseline_drs", ",", "clauses_gold_list", ")", ":", "\n", "\t", "'''Fill baseline drss so that we can compare all DRSs to a baseline'''", "\n", "return", "[", "baseline_drs", "for", "_", "in", "range", "(", "len", "(", "clauses_gold_list", ")", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_clause_id": [[298, 307], ["clause.split", "len", "utils_counter.all_upper", "utils_counter.is_role", "spl_line[].replace"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.all_upper", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.is_role"], ["", "def", "get_clause_id", "(", "clause", ")", ":", "\n", "\t", "'''Get individual clause ID, e.g. Theme, work, IMP\n\t   However, for concepts we also want the sense!'''", "\n", "spl_line", "=", "clause", ".", "split", "(", ")", "\n", "if", "len", "(", "spl_line", ")", ">", "2", ":", "\n", "\t\t", "if", "all_upper", "(", "spl_line", "[", "1", "]", ")", "or", "is_role", "(", "spl_line", "[", "1", "]", ")", ":", "\n", "\t\t\t", "return", "spl_line", "[", "1", "]", "\n", "", "else", ":", "\n", "\t\t\t", "return", "spl_line", "[", "1", "]", "+", "'.'", "+", "spl_line", "[", "2", "]", ".", "replace", "(", "'\"'", ",", "''", ")", "#get sense without quotes", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_num_concepts": [[309, 323], ["utils_counter.all_upper", "utils_counter.is_role", "print", "clause[].split"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.all_upper", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.is_role"], ["", "", "", "def", "get_num_concepts", "(", "clause_list", ",", "pos_tag", ")", ":", "\n", "\t", "'''Get the number of concepts with a certain pos-tag'''", "\n", "num_concepts", "=", "0", "\n", "for", "clause", "in", "clause_list", ":", "\n", "\t\t", "if", "not", "all_upper", "(", "clause", "[", "1", "]", ")", "and", "not", "is_role", "(", "clause", "[", "1", "]", ")", ":", "\n", "\t\t\t", "try", ":", "\n", "\t\t\t\t", "cur_pos_tag", "=", "clause", "[", "2", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "[", "-", "1", "]", "\n", "if", "cur_pos_tag", "==", "'s'", ":", "\n", "\t\t\t\t\t", "cur_pos_tag", "=", "'a'", "# a and a are both adjectives", "\n", "", "if", "cur_pos_tag", "==", "pos_tag", ":", "\n", "\t\t\t\t\t", "num_concepts", "+=", "1", "\n", "", "", "except", ":", "\n", "\t\t\t\t", "print", "(", "'Strange concept clause'", ",", "\" \"", ".", "join", "(", "clause", ")", ")", "\n", "", "", "", "return", "num_concepts", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_detailed_results": [[325, 351], ["clause.split", "utils_counter.all_upper", "utils_counter.is_role", "clause.split.index", "print", "spl_line[].split", "possible_tags.index"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.all_upper", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.is_role"], ["", "def", "get_detailed_results", "(", "match", ")", ":", "\n", "\t", "'''Get more detailed results regarding matching concepts, for nouns, verbs, adjectives and adverbs'''", "\n", "match_division", "=", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "possible_tags", "=", "[", "'n'", ",", "'v'", ",", "'a'", ",", "'r'", "]", "# possible tags of WordNet concepts currently", "\n", "event_tags", "=", "[", "'v'", ",", "'a'", "]", "# tags that introduce events", "\n", "for", "clause", "in", "[", "x", "[", "0", "]", "for", "x", "in", "match", "]", ":", "\n", "\t\t", "spl_line", "=", "clause", ".", "split", "(", ")", "\n", "if", "'%'", "in", "spl_line", ":", "\n", "\t\t\t", "spl_line", "=", "spl_line", "[", "0", ":", "spl_line", ".", "index", "(", "'%'", ")", "]", "\n", "", "if", "all_upper", "(", "spl_line", "[", "1", "]", ")", ":", "\n", "\t\t\t", "match_division", "[", "0", "]", "+=", "1", "\n", "", "elif", "is_role", "(", "spl_line", "[", "1", "]", ")", ":", "\n", "\t\t\t", "match_division", "[", "1", "]", "+=", "1", "\n", "", "else", ":", "#concepts, but also division of concepts", "\n", "\t\t\t", "match_division", "[", "2", "]", "+=", "1", "\n", "try", ":", "\n", "\t\t\t\t", "pos_tag", "=", "spl_line", "[", "2", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "[", "-", "1", "]", "\n", "if", "pos_tag", "==", "'s'", ":", "#actually s and a are the same", "\n", "\t\t\t\t\t", "pos_tag", "=", "'a'", "\n", "", "if", "pos_tag", "in", "possible_tags", ":", "\n", "\t\t\t\t\t", "match_division", "[", "possible_tags", ".", "index", "(", "pos_tag", ")", "+", "3", "]", "+=", "1", "\n", "", "if", "pos_tag", "in", "event_tags", ":", "\n", "\t\t\t\t\t", "match_division", "[", "7", "]", "+=", "1", "\n", "", "", "except", ":", "\n", "\t\t\t\t", "print", "(", "'Strange concept clause:'", ",", "\" \"", ".", "join", "(", "spl_line", ")", ")", "\n", "", "", "", "return", "match_division", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_mappings": [[353, 423], ["sorted", "sorted", "sorted", "round", "round", "utils_counter.create_tab_list", "utils_counter.create_tab_list", "counter.get_detailed_results", "match.append", "orig_prod_idx_match.append", "orig_gold_idx_match.append", "counter.get_clause_id", "no_match.append", "counter.get_clause_id", "counter.get_clause_id", "ValueError", "no_match.append", "len", "float", "len", "float", "range", "range", "zip", "len", "len"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.create_tab_list", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.create_tab_list", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_detailed_results", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_clause_id", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_clause_id", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_clause_id"], ["", "def", "get_mappings", "(", "clause_pairs", ",", "prod_drs", ",", "gold_drs", ",", "prec", ",", "rec", ",", "significant", ")", ":", "\n", "\t", "'''Output the matching and non-matching clauses'''", "\n", "\n", "# Flatten lists of lists to get list of indices", "\n", "indices_prod", "=", "prod_drs", ".", "op_two_vars_idx", "+", "prod_drs", ".", "op_two_vars_abs_idx1", "+", "prod_drs", ".", "op_two_vars_abs_idx2", "+", "prod_drs", ".", "op_three_vars_idx", "+", "prod_drs", ".", "roles_two_abs_idx", "+", "prod_drs", ".", "roles_abs_idx1", "+", "prod_drs", ".", "roles_abs_idx2", "+", "prod_drs", ".", "roles_idx", "+", "prod_drs", ".", "concepts_idx", "\n", "indices_gold", "=", "gold_drs", ".", "op_two_vars_idx", "+", "gold_drs", ".", "op_two_vars_abs_idx1", "+", "gold_drs", ".", "op_two_vars_abs_idx2", "+", "gold_drs", ".", "op_three_vars_idx", "+", "gold_drs", ".", "roles_two_abs_idx", "+", "gold_drs", ".", "roles_abs_idx1", "+", "gold_drs", ".", "roles_abs_idx2", "+", "gold_drs", ".", "roles_idx", "+", "gold_drs", ".", "concepts_idx", "\n", "\n", "idv_dict", "=", "{", "}", "#idv_dict is used to save information about individual matches, e.g. what is the F-score for \"Theme\" only", "\n", "match", ",", "no_match", ",", "orig_prod_idx_match", ",", "orig_gold_idx_match", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "# First get all matches and order them based on gold occurence", "\n", "ordered_clauses", "=", "[", "[", "indices_prod", "[", "idx2", "]", ",", "indices_gold", "[", "idx1", "]", "]", "for", "idx1", ",", "idx2", "in", "clause_pairs", "]", "\n", "for", "idx_prod", ",", "idx_gold", "in", "sorted", "(", "ordered_clauses", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ")", ":", "\n", "\t\t", "match", ".", "append", "(", "[", "prod_drs", ".", "original_clauses", "[", "idx_prod", "]", ",", "gold_drs", ".", "original_clauses", "[", "idx_gold", "]", "]", ")", "\n", "orig_prod_idx_match", ".", "append", "(", "idx_prod", ")", "\n", "orig_gold_idx_match", ".", "append", "(", "idx_gold", ")", "\n", "\n", "#Save specific information about clause ID (Theme, work.n.01, IMP) here", "\n", "clause_id", "=", "get_clause_id", "(", "prod_drs", ".", "original_clauses", "[", "idx_prod", "]", ")", "\n", "if", "clause_id", "not", "in", "idv_dict", ":", "\n", "\t\t\t", "idv_dict", "[", "clause_id", "]", "=", "[", "1", ",", "1", ",", "1", "]", "#contains [match_num, prod_num, gold_num]", "\n", "", "else", ":", "\n", "\t\t\t", "idv_dict", "[", "clause_id", "]", "=", "[", "x", "+", "y", "for", "x", ",", "y", "in", "zip", "(", "idv_dict", "[", "clause_id", "]", ",", "[", "1", ",", "1", ",", "1", "]", ")", "]", "\n", "\n", "# Get which indices match and do no match (do sorted for no match so that we have some kind of order still)", "\n", "", "", "no_match_prod", "=", "sorted", "(", "[", "x", "for", "x", "in", "range", "(", "len", "(", "prod_drs", ".", "original_clauses", ")", ")", "if", "x", "not", "in", "orig_prod_idx_match", "]", ")", "\n", "no_match_gold", "=", "sorted", "(", "[", "x", "for", "x", "in", "range", "(", "len", "(", "gold_drs", ".", "original_clauses", ")", ")", "if", "x", "not", "in", "orig_gold_idx_match", "]", ")", "\n", "\n", "# Populate the no match part of what we will print later (is a bit cumbersome because we want aligned printing later)", "\n", "for", "num", "in", "no_match_prod", ":", "\n", "\t\t", "no_match", ".", "append", "(", "[", "prod_drs", ".", "original_clauses", "[", "num", "]", ",", "''", "]", ")", "\n", "\n", "# Save individual information again here", "\n", "clause_id", "=", "get_clause_id", "(", "prod_drs", ".", "original_clauses", "[", "num", "]", ")", "\n", "if", "clause_id", "not", "in", "idv_dict", ":", "\n", "\t\t\t", "idv_dict", "[", "clause_id", "]", "=", "[", "0", ",", "1", ",", "0", "]", "#contains [match_num, prod_num, gold_num]", "\n", "", "else", ":", "\n", "\t\t\t", "idv_dict", "[", "clause_id", "]", "[", "1", "]", "+=", "1", "#else only add 1 to prod_num", "\n", "\n", "", "", "for", "num", "in", "no_match_gold", ":", "\n", "\t\t", "found", "=", "False", "\n", "for", "no_match_item", "in", "no_match", ":", "\n", "\t\t\t", "if", "no_match_item", "[", "1", "]", "==", "''", ":", "# there is still space to add", "\n", "\t\t\t\t", "no_match_item", "[", "1", "]", "=", "gold_drs", ".", "original_clauses", "[", "num", "]", "\n", "found", "=", "True", "\n", "break", "\n", "", "", "if", "not", "found", ":", "# no space to add, create new row", "\n", "\t\t\t", "no_match", ".", "append", "(", "[", "''", ",", "gold_drs", ".", "original_clauses", "[", "num", "]", "]", ")", "\n", "\n", "# Save individual information again here", "\n", "", "clause_id", "=", "get_clause_id", "(", "gold_drs", ".", "original_clauses", "[", "num", "]", ")", "\n", "if", "clause_id", "not", "in", "idv_dict", ":", "\n", "\t\t\t", "idv_dict", "[", "clause_id", "]", "=", "[", "0", ",", "0", ",", "1", "]", "#contains [match_num, prod_num, gold_num]", "\n", "", "else", ":", "\n", "\t\t\t", "idv_dict", "[", "clause_id", "]", "[", "2", "]", "+=", "1", "#else only add 1 to gold_num", "\n", "\n", "# Check if results make sense compared to our previous result", "\n", "", "", "print_prec", "=", "round", "(", "len", "(", "match", ")", "/", "float", "(", "prod_drs", ".", "total_clauses", ")", ",", "significant", ")", "\n", "print_rec", "=", "round", "(", "len", "(", "match", ")", "/", "float", "(", "gold_drs", ".", "total_clauses", ")", ",", "significant", ")", "\n", "if", "print_prec", "!=", "prec", "or", "print_rec", "!=", "rec", ":", "\n", "\t\t", "raise", "ValueError", "(", "\n", "\"Error when calculating precision/recall for printing clauses:\\nPrint prec {0} vs search prec {1}\\nPrint rec {0} vs search rec {1}\\n\"", ".", "format", "(", "print_prec", ",", "prec", ",", "print_rec", ",", "rec", ")", ")", "\n", "\n", "# Print to screen and possibly to file later", "\n", "", "print_match", "=", "create_tab_list", "(", "match", ",", "'\\n## Matching clauses ##\\n'", ",", "\"| \"", ")", "\n", "print_no_match", "=", "create_tab_list", "(", "no_match", ",", "'\\n## Non-matching clauses ##\\n'", ",", "\"| \"", ")", "\n", "\n", "# Also get number of matching operator/roles/concepts for more detailed results", "\n", "match_division", "=", "get_detailed_results", "(", "match", ")", "\n", "return", "print_match", ",", "print_no_match", ",", "match_division", ",", "idv_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_matching_clauses": [[425, 477], ["time.time", "prod_drs.get_specific_clauses", "gold_drs.get_specific_clauses", "counter.DRS", "counter.DRS", "print", "hill_climbing.get_best_match", "utils_counter.compute_f", "len", "counter.get_mappings", "counter.get_num_concepts", "counter.get_num_concepts", "counter.get_num_concepts", "counter.get_num_concepts", "counter.get_num_concepts", "counter.get_num_concepts", "counter.get_num_concepts", "counter.get_num_concepts", "counter.print_results", "len", "utils_counter.create_tab_list", "counter.get_num_concepts", "counter.get_num_concepts", "counter.get_num_concepts", "counter.get_num_concepts", "uniq_rewrite.append", "print", "print", "len"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.get_specific_clauses", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.DRS.get_specific_clauses", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.get_best_match", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.compute_f", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_mappings", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_num_concepts", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_num_concepts", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_num_concepts", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_num_concepts", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_num_concepts", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_num_concepts", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_num_concepts", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_num_concepts", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.print_results", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.create_tab_list", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_num_concepts", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_num_concepts", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_num_concepts", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_num_concepts"], ["", "def", "get_matching_clauses", "(", "arg_list", ")", ":", "\n", "\t", "'''Function that gets matching clauses (easier to parallelize)'''", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "# Unpack arguments to make things easier", "\n", "prod_t", ",", "gold_t", ",", "args", ",", "single", ",", "original_prod", ",", "original_gold", ",", "en_sense_dict", ",", "signature", "=", "arg_list", "\n", "# Create DRS objects", "\n", "prod_drs", ",", "gold_drs", "=", "DRS", "(", "signature", ")", ",", "DRS", "(", "signature", ")", "\n", "prod_drs", ".", "prefix", ",", "gold_drs", ".", "prefix", "=", "'a'", ",", "'b'", "# Prefixes are used to create standardized variable-names", "\n", "prod_drs", ".", "file_name", ",", "gold_drs", ".", "file_name", "=", "args", ".", "f1", ",", "args", ".", "f2", "\n", "prod_drs", ".", "original_clauses", ",", "gold_drs", ".", "original_clauses", "=", "original_prod", ",", "original_gold", "\n", "\n", "# Get the specific clauses here", "\n", "prod_drs", ".", "get_specific_clauses", "(", "prod_t", ",", "en_sense_dict", ",", "args", ")", "\n", "gold_drs", ".", "get_specific_clauses", "(", "gold_t", ",", "en_sense_dict", ",", "args", ")", "\n", "\n", "if", "single", "and", "(", "args", ".", "max_clauses", ">", "0", "and", "(", "(", "prod_drs", ".", "total_clauses", ">", "args", ".", "max_clauses", ")", "or", "(", "gold_drs", ".", "total_clauses", ">", "args", ".", "max_clauses", ")", ")", ")", ":", "\n", "\t\t", "print", "(", "'Skip calculation of DRS, more clauses than max of {0}'", ".", "format", "(", "args", ".", "max_clauses", ")", ")", "\n", "return", "'skip'", "\n", "\n", "", "if", "args", ".", "stats", ":", "#only do stats", "\n", "\t\t", "return", "[", "0", ",", "prod_drs", ".", "total_clauses", ",", "gold_drs", ".", "total_clauses", ",", "[", "]", ",", "0", ",", "0", ",", "0", ",", "len", "(", "prod_drs", ".", "var_map", ")", "]", "# only care about clauses and var count, skip calculations", "\n", "", "else", ":", "\n", "# Do the hill-climbing for the matching here", "\n", "\t\t", "(", "best_mapping", ",", "best_match_num", ",", "found_idx", ",", "smart_fscores", ",", "clause_pairs", ")", "=", "get_best_match", "(", "prod_drs", ",", "gold_drs", ",", "args", ",", "single", ")", "\n", "(", "precision", ",", "recall", ",", "best_f_score", ")", "=", "compute_f", "(", "best_match_num", ",", "prod_drs", ".", "total_clauses", ",", "gold_drs", ".", "total_clauses", ",", "args", ".", "significant", ",", "False", ")", "\n", "\n", "\n", "if", "not", "args", ".", "no_mapping", ":", "\n", "# Print clause mapping if -prin is used and we either do multiple scores, or just had a single DRS", "\n", "\t\t\t", "print_match", ",", "print_no_match", ",", "match_division", ",", "idv_dict", "=", "get_mappings", "(", "clause_pairs", ",", "prod_drs", ",", "gold_drs", ",", "precision", ",", "recall", ",", "args", ".", "significant", ")", "\n", "# Print to file or/and screen", "\n", "if", "args", ".", "prin", "and", "(", "args", ".", "ms", "or", "single", ")", "and", "not", "args", ".", "no_mapping", ":", "\n", "\n", "# Print rewrites of concepts that were performed (only for single instances)", "\n", "\t\t\t\t", "rewrite_list", "=", "create_tab_list", "(", "prod_drs", ".", "rewritten_concepts", "+", "gold_drs", ".", "rewritten_concepts", ",", "'\\n## Normalized concepts to synset ID ##\\n'", ",", "'-> '", ")", "\n", "uniq_rewrite", "=", "[", "]", "\n", "[", "uniq_rewrite", ".", "append", "(", "item", ")", "for", "item", "in", "rewrite_list", "if", "item", "not", "in", "uniq_rewrite", "]", "#only unique transformations, but keep order", "\n", "\n", "# Print match and non-match to screen", "\n", "for", "print_line", "in", "print_match", ":", "print", "(", "print_line", ")", "\n", "for", "print_line", "in", "print_no_match", ":", "print", "(", "print_line", ")", "\n", "", "", "else", ":", "\n", "\t\t\t", "match_division", "=", "[", "]", "\n", "idv_dict", "=", "{", "}", "\n", "\n", "# For single DRS we print results later on anyway", "\n", "", "prod_clause_division", "=", "[", "prod_drs", ".", "num_operators", ",", "prod_drs", ".", "num_roles", ",", "prod_drs", ".", "num_concepts", ",", "get_num_concepts", "(", "prod_drs", ".", "concepts", ",", "'n'", ")", ",", "get_num_concepts", "(", "prod_drs", ".", "concepts", ",", "'v'", ")", ",", "get_num_concepts", "(", "prod_drs", ".", "concepts", ",", "'a'", ")", ",", "get_num_concepts", "(", "prod_drs", ".", "concepts", ",", "'r'", ")", ",", "get_num_concepts", "(", "prod_drs", ".", "concepts", ",", "'v'", ")", "+", "get_num_concepts", "(", "prod_drs", ".", "concepts", ",", "'a'", ")", "]", "\n", "gold_clause_division", "=", "[", "gold_drs", ".", "num_operators", ",", "gold_drs", ".", "num_roles", ",", "gold_drs", ".", "num_concepts", ",", "get_num_concepts", "(", "gold_drs", ".", "concepts", ",", "'n'", ")", ",", "get_num_concepts", "(", "gold_drs", ".", "concepts", ",", "'v'", ")", ",", "get_num_concepts", "(", "gold_drs", ".", "concepts", ",", "'a'", ")", ",", "get_num_concepts", "(", "gold_drs", ".", "concepts", ",", "'r'", ")", ",", "get_num_concepts", "(", "gold_drs", ".", "concepts", ",", "'v'", ")", "+", "get_num_concepts", "(", "gold_drs", ".", "concepts", ",", "'a'", ")", "]", "\n", "if", "args", ".", "ms", "and", "not", "single", ":", "\n", "\t\t\t", "print_results", "(", "[", "[", "best_match_num", ",", "prod_drs", ".", "total_clauses", ",", "gold_drs", ".", "total_clauses", ",", "smart_fscores", ",", "found_idx", ",", "match_division", ",", "prod_clause_division", ",", "gold_clause_division", ",", "len", "(", "prod_drs", ".", "var_map", ")", ",", "idv_dict", "]", "]", ",", "\n", "False", ",", "start_time", ",", "single", ",", "args", ")", "\n", "", "return", "[", "best_match_num", ",", "prod_drs", ".", "total_clauses", ",", "gold_drs", ".", "total_clauses", ",", "smart_fscores", ",", "found_idx", ",", "match_division", ",", "prod_clause_division", ",", "gold_clause_division", ",", "len", "(", "prod_drs", ".", "var_map", ")", ",", "idv_dict", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.print_results": [[479, 546], ["sum", "sum", "sum", "round", "round", "utils_counter.compute_f", "print", "float", "float", "time.time", "print", "print", "print", "print", "print", "print", "print", "print", "sum", "len", "print", "print", "print", "range", "html_results.coda_html", "round", "round", "round", "len", "print", "utils_counter.compute_f", "print", "print", "print", "print", "len", "codecs.open", "html.write", "len", "sum", "int"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.compute_f", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.html_results.coda_html", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.compute_f"], ["", "", "def", "print_results", "(", "res_list", ",", "no_print", ",", "start_time", ",", "single", ",", "args", ")", ":", "\n", "\t", "'''Print the final or inbetween scores -- res_list has format '''", "\n", "\n", "# Calculate average scores", "\n", "total_match_num", "=", "sum", "(", "[", "x", "[", "0", "]", "for", "x", "in", "res_list", "if", "x", "]", ")", "\n", "total_test_num", "=", "sum", "(", "[", "x", "[", "1", "]", "for", "x", "in", "res_list", "if", "x", "]", ")", "\n", "total_gold_num", "=", "sum", "(", "[", "x", "[", "2", "]", "for", "x", "in", "res_list", "if", "x", "]", ")", "\n", "found_idx", "=", "round", "(", "float", "(", "sum", "(", "[", "x", "[", "4", "]", "for", "x", "in", "res_list", "if", "x", "]", ")", ")", "/", "float", "(", "len", "(", "[", "x", "[", "4", "]", "for", "x", "in", "res_list", "if", "x", "]", ")", ")", ",", "args", ".", "significant", ")", "\n", "runtime", "=", "round", "(", "time", ".", "time", "(", ")", "-", "start_time", ",", "args", ".", "significant", ")", "\n", "match_division", "=", "[", "x", "[", "5", "]", "for", "x", "in", "res_list", "]", "\n", "prod_division", "=", "[", "x", "[", "6", "]", "for", "x", "in", "res_list", "]", "\n", "gold_division", "=", "[", "x", "[", "7", "]", "for", "x", "in", "res_list", "]", "\n", "\n", "# Calculate detailed F-scores for clauses, roles, concepts etc", "\n", "name_list", "=", "[", "'operators'", ",", "'roles'", ",", "'concepts'", ",", "'nouns'", ",", "'verbs'", ",", "'adjectives'", ",", "'adverbs'", ",", "'events'", "]", "\n", "res_dict", "=", "{", "}", "\n", "# Deactivate this function", "\n", "# for idx, name in enumerate(name_list):", "\n", "# res_dict[name] = compute_f(sum([x[idx] for x in match_division]), sum([x[idx] for x in prod_division]), sum([x[idx] for x in gold_division]), args.significant, False)", "\n", "\n", "# Output document-level score (a single f-score for all DRS pairs in two files)", "\n", "(", "precision", ",", "recall", ",", "best_f_score", ")", "=", "compute_f", "(", "total_match_num", ",", "total_test_num", ",", "total_gold_num", ",", "args", ".", "significant", ",", "False", ")", "\n", "\n", "if", "not", "res_list", ":", "\n", "\t\t", "return", "[", "]", "# no results for some reason", "\n", "", "elif", "no_print", ":", "# averaging over multiple runs, don't print results", "\n", "\t\t", "return", "[", "precision", ",", "recall", ",", "best_f_score", "]", "\n", "", "else", ":", "\n", "\t\t", "print", "(", "'\\n## Clause information ##\\n'", ")", "\n", "print", "(", "'Clauses prod : {0}'", ".", "format", "(", "total_test_num", ")", ")", "\n", "print", "(", "'Clauses gold : {0}\\n'", ".", "format", "(", "total_gold_num", ")", ")", "\n", "if", "args", ".", "max_clauses", ">", "0", ":", "\n", "\t\t\t", "print", "(", "'Max number of clauses per DRS:  {0}\\n'", ".", "format", "(", "args", ".", "max_clauses", ")", ")", "\n", "", "print", "(", "'## Main Results ##\\n'", ")", "\n", "if", "not", "single", ":", "\n", "\t\t\t", "print", "(", "'All shown number are micro-averages calculated over {0} DRS-pairs\\n'", ".", "format", "(", "len", "(", "res_list", ")", ")", ")", "\n", "", "print", "(", "'Matching clauses: {0}\\n'", ".", "format", "(", "total_match_num", ")", ")", "\n", "print", "(", "\"Precision: {0}\"", ".", "format", "(", "round", "(", "precision", ",", "args", ".", "significant", ")", ")", ")", "\n", "print", "(", "\"Recall   : {0}\"", ".", "format", "(", "round", "(", "recall", ",", "args", ".", "significant", ")", ")", ")", "\n", "print", "(", "\"F-score  : {0}\"", ".", "format", "(", "round", "(", "best_f_score", ",", "args", ".", "significant", ")", ")", ")", "\n", "\n", "# Print specific output here", "\n", "if", "args", ".", "prin", ":", "\n", "\t\t\t", "print", "(", "'\\n## Detailed precision, recall, F-score ##\\n'", ")", "\n", "for", "idx", "in", "range", "(", "0", ",", "len", "(", "name_list", ")", ")", ":", "\n", "\t\t\t\t", "print", "(", "'Prec, rec, F1 {0}: {1}, {2}, {3}'", ".", "format", "(", "name_list", "[", "idx", "]", ",", "res_dict", "[", "name_list", "[", "idx", "]", "]", "[", "0", "]", ",", "res_dict", "[", "name_list", "[", "idx", "]", "]", "[", "1", "]", ",", "res_dict", "[", "name_list", "[", "idx", "]", "]", "[", "2", "]", ")", ")", "\n", "", "if", "args", ".", "smart", "==", "'conc'", ":", "\n", "\t\t\t\t", "smart_conc", "=", "compute_f", "(", "sum", "(", "[", "y", "[", "0", "]", "for", "y", "in", "[", "x", "[", "3", "]", "for", "x", "in", "res_list", "]", "]", ")", ",", "total_test_num", ",", "total_gold_num", ",", "args", ".", "significant", ",", "True", ")", "\n", "print", "(", "'Smart F-score concepts: {0}\\n'", ".", "format", "(", "smart_conc", ")", ")", "\n", "\n", "# For a single DRS we can print some more information", "\n", "", "if", "single", ":", "\n", "\t\t\t\t", "print", "(", "'\\n## Restarts and processing time ##\\n'", ")", "\n", "print", "(", "'Num restarts specified       : {0}'", ".", "format", "(", "args", ".", "restarts", ")", ")", "\n", "print", "(", "'Found best mapping at restart: {0}'", ".", "format", "(", "int", "(", "found_idx", ")", ")", ")", "\n", "\n", "# Print detailed results in an html file for the CodaLab usage", "\n", "", "", "if", "args", ".", "codalab", ":", "\n", "#global ill_drs_ids # number of ill DRSs found in the system output", "\n", "\t\t\t", "counts", "=", "(", "total_test_num", ",", "total_gold_num", ",", "total_match_num", ")", "\n", "measures", "=", "(", "precision", ",", "recall", ",", "best_f_score", ")", "\n", "html_content", "=", "coda_html", "(", "len", "(", "res_list", ")", ",", "ill_drs_ids", ",", "counts", ",", "measures", ",", "name_list", ",", "res_dict", ")", "\n", "with", "codecs", ".", "open", "(", "args", ".", "codalab", "+", "'.html'", ",", "'w'", ",", "encoding", "=", "'UTF-8'", ")", "as", "html", ":", "\n", "\t\t\t\t", "html", ".", "write", "(", "html_content", ")", "\n", "\n", "", "", "", "print", "(", "'Total processing time: {0} sec'", ".", "format", "(", "runtime", ")", ")", "\n", "return", "[", "precision", ",", "recall", ",", "best_f_score", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.check_input": [[548, 570], ["print", "len", "print", "counter.fill_baseline_list", "counter.fill_baseline_list", "ValueError", "len", "len", "print", "sys.exit", "print", "sys.exit", "len", "len", "len", "len", "len", "len", "print", "len", "zip", "len", "len"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.fill_baseline_list", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.fill_baseline_list"], ["", "def", "check_input", "(", "clauses_prod_list", ",", "original_prod", ",", "original_gold", ",", "clauses_gold_list", ",", "baseline", ",", "f1", ",", "max_clauses", ",", "single", ")", ":", "\n", "\t", "'''Check if the input is valid -- or fill baseline if that is asked'''", "\n", "if", "baseline", ":", "# if we try a baseline DRS, we have to fill a list of this baseline", "\n", "\t\t", "if", "len", "(", "clauses_prod_list", ")", "==", "1", ":", "\n", "\t\t\t", "print", "(", "'Testing baseline DRS vs {0} DRSs...\\n'", ".", "format", "(", "len", "(", "clauses_gold_list", ")", ")", ")", "\n", "clauses_prod_list", "=", "fill_baseline_list", "(", "clauses_prod_list", "[", "0", "]", ",", "clauses_gold_list", ")", "\n", "original_prod", "=", "fill_baseline_list", "(", "original_prod", "[", "0", "]", ",", "original_gold", ")", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "\"Using --baseline, but there is more than 1 DRS in prod file\"", ")", "\n", "", "", "elif", "len", "(", "clauses_prod_list", ")", "!=", "len", "(", "clauses_gold_list", ")", ":", "\n", "\t\t", "print", "(", "\"Number of DRSs not equal, {0} vs {1}, exiting...\"", ".", "format", "(", "len", "(", "clauses_prod_list", ")", ",", "len", "(", "clauses_gold_list", ")", ")", ")", "\n", "sys", ".", "exit", "(", "0", ")", "\n", "", "elif", "len", "(", "clauses_prod_list", ")", "==", "0", "and", "len", "(", "clauses_gold_list", ")", "==", "0", ":", "\n", "\t\t", "print", "(", "\"Both DRSs empty, exiting...\"", ")", "\n", "sys", ".", "exit", "(", "0", ")", "\n", "", "elif", "not", "single", ":", "\n", "\t\t", "print", "(", "'Comparing {0} DRSs...\\n'", ".", "format", "(", "len", "(", "clauses_gold_list", ")", ")", ")", "\n", "\n", "# Print number of DRSs we skip due to the -max_clauses parameter", "\n", "", "if", "max_clauses", ">", "0", "and", "not", "single", ":", "\n", "\t\t", "print", "(", "'Skipping {0} DRSs due to their length exceeding {1} (--max_clauses)\\n'", ".", "format", "(", "len", "(", "[", "x", "for", "x", ",", "y", "in", "zip", "(", "clauses_gold_list", ",", "clauses_prod_list", ")", "if", "len", "(", "x", ")", ">", "max_clauses", "or", "len", "(", "y", ")", ">", "max_clauses", "]", ")", ",", "max_clauses", ")", ")", "\n", "", "return", "original_prod", ",", "clauses_prod_list", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.save_detailed_stats": [[723, 745], ["utils_counter.merge_dicts", "sorted", "enumerate", "print", "utils_counter.create_tab_list", "utils_counter.all_upper", "print", "print_list[].append", "utils_counter.is_role", "print_headers[].lower", "print_list[].append", "print_list[].append", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.merge_dicts", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.create_tab_list", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.all_upper", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.is_role"], ["", "", "def", "save_detailed_stats", "(", "all_dicts", ",", "args", ")", ":", "\n", "\t", "'''Print detailed statistics to the screen, if args.detailed_stats > 0'''", "\n", "final_dict", ",", "f_dict", "=", "merge_dicts", "(", "all_dicts", ",", "args", ")", "#first merge all dictionaries in a single dict and also create dict with F-scores", "\n", "print_list", "=", "[", "[", "]", ",", "[", "]", ",", "[", "]", "]", "\n", "print_headers", "=", "[", "'Operators'", ",", "'Roles'", ",", "'Concepts'", "]", "\n", "print_line", "=", "'Individual clause scores for'", "\n", "\n", "# Create lists to print when looping over the sorted dictionary", "\n", "for", "w", "in", "sorted", "(", "f_dict", ",", "key", "=", "f_dict", ".", "get", ",", "reverse", "=", "True", ")", ":", "\n", "\t\t", "if", "final_dict", "[", "w", "]", "[", "1", "]", ">=", "args", ".", "detailed_stats", "or", "final_dict", "[", "w", "]", "[", "2", "]", ">=", "args", ".", "detailed_stats", ":", "#only print if it has a minimum occurrence in prod or gold", "\n", "\t\t\t", "if", "all_upper", "(", "w", ")", ":", "\n", "\t\t\t\t", "print_list", "[", "0", "]", ".", "append", "(", "[", "w", ",", "str", "(", "f_dict", "[", "w", "]", ")", ",", "str", "(", "final_dict", "[", "w", "]", "[", "1", "]", ")", ",", "str", "(", "final_dict", "[", "w", "]", "[", "2", "]", ")", ",", "str", "(", "final_dict", "[", "w", "]", "[", "0", "]", ")", "]", ")", "\n", "", "elif", "is_role", "(", "w", ")", ":", "\n", "\t\t\t\t", "print_list", "[", "1", "]", ".", "append", "(", "[", "w", ",", "str", "(", "f_dict", "[", "w", "]", ")", ",", "str", "(", "final_dict", "[", "w", "]", "[", "1", "]", ")", ",", "str", "(", "final_dict", "[", "w", "]", "[", "2", "]", ")", ",", "str", "(", "final_dict", "[", "w", "]", "[", "0", "]", ")", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "print_list", "[", "2", "]", ".", "append", "(", "[", "w", ",", "str", "(", "f_dict", "[", "w", "]", ")", ",", "str", "(", "final_dict", "[", "w", "]", "[", "1", "]", ")", ",", "str", "(", "final_dict", "[", "w", "]", "[", "2", "]", ")", ",", "str", "(", "final_dict", "[", "w", "]", "[", "0", "]", ")", "]", ")", "\n", "\n", "# Now print a nicely aligned tab-list for the three types of clauses so it is easier to keep them straight", "\n", "", "", "", "for", "idx", ",", "item", "in", "enumerate", "(", "print_list", ")", ":", "\n", "\t\t", "print", "(", "'\\n{0} {1}:\\n'", ".", "format", "(", "print_line", ",", "print_headers", "[", "idx", "]", ".", "lower", "(", ")", ")", ")", "\n", "to_print", "=", "create_tab_list", "(", "[", "[", "print_headers", "[", "idx", "]", ",", "'F-score'", ",", "'Prod inst'", ",", "'Gold inst'", ",", "\"Match\"", "]", "]", "+", "print_list", "[", "idx", "]", ",", "[", "]", ",", "'\\t'", ")", "\n", "for", "t", "in", "to_print", ":", "print", "(", "t", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.save_stats": [[747, 761], ["enumerate", "print", "print", "pickle.dump", "open", "float", "float", "float", "float", "len", "numpy.median", "max", "numpy.median", "max", "sum", "len", "sum", "len"], "function", ["None"], ["", "", "def", "save_stats", "(", "all_clauses", ",", "all_vars", ",", "stat_file", ")", ":", "\n", "\t", "'''Print and save statistics related to number of variables and clauses per DRSs'''", "\n", "max_num", "=", "0", "\n", "for", "idx", ",", "num", "in", "enumerate", "(", "all_clauses", ")", ":", "\n", "\t\t", "if", "num", ">", "max_num", ":", "\n", "\t\t\t", "max_num", "=", "num", "\n", "best_idx", "=", "idx", "\n", "\n", "", "", "drs_max_clauses", ",", "mean_clauses", ",", "mean_variables", "=", "best_idx", "+", "1", ",", "float", "(", "sum", "(", "all_clauses", ")", ")", "/", "float", "(", "len", "(", "all_clauses", ")", ")", ",", "float", "(", "sum", "(", "all_vars", ")", ")", "/", "float", "(", "len", "(", "all_vars", ")", ")", "\n", "print", "(", "'\\nStatistics:\\n\\nDRS {0} has max clauses\\nLen DRSs: {1}\\nMean clauses: {2}\\nMedian clauses: {3}\\nMax clauses: {4}\\n'", ".", "format", "(", "drs_max_clauses", ",", "len", "(", "all_clauses", ")", ",", "mean_clauses", ",", "median", "(", "all_clauses", ")", ",", "max", "(", "all_clauses", ")", ")", ")", "\n", "print", "(", "'Mean variables: {0}\\nMedian variables: {1}\\nMax variables: {2}\\n'", ".", "format", "(", "mean_variables", ",", "median", "(", "all_vars", ")", ",", "max", "(", "all_vars", ")", ")", ")", "\n", "\n", "dump_lists", "=", "[", "all_clauses", ",", "all_vars", "]", "\n", "pickle", ".", "dump", "(", "dump_lists", ",", "open", "(", "stat_file", ",", "'w'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.main": [[763, 847], ["time.time", "clf_referee.get_signature", "counter.get_clauses", "counter.get_clauses", "counter.check_input", "range", "enumerate", "print", "print", "print", "print", "counter.save_stats", "out_f.close", "counter.save_detailed_stats", "len", "zip", "arg_list.append", "enumerate", "multiprocessing.Pool().map", "len", "codecs.open", "scores_file.write", "open", "enumerate", "multiprocessing.Pool().map.append", "ValueError", "round", "round", "round", "utils_counter.compute_f", "next", "counter.get_matching_clauses", "multiprocessing.Pool", "res.append", "out_f.write", "out_f.write", "len", "counter.print_results", "float", "float", "float", "float", "float", "float", "sum", "sum", "sum", "str", "str", "cl[].startswith", "len"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.get_signature", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_clauses", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_clauses", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.check_input", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.save_stats", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.save_detailed_stats", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.utils_counter.compute_f", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.get_matching_clauses", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.counter.print_results"], ["", "def", "main", "(", "args", ")", ":", "\n", "\t", "'''Main function of counter score calculation'''", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "\n", "# Read in English sense dict for rewriting concepts to synset ID", "\n", "# This is read from a Python import to speed things up (twice as fast as loading JSON every time)", "\n", "from", "wordnet_dict_en", "import", "en_sense_dict", "\n", "signature", "=", "get_signature", "(", "args", ".", "sig_file", ")", "# Get signature", "\n", "res", "=", "[", "]", "\n", "\n", "# Get all the clauses and check if they are valid", "\n", "clauses_gold_list", ",", "original_gold", "=", "get_clauses", "(", "args", ".", "f2", ",", "signature", ",", "args", ".", "ill", ")", "\n", "clauses_prod_list", ",", "original_prod", "=", "get_clauses", "(", "args", ".", "f1", ",", "signature", ",", "args", ".", "ill", ")", "\n", "\n", "# Count ill-DRSs in the system output", "\n", "global", "ill_drs_ids", "\n", "if", "args", ".", "codalab", "and", "args", ".", "ill", "==", "'dummy'", ":", "\n", "\t\t", "ill_drs_ids", "=", "[", "i", "for", "(", "i", ",", "x", ")", "in", "enumerate", "(", "clauses_prod_list", ",", "start", "=", "1", ")", "if", "len", "(", "x", ")", "<", "3", "\n", "and", "next", "(", "(", "cl", "for", "cl", "in", "x", "if", "len", "(", "cl", ")", ">", "1", "and", "cl", "[", "1", "]", ".", "startswith", "(", "'alwayswrong'", ")", ")", ",", "False", ")", "]", "\n", "\n", "# Don't print the results each time if we do multiple runs", "\n", "", "no_print", "=", "True", "if", "args", ".", "runs", ">", "1", "else", "False", "\n", "single", "=", "True", "if", "len", "(", "clauses_gold_list", ")", "==", "1", "else", "False", "# true if we are doing a single DRS", "\n", "\n", "# Check if correct input (number of instances, baseline, etc)", "\n", "original_prod", ",", "clauses_prod_list", "=", "check_input", "(", "clauses_prod_list", ",", "original_prod", ",", "original_gold", ",", "clauses_gold_list", ",", "args", ".", "baseline", ",", "args", ".", "f1", ",", "args", ".", "max_clauses", ",", "single", ")", "\n", "\n", "# Processing clauses", "\n", "for", "_", "in", "range", "(", "args", ".", "runs", ")", ":", "# for experiments we want to more runs so we can average later", "\n", "\t\t", "arg_list", "=", "[", "]", "\n", "for", "count", ",", "(", "prod_t", ",", "gold_t", ")", "in", "enumerate", "(", "zip", "(", "clauses_prod_list", ",", "clauses_gold_list", ")", ")", ":", "\n", "\t\t\t", "arg_list", ".", "append", "(", "[", "prod_t", ",", "gold_t", ",", "args", ",", "single", ",", "original_prod", "[", "count", "]", ",", "original_gold", "[", "count", "]", ",", "en_sense_dict", ",", "signature", "]", ")", "\n", "\n", "# Parallel processing here", "\n", "", "if", "args", ".", "parallel", "==", "1", ":", "# no need for parallelization for p=1", "\n", "\t\t\t", "all_results", "=", "[", "]", "\n", "for", "num_count", ",", "arguments", "in", "enumerate", "(", "arg_list", ")", ":", "\n", "\t\t\t\t", "all_results", ".", "append", "(", "get_matching_clauses", "(", "arguments", ")", ")", "\n", "", "", "else", ":", "\n", "\t\t\t", "all_results", "=", "multiprocessing", ".", "Pool", "(", "args", ".", "parallel", ")", ".", "map", "(", "get_matching_clauses", ",", "arg_list", ")", "\n", "\n", "# If we find results, print them in a nice way", "\n", "", "if", "all_results", "==", "[", "'skip'", "]", ":", "#skip result", "\n", "\t\t\t", "pass", "\n", "", "elif", "all_results", "and", "all_results", "[", "0", "]", ":", "\n", "\t\t\t", "all_clauses", "=", "[", "x", "[", "1", "]", "for", "x", "in", "all_results", "]", "\n", "all_vars", "=", "[", "x", "[", "7", "]", "for", "x", "in", "all_results", "]", "\n", "if", "not", "args", ".", "stats", ":", "\n", "\t\t\t\t", "res", ".", "append", "(", "print_results", "(", "all_results", ",", "no_print", ",", "start", ",", "single", ",", "args", ")", ")", "\n", "", "", "else", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'No results found'", ")", "\n", "\n", "# If multiple runs, print averages", "\n", "", "", "if", "res", "and", "args", ".", "runs", ">", "1", "and", "not", "args", ".", "stats", ":", "\n", "\t\t", "print", "(", "'Average scores over {0} runs:\\n'", ".", "format", "(", "args", ".", "runs", ")", ")", "\n", "print", "(", "'Precision: {0}'", ".", "format", "(", "round", "(", "float", "(", "sum", "(", "[", "x", "[", "0", "]", "for", "x", "in", "res", "]", ")", ")", "/", "float", "(", "args", ".", "runs", ")", ",", "args", ".", "significant", ")", ")", ")", "\n", "print", "(", "'Recall   : {0}'", ".", "format", "(", "round", "(", "float", "(", "sum", "(", "[", "x", "[", "1", "]", "for", "x", "in", "res", "]", ")", ")", "/", "float", "(", "args", ".", "runs", ")", ",", "args", ".", "significant", ")", ")", ")", "\n", "print", "(", "'F-score  : {0}'", ".", "format", "(", "round", "(", "float", "(", "sum", "(", "[", "x", "[", "2", "]", "for", "x", "in", "res", "]", ")", ")", "/", "float", "(", "args", ".", "runs", ")", ",", "args", ".", "significant", ")", ")", ")", "\n", "\n", "# print scores in scores.txt file for codalab usage", "\n", "", "if", "len", "(", "res", ")", "==", "1", "and", "args", ".", "runs", "==", "1", "and", "args", ".", "codalab", ":", "\n", "\t\t", "with", "codecs", ".", "open", "(", "args", ".", "codalab", "+", "'.txt'", ",", "'w'", ",", "encoding", "=", "'UTF-8'", ")", "as", "scores_file", ":", "\n", "\t\t\t", "[", "[", "score_p", ",", "score_r", ",", "score_f", "]", "]", "=", "res", "\n", "scores_file", ".", "write", "(", "\"Precision: {}\\nRecall: {}\\nF-score: {}\"", ".", "format", "(", "*", "res", "[", "0", "]", ")", ")", "\n", "\n", "# Sometimes we are also interested in (saving and printing) some statistics, do that here", "\n", "", "", "if", "args", ".", "stats", "and", "args", ".", "runs", "<=", "1", ":", "\n", "\t\t", "save_stats", "(", "all_clauses", ",", "all_vars", ",", "args", ".", "stats", ")", "\n", "\n", "# We might also want to save all individual F-scores, usually for the sake of doing statistics. We print them to a file here", "\n", "", "if", "args", ".", "ms_file", ":", "\n", "\t\t", "with", "open", "(", "args", ".", "ms_file", ",", "'w'", ")", "as", "out_f", ":", "\n", "\t\t\t", "for", "items", "in", "all_results", ":", "\n", "\t\t\t\t", "_", ",", "_", ",", "f_score", "=", "compute_f", "(", "items", "[", "0", "]", ",", "items", "[", "1", "]", ",", "items", "[", "2", "]", ",", "args", ".", "significant", ",", "False", ")", "\n", "if", "args", ".", "all_idv", ":", "\n", "\t\t\t\t\t", "print_line", "=", "\" \"", ".", "join", "(", "[", "str", "(", "x", ")", "for", "x", "in", "[", "items", "[", "0", "]", ",", "items", "[", "1", "]", ",", "items", "[", "2", "]", "]", "]", ")", "\n", "out_f", ".", "write", "(", "print_line", "+", "'\\n'", ")", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "out_f", ".", "write", "(", "str", "(", "f_score", ")", "+", "'\\n'", ")", "\n", "", "", "", "out_f", ".", "close", "(", ")", "\n", "\n", "# We might want to output statistics about individual types of clauses", "\n", "", "if", "args", ".", "detailed_stats", ">", "0", ":", "\n", "\t\t", "save_detailed_stats", "(", "[", "x", "[", "9", "]", "for", "x", "in", "all_results", "]", ",", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.Box.__init__": [[288, 300], ["set", "set", "set", "set"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "name", ")", ":", "\n", "        ", "self", ".", "name", "=", "name", "\n", "# discourse referents", "\n", "self", ".", "refs", "=", "set", "(", ")", "\n", "# speech act discourse referents", "\n", "# self.box_refs = set()", "\n", "# set of DRS conditions", "\n", "self", ".", "conds", "=", "set", "(", ")", "\n", "# discourse referents directly mentioned in DRS conditions", "\n", "self", ".", "cond_refs", "=", "set", "(", ")", "\n", "# boxes which this subordinates", "\n", "self", ".", "subs", "=", "set", "(", ")", "\n", "# discourse relations", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.parse_arguments": [[22, 40], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "parse_arguments", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Validate sets of caluses in the file'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'src'", ",", "metavar", "=", "'PATH'", ",", "\n", "help", "=", "'File containing sets of caluses'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'-v'", ",", "'--verbose'", ",", "dest", "=", "'v'", ",", "default", "=", "0", ",", "type", "=", "int", ",", "\n", "metavar", "=", "'N'", ",", "help", "=", "'verbosity level of reporting'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'-q'", ",", "'--quiet'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Do not report the found mistakes by throwing an error'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'-s'", ",", "'--sig'", ",", "dest", "=", "'sig_file'", ",", "default", "=", "''", ",", "\n", "help", "=", "'If added, this contains a file with all allowed roles\\\n              otherwise a simple signature is used that\\\n              mainly recognizes operators based on their formatting'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.check_clf": [[43, 79], ["clf_referee.clf_typing", "arg_typing.items", "clf_referee.clf_to_box_dict", "set", "clf_referee.box_dict_to_subordinate_rel", "clf_referee.connected_boxes", "clf_referee.unbound_referents", "print", "print", "set", "sub_rel.copy", "RuntimeError", "clf_referee.pr_box", "box_dict.keys", "len", "clf_referee.pr_2rel", "clf_referee.pr_set"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.clf_typing", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.clf_to_box_dict", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.box_dict_to_subordinate_rel", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.connected_boxes", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.unbound_referents", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_box", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_2rel", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_set"], ["", "def", "check_clf", "(", "clf", ",", "signature", ",", "v", "=", "0", ")", ":", "\n", "    ", "'''checks well-formedness of a clausal form\n       It returns fine-grained information about the CLF and its DRS:\n       * main_box subordinates all the boxes, i.e. all boxes are accessible for it\n       * box_dict is a dictionary of {box_label:box_object}\n       * direct_sub is subordinate relation derived from box nesting, immediate subordination\n       * sub_rel is a subordinate relation over boxes: direct_sub + covert subordinate relations\n       * op_types is a list of types of the clauses in CLF\n    '''", "\n", "# get argument typing and for each clause an operator type", "\n", "(", "op_types", ",", "arg_typing", ")", "=", "clf_typing", "(", "clf", ",", "signature", ",", "v", "=", "v", ")", "\n", "# make all terms, i.e., of unresolved term types, variables (strict mode)", "\n", "for", "term", ",", "type", "in", "arg_typing", ".", "items", "(", ")", ":", "\n", "        ", "if", "type", "==", "'t'", ":", "arg_typing", "[", "term", "]", "=", "'x'", "\n", "# get dictionary of box objects. presupp_rel is a subset of disc_rel", "\n", "", "(", "box_dict", ",", "disc_rels", ",", "presupp_rels", ")", "=", "clf_to_box_dict", "(", "clf", ",", "op_types", ",", "arg_typing", ",", "v", "=", "v", ")", "\n", "if", "v", ">=", "2", ":", "print", "(", "\"#boxes = {}\"", ".", "format", "(", "len", "(", "box_dict", ")", ")", ")", "\n", "if", "v", ">=", "3", ":", "\n", "        ", "for", "b", "in", "box_dict", ":", "\n", "            ", "pr_box", "(", "box_dict", "[", "b", "]", ")", "\n", "# assumption on discourse relations", "\n", "", "", "disc_sub_rel", "=", "set", "(", "[", "(", "a", ",", "b", ")", "for", "(", "_", ",", "a", ",", "b", ")", "in", "disc_rels", "]", ")", "\n", "# get transitive closure of subordinate relation (as set)", "\n", "# also checks whether there is a loop in terms of element reflexivity", "\n", "(", "sub_rel", ",", "direct_sub", ")", "=", "box_dict_to_subordinate_rel", "(", "box_dict", ",", "presupp_rels", ",", "disc_sub_rel", ",", "v", "=", "v", ")", "\n", "if", "v", ">=", "2", ":", "print", "(", "\"subordinate relation: {}\"", ".", "format", "(", "pr_2rel", "(", "sub_rel", ")", ")", ")", "\n", "\n", "# check connectivity of all boxes and discourse boxes: can travel from any box to any box", "\n", "connected_boxes", "(", "set", "(", "box_dict", ".", "keys", "(", ")", ")", ",", "sub_rel", ".", "copy", "(", ")", ",", "v", "=", "v", ")", "\n", "\n", "# find is there are unbound referents", "\n", "unbound_refs", "=", "unbound_referents", "(", "box_dict", ",", "sub_rel", ",", "v", "=", "v", ")", "\n", "if", "unbound_refs", ":", "\n", "        ", "raise", "RuntimeError", "(", "'Unbound referents || {}'", ".", "format", "(", "pr_set", "(", "unbound_refs", ")", ")", ")", "\n", "\n", "", "return", "(", "box_dict", ",", "sub_rel", ",", "direct_sub", ",", "op_types", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.clf_typing": [[81, 105], ["dict", "clf_referee.clause_typing", "op_types.append", "print", "clf_referee.specify_arg_type", "clf_referee.unify_types", "clf_referee.pr_clause", "clf_referee.pr_2rel", "clf_referee.report_error"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.clause_typing", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.specify_arg_type", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.unify_types", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_clause", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_2rel", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.report_error"], ["", "def", "clf_typing", "(", "clf", ",", "signature", ",", "v", "=", "0", ")", ":", "\n", "    ", "'''Checks well-formedness of a clausal form in terms of typing.\n       Return a list of clause types (i.e. opearator types)\n       and a dictionary of term typing\n    '''", "\n", "arg_typing", "=", "dict", "(", ")", "\n", "op_types", "=", "[", "]", "\n", "# check each clause individually and get variable types", "\n", "for", "cl", "in", "clf", ":", "\n", "        ", "(", "op_type", ",", "typing", ")", "=", "clause_typing", "(", "cl", ",", "signature", ",", "v", "=", "v", ")", "\n", "op_types", ".", "append", "(", "op_type", ")", "\n", "if", "v", ">=", "4", ":", "print", "(", "\"{}: {} @ {}\"", ".", "format", "(", "pr_clause", "(", "cl", ")", ",", "op_type", ",", "pr_2rel", "(", "typing", ",", "sep", "=", "':'", ")", ")", ")", "\n", "for", "(", "arg", ",", "t", ")", "in", "typing", ":", "\n", "# make type more specific if possible", "\n", "            ", "t", "=", "specify_arg_type", "(", "arg", ",", "t", ",", "v", "=", "v", ")", "# 't' might become 'c'", "\n", "if", "arg", "in", "arg_typing", ":", "\n", "                ", "u", "=", "unify_types", "(", "arg_typing", "[", "arg", "]", ",", "t", ")", "\n", "if", "not", "u", ":", "\n", "                    ", "report_error", "(", "\"Type clash || '{}' is of type '{}' and '{}' in {}\"", ".", "format", "(", "\n", "arg", ",", "arg_typing", "[", "arg", "]", ",", "t", ",", "cl", ")", ",", "v", "=", "v", ")", "\n", "", "arg_typing", "[", "arg", "]", "=", "u", "\n", "", "else", ":", "\n", "                ", "arg_typing", "[", "arg", "]", "=", "t", "\n", "", "", "", "return", "(", "op_types", ",", "arg_typing", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.clause_typing": [[107, 120], ["clf_referee.operator_type", "set", "len", "clf_referee.report_error", "len", "len", "clf_referee.report_error", "zip", "len"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.operator_type", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.report_error", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.report_error"], ["", "def", "clause_typing", "(", "clause", ",", "signature", ",", "v", "=", "0", ")", ":", "\n", "    ", "'''checks well-formedness of a clause (context insensitive)\n       and returns its main operator type with the types of variables\n    '''", "\n", "if", "len", "(", "clause", ")", ">", "4", ":", "\n", "        ", "report_error", "(", "\"Too many elements in a clause || {}\"", ".", "format", "(", "clause", ")", ",", "v", "=", "v", ")", "\n", "", "operator", ",", "arguments", "=", "clause", "[", "1", "]", ",", "(", "clause", "[", "0", "]", ",", ")", "+", "clause", "[", "2", ":", "]", "\n", "(", "op_type", ",", "arg_types", ")", "=", "operator_type", "(", "operator", ",", "arguments", ",", "signature", ",", "v", "=", "v", ")", "\n", "if", "len", "(", "arguments", ")", "!=", "len", "(", "arg_types", ")", ":", "\n", "        ", "report_error", "(", "\"Arity Error || Arg-number should be {} in /{}/\"", ".", "format", "(", "len", "(", "arg_types", ")", ",", "clause", ")", ",", "v", "=", "v", ")", "\n", "", "typing", "=", "set", "(", "zip", "(", "arguments", ",", "arg_types", ")", ")", "\n", "# check if typing per se is ok", "\n", "return", "(", "op_type", ",", "typing", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.specify_arg_type": [[122, 139], ["print", "clf_referee.report_error", "clf_referee.report_error", "re.match", "re.match", "clf_referee.unify_types"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.report_error", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.report_error", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.unify_types"], ["", "def", "specify_arg_type", "(", "arg", ",", "t", ",", "v", "=", "0", ")", ":", "\n", "    ", "'''check if argument and a type are compatible\n       and return a type, more specific if possible\n       (e.g., \"now\" will be of type c instead of t)\n    '''", "\n", "if", "v", ">=", "4", ":", "print", "(", "\"{} {}\"", ".", "format", "(", "arg", ",", "t", ")", ")", "\n", "# argument is in double quotes or has no quotes", "\n", "if", "(", "not", "re", ".", "match", "(", "'\"[^\"]+\"$'", ",", "arg", ")", "and", "\n", "not", "re", ".", "match", "(", "'[^\"]+$'", ",", "arg", ")", ")", ":", "# try without re", "\n", "        ", "report_error", "(", "\"Syntax error || argument {} is ill-formed\"", ".", "format", "(", "arg", ")", ",", "v", "=", "v", ")", "\n", "# if in double quotes, then is of type t, and if of type c, then id double quotes", "\n", "", "if", "(", "(", "t", "==", "'c'", "and", "(", "arg", "[", "0", "]", ",", "arg", "[", "-", "1", "]", ")", "!=", "(", "'\"'", ",", "'\"'", ")", ")", "or", "\n", "(", "'c'", "!=", "unify_types", "(", "t", ",", "'c'", ")", "and", "(", "arg", "[", "0", "]", ",", "arg", "[", "-", "1", "]", ")", "==", "(", "'\"'", ",", "'\"'", ")", ")", ")", ":", "\n", "        ", "report_error", "(", "\"Type clash || {} is of type {}\"", ".", "format", "(", "arg", ",", "t", ")", ",", "v", "=", "v", ")", "\n", "", "if", "(", "arg", "[", "0", "]", ",", "arg", "[", "-", "1", "]", ")", "==", "(", "'\"'", ",", "'\"'", ")", ":", "\n", "        ", "return", "'c'", "# constant type", "\n", "", "return", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.unify_types": [[141, 150], ["set", "set", "set", "set"], "function", ["None"], ["", "def", "unify_types", "(", "t1", ",", "t2", ",", "v", "=", "0", ")", ":", "\n", "    ", "'''unify two types. If not possible return false'''", "\n", "if", "t1", "==", "t2", ":", "\n", "        ", "return", "t1", "\n", "", "if", "set", "(", "[", "t1", ",", "t2", "]", ")", "==", "set", "(", "[", "'t'", ",", "'c'", "]", ")", ":", "\n", "        ", "return", "'c'", "\n", "", "if", "set", "(", "[", "t1", ",", "t2", "]", ")", "==", "set", "(", "[", "'t'", ",", "'x'", "]", ")", ":", "\n", "        ", "return", "'x'", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.operator_type": [[152, 171], ["clf_referee.report_error", "re.match", "re.match", "re.match", "clf_referee.operator_type_default"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.report_error", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.operator_type_default"], ["", "def", "operator_type", "(", "op", ",", "args", ",", "sig", ",", "v", "=", "0", ")", ":", "\n", "    ", "'''detect operator kind and types of its arguments'''", "\n", "# Wordnet senses", "\n", "if", "re", ".", "match", "(", "'\"[avnr]\\.\\d\\d\"$'", ",", "args", "[", "1", "]", ")", "and", "re", ".", "match", "(", "\"[.'\\w]\"", ",", "op", ",", "re", ".", "U", ")", "and", "re", ".", "match", "(", "\"[^_]\"", ",", "op", ",", "re", ".", "U", ")", ":", "\n", "        ", "return", "(", "'LEX'", ",", "'bct'", ")", "# b LEX c t", "\n", "# when signature is empty use a fallback type-checking", "\n", "", "if", "not", "sig", ":", "\n", "       ", "return", "operator_type_default", "(", "op", ",", "args", ",", "v", "=", "v", ")", "\n", "# Operator is in the signature", "\n", "", "if", "op", "in", "sig", ":", "\n", "        ", "(", "op_kind", ",", "arg_types", ")", "=", "sig", "[", "op", "]", "\n", "if", "op_kind", "in", "[", "'DRS'", "]", ":", "\n", "            ", "return", "(", "op", ",", "arg_types", ")", "\n", "", "if", "op_kind", "in", "[", "'DRL'", ",", "'PRE'", "]", ":", "\n", "            ", "return", "(", "op_kind", ",", "arg_types", ")", "\n", "", "return", "(", "'ROL'", ",", "arg_types", ")", "# treat all different types of role as of type ROL", "\n", "", "report_error", "(", "\"unknown clause || {} @ {}\"", ".", "format", "(", "op", ",", "args", ")", ".", "encode", "(", "'UTF-8'", ")", ",", "v", "=", "v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.operator_type_default": [[173, 198], ["op.isupper", "op[].istitle", "clf_referee.report_error", "op.isupper", "len"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.report_error"], ["", "def", "operator_type_default", "(", "op", ",", "args", ",", "v", "=", "0", ")", ":", "\n", "    ", "'''detect operator kind and types of its arguments\n       based solely on format, without a specified signature\n    '''", "\n", "# Operator is in the signature", "\n", "if", "op", "in", "[", "'REF'", "]", ":", "\n", "        ", "return", "(", "op", ",", "'bx'", ")", "\n", "", "if", "op", "in", "[", "'NOT'", ",", "'POS'", ",", "'NEC'", ",", "'DRS'", "]", ":", "\n", "        ", "return", "(", "op", ",", "'bb'", ")", "\n", "", "if", "op", "in", "[", "'IMP'", ",", "'DIS'", ",", "'DUP'", "]", ":", "\n", "        ", "return", "(", "op", ",", "'bbb'", ")", "\n", "", "if", "op", "in", "[", "'PRP'", "]", ":", "\n", "        ", "return", "(", "op", ",", "'bxb'", ")", "\n", "", "if", "op", "in", "[", "'PRESUPPOSITION'", "]", ":", "\n", "        ", "return", "(", "'PRE'", ",", "'bb'", ")", "\n", "# is a temporal or spatial relation", "\n", "", "if", "len", "(", "op", ")", "==", "3", "and", "op", ".", "isupper", "(", ")", ":", "\n", "        ", "return", "(", "'ROL'", ",", "'btt'", ")", "\n", "# is a discourse relation", "\n", "", "if", "op", ".", "isupper", "(", ")", ":", "\n", "        ", "return", "(", "'DRL'", ",", "'bb'", ")", "# Disc. Relations are outside box", "\n", "# is a role", "\n", "", "if", "op", "[", "0", ":", "2", "]", ".", "istitle", "(", ")", ":", "# includes the roles like \"PartOf\" too", "\n", "        ", "return", "(", "'ROL'", ",", "'btt'", ")", "\n", "", "report_error", "(", "\"unknown clause || {} @ {}\"", ".", "format", "(", "op", ",", "args", ")", ",", "v", "=", "v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.file_to_clfs": [[201, 240], ["codecs.open", "enumerate", "list_of_clf.append", "list_of_raw.append", "[].strip.startswith", "[].strip", "tuple", "pre_line[].strip", "[].strip.startswith", "[].strip.strip", "print", "[].strip.split", "len", "clf.append", "list_of_clf.append", "list_of_raw.append", "pre_line[].strip", "len", "len", "len", "len", "clf_referee.pr_clf", "[].strip.split"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_clf"], ["", "def", "file_to_clfs", "(", "filepath", ",", "v", "=", "0", ")", ":", "\n", "    ", "'''reads a file with raw text and clausal forms inside it and\n       returns a list of clausal forms and a list of raws.\n       Each clausal form is a list of clauses/tuples.\n       An empty line is a separator of clausal forms\n    '''", "\n", "list_of_clf", "=", "[", "]", "\n", "list_of_raw", "=", "[", "]", "\n", "clf", "=", "[", "]", "\n", "with", "codecs", ".", "open", "(", "filepath", ",", "'r'", ",", "encoding", "=", "'UTF-8'", ")", "as", "f", ":", "\n", "        ", "pre_line", "=", "''", "# saves previous line", "\n", "for", "i", ",", "line", "in", "enumerate", "(", "f", ")", ":", "\n", "# when the line is a comment ignore,", "\n", "# but if its previous line contains a raw text, then save it", "\n", "            ", "if", "line", ".", "startswith", "(", "\"%\"", ")", ":", "\n", "# save the last line starting with %%%, it can be a raw text", "\n", "                ", "if", "line", ".", "startswith", "(", "\"%%%\"", ")", ":", "\n", "                    ", "pre_line", "=", "line", "\n", "", "continue", "\n", "", "if", "not", "line", ".", "strip", "(", ")", ":", "# clf separator", "\n", "                ", "if", "clf", ":", "# add only non-empty clf", "\n", "                    ", "list_of_clf", ".", "append", "(", "clf", ")", "\n", "list_of_raw", ".", "append", "(", "pre_line", "[", "3", ":", "]", ".", "strip", "(", ")", ")", "\n", "assert", "len", "(", "list_of_clf", ")", "==", "len", "(", "list_of_raw", ")", ",", "\"Number of clfs ({}) and raws ({}) do not match: {} vs {}\"", ".", "format", "(", "\n", "len", "(", "list_of_clf", ")", ",", "len", "(", "list_of_raw", ")", ",", "\n", "list_of_raw", "[", "-", "1", "]", ",", "pr_clf", "(", "list_of_clf", "[", "-", "1", "]", ")", ")", "\n", "clf", "=", "[", "]", "\n", "", "continue", "\n", "# remove % comments if any", "\n", "", "line", "=", "line", ".", "split", "(", "' %'", ",", "1", ")", "[", "0", "]", ".", "strip", "(", ")", "\n", "if", "v", ">=", "5", ":", "print", "(", "\"/{}/\"", ".", "format", "(", "line", ")", ")", "\n", "clause", "=", "tuple", "(", "line", ".", "split", "(", "' '", ")", ")", "\n", "if", "len", "(", "clause", ")", ">", "1", ":", "#remove lines that are comments and started with whitespace", "\n", "                ", "clf", ".", "append", "(", "clause", ")", "\n", "", "", "", "if", "clf", ":", "# add last clf", "\n", "        ", "list_of_clf", ".", "append", "(", "clf", ")", "\n", "list_of_raw", ".", "append", "(", "pre_line", "[", "3", ":", "]", ".", "strip", "(", ")", ")", "\n", "", "return", "(", "list_of_clf", ",", "list_of_raw", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.report_error": [[242, 246], ["RuntimeError", "print"], "function", ["None"], ["", "def", "report_error", "(", "message", ",", "v", "=", "0", ")", ":", "\n", "    ", "if", "v", ">=", "1", ":", "\n", "        ", "print", "(", "message", ")", "\n", "", "raise", "RuntimeError", "(", "message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.counter_prog": [[248, 253], ["sys.stdout.write", "sys.stdout.flush"], "function", ["None"], ["", "def", "counter_prog", "(", "i", ",", "v", "=", "0", ")", ":", "\n", "    ", "'''Displays a counter to show the progress'''", "\n", "if", "v", ">=", "1", ":", "\n", "        ", "sys", ".", "stdout", ".", "write", "(", "'\\r{}:'", ".", "format", "(", "i", ")", ")", "\n", "sys", ".", "stdout", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.get_signature": [[255, 278], ["os.path.isfile", "RuntimeError", "ValueError", "codecs.open", "yaml.load"], "function", ["None"], ["", "", "def", "get_signature", "(", "sig_file", ",", "out", "=", "'{op:(kind,types)}'", ",", "v", "=", "0", ")", ":", "\n", "    ", "'''get particular information related to operators used in clausal forms'''", "\n", "# DRS operators and their argumnet types", "\n", "# return an empty dictionary for no signature file", "\n", "if", "not", "sig_file", ":", "\n", "        ", "return", "{", "}", "\n", "# read signature from the yaml file", "\n", "", "if", "os", ".", "path", ".", "isfile", "(", "sig_file", ")", ":", "\n", "        ", "with", "codecs", ".", "open", "(", "sig_file", ",", "'r'", ",", "encoding", "=", "'UTF-8'", ")", "as", "f", ":", "\n", "            ", "sig", "=", "yaml", ".", "load", "(", "f", ")", "\n", "", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Specified signature file is not a file\"", ")", "\n", "# original as it is from the yaml file", "\n", "", "if", "out", "==", "'{types:{kind:op}}'", ":", "\n", "        ", "return", "sig", "\n", "# operators as keys", "\n", "", "if", "out", "==", "'{op:(kind,types)}'", ":", "\n", "        ", "return", "{", "op", ":", "(", "k", ",", "t", ")", "for", "t", "in", "sig", "for", "k", "in", "sig", "[", "t", "]", "for", "op", "in", "sig", "[", "t", "]", "[", "k", "]", "}", "\n", "# simple list of operators", "\n", "", "if", "out", "==", "'[op]'", ":", "\n", "        ", "return", "[", "op", "for", "t", "in", "sig", "for", "k", "in", "sig", "[", "t", "]", "for", "op", "in", "sig", "[", "t", "]", "[", "k", "]", "]", "\n", "# error for the uncovered mode found", "\n", "", "raise", "RuntimeError", "(", "\"Unknown parameter || {}\"", ".", "format", "(", "out", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_box": [[310, 328], ["print", "print", "print", "print", "print", "print", "print"], "function", ["None"], ["", "", "def", "pr_box", "(", "box", ",", "indent", "=", "0", ")", ":", "\n", "    ", "'''Print a box object'''", "\n", "ind", "=", "indent", "*", "' '", "\n", "print", "(", "\"{} {}\"", ".", "format", "(", "ind", ",", "20", "*", "'_'", ")", ")", "\n", "print", "(", "\"{} {}\"", ".", "format", "(", "ind", ",", "box", ".", "name", ")", ")", "\n", "#discourse referents", "\n", "print", "(", "\"{} {} {}\"", ".", "format", "(", "ind", ",", "'| '", ",", "' '", ".", "join", "(", "box", ".", "refs", ")", ")", ")", "\n", "#if box.box_refs: print ind, '[[ ', ' '.join(box.box_refs)", "\n", "print", "(", "\"{} {}\"", ".", "format", "(", "ind", ",", "20", "*", "'-'", ")", ")", "\n", "if", "box", ".", "conds", ":", "\n", "        ", "for", "c", "in", "box", ".", "conds", ":", "\n", "            ", "print", "(", "\"{} {} {}\"", ".", "format", "(", "ind", ",", "'| '", ",", "' '", ".", "join", "(", "c", ")", ")", ")", "\n", "#if box.rels: # relations are floating outside boxes now", "\n", "#    for r in box.rels:", "\n", "#        print ind, '[ ', ' '.join(r), ' ]'", "\n", "", "", "if", "box", ".", "cond_refs", ":", "print", "(", "\"{} {} {} {}\"", ".", "format", "(", "ind", ",", "'{ '", ",", "' '", ".", "join", "(", "box", ".", "cond_refs", ")", ",", "' }'", ")", ")", "\n", "#if box.rel_boxes: print ind, '[{ ', ' '.join(box.rel_boxes), ' ]]'", "\n", "if", "box", ".", "subs", ":", "print", "(", "\"{} {} {} {}\"", ".", "format", "(", "ind", ",", "'< '", ",", "' '", ".", "join", "(", "box", ".", "subs", ")", ",", "' >'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_2rel": [[330, 337], ["print"], "function", ["None"], ["", "def", "pr_2rel", "(", "rel", ",", "pr", "=", "False", ",", "sep", "=", "'>'", ")", ":", "\n", "    ", "'''Print binary relation'''", "\n", "message", "=", "'{ '", "+", "', '", ".", "join", "(", "[", "a", "+", "sep", "+", "b", "for", "(", "a", ",", "b", ")", "in", "rel", "]", ")", "+", "' }'", "\n", "if", "pr", ":", "\n", "        ", "print", "(", "message", ")", "\n", "", "else", ":", "\n", "        ", "return", "message", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_clf": [[339, 347], ["sep.join", "print", "clf_referee.pr_clause"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_clause"], ["", "", "def", "pr_clf", "(", "clf", ",", "pr", "=", "False", ",", "inline", "=", "True", ",", "indent", "=", "0", ")", ":", "\n", "    ", "'''Print clf with clause per line'''", "\n", "sep", "=", "'; '", "if", "inline", "else", "'\\n'", "+", "indent", "*", "' '", "\n", "message", "=", "sep", ".", "join", "(", "[", "pr_clause", "(", "clause", ")", "for", "clause", "in", "clf", "]", ")", "\n", "if", "pr", ":", "\n", "        ", "print", "(", "indent", "*", "' '", "+", "message", ")", "\n", "", "else", ":", "\n", "        ", "return", "indent", "*", "' '", "+", "message", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_set": [[349, 356], ["print"], "function", ["None"], ["", "", "def", "pr_set", "(", "set", ",", "pr", "=", "False", ")", ":", "\n", "    ", "'''Print set with simple elements'''", "\n", "message", "=", "'{ '", "+", "', '", ".", "join", "(", "set", ")", "+", "' }'", "\n", "if", "pr", ":", "\n", "        ", "print", "(", "message", ")", "\n", "", "else", ":", "\n", "        ", "return", "message", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_clause": [[358, 365], ["print"], "function", ["None"], ["", "", "def", "pr_clause", "(", "clause", ",", "pr", "=", "False", ")", ":", "\n", "    ", "'''Make clause prettier (and print it if needed)'''", "\n", "message", "=", "' '", ".", "join", "(", "clause", ")", "\n", "if", "pr", ":", "\n", "        ", "print", "(", "message", ")", "\n", "", "else", ":", "\n", "        ", "return", "message", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.clf_to_box_dict": [[367, 468], ["dict", "set", "set", "enumerate", "RuntimeError", "print", "dict.setdefault().refs.add", "dict.setdefault().conds.add", "box_dict[].subs.add", "dict.setdefault", "dict.setdefault().conds.add", "box_dict[].subs.update", "dict.setdefault", "dict.setdefault", "dict.setdefault().conds.add", "box_dict[].subs.add", "box_dict[].cond_refs.add", "dict.setdefault", "dict.setdefault().conds.add", "dict.setdefault", "dict.setdefault", "set.add", "set.add", "dict.setdefault", "dict.setdefault", "dict.setdefault().conds.add", "box_dict[].cond_refs.update", "clf_referee.pr_box", "print", "print", "clf_referee.Box", "print", "clf_referee.Box", "clf_referee.Box", "box_dict[].subs.add", "print", "clf_referee.Box", "clf_referee.unify_types", "print", "box_dict[].cond_refs.add", "print", "clf_referee.Box", "clf_referee.Box", "print", "clf_referee.Box", "clf_referee.Box", "clf_referee.unify_types", "clf_referee.unify_types", "print", "dict.setdefault", "dict.setdefault", "dict.setdefault", "dict.setdefault", "dict.setdefault", "dict.setdefault", "clf_referee.Box", "clf_referee.Box", "clf_referee.Box", "clf_referee.Box", "clf_referee.Box", "clf_referee.Box"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_box", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.unify_types", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.unify_types", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.unify_types"], ["", "", "def", "clf_to_box_dict", "(", "clf", ",", "op_types", ",", "arg_typing", ",", "v", "=", "0", ")", ":", "\n", "    ", "'''Convert a clausal form into a dictionay of DRSs.\n       Additionally return a set of Discourse relations, typing of conditions,\n       and presupposition rels from PRESUPPOSITION\n    '''", "\n", "box_dict", "=", "dict", "(", ")", "# collects all box names and box objects pairs", "\n", "disc_rels", "=", "set", "(", ")", "# a set of discourse relations", "\n", "presupp_rels", "=", "set", "(", ")", "# a set of subordinate (currently, presupposition) relations", "\n", "for", "(", "i", ",", "cl", ")", "in", "enumerate", "(", "clf", ")", ":", "\n", "        ", "op_type", "=", "op_types", "[", "i", "]", "\n", "#if v >=4: print \"Dealing with {} of type {}\".format(cl, op_type)", "\n", "# gradually print boxes", "\n", "if", "v", ">=", "4", ":", "\n", "            ", "print", "(", "30", "*", "'#'", ")", "\n", "for", "b", "in", "box_dict", ":", "\n", "                ", "pr_box", "(", "box_dict", "[", "b", "]", ",", "indent", "=", "5", ")", "\n", "# Reference clause: b REF x", "\n", "", "", "if", "op_type", "in", "[", "'REF'", "]", ":", "\n", "            ", "(", "b", ",", "op", ",", "x", ")", "=", "cl", "\n", "if", "v", ">=", "4", ":", "print", "(", "\"Adding {} to {} as {}\"", ".", "format", "(", "cl", ",", "b", ",", "op_type", ")", ")", "\n", "assert", "(", "arg_typing", "[", "b", "]", ",", "arg_typing", "[", "x", "]", ")", "==", "(", "'b'", ",", "'x'", ")", "\n", "box_dict", ".", "setdefault", "(", "b", ",", "Box", "(", "b", ")", ")", ".", "refs", ".", "add", "(", "x", ")", "\n", "continue", "\n", "# clause for a condition with a single DRS", "\n", "", "if", "op_type", "in", "[", "'NOT'", ",", "'POS'", ",", "'NEC'", "]", ":", "# remove 'DRS'", "\n", "            ", "(", "b0", ",", "op", ",", "b1", ")", "=", "cl", "\n", "if", "v", ">=", "4", ":", "print", "(", "\"Adding {} to {} as {}\"", ".", "format", "(", "cl", ",", "b0", ",", "op_type", ")", ")", "\n", "assert", "(", "arg_typing", "[", "b0", "]", ",", "arg_typing", "[", "b1", "]", ")", "==", "(", "'b'", ",", "'b'", ")", "\n", "box_dict", ".", "setdefault", "(", "b0", ",", "Box", "(", "b0", ")", ")", ".", "conds", ".", "add", "(", "(", "op", ",", "b1", ")", ")", "\n", "box_dict", "[", "b0", "]", ".", "subs", ".", "add", "(", "b1", ")", "\n", "box_dict", ".", "setdefault", "(", "b1", ",", "Box", "(", "b1", ")", ")", "\n", "continue", "\n", "# clause for an implication (b0 IMP b1 b2) or duplex (b0 DUP b1 b2) condition", "\n", "# also for disjunction condition: b0 DIS b1 b2", "\n", "", "if", "op_type", "in", "[", "'IMP'", ",", "'DUP'", ",", "'DIS'", "]", ":", "\n", "            ", "(", "b0", ",", "op", ",", "b1", ",", "b2", ")", "=", "cl", "\n", "if", "v", ">=", "4", ":", "print", "(", "\"Adding {} to {} as {}\"", ".", "format", "(", "cl", ",", "b0", ",", "op_type", ")", ")", "\n", "assert", "(", "arg_typing", "[", "b0", "]", ",", "arg_typing", "[", "b1", "]", ",", "arg_typing", "[", "b2", "]", ")", "==", "(", "'b'", ",", "'b'", ",", "'b'", ")", "\n", "box_dict", ".", "setdefault", "(", "b0", ",", "Box", "(", "b0", ")", ")", ".", "conds", ".", "add", "(", "(", "op", ",", "b1", ",", "b2", ")", ")", "\n", "box_dict", "[", "b0", "]", ".", "subs", ".", "update", "(", "[", "b1", ",", "b2", "]", ")", "\n", "box_dict", ".", "setdefault", "(", "b1", ",", "Box", "(", "b1", ")", ")", "\n", "box_dict", ".", "setdefault", "(", "b2", ",", "Box", "(", "b2", ")", ")", "\n", "if", "op_type", "in", "[", "'IMP'", ",", "'DUP'", "]", ":", "\n", "                ", "box_dict", "[", "b1", "]", ".", "subs", ".", "add", "(", "b2", ")", "# antecedent subordinates consequent", "\n", "", "continue", "\n", "# clause for a propositional condition", "\n", "", "if", "op_type", "in", "[", "'PRP'", "]", ":", "\n", "            ", "(", "b0", ",", "op", ",", "x", ",", "b1", ")", "=", "cl", "\n", "if", "v", ">=", "4", ":", "print", "(", "\"Adding {} to {} as {}\"", ".", "format", "(", "cl", ",", "b0", ",", "op_type", ")", ")", "\n", "assert", "(", "arg_typing", "[", "b0", "]", ",", "arg_typing", "[", "x", "]", ",", "arg_typing", "[", "b1", "]", ")", "==", "(", "'b'", ",", "'x'", ",", "'b'", ")", "\n", "box_dict", ".", "setdefault", "(", "b0", ",", "Box", "(", "b0", ")", ")", ".", "conds", ".", "add", "(", "(", "op", ",", "x", ",", "b1", ")", ")", "\n", "box_dict", "[", "b0", "]", ".", "subs", ".", "add", "(", "b1", ")", "\n", "box_dict", "[", "b0", "]", ".", "cond_refs", ".", "add", "(", "x", ")", "\n", "#box_dict[b0].refs.add(x)", "\n", "box_dict", ".", "setdefault", "(", "b1", ",", "Box", "(", "b1", ")", ")", "\n", "continue", "\n", "# clause for a condition with lexical/WN predicate", "\n", "", "if", "op_type", "in", "[", "'LEX'", "]", ":", "\n", "            ", "(", "b", ",", "op", ",", "pos", ",", "t", ")", "=", "cl", "\n", "assert", "(", "arg_typing", "[", "b", "]", ",", "arg_typing", "[", "pos", "]", ")", "==", "(", "'b'", ",", "'c'", ")", "and", "unify_types", "(", "arg_typing", "[", "t", "]", ",", "'t'", ")", "\n", "if", "v", ">=", "4", ":", "print", "(", "\"Adding {} to {} as {}\"", ".", "format", "(", "cl", ",", "b", ",", "op_type", ")", ")", "\n", "box_dict", ".", "setdefault", "(", "b", ",", "Box", "(", "b", ")", ")", ".", "conds", ".", "add", "(", "(", "op", ",", "pos", ",", "t", ")", ")", "\n", "if", "arg_typing", "[", "t", "]", "==", "'x'", ":", "\n", "#box_dict[b].refs.add(x)", "\n", "                ", "box_dict", "[", "b", "]", ".", "cond_refs", ".", "add", "(", "t", ")", "\n", "", "continue", "\n", "# clause for a discourse relation", "\n", "", "if", "op_type", "in", "[", "'DRL'", "]", ":", "\n", "            ", "(", "b1", ",", "op", ",", "b2", ")", "=", "cl", "\n", "if", "v", ">=", "4", ":", "print", "(", "\"Adding {} as {}\"", ".", "format", "(", "cl", ",", "op_type", ")", ")", "\n", "assert", "(", "arg_typing", "[", "b1", "]", ",", "arg_typing", "[", "b2", "]", ")", "==", "(", "'b'", ",", "'b'", ")", "\n", "# since there can be an empty box, allow DRLs to introduce boxes", "\n", "box_dict", ".", "setdefault", "(", "b1", ",", "Box", "(", "b1", ")", ")", "\n", "box_dict", ".", "setdefault", "(", "b2", ",", "Box", "(", "b2", ")", ")", "\n", "disc_rels", ".", "add", "(", "(", "op", ",", "b1", ",", "b2", ")", ")", "# Disc. rels are floating", "\n", "continue", "\n", "# clause for a presupposition relation", "\n", "", "if", "op_type", "in", "[", "'PRE'", "]", ":", "# presupposition relation gives subordinate info", "\n", "            ", "(", "b1", ",", "op", ",", "b2", ")", "=", "cl", "\n", "if", "v", ">=", "4", ":", "print", "(", "\"Adding {} as {}\"", ".", "format", "(", "cl", ",", "op_type", ")", ")", "\n", "assert", "(", "arg_typing", "[", "b1", "]", ",", "arg_typing", "[", "b2", "]", ")", "==", "(", "'b'", ",", "'b'", ")", "\n", "presupp_rels", ".", "add", "(", "(", "b1", ",", "b2", ")", ")", "# b1 subordinates b2 if b1 is a presupposition of b2", "\n", "# since there can be an empty box, allow PREs to introduce boxes", "\n", "box_dict", ".", "setdefault", "(", "b1", ",", "Box", "(", "b1", ")", ")", "\n", "box_dict", ".", "setdefault", "(", "b2", ",", "Box", "(", "b2", ")", ")", "\n", "continue", "\n", "# clause for a condition with Role predicate", "\n", "", "if", "op_type", "in", "[", "'ROL'", "]", ":", "\n", "            ", "(", "b", ",", "op", ",", "t1", ",", "t2", ")", "=", "cl", "\n", "assert", "arg_typing", "[", "b", "]", "==", "'b'", "and", "unify_types", "(", "arg_typing", "[", "t1", "]", ",", "'t'", ")", "and", "unify_types", "(", "arg_typing", "[", "t2", "]", ",", "'t'", ")", "\n", "if", "v", ">=", "4", ":", "print", "(", "\"Adding {} to {} as {}\"", ".", "format", "(", "cl", ",", "b", ",", "op_type", ")", ")", "\n", "#pr_box(Box(b), indent=10)", "\n", "#print \"conditions = {}\".format(box_dict.setdefault(b, Box(b)).conds)", "\n", "box_dict", ".", "setdefault", "(", "b", ",", "Box", "(", "b", ")", ")", ".", "conds", ".", "add", "(", "(", "op", ",", "t1", ",", "t2", ")", ")", "\n", "refs", "=", "[", "r", "for", "r", "in", "[", "t1", ",", "t2", "]", "if", "arg_typing", "[", "r", "]", "==", "'x'", "]", "\n", "#box_dict[b].refs.update(refs)", "\n", "box_dict", "[", "b", "]", ".", "cond_refs", ".", "update", "(", "refs", ")", "\n", "continue", "\n", "# raise an error for the uncovered clauses", "\n", "", "raise", "RuntimeError", "(", "\"Cannot accommodate clause of this type in box || {} {}\"", ".", "format", "(", "cl", ",", "op_type", ")", ")", "\n", "", "return", "box_dict", ",", "disc_rels", ",", "presupp_rels", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.box_dict_to_subordinate_rel": [[470, 520], ["set", "connectivity_closure.copy", "connectivity_closure.update", "print", "print", "print", "print", "connectivity_closure.copy", "clf_referee.transitive_closure", "clf_referee.connectivity_closure", "connectivity_closure.add", "connectivity_closure.copy", "RuntimeError", "clf_referee.pr_2rel", "clf_referee.pr_2rel", "clf_referee.pr_2rel", "clf_referee.pr_2rel", "sorted", "sorted", "sorted", "sorted", "connectivity_closure.add"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.transitive_closure", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.connectivity_closure", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_2rel", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_2rel", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_2rel", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_2rel"], ["", "def", "box_dict_to_subordinate_rel", "(", "box_dict", ",", "presupp_rels", ",", "disc_sub_rels", ",", "v", "=", "0", ")", ":", "\n", "    ", "'''get transitive closure of the subordinate relation from\n       direct subordination available in box dictionary and a presuposition relations.\n       (b1,b2) should be read as 'b1 subordinates b2', or 'b2 is subordinate to b1', or 'refs of b1 are accessible for b2'\n    '''", "\n", "subs", "=", "set", "(", ")", "\n", "\n", "# read direct subordination from the box dictionary", "\n", "for", "b0", "in", "box_dict", ":", "\n", "        ", "for", "b1", "in", "box_dict", "[", "b0", "]", ".", "subs", ":", "\n", "            ", "subs", ".", "add", "(", "(", "b0", ",", "b1", ")", ")", "# b0 subordinates b1", "\n", "", "", "direct_subs", "=", "subs", ".", "copy", "(", ")", "\n", "if", "v", ">=", "3", ":", "print", "(", "\"direct subs: {}\"", ".", "format", "(", "pr_2rel", "(", "sorted", "(", "subs", ")", ")", ")", ")", "\n", "if", "v", ">=", "3", ":", "print", "(", "\"presup subs: {}\"", ".", "format", "(", "pr_2rel", "(", "sorted", "(", "presupp_rels", ")", ")", ")", ")", "\n", "if", "v", ">=", "3", ":", "print", "(", "\"discrs subs: {}\"", ".", "format", "(", "pr_2rel", "(", "sorted", "(", "disc_sub_rels", ")", ")", ")", ")", "\n", "\n", "init_subs", "=", "subs", ".", "copy", "(", ")", "|", "presupp_rels", "|", "disc_sub_rels", "# record subs before expansion", "\n", "subs", ".", "update", "(", "presupp_rels", "|", "disc_sub_rels", ")", "\n", "# if b2's condition uses referent introduced by b1,", "\n", "# then make b1 subordinate b2, i.e. b2 is subordinate to b1", "\n", "for", "b2", "in", "box_dict", ":", "\n", "        ", "for", "ref", "in", "box_dict", "[", "b2", "]", ".", "cond_refs", ":", "\n", "            ", "if", "v", ">=", "4", ":", "\"{} if in {}\"", ".", "format", "(", "ref", ",", "b2", ")", "\n", "if", "ref", "not", "in", "box_dict", "[", "b2", "]", ".", "refs", ":", "\n", "                ", "if", "v", ">=", "4", ":", "\"{} is not introduced by {}\"", ".", "format", "(", "ref", ",", "b2", ")", "\n", "# referent is not introduced by the same box", "\n", "for", "b1", "in", "box_dict", ":", "\n", "                    ", "if", "(", "b1", "!=", "b2", ")", "and", "(", "ref", "in", "box_dict", "[", "b1", "]", ".", "refs", ")", ":", "\n", "# b1 introduces referent that b2 uses", "\n", "                        ", "subs", ".", "add", "(", "(", "b1", ",", "b2", ")", ")", "\n", "", "", "", "", "", "if", "v", ">=", "3", ":", "print", "(", "\"+ accessibility subs: {}\"", ".", "format", "(", "pr_2rel", "(", "sorted", "(", "subs", "-", "init_subs", ")", ")", ")", ")", "\n", "# get closure of subs by combining simple transitive rule", "\n", "# and subordination connectivity, which encourages connectivity of the relation", "\n", "# connectivity: if b0 directly subordinates b1, and b2 is not subordinate to b0 and subordinates b1,", "\n", "#   then b2 will subordinates b0 too", "\n", "#   for example, if k0 directly subordinates b1 & b2 since b1->b2 is in k0,", "\n", "#   then presupposition b0 of b1 and b2 will subordinate k0.", "\n", "# cl_subs = subs.copy()", "\n", "while", "True", ":", "\n", "        ", "temp_cl", "=", "subs", ".", "copy", "(", ")", "\n", "tran_cl", "=", "transitive_closure", "(", "temp_cl", ",", "v", "=", "v", ")", "\n", "#subs = tran_cl", "\n", "subs", "=", "connectivity_closure", "(", "box_dict", ",", "tran_cl", ",", "v", "=", "v", ")", "# without connectivity ca 40% of CLFs are wrong", "\n", "if", "subs", "==", "temp_cl", ":", "\n", "            ", "break", "\n", "# subordination relation has no loops", "\n", "", "", "for", "(", "a", ",", "b", ")", "in", "subs", ":", "\n", "        ", "if", "a", "==", "b", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Subordinate relation has a loop || {}>{}\"", ".", "format", "(", "a", ",", "b", ")", ")", "\n", "", "", "return", "subs", ",", "direct_subs", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.transitive_closure": [[523, 538], ["relation.copy", "relation.copy.copy", "print", "clf_referee.pr_2rel", "relation.copy.add", "sorted"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_2rel"], ["", "def", "transitive_closure", "(", "relation", ",", "v", "=", "0", ")", ":", "\n", "    ", "'''return a transitive closure of the input relation'''", "\n", "tran_closure", "=", "relation", ".", "copy", "(", ")", "\n", "while", "True", ":", "\n", "# add trnsitively obtained relations", "\n", "        ", "temp_rel", "=", "tran_closure", ".", "copy", "(", ")", "\n", "for", "(", "a1", ",", "b1", ")", "in", "temp_rel", ":", "\n", "            ", "for", "(", "a2", ",", "b2", ")", "in", "temp_rel", ":", "\n", "                ", "if", "b1", "==", "a2", ":", "\n", "                    ", "tran_closure", ".", "add", "(", "(", "a1", ",", "b2", ")", ")", "\n", "# exit when no increase is detected", "\n", "", "", "", "if", "temp_rel", "==", "tran_closure", ":", "\n", "            ", "break", "\n", "", "", "if", "v", ">=", "4", ":", "print", "(", "\"+ transitivity closure: {}\"", ".", "format", "(", "pr_2rel", "(", "sorted", "(", "tran_closure", "-", "relation", ")", ")", ")", ")", "\n", "return", "tran_closure", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.connectivity_closure": [[540, 550], ["subs.copy", "print", "subs.copy.add", "clf_referee.pr_2rel", "sorted"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_2rel"], ["", "def", "connectivity_closure", "(", "box_dict", ",", "subs", ",", "v", "=", "0", ")", ":", "\n", "    ", "'''return a connectivity closure of the subordination relation'''", "\n", "cl_subs", "=", "subs", ".", "copy", "(", ")", "\n", "for", "b0", "in", "box_dict", ":", "\n", "        ", "for", "b1", "in", "box_dict", "[", "b0", "]", ".", "subs", ":", "\n", "# add b>b0 if b0>b1 immediately and b>b1", "\n", "            ", "for", "b", "in", "[", "b2", "for", "(", "b2", ",", "b3", ")", "in", "subs", "if", "b3", "==", "b1", "and", "b2", "!=", "b0", "and", "(", "b0", ",", "b2", ")", "not", "in", "subs", "]", ":", "\n", "                ", "cl_subs", ".", "add", "(", "(", "b", ",", "b0", ")", ")", "\n", "", "", "", "if", "v", ">=", "4", ":", "print", "(", "\"+ connecticity closure: {}\"", ".", "format", "(", "pr_2rel", "(", "sorted", "(", "cl_subs", "-", "subs", ")", ")", ")", ")", "\n", "return", "cl_subs", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.linear_order": [[552, 569], ["elements.copy", "elements.copy", "bot_set.pop", "top_set.pop", "bot_set.remove", "top_set.remove", "RuntimeError", "RuntimeError", "len", "len", "clf_referee.pr_set", "clf_referee.pr_set"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_set", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_set"], ["", "def", "linear_order", "(", "elements", ",", "rels", ",", "v", "=", "0", ")", ":", "\n", "    ", "'''Check if relation is linear over elements and return max/top and min/bot elements.\n       Relation is a set of tuples (op, el1, el2)\n    '''", "\n", "# stop if elemenst or rels is empty", "\n", "if", "not", "(", "rels", "and", "elements", ")", ":", "return", "None", ",", "None", "\n", "bot_set", ",", "top_set", "=", "elements", ".", "copy", "(", ")", ",", "elements", ".", "copy", "(", ")", "\n", "try", ":", "# remove elemenst from set gradually, in the end singleton sets should remain", "\n", "        ", "for", "_", ",", "a", ",", "b", "in", "rels", ":", "\n", "            ", "bot_set", ".", "remove", "(", "b", ")", "\n", "top_set", ".", "remove", "(", "a", ")", "\n", "", "if", "not", "(", "len", "(", "bot_set", ")", "==", "1", "and", "len", "(", "top_set", ")", "==", "1", ")", ":", "\n", "             ", "raise", "RuntimeError", "(", "'Error'", ")", "\n", "", "", "except", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"Discourse boxes are not linearly ordered || min ({}) and max ({})\"", ".", "format", "(", "pr_set", "(", "bot_set", ")", ",", "pr_set", "(", "top_set", ")", ")", ")", "\n", "", "return", "bot_set", ".", "pop", "(", ")", ",", "top_set", ".", "pop", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.connected_boxes": [[571, 597], ["set", "set", "set.copy", "expanding.copy.copy", "RuntimeError", "elements.pop", "rels.copy", "print", "clf_referee.pr_set", "clf_referee.pr_set", "set.add", "rels.remove", "set.add", "rels.remove", "clf_referee.pr_set"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_set", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_set", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.pr_set"], ["", "def", "connected_boxes", "(", "elements", ",", "rels", ",", "v", "=", "0", ")", ":", "\n", "    ", "'''Check if all boxes are connected with a relation,\n       i.e. one can visist to any box from any box via the relation (non-directional)\n    '''", "\n", "# stop if elements or rels is empty", "\n", "if", "not", "(", "rels", "and", "elements", ")", ":", "\n", "        ", "return", "False", "\n", "# start with empty set and increase gradually to cover all elements", "\n", "", "before_expansion", "=", "set", "(", ")", "\n", "expanding", "=", "set", "(", "[", "elements", ".", "pop", "(", ")", "]", ")", "# start with a random element", "\n", "while", "before_expansion", "!=", "expanding", ":", "# i.e. after expansion it didn't expand", "\n", "        ", "before_expansion", "=", "expanding", ".", "copy", "(", ")", "\n", "for", "i", "in", "before_expansion", ".", "copy", "(", ")", ":", "\n", "            ", "for", "(", "a", ",", "b", ")", "in", "rels", ".", "copy", "(", ")", ":", "\n", "                ", "if", "i", "==", "a", ":", "\n", "                    ", "expanding", ".", "add", "(", "b", ")", "\n", "rels", ".", "remove", "(", "(", "a", ",", "b", ")", ")", "\n", "", "if", "i", "==", "b", ":", "\n", "                    ", "expanding", ".", "add", "(", "a", ")", "\n", "rels", ".", "remove", "(", "(", "a", ",", "b", ")", ")", "\n", "", "", "", "", "diff", "=", "elements", "-", "expanding", "\n", "if", "diff", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"Boxes are not connected || {} are not connected with {}\"", ".", "format", "(", "pr_set", "(", "diff", ")", ",", "pr_set", "(", "expanding", ")", ")", ")", "\n", "", "else", ":", "\n", "        ", "if", "v", ">=", "2", ":", "print", "(", "\"Boxes {} are connected\"", ".", "format", "(", "pr_set", "(", "elements", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.unbound_referents": [[599, 614], ["set", "next", "set.add"], "function", ["None"], ["", "", "def", "unbound_referents", "(", "box_dict", ",", "sub_rel", ",", "v", "=", "0", ")", ":", "\n", "    ", "'''get a set of unbound discourse referents\n    '''", "\n", "unbound", "=", "set", "(", ")", "\n", "for", "b", "in", "box_dict", ":", "\n", "        ", "outsider_refs", "=", "box_dict", "[", "b", "]", ".", "cond_refs", "-", "box_dict", "[", "b", "]", ".", "refs", "\n", "#print \"outsider refs for {} are {}\".format(b, pr_set(outsider_refs))", "\n", "for", "x", "in", "outsider_refs", ":", "\n", "# find a box subordinating the current one and introducing x as referent", "\n", "            ", "if", "not", "next", "(", "(", "b1", "for", "(", "b1", ",", "b2", ")", "in", "sub_rel", "\n", "if", "b2", "==", "b", "and", "x", "in", "box_dict", "[", "b1", "]", ".", "refs", ")", ",", "\n", "False", ")", ":", "\n", "                ", "unbound", ".", "add", "(", "x", ")", "\n", "# one can already raise error for efficiency", "\n", "", "", "", "return", "unbound", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.clf_referee.non_subordinating_boxes": [[616, 626], ["set", "next", "set.add"], "function", ["None"], ["", "def", "non_subordinating_boxes", "(", "box_dict", ",", "sub_rel", ",", "v", "=", "0", ")", ":", "\n", "    ", "'''Get boxes that do not subordinate anything\n    '''", "\n", "non_sub_boxes", "=", "set", "(", ")", "\n", "for", "a", "in", "box_dict", ":", "\n", "# if there is b such that a subordinates b", "\n", "        ", "if", "next", "(", "(", "b", "for", "b", "in", "box_dict", "if", "a", "!=", "b", "and", "(", "a", ",", "b", ")", "in", "sub_rel", ")", ",", "False", ")", ":", "\n", "            ", "continue", "\n", "", "non_sub_boxes", ".", "add", "(", "a", ")", "\n", "", "return", "non_sub_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.DRS_match.__init__": [[7, 17], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "\t\t", "self", ".", "matched_clause_keys", "=", "{", "}", "\n", "#we have to make sure that each produced and gold clause can only be (partially) matched once. We save that here and check", "\n", "self", ".", "clause_dict_gold", "=", "{", "}", "\n", "self", ".", "clause_dict_prod", "=", "{", "}", "\n", "#Save all combinations of variables that match, so we can print matching clauses later", "\n", "self", ".", "clause_pairs", "=", "{", "}", "\n", "self", ".", "match_num", "=", "0", "\n", "self", ".", "mapping", "=", "[", "]", "#initialized empty but always set to the current mapping", "\n", "self", ".", "weight_dict", "=", "{", "}", "#initialized empty but always set to the current weight_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.get_memory_usage": [[19, 24], ["psutil.Process", "os.getpid", "float", "psutil.Process.memory_info"], "function", ["None"], ["", "", "def", "get_memory_usage", "(", ")", ":", "\n", "\t", "'''return the memory usage in MB'''", "\n", "process", "=", "psutil", ".", "Process", "(", "os", ".", "getpid", "(", ")", ")", "\n", "mem", "=", "process", ".", "memory_info", "(", ")", "[", "0", "]", "/", "float", "(", "1000000", ")", "\n", "return", "mem", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.get_best_match": [[26, 133], ["hill_climbing.compute_pool", "enumerate", "hill_climbing.compute_match", "match_clause_dict.clear", "len", "hill_climbing.smart_concept_mapping", "hill_climbing.compute_match", "hill_climbing.get_mapping_list", "len", "len", "len", "ValueError", "tuple", "len", "set", "len", "hill_climbing.get_best_gain", "hill_climbing.get_memory_usage", "match_clause_dict.clear", "print", "len", "tuple", "print", "ValueError", "tuple", "len"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.compute_pool", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.compute_match", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.smart_concept_mapping", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.compute_match", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.get_mapping_list", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.get_best_gain", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.get_memory_usage"], ["", "def", "get_best_match", "(", "prod_drs", ",", "gold_drs", ",", "args", ",", "single", ")", ":", "\n", "\t", "\"\"\"\n\tGet the highest clause match number between two sets of clauses via hill-climbing.\n\tArguments:\n\t\tprod_drs: Object with all information of the produced DRS\n\t\tgold_drs: Object with all information of the gold DRS\n\t\targs: command line argparse arguments\n\t\tsingle: whether this is the only DRS we do\n\tReturns:\n\t\tbest_match: the node mapping that results in the highest clause matching number\n\t\tbest_match_num: the highest clause matching number\n\n\t\"\"\"", "\n", "\n", "# Compute candidate pool - all possible node match candidates.", "\n", "# In the hill-climbing, we only consider candidate in this pool to save computing time.", "\n", "# weight_dict is a dictionary that maps a pair of node", "\n", "(", "candidate_mappings", ",", "weight_dict", ")", "=", "compute_pool", "(", "prod_drs", ",", "gold_drs", ",", "args", ")", "\n", "#for w in weight_dict:", "\n", "#print w", "\n", "#for x in weight_dict[w]:", "\n", "#print x, weight_dict[w][x]", "\n", "#print '\\n'", "\n", "# Save mapping and number of matches so that we don't have to calculate stuff twice", "\n", "match_clause_dict", "=", "{", "}", "\n", "\n", "# Set intitial values", "\n", "best_match_num", "=", "0", "\n", "best_mapping", "=", "[", "-", "1", "]", "*", "len", "(", "prod_drs", ".", "var_map", ")", "\n", "found_idx", "=", "0", "\n", "\n", "# Find smart mappings first, if specified", "\n", "if", "args", ".", "smart", "==", "'conc'", ":", "\n", "\t\t", "smart_conc", "=", "smart_concept_mapping", "(", "candidate_mappings", ",", "prod_drs", ".", "concepts", ",", "gold_drs", ".", "concepts", ")", "\n", "matches", ",", "match_clause_dict", "=", "compute_match", "(", "smart_conc", ",", "weight_dict", ",", "match_clause_dict", ")", "\n", "smart_mappings", "=", "[", "[", "smart_conc", ",", "matches", "]", "]", "\n", "smart_fscores", "=", "[", "0", "]", "\n", "", "else", ":", "\n", "\t\t", "smart_mappings", "=", "[", "]", "\n", "smart_fscores", "=", "[", "]", "\n", "\n", "# Then add random mappings", "\n", "", "mapping_order", "=", "smart_mappings", "+", "get_mapping_list", "(", "candidate_mappings", ",", "weight_dict", ",", "args", ".", "restarts", "-", "len", "(", "smart_fscores", ")", ",", "match_clause_dict", ")", "\n", "#mapping_order = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]", "\n", "# Set initial values", "\n", "done_mappings", "=", "{", "}", "\n", "# Loop over the mappings to find the best score", "\n", "for", "i", ",", "map_cur", "in", "enumerate", "(", "mapping_order", ")", ":", "# number of restarts is number of mappings", "\n", "\t\t", "cur_mapping", "=", "map_cur", "[", "0", "]", "\n", "match_num", "=", "map_cur", "[", "1", "]", "\n", "num_vars", "=", "len", "(", "gold_drs", ".", "var_map", ")", "\n", "\n", "if", "tuple", "(", "cur_mapping", ")", "in", "done_mappings", ":", "\n", "\t\t\t", "match_num", "=", "done_mappings", "[", "tuple", "(", "cur_mapping", ")", "]", "\n", "", "else", ":", "\n", "# Do hill-climbing until there will be no gain for new node mapping", "\n", "\t\t\t", "while", "True", ":", "\n", "# get best gain", "\n", "\t\t\t\t", "(", "gain", ",", "new_mapping", ",", "match_clause_dict", ")", "=", "get_best_gain", "(", "cur_mapping", ",", "candidate_mappings", ",", "weight_dict", ",", "num_vars", ",", "match_clause_dict", ")", "\n", "\n", "if", "match_num", "+", "gain", ">", "prod_drs", ".", "total_clauses", ":", "\n", "\t\t\t\t\t", "print", "(", "new_mapping", ",", "match_num", "+", "gain", ",", "prod_drs", ".", "total_clauses", ")", "\n", "raise", "ValueError", "(", "\n", "\"More matches than there are produced clauses. If this ever occurs something is seriously wrong with the algorithm\"", ")", "\n", "\n", "", "if", "gain", "<=", "0", ":", "\n", "# print 'No gain so break'", "\n", "\t\t\t\t\t", "break", "\n", "# otherwise update match_num and mapping", "\n", "", "match_num", "+=", "gain", "\n", "cur_mapping", "=", "new_mapping", "[", ":", "]", "\n", "\n", "# Save mappings we already did", "\n", "", "done_mappings", "[", "tuple", "(", "cur_mapping", ")", "]", "=", "match_num", "\n", "\n", "# Update our best match number so far", "\n", "if", "match_num", ">", "best_match_num", ":", "\n", "\t\t\t\t", "best_mapping", "=", "cur_mapping", "[", ":", "]", "\n", "best_match_num", "=", "match_num", "\n", "found_idx", "=", "i", "\n", "\n", "# Check if we exceed maximum memory, if so, clear clause_dict", "\n", "# (saves us from getting memory issues with high number of", "\n", "# restarts)", "\n", "", "if", "get_memory_usage", "(", ")", ">", "args", ".", "mem_limit", ":", "\n", "\t\t\t\t", "match_clause_dict", ".", "clear", "(", ")", "\n", "\n", "# If we have matched as much we can (precision 1.0), we might as well", "\n", "# stop instead of doing all other restarts - but always do smart mappings", "\n", "", "", "if", "match_num", "==", "prod_drs", ".", "total_clauses", "and", "i", ">", "len", "(", "smart_fscores", ")", "-", "1", ":", "\n", "\t\t\t", "if", "args", ".", "prin", "and", "single", ":", "\n", "\t\t\t\t", "print", "(", "'Best match already found, stop restarts at restart {0}'", ".", "format", "(", "i", ")", ")", "\n", "", "if", "i", "<", "len", "(", "smart_fscores", ")", ":", "\n", "\t\t\t\t", "smart_fscores", "[", "i", "]", "=", "match_num", "\n", "", "break", "\n", "\n", "# Add smart F-scores", "\n", "", "if", "i", "<", "len", "(", "smart_fscores", ")", ":", "# are we still adding smart F-scores?", "\n", "\t\t\t", "smart_fscores", "[", "i", "]", "=", "match_num", "\n", "\n", "", "", "_", ",", "clause_pairs", "=", "compute_match", "(", "best_mapping", ",", "weight_dict", ",", "{", "}", ",", "final", "=", "True", ")", "\n", "\n", "# Clear matches out of memory", "\n", "match_clause_dict", ".", "clear", "(", ")", "\n", "if", "len", "(", "set", "(", "[", "x", "for", "x", "in", "best_mapping", "if", "x", "!=", "-", "1", "]", ")", ")", "!=", "len", "(", "[", "x", "for", "x", "in", "best_mapping", "if", "x", "!=", "-", "1", "]", ")", ":", "\n", "\t\t", "raise", "ValueError", "(", "\"Variable maps to two other variables, not allowed, and should never happen -- {0}\"", ".", "format", "(", "best_mapping", ")", ")", "\n", "", "return", "best_mapping", ",", "best_match_num", ",", "found_idx", ",", "smart_fscores", ",", "clause_pairs", ",", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_random_mapping": [[135, 153], ["list", "random.shuffle", "range", "len", "list", "len", "random.randint", "list.pop", "len"], "function", ["None"], ["", "def", "add_random_mapping", "(", "result", ",", "matched_dict", ",", "candidate_mapping", ")", ":", "\n", "\t", "'''If mapping is still -1 after adding a smart mapping, randomly fill in the blanks'''", "\n", "# First shuffle the way we loop over result, so that we increase the randomness of the mappings", "\n", "indices", "=", "list", "(", "range", "(", "len", "(", "result", ")", ")", ")", "\n", "random", ".", "shuffle", "(", "indices", ")", "\n", "for", "idx", "in", "indices", ":", "\n", "\t\t", "if", "result", "[", "idx", "]", "==", "-", "1", ":", "# no mapping yet", "\n", "\t\t\t", "candidates", "=", "list", "(", "candidate_mapping", "[", "idx", "]", ")", "\n", "while", "len", "(", "candidates", ")", ">", "0", ":", "\n", "# get a random node index from candidates", "\n", "\t\t\t\t", "rid", "=", "random", ".", "randint", "(", "0", ",", "len", "(", "candidates", ")", "-", "1", ")", "\n", "if", "candidates", "[", "rid", "]", "in", "matched_dict", ":", "\n", "\t\t\t\t\t", "candidates", ".", "pop", "(", "rid", ")", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "matched_dict", "[", "candidates", "[", "rid", "]", "]", "=", "1", "\n", "result", "[", "idx", "]", "=", "candidates", "[", "rid", "]", "\n", "break", "\n", "", "", "", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.smart_concept_mapping": [[155, 185], ["hill_climbing.add_random_mapping", "len", "int", "int", "int", "int"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_random_mapping"], ["", "def", "smart_concept_mapping", "(", "candidate_mapping", ",", "concepts1", ",", "concepts2", ")", ":", "\n", "\t", "\"\"\"\n\tInitialize mapping based on the concept mapping (smart initialization)\n\tArguments:\n\t\tcandidate_mapping: candidate node match list\n\t\tconcepts1/2: list of concepts clauses: var1 concept \"sense\" var2\n\tReturns:\n\t\tsmart initial mapping between two DRSs based on concepts\n\t\"\"\"", "\n", "matched_dict", "=", "{", "}", "\n", "result", "=", "[", "-", "1", "]", "*", "len", "(", "candidate_mapping", ")", "\n", "for", "conc1", "in", "concepts1", ":", "\n", "\t\t", "for", "conc2", "in", "concepts2", ":", "\n", "# Check if concept and sense matches", "\n", "\t\t\t", "if", "conc1", "[", "1", "]", "==", "conc2", "[", "1", "]", "and", "conc1", "[", "2", "]", "==", "conc2", "[", "2", "]", ":", "\n", "# If so, check if variables can match", "\n", "\t\t\t\t", "var11", ",", "var12", ",", "var21", ",", "var22", "=", "int", "(", "conc1", "[", "0", "]", "[", "1", ":", "]", ")", ",", "int", "(", "\n", "conc1", "[", "3", "]", "[", "1", ":", "]", ")", ",", "int", "(", "conc2", "[", "0", "]", "[", "1", ":", "]", ")", ",", "int", "(", "conc2", "[", "3", "]", "[", "1", ":", "]", ")", "\n", "if", "var21", "in", "candidate_mapping", "[", "var11", "]", "and", "var22", "in", "candidate_mapping", "[", "var12", "]", ":", "\n", "# Match here, so add mapping if we didn't do so before", "\n", "\t\t\t\t\t", "if", "result", "[", "var11", "]", "==", "-", "1", "and", "var21", "not", "in", "matched_dict", ":", "\n", "\t\t\t\t\t\t", "result", "[", "var11", "]", "=", "var21", "\n", "matched_dict", "[", "var21", "]", "=", "1", "\n", "", "if", "result", "[", "var12", "]", "==", "-", "1", "and", "var22", "not", "in", "matched_dict", ":", "\n", "\t\t\t\t\t\t", "result", "[", "var12", "]", "=", "var22", "\n", "matched_dict", "[", "var22", "]", "=", "1", "\n", "\n", "# Randomly fill in the blanks for variables that did not have a smart concept mapping", "\n", "", "", "", "", "", "result", "=", "add_random_mapping", "(", "result", ",", "matched_dict", ",", "candidate_mapping", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.get_mapping_list": [[187, 194], ["hill_climbing.get_random_set"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.get_random_set"], ["", "def", "get_mapping_list", "(", "candidate_mappings", ",", "weight_dict", ",", "total_restarts", ",", "match_clause_dict", ")", ":", "\n", "\t", "'''Function that returns a mapping list, each item being [mapping, match_num] '''", "\n", "\n", "if", "total_restarts", "<=", "0", ":", "# nothing to do here, we do more smart mappings than restarts anyway", "\n", "\t\t", "return", "[", "]", "\n", "", "random_maps", "=", "get_random_set", "(", "candidate_mappings", ",", "weight_dict", ",", "total_restarts", ",", "match_clause_dict", ")", "# get set of random mappings here", "\n", "return", "random_maps", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.get_random_set": [[196, 212], ["hill_climbing.add_random_mapping", "hill_climbing.compute_match", "len", "random_maps.append", "len", "len", "set"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_random_mapping", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.compute_match"], ["", "def", "get_random_set", "(", "candidate_mappings", ",", "weight_dict", ",", "map_ceil", ",", "match_clause_dict", ")", ":", "\n", "\t", "'''Function that returns a set of random mappings based on candidate_mappings'''", "\n", "\n", "random_maps", "=", "[", "]", "\n", "count_duplicate", "=", "0", "\n", "\n", "# only do random mappings we haven't done before, but if we have 50 duplicates in a row, we are probably done with all mappings", "\n", "while", "len", "(", "random_maps", ")", "<", "map_ceil", "and", "count_duplicate", "<=", "50", ":", "\n", "\t\t", "cur_mapping", "=", "add_random_mapping", "(", "[", "-", "1", "for", "x", "in", "candidate_mappings", "]", ",", "{", "}", ",", "candidate_mappings", ")", "\n", "match_num", ",", "match_clause_dict", "=", "compute_match", "(", "cur_mapping", ",", "weight_dict", ",", "match_clause_dict", ")", "\n", "if", "[", "cur_mapping", ",", "match_num", "]", "not", "in", "random_maps", "and", "len", "(", "set", "(", "[", "x", "for", "x", "in", "cur_mapping", "if", "x", "!=", "-", "1", "]", ")", ")", "==", "len", "(", "[", "x", "for", "x", "in", "cur_mapping", "if", "x", "!=", "-", "1", "]", ")", ":", "\n", "\t\t\t", "random_maps", ".", "append", "(", "[", "cur_mapping", ",", "match_num", "]", ")", "\n", "count_duplicate", "=", "0", "\n", "", "else", ":", "\n", "\t\t\t", "count_duplicate", "+=", "1", "\n", "", "", "return", "random_maps", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize": [[214, 217], ["None"], "function", ["None"], ["", "def", "normalize", "(", "item", ")", ":", "\n", "\t", "'''We do not normalize anymore, but we might add something here'''", "\n", "return", "item", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_node_pairs": [[219, 234], ["len", "len", "set", "[].append", "[].append"], "function", ["None"], ["", "def", "add_node_pairs", "(", "node_pair1", ",", "node_pair2", ",", "node_pair3", ",", "weight_dict", ",", "weight_score", ",", "no_match", ",", "gold_clause_idx", ",", "prod_clause_idx", ")", ":", "\n", "\t", "'''Add possible node pairs to weight dict for node pair1'''", "\n", "\n", "if", "len", "(", "[", "node_pair1", ",", "node_pair2", ",", "node_pair3", "]", ")", "==", "len", "(", "set", "(", "[", "node_pair1", ",", "node_pair2", ",", "node_pair3", "]", ")", ")", ":", "# node pairs cant be duplicates", "\n", "\t\t", "if", "node_pair1", "in", "weight_dict", ":", "\n", "\t\t\t", "if", "(", "node_pair2", ",", "node_pair3", ")", "in", "weight_dict", "[", "node_pair1", "]", ":", "\n", "\t\t\t\t", "weight_dict", "[", "node_pair1", "]", "[", "(", "node_pair2", ",", "node_pair3", ")", "]", ".", "append", "(", "[", "weight_score", ",", "no_match", ",", "gold_clause_idx", ",", "prod_clause_idx", "]", ")", "\n", "", "elif", "(", "node_pair3", ",", "node_pair2", ")", "in", "weight_dict", "[", "node_pair1", "]", ":", "\n", "\t\t\t\t", "weight_dict", "[", "node_pair1", "]", "[", "(", "node_pair3", ",", "node_pair2", ")", "]", ".", "append", "(", "[", "weight_score", ",", "no_match", ",", "gold_clause_idx", ",", "prod_clause_idx", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "weight_dict", "[", "node_pair1", "]", "[", "(", "node_pair2", ",", "node_pair3", ")", "]", "=", "[", "[", "weight_score", ",", "no_match", ",", "gold_clause_idx", ",", "prod_clause_idx", "]", "]", "\n", "", "", "else", ":", "\n", "\t\t\t", "weight_dict", "[", "node_pair1", "]", "=", "{", "}", "\n", "weight_dict", "[", "node_pair1", "]", "[", "(", "node_pair2", ",", "node_pair3", ")", "]", "=", "[", "[", "weight_score", ",", "no_match", ",", "gold_clause_idx", ",", "prod_clause_idx", "]", "]", "\n", "", "", "return", "weight_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_candidate_mapping_three_vars": [[236, 362], ["int", "int", "int", "int", "int", "int", "hill_climbing.same_edge_type_check", "candidate_mapping[].add", "candidate_mapping[].add", "candidate_mapping[].add", "hill_climbing.add_node_pairs", "hill_climbing.add_node_pairs", "hill_climbing.add_node_pairs", "len", "len", "len", "len", "len", "len", "hill_climbing.normalize", "hill_climbing.normalize", "candidate_mapping[].add", "candidate_mapping[].add", "candidate_mapping[].add", "hill_climbing.add_node_pairs", "hill_climbing.add_node_pairs", "hill_climbing.add_node_pairs", "hill_climbing.normalize", "hill_climbing.normalize", "candidate_mapping[].add", "candidate_mapping[].add", "candidate_mapping[].add", "hill_climbing.add_node_pairs", "hill_climbing.add_node_pairs", "hill_climbing.add_node_pairs", "candidate_mapping[].add", "hill_climbing.add_single_var_mapping", "candidate_mapping[].add", "hill_climbing.add_single_var_mapping", "candidate_mapping[].add", "hill_climbing.add_single_var_mapping", "hill_climbing.add_candidate_mapping", "hill_climbing.add_candidate_mapping", "hill_climbing.add_candidate_mapping", "float", "float", "float", "float", "float", "float", "float", "float"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.same_edge_type_check", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_node_pairs", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_node_pairs", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_node_pairs", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_node_pairs", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_node_pairs", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_node_pairs", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_node_pairs", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_node_pairs", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_node_pairs", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_single_var_mapping", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_single_var_mapping", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_single_var_mapping", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_candidate_mapping", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_candidate_mapping", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_candidate_mapping"], ["", "def", "add_candidate_mapping_three_vars", "(", "prod_clauses", ",", "gold_clauses", ",", "prod_drs", ",", "gold_drs", ",", "candidate_mapping", ",", "weight_dict", ",", "i", ",", "j", ",", "add_to_index", ",", "add_to_index2", ",", "args", ")", ":", "\n", "\t", "'''Add the candidate mapping for this node pair to the weight dict - for three variables\n\t   It is possible to do partial matching, but the usual case only does full matching'''", "\n", "\n", "# Set initial variables", "\n", "index1", ",", "index2", ",", "index3", ",", "edge_index", "=", "0", ",", "2", ",", "3", ",", "1", "\n", "allowed_var1", ",", "allowed_var2", ",", "allowed_var3", ",", "same_edge_type", "=", "False", ",", "False", ",", "False", ",", "False", "\n", "edge_match", "=", "0", "\n", "\n", "# Set values to make things a bit clearer", "\n", "node1_index_drs1", "=", "int", "(", "prod_clauses", "[", "i", "]", "[", "index1", "]", "[", "len", "(", "prod_drs", ".", "prefix", ")", ":", "]", ")", "\n", "node1_index_drs2", "=", "int", "(", "gold_clauses", "[", "j", "]", "[", "index1", "]", "[", "len", "(", "gold_drs", ".", "prefix", ")", ":", "]", ")", "\n", "node2_index_drs1", "=", "int", "(", "prod_clauses", "[", "i", "]", "[", "index2", "]", "[", "len", "(", "prod_drs", ".", "prefix", ")", ":", "]", ")", "\n", "node2_index_drs2", "=", "int", "(", "gold_clauses", "[", "j", "]", "[", "index2", "]", "[", "len", "(", "gold_drs", ".", "prefix", ")", ":", "]", ")", "\n", "node3_index_drs1", "=", "int", "(", "prod_clauses", "[", "i", "]", "[", "index3", "]", "[", "len", "(", "prod_drs", ".", "prefix", ")", ":", "]", ")", "\n", "node3_index_drs2", "=", "int", "(", "gold_clauses", "[", "j", "]", "[", "index3", "]", "[", "len", "(", "gold_drs", ".", "prefix", ")", ":", "]", ")", "\n", "\n", "node_pair1", "=", "(", "node1_index_drs1", ",", "node1_index_drs2", ")", "\n", "node_pair2", "=", "(", "node2_index_drs1", ",", "node2_index_drs2", ")", "\n", "node_pair3", "=", "(", "node3_index_drs1", ",", "node3_index_drs2", ")", "\n", "\n", "# Check if nodes are even allowed to match, based on their type", "\n", "if", "prod_drs", ".", "type_vars", "[", "prod_clauses", "[", "i", "]", "[", "index1", "]", "]", "==", "gold_drs", ".", "type_vars", "[", "gold_clauses", "[", "j", "]", "[", "index1", "]", "]", ":", "\n", "\t\t", "allowed_var1", "=", "True", "\n", "", "if", "prod_drs", ".", "type_vars", "[", "prod_clauses", "[", "i", "]", "[", "index2", "]", "]", "==", "gold_drs", ".", "type_vars", "[", "gold_clauses", "[", "j", "]", "[", "index2", "]", "]", ":", "\n", "\t\t", "allowed_var2", "=", "True", "\n", "", "if", "prod_drs", ".", "type_vars", "[", "prod_clauses", "[", "i", "]", "[", "index3", "]", "]", "==", "gold_drs", ".", "type_vars", "[", "gold_clauses", "[", "j", "]", "[", "index3", "]", "]", ":", "\n", "\t\t", "allowed_var3", "=", "True", "\n", "\n", "", "if", "not", "args", ".", "partial", ":", "\n", "# Usual case -- do not do partial matching", "\n", "# Check if all vars can match and if edges matches as well", "\n", "\t\t", "if", "allowed_var1", "and", "allowed_var2", "and", "allowed_var3", "and", "normalize", "(", "prod_clauses", "[", "i", "]", "[", "edge_index", "]", ")", "==", "normalize", "(", "gold_clauses", "[", "j", "]", "[", "edge_index", "]", ")", ":", "\n", "\t\t\t", "candidate_mapping", "[", "node1_index_drs1", "]", ".", "add", "(", "node1_index_drs2", ")", "\n", "candidate_mapping", "[", "node2_index_drs1", "]", ".", "add", "(", "node2_index_drs2", ")", "\n", "candidate_mapping", "[", "node3_index_drs1", "]", ".", "add", "(", "node3_index_drs2", ")", "\n", "no_match", "=", "''", "# empty no_match for normal matching", "\n", "weight_score", "=", "1", "\n", "\n", "# add to weight dict here, only do for 1,2 - 1,3 and 2,3", "\n", "weight_dict", "=", "add_node_pairs", "(", "node_pair1", ",", "node_pair2", ",", "node_pair3", ",", "weight_dict", ",", "weight_score", ",", "no_match", ",", "j", "+", "add_to_index", ",", "i", "+", "add_to_index2", ")", "\n", "weight_dict", "=", "add_node_pairs", "(", "node_pair2", ",", "node_pair1", ",", "node_pair3", ",", "weight_dict", ",", "weight_score", ",", "no_match", ",", "j", "+", "add_to_index", ",", "i", "+", "add_to_index2", ")", "\n", "weight_dict", "=", "add_node_pairs", "(", "node_pair3", ",", "node_pair1", ",", "node_pair2", ",", "weight_dict", ",", "weight_score", ",", "no_match", ",", "j", "+", "add_to_index", ",", "i", "+", "add_to_index2", ")", "\n", "\n", "# If the edge is part of inv_boxes, it means that e.g. b1 INV_BOX x1 x2 == b1 INV_BOX x2 x1", "\n", "# We want to add this information to the matching dictionary as well here", "\n", "if", "prod_clauses", "[", "i", "]", "[", "edge_index", "]", "in", "prod_drs", ".", "inv_boxes", ":", "\n", "# Node pairs are inverted now", "\n", "\t\t\t\t", "node_pair_new1", "=", "(", "node1_index_drs1", ",", "node1_index_drs2", ")", "\n", "node_pair_new2", "=", "(", "node2_index_drs1", ",", "node3_index_drs2", ")", "\n", "node_pair_new3", "=", "(", "node3_index_drs1", ",", "node2_index_drs2", ")", "\n", "# Add correct candidate mappings for these nodes", "\n", "candidate_mapping", "[", "node1_index_drs1", "]", ".", "add", "(", "node1_index_drs2", ")", "\n", "candidate_mapping", "[", "node2_index_drs1", "]", ".", "add", "(", "node3_index_drs2", ")", "\n", "candidate_mapping", "[", "node3_index_drs1", "]", ".", "add", "(", "node2_index_drs2", ")", "\n", "# Update the weight dictionary", "\n", "weight_dict", "=", "add_node_pairs", "(", "node_pair_new1", ",", "node_pair_new2", ",", "node_pair_new3", ",", "weight_dict", ",", "weight_score", ",", "no_match", ",", "j", "+", "add_to_index", ",", "i", "+", "add_to_index2", ")", "\n", "weight_dict", "=", "add_node_pairs", "(", "node_pair_new2", ",", "node_pair_new1", ",", "node_pair_new3", ",", "weight_dict", ",", "weight_score", ",", "no_match", ",", "j", "+", "add_to_index", ",", "i", "+", "add_to_index2", ")", "\n", "weight_dict", "=", "add_node_pairs", "(", "node_pair_new3", ",", "node_pair_new1", ",", "node_pair_new2", ",", "weight_dict", ",", "weight_score", ",", "no_match", ",", "j", "+", "add_to_index", ",", "i", "+", "add_to_index2", ")", "\n", "\n", "", "", "", "else", ":", "\n", "# Do partial matching", "\n", "# Check if edge matches", "\n", "\t\t", "if", "same_edge_type_check", "(", "prod_clauses", "[", "i", "]", "[", "edge_index", "]", ",", "gold_clauses", "[", "j", "]", "[", "edge_index", "]", ")", ":", "\n", "\t\t\t", "same_edge_type", "=", "True", "\n", "if", "normalize", "(", "prod_clauses", "[", "i", "]", "[", "edge_index", "]", ")", "==", "normalize", "(", "gold_clauses", "[", "j", "]", "[", "edge_index", "]", ")", ":", "\n", "\t\t\t\t", "edge_match", "=", "1", "/", "float", "(", "4", ")", "\n", "\n", "# Save mapping between the nodes only if edge is of the same type", "\n", "", "", "if", "same_edge_type", ":", "\n", "\n", "# Add match for all variables", "\n", "\t\t\t", "if", "allowed_var1", "and", "allowed_var2", "and", "allowed_var3", ":", "\n", "\t\t\t\t", "candidate_mapping", "[", "node1_index_drs1", "]", ".", "add", "(", "node1_index_drs2", ")", "\n", "candidate_mapping", "[", "node2_index_drs1", "]", ".", "add", "(", "node2_index_drs2", ")", "\n", "candidate_mapping", "[", "node3_index_drs1", "]", ".", "add", "(", "node3_index_drs2", ")", "\n", "no_match", "=", "''", "# empty no_match because all variables already match here", "\n", "weight_score", "=", "3", "/", "float", "(", "4", ")", "+", "edge_match", "\n", "\n", "# add to weight dict here, only do for 1,2 - 1,3 and 2,3", "\n", "weight_dict", "=", "add_node_pairs", "(", "node_pair1", ",", "node_pair2", ",", "node_pair3", ",", "weight_dict", ",", "weight_score", ",", "no_match", ",", "j", "+", "add_to_index", ",", "i", "+", "add_to_index2", ")", "\n", "weight_dict", "=", "add_node_pairs", "(", "node_pair2", ",", "node_pair1", ",", "node_pair3", ",", "weight_dict", ",", "weight_score", ",", "no_match", ",", "j", "+", "add_to_index", ",", "i", "+", "add_to_index2", ")", "\n", "weight_dict", "=", "add_node_pairs", "(", "node_pair3", ",", "node_pair1", ",", "node_pair2", ",", "weight_dict", ",", "weight_score", ",", "no_match", ",", "j", "+", "add_to_index", ",", "i", "+", "add_to_index2", ")", "\n", "\n", "# Partial matches for single variable ##", "\n", "", "if", "allowed_var1", ":", "# add partial match for single variable 1", "\n", "\t\t\t\t", "no_match", "=", "(", "(", "node2_index_drs1", ",", "node2_index_drs2", ")", ",", "(", "node3_index_drs1", ",", "node3_index_drs2", ")", ",", ")", "\n", "candidate_mapping", "[", "node1_index_drs1", "]", ".", "add", "(", "node1_index_drs2", ")", "\n", "weight_score", "=", "1", "/", "float", "(", "4", ")", "+", "edge_match", "\n", "candidate_mapping", ",", "weight_dict", "=", "add_single_var_mapping", "(", "node1_index_drs1", ",", "node1_index_drs2", ",", "\n", "candidate_mapping", ",", "weight_dict", ",", "weight_score", ",", "no_match", ",", "j", "+", "add_to_index", ",", "i", "+", "add_to_index2", ")", "\n", "\n", "", "if", "allowed_var2", ":", "# add partial match for single variable 2", "\n", "\t\t\t\t", "no_match", "=", "(", "(", "node1_index_drs1", ",", "node1_index_drs2", ")", ",", "(", "node3_index_drs1", ",", "node3_index_drs2", ")", ",", ")", "\n", "candidate_mapping", "[", "node2_index_drs1", "]", ".", "add", "(", "node2_index_drs2", ")", "\n", "weight_score", "=", "1", "/", "float", "(", "4", ")", "+", "edge_match", "\n", "candidate_mapping", ",", "weight_dict", "=", "add_single_var_mapping", "(", "node2_index_drs1", ",", "node2_index_drs2", ",", "\n", "candidate_mapping", ",", "weight_dict", ",", "weight_score", ",", "no_match", ",", "j", "+", "add_to_index", ",", "i", "+", "add_to_index2", ")", "\n", "\n", "", "if", "allowed_var3", ":", "# add partial match for single variable 3", "\n", "\t\t\t\t", "no_match", "=", "(", "(", "node1_index_drs1", ",", "node1_index_drs2", ")", ",", "(", "node2_index_drs1", ",", "node2_index_drs2", ")", ",", ")", "\n", "candidate_mapping", "[", "node3_index_drs1", "]", ".", "add", "(", "node3_index_drs2", ")", "\n", "weight_score", "=", "1", "/", "float", "(", "4", ")", "+", "edge_match", "\n", "candidate_mapping", ",", "weight_dict", "=", "add_single_var_mapping", "(", "node3_index_drs1", ",", "node3_index_drs2", ",", "\n", "candidate_mapping", ",", "weight_dict", ",", "weight_score", ",", "no_match", ",", "j", "+", "add_to_index", ",", "i", "+", "add_to_index2", ")", "\n", "\n", "# Partial matches for two variables ##", "\n", "", "if", "allowed_var1", "and", "allowed_var2", ":", "# add partial match for var 1 and 2", "\n", "\t\t\t\t", "no_match", "=", "(", "(", "node3_index_drs1", ",", "node3_index_drs2", ")", ",", ")", "\n", "weight_score", "=", "2", "/", "float", "(", "4", ")", "+", "edge_match", "\n", "candidate_mapping", ",", "weight_dict", "=", "add_candidate_mapping", "(", "candidate_mapping", ",", "weight_dict", ",", "weight_score", ",", "node1_index_drs1", ",", "\n", "node1_index_drs2", ",", "node2_index_drs1", ",", "node2_index_drs2", ",", "no_match", ",", "j", "+", "add_to_index", ",", "i", "+", "add_to_index2", ",", "args", ")", "\n", "\n", "", "if", "allowed_var1", "and", "allowed_var3", ":", "# add partial match for var 1 and 3", "\n", "\t\t\t\t", "no_match", "=", "(", "(", "node2_index_drs1", ",", "node2_index_drs2", ")", ",", ")", "\n", "weight_score", "=", "2", "/", "float", "(", "4", ")", "+", "edge_match", "\n", "candidate_mapping", ",", "weight_dict", "=", "add_candidate_mapping", "(", "candidate_mapping", ",", "weight_dict", ",", "weight_score", ",", "node1_index_drs1", ",", "\n", "node1_index_drs2", ",", "node3_index_drs1", ",", "node3_index_drs2", ",", "no_match", ",", "j", "+", "add_to_index", ",", "i", "+", "add_to_index2", ",", "args", ")", "\n", "\n", "", "if", "allowed_var2", "and", "allowed_var3", ":", "# add partial match for var 2 and 3", "\n", "\t\t\t\t", "no_match", "=", "(", "(", "node1_index_drs1", ",", "node1_index_drs2", ")", ",", ")", "\n", "weight_score", "=", "2", "/", "float", "(", "4", ")", "+", "edge_match", "\n", "candidate_mapping", ",", "weight_dict", "=", "add_candidate_mapping", "(", "candidate_mapping", ",", "weight_dict", ",", "weight_score", ",", "node2_index_drs1", ",", "\n", "node2_index_drs2", ",", "node3_index_drs1", ",", "node3_index_drs2", ",", "no_match", ",", "j", "+", "add_to_index", ",", "i", "+", "add_to_index2", ",", "args", ")", "\n", "\n", "", "", "", "return", "candidate_mapping", ",", "weight_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_candidate_mapping": [[364, 398], ["candidate_mapping[].add", "candidate_mapping[].add", "print", "[].append", "[].append"], "function", ["None"], ["", "def", "add_candidate_mapping", "(", "candidate_mapping", ",", "weight_dict", ",", "weight_score", ",", "node1_index_drs1", ",", "node1_index_drs2", ",", "node2_index_drs1", ",", "node2_index_drs2", ",", "no_match", ",", "gold_clause_idx", ",", "prod_clause_idx", ",", "args", ")", ":", "\n", "\t", "'''Add the candidate mapping for this node pair to the weight dict - for two variables'''", "\n", "\n", "# add mapping between two nodes", "\n", "candidate_mapping", "[", "node1_index_drs1", "]", ".", "add", "(", "node1_index_drs2", ")", "\n", "candidate_mapping", "[", "node2_index_drs1", "]", ".", "add", "(", "node2_index_drs2", ")", "\n", "node_pair1", "=", "(", "node1_index_drs1", ",", "node1_index_drs2", ")", "\n", "node_pair2", "=", "(", "node2_index_drs1", ",", "node2_index_drs2", ")", "\n", "if", "node_pair2", "==", "node_pair1", ":", "\n", "\t\t", "print", "(", "\"WARNING: two nodepairs are the same, should never happen, except when using -ill score\"", ")", "\n", "# update weight_dict weight. Note that we need to update both entries for future search", "\n", "", "if", "node_pair1", "in", "weight_dict", ":", "\n", "\t\t", "if", "node_pair2", "in", "weight_dict", "[", "node_pair1", "]", ":", "\n", "\t\t\t", "weight_dict", "[", "node_pair1", "]", "[", "node_pair2", "]", ".", "append", "(", "\n", "[", "weight_score", ",", "no_match", ",", "gold_clause_idx", ",", "prod_clause_idx", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t", "weight_dict", "[", "node_pair1", "]", "[", "node_pair2", "]", "=", "[", "\n", "[", "weight_score", ",", "no_match", ",", "gold_clause_idx", ",", "prod_clause_idx", "]", "]", "\n", "", "", "else", ":", "\n", "\t\t", "weight_dict", "[", "node_pair1", "]", "=", "{", "}", "\n", "weight_dict", "[", "node_pair1", "]", "[", "node_pair2", "]", "=", "[", "\n", "[", "weight_score", ",", "no_match", ",", "gold_clause_idx", ",", "prod_clause_idx", "]", "]", "\n", "", "if", "node_pair2", "in", "weight_dict", ":", "\n", "\t\t", "if", "node_pair1", "in", "weight_dict", "[", "node_pair2", "]", ":", "\n", "\t\t\t", "weight_dict", "[", "node_pair2", "]", "[", "node_pair1", "]", ".", "append", "(", "\n", "[", "weight_score", ",", "no_match", ",", "gold_clause_idx", ",", "prod_clause_idx", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t", "weight_dict", "[", "node_pair2", "]", "[", "node_pair1", "]", "=", "[", "\n", "[", "weight_score", ",", "no_match", ",", "gold_clause_idx", ",", "prod_clause_idx", "]", "]", "\n", "", "", "else", ":", "\n", "\t\t", "weight_dict", "[", "node_pair2", "]", "=", "{", "}", "\n", "weight_dict", "[", "node_pair2", "]", "[", "node_pair1", "]", "=", "[", "\n", "[", "weight_score", ",", "no_match", ",", "gold_clause_idx", ",", "prod_clause_idx", "]", "]", "\n", "", "return", "candidate_mapping", ",", "weight_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.same_edge_type_check": [[400, 414], ["edge1.isupper", "edge2.isupper", "edge1[].isupper", "edge1[].islower", "edge2[].isupper", "edge2[].islower", "edge1.islower", "edge2.islower"], "function", ["None"], ["", "def", "same_edge_type_check", "(", "edge1", ",", "edge2", ")", ":", "\n", "\t", "'''Check if two edges are of the same type (concepts, roles, operators)\n\t   Roles: Agent, Theme\n\t   concepts: verb\n\t   operators: REF, EQU'''", "\n", "\n", "if", "edge1", ".", "isupper", "(", ")", "and", "edge2", ".", "isupper", "(", ")", ":", "# operator", "\n", "\t\t", "return", "True", "\n", "", "elif", "edge1", "[", "0", "]", ".", "isupper", "(", ")", "and", "edge1", "[", "1", ":", "]", ".", "islower", "(", ")", "and", "edge2", "[", "0", "]", ".", "isupper", "(", ")", "and", "edge2", "[", "1", ":", "]", ".", "islower", "(", ")", ":", "# role", "\n", "\t\t", "return", "True", "\n", "", "elif", "edge1", ".", "islower", "(", ")", "and", "edge2", ".", "islower", "(", ")", ":", "# concept", "\n", "\t\t", "return", "True", "\n", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_single_var_mapping": [[416, 435], ["candidate_mapping[].add", "[].append"], "function", ["None"], ["", "def", "add_single_var_mapping", "(", "node1_index", ",", "node2_index", ",", "candidate_mapping", ",", "weight_dict", ",", "weight_score", ",", "no_match", ",", "gold_clause_idx", ",", "prod_clause_idx", ")", ":", "\n", "\t", "'''Add to the weight dictionary the result for a single variable match (e.g. x1 to x4)\n\t   Since we might do partial matching we have a [weight_score] to add to the dictionary, between 0 and 1\n\t   For some clauses this means that we only return the score if one other set of nodes does NOT match'''", "\n", "\n", "candidate_mapping", "[", "node1_index", "]", ".", "add", "(", "node2_index", ")", "\n", "node_pair", "=", "(", "node1_index", ",", "node2_index", ")", "\n", "# use -1 as key in weight_dict for single variable mappings", "\n", "if", "node_pair", "in", "weight_dict", ":", "\n", "\t\t", "if", "-", "1", "in", "weight_dict", "[", "node_pair", "]", ":", "\n", "\t\t\t", "weight_dict", "[", "node_pair", "]", "[", "-", "1", "]", ".", "append", "(", "\n", "[", "weight_score", ",", "no_match", ",", "gold_clause_idx", ",", "prod_clause_idx", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t", "weight_dict", "[", "node_pair", "]", "[", "-", "1", "]", "=", "[", "[", "weight_score", ",", "no_match", ",", "gold_clause_idx", ",", "prod_clause_idx", "]", "]", "\n", "", "", "else", ":", "\n", "\t\t", "weight_dict", "[", "node_pair", "]", "=", "{", "}", "\n", "weight_dict", "[", "node_pair", "]", "[", "-", "1", "]", "=", "[", "[", "weight_score", ",", "no_match", ",", "gold_clause_idx", ",", "prod_clause_idx", "]", "]", "\n", "\n", "", "return", "candidate_mapping", ",", "weight_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.map_two_vars_edges": [[437, 517], ["range", "len", "range", "len", "int", "int", "int", "int", "hill_climbing.same_edge_type_check", "hill_climbing.add_candidate_mapping", "len", "hill_climbing.add_single_var_mapping", "hill_climbing.add_single_var_mapping", "hill_climbing.add_candidate_mapping", "len", "len", "len", "len", "len", "hill_climbing.normalize", "hill_climbing.normalize", "hill_climbing.normalize", "hill_climbing.normalize", "hill_climbing.normalize", "hill_climbing.normalize", "int", "int", "int", "int", "hill_climbing.normalize", "hill_climbing.normalize", "float", "float", "int", "int", "int", "int", "len", "len", "float", "float", "float", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.same_edge_type_check", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_candidate_mapping", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_single_var_mapping", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_single_var_mapping", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_candidate_mapping", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize"], ["", "def", "map_two_vars_edges", "(", "clauses_prod", ",", "clauses_gold", ",", "prod_drs", ",", "gold_drs", ",", "edge_numbers", ",", "candidate_mapping", ",", "weight_dict", ",", "var_index1", ",", "var_index2", ",", "add_to_index", ",", "add_to_index2", ",", "args", ")", ":", "\n", "\t", "'''Function that updates weight_dict and candidate mappings for clauses with 2 variable and 1 or 2 edges\n\t   clause looks like: (var1, edge, var2) or (var1, edge, var2, \"constant\") or (var1, edge, \"constant\", var2)'''", "\n", "\n", "# Make things a bit more readable", "\n", "prefix1", "=", "prod_drs", ".", "prefix", "\n", "prefix2", "=", "gold_drs", ".", "prefix", "\n", "\n", "# Try different mappings", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "clauses_prod", ")", ")", ":", "\n", "\t\t", "for", "j", "in", "range", "(", "0", ",", "len", "(", "clauses_gold", ")", ")", ":", "\n", "# Set values to make things a bit easier", "\n", "\t\t\t", "node1_index_drs1", "=", "int", "(", "clauses_prod", "[", "i", "]", "[", "var_index1", "]", "[", "len", "(", "prefix1", ")", ":", "]", ")", "\n", "node1_index_drs2", "=", "int", "(", "clauses_gold", "[", "j", "]", "[", "var_index1", "]", "[", "len", "(", "prefix2", ")", ":", "]", ")", "\n", "node2_index_drs1", "=", "int", "(", "clauses_prod", "[", "i", "]", "[", "var_index2", "]", "[", "len", "(", "prefix1", ")", ":", "]", ")", "\n", "node2_index_drs2", "=", "int", "(", "clauses_gold", "[", "j", "]", "[", "var_index2", "]", "[", "len", "(", "prefix2", ")", ":", "]", ")", "\n", "\n", "# Set other params", "\n", "allowed_var1", ",", "allowed_var2", ",", "same_edge_type", "=", "False", ",", "False", ",", "False", "\n", "edge_match", ",", "const_match", "=", "0", ",", "0", "# default is no match", "\n", "\n", "# First check if nodes are even allowed to match, based on the type", "\n", "# of the variables (e.g. b1 can never match to x1)", "\n", "if", "prod_drs", ".", "type_vars", "[", "clauses_prod", "[", "i", "]", "[", "var_index1", "]", "]", "==", "gold_drs", ".", "type_vars", "[", "clauses_gold", "[", "j", "]", "[", "var_index1", "]", "]", ":", "\n", "\t\t\t\t", "allowed_var1", "=", "True", "\n", "", "if", "prod_drs", ".", "type_vars", "[", "clauses_prod", "[", "i", "]", "[", "var_index2", "]", "]", "==", "gold_drs", ".", "type_vars", "[", "clauses_gold", "[", "j", "]", "[", "var_index2", "]", "]", ":", "\n", "\t\t\t\t", "allowed_var2", "=", "True", "\n", "\n", "# Then do the (partial) matching", "\n", "", "if", "not", "args", ".", "partial", ":", "\n", "# If there is more than 1 edge number, it should match, else it is allowed anyway", "\n", "\t\t\t\t", "if", "len", "(", "edge_numbers", ")", ">", "1", "and", "not", "normalize", "(", "clauses_prod", "[", "i", "]", "[", "edge_numbers", "[", "1", "]", "]", ")", "==", "normalize", "(", "clauses_gold", "[", "j", "]", "[", "edge_numbers", "[", "1", "]", "]", ")", ":", "\n", "\t\t\t\t\t", "allowed_edge", "=", "False", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "allowed_edge", "=", "True", "\n", "\n", "# We do not do partial matching, normal case -- everything should match", "\n", "", "if", "allowed_var1", "and", "allowed_var2", "and", "allowed_edge", "and", "normalize", "(", "clauses_prod", "[", "i", "]", "[", "edge_numbers", "[", "0", "]", "]", ")", "==", "normalize", "(", "clauses_gold", "[", "j", "]", "[", "edge_numbers", "[", "0", "]", "]", ")", ":", "\n", "\t\t\t\t\t", "weight_score", "=", "1", "# clause matches for 1", "\n", "no_match", "=", "''", "# since we do not partial matching no_match is empty", "\n", "candidate_mapping", ",", "weight_dict", "=", "add_candidate_mapping", "(", "candidate_mapping", ",", "weight_dict", ",", "weight_score", ",", "node1_index_drs1", ",", "node1_index_drs2", ",", "\n", "node2_index_drs1", ",", "node2_index_drs2", ",", "no_match", ",", "j", "+", "add_to_index", ",", "i", "+", "add_to_index2", ",", "args", ")", "\n", "", "", "else", ":", "\n", "# Do partial matching", "\n", "# Check if edge is of the same type (e.g. both concepts, both roles, both operators)", "\n", "\t\t\t\t", "if", "same_edge_type_check", "(", "clauses_prod", "[", "i", "]", "[", "edge_numbers", "[", "0", "]", "]", ",", "clauses_gold", "[", "j", "]", "[", "edge_numbers", "[", "0", "]", "]", ")", ":", "\n", "\t\t\t\t\t", "same_edge_type", "=", "True", "\n", "# Clause of the same type can always partially match, but", "\n", "# we have to check if they share the same concept/role, if", "\n", "# they do we add a higher value", "\n", "if", "normalize", "(", "clauses_prod", "[", "i", "]", "[", "edge_numbers", "[", "0", "]", "]", ")", "==", "normalize", "(", "clauses_gold", "[", "j", "]", "[", "edge_numbers", "[", "0", "]", "]", ")", ":", "\n", "\t\t\t\t\t\t", "edge_match", "=", "1", "/", "float", "(", "len", "(", "clauses_prod", "[", "0", "]", ")", ")", "# edge match results in an increase of 0.25 or 0.33", "\n", "\n", "", "", "if", "len", "(", "edge_numbers", ")", ">", "1", ":", "# also a constant", "\n", "\t\t\t\t\t", "if", "normalize", "(", "clauses_prod", "[", "i", "]", "[", "edge_numbers", "[", "1", "]", "]", ")", "==", "normalize", "(", "clauses_gold", "[", "j", "]", "[", "edge_numbers", "[", "1", "]", "]", ")", ":", "\n", "\t\t\t\t\t\t", "const_match", "=", "1", "/", "float", "(", "len", "(", "clauses_prod", "[", "0", "]", ")", ")", "# const match results in an increase of 0.25 or 0.33", "\n", "\n", "# Actually update the weight dictionary here", "\n", "", "", "if", "allowed_var1", "and", "same_edge_type", ":", "# add for single variable match", "\n", "\n", "# Add that other node pair can not match if we do this", "\n", "# single partial matching", "\n", "\t\t\t\t\t", "no_match", "=", "(", "(", "int", "(", "clauses_prod", "[", "i", "]", "[", "var_index2", "]", "[", "1", ":", "]", ")", ",", "int", "(", "clauses_gold", "[", "j", "]", "[", "var_index2", "]", "[", "1", ":", "]", ")", ")", ",", ")", "\n", "weight_score", "=", "1", "/", "float", "(", "len", "(", "clauses_prod", "[", "0", "]", ")", ")", "+", "edge_match", "+", "const_match", "\n", "candidate_mapping", ",", "weight_dict", "=", "add_single_var_mapping", "(", "int", "(", "clauses_prod", "[", "i", "]", "[", "var_index1", "]", "[", "1", ":", "]", ")", ",", "int", "(", "clauses_gold", "[", "j", "]", "[", "var_index1", "]", "[", "1", ":", "]", ")", ",", "candidate_mapping", ",", "weight_dict", ",", "weight_score", ",", "no_match", ",", "j", "+", "add_to_index", ",", "i", "+", "add_to_index2", ")", "\n", "\n", "", "if", "allowed_var2", "and", "same_edge_type", ":", "# add for single variable match", "\n", "# Add that var1 can not match if we do this single partial matching", "\n", "\t\t\t\t\t", "no_match", "=", "(", "(", "int", "(", "clauses_prod", "[", "i", "]", "[", "var_index1", "]", "[", "1", ":", "]", ")", ",", "int", "(", "clauses_gold", "[", "j", "]", "[", "var_index1", "]", "[", "1", ":", "]", ")", ")", ",", ")", "\n", "weight_score", "=", "1", "/", "float", "(", "len", "(", "clauses_prod", "[", "0", "]", ")", ")", "+", "edge_match", "+", "const_match", "\n", "candidate_mapping", ",", "weight_dict", "=", "add_single_var_mapping", "(", "int", "(", "clauses_prod", "[", "i", "]", "[", "var_index2", "]", "[", "1", ":", "]", ")", ",", "int", "(", "clauses_gold", "[", "j", "]", "[", "var_index2", "]", "[", "1", ":", "]", ")", ",", "candidate_mapping", ",", "weight_dict", ",", "weight_score", ",", "no_match", ",", "j", "+", "add_to_index", ",", "i", "+", "add_to_index2", ")", "\n", "\n", "# Add for two variables that have to match  - no match is empty", "\n", "# since we only have two variables here", "\n", "", "if", "allowed_var1", "and", "allowed_var1", "and", "same_edge_type", ":", "\n", "\t\t\t\t\t", "no_match", "=", "''", "\n", "weight_score", "=", "2", "/", "float", "(", "len", "(", "clauses_prod", "[", "0", "]", ")", ")", "+", "edge_match", "+", "const_match", "\n", "candidate_mapping", ",", "weight_dict", "=", "add_candidate_mapping", "(", "candidate_mapping", ",", "weight_dict", ",", "weight_score", ",", "node1_index_drs1", ",", "node1_index_drs2", ",", "node2_index_drs1", ",", "node2_index_drs2", ",", "no_match", ",", "j", "+", "add_to_index", ",", "i", "+", "add_to_index2", ",", "args", ")", "\n", "\n", "", "", "", "", "return", "candidate_mapping", ",", "weight_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_mapping_role_two_abs": [[519, 561], ["range", "len", "range", "len", "int", "int", "candidate_mapping[].add", "int", "int", "candidate_mapping[].add", "len", "hill_climbing.normalize", "hill_climbing.normalize", "hill_climbing.normalize", "hill_climbing.normalize", "hill_climbing.normalize", "hill_climbing.normalize", "hill_climbing.normalize", "hill_climbing.normalize", "hill_climbing.normalize", "hill_climbing.normalize", "hill_climbing.normalize", "hill_climbing.normalize", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.normalize"], ["", "def", "add_mapping_role_two_abs", "(", "prod_drs", ",", "gold_drs", ",", "weight_dict", ",", "candidate_mapping", ",", "add_to_index_gold", ",", "add_to_index_prod", ",", "args", ")", ":", "\n", "\t", "'''Add a candidate mapping for a role clause with two constant items\n\t   Clause looks like: b1 Role \"item1\" \"item2\" '''", "\n", "minus_count", "=", "-", "1", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "prod_drs", ".", "roles_two_abs", ")", ")", ":", "\n", "\t\t", "for", "j", "in", "range", "(", "0", ",", "len", "(", "gold_drs", ".", "roles_two_abs", ")", ")", ":", "\n", "\t\t\t", "var_index", "=", "0", "\n", "if", "not", "args", ".", "partial", ":", "\n", "# Check if all the other values match (Role, \"item1\", \"item2\")", "\n", "\t\t\t\t", "if", "normalize", "(", "prod_drs", ".", "roles_two_abs", "[", "i", "]", "[", "1", "]", ")", "==", "normalize", "(", "gold_drs", ".", "roles_two_abs", "[", "j", "]", "[", "1", "]", ")", "and", "normalize", "(", "prod_drs", ".", "roles_two_abs", "[", "i", "]", "[", "2", "]", ")", "==", "normalize", "(", "gold_drs", ".", "roles_two_abs", "[", "j", "]", "[", "2", "]", ")", "and", "normalize", "(", "prod_drs", ".", "roles_two_abs", "[", "i", "]", "[", "3", "]", ")", "==", "normalize", "(", "gold_drs", ".", "roles_two_abs", "[", "j", "]", "[", "3", "]", ")", ":", "\n", "# We have a match here, add mapping and weights", "\n", "\t\t\t\t\t", "node1_index", "=", "int", "(", "prod_drs", ".", "roles_two_abs", "[", "i", "]", "[", "var_index", "]", "[", "len", "(", "prod_drs", ".", "prefix", ")", ":", "]", ")", "\n", "node2_index", "=", "int", "(", "gold_drs", ".", "roles_two_abs", "[", "j", "]", "[", "var_index", "]", "[", "len", "(", "gold_drs", ".", "prefix", ")", ":", "]", ")", "\n", "candidate_mapping", "[", "node1_index", "]", ".", "add", "(", "node2_index", ")", "\n", "node_pair", "=", "(", "node1_index", ",", "node2_index", ")", "\n", "# use a minus count as key in weight_dict for roles_two_abs", "\n", "if", "node_pair", "not", "in", "weight_dict", ":", "\n", "\t\t\t\t\t\t", "weight_dict", "[", "node_pair", "]", "=", "{", "}", "\n", "", "weight_dict", "[", "node_pair", "]", "[", "minus_count", "]", "=", "[", "[", "1", ",", "''", ",", "add_to_index_gold", "+", "j", ",", "add_to_index_prod", "+", "i", "]", "]", "\n", "minus_count", "-=", "1", "\n", "# Do partial matching here", "\n", "", "", "else", ":", "\n", "\t\t\t\t", "partial_value", "=", "1", "/", "len", "(", "prod_drs", ".", "roles_two_abs", "[", "0", "]", ")", "\n", "total_match", "=", "partial_value", "\n", "# Update partial matching score if one of the absolute values match", "\n", "if", "normalize", "(", "prod_drs", ".", "roles_two_abs", "[", "i", "]", "[", "1", "]", ")", "==", "normalize", "(", "gold_drs", ".", "roles_two_abs", "[", "j", "]", "[", "1", "]", ")", ":", "\n", "\t\t\t\t\t", "total_match", "+=", "partial_value", "\n", "", "if", "normalize", "(", "prod_drs", ".", "roles_two_abs", "[", "i", "]", "[", "2", "]", ")", "==", "normalize", "(", "gold_drs", ".", "roles_two_abs", "[", "j", "]", "[", "2", "]", ")", ":", "\n", "\t\t\t\t\t", "total_match", "+=", "partial_value", "\n", "", "if", "normalize", "(", "prod_drs", ".", "roles_two_abs", "[", "i", "]", "[", "3", "]", ")", "==", "normalize", "(", "gold_drs", ".", "roles_two_abs", "[", "j", "]", "[", "3", "]", ")", ":", "\n", "\t\t\t\t\t", "total_match", "+=", "partial_value", "\n", "# We have a match here, add mapping and weights", "\n", "", "node1_index", "=", "int", "(", "prod_drs", ".", "roles_two_abs", "[", "i", "]", "[", "var_index", "]", "[", "len", "(", "prod_drs", ".", "prefix", ")", ":", "]", ")", "\n", "node2_index", "=", "int", "(", "gold_drs", ".", "roles_two_abs", "[", "j", "]", "[", "var_index", "]", "[", "len", "(", "gold_drs", ".", "prefix", ")", ":", "]", ")", "\n", "candidate_mapping", "[", "node1_index", "]", ".", "add", "(", "node2_index", ")", "\n", "node_pair", "=", "(", "node1_index", ",", "node2_index", ")", "\n", "# Update weight dictionary here", "\n", "if", "node_pair", "not", "in", "weight_dict", ":", "\n", "\t\t\t\t\t", "weight_dict", "[", "node_pair", "]", "=", "{", "}", "\n", "", "weight_dict", "[", "node_pair", "]", "[", "minus_count", "]", "=", "[", "total_match", ",", "''", ",", "add_to_index_gold", "+", "j", ",", "add_to_index_prod", "+", "i", "]", "\n", "minus_count", "-=", "1", "\n", "", "", "", "return", "candidate_mapping", ",", "weight_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.compute_pool": [[563, 622], ["range", "hill_climbing.map_two_vars_edges", "hill_climbing.map_two_vars_edges", "hill_climbing.map_two_vars_edges", "range", "hill_climbing.add_mapping_role_two_abs", "hill_climbing.map_two_vars_edges", "hill_climbing.map_two_vars_edges", "range", "hill_climbing.map_two_vars_edges", "len", "candidate_mapping.append", "len", "len", "len", "range", "len", "range", "set", "len", "len", "len", "len", "len", "hill_climbing.add_candidate_mapping_three_vars", "len", "len", "len", "len", "len", "len", "len", "hill_climbing.add_candidate_mapping_three_vars", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.map_two_vars_edges", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.map_two_vars_edges", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.map_two_vars_edges", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_mapping_role_two_abs", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.map_two_vars_edges", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.map_two_vars_edges", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.map_two_vars_edges", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_candidate_mapping_three_vars", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.add_candidate_mapping_three_vars"], ["", "def", "compute_pool", "(", "prod_drs", ",", "gold_drs", ",", "args", ")", ":", "\n", "\t", "\"\"\"\n\tcompute all possible node mapping candidates and their weights (the clause matching number gain resulting from\n\tmapping one node in DRS 1 to another node in DRS2)\n\n\tArguments:\n\t\tprod_drs: Object with all information of the produced DRS\n\t\tgold_drs: Object with all informtation of the gold DRS\n\tReturns:\n\t  candidate_mapping: a list of candidate nodes.\n\t\t\t\t\t   The ith element contains the node indices (in DRS 2) the ith node (in DRS 1) can map to.\n\t\t\t\t\t   (resulting in non-zero clause match)\n\t  weight_dict: a dictionary which contains the matching clause number for every pair of node mapping. The key\n\t\t\t\t   is a node pair. The value is another dictionary. Key {-1} is clause match resulting from this node\n\t\t\t\t   pair alone, and other keys are node pairs that can result\n\t\t\t\t   in relation clause match together with the first node pair.\n\n\n\t\"\"\"", "\n", "candidate_mapping", "=", "[", "]", "\n", "weight_dict", "=", "{", "}", "\n", "\n", "# Add as much candidate mappings as we have variables", "\n", "for", "i", "in", "range", "(", "len", "(", "prod_drs", ".", "var_map", ")", ")", ":", "\n", "\t\t", "candidate_mapping", ".", "append", "(", "set", "(", ")", ")", "\n", "\n", "# Adding mappings for all types of clause that have two variables", "\n", "# Clause looks like (var1, OPR, var2)", "\n", "", "var_spot1", ",", "var_spot2", ",", "count_clauses_prod", ",", "count_clauses_gold", "=", "0", ",", "2", ",", "0", ",", "0", "\n", "edge_nums", "=", "[", "1", "]", "\n", "candidate_mapping", ",", "weight_dict", "=", "map_two_vars_edges", "(", "prod_drs", ".", "op_two_vars", ",", "gold_drs", ".", "op_two_vars", ",", "prod_drs", ",", "gold_drs", ",", "edge_nums", ",", "candidate_mapping", ",", "weight_dict", ",", "var_spot1", ",", "var_spot2", ",", "count_clauses_prod", ",", "count_clauses_gold", ",", "args", ")", "\n", "\n", "# Clause looks like (var1, OPR, \"item\", var2)", "\n", "candidate_mapping", ",", "weight_dict", "=", "map_two_vars_edges", "(", "prod_drs", ".", "op_two_vars_abs1", ",", "gold_drs", ".", "op_two_vars_abs1", ",", "prod_drs", ",", "gold_drs", ",", "[", "1", ",", "2", "]", ",", "candidate_mapping", ",", "weight_dict", ",", "0", ",", "3", ",", "len", "(", "gold_drs", ".", "op_two_vars", ")", ",", "len", "(", "prod_drs", ".", "op_two_vars", ")", ",", "args", ")", "\n", "\n", "# Clause looks like (var1, OPR, var2, \"item\")", "\n", "candidate_mapping", ",", "weight_dict", "=", "map_two_vars_edges", "(", "prod_drs", ".", "op_two_vars_abs2", ",", "gold_drs", ".", "op_two_vars_abs2", ",", "prod_drs", ",", "gold_drs", ",", "[", "1", ",", "3", "]", ",", "candidate_mapping", ",", "weight_dict", ",", "0", ",", "2", ",", "len", "(", "gold_drs", ".", "op_two_vars", ")", "+", "len", "(", "gold_drs", ".", "op_two_vars_abs1", ")", ",", "len", "(", "prod_drs", ".", "op_two_vars", ")", "+", "len", "(", "prod_drs", ".", "op_two_vars_abs1", ")", ",", "args", ")", "\n", "\n", "# Clause looks like (var1, OPR, var2, var3)", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "prod_drs", ".", "op_three_vars", ")", ")", ":", "\n", "\t\t", "for", "j", "in", "range", "(", "0", ",", "len", "(", "gold_drs", ".", "op_three_vars", ")", ")", ":", "\n", "\t\t\t", "candidate_mapping", ",", "weight_dict", "=", "add_candidate_mapping_three_vars", "(", "prod_drs", ".", "op_three_vars", ",", "gold_drs", ".", "op_three_vars", ",", "prod_drs", ",", "gold_drs", ",", "candidate_mapping", ",", "weight_dict", ",", "i", ",", "j", ",", "len", "(", "gold_drs", ".", "op_two_vars", ")", "+", "len", "(", "gold_drs", ".", "op_two_vars_abs1", ")", "+", "len", "(", "gold_drs", ".", "op_two_vars_abs2", ")", ",", "len", "(", "prod_drs", ".", "op_two_vars", ")", "+", "len", "(", "prod_drs", ".", "op_two_vars_abs1", ")", "+", "len", "(", "prod_drs", ".", "op_two_vars_abs2", ")", ",", "args", ")", "\n", "\n", "# Clause looks like (var1, Role, \"item1\", \"item2\")", "\n", "", "", "candidate_mapping", ",", "weight_dict", "=", "add_mapping_role_two_abs", "(", "prod_drs", ",", "gold_drs", ",", "weight_dict", ",", "candidate_mapping", ",", "len", "(", "gold_drs", ".", "op_two_vars", ")", "+", "len", "(", "gold_drs", ".", "op_two_vars_abs1", ")", "+", "len", "(", "gold_drs", ".", "op_two_vars_abs2", ")", "+", "len", "(", "gold_drs", ".", "op_three_vars", ")", ",", "len", "(", "prod_drs", ".", "op_two_vars", ")", "+", "len", "(", "prod_drs", ".", "op_two_vars_abs1", ")", "+", "len", "(", "prod_drs", ".", "op_two_vars_abs2", ")", "+", "len", "(", "prod_drs", ".", "op_three_vars", ")", ",", "args", ")", "\n", "\n", "# Clause looks liks (var1, Role, \"item\", var2)", "\n", "candidate_mapping", ",", "weight_dict", "=", "map_two_vars_edges", "(", "prod_drs", ".", "roles_abs1", ",", "gold_drs", ".", "roles_abs1", ",", "prod_drs", ",", "gold_drs", ",", "[", "1", ",", "2", "]", ",", "candidate_mapping", ",", "weight_dict", ",", "0", ",", "3", ",", "len", "(", "gold_drs", ".", "op_two_vars", ")", "+", "len", "(", "gold_drs", ".", "op_two_vars_abs1", ")", "+", "len", "(", "gold_drs", ".", "op_two_vars_abs2", ")", "+", "len", "(", "gold_drs", ".", "op_three_vars", ")", "+", "len", "(", "gold_drs", ".", "roles_two_abs", ")", ",", "len", "(", "prod_drs", ".", "op_two_vars", ")", "+", "len", "(", "prod_drs", ".", "op_two_vars_abs1", ")", "+", "len", "(", "prod_drs", ".", "op_two_vars_abs2", ")", "+", "len", "(", "prod_drs", ".", "op_three_vars", ")", "+", "len", "(", "prod_drs", ".", "roles_two_abs", ")", ",", "args", ")", "\n", "\n", "# Clause looks like (var1, Role, var2, \"item\")", "\n", "candidate_mapping", ",", "weight_dict", "=", "map_two_vars_edges", "(", "prod_drs", ".", "roles_abs2", ",", "gold_drs", ".", "roles_abs2", ",", "prod_drs", ",", "gold_drs", ",", "[", "1", ",", "3", "]", ",", "candidate_mapping", ",", "weight_dict", ",", "0", ",", "2", ",", "len", "(", "gold_drs", ".", "op_two_vars", ")", "+", "len", "(", "gold_drs", ".", "op_two_vars_abs1", ")", "+", "len", "(", "gold_drs", ".", "op_two_vars_abs2", ")", "+", "len", "(", "gold_drs", ".", "op_three_vars", ")", "+", "len", "(", "gold_drs", ".", "roles_two_abs", ")", "+", "len", "(", "gold_drs", ".", "roles_abs1", ")", ",", "len", "(", "prod_drs", ".", "op_two_vars", ")", "+", "len", "(", "prod_drs", ".", "op_two_vars_abs1", ")", "+", "len", "(", "prod_drs", ".", "op_two_vars_abs2", ")", "+", "len", "(", "prod_drs", ".", "op_three_vars", ")", "+", "len", "(", "prod_drs", ".", "roles_two_abs", ")", "+", "len", "(", "prod_drs", ".", "roles_abs1", ")", ",", "args", ")", "\n", "# Clause looks like (var1, Role, var2, var3)", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "prod_drs", ".", "roles", ")", ")", ":", "\n", "\t\t", "for", "j", "in", "range", "(", "0", ",", "len", "(", "gold_drs", ".", "roles", ")", ")", ":", "\n", "\t\t\t", "candidate_mapping", ",", "weight_dict", "=", "add_candidate_mapping_three_vars", "(", "prod_drs", ".", "roles", ",", "gold_drs", ".", "roles", ",", "prod_drs", ",", "gold_drs", ",", "candidate_mapping", ",", "weight_dict", ",", "i", ",", "j", ",", "len", "(", "gold_drs", ".", "op_two_vars", ")", "+", "len", "(", "gold_drs", ".", "op_two_vars_abs1", ")", "+", "len", "(", "gold_drs", ".", "op_two_vars_abs2", ")", "+", "len", "(", "gold_drs", ".", "roles_two_abs", ")", "+", "len", "(", "gold_drs", ".", "roles_abs1", ")", "+", "len", "(", "gold_drs", ".", "roles_abs2", ")", "+", "len", "(", "gold_drs", ".", "op_three_vars", ")", ",", "len", "(", "prod_drs", ".", "op_two_vars", ")", "+", "len", "(", "prod_drs", ".", "op_two_vars_abs1", ")", "+", "len", "(", "prod_drs", ".", "op_two_vars_abs2", ")", "+", "len", "(", "prod_drs", ".", "roles_two_abs", ")", "+", "len", "(", "prod_drs", ".", "roles_abs1", ")", "+", "len", "(", "prod_drs", ".", "roles_abs2", ")", "+", "len", "(", "prod_drs", ".", "op_three_vars", ")", ",", "args", ")", "\n", "\n", "# Clause looks like (var1, concept, \"sns\", var2)", "\n", "", "", "candidate_mapping", ",", "weight_dict", "=", "map_two_vars_edges", "(", "prod_drs", ".", "concepts", ",", "gold_drs", ".", "concepts", ",", "prod_drs", ",", "gold_drs", ",", "[", "1", ",", "2", "]", ",", "candidate_mapping", ",", "weight_dict", ",", "0", ",", "3", ",", "len", "(", "gold_drs", ".", "op_two_vars", ")", "+", "len", "(", "gold_drs", ".", "op_two_vars_abs1", ")", "+", "len", "(", "gold_drs", ".", "op_two_vars_abs2", ")", "+", "len", "(", "gold_drs", ".", "roles_two_abs", ")", "+", "len", "(", "gold_drs", ".", "roles_abs1", ")", "+", "len", "(", "gold_drs", ".", "roles_abs2", ")", "+", "len", "(", "gold_drs", ".", "op_three_vars", ")", "+", "len", "(", "gold_drs", ".", "roles", ")", ",", "len", "(", "prod_drs", ".", "op_two_vars", ")", "+", "len", "(", "prod_drs", ".", "op_two_vars_abs1", ")", "+", "len", "(", "prod_drs", ".", "op_two_vars_abs2", ")", "+", "len", "(", "prod_drs", ".", "roles_two_abs", ")", "+", "len", "(", "prod_drs", ".", "roles_abs1", ")", "+", "len", "(", "prod_drs", ".", "roles_abs2", ")", "+", "len", "(", "prod_drs", ".", "op_three_vars", ")", "+", "len", "(", "prod_drs", ".", "roles", ")", ",", "args", ")", "\n", "return", "candidate_mapping", ",", "weight_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.get_best_gain": [[625, 713], ["set", "hill_climbing.compute_match", "enumerate", "enumerate", "range", "range", "set.remove", "len", "len", "len", "hill_climbing.compute_match", "len", "len", "hill_climbing.compute_match", "set", "set"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.compute_match", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.compute_match", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.compute_match"], ["", "def", "get_best_gain", "(", "mapping", ",", "candidate_mappings", ",", "weight_dict", ",", "num_vars", ",", "match_clause_dict", ")", ":", "\n", "\t", "\"\"\"\n\tHill-climbing method to return the best gain swap/move can get\n\tArguments:\n\tmapping: current node mapping\n\tcandidate_mappings: the candidates mapping list\n\tweight_dict: the weight dictionary\n\tnum_vars: the number of the nodes in DRG 2\n\tReturns:\n\tthe best gain we can get via swap/move operation\n\t\"\"\"", "\n", "\n", "largest_gain", "=", "0", "\n", "# True: using swap; False: using move", "\n", "use_swap", "=", "False", "\n", "use_move", "=", "False", "\n", "# the node to be moved/swapped", "\n", "node1", "=", "None", "\n", "# store the other node affected. In swap, this other node is the node swapping with node1. In move, this other", "\n", "# node is the node node1 will move to.", "\n", "node2", "=", "None", "\n", "# unmatched nodes in DRG 2", "\n", "unmatched", "=", "set", "(", "range", "(", "0", ",", "num_vars", ")", ")", "\n", "# exclude nodes in current mapping", "\n", "# get unmatched nodes", "\n", "for", "nid", "in", "mapping", ":", "\n", "\t\t", "if", "nid", "in", "unmatched", ":", "\n", "\t\t\t", "unmatched", ".", "remove", "(", "nid", ")", "\n", "\n", "", "", "matches", ",", "match_clause_dict", "=", "compute_match", "(", "mapping", ",", "weight_dict", ",", "match_clause_dict", ")", "\n", "old_match_num", "=", "matches", "#the number of matches we have for our current mapping", "\n", "\n", "## compute move gain ##", "\n", "\n", "for", "i", ",", "nid", "in", "enumerate", "(", "mapping", ")", ":", "\n", "# current node i in DRG 1 maps to node nid in DRG 2", "\n", "\t\t", "for", "nm", "in", "unmatched", ":", "\n", "\t\t\t", "if", "nm", "in", "candidate_mappings", "[", "i", "]", ":", "\n", "# remap i to another unmatched node (move)", "\n", "# (i, m) -> (i, nm)", "\n", "\t\t\t\t", "new_mapping", "=", "mapping", "[", ":", "]", "\n", "new_mapping", "[", "i", "]", "=", "nm", "\n", "## Check if the mapping does not result in a double mapping", "\n", "if", "len", "(", "set", "(", "[", "x", "for", "x", "in", "new_mapping", "if", "x", "!=", "-", "1", "]", ")", ")", "==", "len", "(", "[", "x", "for", "x", "in", "new_mapping", "if", "x", "!=", "-", "1", "]", ")", ":", "\n", "\t\t\t\t\t", "matches", ",", "match_clause_dict", "=", "compute_match", "(", "new_mapping", ",", "weight_dict", ",", "match_clause_dict", ")", "\n", "new_match_num", "=", "matches", "\n", "mv_gain", "=", "new_match_num", "-", "old_match_num", "\n", "\n", "if", "mv_gain", ">", "largest_gain", ":", "#new best gain", "\n", "\t\t\t\t\t\t", "largest_gain", "=", "mv_gain", "\n", "node1", "=", "i", "\n", "node2", "=", "nm", "\n", "use_move", "=", "True", "\n", "\n", "## compute swap gain ##", "\n", "\n", "", "", "", "", "", "for", "i", ",", "m", "in", "enumerate", "(", "mapping", ")", ":", "\n", "\t\t", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "mapping", ")", ")", ":", "\n", "\t\t\t", "m2", "=", "mapping", "[", "j", "]", "\n", "# swap operation (i, m) (j, m2) -> (i, m2) (j, m)", "\n", "# j starts from i+1, to avoid duplicate swap", "\n", "\n", "new_mapping", "=", "mapping", "[", ":", "]", "\n", "new_mapping", "[", "i", "]", "=", "m2", "\n", "new_mapping", "[", "j", "]", "=", "m", "\n", "## Check if the mapping does not result in a double mapping", "\n", "if", "len", "(", "set", "(", "[", "x", "for", "x", "in", "new_mapping", "if", "x", "!=", "-", "1", "]", ")", ")", "==", "len", "(", "[", "x", "for", "x", "in", "new_mapping", "if", "x", "!=", "-", "1", "]", ")", ":", "\n", "\t\t\t\t", "matches", ",", "match_clause_dict", "=", "compute_match", "(", "new_mapping", ",", "weight_dict", ",", "match_clause_dict", ")", "\n", "new_match_num", "=", "matches", "\n", "sw_gain", "=", "new_match_num", "-", "old_match_num", "\n", "\n", "if", "sw_gain", ">", "largest_gain", ":", "#new best swap gain", "\n", "\t\t\t\t\t", "largest_gain", "=", "sw_gain", "\n", "node1", ",", "node2", "=", "i", ",", "j", "\n", "use_swap", "=", "True", "\n", "\n", "# generate a new mapping based on swap/move", "\n", "\n", "", "", "", "", "cur_mapping", "=", "mapping", "[", ":", "]", "\n", "if", "node1", "is", "not", "None", ":", "\n", "\t\t", "if", "use_swap", ":", "\n", "\t\t\t", "temp", "=", "cur_mapping", "[", "node1", "]", "\n", "cur_mapping", "[", "node1", "]", "=", "cur_mapping", "[", "node2", "]", "\n", "cur_mapping", "[", "node2", "]", "=", "temp", "\n", "", "elif", "use_move", ":", "\n", "\t\t\t", "cur_mapping", "[", "node1", "]", "=", "node2", "\n", "\n", "", "", "return", "largest_gain", ",", "cur_mapping", ",", "match_clause_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.compute_match": [[715, 750], ["hill_climbing.DRS_match", "enumerate", "tuple", "hill_climbing.compute_match_for_key", "tuple", "tuple"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.compute_match_for_key"], ["", "def", "compute_match", "(", "mapping", ",", "weight_dict", ",", "match_clause_dict", ",", "final", "=", "False", ")", ":", "\n", "\t", "\"\"\"\n\tGiven a node mapping, compute match number based on weight_dict.\n\tArgs:\n\tmappings: a list of node index in DRG 2. The ith element (value j) means node i in DRG 1 maps to node j in DRG 2.\n\tReturns:\n\tmatching clause number\n\tComplexity: O(m*n) , m is the node number of DRG 1, n is the node number of DRG 2\n\n\t\"\"\"", "\n", "if", "tuple", "(", "mapping", ")", "in", "match_clause_dict", ":", "\n", "\t\t", "return", "match_clause_dict", "[", "tuple", "(", "mapping", ")", "]", ",", "match_clause_dict", "\n", "\n", "# Initialize class to save all information in", "\n", "", "drs_match", "=", "DRS_match", "(", ")", "\n", "drs_match", ".", "mapping", "=", "mapping", "\n", "drs_match", ".", "weight_dict", "=", "weight_dict", "\n", "\n", "for", "i", ",", "m", "in", "enumerate", "(", "drs_match", ".", "mapping", ")", ":", "\n", "\t\t", "if", "m", "==", "-", "1", ":", "\n", "# no node maps to this node", "\n", "\t\t\t", "continue", "\n", "# node i in DRG 1 maps to node m in DRG 2", "\n", "", "current_node_pair", "=", "(", "i", ",", "m", ")", "\n", "if", "current_node_pair", "not", "in", "drs_match", ".", "weight_dict", ":", "\n", "\t\t\t", "continue", "\n", "", "for", "key", "in", "drs_match", ".", "weight_dict", "[", "current_node_pair", "]", ":", "\n", "\t\t\t", "drs_match", "=", "compute_match_for_key", "(", "key", ",", "current_node_pair", ",", "drs_match", ")", "#return number of matches here", "\n", "\n", "# update match_clause_dict", "\n", "", "", "match_clause_dict", "[", "tuple", "(", "mapping", ")", "]", "=", "drs_match", ".", "match_num", "\n", "if", "final", ":", "\n", "\t\t", "return", "drs_match", ".", "match_num", ",", "drs_match", ".", "clause_pairs", "\n", "", "else", ":", "\n", "\t\t", "return", "drs_match", ".", "match_num", ",", "match_clause_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.check_dict_for_adding": [[752, 810], ["float", "to_delete.append", "to_delete.append"], "function", ["None"], ["", "", "def", "check_dict_for_adding", "(", "drs_match", ",", "item", ")", ":", "\n", "\t", "'''Only add value to our score if it is a better match for this clause\n\t   Each gold clause can only (partially) match once'''", "\n", "\n", "if", "item", "[", "2", "]", "in", "drs_match", ".", "clause_dict_gold", "and", "item", "[", "3", "]", "in", "drs_match", ".", "clause_dict_prod", ":", "\n", "#we already have a match for this gold clause AND produced clause, only add if this is a better match in total (and substract previous score)", "\n", "\t\t", "total_gain", "=", "(", "item", "[", "0", "]", "-", "drs_match", ".", "clause_dict_gold", "[", "item", "[", "2", "]", "]", ")", "+", "(", "item", "[", "0", "]", "-", "drs_match", ".", "clause_dict_prod", "[", "item", "[", "3", "]", "]", ")", "\n", "if", "total_gain", ">", "0", ":", "\n", "\t\t\t", "drs_match", ".", "clause_dict_gold", "[", "item", "[", "2", "]", "]", "=", "item", "[", "0", "]", "\n", "drs_match", ".", "clause_dict_prod", "[", "item", "[", "3", "]", "]", "=", "item", "[", "0", "]", "\n", "## Remove and add the items from our clause pairs so that we can easily find the matching parts later", "\n", "drs_match", ".", "clause_pairs", "[", "item", "[", "2", "]", ",", "item", "[", "3", "]", "]", "=", "1", "\n", "drs_match", ".", "match_num", "+=", "(", "float", "(", "total_gain", ")", "/", "2", ")", "#divide by 2 otherwise we add double", "\n", "", "else", ":", "#not an improvement, do nothing", "\n", "\t\t\t", "pass", "\n", "", "", "elif", "item", "[", "2", "]", "in", "drs_match", ".", "clause_dict_gold", ":", "\n", "#only gold item is already in our dict, so check if adding this clause instead gains us something", "\n", "\t\t", "if", "item", "[", "0", "]", ">", "drs_match", ".", "clause_dict_gold", "[", "item", "[", "2", "]", "]", ":", "\n", "\t\t\t", "drs_match", ".", "match_num", "+=", "(", "item", "[", "0", "]", "-", "drs_match", ".", "clause_dict_gold", "[", "item", "[", "2", "]", "]", ")", "\n", "drs_match", ".", "clause_dict_gold", "[", "item", "[", "2", "]", "]", "=", "item", "[", "0", "]", "#keep track of new value", "\n", "## Remove previous gold item from clause pairs (if there) and add new one", "\n", "to_delete", "=", "[", "]", "\n", "for", "key", "in", "drs_match", ".", "clause_pairs", ":", "\n", "\t\t\t\t", "if", "key", "[", "0", "]", "==", "drs_match", ".", "clause_dict_gold", "[", "item", "[", "2", "]", "]", ":", "\n", "\t\t\t\t\t", "to_delete", ".", "append", "(", "key", ")", "\n", "", "", "for", "t", "in", "to_delete", ":", "\n", "\t\t\t\t", "del", "drs_match", ".", "clause_pairs", "[", "t", "]", "\n", "\n", "\n", "", "drs_match", ".", "clause_pairs", "[", "item", "[", "2", "]", ",", "item", "[", "3", "]", "]", "=", "1", "\n", "", "else", ":", "\n", "#this gold clause has already matched and this match is not an improvement, so we do nothing", "\n", "\t\t\t", "pass", "\n", "\n", "", "", "elif", "item", "[", "3", "]", "in", "drs_match", ".", "clause_dict_prod", ":", "\n", "#only prod clause is already matched, check if adding this clause instead gains us something", "\n", "\t\t", "if", "item", "[", "0", "]", ">", "drs_match", ".", "clause_dict_prod", "[", "item", "[", "3", "]", "]", ":", "\n", "\t\t\t", "drs_match", ".", "match_num", "+=", "(", "item", "[", "0", "]", "-", "drs_match", ".", "clause_dict_prod", "[", "item", "[", "3", "]", "]", ")", "\n", "drs_match", ".", "clause_dict_prod", "[", "item", "[", "3", "]", "]", "=", "item", "[", "0", "]", "#keep track of new value", "\n", "\n", "## Remove previous gold item from clause pairs (if there) and add new one", "\n", "to_delete", "=", "[", "]", "\n", "for", "key", "in", "drs_match", ".", "clause_pairs", ":", "\n", "\t\t\t\t", "if", "key", "[", "1", "]", "==", "drs_match", ".", "clause_dict_prod", "[", "item", "[", "3", "]", "]", ":", "\n", "\t\t\t\t\t", "to_delete", ".", "append", "(", "key", ")", "\n", "", "", "for", "t", "in", "to_delete", ":", "\n", "\t\t\t\t", "del", "drs_match", ".", "clause_pairs", "[", "t", "]", "\n", "#clause_pairs[clause_dict_gold[item[2]],clause_dict_prod[item[3]]] = 1", "\n", "", "drs_match", ".", "clause_pairs", "[", "item", "[", "2", "]", ",", "item", "[", "3", "]", "]", "=", "1", "\n", "", "else", ":", "\n", "\t\t\t", "pass", "\n", "", "", "else", ":", "\n", "#this clause hasn't matched yet, just add score and save", "\n", "\t\t", "drs_match", ".", "match_num", "+=", "item", "[", "0", "]", "\n", "drs_match", ".", "clause_dict_gold", "[", "item", "[", "2", "]", "]", "=", "item", "[", "0", "]", "\n", "drs_match", ".", "clause_dict_prod", "[", "item", "[", "3", "]", "]", "=", "item", "[", "0", "]", "\n", "drs_match", ".", "clause_pairs", "[", "item", "[", "2", "]", ",", "item", "[", "3", "]", "]", "=", "1", "\n", "", "return", "drs_match", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.get_matches": [[812, 828], ["hill_climbing.check_dict_for_adding", "hill_climbing.check_dict_for_adding"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.check_dict_for_adding", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.check_dict_for_adding"], ["", "def", "get_matches", "(", "current_node_pair", ",", "key", ",", "drs_match", ")", ":", "\n", "\t", "'''Add specific number, but make sure to only to do that if we are allowed to match (given no match)\n\t   clause_dict_gold contains all gold clauses (by index) that already had a (partial) match\n\t   Have to keep track of this to not match gold clauses for more than 1'''", "\n", "\n", "for", "item", "in", "drs_match", ".", "weight_dict", "[", "current_node_pair", "]", "[", "key", "]", ":", "#item looks like this [score, tuple of node pairs, gold_clause_idx, prod_clause_idx] e.g. [0.75, ((2,4), (3,5)), 4, 6]", "\n", "\t\t", "if", "item", "[", "1", "]", ":", "#sometimes no_match is empty, then just add", "\n", "\t\t\t", "add", "=", "True", "\n", "for", "tup", "in", "item", "[", "1", "]", ":", "#tuple of tuples", "\n", "\t\t\t\t", "if", "drs_match", ".", "mapping", "[", "tup", "[", "0", "]", "]", "==", "tup", "[", "1", "]", ":", "#variable matches while it should not match to add score", "\n", "\t\t\t\t\t", "add", "=", "False", "\n", "", "", "if", "add", ":", "\n", "\t\t\t\t", "drs_match", "=", "check_dict_for_adding", "(", "drs_match", ",", "item", ")", "#only add if this is a better match", "\n", "", "", "else", ":", "\n", "\t\t\t", "drs_match", "=", "check_dict_for_adding", "(", "drs_match", ",", "item", ")", "\n", "", "", "return", "drs_match", "\n", "\n"]], "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.compute_match_for_key": [[830, 859], ["isinstance", "hill_climbing.get_matches", "any", "tuple", "tuple", "sorted", "sorted", "isinstance", "hill_climbing.get_matches", "hill_climbing.get_matches"], "function", ["home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.get_matches", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.get_matches", "home.repos.pwc.inspect_result.verypluming_SyGNS.DRS_parsing.hill_climbing.get_matches"], ["", "def", "compute_match_for_key", "(", "key", ",", "current_node_pair", ",", "drs_match", ")", ":", "\n", "\t", "'''Compute the matches based on the key'''", "\n", "#start with 0 and add when we find matches", "\n", "if", "isinstance", "(", "key", ",", "int", ")", "and", "key", "<", "0", ":", "\n", "# matching clauses resulting from roles_two_abs clauses", "\n", "\t\t", "drs_match", "=", "get_matches", "(", "current_node_pair", ",", "key", ",", "drs_match", ")", "\n", "\n", "", "elif", "not", "any", "(", "isinstance", "(", "inst", ",", "tuple", ")", "for", "inst", "in", "key", ")", ":", "#not a list of tuple but just a tuple", "\n", "# key looks like this: (2,3)", "\n", "\t\t", "sorted_t", "=", "(", "key", ",", ")", "+", "(", "current_node_pair", ",", ")", "\n", "sorted_tuple", "=", "tuple", "(", "sorted", "(", "sorted_t", ",", "key", "=", "lambda", "item", ":", "item", "[", "0", "]", ")", ")", "\n", "\n", "if", "sorted_tuple", "in", "drs_match", ".", "matched_clause_keys", ":", "#already matched, don't do again - e.g. if we matched (0,0),(1,1) we don't want to also match (1,1), (0,0), because they match the same clause", "\n", "\t\t\t", "pass", "\n", "", "elif", "drs_match", ".", "mapping", "[", "key", "[", "0", "]", "]", "==", "key", "[", "1", "]", ":", "#variable matches, check how much we want to add", "\n", "\t\t\t", "drs_match", "=", "get_matches", "(", "current_node_pair", ",", "key", ",", "drs_match", ")", "\n", "drs_match", ".", "matched_clause_keys", "[", "sorted_tuple", "]", "=", "1", "\n", "", "", "else", ":", "\n", "#tuple of tuples here for tuples with 3 variables", "\n", "#key looks like this: ((2,3), (3,4), (4,7))", "\n", "\t\t", "sorted_t", "=", "key", "+", "(", "current_node_pair", ",", ")", "\n", "sorted_tuple", "=", "tuple", "(", "sorted", "(", "sorted_t", ",", "key", "=", "lambda", "item", ":", "item", "[", "0", "]", ")", ")", "\n", "if", "sorted_tuple", "in", "drs_match", ".", "matched_clause_keys", ":", "#already matched, don't do again - e.g. if we matched (0,0),(1,1),(2,2) we don't want to also match (1,1), (0,0),(2,2), because they match the same clause", "\n", "\t\t\t", "pass", "\n", "", "else", ":", "\n", "\t\t\t", "if", "drs_match", ".", "mapping", "[", "key", "[", "0", "]", "[", "0", "]", "]", "==", "key", "[", "0", "]", "[", "1", "]", "and", "drs_match", ".", "mapping", "[", "key", "[", "1", "]", "[", "0", "]", "]", "==", "key", "[", "1", "]", "[", "1", "]", ":", "#both nodes also match", "\n", "\t\t\t\t", "drs_match", "=", "get_matches", "(", "current_node_pair", ",", "key", ",", "drs_match", ")", "\n", "drs_match", ".", "matched_clause_keys", "[", "sorted_tuple", "]", "=", "1", "\n", "", "", "", "return", "drs_match", "\n", "", ""]]}